{"SourceCode": "// SPDX-License-Identifier: MIT\r\n//I WENT TO MIT\r\n\r\npragma solidity ^0.8.18;\r\n\r\ninterface Callable {\r\n    function tokenCallback(address _from, uint256 _tokens, bytes calldata _data) external returns (bool);\r\n}\r\n\r\ninterface ERC20Interface {\r\n    function balanceOf(address) external view returns (uint256);\r\n    function allowance(address, address) external view returns (uint256);\r\n    function transfer(address, uint256) external returns (bool);\r\n    function transferFrom(address, address, uint256) external returns (bool);\r\n}\r\n\r\n\r\nlibrary Math {\r\n    \r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\r\n     * towards zero.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10 ** 64) {\r\n                value /= 10 ** 64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10 ** 32) {\r\n                value /= 10 ** 32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10 ** 16) {\r\n                value /= 10 ** 16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10 ** 8) {\r\n                value /= 10 ** 8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10 ** 4) {\r\n                value /= 10 ** 4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10 ** 2) {\r\n                value /= 10 ** 2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10 ** 1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\r\n    uint8 private constant ADDRESS_LENGTH = 20;\r\n\r\n    /**\r\n     * @dev The `value` string doesn't fit in the specified `length`.\r\n     */\r\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            uint256 length = Math.log10(value) + 1;\r\n            string memory buffer = new string(length);\r\n            uint256 ptr;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                ptr := add(buffer, add(32, length))\r\n            }\r\n            while (true) {\r\n                ptr--;\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\r\n                }\r\n                value /= 10;\r\n                if (value == 0) break;\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Ownable {\r\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\r\n\r\n    error Unauthorized();\r\n    error InvalidOwner();\r\n\r\n    address public owner;\r\n\r\n    modifier onlyOwner() virtual {\r\n        if (msg.sender != owner) revert Unauthorized();\r\n\r\n        _;\r\n    }\r\n\r\n    constructor(address _owner) {\r\n        if (_owner == address(0)) revert InvalidOwner();\r\n\r\n        owner = _owner;\r\n\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    function transferOwnership(address _owner) public virtual onlyOwner {\r\n        if (_owner == address(0)) revert InvalidOwner();\r\n\r\n        owner = _owner;\r\n\r\n        emit OwnershipTransferred(msg.sender, _owner);\r\n    }\r\n\r\n    function revokeOwnership() public virtual onlyOwner {\r\n        owner = address(0);\r\n\r\n        emit OwnershipTransferred(msg.sender, address(0));\r\n    }\r\n}\r\n\r\nabstract contract ERC721Receiver {\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes calldata\r\n    ) external virtual returns (bytes4) {\r\n        return ERC721Receiver.onERC721Received.selector;\r\n    }\r\n}\r\n\r\n/// @notice ERC404\r\n///         A gas-efficient, mixed ERC20 / ERC721 implementation\r\n///         with native liquidity and fractionalization.\r\n///\r\n///         This is an experimental standard designed to integrate\r\n///         with pre-existing ERC20 / ERC721 support as smoothly as\r\n///         possible.\r\n///\r\n/// @dev    In order to support full functionality of ERC20 and ERC721\r\n///         supply assumptions are made that slightly constraint usage.\r\n///         Ensure decimals are sufficiently large (standard 18 recommended)\r\n///         as ids are effectively encoded in the lowest range of amounts.\r\n///\r\n///         NFTs are spent on ERC20 functions in a FILO queue, this is by\r\n///         design.\r\n///\r\nabstract contract ERC404 is Ownable {\r\n    // Events\r\n    event ERC20Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount\r\n    );\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 amount\r\n    );\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed id\r\n    );\r\n    event ERC721Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 indexed id\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    // Errors\r\n    error NotFound();\r\n    error AlreadyExists();\r\n    error InvalidRecipient();\r\n    error InvalidSender();\r\n    error UnsafeRecipient();\r\n\r\n    // Metadata\r\n    /// @dev Token name\r\n    string public name;\r\n\r\n    /// @dev Token symbol\r\n    string public symbol;\r\n\r\n    /// @dev Decimals for fractional representation\r\n    uint8 public immutable decimals;\r\n\r\n    /// @dev Total supply in fractionalized representation\r\n    uint256 public immutable totalSupply;\r\n\r\n    /// @dev Current mint counter, monotonically increasing to ensure accurate ownership\r\n    uint256 public minted;\r\n\r\n    // Mappings\r\n    /// @dev Balance of user in fractional representation\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    /// @dev Allowance of user in fractional representation\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /// @dev Approval in native representaion\r\n    mapping(uint256 => address) public getApproved;\r\n\r\n    /// @dev Approval for all in native representation\r\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\r\n\r\n    /// @dev Owner of id in native representation\r\n    mapping(uint256 => address) internal _ownerOf;\r\n\r\n    /// @dev Array of owned ids in native representation\r\n    mapping(address => uint256[]) private _owned;\r\n    function getLastOwnedTokenId(address owner) internal view returns (uint256) {\r\n        require(_owned[owner].length > 0, \"Owner has no tokens\");\r\n        return _owned[owner][_owned[owner].length - 1];\r\n    }\r\n    function getOwnedTokens(address owner) public view returns(uint[] memory){\r\n        return _owned[owner];\r\n    }\r\n\r\n    /// @dev Tracks indices for the _owned mapping\r\n    mapping(uint256 => uint256) internal _ownedIndex;\r\n\r\n    /// @dev Addresses whitelisted from minting / burning for gas savings (pairs, routers, etc)\r\n    mapping(address => bool) public whitelist;\r\n\r\n    // Constructor\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals,\r\n        uint256 _totalNativeSupply,\r\n        address _owner\r\n    ) Ownable(_owner) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        totalSupply = _totalNativeSupply * (10 ** decimals);\r\n        setWhitelist(_owner,true);\r\n    }\r\n\r\n    /// @notice Initialization function to set pairs / etc\r\n    ///         saving gas by avoiding mint / burn on unnecessary targets\r\n    /// Primarily for backwards compatibility with legacy contracts\r\n    function setWhitelist(address target, bool state) public onlyOwner {\r\n        if(balanceOf[target]==0)\r\n            whitelist[target] = state;\r\n    }\r\n    \r\n    function systemSetWhitelist(address target) internal {\r\n        if(balanceOf[target]==0)\r\n            whitelist[target] = true;\r\n    }\r\n\r\n    /// @notice Allows a user to control if they want to receive NFTs or not\r\n    function setWhitelist(bool state) public {\r\n        address sender = msg.sender;\r\n        if(balanceOf[sender]==0)\r\n            whitelist[sender] = state;\r\n    }\r\n    function setWhitelist() public {\r\n        address sender = msg.sender;\r\n        if(balanceOf[sender]==0)\r\n            whitelist[sender] = !whitelist[sender];\r\n    }\r\n\r\n    /// @notice Function to find owner of a given native token\r\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\r\n        owner = _ownerOf[id];\r\n\r\n        if (owner == address(0)) {\r\n            revert NotFound();\r\n        }\r\n    }\r\n\r\n    /// @notice tokenURI must be implemented by child contract\r\n    function tokenURI(uint256 id) public view virtual returns (string memory);\r\n\r\n    /// @notice Function for token approvals\r\n    /// @dev This function assumes id / native if amount less than or equal to current max id\r\n    function approve(\r\n        address spender,\r\n        uint256 amountOrId\r\n    ) public virtual returns (bool) {\r\n        if (amountOrId <= minted && amountOrId > 0) {\r\n            address owner = _ownerOf[amountOrId];\r\n\r\n            if (msg.sender != owner && !isApprovedForAll[owner][msg.sender]) {\r\n                revert Unauthorized();\r\n            }\r\n\r\n            getApproved[amountOrId] = spender;\r\n\r\n            emit Approval(owner, spender, amountOrId);\r\n        } else {\r\n            allowance[msg.sender][spender] = amountOrId;\r\n\r\n            emit Approval(msg.sender, spender, amountOrId);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Function native approvals\r\n    function setApprovalForAll(address operator, bool approved) public virtual {\r\n        isApprovedForAll[msg.sender][operator] = approved;\r\n\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    /// @notice Function for mixed transfers\r\n    /// @dev This function assumes id / native if amount less than or equal to current max id\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amountOrId\r\n    ) public virtual {\r\n        if (amountOrId <= minted && !whitelist[to]){\r\n            if (from != _ownerOf[amountOrId]) {\r\n                revert InvalidSender();\r\n            }\r\n\r\n            if (to == address(0)) {\r\n                revert InvalidRecipient();\r\n            }\r\n\r\n            if (\r\n                msg.sender != from &&\r\n                !isApprovedForAll[from][msg.sender] &&\r\n                msg.sender != getApproved[amountOrId]\r\n            ){\r\n                revert Unauthorized();\r\n            }\r\n\r\n            balanceOf[from] -= _getUnit();\r\n\r\n            unchecked {\r\n                balanceOf[to] += _getUnit();\r\n            }\r\n\r\n            _ownerOf[amountOrId] = to;\r\n            delete getApproved[amountOrId];\r\n\r\n            // update _owned for sender\r\n            uint256 updatedId = _owned[from][_owned[from].length - 1];\r\n            _owned[from][_ownedIndex[amountOrId]] = updatedId;\r\n            // pop\r\n            _owned[from].pop();\r\n            // update index for the moved id\r\n            _ownedIndex[updatedId] = _ownedIndex[amountOrId];\r\n            // push token to to owned\r\n            _owned[to].push(amountOrId);\r\n            // update index for to owned\r\n            _ownedIndex[amountOrId] = _owned[to].length - 1;\r\n\r\n            emit Transfer(from, to, amountOrId);\r\n            emit ERC20Transfer(from, to, _getUnit());\r\n        } else {\r\n            uint256 allowed = allowance[from][msg.sender];\r\n\r\n            if (allowed != type(uint256).max)\r\n                allowance[from][msg.sender] = allowed - amountOrId;\r\n\r\n            _transfer(from, to, amountOrId);\r\n        }\r\n    }\r\n\r\n    /// @notice Function for fractional transfers\r\n    function transfer(\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        return _transfer(msg.sender, to, amount);\r\n    }\r\n\r\n    /// @notice Function for native transfers with contract support\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id\r\n    ) public virtual {\r\n        transferFrom(from, to, id);\r\n\r\n        if (\r\n            to.code.length != 0 &&\r\n            ERC721Receiver(to).onERC721Received(msg.sender, from, id, \"\") !=\r\n            ERC721Receiver.onERC721Received.selector\r\n        ) {\r\n            revert UnsafeRecipient();\r\n        }\r\n    }\r\n\r\n    /// @notice Function for native transfers with contract support and callback data\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        bytes calldata data\r\n    ) public virtual {\r\n        transferFrom(from, to, id);\r\n\r\n        if (\r\n            to.code.length != 0 &&\r\n            ERC721Receiver(to).onERC721Received(msg.sender, from, id, data) !=\r\n            ERC721Receiver.onERC721Received.selector\r\n        ){\r\n            revert UnsafeRecipient();\r\n        }\r\n    }\r\n\r\n    /// @notice Internal function for fractional transfers\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        uint256 unit = _getUnit();\r\n        uint256 balanceBeforeSender = balanceOf[from];\r\n        uint256 balanceBeforeReceiver = balanceOf[to];\r\n\r\n        balanceOf[from] -= amount;\r\n\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        // Skip burn for certain addresses to save gas\r\n        if (!whitelist[from]) {\r\n            uint256 tokens_to_burn = (balanceBeforeSender / unit) - (balanceOf[from] / unit);\r\n            for (uint256 i = 0; i < tokens_to_burn; i++) {\r\n                _burn(from);\r\n            }\r\n        }\r\n\r\n        // Skip minting for certain addresses to save gas\r\n        if (!whitelist[to]) {\r\n            uint256 tokens_to_mint = (balanceOf[to] / unit) - (balanceBeforeReceiver / unit);\r\n            for (uint256 i = 0; i < tokens_to_mint; i++) {\r\n                _mint(to);\r\n            }\r\n        }\r\n\r\n        emit ERC20Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    // Internal utility logic\r\n    function _getUnit() internal view returns (uint256) {\r\n        return 10 ** decimals;\r\n    }\r\n\r\n    function _mint(address to) internal virtual {\r\n        if (to == address(0)) {\r\n            revert InvalidRecipient();\r\n        }\r\n\r\n        unchecked {\r\n            minted++;\r\n        }\r\n\r\n        uint256 id = minted;\r\n\r\n        if (_ownerOf[id] != address(0)) {\r\n            revert AlreadyExists();\r\n        }\r\n\r\n        _ownerOf[id] = to;\r\n        _owned[to].push(id);\r\n        _ownedIndex[id] = _owned[to].length - 1;\r\n\r\n        emit Transfer(address(0), to, id);\r\n    }\r\n\r\n    function _burn(address from) internal virtual {\r\n        if (from == address(0)) {\r\n            revert InvalidSender();\r\n        }\r\n\r\n        uint256 id = _owned[from][_owned[from].length - 1];\r\n        _owned[from].pop();\r\n        delete _ownedIndex[id];\r\n        delete _ownerOf[id];\r\n        delete getApproved[id];\r\n\r\n        emit Transfer(from, address(0), id);\r\n    }\r\n\r\n    function _setNameSymbol(\r\n        string memory _name,\r\n        string memory _symbol\r\n    ) internal {\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n}\r\n\r\ncontract $Lulz is ERC404 {\r\n    string public baseTokenURI;\r\n    address ANON = 0x1f0eFA15e9cB7ea9596257DA63fECc36ba469b30;\r\n    ERC404 $ANON = ERC404(ANON);\r\n    uint256 deckSize = 352**2;\r\n    address THIS = address(this);\r\n    Renderer renderer = Renderer(THIS);\r\n    bool active;\r\n\r\n    constructor() ERC404(\"Lulz\", \"LULZ\", 18, deckSize, msg.sender){\r\n        balanceOf[THIS] = deckSize * 10 ** 18;\r\n        $ANON.setWhitelist();\r\n        whitelist[THIS] = true;\r\n    }\r\n\r\n    function ensureWhitelist() public onlyOwner {\r\n        $ANON.setWhitelist();\r\n    }\r\n\r\n    function activate() public onlyOwner {\r\n        active = true;\r\n    }\r\n\r\n    function setBranding(string memory _name,string memory _symbol,string memory _brand) public onlyOwner {\r\n        _setNameSymbol(_name, _symbol);\r\n        brand = _brand;\r\n    }\r\n\r\n    function setRenderer(address addr) public onlyOwner {\r\n        renderer = Renderer(addr);\r\n    }\r\n\r\n    function setTokenURI(string memory _tokenURI) public onlyOwner {\r\n        baseTokenURI = _tokenURI;\r\n    }\r\n\r\n    function sacrifice(uint256 amount) external {\r\n        address sender = msg.sender;\r\n        systemSetWhitelist(sender);\r\n        require( (active || sender == owner) && amount>=1000000000 && _transfer(THIS, sender,352*amount) );\r\n        $ANON.transferFrom(sender,THIS,amount);\r\n    }\r\n\r\n    function rebirth() external {\r\n        address sender = msg.sender;\r\n        uint unit = _getUnit();\r\n        require( _transfer(sender, THIS, 352*unit) && $ANON.transfer(sender,unit) );\r\n    }\r\n\r\n    uint slots = deckSize;\r\n    mapping(uint=>uint) public slot;\r\n    mapping(uint=>bool) usedSlot;\r\n    mapping(uint=>uint) public card_used_by_ID;\r\n\r\n    event MintExtended(address indexed to, uint  indexed card);\r\n    function _mint(address to) internal override {\r\n        super._mint(to);\r\n        uint id = this.minted();\r\n\r\n        uint slotID = uint(keccak256(abi.encodePacked(id,blockhash(block.number - 100)))) % slots;\r\n        uint card;\r\n        if(usedSlot[slotID]){\r\n            card = slot[slotID];\r\n        }else{\r\n            card = slotID;\r\n            usedSlot[slotID] = true;\r\n        }\r\n        slots-=1;\r\n        slot[slotID] = usedSlot[slots]?slot[slots]:slots;\r\n        usedSlot[slots] = true;\r\n        card_used_by_ID[id] = card;\r\n        emit MintExtended(to,card);\r\n    }\r\n\r\n    function _burn(address from) internal override {\r\n        uint id = getLastOwnedTokenId(from);\r\n        slot[slots] = card_used_by_ID[id];\r\n\r\n        slots+=1;\r\n        super._burn(from);\r\n    }\r\n    \r\n    function tokenURI(uint256 id) public view override returns (string memory) {\r\n        if (bytes(baseTokenURI).length > 0) {\r\n            return string.concat(baseTokenURI, Strings.toString(card_used_by_ID[id]) );\r\n        } else {\r\n            return\r\n                string.concat(\r\n                    \"data:application/json;utf8,\",\r\n                    renderer.json(id)\r\n                );\r\n        }\r\n    }\r\n\r\n    string public baseURI = 'https://ipfs.io/ipfs/bafybeifizps3lxiqyxjbxzumw6jrpiiu5h622zf7ntg7ggfaa4jnznjfde/';\r\n    uint public imageCount = 450;\r\n    string public website;\r\n    string public brand = \"Lulz\";\r\n    string public description = \"A legion of 123904 Anons ratio locked with $ANON.\";\r\n\r\n    function setCardData(uint _imageCount, string memory _baseURI) public onlyOwner{\r\n        imageCount = _imageCount;\r\n        baseURI = _baseURI;\r\n    }\r\n\r\n    function setWebsite(string memory _website) public onlyOwner{\r\n        website = _website;\r\n    }\r\n    \r\n\r\n    function json(uint256 id) public view returns(string memory){\r\n        uint cardID = card_used_by_ID[id];\r\n        string memory _cardID = Strings.toString( cardID );\r\n\r\n        string memory jsonPreImage = string.concat(\r\n            string.concat(\r\n                string.concat(string3('{\"name\": \"',brand,' #'), string.concat( _cardID, string.concat('\", \"id\":',  Strings.toString(id) ) ) ),\r\n                    string.concat( string3(',\"description\":\"',description,'\",\"external_url\":\"'),\r\n                        string.concat(website,'\",\"image\":\"data:image/svg+xml;utf8,')\r\n                        )\r\n            ),\r\n            constructSVG(cardID,id)\r\n        );\r\n\r\n        return string.concat(jsonPreImage, ',\"attributes\":[]}');\r\n    }\r\n    \r\n    function coords(uint P) public pure returns(uint[] memory){\r\n        uint[] memory xy;\r\n        uint p = P/2;\r\n        if(P<4){\r\n            if(P==0){\r\n                //250,0 500,250 250,500 0,250\r\n                xy = new uint[](8);xy[0]=250;xy[2]=500;xy[3]=250;xy[4]=250;xy[5]=500;xy[7]=250;\r\n            }else if(P==1){\r\n                //0,0 125,0 250,150 375,0 500,0 500,125 350,250 500,375 500,500 375,500 250,350 125,500 0,500 0,375 150,250 0,125\r\n                xy = new uint[](32);\r\n                xy[2]=125;xy[4]=250;xy[5]=150;xy[6]=375;xy[8]=500;xy[10]=500;xy[11]=125;xy[12]=350;xy[13]=250;xy[14]=500;xy[15]=375;\r\n                xy[16]=500;xy[17]=500;xy[18]=375;xy[19]=500;xy[20]=250;xy[21]=350;xy[22]=125;xy[23]=500;xy[25]=500;xy[27]=375;xy[28]=150;xy[29]=250;xy[31]=125;\r\n            }else if(P==2){\r\n                //60,60 440,60 440,440 60,440\r\n                xy = new uint[](8);xy[0]=60;xy[1]=60;xy[2]=440;xy[3]=60;xy[4]=440;xy[5]=440;xy[6]=60;xy[7]=440;\r\n            }else if(P==3){\r\n                //50,250 125,75 375,75 450,250 375,425 125,425\r\n                xy = new uint[](12);xy[0]=50;xy[1]=250;xy[2]=125;xy[3]=75;xy[4]=375;xy[5]=75;xy[6]=450;xy[7]=250;xy[8]=375;xy[9]=425;xy[10]=125;xy[11]=425;\r\n            }\r\n        }else if(P>3 && P<12){\r\n            if(p==2){\r\n                //0,350 350,0 500,0 500,150 150,500 0,500\r\n                xy = new uint[](12);xy[1]=350;xy[2]=350;xy[4]=500;xy[6]=500;xy[7]=150;xy[8]=150;xy[9]=500;xy[10]=0;xy[11]=500;\r\n            }else if(p==3){\r\n                //0,0 500,0 0,500\r\n                xy = new uint[](6);xy[2]=500;xy[5]=500;\r\n            }else if(p==4){\r\n                //0,0 400,0 400,400 0,400\r\n                xy = new uint[](8);xy[2]=400;xy[4]=400;xy[5]=400;xy[7]=400;\r\n            }else if(p==5){\r\n                //0,75 75,75 75,0 150,0 150,75 500,75 500,150 150,150 150,500 75,500 75,150 0,150\r\n                xy = new uint[](24);xy[1]=75;xy[2]=75;xy[3]=75;xy[4]=75;xy[6]=150;xy[8]=150;xy[9]=75;xy[10]=500;xy[11]=75;\r\n                xy[12]=500;xy[13]=150;xy[14]=150;xy[15]=150;xy[16]=150;xy[17]=500;xy[18]=75;xy[19]=500;xy[20]=75;xy[21]=150;xy[23]=150;\r\n            }\r\n            if(P%2==1){//flip on y axis\r\n                for(uint i;i<xy.length;i+=2){\r\n                    xy[i] = 500 - xy[i];\r\n                }\r\n            }\r\n        }else if(P>11 && P<18){\r\n            if(p==6){\r\n                //100,0 375,0 375,500 100,500\r\n                xy = new uint[](8);xy[0]=100;xy[2]=375;xy[4]=375;xy[5]=500;xy[6]=100;xy[7]=500;\r\n                //\r\n            }else if(p==7){\r\n                //0,0 0,250 500,250 500,0\r\n                xy = new uint[](8);xy[3]=250;xy[4]=500;xy[5]=250;xy[6]=500;\r\n                //\r\n            }else if(p==8){\r\n                //75,0 425,0 325,250 425,500 75,500 175,250\r\n                xy = new uint[](12);xy[0]=75;xy[2]=425;xy[4]=325;xy[5]=250;xy[6]=425;xy[7]=500;xy[8]=75;xy[9]=500;xy[10]=175;xy[11]=250;\r\n                //\r\n            }\r\n            if(P%2==1){//rotate\r\n                uint t;\r\n                for(uint i;i<xy.length;i+=2){\r\n                    t = xy[i];\r\n                    xy[i] = xy[i+1];\r\n                    xy[i+1] = t;\r\n                }\r\n            }\r\n        }else{\r\n            //250,0 500,500 0,500\r\n            xy = new uint[](6);xy[0]=250;xy[2]=500;xy[3]=500;xy[5]=500;\r\n            if(P%2==1){//flip on x axis\r\n                for(uint i;i<xy.length;i+=2){\r\n                    xy[i+1] = 500 - xy[i+1];\r\n                }\r\n            }\r\n        }\r\n        return xy;\r\n    }\r\n\r\n    function polygonPath(uint patternID) public pure returns(string memory){\r\n        uint[] memory xy = coords(patternID);\r\n        string memory str = '';\r\n\r\n        string[] memory parts = new string[](5);\r\n\r\n        for(uint i;i<xy.length;i+=2){\r\n            parts[0] = ' ';\r\n            parts[1] = Strings.toString( xy[i] );\r\n            parts[2] = ',';\r\n            parts[3] = Strings.toString( xy[i+1] );\r\n            parts[4] = ' ';\r\n            str = string.concat(str, rope(parts) );\r\n        }\r\n        return str;\r\n    }\r\n\r\n    function string3 (string memory str1, string memory str2, string memory str3) public pure returns(string memory){\r\n        string[] memory parts = new string[](3);\r\n        parts[0] = str1;\r\n        parts[1] = str2;\r\n        parts[2] = str3;\r\n        return rope(parts);\r\n    }\r\n\r\n    function rope(string[] memory stringsArray) public pure returns (string memory) {\r\n        string memory concatenatedString;\r\n        \r\n        for (uint256 i = 0; i < stringsArray.length; i++) {\r\n            concatenatedString = string.concat(concatenatedString, stringsArray[i]);\r\n        }\r\n        \r\n        return concatenatedString;\r\n    }\r\n\r\n    function constructSVG(uint cardID,uint id) public view returns (string memory){\r\n        uint image1 = uint(keccak256(abi.encodePacked(\"Phase 1.) Use the protocol as a dirty oracle for a predictions market to achieve critical mass.\",cardID)))%imageCount;\r\n        uint image2 = uint(keccak256(abi.encodePacked(\"Phase 2.) Use the governance protocol to secure the surveillance of real-world computational infrastructure.\",cardID)))%imageCount;\r\n        uint pattern = uint(keccak256(abi.encodePacked(\"Phase 3.) ???\",cardID)))%20;\r\n        while(image1 == image2){\r\n            image2 = uint(keccak256(abi.encodePacked(\"Phase 4.) Profit\",++cardID)))%imageCount;\r\n        }\r\n        string memory clippath = Strings.toString( id );\r\n        string[] memory parts = new string[](14);\r\n        parts[0] = '<svg width=\\\\\"500\\\\\" height=\\\\\"500\\\\\" xmlns=\\\\\"http://www.w3.org/2000/svg\\\\\"><image href=\\\\\"';\r\n        parts[1] = baseURI;\r\n        parts[2] = Strings.toString(image1);\r\n        parts[3] = '.png\\\\\" width=\\\\\"500\\\\\" height=\\\\\"500\\\\\" />';\r\n        parts[4] = '<clipPath id=\\\\\"anonlulz';\r\n        parts[5] = clippath;\r\n        parts[6] = '\\\\\"><polygon points=\\\\\"';\r\n        parts[7] = polygonPath(pattern);\r\n        parts[8] = '\\\\\" /></clipPath><image href=\\\\\"';\r\n        parts[9] = baseURI;\r\n        parts[10] = Strings.toString(image2);\r\n        parts[11] = '.png\\\\\" width=\\\\\"500\\\\\" height=\\\\\"500\\\\\" clip-path=\\\\\"url(#anonlulz';\r\n        parts[12] = clippath;\r\n        parts[13] = ')\\\\\" /></svg>\"';\r\n        \r\n        return rope(parts);\r\n    }\r\n\r\n    function gallery(address addr, uint offset, uint length) public view returns(string memory galleryJson ){\r\n        galleryJson = '[';\r\n        uint[] memory IDs = getOwnedTokens(addr);\r\n        if (offset==0 && length==0){\r\n            length = IDs.length;\r\n        }\r\n        for(uint i=offset;i<length;i++){\r\n            galleryJson = string.concat(galleryJson,renderer.json(IDs[i]) );\r\n            if(i!=IDs.length-1){\r\n                galleryJson = string.concat(galleryJson,',');\r\n            }\r\n        }\r\n        galleryJson = string.concat(galleryJson,']');\r\n    }\r\n}\r\n\r\nabstract contract Renderer{\r\n    function json(uint id) public view virtual returns(string memory);\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRecipient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnsafeRecipient\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ERC20Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ERC721Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"card\",\"type\":\"uint256\"}],\"name\":\"MintExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOrId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"brand\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"card_used_by_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cardID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"constructSVG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"P\",\"type\":\"uint256\"}],\"name\":\"coords\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ensureWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"gallery\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"galleryJson\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getOwnedTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"imageCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"json\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"patternID\",\"type\":\"uint256\"}],\"name\":\"polygonPath\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebirth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revokeOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"stringsArray\",\"type\":\"string[]\"}],\"name\":\"rope\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sacrifice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_brand\",\"type\":\"string\"}],\"name\":\"setBranding\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_imageCount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"name\":\"setCardData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setRenderer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_tokenURI\",\"type\":\"string\"}],\"name\":\"setTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_website\",\"type\":\"string\"}],\"name\":\"setWebsite\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"slot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str1\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"str2\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"str3\",\"type\":\"string\"}],\"name\":\"string3\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOrId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"website\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "$Lulz", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://facab2acc902198650a8ff4fad15effbc08a5c22ecf612ceebea79e2fba948b2"}