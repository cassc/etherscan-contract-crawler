{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SignedSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @title SignedSafeMath\\n * @dev Signed math operations with safety checks that revert on error.\\n */\\nlibrary SignedSafeMath {\\n    int256 constant private _INT256_MIN = -2**255;\\n\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT256_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        int256 c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(!(b == -1 && a == _INT256_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n        int256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value < 2**128, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value < 2**64, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value < 2**32, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value < 2**16, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value < 2**8, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= -2**127 && value < 2**127, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= -2**63 && value < 2**63, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= -2**31 && value < 2**31, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= -2**15 && value < 2**15, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= -2**7 && value < 2**7, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        require(value < 2**255, \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/adapters/AaveMigrationExtension.sol\": {\r\n      \"content\": \"/*\\n    Copyright 2024 Index Coop\\n\\n    Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n    you may not use this file except in compliance with the License.\\n    You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n    Unless required by applicable law or agreed to in writing, software\\n    distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n    See the License for the specific language governing permissions and\\n    limitations under the License.\\n\\n    SPDX-License-Identifier: Apache License, Version 2.0\\n*/\\n\\npragma solidity 0.6.10;\\npragma experimental ABIEncoderV2;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IERC721Receiver } from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport { SafeCast } from \\\"@openzeppelin/contracts/utils/SafeCast.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport { SafeMath } from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport { FlashLoanSimpleReceiverBase } from \\\"../lib/FlashLoanSimpleReceiverBase.sol\\\";\\nimport { IPoolAddressesProvider } from \\\"../interfaces/IPoolAddressesProvider.sol\\\";\\n\\nimport { INonfungiblePositionManager } from \\\"../interfaces/external/uniswap-v3/INonfungiblePositionManager.sol\\\";\\nimport { IUniswapV3Pool } from \\\"../interfaces/external/uniswap-v3/IUniswapV3Pool.sol\\\";\\n\\nimport { BaseExtension } from \\\"../lib/BaseExtension.sol\\\";\\nimport { IBaseManager } from \\\"../interfaces/IBaseManager.sol\\\";\\nimport { IDebtIssuanceModule } from \\\"../interfaces/IDebtIssuanceModule.sol\\\";\\nimport { ISetToken } from \\\"../interfaces/ISetToken.sol\\\";\\nimport { ITradeModule } from \\\"../interfaces/ITradeModule.sol\\\";\\nimport { PreciseUnitMath } from \\\"../lib/PreciseUnitMath.sol\\\";\\n\\n/**\\n * @title AaveMigrationExtension\\n * @author Index Coop\\n * @notice This extension facilitates the migration of a SetToken's position from an unwrapped collateral\\n * asset to another SetToken that consists solely of Aave's wrapped collateral asset. The migration is\\n * executed through several steps: obtaining a flash loan of the unwrapped collateral, minting the required\\n * quantity of the wrapped SetToken, adding liquidity to the Uniswap V3 pool, swapping the unwrapped\\n * collateral for the wrapped SetToken, removing liquidity from the Uniswap V3 pool, and finally,\\n * redeeming any excess wrapped SetToken. This process is specifically designed to efficiently migrate\\n * the SetToken's collateral using only the TradeModule on the SetToken.\\n */\\ncontract AaveMigrationExtension is BaseExtension, FlashLoanSimpleReceiverBase, IERC721Receiver {\\n    using PreciseUnitMath for uint256;\\n    using SafeCast for int256;\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint256;\\n\\n    /* ============ Structs ============ */\\n\\n    struct DecodedParams {\\n        uint256 supplyLiquidityAmount0Desired;\\n        uint256 supplyLiquidityAmount1Desired;\\n        uint256 supplyLiquidityAmount0Min;\\n        uint256 supplyLiquidityAmount1Min;\\n        uint256 tokenId;\\n        string exchangeName;\\n        uint256 underlyingTradeUnits;\\n        uint256 wrappedSetTokenTradeUnits;\\n        bytes exchangeData;\\n        uint256 redeemLiquidityAmount0Min;\\n        uint256 redeemLiquidityAmount1Min;\\n        bool isUnderlyingToken0;\\n    }\\n\\n    /* ========== State Variables ========= */\\n\\n    ISetToken public immutable setToken; \\n    IERC20 public immutable underlyingToken;\\n    IERC20 public immutable aaveToken;\\n    ISetToken public immutable wrappedSetToken;\\n    ITradeModule public immutable tradeModule;\\n    IDebtIssuanceModule public immutable issuanceModule;\\n    INonfungiblePositionManager public immutable nonfungiblePositionManager;\\n\\n    uint256[] public tokenIds; // UniV3 LP Token IDs\\n\\n    /* ============ Constructor ============ */\\n\\n    /**\\n     * @notice Initializes the AaveMigrationExtension with immutable migration variables.\\n     * @param _manager BaseManager contract for managing the SetToken's operations and permissions.\\n     * @param _underlyingToken Address of the underlying token to be migrated.\\n     * @param _aaveToken Address of Aave's wrapped collateral asset.\\n     * @param _wrappedSetToken SetToken that consists solely of Aave's wrapped collateral asset.\\n     * @param _tradeModule TradeModule address for executing trades on behalf of the SetToken.\\n     * @param _issuanceModule IssuanceModule address for managing issuance and redemption of the Wrapped SetToken.\\n     * @param _nonfungiblePositionManager Uniswap V3's NonFungiblePositionManager for managing liquidity positions.\\n     * @param _addressProvider Aave V3's Pool Address Provider, used for accessing the Aave lending pool.\\n     */\\n    constructor(\\n        IBaseManager _manager, \\n        IERC20 _underlyingToken,\\n        IERC20 _aaveToken,\\n        ISetToken _wrappedSetToken,\\n        ITradeModule _tradeModule,\\n        IDebtIssuanceModule _issuanceModule,\\n        INonfungiblePositionManager _nonfungiblePositionManager,\\n        IPoolAddressesProvider _addressProvider\\n    ) \\n        public\\n        BaseExtension(_manager)\\n        FlashLoanSimpleReceiverBase(_addressProvider)\\n    {\\n        manager = _manager;\\n        setToken = manager.setToken();\\n        underlyingToken = _underlyingToken;\\n        aaveToken = _aaveToken;\\n        wrappedSetToken = _wrappedSetToken;\\n        tradeModule = _tradeModule;\\n        issuanceModule = _issuanceModule;\\n        nonfungiblePositionManager = _nonfungiblePositionManager;\\n    }\\n\\n    /* ========== External Functions ========== */\\n\\n    /**\\n     * @notice OPERATOR ONLY: Initializes the Set Token on the Trade Module.\\n     */\\n    function initialize() external onlyOperator {\\n        bytes memory data = abi.encodeWithSelector(tradeModule.initialize.selector, setToken);\\n        invokeManager(address(tradeModule), data);\\n    }\\n    \\n    /**\\n     * @notice OPERATOR ONLY: Executes a trade on a supported DEX.\\n     * @dev Although the SetToken units are passed in for the send and receive quantities, the total quantity\\n     * sent and received is the quantity of SetToken units multiplied by the SetToken totalSupply.\\n     * @param _exchangeName The human-readable name of the exchange in the integrations registry.\\n     * @param _sendToken The address of the token being sent to the exchange.\\n     * @param _sendQuantity The amount of the token (in SetToken units) being sent to the exchange.\\n     * @param _receiveToken The address of the token being received from the exchange.\\n     * @param _minReceiveQuantity The minimum amount of the receive token (in SetToken units) expected from the exchange.\\n     * @param _data Arbitrary data used to construct the trade call data.\\n     */\\n    function trade(\\n        string memory _exchangeName,\\n        address _sendToken,\\n        uint256 _sendQuantity,\\n        address _receiveToken,\\n        uint256 _minReceiveQuantity,\\n        bytes memory _data\\n    )\\n        external\\n        onlyOperator\\n    {\\n        _trade(\\n            _exchangeName,\\n            _sendToken,\\n            _sendQuantity,\\n            _receiveToken,\\n            _minReceiveQuantity,\\n            _data\\n        );\\n    }\\n\\n    /**\\n     * @notice OPERATOR ONLY: Mints a new liquidity position in the Uniswap V3 pool.\\n     * @param _amount0Desired The desired amount of token0 to be added as liquidity.\\n     * @param _amount1Desired The desired amount of token1 to be added as liquidity.\\n     * @param _amount0Min The minimum amount of token0 to be added as liquidity.\\n     * @param _amount1Min The minimum amount of token1 to be added as liquidity.\\n     * @param _tickLower The lower end of the desired tick range for the position.\\n     * @param _tickUpper The upper end of the desired tick range for the position.\\n     * @param _fee The fee tier of the Uniswap V3 pool in which to add liquidity.\\n     * @param _isUnderlyingToken0 True if the underlying token is token0, false if it is token1.\\n     */\\n    function mintLiquidityPosition(\\n        uint256 _amount0Desired,\\n        uint256 _amount1Desired,\\n        uint256 _amount0Min,\\n        uint256 _amount1Min,\\n        int24 _tickLower,\\n        int24 _tickUpper,\\n        uint24 _fee,\\n        bool _isUnderlyingToken0\\n    )\\n        external\\n        onlyOperator\\n    {\\n        _mintLiquidityPosition(\\n            _amount0Desired,\\n            _amount1Desired,\\n            _amount0Min,\\n            _amount1Min,\\n            _tickLower,\\n            _tickUpper,\\n            _fee,\\n            _isUnderlyingToken0\\n        );\\n    }\\n\\n    /**\\n     * @notice OPERATOR ONLY: Increases liquidity position in the Uniswap V3 pool.\\n     * @param _amount0Desired The desired amount of token0 to be added as liquidity.\\n     * @param _amount1Desired The desired amount of token1 to be added as liquidity.\\n     * @param _amount0Min The minimum amount of token0 to be added as liquidity.\\n     * @param _amount1Min The minimum amount of token1 to be added as liquidity.\\n     * @param _tokenId The ID of the UniV3 LP Token for which liquidity is being increased.\\n     * @param _isUnderlyingToken0 True if the underlying token is token0, false if it is token1.\\n     * @return liquidity The new liquidity amount as a result of the increase.\\n     */\\n    function increaseLiquidityPosition(\\n        uint256 _amount0Desired,\\n        uint256 _amount1Desired,\\n        uint256 _amount0Min,\\n        uint256 _amount1Min,\\n        uint256 _tokenId,\\n        bool _isUnderlyingToken0\\n    )\\n        external\\n        onlyOperator\\n        returns (uint128 liquidity)\\n    {\\n        liquidity = _increaseLiquidityPosition(\\n            _amount0Desired,\\n            _amount1Desired,\\n            _amount0Min,\\n            _amount1Min,\\n            _tokenId,\\n            _isUnderlyingToken0\\n        );\\n    }\\n\\n    /**\\n     * @notice OPERATOR ONLY: Decreases and collects from a liquidity position in the Uniswap V3 pool.\\n     * @param _tokenId The ID of the UniV3 LP Token for which liquidity is being decreased.\\n     * @param _liquidity The amount of liquidity to decrease.\\n     * @param _amount0Min The minimum amount of token0 that should be accounted for the burned liquidity.\\n     * @param _amount1Min The minimum amount of token1 that should be accounted for the burned liquidity.\\n     */\\n    function decreaseLiquidityPosition(\\n        uint256 _tokenId,\\n        uint128 _liquidity,\\n        uint256 _amount0Min,\\n        uint256 _amount1Min\\n    )\\n        external\\n        onlyOperator\\n    {\\n        _decreaseLiquidityPosition(\\n            _tokenId,\\n            _liquidity,\\n            _amount0Min,\\n            _amount1Min\\n        );\\n    }\\n\\n    /**\\n     * @notice OPERATOR ONLY: Migrates a SetToken's position from an unwrapped collateral asset to another SetToken \\n     * that consists solely of Aave's wrapped collateral asset\\n     * @param _decodedParams The decoded migration parameters.\\n     * @param _underlyingLoanAmount The amount of unwrapped collateral asset to be borrowed via flash loan.\\n     * @param _maxSubsidy The maximum amount of unwrapped collateral asset to be transferred to the Extension as a subsidy.\\n     * @return underlyingOutputAmount The amount of unwrapped collateral asset returned to the operator.\\n     */\\n    function migrate(\\n        DecodedParams memory _decodedParams,\\n        uint256 _underlyingLoanAmount,\\n        uint256 _maxSubsidy\\n    )\\n        external\\n        onlyOperator\\n        returns (uint256 underlyingOutputAmount)\\n    {\\n        // Subsidize the migration\\n        if (_maxSubsidy > 0) {\\n            underlyingToken.transferFrom(msg.sender, address(this), _maxSubsidy);\\n        }\\n\\n        // Encode migration parameters for flash loan callback\\n        bytes memory params = abi.encode(_decodedParams);\\n\\n        // Request flash loan for the underlying token\\n        POOL.flashLoanSimple(\\n            address(this),\\n            address(underlyingToken),\\n            _underlyingLoanAmount,\\n            params,\\n            0\\n        );\\n\\n        // Return remaining underlying token to the operator\\n        underlyingOutputAmount = _returnExcessUnderlying();\\n    }\\n\\n    /**\\n     * @dev Callback function for Aave V3 flash loan, executed post-loan. It decodes the provided parameters, conducts the migration, and repays the flash loan.\\n     * @param amount The amount borrowed.\\n     * @param premium The additional fee charged for the flash loan.\\n     * @param initiator The initiator of the flash loan.\\n     * @param params Encoded migration parameters.\\n     * @return True if the operation is successful.\\n     */\\n    function executeOperation(\\n        address, // asset\\n        uint256 amount,\\n        uint256 premium,\\n        address initiator,\\n        bytes calldata params\\n    )\\n        external\\n        override\\n        returns (bool) \\n    {\\n        require(msg.sender == address(POOL), \\\"MigrationExtension: invalid flashloan sender\\\");\\n        require(initiator == address(this), \\\"MigrationExtension: invalid flashloan initiator\\\");\\n\\n        // Decode parameters and migrate\\n        DecodedParams memory decodedParams = abi.decode(params, (DecodedParams));\\n        _migrate(decodedParams);\\n\\n        underlyingToken.approve(address(POOL), amount + premium);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Receives ERC721 tokens, required for Uniswap V3 LP NFT handling.\\n     * @dev Callback function for ERC721 token transfers, enabling the contract to receive Uniswap V3 LP NFTs. Always returns the selector to indicate successful receipt.\\n     * @return The selector of the `onERC721Received` function.\\n     */\\n    function onERC721Received(\\n        address, // operator\\n        address, // from\\n        uint256, // tokenId\\n        bytes calldata // data\\n    ) \\n        external\\n        override\\n        returns (bytes4)\\n    {\\n        return this.onERC721Received.selector;\\n    }\\n\\n    /**\\n     * @notice OPERATOR ONLY: Transfers any residual balances to the operator's address.\\n     * @dev This function is intended to recover tokens that might have been left behind\\n     * due to the migration process or any other operation. It ensures that the contract\\n     * does not retain any assets inadvertently. Only callable by the operator.\\n     * @param _token The address of the token to be swept.\\n     */\\n    function sweepTokens(address _token) external onlyOperator {\\n        IERC20 token = IERC20(_token);\\n        uint256 balance = token.balanceOf(address(this));\\n        require(balance > 0, \\\"MigrationExtension: no balance to sweep\\\");\\n        token.transfer(manager.operator(), balance);\\n    }\\n\\n    /* ========== Internal Functions ========== */\\n\\n    /**\\n     * @dev Conducts the actual migration steps utilizing the decoded parameters from the flash loan callback.\\n     * @param decodedParams The decoded set of parameters needed for migration.\\n     */\\n    function _migrate(DecodedParams memory decodedParams) internal {\\n        uint256 wrappedSetTokenSupplyLiquidityAmount = decodedParams.isUnderlyingToken0 \\n            ? decodedParams.supplyLiquidityAmount1Desired \\n            : decodedParams.supplyLiquidityAmount0Desired;\\n\\n        _issueRequiredWrappedSetToken(wrappedSetTokenSupplyLiquidityAmount);\\n\\n        uint128 liquidity = _increaseLiquidityPosition(\\n            decodedParams.supplyLiquidityAmount0Desired,\\n            decodedParams.supplyLiquidityAmount1Desired,\\n            decodedParams.supplyLiquidityAmount0Min,\\n            decodedParams.supplyLiquidityAmount1Min,\\n            decodedParams.tokenId,\\n            decodedParams.isUnderlyingToken0\\n        );\\n\\n        _trade(\\n            decodedParams.exchangeName,\\n            address(underlyingToken),\\n            decodedParams.underlyingTradeUnits,\\n            address(wrappedSetToken),\\n            decodedParams.wrappedSetTokenTradeUnits,\\n            decodedParams.exchangeData\\n        );\\n\\n        _decreaseLiquidityPosition(\\n            decodedParams.tokenId,\\n            liquidity,\\n            decodedParams.redeemLiquidityAmount0Min,\\n            decodedParams.redeemLiquidityAmount1Min\\n        );\\n\\n        _redeemExcessWrappedSetToken();\\n    }\\n\\n    /**\\n     * @dev Internal function to execute trades. This function constructs the trade call data and invokes the trade module\\n     * to execute the trade. The SetToken units for send and receive quantities are automatically scaled up by the SetToken's\\n     * total supply.\\n     * @param _exchangeName The human-readable name of the exchange in the integrations registry.\\n     * @param _sendToken The address of the token being sent to the exchange.\\n     * @param _sendQuantity The amount of the token (in SetToken units) being sent to the exchange.\\n     * @param _receiveToken The address of the token being received from the exchange.\\n     * @param _minReceiveQuantity The minimum amount of the receive token (in SetToken units) expected from the exchange.\\n     * @param _data Arbitrary data used to construct the trade call data.\\n     */\\n    function _trade(\\n        string memory _exchangeName,\\n        address _sendToken,\\n        uint256 _sendQuantity,\\n        address _receiveToken,\\n        uint256 _minReceiveQuantity,\\n        bytes memory _data\\n    )\\n        internal\\n    {\\n        bytes memory callData = abi.encodeWithSignature(\\n            \\\"trade(address,string,address,uint256,address,uint256,bytes)\\\",\\n            setToken,\\n            _exchangeName,\\n            _sendToken,\\n            _sendQuantity,\\n            _receiveToken,\\n            _minReceiveQuantity,\\n            _data\\n        );\\n        invokeManager(address(tradeModule), callData);\\n    }\\n\\n    /**\\n     * @dev Issues the required amount of wrapped SetToken for the liquidity increase\\n     * @param _wrappedSetTokenSupplyLiquidityAmount The amount of wrapped SetToken to be supplied to the pool.\\n     */\\n    function _issueRequiredWrappedSetToken(uint256 _wrappedSetTokenSupplyLiquidityAmount) internal {\\n        uint256 wrappedSetTokenBalance = wrappedSetToken.balanceOf(address(this));\\n        if (_wrappedSetTokenSupplyLiquidityAmount > wrappedSetTokenBalance) {\\n            uint256 wrappedSetTokenIssueAmount = _wrappedSetTokenSupplyLiquidityAmount.sub(wrappedSetTokenBalance);\\n            (address[] memory underlyingAssets ,uint256[] memory underlyingUnits,) = issuanceModule.getRequiredComponentIssuanceUnits(\\n                wrappedSetToken,\\n                wrappedSetTokenIssueAmount\\n            );\\n            require(underlyingAssets.length == 1, \\\"MigrationExtension: invalid wrapped SetToken composition\\\");\\n            require(underlyingAssets[0] == address(aaveToken), \\\"MigrationExtension: wrapped SetToken underlying mismatch\\\");\\n\\n            // Supply underlying for Aave wrapped token\\n            underlyingToken.approve(address(POOL), underlyingUnits[0]);\\n            POOL.supply(\\n                address(underlyingToken),\\n                underlyingUnits[0],\\n                address(this),\\n                0\\n            );\\n\\n            // Issue wrapped SetToken\\n            aaveToken.approve(address(issuanceModule), wrappedSetTokenIssueAmount);\\n            issuanceModule.issue(wrappedSetToken, wrappedSetTokenIssueAmount, address(this));\\n        }\\n    }\\n\\n    /**\\n     * @dev Redeems any excess wrapped SetToken after liquidity decrease\\n     */\\n    function _redeemExcessWrappedSetToken() internal {\\n        uint256 wrappedSetTokenBalance = wrappedSetToken.balanceOf(address(this));\\n        if (wrappedSetTokenBalance > 0) {\\n            // Redeem wrapped SetToken\\n            wrappedSetToken.approve(address(issuanceModule), wrappedSetTokenBalance);\\n            issuanceModule.redeem(wrappedSetToken, wrappedSetTokenBalance, address(this));\\n\\n            // Withdraw underlying from Aave\\n            uint256 aaveBalance = aaveToken.balanceOf(address(this));\\n            aaveToken.approve(address(POOL), aaveBalance);\\n            POOL.withdraw(\\n                address(underlyingToken),\\n                aaveBalance,\\n                address(this)\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to mint a new liquidity position in the Uniswap V3 pool.\\n     * Calls Uniswap's `mint` function with specified parameters.\\n     * @param _amount0Desired The desired amount of token0 to be added as liquidity.\\n     * @param _amount1Desired The desired amount of token1 to be added as liquidity.\\n     * @param _amount0Min The minimum amount of token0 to be added as liquidity.\\n     * @param _amount1Min The minimum amount of token1 to be added as liquidity.\\n     * @param _tickLower The lower end of the desired tick range for the position.\\n     * @param _tickUpper The upper end of the desired tick range for the position.\\n     * @param _fee The fee tier of the Uniswap V3 pool in which to add liquidity.\\n     * @param _isUnderlyingToken0 True if the underlying token is token0, false if it is token1.\\n     */\\n    function _mintLiquidityPosition(\\n        uint256 _amount0Desired,\\n        uint256 _amount1Desired,\\n        uint256 _amount0Min,\\n        uint256 _amount1Min,\\n        int24 _tickLower,\\n        int24 _tickUpper,\\n        uint24 _fee,\\n        bool _isUnderlyingToken0\\n    ) internal {\\n        // Sort tokens and amounts\\n        (\\n            address token0,\\n            address token1,\\n            uint256 underlyingAmount,\\n            uint256 wrappedSetTokenAmount\\n        ) = _isUnderlyingToken0\\n            ? (address(underlyingToken), address(wrappedSetToken), _amount0Desired, _amount1Desired)\\n            : (address(wrappedSetToken), address(underlyingToken), _amount1Desired, _amount0Desired);\\n\\n        // Approve tokens\\n        if (underlyingAmount > 0) {\\n            underlyingToken.approve(address(nonfungiblePositionManager), underlyingAmount);\\n        }\\n        if (wrappedSetTokenAmount > 0) {\\n            wrappedSetToken.approve(address(nonfungiblePositionManager), wrappedSetTokenAmount);\\n        }\\n\\n        // Mint liquidity position\\n        INonfungiblePositionManager.MintParams memory mintParams = INonfungiblePositionManager.MintParams({\\n            token0: token0,\\n            token1: token1,\\n            fee: _fee,\\n            tickLower: _tickLower,\\n            tickUpper: _tickUpper,\\n            amount0Desired: _amount0Desired,\\n            amount1Desired: _amount1Desired,\\n            amount0Min: _amount0Min,\\n            amount1Min: _amount1Min,\\n            recipient: address(this),\\n            deadline: block.timestamp\\n        });\\n        (uint256 tokenId,,,) = nonfungiblePositionManager.mint(mintParams);\\n        tokenIds.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to increase liquidity in a Uniswap V3 pool position.\\n     * Calls Uniswap's `increaseLiquidity` function with specified parameters.\\n     * @param _amount0Desired The desired amount of token0 to be added as liquidity.\\n     * @param _amount1Desired The desired amount of token1 to be added as liquidity.\\n     * @param _amount0Min The minimum amount of token0 to be added as liquidity.\\n     * @param _amount1Min The minimum amount of token1 to be added as liquidity.\\n     * @param _tokenId The ID of the UniV3 LP Token for which liquidity is being increased.\\n     * @param _isUnderlyingToken0 True if the underlying token is token0, false if it is token1.\\n     * @return liquidity The new liquidity amount as a result of the increase.\\n     */\\n    function _increaseLiquidityPosition(\\n        uint256 _amount0Desired,\\n        uint256 _amount1Desired,\\n        uint256 _amount0Min,\\n        uint256 _amount1Min,\\n        uint256 _tokenId,\\n        bool _isUnderlyingToken0\\n    )\\n        internal\\n        returns (uint128 liquidity)\\n    {\\n        (uint256 underlyingAmount, uint256 wrappedSetTokenAmount) = _isUnderlyingToken0\\n            ? (_amount0Desired, _amount1Desired)\\n            : (_amount1Desired, _amount0Desired);\\n\\n        // Approve tokens\\n        if (underlyingAmount > 0) {\\n            underlyingToken.approve(address(nonfungiblePositionManager), underlyingAmount);\\n        }\\n        if (wrappedSetTokenAmount > 0) {\\n            wrappedSetToken.approve(address(nonfungiblePositionManager), wrappedSetTokenAmount);\\n        }\\n\\n        // Increase liquidity\\n        INonfungiblePositionManager.IncreaseLiquidityParams memory increaseParams = INonfungiblePositionManager.IncreaseLiquidityParams({\\n            tokenId: _tokenId,\\n            amount0Desired: _amount0Desired,\\n            amount1Desired: _amount1Desired,\\n            amount0Min: _amount0Min,\\n            amount1Min: _amount1Min,\\n            deadline: block.timestamp\\n        });\\n        (liquidity,,) = nonfungiblePositionManager.increaseLiquidity(increaseParams);\\n    }\\n\\n    /**\\n     * @dev Internal function to decrease liquidity and collect fees for a Uniswap V3 position.\\n     * Calls Uniswap's `decreaseLiquidity` and `collect` functions with specified parameters.\\n     * @param _tokenId The ID of the UniV3 LP Token for which liquidity is being decreased.\\n     * @param _liquidity The amount by which liquidity will be decreased.\\n     * @param _amount0Min The minimum amount of token0 that should be accounted for the burned liquidity.\\n     * @param _amount1Min The minimum amount of token1 that should be accounted for the burned liquidity.\\n     */\\n    function _decreaseLiquidityPosition(\\n        uint256 _tokenId,\\n        uint128 _liquidity,\\n        uint256 _amount0Min,\\n        uint256 _amount1Min\\n    ) internal {\\n        // Decrease liquidity\\n        INonfungiblePositionManager.DecreaseLiquidityParams memory decreaseParams = INonfungiblePositionManager.DecreaseLiquidityParams({\\n            tokenId: _tokenId,\\n            liquidity: _liquidity,\\n            amount0Min: _amount0Min,\\n            amount1Min: _amount1Min,\\n            deadline: block.timestamp\\n        });\\n        nonfungiblePositionManager.decreaseLiquidity(decreaseParams);\\n\\n        // Collect liquidity and fees\\n        INonfungiblePositionManager.CollectParams memory params = INonfungiblePositionManager.CollectParams({\\n            tokenId: _tokenId,\\n            recipient: address(this),\\n            amount0Max: type(uint128).max,\\n            amount1Max: type(uint128).max\\n        });\\n        nonfungiblePositionManager.collect(params);\\n    }\\n\\n    /**\\n     * @dev Internal function to return any remaining unwrapped collateral asset to the operator.\\n     * @return underlyingOutputAmount The amount of unwrapped collateral asset returned to the operator.\\n     */\\n    function _returnExcessUnderlying() internal returns (uint256 underlyingOutputAmount) {\\n        underlyingOutputAmount = underlyingToken.balanceOf(address(this));\\n        if (underlyingOutputAmount > 0) {\\n            underlyingToken.transfer(msg.sender, underlyingOutputAmount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Datatypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.6.10;\\n\\nlibrary DataTypes {\\n  struct ReserveData {\\n    //stores the reserve configuration\\n    ReserveConfigurationMap configuration;\\n    //the liquidity index. Expressed in ray\\n    uint128 liquidityIndex;\\n    //the current supply rate. Expressed in ray\\n    uint128 currentLiquidityRate;\\n    //variable borrow index. Expressed in ray\\n    uint128 variableBorrowIndex;\\n    //the current variable borrow rate. Expressed in ray\\n    uint128 currentVariableBorrowRate;\\n    //the current stable borrow rate. Expressed in ray\\n    uint128 currentStableBorrowRate;\\n    //timestamp of last update\\n    uint40 lastUpdateTimestamp;\\n    //the id of the reserve. Represents the position in the list of the active reserves\\n    uint16 id;\\n    //aToken address\\n    address aTokenAddress;\\n    //stableDebtToken address\\n    address stableDebtTokenAddress;\\n    //variableDebtToken address\\n    address variableDebtTokenAddress;\\n    //address of the interest rate strategy\\n    address interestRateStrategyAddress;\\n    //the current treasury balance, scaled\\n    uint128 accruedToTreasury;\\n    //the outstanding unbacked aTokens minted through the bridging feature\\n    uint128 unbacked;\\n    //the outstanding debt borrowed against this asset in isolation mode\\n    uint128 isolationModeTotalDebt;\\n  }\\n\\n  struct ReserveConfigurationMap {\\n    //bit 0-15: LTV\\n    //bit 16-31: Liq. threshold\\n    //bit 32-47: Liq. bonus\\n    //bit 48-55: Decimals\\n    //bit 56: reserve is active\\n    //bit 57: reserve is frozen\\n    //bit 58: borrowing is enabled\\n    //bit 59: stable rate borrowing enabled\\n    //bit 60: asset is paused\\n    //bit 61: borrowing in isolation mode is enabled\\n    //bit 62-63: reserved\\n    //bit 64-79: reserve factor\\n    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\\n    //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\\n    //bit 152-167 liquidation protocol fee\\n    //bit 168-175 eMode category\\n    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\\n    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\\n    //bit 252-255 unused\\n\\n    uint256 data;\\n  }\\n\\n  struct UserConfigurationMap {\\n    /**\\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\\n     * asset is borrowed by the user.\\n     */\\n    uint256 data;\\n  }\\n\\n  struct EModeCategory {\\n    // each eMode category has a custom ltv and liquidation threshold\\n    uint16 ltv;\\n    uint16 liquidationThreshold;\\n    uint16 liquidationBonus;\\n    // each eMode category may or may not have a custom oracle to override the individual assets price oracles\\n    address priceSource;\\n    string label;\\n  }\\n\\n  enum InterestRateMode {\\n    NONE,\\n    STABLE,\\n    VARIABLE\\n  }\\n\\n  struct ReserveCache {\\n    uint256 currScaledVariableDebt;\\n    uint256 nextScaledVariableDebt;\\n    uint256 currPrincipalStableDebt;\\n    uint256 currAvgStableBorrowRate;\\n    uint256 currTotalStableDebt;\\n    uint256 nextAvgStableBorrowRate;\\n    uint256 nextTotalStableDebt;\\n    uint256 currLiquidityIndex;\\n    uint256 nextLiquidityIndex;\\n    uint256 currVariableBorrowIndex;\\n    uint256 nextVariableBorrowIndex;\\n    uint256 currLiquidityRate;\\n    uint256 currVariableBorrowRate;\\n    uint256 reserveFactor;\\n    ReserveConfigurationMap reserveConfiguration;\\n    address aTokenAddress;\\n    address stableDebtTokenAddress;\\n    address variableDebtTokenAddress;\\n    uint40 reserveLastUpdateTimestamp;\\n    uint40 stableDebtLastUpdateTimestamp;\\n  }\\n\\n  struct ExecuteLiquidationCallParams {\\n    uint256 reservesCount;\\n    uint256 debtToCover;\\n    address collateralAsset;\\n    address debtAsset;\\n    address user;\\n    bool receiveAToken;\\n    address priceOracle;\\n    uint8 userEModeCategory;\\n    address priceOracleSentinel;\\n  }\\n\\n  struct ExecuteSupplyParams {\\n    address asset;\\n    uint256 amount;\\n    address onBehalfOf;\\n    uint16 referralCode;\\n  }\\n\\n  struct ExecuteBorrowParams {\\n    address asset;\\n    address user;\\n    address onBehalfOf;\\n    uint256 amount;\\n    InterestRateMode interestRateMode;\\n    uint16 referralCode;\\n    bool releaseUnderlying;\\n    uint256 maxStableRateBorrowSizePercent;\\n    uint256 reservesCount;\\n    address oracle;\\n    uint8 userEModeCategory;\\n    address priceOracleSentinel;\\n  }\\n\\n  struct ExecuteRepayParams {\\n    address asset;\\n    uint256 amount;\\n    InterestRateMode interestRateMode;\\n    address onBehalfOf;\\n    bool useATokens;\\n  }\\n\\n  struct ExecuteWithdrawParams {\\n    address asset;\\n    uint256 amount;\\n    address to;\\n    uint256 reservesCount;\\n    address oracle;\\n    uint8 userEModeCategory;\\n  }\\n\\n  struct ExecuteSetUserEModeParams {\\n    uint256 reservesCount;\\n    address oracle;\\n    uint8 categoryId;\\n  }\\n\\n  struct FinalizeTransferParams {\\n    address asset;\\n    address from;\\n    address to;\\n    uint256 amount;\\n    uint256 balanceFromBefore;\\n    uint256 balanceToBefore;\\n    uint256 reservesCount;\\n    address oracle;\\n    uint8 fromEModeCategory;\\n  }\\n\\n  struct FlashloanParams {\\n    address receiverAddress;\\n    address[] assets;\\n    uint256[] amounts;\\n    uint256[] interestRateModes;\\n    address onBehalfOf;\\n    bytes params;\\n    uint16 referralCode;\\n    uint256 flashLoanPremiumToProtocol;\\n    uint256 flashLoanPremiumTotal;\\n    uint256 maxStableRateBorrowSizePercent;\\n    uint256 reservesCount;\\n    address addressesProvider;\\n    uint8 userEModeCategory;\\n    bool isAuthorizedFlashBorrower;\\n  }\\n\\n  struct FlashloanSimpleParams {\\n    address receiverAddress;\\n    address asset;\\n    uint256 amount;\\n    bytes params;\\n    uint16 referralCode;\\n    uint256 flashLoanPremiumToProtocol;\\n    uint256 flashLoanPremiumTotal;\\n  }\\n\\n  struct FlashLoanRepaymentParams {\\n    uint256 amount;\\n    uint256 totalPremium;\\n    uint256 flashLoanPremiumToProtocol;\\n    address asset;\\n    address receiverAddress;\\n    uint16 referralCode;\\n  }\\n\\n  struct CalculateUserAccountDataParams {\\n    UserConfigurationMap userConfig;\\n    uint256 reservesCount;\\n    address user;\\n    address oracle;\\n    uint8 userEModeCategory;\\n  }\\n\\n  struct ValidateBorrowParams {\\n    ReserveCache reserveCache;\\n    UserConfigurationMap userConfig;\\n    address asset;\\n    address userAddress;\\n    uint256 amount;\\n    InterestRateMode interestRateMode;\\n    uint256 maxStableLoanPercent;\\n    uint256 reservesCount;\\n    address oracle;\\n    uint8 userEModeCategory;\\n    address priceOracleSentinel;\\n    bool isolationModeActive;\\n    address isolationModeCollateralAddress;\\n    uint256 isolationModeDebtCeiling;\\n  }\\n\\n  struct ValidateLiquidationCallParams {\\n    ReserveCache debtReserveCache;\\n    uint256 totalDebt;\\n    uint256 healthFactor;\\n    address priceOracleSentinel;\\n  }\\n\\n  struct CalculateInterestRatesParams {\\n    uint256 unbacked;\\n    uint256 liquidityAdded;\\n    uint256 liquidityTaken;\\n    uint256 totalStableDebt;\\n    uint256 totalVariableDebt;\\n    uint256 averageStableBorrowRate;\\n    uint256 reserveFactor;\\n    address reserve;\\n    address aToken;\\n  }\\n\\n  struct InitReserveParams {\\n    address asset;\\n    address aTokenAddress;\\n    address stableDebtAddress;\\n    address variableDebtAddress;\\n    address interestRateStrategyAddress;\\n    uint16 reservesCount;\\n    uint16 maxNumberReserves;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBaseManager.sol\": {\r\n      \"content\": \"/*\\n    Copyright 2021 Set Labs Inc.\\n\\n    Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n    you may not use this file except in compliance with the License.\\n    You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n    Unless required by applicable law or agreed to in writing, software\\n    distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n    See the License for the specific language governing permissions and\\n    limitations under the License.\\n\\n    SPDX-License-Identifier: Apache License, Version 2.0\\n*/\\n\\npragma solidity 0.6.10;\\npragma experimental \\\"ABIEncoderV2\\\";\\n\\nimport { ISetToken } from \\\"./ISetToken.sol\\\";\\n\\ninterface IBaseManager {\\n    function setToken() external returns(ISetToken);\\n\\n    function methodologist() external returns(address);\\n\\n    function operator() external returns(address);\\n\\n    function interactManager(address _module, bytes calldata _encoded) external;\\n\\n    function transferTokens(address _token, address _destination, uint256 _amount) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IDebtIssuanceModule.sol\": {\r\n      \"content\": \"/*\\n    Copyright 2020 Set Labs Inc.\\n    Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n    you may not use this file except in compliance with the License.\\n    You may obtain a copy of the License at\\n    http://www.apache.org/licenses/LICENSE-2.0\\n    Unless required by applicable law or agreed to in writing, software\\n    distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n    See the License for the specific language governing permissions and\\n    limitations under the License.\\n    SPDX-License-Identifier: Apache License, Version 2.0\\n*/\\npragma solidity >=0.6.10;\\n\\nimport { ISetToken } from \\\"./ISetToken.sol\\\";\\nimport { IManagerIssuanceHook } from \\\"./IManagerIssuanceHook.sol\\\";\\n\\ninterface IDebtIssuanceModule {\\n    function getRequiredComponentIssuanceUnits(\\n        ISetToken _setToken,\\n        uint256 _quantity\\n    ) external view returns (address[] memory, uint256[] memory, uint256[] memory);\\n    function getRequiredComponentRedemptionUnits(\\n        ISetToken _setToken,\\n        uint256 _quantity\\n    ) external view returns (address[] memory, uint256[] memory, uint256[] memory);\\n    function issue(ISetToken _setToken, uint256 _quantity, address _to) external;\\n    function redeem(ISetToken _token, uint256 _quantity, address _to) external;\\n    function initialize(\\n        ISetToken _setToken,\\n        uint256 _maxManagerFee,\\n        uint256 _managerIssueFee,\\n        uint256 _managerRedeemFee,\\n        address _feeRecipient,\\n        IManagerIssuanceHook _managerIssuanceHook\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFlashLoanSimpleReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.6.10;\\n\\nimport {IPoolAddressesProvider} from \\\"./IPoolAddressesProvider.sol\\\";\\nimport {IPool} from \\\"./IPool.sol\\\";\\n\\n/**\\n * @title IFlashLoanSimpleReceiver\\n * @author Aave\\n * @notice Defines the basic interface of a flashloan-receiver contract.\\n * @dev Implement this interface to develop a flashloan-compatible flashLoanReceiver contract\\n */\\ninterface IFlashLoanSimpleReceiver {\\n  /**\\n   * @notice Executes an operation after receiving the flash-borrowed asset\\n   * @dev Ensure that the contract can return the debt + premium, e.g., has\\n   *      enough funds to repay and has approved the Pool to pull the total amount\\n   * @param asset The address of the flash-borrowed asset\\n   * @param amount The amount of the flash-borrowed asset\\n   * @param premium The fee of the flash-borrowed asset\\n   * @param initiator The address of the flashloan initiator\\n   * @param params The byte-encoded params passed when initiating the flashloan\\n   * @return True if the execution of the operation succeeds, false otherwise\\n   */\\n  function executeOperation(\\n    address asset,\\n    uint256 amount,\\n    uint256 premium,\\n    address initiator,\\n    bytes calldata params\\n  ) external returns (bool);\\n\\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\\n\\n  function POOL() external view returns (IPool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IManagerIssuanceHook.sol\": {\r\n      \"content\": \"/*\\n    Copyright 2020 Set Labs Inc.\\n\\n    Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n    you may not use this file except in compliance with the License.\\n    You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n    Unless required by applicable law or agreed to in writing, software\\n    distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n    See the License for the specific language governing permissions and\\n    limitations under the License.\\n\\n    SPDX-License-Identifier: Apache License, Version 2.0\\n*/\\npragma solidity 0.6.10;\\n\\nimport { ISetToken } from \\\"./ISetToken.sol\\\";\\n\\ninterface IManagerIssuanceHook {\\n    function invokePreIssueHook(ISetToken _setToken, uint256 _issueQuantity, address _sender, address _to) external;\\n    function invokePreRedeemHook(ISetToken _setToken, uint256 _redeemQuantity, address _sender, address _to) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPool.sol\": {\r\n      \"content\": \"pragma solidity 0.6.10;\\npragma experimental ABIEncoderV2;\\nimport { DataTypes } from \\\"./Datatypes.sol\\\";\\n\\ninterface IPool {\\n    event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\\n    event Borrow(\\n        address indexed reserve,\\n        address user,\\n        address indexed onBehalfOf,\\n        uint256 amount,\\n        uint8 interestRateMode,\\n        uint256 borrowRate,\\n        uint16 indexed referralCode\\n    );\\n    event FlashLoan(\\n        address indexed target,\\n        address initiator,\\n        address indexed asset,\\n        uint256 amount,\\n        uint8 interestRateMode,\\n        uint256 premium,\\n        uint16 indexed referralCode\\n    );\\n    event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\\n    event LiquidationCall(\\n        address indexed collateralAsset,\\n        address indexed debtAsset,\\n        address indexed user,\\n        uint256 debtToCover,\\n        uint256 liquidatedCollateralAmount,\\n        address liquidator,\\n        bool receiveAToken\\n    );\\n    event MintUnbacked(\\n        address indexed reserve, address user, address indexed onBehalfOf, uint256 amount, uint16 indexed referralCode\\n    );\\n    event MintedToTreasury(address indexed reserve, uint256 amountMinted);\\n    event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\\n    event Repay(\\n        address indexed reserve, address indexed user, address indexed repayer, uint256 amount, bool useATokens\\n    );\\n    event ReserveDataUpdated(\\n        address indexed reserve,\\n        uint256 liquidityRate,\\n        uint256 stableBorrowRate,\\n        uint256 variableBorrowRate,\\n        uint256 liquidityIndex,\\n        uint256 variableBorrowIndex\\n    );\\n    event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\\n    event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\\n    event Supply(\\n        address indexed reserve, address user, address indexed onBehalfOf, uint256 amount, uint16 indexed referralCode\\n    );\\n    event SwapBorrowRateMode(address indexed reserve, address indexed user, uint8 interestRateMode);\\n    event UserEModeSet(address indexed user, uint8 categoryId);\\n    event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\\n\\n    struct EModeCategory {\\n        uint16 ltv;\\n        uint16 liquidationThreshold;\\n        uint16 liquidationBonus;\\n        address priceSource;\\n        string label;\\n    }\\n\\n    struct ReserveConfigurationMap {\\n        uint256 data;\\n    }\\n\\n    struct ReserveData {\\n        ReserveConfigurationMap configuration;\\n        uint128 liquidityIndex;\\n        uint128 currentLiquidityRate;\\n        uint128 variableBorrowIndex;\\n        uint128 currentVariableBorrowRate;\\n        uint128 currentStableBorrowRate;\\n        uint40 lastUpdateTimestamp;\\n        uint16 id;\\n        address aTokenAddress;\\n        address stableDebtTokenAddress;\\n        address variableDebtTokenAddress;\\n        address interestRateStrategyAddress;\\n        uint128 accruedToTreasury;\\n        uint128 unbacked;\\n        uint128 isolationModeTotalDebt;\\n    }\\n\\n    struct UserConfigurationMap {\\n        uint256 data;\\n    }\\n\\n    function ADDRESSES_PROVIDER() external view returns (address);\\n    function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\\n    function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\\n    function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\\n    function MAX_NUMBER_RESERVES() external view returns (uint16);\\n    function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);\\n    function POOL_REVISION() external view returns (uint256);\\n    function backUnbacked(address asset, uint256 amount, uint256 fee) external returns (uint256);\\n    function borrow(address asset, uint256 amount, uint256 interestRateMode, uint16 referralCode, address onBehalfOf)\\n        external;\\n    function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory category) external;\\n    function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\\n    function dropReserve(address asset) external;\\n    function finalizeTransfer(\\n        address asset,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 balanceFromBefore,\\n        uint256 balanceToBefore\\n    ) external;\\n    function flashLoan(\\n        address receiverAddress,\\n        address[] memory assets,\\n        uint256[] memory amounts,\\n        uint256[] memory interestRateModes,\\n        address onBehalfOf,\\n        bytes memory params,\\n        uint16 referralCode\\n    ) external;\\n    function flashLoanSimple(\\n        address receiverAddress,\\n        address asset,\\n        uint256 amount,\\n        bytes memory params,\\n        uint16 referralCode\\n    ) external;\\n    function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);\\n    function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);\\n    function getReserveAddressById(uint16 id) external view returns (address);\\n    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\\n    function getReserveNormalizedIncome(address asset) external view returns (uint256);\\n    function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\\n    function getReservesList() external view returns (address[] memory);\\n    function getUserAccountData(address user)\\n        external\\n        view\\n        returns (\\n            uint256 totalCollateralBase,\\n            uint256 totalDebtBase,\\n            uint256 availableBorrowsBase,\\n            uint256 currentLiquidationThreshold,\\n            uint256 ltv,\\n            uint256 healthFactor\\n        );\\n    function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);\\n    function getUserEMode(address user) external view returns (uint256);\\n    function initReserve(\\n        address asset,\\n        address aTokenAddress,\\n        address stableDebtAddress,\\n        address variableDebtAddress,\\n        address interestRateStrategyAddress\\n    ) external;\\n    function initialize(address provider) external;\\n    function liquidationCall(\\n        address collateralAsset,\\n        address debtAsset,\\n        address user,\\n        uint256 debtToCover,\\n        bool receiveAToken\\n    ) external;\\n    function mintToTreasury(address[] memory assets) external;\\n    function mintUnbacked(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\\n    function rebalanceStableBorrowRate(address asset, address user) external;\\n    function repay(address asset, uint256 amount, uint256 interestRateMode, address onBehalfOf)\\n        external\\n        returns (uint256);\\n    function repayWithATokens(address asset, uint256 amount, uint256 interestRateMode) external returns (uint256);\\n    function repayWithPermit(\\n        address asset,\\n        uint256 amount,\\n        uint256 interestRateMode,\\n        address onBehalfOf,\\n        uint256 deadline,\\n        uint8 permitV,\\n        bytes32 permitR,\\n        bytes32 permitS\\n    ) external returns (uint256);\\n    function rescueTokens(address token, address to, uint256 amount) external;\\n    function resetIsolationModeTotalDebt(address asset) external;\\n    function setConfiguration(address asset, DataTypes.ReserveConfigurationMap memory configuration) external;\\n    function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress) external;\\n    function setUserEMode(uint8 categoryId) external;\\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\\n    function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\\n    function supplyWithPermit(\\n        address asset,\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint16 referralCode,\\n        uint256 deadline,\\n        uint8 permitV,\\n        bytes32 permitR,\\n        bytes32 permitS\\n    ) external;\\n    function swapBorrowRateMode(address asset, uint256 interestRateMode) external;\\n    function updateBridgeProtocolFee(uint256 protocolFee) external;\\n    function updateFlashloanPremiums(uint128 flashLoanPremiumTotal, uint128 flashLoanPremiumToProtocol) external;\\n    function withdraw(address asset, uint256 amount, address to) external returns (uint256);\\n}\\n\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolAddressesProvider.sol\": {\r\n      \"content\": \"pragma solidity 0.6.10;\\n\\ninterface IPoolAddressesProvider {\\n    event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\\n    event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\\n    event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\\n    event AddressSetAsProxy(\\n        bytes32 indexed id,\\n        address indexed proxyAddress,\\n        address oldImplementationAddress,\\n        address indexed newImplementationAddress\\n    );\\n    event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\\n    event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\\n    event PoolUpdated(address indexed oldAddress, address indexed newAddress);\\n    event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\\n    event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\\n    event ProxyCreated(bytes32 indexed id, address indexed proxyAddress, address indexed implementationAddress);\\n\\n    function getACLAdmin() external view returns (address);\\n    function getACLManager() external view returns (address);\\n    function getAddress(bytes32 id) external view returns (address);\\n    function getMarketId() external view returns (string memory);\\n    function getPool() external view returns (address);\\n    function getPoolConfigurator() external view returns (address);\\n    function getPoolDataProvider() external view returns (address);\\n    function getPriceOracle() external view returns (address);\\n    function getPriceOracleSentinel() external view returns (address);\\n    function owner() external view returns (address);\\n    function renounceOwnership() external;\\n    function setACLAdmin(address newAclAdmin) external;\\n    function setACLManager(address newAclManager) external;\\n    function setAddress(bytes32 id, address newAddress) external;\\n    function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\\n    function setMarketId(string memory newMarketId) external;\\n    function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\\n    function setPoolDataProvider(address newDataProvider) external;\\n    function setPoolImpl(address newPoolImpl) external;\\n    function setPriceOracle(address newPriceOracle) external;\\n    function setPriceOracleSentinel(address newPriceOracleSentinel) external;\\n    function transferOwnership(address newOwner) external;\\n}\\n\\n\"\r\n    },\r\n    \"contracts/interfaces/ISetToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache License, Version 2.0\\npragma solidity 0.6.10;\\npragma experimental \\\"ABIEncoderV2\\\";\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title ISetToken\\n * @author Set Protocol\\n *\\n * Interface for operating with SetTokens.\\n */\\ninterface ISetToken is IERC20 {\\n\\n    /* ============ Enums ============ */\\n\\n    enum ModuleState {\\n        NONE,\\n        PENDING,\\n        INITIALIZED\\n    }\\n\\n    /* ============ Structs ============ */\\n    /**\\n     * The base definition of a SetToken Position\\n     *\\n     * @param component           Address of token in the Position\\n     * @param module              If not in default state, the address of associated module\\n     * @param unit                Each unit is the # of components per 10^18 of a SetToken\\n     * @param positionState       Position ENUM. Default is 0; External is 1\\n     * @param data                Arbitrary data\\n     */\\n    struct Position {\\n        address component;\\n        address module;\\n        int256 unit;\\n        uint8 positionState;\\n        bytes data;\\n    }\\n\\n    /**\\n     * A struct that stores a component's cash position details and external positions\\n     * This data structure allows O(1) access to a component's cash position units and\\n     * virtual units.\\n     *\\n     * @param virtualUnit               Virtual value of a component's DEFAULT position. Stored as virtual for efficiency\\n     *                                  updating all units at once via the position multiplier. Virtual units are achieved\\n     *                                  by dividing a \\\"real\\\" value by the \\\"positionMultiplier\\\"\\n     * @param componentIndex\\n     * @param externalPositionModules   List of external modules attached to each external position. Each module\\n     *                                  maps to an external position\\n     * @param externalPositions         Mapping of module => ExternalPosition struct for a given component\\n     */\\n    struct ComponentPosition {\\n      int256 virtualUnit;\\n      address[] externalPositionModules;\\n      mapping(address => ExternalPosition) externalPositions;\\n    }\\n\\n    /**\\n     * A struct that stores a component's external position details including virtual unit and any\\n     * auxiliary data.\\n     *\\n     * @param virtualUnit       Virtual value of a component's EXTERNAL position.\\n     * @param data              Arbitrary data\\n     */\\n    struct ExternalPosition {\\n      int256 virtualUnit;\\n      bytes data;\\n    }\\n\\n\\n    /* ============ Functions ============ */\\n\\n    function addComponent(address _component) external;\\n    function removeComponent(address _component) external;\\n    function editDefaultPositionUnit(address _component, int256 _realUnit) external;\\n    function addExternalPositionModule(address _component, address _positionModule) external;\\n    function removeExternalPositionModule(address _component, address _positionModule) external;\\n    function editExternalPositionUnit(address _component, address _positionModule, int256 _realUnit) external;\\n    function editExternalPositionData(address _component, address _positionModule, bytes calldata _data) external;\\n\\n    function invoke(address _target, uint256 _value, bytes calldata _data) external returns(bytes memory);\\n\\n    function editPositionMultiplier(int256 _newMultiplier) external;\\n\\n    function mint(address _account, uint256 _quantity) external;\\n    function burn(address _account, uint256 _quantity) external;\\n\\n    function lock() external;\\n    function unlock() external;\\n\\n    function addModule(address _module) external;\\n    function removeModule(address _module) external;\\n    function initializeModule() external;\\n\\n    function setManager(address _manager) external;\\n\\n    function manager() external view returns (address);\\n    function moduleStates(address _module) external view returns (ModuleState);\\n    function getModules() external view returns (address[] memory);\\n\\n    function getDefaultPositionRealUnit(address _component) external view returns(int256);\\n    function getExternalPositionRealUnit(address _component, address _positionModule) external view returns(int256);\\n    function getComponents() external view returns(address[] memory);\\n    function getExternalPositionModules(address _component) external view returns(address[] memory);\\n    function getExternalPositionData(address _component, address _positionModule) external view returns(bytes memory);\\n    function isExternalPositionModule(address _component, address _module) external view returns(bool);\\n    function isComponent(address _component) external view returns(bool);\\n\\n    function positionMultiplier() external view returns (int256);\\n    function getPositions() external view returns (Position[] memory);\\n    function getTotalComponentRealUnits(address _component) external view returns(int256);\\n\\n    function isInitializedModule(address _module) external view returns(bool);\\n    function isPendingModule(address _module) external view returns(bool);\\n    function isLocked() external view returns (bool);\\n}\"\r\n    },\r\n    \"contracts/interfaces/ITradeModule.sol\": {\r\n      \"content\": \"/*\\n    Copyright 2022 Index Cooperative.\\n\\n    Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n    you may not use this file except in compliance with the License.\\n    You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n    Unless required by applicable law or agreed to in writing, software\\n    distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n    See the License for the specific language governing permissions and\\n    limitations under the License.\\n*/\\n\\npragma solidity 0.6.10;\\n\\nimport { ISetToken } from \\\"../interfaces/ISetToken.sol\\\";\\n\\ninterface ITradeModule {\\n    function initialize(ISetToken _setToken) external;\\n\\n    function trade(\\n        ISetToken _setToken,\\n        string memory _exchangeName,\\n        address _sendToken,\\n        uint256 _sendQuantity,\\n        address _receiveToken,\\n        uint256 _minReceiveQuantity,\\n        bytes memory _data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/external/uniswap-v3/INonfungiblePositionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.6.10;\\npragma experimental ABIEncoderV2;\\n\\n/// @title Non-fungible token for positions\\n/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred\\n/// and authorized.\\n/// https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/INonfungiblePositionManager.sol\\ninterface INonfungiblePositionManager {\\n    /// @notice Returns the position information associated with a given token ID.\\n    /// @dev Throws if the token ID is not valid.\\n    /// @param tokenId The ID of the token that represents the position\\n    /// @return nonce The nonce for permits\\n    /// @return operator The address that is approved for spending\\n    /// @return token0 The address of the token0 for a specific pool\\n    /// @return token1 The address of the token1 for a specific pool\\n    /// @return fee The fee associated with the pool\\n    /// @return tickLower The lower end of the tick range for the position\\n    /// @return tickUpper The higher end of the tick range for the position\\n    /// @return liquidity The liquidity of the position\\n    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position\\n    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position\\n    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation\\n    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation\\n    function positions(uint256 tokenId)\\n        external\\n        view\\n        returns (\\n            uint96 nonce,\\n            address operator,\\n            address token0,\\n            address token1,\\n            uint24 fee,\\n            int24 tickLower,\\n            int24 tickUpper,\\n            uint128 liquidity,\\n            uint256 feeGrowthInside0LastX128,\\n            uint256 feeGrowthInside1LastX128,\\n            uint128 tokensOwed0,\\n            uint128 tokensOwed1\\n        );\\n\\n    struct MintParams {\\n        address token0;\\n        address token1;\\n        uint24 fee;\\n        int24 tickLower;\\n        int24 tickUpper;\\n        uint256 amount0Desired;\\n        uint256 amount1Desired;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        address recipient;\\n        uint256 deadline;\\n    }\\n\\n    /// @notice Creates a new position wrapped in a NFT\\n    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized\\n    /// a method does not exist, i.e. the pool is assumed to be initialized.\\n    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata\\n    /// @return tokenId The ID of the token that represents the minted position\\n    /// @return liquidity The amount of liquidity for this position\\n    /// @return amount0 The amount of token0\\n    /// @return amount1 The amount of token1\\n    function mint(MintParams calldata params)\\n        external\\n        payable\\n        returns (\\n            uint256 tokenId,\\n            uint128 liquidity,\\n            uint256 amount0,\\n            uint256 amount1\\n        );\\n\\n    struct IncreaseLiquidityParams {\\n        uint256 tokenId;\\n        uint256 amount0Desired;\\n        uint256 amount1Desired;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        uint256 deadline;\\n    }\\n\\n    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\\n    /// @param params tokenId The ID of the token for which liquidity is being increased,\\n    /// amount0Desired The desired amount of token0 to be spent,\\n    /// amount1Desired The desired amount of token1 to be spent,\\n    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\\n    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\\n    /// deadline The time by which the transaction must be included to effect the change\\n    /// @return liquidity The new liquidity amount as a result of the increase\\n    /// @return amount0 The amount of token0 to acheive resulting liquidity\\n    /// @return amount1 The amount of token1 to acheive resulting liquidity\\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\\n        external\\n        payable\\n        returns (\\n            uint128 liquidity,\\n            uint256 amount0,\\n            uint256 amount1\\n        );\\n\\n    struct DecreaseLiquidityParams {\\n        uint256 tokenId;\\n        uint128 liquidity;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        uint256 deadline;\\n    }\\n\\n    /// @notice Decreases the amount of liquidity in a position and accounts it to the position\\n    /// @param params tokenId The ID of the token for which liquidity is being decreased,\\n    /// amount The amount by which liquidity will be decreased,\\n    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\\n    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\\n    /// deadline The time by which the transaction must be included to effect the change\\n    /// @return amount0 The amount of token0 accounted to the position's tokens owed\\n    /// @return amount1 The amount of token1 accounted to the position's tokens owed\\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\\n        external\\n        payable\\n        returns (uint256 amount0, uint256 amount1);\\n\\n    struct CollectParams {\\n        uint256 tokenId;\\n        address recipient;\\n        uint128 amount0Max;\\n        uint128 amount1Max;\\n    }\\n\\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\\n    /// @param params tokenId The ID of the NFT for which tokens are being collected,\\n    /// recipient The account that should receive the tokens,\\n    /// amount0Max The maximum amount of token0 to collect,\\n    /// amount1Max The maximum amount of token1 to collect\\n    /// @return amount0 The amount of fees collected in token0\\n    /// @return amount1 The amount of fees collected in token1\\n    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);\\n\\n    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens\\n    /// must be collected first.\\n    /// @param tokenId The ID of the token that is being burned\\n    function burn(uint256 tokenId) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/external/uniswap-v3/IUniswapV3Pool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.6.10;\\npragma experimental ABIEncoderV2;\\n\\n/// @title Permissionless pool actions\\n/// @notice Contains pool methods that can be called by anyone\\n/// https://github.com/Uniswap/v3-core/blob/main/contracts/interfaces/pool/IUniswapV3PoolActions.sol\\ninterface IUniswapV3Pool {\\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\\n    /// when accessed externally.\\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\\n    /// boundary.\\n    /// observationIndex The index of the last oracle observation that was written,\\n    /// observationCardinality The current maximum number of observations stored in the pool,\\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\\n    /// feeProtocol The protocol fee for both tokens of the pool.\\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\\n    /// unlocked Whether the pool is currently locked to reentrancy\\n    function slot0()\\n        external\\n        view\\n        returns (\\n            uint160 sqrtPriceX96,\\n            int24 tick,\\n            uint16 observationIndex,\\n            uint16 observationCardinality,\\n            uint16 observationCardinalityNext,\\n            uint8 feeProtocol,\\n            bool unlocked\\n        );\\n\\n    /// @notice Sets the initial price for the pool\\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\\n    function initialize(uint160 sqrtPriceX96) external;\\n\\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\\n    /// @param recipient The address for which the liquidity will be created\\n    /// @param tickLower The lower tick of the position in which to add liquidity\\n    /// @param tickUpper The upper tick of the position in which to add liquidity\\n    /// @param amount The amount of liquidity to mint\\n    /// @param data Any data that should be passed through to the callback\\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\\n    function mint(\\n        address recipient,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 amount,\\n        bytes calldata data\\n    ) external returns (uint256 amount0, uint256 amount1);\\n\\n    /// @notice Collects tokens owed to a position\\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\\n    /// @param recipient The address which should receive the fees collected\\n    /// @param tickLower The lower tick of the position for which to collect fees\\n    /// @param tickUpper The upper tick of the position for which to collect fees\\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\\n    /// @return amount0 The amount of fees collected in token0\\n    /// @return amount1 The amount of fees collected in token1\\n    function collect(\\n        address recipient,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 amount0Requested,\\n        uint128 amount1Requested\\n    ) external returns (uint128 amount0, uint128 amount1);\\n\\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\\n    /// @dev Fees must be collected separately via a call to #collect\\n    /// @param tickLower The lower tick of the position for which to burn liquidity\\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\\n    /// @param amount How much liquidity to burn\\n    /// @return amount0 The amount of token0 sent to the recipient\\n    /// @return amount1 The amount of token1 sent to the recipient\\n    function burn(\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 amount\\n    ) external returns (uint256 amount0, uint256 amount1);\\n\\n    /// @notice Swap token0 for token1, or token1 for token0\\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\\n    /// @param recipient The address to receive the output of the swap\\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\\n    /// @param data Any data to be passed through to the callback\\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\\n    function swap(\\n        address recipient,\\n        bool zeroForOne,\\n        int256 amountSpecified,\\n        uint160 sqrtPriceLimitX96,\\n        bytes calldata data\\n    ) external returns (int256 amount0, int256 amount1);\\n\\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\\n    /// @param recipient The address which will receive the token0 and token1 amounts\\n    /// @param amount0 The amount of token0 to send\\n    /// @param amount1 The amount of token1 to send\\n    /// @param data Any data to be passed through to the callback\\n    function flash(\\n        address recipient,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata data\\n    ) external;\\n\\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\\n    /// the input observationCardinalityNext.\\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/AddressArrayUtils.sol\": {\r\n      \"content\": \"/*\\n    Copyright 2020 Set Labs Inc.\\n\\n    Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n    you may not use this file except in compliance with the License.\\n    You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n    Unless required by applicable law or agreed to in writing, software\\n    distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n    See the License for the specific language governing permissions and\\n    limitations under the License.\\n\\n    SPDX-License-Identifier: Apache License, Version 2.0\\n*/\\n\\npragma solidity 0.6.10;\\n\\n/**\\n * @title AddressArrayUtils\\n * @author Set Protocol\\n *\\n * Utility functions to handle Address Arrays\\n *\\n * CHANGELOG:\\n * - 4/27/21: Added validatePairsWithArray methods\\n */\\nlibrary AddressArrayUtils {\\n\\n    /**\\n     * Finds the index of the first occurrence of the given element.\\n     * @param A The input array to search\\n     * @param a The value to find\\n     * @return Returns (index and isIn) for the first occurrence starting from index 0\\n     */\\n    function indexOf(address[] memory A, address a) internal pure returns (uint256, bool) {\\n        uint256 length = A.length;\\n        for (uint256 i = 0; i < length; i++) {\\n            if (A[i] == a) {\\n                return (i, true);\\n            }\\n        }\\n        return (uint256(-1), false);\\n    }\\n\\n    /**\\n    * Returns true if the value is present in the list. Uses indexOf internally.\\n    * @param A The input array to search\\n    * @param a The value to find\\n    * @return Returns isIn for the first occurrence starting from index 0\\n    */\\n    function contains(address[] memory A, address a) internal pure returns (bool) {\\n        (, bool isIn) = indexOf(A, a);\\n        return isIn;\\n    }\\n\\n    /**\\n    * Returns true if there are 2 elements that are the same in an array\\n    * @param A The input array to search\\n    * @return Returns boolean for the first occurrence of a duplicate\\n    */\\n    function hasDuplicate(address[] memory A) internal pure returns(bool) {\\n        require(A.length > 0, \\\"A is empty\\\");\\n\\n        for (uint256 i = 0; i < A.length - 1; i++) {\\n            address current = A[i];\\n            for (uint256 j = i + 1; j < A.length; j++) {\\n                if (current == A[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @param A The input array to search\\n     * @param a The address to remove\\n     * @return Returns the array with the object removed.\\n     */\\n    function remove(address[] memory A, address a)\\n        internal\\n        pure\\n        returns (address[] memory)\\n    {\\n        (uint256 index, bool isIn) = indexOf(A, a);\\n        if (!isIn) {\\n            revert(\\\"Address not in array.\\\");\\n        } else {\\n            (address[] memory _A,) = pop(A, index);\\n            return _A;\\n        }\\n    }\\n\\n    /**\\n     * @param A The input array to search\\n     * @param a The address to remove\\n     */\\n    function removeStorage(address[] storage A, address a)\\n        internal\\n    {\\n        (uint256 index, bool isIn) = indexOf(A, a);\\n        if (!isIn) {\\n            revert(\\\"Address not in array.\\\");\\n        } else {\\n            uint256 lastIndex = A.length - 1; // If the array would be empty, the previous line would throw, so no underflow here\\n            if (index != lastIndex) { A[index] = A[lastIndex]; }\\n            A.pop();\\n        }\\n    }\\n\\n    /**\\n    * Removes specified index from array\\n    * @param A The input array to search\\n    * @param index The index to remove\\n    * @return Returns the new array and the removed entry\\n    */\\n    function pop(address[] memory A, uint256 index)\\n        internal\\n        pure\\n        returns (address[] memory, address)\\n    {\\n        uint256 length = A.length;\\n        require(index < A.length, \\\"Index must be < A length\\\");\\n        address[] memory newAddresses = new address[](length - 1);\\n        for (uint256 i = 0; i < index; i++) {\\n            newAddresses[i] = A[i];\\n        }\\n        for (uint256 j = index + 1; j < length; j++) {\\n            newAddresses[j - 1] = A[j];\\n        }\\n        return (newAddresses, A[index]);\\n    }\\n\\n    /**\\n     * Returns the combination of the two arrays\\n     * @param A The first array\\n     * @param B The second array\\n     * @return Returns A extended by B\\n     */\\n    function extend(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\\n        uint256 aLength = A.length;\\n        uint256 bLength = B.length;\\n        address[] memory newAddresses = new address[](aLength + bLength);\\n        for (uint256 i = 0; i < aLength; i++) {\\n            newAddresses[i] = A[i];\\n        }\\n        for (uint256 j = 0; j < bLength; j++) {\\n            newAddresses[aLength + j] = B[j];\\n        }\\n        return newAddresses;\\n    }\\n\\n    /**\\n     * Validate that address and uint array lengths match. Validate address array is not empty\\n     * and contains no duplicate elements.\\n     *\\n     * @param A         Array of addresses\\n     * @param B         Array of uint\\n     */\\n    function validatePairsWithArray(address[] memory A, uint[] memory B) internal pure {\\n        require(A.length == B.length, \\\"Array length mismatch\\\");\\n        _validateLengthAndUniqueness(A);\\n    }\\n\\n    /**\\n     * Validate that address and bool array lengths match. Validate address array is not empty\\n     * and contains no duplicate elements.\\n     *\\n     * @param A         Array of addresses\\n     * @param B         Array of bool\\n     */\\n    function validatePairsWithArray(address[] memory A, bool[] memory B) internal pure {\\n        require(A.length == B.length, \\\"Array length mismatch\\\");\\n        _validateLengthAndUniqueness(A);\\n    }\\n\\n    /**\\n     * Validate that address and string array lengths match. Validate address array is not empty\\n     * and contains no duplicate elements.\\n     *\\n     * @param A         Array of addresses\\n     * @param B         Array of strings\\n     */\\n    function validatePairsWithArray(address[] memory A, string[] memory B) internal pure {\\n        require(A.length == B.length, \\\"Array length mismatch\\\");\\n        _validateLengthAndUniqueness(A);\\n    }\\n\\n    /**\\n     * Validate that address array lengths match, and calling address array are not empty\\n     * and contain no duplicate elements.\\n     *\\n     * @param A         Array of addresses\\n     * @param B         Array of addresses\\n     */\\n    function validatePairsWithArray(address[] memory A, address[] memory B) internal pure {\\n        require(A.length == B.length, \\\"Array length mismatch\\\");\\n        _validateLengthAndUniqueness(A);\\n    }\\n\\n    /**\\n     * Validate that address and bytes array lengths match. Validate address array is not empty\\n     * and contains no duplicate elements.\\n     *\\n     * @param A         Array of addresses\\n     * @param B         Array of bytes\\n     */\\n    function validatePairsWithArray(address[] memory A, bytes[] memory B) internal pure {\\n        require(A.length == B.length, \\\"Array length mismatch\\\");\\n        _validateLengthAndUniqueness(A);\\n    }\\n\\n    /**\\n     * Validate address array is not empty and contains no duplicate elements.\\n     *\\n     * @param A          Array of addresses\\n     */\\n    function _validateLengthAndUniqueness(address[] memory A) internal pure {\\n        require(A.length > 0, \\\"Array length must be > 0\\\");\\n        require(!hasDuplicate(A), \\\"Cannot duplicate addresses\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/BaseExtension.sol\": {\r\n      \"content\": \"/*\\n    Copyright 2021 Set Labs Inc.\\n\\n    Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n    you may not use this file except in compliance with the License.\\n    You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n    Unless required by applicable law or agreed to in writing, software\\n    distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n    See the License for the specific language governing permissions and\\n    limitations under the License.\\n\\n    SPDX-License-Identifier: Apache License, Version 2.0\\n*/\\n\\npragma solidity 0.6.10;\\n\\nimport { AddressArrayUtils } from \\\"../lib/AddressArrayUtils.sol\\\";\\nimport { IBaseManager } from \\\"../interfaces/IBaseManager.sol\\\";\\n\\n/**\\n * @title BaseExtension\\n * @author Set Protocol\\n *\\n * Abstract class that houses common extension-related state and functions.\\n */\\nabstract contract BaseExtension {\\n    using AddressArrayUtils for address[];\\n\\n    /* ============ Events ============ */\\n\\n    event CallerStatusUpdated(address indexed _caller, bool _status);\\n    event AnyoneCallableUpdated(bool indexed _status);\\n\\n    /* ============ Modifiers ============ */\\n\\n    /**\\n     * Throws if the sender is not the SetToken operator\\n     */\\n    modifier onlyOperator() {\\n        require(msg.sender == manager.operator(), \\\"Must be operator\\\");\\n        _;\\n    }\\n\\n    /**\\n     * Throws if the sender is not the SetToken methodologist\\n     */\\n    modifier onlyMethodologist() {\\n        require(msg.sender == manager.methodologist(), \\\"Must be methodologist\\\");\\n        _;\\n    }\\n\\n    /**\\n     * Throws if caller is a contract, can be used to stop flash loan and sandwich attacks\\n     */\\n    modifier onlyEOA() {\\n        require(msg.sender == tx.origin, \\\"Caller must be EOA Address\\\");\\n        _;\\n    }\\n\\n    /**\\n     * Throws if not allowed caller\\n     */\\n    modifier onlyAllowedCaller(address _caller) {\\n        require(isAllowedCaller(_caller), \\\"Address not permitted to call\\\");\\n        _;\\n    }\\n\\n    /* ============ State Variables ============ */\\n\\n    // Instance of manager contract\\n    IBaseManager public manager;\\n\\n    // Boolean indicating if anyone can call function\\n    bool public anyoneCallable;\\n\\n    // Mapping of addresses allowed to call function\\n    mapping(address => bool) public callAllowList;\\n\\n    /* ============ Constructor ============ */\\n\\n    constructor(IBaseManager _manager) public { manager = _manager; }\\n\\n    /* ============ External Functions ============ */\\n\\n    /**\\n     * OPERATOR ONLY: Toggle ability for passed addresses to call only allowed caller functions\\n     *\\n     * @param _callers           Array of caller addresses to toggle status\\n     * @param _statuses          Array of statuses for each caller\\n     */\\n    function updateCallerStatus(address[] calldata _callers, bool[] calldata _statuses) external onlyOperator {\\n        require(_callers.length == _statuses.length, \\\"Array length mismatch\\\");\\n        require(_callers.length > 0, \\\"Array length must be > 0\\\");\\n        require(!_callers.hasDuplicate(), \\\"Cannot duplicate callers\\\");\\n\\n        for (uint256 i = 0; i < _callers.length; i++) {\\n            address caller = _callers[i];\\n            bool status = _statuses[i];\\n            callAllowList[caller] = status;\\n            emit CallerStatusUpdated(caller, status);\\n        }\\n    }\\n\\n    /**\\n     * OPERATOR ONLY: Toggle whether anyone can call function, bypassing the callAllowlist\\n     *\\n     * @param _status           Boolean indicating whether to allow anyone call\\n     */\\n    function updateAnyoneCallable(bool _status) external onlyOperator {\\n        anyoneCallable = _status;\\n        emit AnyoneCallableUpdated(_status);\\n    }\\n\\n    /* ============ Internal Functions ============ */\\n\\n    /**\\n     * Invoke manager to transfer tokens from manager to other contract.\\n     *\\n     * @param _token           Token being transferred from manager contract\\n     * @param _amount          Amount of token being transferred\\n     */\\n    function invokeManagerTransfer(address _token, address _destination, uint256 _amount) internal {\\n        manager.transferTokens(_token, _destination, _amount);\\n    }\\n\\n    /**\\n     * Invoke call from manager\\n     *\\n     * @param _module           Module to interact with\\n     * @param _encoded          Encoded byte data\\n     */\\n    function invokeManager(address _module, bytes memory _encoded) internal {\\n        manager.interactManager(_module, _encoded);\\n    }\\n\\n    /**\\n     * Determine if passed address is allowed to call function. If anyoneCallable set to true anyone can call otherwise needs to be approved.\\n     *\\n     * return bool              Boolean indicating if allowed caller\\n     */\\n    function isAllowedCaller(address _caller) internal view virtual returns (bool) {\\n        return anyoneCallable || callAllowList[_caller];\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/FlashLoanSimpleReceiverBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.6.10;\\n\\nimport {IFlashLoanSimpleReceiver} from \\\"../interfaces/IFlashLoanSimpleReceiver.sol\\\";\\nimport {IPoolAddressesProvider} from \\\"../interfaces/IPoolAddressesProvider.sol\\\";\\nimport {IPool} from \\\"../interfaces/IPool.sol\\\";\\n\\n/**\\n * @title FlashLoanSimpleReceiverBase\\n * @author Aave\\n * @notice Base contract to develop a flashloan-receiver contract.\\n */\\nabstract contract FlashLoanSimpleReceiverBase is IFlashLoanSimpleReceiver {\\n  IPoolAddressesProvider public immutable override ADDRESSES_PROVIDER;\\n  IPool public immutable override POOL;\\n\\n  constructor(IPoolAddressesProvider provider) public {\\n    ADDRESSES_PROVIDER = provider;\\n    POOL = IPool(provider.getPool());\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/PreciseUnitMath.sol\": {\r\n      \"content\": \"/*\\n    Copyright 2020 Set Labs Inc.\\n\\n    Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n    you may not use this file except in compliance with the License.\\n    You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n    Unless required by applicable law or agreed to in writing, software\\n    distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n    See the License for the specific language governing permissions and\\n    limitations under the License.\\n\\n    SPDX-License-Identifier: Apache License, Version 2.0\\n*/\\n\\npragma solidity 0.6.10;\\npragma experimental ABIEncoderV2;\\n\\nimport { SafeMath } from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport { SignedSafeMath } from \\\"@openzeppelin/contracts/math/SignedSafeMath.sol\\\";\\n\\n\\n/**\\n * @title PreciseUnitMath\\n * @author Set Protocol\\n *\\n * Arithmetic for fixed-point numbers with 18 decimals of precision. Some functions taken from\\n * dYdX's BaseMath library.\\n *\\n * CHANGELOG:\\n * - 9/21/20: Added safePower function\\n */\\nlibrary PreciseUnitMath {\\n    using SafeMath for uint256;\\n    using SignedSafeMath for int256;\\n\\n    // The number One in precise units.\\n    uint256 constant internal PRECISE_UNIT = 10 ** 18;\\n    int256 constant internal PRECISE_UNIT_INT = 10 ** 18;\\n\\n    // Max unsigned integer value\\n    uint256 constant internal MAX_UINT_256 = type(uint256).max;\\n    // Max and min signed integer value\\n    int256 constant internal MAX_INT_256 = type(int256).max;\\n    int256 constant internal MIN_INT_256 = type(int256).min;\\n\\n    /**\\n     * @dev Getter function since constants can't be read directly from libraries.\\n     */\\n    function preciseUnit() internal pure returns (uint256) {\\n        return PRECISE_UNIT;\\n    }\\n\\n    /**\\n     * @dev Getter function since constants can't be read directly from libraries.\\n     */\\n    function preciseUnitInt() internal pure returns (int256) {\\n        return PRECISE_UNIT_INT;\\n    }\\n\\n    /**\\n     * @dev Getter function since constants can't be read directly from libraries.\\n     */\\n    function maxUint256() internal pure returns (uint256) {\\n        return MAX_UINT_256;\\n    }\\n\\n    /**\\n     * @dev Getter function since constants can't be read directly from libraries.\\n     */\\n    function maxInt256() internal pure returns (int256) {\\n        return MAX_INT_256;\\n    }\\n\\n    /**\\n     * @dev Getter function since constants can't be read directly from libraries.\\n     */\\n    function minInt256() internal pure returns (int256) {\\n        return MIN_INT_256;\\n    }\\n\\n    /**\\n     * @dev Multiplies value a by value b (result is rounded down). It's assumed that the value b is the significand\\n     * of a number with 18 decimals precision.\\n     */\\n    function preciseMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a.mul(b).div(PRECISE_UNIT);\\n    }\\n\\n    /**\\n     * @dev Multiplies value a by value b (result is rounded towards zero). It's assumed that the value b is the\\n     * significand of a number with 18 decimals precision.\\n     */\\n    function preciseMul(int256 a, int256 b) internal pure returns (int256) {\\n        return a.mul(b).div(PRECISE_UNIT_INT);\\n    }\\n\\n    /**\\n     * @dev Multiplies value a by value b (result is rounded up). It's assumed that the value b is the significand\\n     * of a number with 18 decimals precision.\\n     */\\n    function preciseMulCeil(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0 || b == 0) {\\n            return 0;\\n        }\\n        return a.mul(b).sub(1).div(PRECISE_UNIT).add(1);\\n    }\\n\\n    /**\\n     * @dev Divides value a by value b (result is rounded down).\\n     */\\n    function preciseDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a.mul(PRECISE_UNIT).div(b);\\n    }\\n\\n\\n    /**\\n     * @dev Divides value a by value b (result is rounded towards 0).\\n     */\\n    function preciseDiv(int256 a, int256 b) internal pure returns (int256) {\\n        return a.mul(PRECISE_UNIT_INT).div(b);\\n    }\\n\\n    /**\\n     * @dev Divides value a by value b (result is rounded up or away from 0).\\n     */\\n    function preciseDivCeil(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"Cant divide by 0\\\");\\n\\n        return a > 0 ? a.mul(PRECISE_UNIT).sub(1).div(b).add(1) : 0;\\n    }\\n\\n    /**\\n     * @dev Divides value a by value b (result is rounded down - positive numbers toward 0 and negative away from 0).\\n     */\\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, \\\"Cant divide by 0\\\");\\n        require(a != MIN_INT_256 || b != -1, \\\"Invalid input\\\");\\n\\n        int256 result = a.div(b);\\n        if (a ^ b < 0 && a % b != 0) {\\n            result -= 1;\\n        }\\n\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Multiplies value a by value b where rounding is towards the lesser number. \\n     * (positive values are rounded towards zero and negative values are rounded away from 0). \\n     */\\n    function conservativePreciseMul(int256 a, int256 b) internal pure returns (int256) {\\n        return divDown(a.mul(b), PRECISE_UNIT_INT);\\n    }\\n\\n    /**\\n     * @dev Divides value a by value b where rounding is towards the lesser number. \\n     * (positive values are rounded towards zero and negative values are rounded away from 0). \\n     */\\n    function conservativePreciseDiv(int256 a, int256 b) internal pure returns (int256) {\\n        return divDown(a.mul(PRECISE_UNIT_INT), b);\\n    }\\n\\n    /**\\n    * @dev Performs the power on a specified value, reverts on overflow.\\n    */\\n    function safePower(\\n        uint256 a,\\n        uint256 pow\\n    )\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        require(a > 0, \\\"Value must be positive\\\");\\n\\n        uint256 result = 1;\\n        for (uint256 i = 0; i < pow; i++){\\n            uint256 previousResult = result;\\n\\n            // Using safemath multiplication prevents overflows\\n            result = previousResult.mul(a);\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IBaseManager\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_underlyingToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_aaveToken\",\"type\":\"address\"},{\"internalType\":\"contract ISetToken\",\"name\":\"_wrappedSetToken\",\"type\":\"address\"},{\"internalType\":\"contract ITradeModule\",\"name\":\"_tradeModule\",\"type\":\"address\"},{\"internalType\":\"contract IDebtIssuanceModule\",\"name\":\"_issuanceModule\",\"type\":\"address\"},{\"internalType\":\"contract INonfungiblePositionManager\",\"name\":\"_nonfungiblePositionManager\",\"type\":\"address\"},{\"internalType\":\"contract IPoolAddressesProvider\",\"name\":\"_addressProvider\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"AnyoneCallableUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"CallerStatusUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADDRESSES_PROVIDER\",\"outputs\":[{\"internalType\":\"contract IPoolAddressesProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"POOL\",\"outputs\":[{\"internalType\":\"contract IPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aaveToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"anyoneCallable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"callAllowList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"_liquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"_amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount1Min\",\"type\":\"uint256\"}],\"name\":\"decreaseLiquidityPosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"premium\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"executeOperation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount0Desired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount1Desired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount1Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isUnderlyingToken0\",\"type\":\"bool\"}],\"name\":\"increaseLiquidityPosition\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"issuanceModule\",\"outputs\":[{\"internalType\":\"contract IDebtIssuanceModule\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"contract IBaseManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"supplyLiquidityAmount0Desired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyLiquidityAmount1Desired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyLiquidityAmount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyLiquidityAmount1Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"exchangeName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"underlyingTradeUnits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wrappedSetTokenTradeUnits\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"exchangeData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"redeemLiquidityAmount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redeemLiquidityAmount1Min\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnderlyingToken0\",\"type\":\"bool\"}],\"internalType\":\"struct AaveMigrationExtension.DecodedParams\",\"name\":\"_decodedParams\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_underlyingLoanAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxSubsidy\",\"type\":\"uint256\"}],\"name\":\"migrate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingOutputAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount0Desired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount1Desired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount1Min\",\"type\":\"uint256\"},{\"internalType\":\"int24\",\"name\":\"_tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"_tickUpper\",\"type\":\"int24\"},{\"internalType\":\"uint24\",\"name\":\"_fee\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"_isUnderlyingToken0\",\"type\":\"bool\"}],\"name\":\"mintLiquidityPosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonfungiblePositionManager\",\"outputs\":[{\"internalType\":\"contract INonfungiblePositionManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setToken\",\"outputs\":[{\"internalType\":\"contract ISetToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"sweepTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_exchangeName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_sendToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sendQuantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiveToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minReceiveQuantity\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"trade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradeModule\",\"outputs\":[{\"internalType\":\"contract ITradeModule\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"updateAnyoneCallable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_callers\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"_statuses\",\"type\":\"bool[]\"}],\"name\":\"updateCallerStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrappedSetToken\",\"outputs\":[{\"internalType\":\"contract ISetToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AaveMigrationExtension", "CompilerVersion": "v0.6.10+commit.00c0fcaf", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000003b439351177fc9d7b5fd11aedcc177d73f9893410000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c5990000000000000000000000005ee5bf7ae06d1be5997a1a72006fe6c607ec6de8000000000000000000000000d2ac55ca3bbd2dd1e9936ec640dcb4b745fde75900000000000000000000000090f765f63e7dc5ae97d6c576bf693fb6af41c12900000000000000000000000004b59f9f09750c044d7cfbc177561e409085f0f3000000000000000000000000c36442b4a4522e871399cd717abdd847ab11fe880000000000000000000000002f39d218133afab8f2b819b1066c7e434ad94e9e", "EVMVersion": "istanbul", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": ""}