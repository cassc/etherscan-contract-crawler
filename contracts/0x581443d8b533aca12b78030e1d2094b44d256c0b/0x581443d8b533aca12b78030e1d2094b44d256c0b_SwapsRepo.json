{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/lib/SwapsRepo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nlibrary SwapsRepo {\\n\\n    enum StateOfSwap {\\n        Pending,    \\n        Issued,\\n        Closed,\\n        Terminated\\n    }\\n\\n    struct Swap {\\n        uint16 seqOfSwap;\\n        uint32 seqOfPledge;\\n        uint64 paidOfPledge;\\n        uint32 seqOfTarget;\\n        uint64 paidOfTarget;\\n        uint32 priceOfDeal;\\n        bool isPutOpt;\\n        uint8 state;\\n    }\\n\\n    struct Repo {\\n        // seqOfSwap => Swap\\n        mapping(uint256 => Swap) swaps;\\n    }\\n\\n    // ###############\\n    // ##  Modifier ##\\n    // ###############\\n\\n    modifier swapExist(Repo storage repo, uint seqOfSwap) {\\n        require (isSwap(repo, seqOfSwap), \\\"SR.swapExist: not\\\");\\n        _;\\n    }\\n\\n    // ###############\\n    // ## Write I/O ##\\n    // ###############\\n\\n    // ==== cofify / parser ====\\n\\n    function codifySwap(Swap memory swap) public pure returns (bytes32 sn) {\\n        bytes memory _sn = abi.encodePacked(\\n                            swap.seqOfSwap,\\n                            swap.seqOfPledge,\\n                            swap.paidOfPledge,\\n                            swap.seqOfTarget,\\n                            swap.paidOfTarget,\\n                            swap.priceOfDeal,\\n                            swap.isPutOpt,\\n                            swap.state);\\n        assembly {\\n            sn := mload(add(_sn, 0x20))\\n        }\\n    }\\n\\n    function regSwap(\\n        Repo storage repo,\\n        Swap memory swap\\n    ) public returns(Swap memory) {\\n\\n        require(swap.seqOfTarget * swap.paidOfTarget * swap.seqOfPledge > 0,\\n            \\\"SWR.regSwap: zero para\\\");\\n\\n        swap.seqOfSwap = _increaseCounter(repo);\\n\\n        repo.swaps[swap.seqOfSwap] = swap;\\n        repo.swaps[0].paidOfTarget += swap.paidOfTarget;\\n\\n        return swap;\\n    }\\n\\n    function payOffSwap(\\n        Repo storage repo,\\n        uint seqOfSwap,\\n        uint msgValue,\\n        uint centPrice\\n    ) public returns (Swap memory ) {\\n\\n        Swap storage swap = repo.swaps[seqOfSwap];\\n\\n        require(swap.state == uint8(StateOfSwap.Issued), \\n            \\\"SWR.payOffSwap: wrong state\\\");\\n\\n        require (uint(swap.paidOfTarget) * uint(swap.priceOfDeal) * centPrice / 100 <= msgValue, \\\"SWR.payOffSwap: insufficient amt\\\");\\n\\n        swap.state = uint8(StateOfSwap.Closed);\\n\\n        return swap;\\n    }\\n\\n    function terminateSwap(\\n        Repo storage repo,\\n        uint seqOfSwap\\n    ) public returns (Swap memory){\\n\\n        Swap storage swap = repo.swaps[seqOfSwap];\\n\\n        require(swap.state == uint8(StateOfSwap.Issued), \\n            \\\"SWR.terminateSwap: wrong state\\\");\\n\\n        swap.state = uint8(StateOfSwap.Terminated);\\n\\n        return swap;\\n    }\\n\\n    // ==== Counter ====\\n\\n    function _increaseCounter(Repo storage repo) private returns(uint16) {\\n        repo.swaps[0].seqOfSwap++;\\n        return repo.swaps[0].seqOfSwap;\\n    } \\n\\n    // ################\\n    // ##  \u67e5\u8be2\u63a5\u53e3   ##\\n    // ################\\n\\n    function counterOfSwaps(Repo storage repo)\\n        public view returns (uint16)\\n    {\\n        return repo.swaps[0].seqOfSwap;\\n    }\\n\\n    function sumPaidOfTarget(Repo storage repo)\\n        public view returns (uint64)\\n    {\\n        return repo.swaps[0].paidOfTarget;\\n    }\\n\\n    function isSwap(Repo storage repo, uint256 seqOfSwap)\\n        public view returns (bool)\\n    {\\n        return seqOfSwap <= counterOfSwaps(repo);\\n    }\\n\\n    function getSwap(Repo storage repo, uint256 seqOfSwap)\\n        public view swapExist(repo, seqOfSwap) returns (Swap memory)\\n    {\\n        return repo.swaps[seqOfSwap];\\n    }\\n\\n    function checkValueOfSwap(\\n        Repo storage repo,\\n        uint seqOfSwap,\\n        uint centPrice\\n    ) public view returns (uint) {\\n        Swap memory swap = getSwap(repo, seqOfSwap);\\n        return uint(swap.paidOfTarget) * uint(swap.priceOfDeal) * centPrice / 100;\\n    }\\n\\n    function getAllSwaps(Repo storage repo)\\n        public view returns (Swap[] memory )\\n    {\\n        uint256 len = counterOfSwaps(repo);\\n        Swap[] memory swaps = new Swap[](len);\\n\\n        while (len > 0) {\\n            swaps[len-1] = repo.swaps[len];\\n            len--;\\n        }\\n        return swaps;\\n    }\\n\\n    function allSwapsClosed(Repo storage repo)\\n        public view returns (bool)\\n    {\\n        uint256 len = counterOfSwaps(repo);\\n        while (len > 0) {\\n            if (repo.swaps[len].state < uint8(StateOfSwap.Closed))\\n                return false;\\n            len--;\\n        }\\n\\n        return true;        \\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"seqOfSwap\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"seqOfPledge\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"paidOfPledge\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"seqOfTarget\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"paidOfTarget\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"priceOfDeal\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isPutOpt\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"state\",\"type\":\"uint8\"}],\"internalType\":\"struct SwapsRepo.Swap\",\"name\":\"swap\",\"type\":\"tuple\"}],\"name\":\"codifySwap\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"sn\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "SwapsRepo", "CompilerVersion": "v0.8.8+commit.dddeac2f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}