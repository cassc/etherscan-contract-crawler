{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Dependencies/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// Code from https://github.com/smartcontractkit/chainlink/blob/master/evm-contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\ninterface AggregatorV3Interface {\\r\\n\\r\\n  function decimals() external view returns (uint8);\\r\\n  function description() external view returns (string memory);\\r\\n  function version() external view returns (uint256);\\r\\n\\r\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\r\\n  // if they do not have data to report, instead of returning unset values\\r\\n  // which could be misinterpreted as actual reported values.\\r\\n  function getRoundData(uint80 _roundId)\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint80 roundId,\\r\\n      int256 answer,\\r\\n      uint256 startedAt,\\r\\n      uint256 updatedAt,\\r\\n      uint80 answeredInRound\\r\\n    );\\r\\n\\r\\n  function latestRoundData()\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint80 roundId,\\r\\n      int256 answer,\\r\\n      uint256 startedAt,\\r\\n      uint256 updatedAt,\\r\\n      uint80 answeredInRound\\r\\n    );\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Dependencies/BaseMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\n\\r\\ncontract BaseMath {\\r\\n    uint256 constant public DECIMAL_PRECISION = 1e18;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Dependencies/CheckContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\n\\r\\ncontract CheckContract {\\r\\n    /**\\r\\n     * Check that the account is an already deployed non-destroyed contract.\\r\\n     * See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L12\\r\\n     */\\r\\n    function checkContract(address _account) internal view {\\r\\n        require(_account != address(0), \\\"Account cannot be zero address\\\");\\r\\n\\r\\n        uint256 size;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { size := extcodesize(_account) }\\r\\n        require(size > 0, \\\"Account code size cannot be zero\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Dependencies/LiquityMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nlibrary LiquityMath {\\r\\n\\r\\n    uint256 internal constant DECIMAL_PRECISION = 1e18;\\r\\n\\r\\n    /* Precision for Nominal ICR (independent of price). Rationale for the value:\\r\\n     *\\r\\n     * - Making it \u201ctoo high\u201d could lead to overflows.\\r\\n     * - Making it \u201ctoo low\u201d could lead to an ICR equal to zero, due to truncation from Solidity floor division.\\r\\n     *\\r\\n     * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39 ETH,\\r\\n     * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\\r\\n     *\\r\\n     */\\r\\n    uint256 internal constant NICR_PRECISION = 1e20;\\r\\n\\r\\n    function _min(uint256 _a, uint256 _b) internal pure returns (uint) {\\r\\n        return (_a < _b) ? _a : _b;\\r\\n    }\\r\\n\\r\\n    function _max(uint256 _a, uint256 _b) internal pure returns (uint) {\\r\\n        return (_a >= _b) ? _a : _b;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    * Multiply two decimal numbers and use normal rounding rules:\\r\\n    * -round product up if 19'th mantissa digit >= 5\\r\\n    * -round product down if 19'th mantissa digit < 5\\r\\n    *\\r\\n    * Used only inside the exponentiation, _decPow().\\r\\n    */\\r\\n    function decMul(uint256 x, uint256 y) internal pure returns (uint256 decProd) {\\r\\n        uint256 prod_xy = x * y;\\r\\n\\r\\n        decProd = (prod_xy + (DECIMAL_PRECISION / 2)) / DECIMAL_PRECISION;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\\r\\n    *\\r\\n    * Uses the efficient \\\"exponentiation by squaring\\\" algorithm. O(log(n)) complexity.\\r\\n    *\\r\\n    * Called by one function that represent time in units of minutes:\\r\\n    * 1) TroveManager._calcDecayedBaseRate\\r\\n    *\\r\\n    * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\\r\\n    * \\\"minutes in 1000 years\\\": 60 * 24 * 365 * 1000\\r\\n    *\\r\\n    * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\\r\\n    * negligibly different from just passing the cap, since:\\r\\n    *\\r\\n    * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\\r\\n    * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\\r\\n    */\\r\\n    function _decPow(uint256 _base, uint256 _minutes) internal pure returns (uint) {\\r\\n\\r\\n        if (_minutes > 525600000) {_minutes = 525600000;}  // cap to avoid overflow\\r\\n\\r\\n        if (_minutes == 0) {return DECIMAL_PRECISION;}\\r\\n\\r\\n        uint256 y = DECIMAL_PRECISION;\\r\\n        uint256 x = _base;\\r\\n        uint256 n = _minutes;\\r\\n\\r\\n        // Exponentiation-by-squaring\\r\\n        while (n > 1) {\\r\\n            if (n % 2 == 0) {\\r\\n                x = decMul(x, x);\\r\\n                n = n / 2;\\r\\n            } else { // if (n % 2 != 0)\\r\\n                y = decMul(x, y);\\r\\n                x = decMul(x, x);\\r\\n                n = (n - 1) / 2;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return decMul(x, y);\\r\\n  }\\r\\n\\r\\n    function _getAbsoluteDifference(uint256 _a, uint256 _b) internal pure returns (uint) {\\r\\n        return (_a >= _b) ? _a - _b : _b - _a;\\r\\n    }\\r\\n\\r\\n    function _computeNominalCR(uint256 _coll, uint256 _debt) internal pure returns (uint) {\\r\\n        if (_debt > 0) {\\r\\n            return _coll * NICR_PRECISION / _debt;\\r\\n        }\\r\\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \\\"infinite\\\" CR.\\r\\n        else { // if (_debt == 0)\\r\\n            return type(uint256).max;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _computeCR(uint256 _coll, uint256 _debt, uint256 _price) internal pure returns (uint) {\\r\\n        if (_debt > 0) {\\r\\n            uint256 newCollRatio = _coll * _price / _debt;\\r\\n\\r\\n            return newCollRatio;\\r\\n        }\\r\\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \\\"infinite\\\" CR.\\r\\n        else { // if (_debt == 0)\\r\\n            return type(uint256).max;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Dependencies/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\n/**\\r\\n * Based on OpenZeppelin's Ownable contract:\\r\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\r\\n *\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () {\\r\\n        _owner = msg.sender;\\r\\n        emit OwnershipTransferred(address(0), msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the caller is the current owner.\\r\\n     */\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return msg.sender == _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     *\\r\\n     * NOTE: This function is not safe, as it doesn\u2019t check owner is calling it.\\r\\n     * Make sure you check it before calling it.\\r\\n     */\\r\\n    function _renounceOwnership() internal {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/IPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\ninterface IPriceFeed {\\r\\n\\r\\n    // --- Events ---\\r\\n    event LastGoodPriceUpdated(uint256 _lastGoodPrice);\\r\\n   \\r\\n    // --- Function ---\\r\\n    function fetchPrice() external returns (uint);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/ITellorCaller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\ninterface ITellorCaller {\\r\\n    function getTellorCurrentValue() external returns (bool, uint256, uint256);\\r\\n}\"\r\n    },\r\n    \"contracts/PriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"./Interfaces/IPriceFeed.sol\\\";\\r\\nimport \\\"./Interfaces/ITellorCaller.sol\\\";\\r\\nimport \\\"./Dependencies/AggregatorV3Interface.sol\\\";\\r\\nimport \\\"./Dependencies/Ownable.sol\\\";\\r\\nimport \\\"./Dependencies/CheckContract.sol\\\";\\r\\nimport \\\"./Dependencies/BaseMath.sol\\\";\\r\\nimport \\\"./Dependencies/LiquityMath.sol\\\";\\r\\n\\r\\n/*\\r\\n* PriceFeed for mainnet deployment, to be connected to Chainlink's live collateral:USD aggregator reference\\r\\n* contract, and a wrapper contract TellorCaller, which connects to TellorMaster contract.\\r\\n*\\r\\n* The PriceFeed uses Chainlink as primary oracle, and Tellor as fallback. It contains logic for\\r\\n* switching oracles based on oracle failures, timeouts, and conditions for returning to the primary\\r\\n* Chainlink oracle.\\r\\n*/\\r\\ncontract PriceFeed is Ownable, CheckContract, BaseMath, IPriceFeed {\\r\\n\\r\\n    string constant public NAME = \\\"PriceFeed\\\";\\r\\n\\r\\n    AggregatorV3Interface public priceAggregator;  // Mainnet Chainlink aggregator\\r\\n    ITellorCaller public tellorCaller;  // Wrapper contract that calls the Tellor system\\r\\n    uint256 public immutable tellorDigits;\\r\\n\\r\\n    // Use to convert a price answer to an 18-digit precision uint\\r\\n    uint256 constant public TARGET_DIGITS = 18;\\r\\n\\r\\n    // Maximum time period allowed since Chainlink/Tellor's latest round data timestamp, beyond which Chainlink/Tellor is considered frozen.\\r\\n    uint256 constant public TIMEOUT = 14400;  // 4 hours: 60 * 60 * 4\\r\\n\\r\\n    // Maximum deviation allowed between two consecutive Chainlink oracle prices. 18-digit precision.\\r\\n    uint256 constant public MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND =  5e17; // 50%\\r\\n\\r\\n    /*\\r\\n    * The maximum relative price difference between two oracle responses allowed in order for the PriceFeed\\r\\n    * to return to using the Chainlink oracle. 18-digit precision.\\r\\n    */\\r\\n    uint256 constant public MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES = 5e16; // 5%\\r\\n\\r\\n    // The last good price seen from an oracle by Liquity\\r\\n    uint256 public lastGoodPrice;\\r\\n\\r\\n    struct ChainlinkResponse {\\r\\n        uint80 roundId;\\r\\n        int256 answer;\\r\\n        uint256 timestamp;\\r\\n        bool success;\\r\\n        uint8 decimals;\\r\\n    }\\r\\n\\r\\n    struct TellorResponse {\\r\\n        bool ifRetrieve;\\r\\n        uint256 value;\\r\\n        uint256 timestamp;\\r\\n        bool success;\\r\\n    }\\r\\n\\r\\n    enum Status {\\r\\n        chainlinkWorking,\\r\\n        usingTellorChainlinkUntrusted,\\r\\n        bothOraclesUntrusted,\\r\\n        usingTellorChainlinkFrozen,\\r\\n        usingChainlinkTellorUntrusted\\r\\n    }\\r\\n\\r\\n    // The current status of the PricFeed, which determines the conditions for the next price fetch attempt\\r\\n    Status public status;\\r\\n\\r\\n    event PriceFeedStatusChanged(Status newStatus);\\r\\n\\r\\n    constructor (uint256 _tellorDigits) {\\r\\n        require(_tellorDigits > 0 && _tellorDigits <= TARGET_DIGITS, \\\"PriceFeed: wrong decimals for Tellor\\\");\\r\\n        tellorDigits = _tellorDigits;\\r\\n    }\\r\\n\\r\\n    // --- Dependency setters ---\\r\\n\\r\\n    function setAddresses(\\r\\n        address _priceAggregatorAddress,\\r\\n        address _tellorCallerAddress\\r\\n    )\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        require(address(priceAggregator) == address(0), \\\"PriceFeed: contacts already set\\\");\\r\\n\\r\\n        checkContract(_priceAggregatorAddress);\\r\\n        checkContract(_tellorCallerAddress);\\r\\n\\r\\n        priceAggregator = AggregatorV3Interface(_priceAggregatorAddress);\\r\\n        tellorCaller = ITellorCaller(_tellorCallerAddress);\\r\\n\\r\\n        // Explicitly set initial system status\\r\\n        status = Status.chainlinkWorking;\\r\\n\\r\\n        // Get an initial price from Chainlink to serve as first reference for lastGoodPrice\\r\\n        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();\\r\\n        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);\\r\\n\\r\\n        require(!_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse) && !_chainlinkIsFrozen(chainlinkResponse),\\r\\n            \\\"PriceFeed: Chainlink must be working and current\\\");\\r\\n\\r\\n        _storeChainlinkPrice(chainlinkResponse);\\r\\n    }\\r\\n\\r\\n    // --- Functions ---\\r\\n\\r\\n    /*\\r\\n    * fetchPrice():\\r\\n    * Returns the latest price obtained from the Oracle. Called by Liquity functions that require a current price.\\r\\n    *\\r\\n    * Also callable by anyone externally.\\r\\n    *\\r\\n    * Non-view function - it stores the last good price seen by Liquity.\\r\\n    *\\r\\n    * Uses a main oracle (Chainlink) and a fallback oracle (Tellor) in case Chainlink fails. If both fail,\\r\\n    * it uses the last good price seen by Liquity.\\r\\n    *\\r\\n    */\\r\\n    function fetchPrice() external override returns (uint) {\\r\\n        // Get current and previous price data from Chainlink, and current price data from Tellor\\r\\n        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();\\r\\n        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);\\r\\n        TellorResponse memory tellorResponse = _getCurrentTellorResponse();\\r\\n\\r\\n        // --- CASE 1: System fetched last price from Chainlink  ---\\r\\n        if (status == Status.chainlinkWorking) {\\r\\n            // If Chainlink is broken, try Tellor\\r\\n            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {\\r\\n                // If Tellor is broken then both oracles are untrusted, so return the last good price\\r\\n                if (_tellorIsBroken(tellorResponse)) {\\r\\n                    _changeStatus(Status.bothOraclesUntrusted);\\r\\n                    return lastGoodPrice;\\r\\n                }\\r\\n                /*\\r\\n                * If Tellor is only frozen but otherwise returning valid data, return the last good price.\\r\\n                * Tellor may need to be tipped to return current data.\\r\\n                */\\r\\n                if (_tellorIsFrozen(tellorResponse)) {\\r\\n                    _changeStatus(Status.usingTellorChainlinkUntrusted);\\r\\n                    return lastGoodPrice;\\r\\n                }\\r\\n\\r\\n                // If Chainlink is broken and Tellor is working, switch to Tellor and return current Tellor price\\r\\n                _changeStatus(Status.usingTellorChainlinkUntrusted);\\r\\n                return _storeTellorPrice(tellorResponse);\\r\\n            }\\r\\n\\r\\n            // If Chainlink is frozen, try Tellor\\r\\n            if (_chainlinkIsFrozen(chainlinkResponse)) {\\r\\n                // If Tellor is broken too, remember Tellor broke, and return last good price\\r\\n                if (_tellorIsBroken(tellorResponse)) {\\r\\n                    _changeStatus(Status.usingChainlinkTellorUntrusted);\\r\\n                    return lastGoodPrice;\\r\\n                }\\r\\n\\r\\n                // If Tellor is frozen or working, remember Chainlink froze, and switch to Tellor\\r\\n                _changeStatus(Status.usingTellorChainlinkFrozen);\\r\\n\\r\\n                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}\\r\\n\\r\\n                // If Tellor is working, use it\\r\\n                return _storeTellorPrice(tellorResponse);\\r\\n            }\\r\\n\\r\\n            // If Chainlink price has changed by > 50% between two consecutive rounds, compare it to Tellor's price\\r\\n            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {\\r\\n                // If Tellor is broken, both oracles are untrusted, and return last good price\\r\\n                 if (_tellorIsBroken(tellorResponse)) {\\r\\n                    _changeStatus(Status.bothOraclesUntrusted);\\r\\n                    return lastGoodPrice;\\r\\n                }\\r\\n\\r\\n                // If Tellor is frozen, switch to Tellor and return last good price\\r\\n                if (_tellorIsFrozen(tellorResponse)) {\\r\\n                    _changeStatus(Status.usingTellorChainlinkUntrusted);\\r\\n                    return lastGoodPrice;\\r\\n                }\\r\\n\\r\\n                /*\\r\\n                * If Tellor is live and both oracles have a similar price, conclude that Chainlink's large price deviation between\\r\\n                * two consecutive rounds was likely a legitmate market price movement, and so continue using Chainlink\\r\\n                */\\r\\n                if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {\\r\\n                    return _storeChainlinkPrice(chainlinkResponse);\\r\\n                }\\r\\n\\r\\n                // If Tellor is live but the oracles differ too much in price, conclude that Chainlink's initial price deviation was\\r\\n                // an oracle failure. Switch to Tellor, and use Tellor price\\r\\n                _changeStatus(Status.usingTellorChainlinkUntrusted);\\r\\n                return _storeTellorPrice(tellorResponse);\\r\\n            }\\r\\n\\r\\n            // If Chainlink is working and Tellor is broken, remember Tellor is broken\\r\\n            if (_tellorIsBroken(tellorResponse)) {\\r\\n                _changeStatus(Status.usingChainlinkTellorUntrusted);\\r\\n            }\\r\\n\\r\\n            // If Chainlink is working, return Chainlink current price (no status change)\\r\\n            return _storeChainlinkPrice(chainlinkResponse);\\r\\n        }\\r\\n\\r\\n        // --- CASE 2: The system fetched last price from Tellor ---\\r\\n        if (status == Status.usingTellorChainlinkUntrusted) {\\r\\n            // If both Tellor and Chainlink are live, unbroken, and reporting similar prices, switch back to Chainlink\\r\\n            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {\\r\\n                _changeStatus(Status.chainlinkWorking);\\r\\n                return _storeChainlinkPrice(chainlinkResponse);\\r\\n            }\\r\\n\\r\\n            if (_tellorIsBroken(tellorResponse)) {\\r\\n                _changeStatus(Status.bothOraclesUntrusted);\\r\\n                return lastGoodPrice;\\r\\n            }\\r\\n\\r\\n            /*\\r\\n            * If Tellor is only frozen but otherwise returning valid data, just return the last good price.\\r\\n            * Tellor may need to be tipped to return current data.\\r\\n            */\\r\\n            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}\\r\\n\\r\\n            // Otherwise, use Tellor price\\r\\n            return _storeTellorPrice(tellorResponse);\\r\\n        }\\r\\n\\r\\n        // --- CASE 3: Both oracles were untrusted at the last price fetch ---\\r\\n        if (status == Status.bothOraclesUntrusted) {\\r\\n            /*\\r\\n            * If both oracles are now live, unbroken and similar price, we assume that they are reporting\\r\\n            * accurately, and so we switch back to Chainlink.\\r\\n            */\\r\\n            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {\\r\\n                _changeStatus(Status.chainlinkWorking);\\r\\n                return _storeChainlinkPrice(chainlinkResponse);\\r\\n            }\\r\\n\\r\\n            // Otherwise, return the last good price - both oracles are still untrusted (no status change)\\r\\n            return lastGoodPrice;\\r\\n        }\\r\\n\\r\\n        // --- CASE 4: Using Tellor, and Chainlink is frozen ---\\r\\n        if (status == Status.usingTellorChainlinkFrozen) {\\r\\n            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {\\r\\n                // If both Oracles are broken, return last good price\\r\\n                if (_tellorIsBroken(tellorResponse)) {\\r\\n                    _changeStatus(Status.bothOraclesUntrusted);\\r\\n                    return lastGoodPrice;\\r\\n                }\\r\\n\\r\\n                // If Chainlink is broken, remember it and switch to using Tellor\\r\\n                _changeStatus(Status.usingTellorChainlinkUntrusted);\\r\\n\\r\\n                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}\\r\\n\\r\\n                // If Tellor is working, return Tellor current price\\r\\n                return _storeTellorPrice(tellorResponse);\\r\\n            }\\r\\n\\r\\n            if (_chainlinkIsFrozen(chainlinkResponse)) {\\r\\n                // if Chainlink is frozen and Tellor is broken, remember Tellor broke, and return last good price\\r\\n                if (_tellorIsBroken(tellorResponse)) {\\r\\n                    _changeStatus(Status.usingChainlinkTellorUntrusted);\\r\\n                    return lastGoodPrice;\\r\\n                }\\r\\n\\r\\n                // If both are frozen, just use lastGoodPrice\\r\\n                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}\\r\\n\\r\\n                // if Chainlink is frozen and Tellor is working, keep using Tellor (no status change)\\r\\n                return _storeTellorPrice(tellorResponse);\\r\\n            }\\r\\n\\r\\n            // if Chainlink is live and Tellor is broken, remember Tellor broke, and return Chainlink price\\r\\n            if (_tellorIsBroken(tellorResponse)) {\\r\\n                _changeStatus(Status.usingChainlinkTellorUntrusted);\\r\\n                return _storeChainlinkPrice(chainlinkResponse);\\r\\n            }\\r\\n\\r\\n             // If Chainlink is live and Tellor is frozen, just use last good price (no status change) since we have no basis for comparison\\r\\n            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}\\r\\n\\r\\n            // If Chainlink is live and Tellor is working, compare prices. Switch to Chainlink\\r\\n            // if prices are within 5%, and return Chainlink price.\\r\\n            if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {\\r\\n                _changeStatus(Status.chainlinkWorking);\\r\\n                return _storeChainlinkPrice(chainlinkResponse);\\r\\n            }\\r\\n\\r\\n            // Otherwise if Chainlink is live but price not within 5% of Tellor, distrust Chainlink, and return Tellor price\\r\\n            _changeStatus(Status.usingTellorChainlinkUntrusted);\\r\\n            return _storeTellorPrice(tellorResponse);\\r\\n        }\\r\\n\\r\\n        // --- CASE 5: Using Chainlink, Tellor is untrusted ---\\r\\n        if (status == Status.usingChainlinkTellorUntrusted) {\\r\\n            // If Chainlink breaks, now both oracles are untrusted\\r\\n            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {\\r\\n                _changeStatus(Status.bothOraclesUntrusted);\\r\\n                return lastGoodPrice;\\r\\n            }\\r\\n\\r\\n            // If Chainlink is frozen, return last good price (no status change)\\r\\n            if (_chainlinkIsFrozen(chainlinkResponse)) {\\r\\n                return lastGoodPrice;\\r\\n            }\\r\\n\\r\\n            // If Chainlink and Tellor are both live, unbroken and similar price, switch back to chainlinkWorking and return Chainlink price\\r\\n            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {\\r\\n                _changeStatus(Status.chainlinkWorking);\\r\\n                return _storeChainlinkPrice(chainlinkResponse);\\r\\n            }\\r\\n\\r\\n            // If Chainlink is live but deviated >50% from it's previous price and Tellor is still untrusted, switch\\r\\n            // to bothOraclesUntrusted and return last good price\\r\\n            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {\\r\\n                _changeStatus(Status.bothOraclesUntrusted);\\r\\n                return lastGoodPrice;\\r\\n            }\\r\\n\\r\\n            // Otherwise if Chainlink is live and deviated <50% from it's previous price and Tellor is still untrusted,\\r\\n            // return Chainlink price (no status change)\\r\\n            return _storeChainlinkPrice(chainlinkResponse);\\r\\n        }\\r\\n        return lastGoodPrice;\\r\\n    }\\r\\n\\r\\n    // --- Helper functions ---\\r\\n\\r\\n    /* Chainlink is considered broken if its current or previous round data is in any way bad. We check the previous round\\r\\n    * for two reasons:\\r\\n    *\\r\\n    * 1) It is necessary data for the price deviation check in case 1,\\r\\n    * and\\r\\n    * 2) Chainlink is the PriceFeed's preferred primary oracle - having two consecutive valid round responses adds\\r\\n    * peace of mind when using or returning to Chainlink.\\r\\n    */\\r\\n    function _chainlinkIsBroken(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal view returns (bool) {\\r\\n        return _badChainlinkResponse(_currentResponse) || _badChainlinkResponse(_prevResponse);\\r\\n    }\\r\\n\\r\\n    function _badChainlinkResponse(ChainlinkResponse memory _response) internal view returns (bool) {\\r\\n         // Check for response call reverted\\r\\n        if (!_response.success) {return true;}\\r\\n        // Check for an invalid roundId that is 0\\r\\n        if (_response.roundId == 0) {return true;}\\r\\n        // Check for an invalid timeStamp that is 0, or in the future\\r\\n        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}\\r\\n        // Check for non-positive price\\r\\n        if (_response.answer <= 0) {return true;}\\r\\n\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function _chainlinkIsFrozen(ChainlinkResponse memory _response) internal view returns (bool) {\\r\\n        return block.timestamp - _response.timestamp > TIMEOUT;\\r\\n    }\\r\\n\\r\\n    function _chainlinkPriceChangeAboveMax(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal pure returns (bool) {\\r\\n        uint256 currentScaledPrice = _scaleChainlinkPriceByDigits(uint256(_currentResponse.answer), _currentResponse.decimals);\\r\\n        uint256 prevScaledPrice = _scaleChainlinkPriceByDigits(uint256(_prevResponse.answer), _prevResponse.decimals);\\r\\n\\r\\n        uint256 minPrice = LiquityMath._min(currentScaledPrice, prevScaledPrice);\\r\\n        uint256 maxPrice = LiquityMath._max(currentScaledPrice, prevScaledPrice);\\r\\n\\r\\n        /*\\r\\n        * Use the larger price as the denominator:\\r\\n        * - If price decreased, the percentage deviation is in relation to the the previous price.\\r\\n        * - If price increased, the percentage deviation is in relation to the current price.\\r\\n        */\\r\\n        uint256 percentDeviation = (maxPrice - minPrice) * DECIMAL_PRECISION / maxPrice;\\r\\n\\r\\n        // Return true if price has more than doubled, or more than halved.\\r\\n        return percentDeviation > MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND;\\r\\n    }\\r\\n\\r\\n    function _tellorIsBroken(TellorResponse memory _response) internal view returns (bool) {\\r\\n        // Check for response call reverted\\r\\n        if (!_response.success) {return true;}\\r\\n        // Check for an invalid timeStamp that is 0, or in the future\\r\\n        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}\\r\\n        // Check for zero price\\r\\n        if (_response.value == 0) {return true;}\\r\\n\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n     function _tellorIsFrozen(TellorResponse  memory _tellorResponse) internal view returns (bool) {\\r\\n        return block.timestamp - _tellorResponse.timestamp > TIMEOUT;\\r\\n    }\\r\\n\\r\\n    function _bothOraclesLiveAndUnbrokenAndSimilarPrice\\r\\n    (\\r\\n        ChainlinkResponse memory _chainlinkResponse,\\r\\n        ChainlinkResponse memory _prevChainlinkResponse,\\r\\n        TellorResponse memory _tellorResponse\\r\\n    )\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        // Return false if either oracle is broken or frozen\\r\\n        if\\r\\n        (\\r\\n            _tellorIsBroken(_tellorResponse) ||\\r\\n            _tellorIsFrozen(_tellorResponse) ||\\r\\n            _chainlinkIsBroken(_chainlinkResponse, _prevChainlinkResponse) ||\\r\\n            _chainlinkIsFrozen(_chainlinkResponse)\\r\\n        )\\r\\n        {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        return _bothOraclesSimilarPrice(_chainlinkResponse, _tellorResponse);\\r\\n    }\\r\\n\\r\\n    function _bothOraclesSimilarPrice( ChainlinkResponse memory _chainlinkResponse, TellorResponse memory _tellorResponse) internal view returns (bool) {\\r\\n        uint256 scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);\\r\\n        uint256 scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);\\r\\n\\r\\n        // Get the relative price difference between the oracles. Use the lower price as the denominator, i.e. the reference for the calculation.\\r\\n        uint256 minPrice = LiquityMath._min(scaledTellorPrice, scaledChainlinkPrice);\\r\\n        uint256 maxPrice = LiquityMath._max(scaledTellorPrice, scaledChainlinkPrice);\\r\\n        uint256 percentPriceDifference = (maxPrice - minPrice) * DECIMAL_PRECISION / minPrice;\\r\\n\\r\\n        /*\\r\\n        * Return true if the relative price difference is <= 3%: if so, we assume both oracles are probably reporting\\r\\n        * the honest market price, as it is unlikely that both have been broken/hacked and are still in-sync.\\r\\n        */\\r\\n        return percentPriceDifference <= MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES;\\r\\n    }\\r\\n\\r\\n    function _scaleChainlinkPriceByDigits(uint256 _price, uint256 _answerDigits) internal pure returns (uint) {\\r\\n        /*\\r\\n        * Convert the price returned by the Chainlink oracle to an 18-digit decimal for use by Liquity.\\r\\n        * At date of Liquity launch, Chainlink uses an 8-digit price, but we also handle the possibility of\\r\\n        * future changes.\\r\\n        *\\r\\n        */\\r\\n        uint256 price;\\r\\n        if (_answerDigits >= TARGET_DIGITS) {\\r\\n            // Scale the returned price value down to Liquity's target precision\\r\\n            price = _price / (10 ** (_answerDigits - TARGET_DIGITS));\\r\\n        }\\r\\n        else if (_answerDigits < TARGET_DIGITS) {\\r\\n            // Scale the returned price value up to Liquity's target precision\\r\\n            price = _price * (10 ** (TARGET_DIGITS - _answerDigits));\\r\\n        }\\r\\n        return price;\\r\\n    }\\r\\n\\r\\n    function _scaleTellorPriceByDigits(uint256 _price) internal view returns (uint) {\\r\\n        return _price * (10**(TARGET_DIGITS - tellorDigits));\\r\\n    }\\r\\n\\r\\n    function _changeStatus(Status _status) internal {\\r\\n        status = _status;\\r\\n        emit PriceFeedStatusChanged(_status);\\r\\n    }\\r\\n\\r\\n    function _storePrice(uint256 _currentPrice) internal {\\r\\n        lastGoodPrice = _currentPrice;\\r\\n        emit LastGoodPriceUpdated(_currentPrice);\\r\\n    }\\r\\n\\r\\n     function _storeTellorPrice(TellorResponse memory _tellorResponse) internal returns (uint) {\\r\\n        uint256 scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);\\r\\n        _storePrice(scaledTellorPrice);\\r\\n\\r\\n        return scaledTellorPrice;\\r\\n    }\\r\\n\\r\\n    function _storeChainlinkPrice(ChainlinkResponse memory _chainlinkResponse) internal returns (uint) {\\r\\n        uint256 scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);\\r\\n        _storePrice(scaledChainlinkPrice);\\r\\n\\r\\n        return scaledChainlinkPrice;\\r\\n    }\\r\\n\\r\\n    // --- Oracle response wrapper functions ---\\r\\n\\r\\n    function _getCurrentTellorResponse() internal returns (TellorResponse memory tellorResponse) {\\r\\n        try tellorCaller.getTellorCurrentValue() returns\\r\\n        (\\r\\n            bool ifRetrieve,\\r\\n            uint256 value,\\r\\n            uint256 _timestampRetrieved\\r\\n        )\\r\\n        {\\r\\n            // If call to Tellor succeeds, return the response and success = true\\r\\n            tellorResponse.ifRetrieve = ifRetrieve;\\r\\n            tellorResponse.value = value;\\r\\n            tellorResponse.timestamp = _timestampRetrieved;\\r\\n            tellorResponse.success = true;\\r\\n\\r\\n            return (tellorResponse);\\r\\n        }catch {\\r\\n             // If call to Tellor reverts, return a zero response with success = false\\r\\n            return (tellorResponse);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getCurrentChainlinkResponse() internal view returns (ChainlinkResponse memory chainlinkResponse) {\\r\\n        // First, try to get current decimal precision:\\r\\n        try priceAggregator.decimals() returns (uint8 decimals) {\\r\\n            // If call to Chainlink succeeds, record the current decimal precision\\r\\n            chainlinkResponse.decimals = decimals;\\r\\n        } catch {\\r\\n            // If call to Chainlink aggregator reverts, return a zero response with success = false\\r\\n            return chainlinkResponse;\\r\\n        }\\r\\n\\r\\n        // Secondly, try to get latest price data:\\r\\n        try priceAggregator.latestRoundData() returns\\r\\n        (\\r\\n            uint80 roundId,\\r\\n            int256 answer,\\r\\n            uint256 /* startedAt */,\\r\\n            uint256 timestamp,\\r\\n            uint80 /* answeredInRound */\\r\\n        )\\r\\n        {\\r\\n            // If call to Chainlink succeeds, return the response and success = true\\r\\n            chainlinkResponse.roundId = roundId;\\r\\n            chainlinkResponse.answer = answer;\\r\\n            chainlinkResponse.timestamp = timestamp;\\r\\n            chainlinkResponse.success = true;\\r\\n            return chainlinkResponse;\\r\\n        } catch {\\r\\n            // If call to Chainlink aggregator reverts, return a zero response with success = false\\r\\n            return chainlinkResponse;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getPrevChainlinkResponse(uint80 _currentRoundId, uint8 _currentDecimals) internal view returns (ChainlinkResponse memory prevChainlinkResponse) {\\r\\n        /*\\r\\n        * NOTE: Chainlink only offers a current decimals() value - there is no way to obtain the decimal precision used in a\\r\\n        * previous round.  We assume the decimals used in the previous round are the same as the current round.\\r\\n        */\\r\\n        if (_currentRoundId == 0) {\\r\\n      \\t\\t\\treturn prevChainlinkResponse;\\r\\n    \\t\\t}\\r\\n        // Try to get the price data from the previous round:\\r\\n        try priceAggregator.getRoundData(_currentRoundId - 1) returns\\r\\n        (\\r\\n            uint80 roundId,\\r\\n            int256 answer,\\r\\n            uint256 /* startedAt */,\\r\\n            uint256 timestamp,\\r\\n            uint80 /* answeredInRound */\\r\\n        )\\r\\n        {\\r\\n            // If call to Chainlink succeeds, return the response and success = true\\r\\n            prevChainlinkResponse.roundId = roundId;\\r\\n            prevChainlinkResponse.answer = answer;\\r\\n            prevChainlinkResponse.timestamp = timestamp;\\r\\n            prevChainlinkResponse.decimals = _currentDecimals;\\r\\n            prevChainlinkResponse.success = true;\\r\\n            return prevChainlinkResponse;\\r\\n        } catch {\\r\\n            // If call to Chainlink aggregator reverts, return a zero response with success = false\\r\\n            return prevChainlinkResponse;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    * forceExitBothUntrustedStatus()\\r\\n    * DAO can help one oracle return back online only if previously both were untrusted.\\r\\n    * Function reverts if both oracles are still broken.\\r\\n    * In case when both oracles are online but have different prices then caller can control \\r\\n    * which will be checked first: ChainLink if tryTellorFirst==false, Tellor otherwise\\r\\n    */ \\r\\n    function forceExitBothUntrustedStatus(bool tryTellorFirst) external onlyOwner {\\r\\n        require(status == Status.bothOraclesUntrusted, \\\"PriceFeed: at least one oracle is working\\\");\\r\\n\\r\\n        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();\\r\\n        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);\\r\\n        TellorResponse memory tellorResponse = _getCurrentTellorResponse();\\r\\n\\r\\n        // check Tellor first only if flag was true, exit function in case of success\\r\\n        if\\r\\n        (\\r\\n            tryTellorFirst &&\\r\\n            _changeStatusIfTellorLiveAndUnbroken(tellorResponse)\\r\\n        )\\r\\n        {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // check ChainLink feed\\r\\n        if \\r\\n        (\\r\\n            !_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse) &&\\r\\n            !_chainlinkIsFrozen(chainlinkResponse) &&\\r\\n            !_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)\\r\\n        ) \\r\\n        {\\r\\n            _changeStatus(Status.usingChainlinkTellorUntrusted);\\r\\n            _storeChainlinkPrice(chainlinkResponse);\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // if Tellor was already checked or check is false then revert transaction\\r\\n        if\\r\\n        (\\r\\n            !tryTellorFirst &&\\r\\n            _changeStatusIfTellorLiveAndUnbroken(tellorResponse)\\r\\n        )\\r\\n        {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // Transaction is successful only if one oracle returned back online\\r\\n        revert(\\\"PriceFeed: both oracles are still untrusted\\\");\\r\\n    }\\r\\n\\r\\n    function _changeStatusIfTellorLiveAndUnbroken\\r\\n    (\\r\\n        TellorResponse memory _tellorResponse\\r\\n    )\\r\\n        internal\\r\\n        returns (bool)\\r\\n    {\\r\\n        // Return true if Tellor is back online\\r\\n        if\\r\\n        (\\r\\n            !_tellorIsBroken(_tellorResponse) &&\\r\\n            !_tellorIsFrozen(_tellorResponse)\\r\\n        )\\r\\n        {\\r\\n            _changeStatus(Status.usingTellorChainlinkUntrusted);\\r\\n            _storeTellorPrice(_tellorResponse);\\r\\n            return true;\\r\\n        }\\r\\n\\r\\n        return false;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tellorDigits\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_lastGoodPrice\",\"type\":\"uint256\"}],\"name\":\"LastGoodPriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum PriceFeed.Status\",\"name\":\"newStatus\",\"type\":\"uint8\"}],\"name\":\"PriceFeedStatusChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DECIMAL_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TARGET_DIGITS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIMEOUT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fetchPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"tryTellorFirst\",\"type\":\"bool\"}],\"name\":\"forceExitBothUntrustedStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastGoodPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceAggregator\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_priceAggregatorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tellorCallerAddress\",\"type\":\"address\"}],\"name\":\"setAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"internalType\":\"enum PriceFeed.Status\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tellorCaller\",\"outputs\":[{\"internalType\":\"contract ITellorCaller\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tellorDigits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PriceFeed", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000012", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}