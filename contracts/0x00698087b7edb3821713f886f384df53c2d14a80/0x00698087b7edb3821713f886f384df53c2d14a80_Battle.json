{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFCoordinatorV2Interface {\\n  /**\\n   * @notice Get configuration relevant for making requests\\n   * @return minimumRequestConfirmations global min for request confirmations\\n   * @return maxGasLimit global max for request gas limit\\n   * @return s_provingKeyHashes list of registered key hashes\\n   */\\n  function getRequestConfig()\\n    external\\n    view\\n    returns (\\n      uint16,\\n      uint32,\\n      bytes32[] memory\\n    );\\n\\n  /**\\n   * @notice Request a set of random words.\\n   * @param keyHash - Corresponds to a particular oracle job which uses\\n   * that key for generating the VRF proof. Different keyHash's have different gas price\\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\\n   * @param subId  - The ID of the VRF subscription. Must be funded\\n   * with the minimum subscription balance required for the selected keyHash.\\n   * @param minimumRequestConfirmations - How many blocks you'd like the\\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\\n   * for why you may want to request more. The acceptable range is\\n   * [minimumRequestBlockConfirmations, 200].\\n   * @param callbackGasLimit - How much gas you'd like to receive in your\\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n   * may be slightly less than this amount because of gas used calling the function\\n   * (argument decoding etc.), so you may need to request slightly more than you expect\\n   * to have inside fulfillRandomWords. The acceptable range is\\n   * [0, maxGasLimit]\\n   * @param numWords - The number of uint256 random values you'd like to receive\\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n   * @return requestId - A unique identifier of the request. Can be used to match\\n   * a request to a response in fulfillRandomWords.\\n   */\\n  function requestRandomWords(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256 requestId);\\n\\n  /**\\n   * @notice Create a VRF subscription.\\n   * @return subId - A unique subscription id.\\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n   * @dev Note to fund the subscription, use transferAndCall. For example\\n   * @dev  LINKTOKEN.transferAndCall(\\n   * @dev    address(COORDINATOR),\\n   * @dev    amount,\\n   * @dev    abi.encode(subId));\\n   */\\n  function createSubscription() external returns (uint64 subId);\\n\\n  /**\\n   * @notice Get a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @return balance - LINK balance of the subscription in juels.\\n   * @return reqCount - number of requests for this subscription, determines fee tier.\\n   * @return owner - owner of the subscription.\\n   * @return consumers - list of consumer address which are able to use this subscription.\\n   */\\n  function getSubscription(uint64 subId)\\n    external\\n    view\\n    returns (\\n      uint96 balance,\\n      uint64 reqCount,\\n      address owner,\\n      address[] memory consumers\\n    );\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @param newOwner - proposed new owner of the subscription\\n   */\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @dev will revert if original owner of subId has\\n   * not requested that msg.sender become the new owner.\\n   */\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\\n\\n  /**\\n   * @notice Add a consumer to a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - New consumer which can use the subscription\\n   */\\n  function addConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Remove a consumer from a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - Consumer to remove from the subscription\\n   */\\n  function removeConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Cancel a subscription\\n   * @param subId - ID of the subscription\\n   * @param to - Where to send the remaining LINK to\\n   */\\n  function cancelSubscription(uint64 subId, address to) external;\\n\\n  /*\\n   * @notice Check to see if there exists a request commitment consumers\\n   * for all consumers and keyhashes for a given sub.\\n   * @param subId - ID of the subscription\\n   * @return true if there exists at least one unfulfilled request for the subscription, false\\n   * otherwise.\\n   */\\n  function pendingRequestExists(uint64 subId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\\n * @dev 1. The fulfillment came from the VRFCoordinator\\n * @dev 2. The consumer contract implements fulfillRandomWords.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash). Create subscription, fund it\\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\\n * @dev subscription management functions).\\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\\n * @dev callbackGasLimit, numWords),\\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomWords method.\\n *\\n * @dev The randomness argument to fulfillRandomWords is a set of random words\\n * @dev generated from your requestId and the blockHash of the request.\\n *\\n * @dev If your contract could have concurrent requests open, you can use the\\n * @dev requestId returned from requestRandomWords to track which response is associated\\n * @dev with which randomness request.\\n * @dev See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ.\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request. It is for this reason that\\n * @dev that you can signal to an oracle you'd like them to wait longer before\\n * @dev responding to the request (however this is not enforced in the contract\\n * @dev and so remains effective only in the case of unmodified oracle software).\\n */\\nabstract contract VRFConsumerBaseV2 {\\n  error OnlyCoordinatorCanFulfill(address have, address want);\\n  address private immutable vrfCoordinator;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   */\\n  constructor(address _vrfCoordinator) {\\n    vrfCoordinator = _vrfCoordinator;\\n  }\\n\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomWords the VRF output expanded to the requested number of words\\n   */\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\\n    if (msg.sender != vrfCoordinator) {\\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\\n    }\\n    fulfillRandomWords(requestId, randomWords);\\n  }\\n}\\n\"\r\n    },\r\n    \"@looksrare/contracts-libs/contracts/errors/GenericErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @notice It is emitted if the call recipient is not a contract.\\n */\\nerror NotAContract();\\n\"\r\n    },\r\n    \"@looksrare/contracts-libs/contracts/errors/LowLevelErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @notice It is emitted if the ETH transfer fails.\\n */\\nerror ETHTransferFail();\\n\\n/**\\n * @notice It is emitted if the ERC20 approval fails.\\n */\\nerror ERC20ApprovalFail();\\n\\n/**\\n * @notice It is emitted if the ERC20 transfer fails.\\n */\\nerror ERC20TransferFail();\\n\\n/**\\n * @notice It is emitted if the ERC20 transferFrom fails.\\n */\\nerror ERC20TransferFromFail();\\n\\n/**\\n * @notice It is emitted if the ERC721 transferFrom fails.\\n */\\nerror ERC721TransferFromFail();\\n\\n/**\\n * @notice It is emitted if the ERC1155 safeTransferFrom fails.\\n */\\nerror ERC1155SafeTransferFromFail();\\n\\n/**\\n * @notice It is emitted if the ERC1155 safeBatchTransferFrom fails.\\n */\\nerror ERC1155SafeBatchTransferFromFail();\\n\"\r\n    },\r\n    \"@looksrare/contracts-libs/contracts/interfaces/generic/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IERC1155 {\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@looksrare/contracts-libs/contracts/interfaces/generic/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@looksrare/contracts-libs/contracts/interfaces/generic/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IERC721 {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    function approve(address to, uint256 tokenId) external;\\n\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@looksrare/contracts-libs/contracts/interfaces/generic/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address dst, uint256 wad) external returns (bool);\\n\\n    function withdraw(uint256 wad) external;\\n}\\n\"\r\n    },\r\n    \"@looksrare/contracts-libs/contracts/interfaces/IOwnableTwoSteps.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @title IOwnableTwoSteps\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ninterface IOwnableTwoSteps {\\n    /**\\n     * @notice This enum keeps track of the ownership status.\\n     * @param NoOngoingTransfer The default status when the owner is set\\n     * @param TransferInProgress The status when a transfer to a new owner is initialized\\n     * @param RenouncementInProgress The status when a transfer to address(0) is initialized\\n     */\\n    enum Status {\\n        NoOngoingTransfer,\\n        TransferInProgress,\\n        RenouncementInProgress\\n    }\\n\\n    /**\\n     * @notice This is returned when there is no transfer of ownership in progress.\\n     */\\n    error NoOngoingTransferInProgress();\\n\\n    /**\\n     * @notice This is returned when the caller is not the owner.\\n     */\\n    error NotOwner();\\n\\n    /**\\n     * @notice This is returned when there is no renouncement in progress but\\n     *         the owner tries to validate the ownership renouncement.\\n     */\\n    error RenouncementNotInProgress();\\n\\n    /**\\n     * @notice This is returned when the transfer is already in progress but the owner tries\\n     *         initiate a new ownership transfer.\\n     */\\n    error TransferAlreadyInProgress();\\n\\n    /**\\n     * @notice This is returned when there is no ownership transfer in progress but the\\n     *         ownership change tries to be approved.\\n     */\\n    error TransferNotInProgress();\\n\\n    /**\\n     * @notice This is returned when the ownership transfer is attempted to be validated by the\\n     *         a caller that is not the potential owner.\\n     */\\n    error WrongPotentialOwner();\\n\\n    /**\\n     * @notice This is emitted if the ownership transfer is cancelled.\\n     */\\n    event CancelOwnershipTransfer();\\n\\n    /**\\n     * @notice This is emitted if the ownership renouncement is initiated.\\n     */\\n    event InitiateOwnershipRenouncement();\\n\\n    /**\\n     * @notice This is emitted if the ownership transfer is initiated.\\n     * @param previousOwner Previous/current owner\\n     * @param potentialOwner Potential/future owner\\n     */\\n    event InitiateOwnershipTransfer(address previousOwner, address potentialOwner);\\n\\n    /**\\n     * @notice This is emitted when there is a new owner.\\n     */\\n    event NewOwner(address newOwner);\\n}\\n\"\r\n    },\r\n    \"@looksrare/contracts-libs/contracts/interfaces/IReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @title IReentrancyGuard\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ninterface IReentrancyGuard {\\n    /**\\n     * @notice This is returned when there is a reentrant call.\\n     */\\n    error ReentrancyFail();\\n}\\n\"\r\n    },\r\n    \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC1155Transfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n// Interfaces\\nimport {IERC1155} from \\\"../interfaces/generic/IERC1155.sol\\\";\\n\\n// Errors\\nimport {ERC1155SafeTransferFromFail, ERC1155SafeBatchTransferFromFail} from \\\"../errors/LowLevelErrors.sol\\\";\\nimport {NotAContract} from \\\"../errors/GenericErrors.sol\\\";\\n\\n/**\\n * @title LowLevelERC1155Transfer\\n * @notice This contract contains low-level calls to transfer ERC1155 tokens.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ncontract LowLevelERC1155Transfer {\\n    /**\\n     * @notice Execute ERC1155 safeTransferFrom\\n     * @param collection Address of the collection\\n     * @param from Address of the sender\\n     * @param to Address of the recipient\\n     * @param tokenId tokenId to transfer\\n     * @param amount Amount to transfer\\n     */\\n    function _executeERC1155SafeTransferFrom(\\n        address collection,\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        uint256 amount\\n    ) internal {\\n        if (collection.code.length == 0) {\\n            revert NotAContract();\\n        }\\n\\n        (bool status, ) = collection.call(abi.encodeCall(IERC1155.safeTransferFrom, (from, to, tokenId, amount, \\\"\\\")));\\n\\n        if (!status) {\\n            revert ERC1155SafeTransferFromFail();\\n        }\\n    }\\n\\n    /**\\n     * @notice Execute ERC1155 safeBatchTransferFrom\\n     * @param collection Address of the collection\\n     * @param from Address of the sender\\n     * @param to Address of the recipient\\n     * @param tokenIds Array of tokenIds to transfer\\n     * @param amounts Array of amounts to transfer\\n     */\\n    function _executeERC1155SafeBatchTransferFrom(\\n        address collection,\\n        address from,\\n        address to,\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata amounts\\n    ) internal {\\n        if (collection.code.length == 0) {\\n            revert NotAContract();\\n        }\\n\\n        (bool status, ) = collection.call(\\n            abi.encodeCall(IERC1155.safeBatchTransferFrom, (from, to, tokenIds, amounts, \\\"\\\"))\\n        );\\n\\n        if (!status) {\\n            revert ERC1155SafeBatchTransferFromFail();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC20Transfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n// Interfaces\\nimport {IERC20} from \\\"../interfaces/generic/IERC20.sol\\\";\\n\\n// Errors\\nimport {ERC20TransferFail, ERC20TransferFromFail} from \\\"../errors/LowLevelErrors.sol\\\";\\nimport {NotAContract} from \\\"../errors/GenericErrors.sol\\\";\\n\\n/**\\n * @title LowLevelERC20Transfer\\n * @notice This contract contains low-level calls to transfer ERC20 tokens.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ncontract LowLevelERC20Transfer {\\n    /**\\n     * @notice Execute ERC20 transferFrom\\n     * @param currency Currency address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param amount Amount to transfer\\n     */\\n    function _executeERC20TransferFrom(address currency, address from, address to, uint256 amount) internal {\\n        if (currency.code.length == 0) {\\n            revert NotAContract();\\n        }\\n\\n        (bool status, bytes memory data) = currency.call(abi.encodeCall(IERC20.transferFrom, (from, to, amount)));\\n\\n        if (!status) {\\n            revert ERC20TransferFromFail();\\n        }\\n\\n        if (data.length > 0) {\\n            if (!abi.decode(data, (bool))) {\\n                revert ERC20TransferFromFail();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Execute ERC20 (direct) transfer\\n     * @param currency Currency address\\n     * @param to Recipient address\\n     * @param amount Amount to transfer\\n     */\\n    function _executeERC20DirectTransfer(address currency, address to, uint256 amount) internal {\\n        if (currency.code.length == 0) {\\n            revert NotAContract();\\n        }\\n\\n        (bool status, bytes memory data) = currency.call(abi.encodeCall(IERC20.transfer, (to, amount)));\\n\\n        if (!status) {\\n            revert ERC20TransferFail();\\n        }\\n\\n        if (data.length > 0) {\\n            if (!abi.decode(data, (bool))) {\\n                revert ERC20TransferFail();\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC721Transfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n// Interfaces\\nimport {IERC721} from \\\"../interfaces/generic/IERC721.sol\\\";\\n\\n// Errors\\nimport {ERC721TransferFromFail} from \\\"../errors/LowLevelErrors.sol\\\";\\nimport {NotAContract} from \\\"../errors/GenericErrors.sol\\\";\\n\\n/**\\n * @title LowLevelERC721Transfer\\n * @notice This contract contains low-level calls to transfer ERC721 tokens.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ncontract LowLevelERC721Transfer {\\n    /**\\n     * @notice Execute ERC721 transferFrom\\n     * @param collection Address of the collection\\n     * @param from Address of the sender\\n     * @param to Address of the recipient\\n     * @param tokenId tokenId to transfer\\n     */\\n    function _executeERC721TransferFrom(address collection, address from, address to, uint256 tokenId) internal {\\n        if (collection.code.length == 0) {\\n            revert NotAContract();\\n        }\\n\\n        (bool status, ) = collection.call(abi.encodeCall(IERC721.transferFrom, (from, to, tokenId)));\\n\\n        if (!status) {\\n            revert ERC721TransferFromFail();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n// Interfaces\\nimport {IWETH} from \\\"../interfaces/generic/IWETH.sol\\\";\\n\\n/**\\n * @title LowLevelWETH\\n * @notice This contract contains a function to transfer ETH with an option to wrap to WETH.\\n *         If the ETH transfer fails within a gas limit, the amount in ETH is wrapped to WETH and then transferred.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ncontract LowLevelWETH {\\n    /**\\n     * @notice It transfers ETH to a recipient with a specified gas limit.\\n     *         If the original transfers fails, it wraps to WETH and transfers the WETH to recipient.\\n     * @param _WETH WETH address\\n     * @param _to Recipient address\\n     * @param _amount Amount to transfer\\n     * @param _gasLimit Gas limit to perform the ETH transfer\\n     */\\n    function _transferETHAndWrapIfFailWithGasLimit(\\n        address _WETH,\\n        address _to,\\n        uint256 _amount,\\n        uint256 _gasLimit\\n    ) internal {\\n        bool status;\\n\\n        assembly {\\n            status := call(_gasLimit, _to, _amount, 0, 0, 0, 0)\\n        }\\n\\n        if (!status) {\\n            IWETH(_WETH).deposit{value: _amount}();\\n            IWETH(_WETH).transfer(_to, _amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@looksrare/contracts-libs/contracts/OwnableTwoSteps.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n// Interfaces\\nimport {IOwnableTwoSteps} from \\\"./interfaces/IOwnableTwoSteps.sol\\\";\\n\\n/**\\n * @title OwnableTwoSteps\\n * @notice This contract offers transfer of ownership in two steps with potential owner\\n *         having to confirm the transaction to become the owner.\\n *         Renouncement of the ownership is also a two-step process since the next potential owner is the address(0).\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\nabstract contract OwnableTwoSteps is IOwnableTwoSteps {\\n    /**\\n     * @notice Address of the current owner.\\n     */\\n    address public owner;\\n\\n    /**\\n     * @notice Address of the potential owner.\\n     */\\n    address public potentialOwner;\\n\\n    /**\\n     * @notice Ownership status.\\n     */\\n    Status public ownershipStatus;\\n\\n    /**\\n     * @notice Modifier to wrap functions for contracts that inherit this contract.\\n     */\\n    modifier onlyOwner() {\\n        _onlyOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Constructor\\n     * @param _owner The contract's owner\\n     */\\n    constructor(address _owner) {\\n        owner = _owner;\\n        emit NewOwner(_owner);\\n    }\\n\\n    /**\\n     * @notice This function is used to cancel the ownership transfer.\\n     * @dev This function can be used for both cancelling a transfer to a new owner and\\n     *      cancelling the renouncement of the ownership.\\n     */\\n    function cancelOwnershipTransfer() external onlyOwner {\\n        Status _ownershipStatus = ownershipStatus;\\n        if (_ownershipStatus == Status.NoOngoingTransfer) {\\n            revert NoOngoingTransferInProgress();\\n        }\\n\\n        if (_ownershipStatus == Status.TransferInProgress) {\\n            delete potentialOwner;\\n        }\\n\\n        delete ownershipStatus;\\n\\n        emit CancelOwnershipTransfer();\\n    }\\n\\n    /**\\n     * @notice This function is used to confirm the ownership renouncement.\\n     */\\n    function confirmOwnershipRenouncement() external onlyOwner {\\n        if (ownershipStatus != Status.RenouncementInProgress) {\\n            revert RenouncementNotInProgress();\\n        }\\n\\n        delete owner;\\n        delete ownershipStatus;\\n\\n        emit NewOwner(address(0));\\n    }\\n\\n    /**\\n     * @notice This function is used to confirm the ownership transfer.\\n     * @dev This function can only be called by the current potential owner.\\n     */\\n    function confirmOwnershipTransfer() external {\\n        if (ownershipStatus != Status.TransferInProgress) {\\n            revert TransferNotInProgress();\\n        }\\n\\n        if (msg.sender != potentialOwner) {\\n            revert WrongPotentialOwner();\\n        }\\n\\n        owner = msg.sender;\\n        delete ownershipStatus;\\n        delete potentialOwner;\\n\\n        emit NewOwner(msg.sender);\\n    }\\n\\n    /**\\n     * @notice This function is used to initiate the transfer of ownership to a new owner.\\n     * @param newPotentialOwner New potential owner address\\n     */\\n    function initiateOwnershipTransfer(address newPotentialOwner) external onlyOwner {\\n        if (ownershipStatus != Status.NoOngoingTransfer) {\\n            revert TransferAlreadyInProgress();\\n        }\\n\\n        ownershipStatus = Status.TransferInProgress;\\n        potentialOwner = newPotentialOwner;\\n\\n        /**\\n         * @dev This function can only be called by the owner, so msg.sender is the owner.\\n         *      We don't have to SLOAD the owner again.\\n         */\\n        emit InitiateOwnershipTransfer(msg.sender, newPotentialOwner);\\n    }\\n\\n    /**\\n     * @notice This function is used to initiate the ownership renouncement.\\n     */\\n    function initiateOwnershipRenouncement() external onlyOwner {\\n        if (ownershipStatus != Status.NoOngoingTransfer) {\\n            revert TransferAlreadyInProgress();\\n        }\\n\\n        ownershipStatus = Status.RenouncementInProgress;\\n\\n        emit InitiateOwnershipRenouncement();\\n    }\\n\\n    function _onlyOwner() private view {\\n        if (msg.sender != owner) revert NotOwner();\\n    }\\n}\\n\"\r\n    },\r\n    \"@looksrare/contracts-libs/contracts/PackableReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n// Interfaces\\nimport {IReentrancyGuard} from \\\"./interfaces/IReentrancyGuard.sol\\\";\\n\\n/**\\n * @title PackableReentrancyGuard\\n * @notice This contract protects against reentrancy attacks.\\n *         It is adjusted from OpenZeppelin.\\n *         The only difference between this contract and ReentrancyGuard\\n *         is that _status is uint8 instead of uint256 so that it can be\\n *         packed with other contracts' storage variables.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\nabstract contract PackableReentrancyGuard is IReentrancyGuard {\\n    uint8 private _status;\\n\\n    /**\\n     * @notice Modifier to wrap functions to prevent reentrancy calls.\\n     */\\n    modifier nonReentrant() {\\n        if (_status == 2) {\\n            revert ReentrancyFail();\\n        }\\n\\n        _status = 2;\\n        _;\\n        _status = 1;\\n    }\\n\\n    constructor() {\\n        _status = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"@looksrare/contracts-libs/contracts/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @title Pausable\\n * @notice This contract makes it possible to pause the contract.\\n *         It is adjusted from OpenZeppelin.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\nabstract contract Pausable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    error IsPaused();\\n    error NotPaused();\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        if (paused()) {\\n            revert IsPaused();\\n        }\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        if (!paused()) {\\n            revert NotPaused();\\n        }\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Battle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.18;\\r\\n\\r\\nimport {LowLevelWETH} from \\\"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelWETH.sol\\\";\\r\\nimport {LowLevelERC20Transfer} from \\\"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC20Transfer.sol\\\";\\r\\nimport {LowLevelERC721Transfer} from \\\"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC721Transfer.sol\\\";\\r\\nimport {LowLevelERC1155Transfer} from \\\"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC1155Transfer.sol\\\";\\r\\nimport {OwnableTwoSteps} from \\\"@looksrare/contracts-libs/contracts/OwnableTwoSteps.sol\\\";\\r\\nimport {PackableReentrancyGuard} from \\\"@looksrare/contracts-libs/contracts/PackableReentrancyGuard.sol\\\";\\r\\nimport {Pausable} from \\\"@looksrare/contracts-libs/contracts/Pausable.sol\\\";\\r\\n\\r\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\\\";\\r\\nimport \\\"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\\\";\\r\\n\\r\\nimport {Arrays} from \\\"./libraries/Arrays.sol\\\";\\r\\n\\r\\nimport {WinningEntrySearchLogic} from \\\"./WinningEntrySearchLogic.sol\\\";\\r\\n\\r\\nimport \\\"./interfaces/IBattle.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Battle v1.0\\r\\n * @notice This contract allows anyone to permissionlessly host battles on BadDogs.io\\r\\n * @author BadDogs team\\r\\n */\\r\\ncontract Battle is\\r\\n    IBattle,\\r\\n    LowLevelWETH,\\r\\n    LowLevelERC20Transfer,\\r\\n    LowLevelERC721Transfer,\\r\\n    LowLevelERC1155Transfer,\\r\\n    VRFConsumerBaseV2,\\r\\n    OwnableTwoSteps,\\r\\n    PackableReentrancyGuard,\\r\\n    Pausable,\\r\\n    WinningEntrySearchLogic\\r\\n{\\r\\n    using Arrays for uint256[];\\r\\n\\r\\n    address public immutable WETH;\\r\\n\\r\\n    uint256 public constant ONE_HOUR = 3_600 seconds;\\r\\n    uint256 public constant ONE_WEEK = 604_800 seconds;\\r\\n\\r\\n    /**\\r\\n     * @notice 100% in basis points.\\r\\n     */\\r\\n    uint256 public constant ONE_HUNDRED_PERCENT_BP = 10_000;\\r\\n\\r\\n    /**\\r\\n     * @notice The number of battles created.\\r\\n     */\\r\\n    uint256 public battlesCount;\\r\\n\\r\\n    /**\\r\\n     * @notice The battles created.\\r\\n     * @dev The key is the battle ID.\\r\\n     */\\r\\n    mapping(uint256 => Battle) public battles;\\r\\n\\r\\n    /**\\r\\n     * @notice The participants stats of the battles.\\r\\n     * @dev The key is the battle ID and the nested key is the participant address.\\r\\n     */\\r\\n    mapping(uint256 => mapping(address => ParticipantStats))\\r\\n        public battlesParticipantsStats;\\r\\n\\r\\n    /**\\r\\n     * @notice It checks whether the currency is allowed.\\r\\n     */\\r\\n    mapping(address => bool) public isCurrencyAllowed;\\r\\n\\r\\n    /**\\r\\n     * @notice The maximum number of prizes per battle.\\r\\n     *         Each individual ERC-721 counts as one prize.\\r\\n     *         Each ETH/ERC-20/ERC-1155 with winnersCount > 1 counts as one prize.\\r\\n     */\\r\\n    uint256 public constant MAXIMUM_NUMBER_OF_PRIZES_PER_BATTLE = 20;\\r\\n\\r\\n    /**\\r\\n     * @notice The maximum number of winners per battle.\\r\\n     */\\r\\n    uint40 public constant MAXIMUM_NUMBER_OF_WINNERS_PER_BATTLE = 110;\\r\\n\\r\\n    /**\\r\\n     * @notice A Chainlink node should wait for 3 confirmations before responding.\\r\\n     */\\r\\n    uint16 public constant REQUEST_CONFIRMATIONS = 3;\\r\\n\\r\\n    /**\\r\\n     * @notice The key hash of the Chainlink VRF.\\r\\n     */\\r\\n    bytes32 public immutable KEY_HASH;\\r\\n\\r\\n    /**\\r\\n     * @notice The subscription ID of the Chainlink VRF.\\r\\n     */\\r\\n    uint64 public immutable SUBSCRIPTION_ID;\\r\\n\\r\\n    /**\\r\\n     * @notice The Chainlink VRF coordinator.\\r\\n     */\\r\\n    VRFCoordinatorV2Interface public immutable VRF_COORDINATOR;\\r\\n\\r\\n    /**\\r\\n     * @notice The randomness requests.\\r\\n     * @dev The key is the request ID returned by Chainlink.\\r\\n     */\\r\\n    mapping(uint256 => RandomnessRequest) public randomnessRequests;\\r\\n\\r\\n    /**\\r\\n     * @notice The maximum protocol fee in basis points, which is 25%.\\r\\n     */\\r\\n    uint16 public constant MAXIMUM_PROTOCOL_FEE_BP = 2_500;\\r\\n\\r\\n    /**\\r\\n     * @notice The protocol fee recipient.\\r\\n     */\\r\\n    address public protocolFeeRecipient;\\r\\n\\r\\n    /**\\r\\n     * @notice The protocol fee in basis points.\\r\\n     */\\r\\n    uint16 public protocolFeeBp;\\r\\n\\r\\n    /**\\r\\n     * @notice The claimable fees of the protocol fee recipient.\\r\\n     * @dev The key is the currency address.\\r\\n     */\\r\\n    mapping(address => uint256) public protocolFeeRecipientClaimableFees;\\r\\n\\r\\n    /**\\r\\n     * @notice The number of pricing options per battle.\\r\\n     */\\r\\n    uint256 public constant PRICING_OPTIONS_PER_BATTLE = 5;\\r\\n\\r\\n    /**\\r\\n     * @param _weth The WETH address\\r\\n     * @param _keyHash Chainlink VRF key hash\\r\\n     * @param _subscriptionId Chainlink VRF subscription ID\\r\\n     * @param _vrfCoordinator Chainlink VRF coordinator address\\r\\n     * @param _owner The owner of the contract\\r\\n     * @param _protocolFeeRecipient The recipient of the protocol fees\\r\\n     * @param _protocolFeeBp The protocol fee in basis points\\r\\n     */\\r\\n    constructor(\\r\\n        address _weth,\\r\\n        bytes32 _keyHash,\\r\\n        uint64 _subscriptionId,\\r\\n        address _vrfCoordinator,\\r\\n        address _owner,\\r\\n        address _protocolFeeRecipient,\\r\\n        uint16 _protocolFeeBp\\r\\n    ) VRFConsumerBaseV2(_vrfCoordinator) OwnableTwoSteps(_owner) {\\r\\n        _setProtocolFeeBp(_protocolFeeBp);\\r\\n        _setProtocolFeeRecipient(_protocolFeeRecipient);\\r\\n\\r\\n        WETH = _weth;\\r\\n        KEY_HASH = _keyHash;\\r\\n        VRF_COORDINATOR = VRFCoordinatorV2Interface(_vrfCoordinator);\\r\\n        SUBSCRIPTION_ID = _subscriptionId;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IBattle\\r\\n     * @dev This function can still be called when the contract is paused because the battle creator\\r\\n     *      would not be able to deposit prizes and open the battle anyway. The restriction to disallow\\r\\n     *      battles creation when the contract is paused will be enforced in the frontend.\\r\\n     */\\r\\n    function createBattle(\\r\\n        CreateBattleCalldata calldata params\\r\\n    ) external payable nonReentrant whenNotPaused returns (uint256 battleId) {\\r\\n        uint40 cutoffTime = params.cutoffTime;\\r\\n        if (\\r\\n            _unsafeAdd(block.timestamp, ONE_HOUR) > cutoffTime ||\\r\\n            cutoffTime > _unsafeAdd(block.timestamp, ONE_WEEK)\\r\\n        ) {\\r\\n            revert InvalidCutoffTime();\\r\\n        }\\r\\n\\r\\n        uint16 agreedProtocolFeeBp = params.protocolFeeBp;\\r\\n        if (agreedProtocolFeeBp != protocolFeeBp) {\\r\\n            revert InvalidProtocolFeeBp();\\r\\n        }\\r\\n\\r\\n        address feeTokenAddress = params.feeTokenAddress;\\r\\n        if (feeTokenAddress != address(0)) {\\r\\n            if (!isCurrencyAllowed[feeTokenAddress]) {\\r\\n                revert InvalidCurrency();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        unchecked {\\r\\n            battleId = ++battlesCount;\\r\\n        }\\r\\n\\r\\n        uint256 prizesCount = params.prizes.length;\\r\\n        if (\\r\\n            prizesCount == 0 ||\\r\\n            prizesCount > MAXIMUM_NUMBER_OF_PRIZES_PER_BATTLE\\r\\n        ) {\\r\\n            revert InvalidPrizesCount();\\r\\n        }\\r\\n\\r\\n        Battle storage battle = battles[battleId];\\r\\n\\r\\n        uint40 cumulativeWinnersCount;\\r\\n        uint8 currentPrizeTier;\\r\\n        for (uint256 i; i < prizesCount; ) {\\r\\n            Prize memory prize = params.prizes[i];\\r\\n            if (prize.prizeTier < currentPrizeTier) {\\r\\n                revert InvalidPrize();\\r\\n            }\\r\\n            _validatePrize(prize);\\r\\n\\r\\n            uint256 expectedEthValue;\\r\\n\\r\\n            TokenType prizeType = prize.prizeType;\\r\\n            if (prizeType == TokenType.ERC721) {\\r\\n                _executeERC721TransferFrom(\\r\\n                    prize.prizeAddress,\\r\\n                    msg.sender,\\r\\n                    address(this),\\r\\n                    prize.prizeId\\r\\n                );\\r\\n            } else if (prizeType == TokenType.ERC20) {\\r\\n                _executeERC20TransferFrom(\\r\\n                    prize.prizeAddress,\\r\\n                    msg.sender,\\r\\n                    address(this),\\r\\n                    prize.prizeAmount * prize.winnersCount\\r\\n                );\\r\\n            } else if (prizeType == TokenType.ETH) {\\r\\n                expectedEthValue += (prize.prizeAmount * prize.winnersCount);\\r\\n            } else {\\r\\n                _executeERC1155SafeTransferFrom(\\r\\n                    prize.prizeAddress,\\r\\n                    msg.sender,\\r\\n                    address(this),\\r\\n                    prize.prizeId,\\r\\n                    prize.prizeAmount * prize.winnersCount\\r\\n                );\\r\\n            }\\r\\n            cumulativeWinnersCount += prize.winnersCount;\\r\\n            prize.cumulativeWinnersCount = cumulativeWinnersCount;\\r\\n            currentPrizeTier = prize.prizeTier;\\r\\n            battle.prizes.push(prize);\\r\\n\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n            _validateExpectedEthValueOrRefund(expectedEthValue);\\r\\n        }\\r\\n\\r\\n        uint40 minimumEntries = params.minimumEntries;\\r\\n        if (\\r\\n            cumulativeWinnersCount > minimumEntries ||\\r\\n            cumulativeWinnersCount > MAXIMUM_NUMBER_OF_WINNERS_PER_BATTLE\\r\\n        ) {\\r\\n            revert InvalidWinnersCount();\\r\\n        }\\r\\n\\r\\n        _validateAndSetPricingOptions(battleId, params.pricingOptions);\\r\\n\\r\\n        battle.owner = msg.sender;\\r\\n        battle.isMinimumEntriesFixed = params.isMinimumEntriesFixed;\\r\\n        battle.cutoffTime = cutoffTime;\\r\\n        battle.minimumEntries = minimumEntries;\\r\\n        battle.maximumEntriesPerParticipant = params\\r\\n            .maximumEntriesPerParticipant;\\r\\n        battle.protocolFeeBp = agreedProtocolFeeBp;\\r\\n        battle.feeTokenAddress = feeTokenAddress;\\r\\n\\r\\n        _setBattleStatus(battle, battleId, BattleStatus.Open);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev This function is required in order for the contract to receive ERC-1155 tokens.\\r\\n     */\\r\\n    function onERC1155Received(\\r\\n        address,\\r\\n        address,\\r\\n        uint256,\\r\\n        uint256,\\r\\n        bytes calldata\\r\\n    ) external pure returns (bytes4) {\\r\\n        return this.onERC1155Received.selector;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IBattle\\r\\n     */\\r\\n    function enterBattles(\\r\\n        EntryCalldata[] calldata entries\\r\\n    ) external payable nonReentrant whenNotPaused {\\r\\n        uint256 entriesCount = entries.length;\\r\\n        uint208 expectedEthValue;\\r\\n        for (uint256 i; i < entriesCount; ) {\\r\\n            EntryCalldata calldata entry = entries[i];\\r\\n\\r\\n            if (entry.pricingOptionIndex >= PRICING_OPTIONS_PER_BATTLE) {\\r\\n                revert InvalidIndex();\\r\\n            }\\r\\n\\r\\n            uint256 battleId = entry.battleId;\\r\\n            Battle storage battle = battles[battleId];\\r\\n\\r\\n            _validateBattleStatus(battle, BattleStatus.Open);\\r\\n\\r\\n            if (block.timestamp >= battle.cutoffTime) {\\r\\n                revert CutoffTimeReached();\\r\\n            }\\r\\n\\r\\n            PricingOption memory pricingOption = battle.pricingOptions[\\r\\n                entry.pricingOptionIndex\\r\\n            ];\\r\\n\\r\\n            uint40 newParticipantEntriesCount = battlesParticipantsStats[\\r\\n                battleId\\r\\n            ][msg.sender].entriesCount + pricingOption.entriesCount;\\r\\n            if (\\r\\n                newParticipantEntriesCount > battle.maximumEntriesPerParticipant\\r\\n            ) {\\r\\n                revert MaximumEntriesPerParticipantReached();\\r\\n            }\\r\\n            battlesParticipantsStats[battleId][msg.sender]\\r\\n                .entriesCount = newParticipantEntriesCount;\\r\\n\\r\\n            uint208 price = pricingOption.price;\\r\\n\\r\\n            if (battle.feeTokenAddress == address(0)) {\\r\\n                expectedEthValue += price;\\r\\n            } else {\\r\\n                _executeERC20TransferFrom(\\r\\n                    battle.feeTokenAddress,\\r\\n                    msg.sender,\\r\\n                    address(this),\\r\\n                    price\\r\\n                );\\r\\n            }\\r\\n\\r\\n            uint40 currentEntryIndex;\\r\\n            uint256 battleEntriesCount = battle.entries.length;\\r\\n            if (battleEntriesCount == 0) {\\r\\n                currentEntryIndex = uint40(\\r\\n                    _unsafeSubtract(pricingOption.entriesCount, 1)\\r\\n                );\\r\\n            } else {\\r\\n                currentEntryIndex =\\r\\n                    battle\\r\\n                        .entries[_unsafeSubtract(battleEntriesCount, 1)]\\r\\n                        .currentEntryIndex +\\r\\n                    pricingOption.entriesCount;\\r\\n            }\\r\\n\\r\\n            if (battle.isMinimumEntriesFixed) {\\r\\n                if (currentEntryIndex >= battle.minimumEntries) {\\r\\n                    revert MaximumEntriesReached();\\r\\n                }\\r\\n            }\\r\\n\\r\\n            battle.entries.push(\\r\\n                Entry({\\r\\n                    currentEntryIndex: currentEntryIndex,\\r\\n                    participant: msg.sender\\r\\n                })\\r\\n            );\\r\\n            battle.claimableFees += price;\\r\\n\\r\\n            battlesParticipantsStats[battleId][msg.sender].amountPaid += price;\\r\\n\\r\\n            emit EntrySold(\\r\\n                battleId,\\r\\n                msg.sender,\\r\\n                pricingOption.entriesCount,\\r\\n                price\\r\\n            );\\r\\n\\r\\n            if (\\r\\n                currentEntryIndex >= _unsafeSubtract(battle.minimumEntries, 1)\\r\\n            ) {\\r\\n                _drawWinners(battleId, battle);\\r\\n            }\\r\\n\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        _validateExpectedEthValueOrRefund(expectedEthValue);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param _requestId The ID of the request\\r\\n     * @param _randomWords The random words returned by Chainlink\\r\\n     */\\r\\n    function fulfillRandomWords(\\r\\n        uint256 _requestId,\\r\\n        uint256[] memory _randomWords\\r\\n    ) internal override {\\r\\n        if (randomnessRequests[_requestId].exists) {\\r\\n            uint256 battleId = randomnessRequests[_requestId].battleId;\\r\\n            Battle storage battle = battles[battleId];\\r\\n\\r\\n            if (battle.status == BattleStatus.Drawing) {\\r\\n                _setBattleStatus(\\r\\n                    battle,\\r\\n                    battleId,\\r\\n                    BattleStatus.RandomnessFulfilled\\r\\n                );\\r\\n                // We ignore the most significant byte to pack the random word with `exists`\\r\\n                randomnessRequests[_requestId].randomWord = uint248(\\r\\n                    _randomWords[0]\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IBattle\\r\\n     */\\r\\n    function selectWinners(uint256 requestId) external {\\r\\n        RandomnessRequest memory randomnessRequest = randomnessRequests[\\r\\n            requestId\\r\\n        ];\\r\\n        if (!randomnessRequest.exists) {\\r\\n            revert RandomnessRequestDoesNotExist();\\r\\n        }\\r\\n\\r\\n        uint256 battleId = randomnessRequest.battleId;\\r\\n        Battle storage battle = battles[battleId];\\r\\n        _validateBattleStatus(battle, BattleStatus.RandomnessFulfilled);\\r\\n\\r\\n        _setBattleStatus(battle, battleId, BattleStatus.Drawn);\\r\\n\\r\\n        Prize[] storage prizes = battle.prizes;\\r\\n        uint256 prizesCount = prizes.length;\\r\\n        uint256 winnersCount = prizes[prizesCount - 1].cumulativeWinnersCount;\\r\\n\\r\\n        Entry[] memory entries = battle.entries;\\r\\n        uint256 entriesCount = entries.length;\\r\\n        uint256 currentEntryIndex = uint256(\\r\\n            entries[entriesCount - 1].currentEntryIndex\\r\\n        );\\r\\n\\r\\n        uint256[] memory winningEntriesBitmap = new uint256[](\\r\\n            (currentEntryIndex >> 8) + 1\\r\\n        );\\r\\n\\r\\n        uint256[] memory currentEntryIndexArray = new uint256[](entriesCount);\\r\\n        for (uint256 i; i < entriesCount; ) {\\r\\n            currentEntryIndexArray[i] = entries[i].currentEntryIndex;\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256[] memory cumulativeWinnersCountArray = new uint256[](\\r\\n            prizesCount\\r\\n        );\\r\\n        for (uint256 i; i < prizesCount; ) {\\r\\n            cumulativeWinnersCountArray[i] = prizes[i].cumulativeWinnersCount;\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 randomWord = randomnessRequest.randomWord;\\r\\n\\r\\n        for (uint256 i; i < winnersCount; ) {\\r\\n            uint256 winningEntry = randomWord % (currentEntryIndex + 1);\\r\\n            (\\r\\n                winningEntry,\\r\\n                winningEntriesBitmap\\r\\n            ) = _incrementWinningEntryUntilThereIsNotADuplicate(\\r\\n                currentEntryIndex,\\r\\n                winningEntry,\\r\\n                winningEntriesBitmap\\r\\n            );\\r\\n\\r\\n            battle.winners.push(\\r\\n                Winner({\\r\\n                    participant: entries[\\r\\n                        currentEntryIndexArray.findUpperBound(winningEntry)\\r\\n                    ].participant,\\r\\n                    claimed: false,\\r\\n                    prizeIndex: uint8(\\r\\n                        cumulativeWinnersCountArray.findUpperBound(\\r\\n                            _unsafeAdd(i, 1)\\r\\n                        )\\r\\n                    ),\\r\\n                    entryIndex: uint40(winningEntry)\\r\\n                })\\r\\n            );\\r\\n\\r\\n            randomWord = uint256(keccak256(abi.encodePacked(randomWord)));\\r\\n\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IBattle\\r\\n     */\\r\\n    function claimPrizes(\\r\\n        ClaimPrizesCalldata[] calldata claimPrizesCalldata\\r\\n    ) external nonReentrant whenNotPaused {\\r\\n        uint256 claimsCount = claimPrizesCalldata.length;\\r\\n        for (uint256 i; i < claimsCount; ) {\\r\\n            _claimPrizesPerBattle(claimPrizesCalldata[i]);\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IBattle\\r\\n     */\\r\\n    function claimProtocolFees(address currency) external onlyOwner {\\r\\n        uint256 claimableFees = protocolFeeRecipientClaimableFees[currency];\\r\\n        protocolFeeRecipientClaimableFees[currency] = 0;\\r\\n        _transferFungibleTokens(currency, protocolFeeRecipient, claimableFees);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IBattle\\r\\n     */\\r\\n    function claimFees(uint256 battleId) external nonReentrant whenNotPaused {\\r\\n        Battle storage battle = battles[battleId];\\r\\n        _validateBattleStatus(battle, BattleStatus.Drawn);\\r\\n\\r\\n        address battleOwner = battle.owner;\\r\\n        if (msg.sender != battleOwner) {\\r\\n            _validateCaller(owner);\\r\\n        }\\r\\n\\r\\n        uint208 claimableFees = battle.claimableFees;\\r\\n        uint208 protocolFees = (claimableFees * uint208(battle.protocolFeeBp)) /\\r\\n            uint208(ONE_HUNDRED_PERCENT_BP);\\r\\n        unchecked {\\r\\n            claimableFees -= protocolFees;\\r\\n        }\\r\\n\\r\\n        _setBattleStatus(battle, battleId, BattleStatus.Complete);\\r\\n\\r\\n        battle.claimableFees = 0;\\r\\n\\r\\n        address feeTokenAddress = battle.feeTokenAddress;\\r\\n        _transferFungibleTokens(feeTokenAddress, battleOwner, claimableFees);\\r\\n\\r\\n        if (protocolFees != 0) {\\r\\n            protocolFeeRecipientClaimableFees[feeTokenAddress] += protocolFees;\\r\\n        }\\r\\n\\r\\n        emit FeesClaimed(battleId, claimableFees);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IBattle\\r\\n     */\\r\\n    function cancel(uint256 battleId) external nonReentrant whenNotPaused {\\r\\n        Battle storage battle = battles[battleId];\\r\\n        bool isOpen = battle.status == BattleStatus.Open;\\r\\n\\r\\n        if (isOpen) {\\r\\n            if (battle.cutoffTime > block.timestamp) {\\r\\n                revert CutoffTimeNotReached();\\r\\n            }\\r\\n        } else {\\r\\n            _validateBattleStatus(battle, BattleStatus.Created);\\r\\n        }\\r\\n\\r\\n        _setBattleStatus(\\r\\n            battle,\\r\\n            battleId,\\r\\n            isOpen ? BattleStatus.Refundable : BattleStatus.Cancelled\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IBattle\\r\\n     */\\r\\n    function cancelAfterRandomnessRequest(\\r\\n        uint256 battleId\\r\\n    ) external onlyOwner nonReentrant {\\r\\n        Battle storage battle = battles[battleId];\\r\\n\\r\\n        _validateBattleStatus(battle, BattleStatus.Drawing);\\r\\n\\r\\n        if (block.timestamp < battle.drawnAt + ONE_HOUR) {\\r\\n            revert DrawExpirationTimeNotReached();\\r\\n        }\\r\\n\\r\\n        _setBattleStatus(battle, battleId, BattleStatus.Refundable);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IBattle\\r\\n     */\\r\\n    function withdrawPrizes(\\r\\n        uint256 battleId\\r\\n    ) external nonReentrant whenNotPaused {\\r\\n        Battle storage battle = battles[battleId];\\r\\n        _validateBattleStatus(battle, BattleStatus.Refundable);\\r\\n\\r\\n        _setBattleStatus(battle, battleId, BattleStatus.Cancelled);\\r\\n\\r\\n        uint256 prizesCount = battle.prizes.length;\\r\\n        address battleOwner = battle.owner;\\r\\n        for (uint256 i; i < prizesCount; ) {\\r\\n            Prize storage prize = battle.prizes[i];\\r\\n            _transferPrize({\\r\\n                prize: prize,\\r\\n                recipient: battleOwner,\\r\\n                multiplier: uint256(prize.winnersCount)\\r\\n            });\\r\\n\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IBattle\\r\\n     * @dev Refundable and Cancelled are the only statuses that allow refunds.\\r\\n     */\\r\\n    function claimRefund(\\r\\n        uint256[] calldata battleIds\\r\\n    ) external nonReentrant whenNotPaused {\\r\\n        uint256 count = battleIds.length;\\r\\n\\r\\n        for (uint256 i; i < count; ) {\\r\\n            uint256 battleId = battleIds[i];\\r\\n            Battle storage battle = battles[battleId];\\r\\n\\r\\n            if (battle.status < BattleStatus.Refundable) {\\r\\n                revert InvalidStatus();\\r\\n            }\\r\\n\\r\\n            ParticipantStats storage stats = battlesParticipantsStats[battleId][\\r\\n                msg.sender\\r\\n            ];\\r\\n\\r\\n            if (stats.refunded) {\\r\\n                revert AlreadyRefunded();\\r\\n            }\\r\\n\\r\\n            stats.refunded = true;\\r\\n\\r\\n            uint208 amountPaid = stats.amountPaid;\\r\\n            _transferFungibleTokens(\\r\\n                battle.feeTokenAddress,\\r\\n                msg.sender,\\r\\n                amountPaid\\r\\n            );\\r\\n\\r\\n            emit EntryRefunded(battleId, msg.sender, amountPaid);\\r\\n\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IBattle\\r\\n     */\\r\\n    function setProtocolFeeRecipient(\\r\\n        address _protocolFeeRecipient\\r\\n    ) external onlyOwner {\\r\\n        _setProtocolFeeRecipient(_protocolFeeRecipient);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IBattle\\r\\n     */\\r\\n    function setProtocolFeeBp(uint16 _protocolFeeBp) external onlyOwner {\\r\\n        _setProtocolFeeBp(_protocolFeeBp);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IBattle\\r\\n     */\\r\\n    function updateCurrenciesStatus(\\r\\n        address[] calldata currencies,\\r\\n        bool isAllowed\\r\\n    ) external onlyOwner {\\r\\n        uint256 count = currencies.length;\\r\\n        for (uint256 i; i < count; ) {\\r\\n            isCurrencyAllowed[currencies[i]] = isAllowed;\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n        emit CurrenciesStatusUpdated(currencies, isAllowed);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IBattle\\r\\n     */\\r\\n    function togglePaused() external onlyOwner {\\r\\n        paused() ? _unpause() : _pause();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IBattle\\r\\n     */\\r\\n    function getWinners(\\r\\n        uint256 battleId\\r\\n    ) external view returns (Winner[] memory winners) {\\r\\n        winners = battles[battleId].winners;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IBattle\\r\\n     */\\r\\n    function getPrizes(\\r\\n        uint256 battleId\\r\\n    ) external view returns (Prize[] memory prizes) {\\r\\n        prizes = battles[battleId].prizes;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IBattle\\r\\n     */\\r\\n    function getEntries(\\r\\n        uint256 battleId\\r\\n    ) external view returns (Entry[] memory entries) {\\r\\n        entries = battles[battleId].entries;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IBattle\\r\\n     */\\r\\n    function getPricingOptions(\\r\\n        uint256 battleId\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            PricingOption[PRICING_OPTIONS_PER_BATTLE] memory pricingOptions\\r\\n        )\\r\\n    {\\r\\n        pricingOptions = battles[battleId].pricingOptions;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param _protocolFeeRecipient The new protocol fee recipient address\\r\\n     */\\r\\n    function _setProtocolFeeRecipient(address _protocolFeeRecipient) private {\\r\\n        if (_protocolFeeRecipient == address(0)) {\\r\\n            revert InvalidProtocolFeeRecipient();\\r\\n        }\\r\\n        protocolFeeRecipient = _protocolFeeRecipient;\\r\\n        emit ProtocolFeeRecipientUpdated(_protocolFeeRecipient);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param _protocolFeeBp The new protocol fee in basis points\\r\\n     */\\r\\n    function _setProtocolFeeBp(uint16 _protocolFeeBp) private {\\r\\n        if (_protocolFeeBp > MAXIMUM_PROTOCOL_FEE_BP) {\\r\\n            revert InvalidProtocolFeeBp();\\r\\n        }\\r\\n        protocolFeeBp = _protocolFeeBp;\\r\\n        emit ProtocolFeeBpUpdated(_protocolFeeBp);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param battleId The ID of the battle.\\r\\n     * @param pricingOptions The pricing options for the battle.\\r\\n     */\\r\\n    function _validateAndSetPricingOptions(\\r\\n        uint256 battleId,\\r\\n        PricingOption[PRICING_OPTIONS_PER_BATTLE] calldata pricingOptions\\r\\n    ) private {\\r\\n        for (uint256 i; i < PRICING_OPTIONS_PER_BATTLE; ) {\\r\\n            PricingOption memory pricingOption = pricingOptions[i];\\r\\n\\r\\n            uint40 entriesCount = pricingOption.entriesCount;\\r\\n            uint208 price = pricingOption.price;\\r\\n\\r\\n            if (i == 0) {\\r\\n                if (entriesCount != 1 || price == 0) {\\r\\n                    revert InvalidPricingOption();\\r\\n                }\\r\\n            } else {\\r\\n                PricingOption memory lastPricingOption = pricingOptions[\\r\\n                    _unsafeSubtract(i, 1)\\r\\n                ];\\r\\n                uint208 lastPrice = lastPricingOption.price;\\r\\n                uint40 lastEntriesCount = lastPricingOption.entriesCount;\\r\\n\\r\\n                if (\\r\\n                    price % entriesCount != 0 ||\\r\\n                    entriesCount <= lastEntriesCount ||\\r\\n                    price <= lastPrice ||\\r\\n                    price / entriesCount > lastPrice / lastEntriesCount\\r\\n                ) {\\r\\n                    revert InvalidPricingOption();\\r\\n                }\\r\\n            }\\r\\n\\r\\n            battles[battleId].pricingOptions[i] = pricingOption;\\r\\n\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param prize The prize.\\r\\n     */\\r\\n    function _validatePrize(Prize memory prize) private view {\\r\\n        if (prize.prizeType == TokenType.ERC721) {\\r\\n            if (prize.prizeAmount != 1 || prize.winnersCount != 1) {\\r\\n                revert InvalidPrize();\\r\\n            }\\r\\n        } else {\\r\\n            if (prize.prizeType == TokenType.ERC20) {\\r\\n                if (!isCurrencyAllowed[prize.prizeAddress]) {\\r\\n                    revert InvalidCurrency();\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if (prize.prizeAmount == 0 || prize.winnersCount == 0) {\\r\\n                revert InvalidPrize();\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param prize The prize to transfer.\\r\\n     * @param recipient The recipient of the prize.\\r\\n     * @param multiplier The multiplier to apply to the prize amount.\\r\\n     */\\r\\n    function _transferPrize(\\r\\n        Prize storage prize,\\r\\n        address recipient,\\r\\n        uint256 multiplier\\r\\n    ) private {\\r\\n        TokenType prizeType = prize.prizeType;\\r\\n        address prizeAddress = prize.prizeAddress;\\r\\n        if (prizeType == TokenType.ERC721) {\\r\\n            _executeERC721TransferFrom(\\r\\n                prizeAddress,\\r\\n                address(this),\\r\\n                recipient,\\r\\n                prize.prizeId\\r\\n            );\\r\\n        } else if (prizeType == TokenType.ERC1155) {\\r\\n            _executeERC1155SafeTransferFrom(\\r\\n                prizeAddress,\\r\\n                address(this),\\r\\n                recipient,\\r\\n                prize.prizeId,\\r\\n                prize.prizeAmount * multiplier\\r\\n            );\\r\\n        } else {\\r\\n            _transferFungibleTokens(\\r\\n                prizeAddress,\\r\\n                recipient,\\r\\n                prize.prizeAmount * multiplier\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param currency The currency to transfer.\\r\\n     * @param recipient The recipient of the currency.\\r\\n     * @param amount The amount of currency to transfer.\\r\\n     */\\r\\n    function _transferFungibleTokens(\\r\\n        address currency,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) private {\\r\\n        if (currency == address(0)) {\\r\\n            _transferETHAndWrapIfFailWithGasLimit(\\r\\n                WETH,\\r\\n                recipient,\\r\\n                amount,\\r\\n                gasleft()\\r\\n            );\\r\\n        } else {\\r\\n            _executeERC20DirectTransfer(currency, recipient, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param claimPrizesCalldata The calldata for claiming prizes.\\r\\n     */\\r\\n    function _claimPrizesPerBattle(\\r\\n        ClaimPrizesCalldata calldata claimPrizesCalldata\\r\\n    ) private {\\r\\n        uint256 battleId = claimPrizesCalldata.battleId;\\r\\n        Battle storage battle = battles[battleId];\\r\\n        BattleStatus status = battle.status;\\r\\n        if (status != BattleStatus.Drawn) {\\r\\n            _validateBattleStatus(battle, BattleStatus.Complete);\\r\\n        }\\r\\n\\r\\n        Winner[] storage winners = battle.winners;\\r\\n        uint256[] calldata winnerIndices = claimPrizesCalldata.winnerIndices;\\r\\n        uint256 winnersCount = winners.length;\\r\\n        uint256 claimsCount = winnerIndices.length;\\r\\n        for (uint256 i; i < claimsCount; ) {\\r\\n            uint256 winnerIndex = winnerIndices[i];\\r\\n\\r\\n            if (winnerIndex >= winnersCount) {\\r\\n                revert InvalidIndex();\\r\\n            }\\r\\n\\r\\n            Winner storage winner = winners[winnerIndex];\\r\\n            if (winner.claimed) {\\r\\n                revert PrizeAlreadyClaimed();\\r\\n            }\\r\\n            _validateCaller(winner.participant);\\r\\n            winner.claimed = true;\\r\\n\\r\\n            Prize storage prize = battle.prizes[winner.prizeIndex];\\r\\n            _transferPrize({\\r\\n                prize: prize,\\r\\n                recipient: msg.sender,\\r\\n                multiplier: 1\\r\\n            });\\r\\n\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit PrizesClaimed(battleId, winnerIndices);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param battleId The ID of the battle to draw winners for.\\r\\n     * @param battle The battle to draw winners for.\\r\\n     */\\r\\n    function _drawWinners(uint256 battleId, Battle storage battle) private {\\r\\n        _setBattleStatus(battle, battleId, BattleStatus.Drawing);\\r\\n        battle.drawnAt = uint40(block.timestamp);\\r\\n\\r\\n        uint256 requestId = VRF_COORDINATOR.requestRandomWords(\\r\\n            KEY_HASH,\\r\\n            SUBSCRIPTION_ID,\\r\\n            REQUEST_CONFIRMATIONS,\\r\\n            uint32(500_000),\\r\\n            uint32(1)\\r\\n        );\\r\\n\\r\\n        if (randomnessRequests[requestId].exists) {\\r\\n            revert RandomnessRequestAlreadyExists();\\r\\n        }\\r\\n\\r\\n        randomnessRequests[requestId].exists = true;\\r\\n        randomnessRequests[requestId].battleId = battleId;\\r\\n\\r\\n        emit RandomnessRequested(battleId, requestId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param battle The battle to check the status of.\\r\\n     * @param status The expected status of the battle\\r\\n     */\\r\\n    function _validateBattleStatus(\\r\\n        Battle storage battle,\\r\\n        BattleStatus status\\r\\n    ) private view {\\r\\n        if (battle.status != status) {\\r\\n            revert InvalidStatus();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param caller The expected caller.\\r\\n     */\\r\\n    function _validateCaller(address caller) private view {\\r\\n        if (msg.sender != caller) {\\r\\n            revert InvalidCaller();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param expectedEthValue The expected ETH value to be sent by the caller.\\r\\n     */\\r\\n    function _validateExpectedEthValueOrRefund(\\r\\n        uint256 expectedEthValue\\r\\n    ) private {\\r\\n        if (expectedEthValue > msg.value) {\\r\\n            revert InsufficientNativeTokensSupplied();\\r\\n        } else if (msg.value > expectedEthValue) {\\r\\n            _transferETHAndWrapIfFailWithGasLimit(\\r\\n                WETH,\\r\\n                msg.sender,\\r\\n                _unsafeSubtract(msg.value, expectedEthValue),\\r\\n                gasleft()\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param battle The battle to set the status of.\\r\\n     * @param battleId The ID of the battle to set the status of.\\r\\n     * @param status The status to set.\\r\\n     */\\r\\n    function _setBattleStatus(\\r\\n        Battle storage battle,\\r\\n        uint256 battleId,\\r\\n        BattleStatus status\\r\\n    ) private {\\r\\n        battle.status = status;\\r\\n        emit BattleStatusUpdated(battleId, status);\\r\\n    }\\r\\n\\r\\n    function _unsafeAdd(uint256 a, uint256 b) private pure returns (uint256) {\\r\\n        unchecked {\\r\\n            return a + b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _unsafeSubtract(\\r\\n        uint256 a,\\r\\n        uint256 b\\r\\n    ) private pure returns (uint256) {\\r\\n        unchecked {\\r\\n            return a - b;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IBattle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.18;\\r\\n\\r\\ninterface IBattle {\\r\\n    enum BattleStatus {\\r\\n        None,\\r\\n        Created,\\r\\n        Open,\\r\\n        Drawing,\\r\\n        RandomnessFulfilled,\\r\\n        Drawn,\\r\\n        Complete,\\r\\n        Refundable,\\r\\n        Cancelled\\r\\n    }\\r\\n\\r\\n    enum TokenType {\\r\\n        ERC721,\\r\\n        ERC1155,\\r\\n        ETH,\\r\\n        ERC20\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param entriesCount The number of entries that can be purchased for the given price.\\r\\n     * @param price The price of the entries.\\r\\n     */\\r\\n    struct PricingOption {\\r\\n        uint40 entriesCount;\\r\\n        uint208 price;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param currentEntryIndex The cumulative number of entries in the battle.\\r\\n     * @param participant The address of the participant.\\r\\n     */\\r\\n    struct Entry {\\r\\n        uint40 currentEntryIndex;\\r\\n        address participant;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param participant The address of the winner.\\r\\n     * @param claimed Whether the winner has claimed the prize.\\r\\n     * @param prizeIndex The index of the prize that was won.\\r\\n     * @param entryIndex The index of the entry that won.\\r\\n     */\\r\\n    struct Winner {\\r\\n        address participant;\\r\\n        bool claimed;\\r\\n        uint8 prizeIndex;\\r\\n        uint40 entryIndex;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param winnersCount The number of winners.\\r\\n     * @param cumulativeWinnersCount The cumulative number of winners in the battle.\\r\\n     * @param prizeType The type of the prize.\\r\\n     * @param prizeTier The tier of the prize.\\r\\n     * @param prizeAddress The address of the prize.\\r\\n     * @param prizeId The id of the prize.\\r\\n     * @param prizeAmount The amount of the prize.\\r\\n     */\\r\\n    struct Prize {\\r\\n        uint40 winnersCount;\\r\\n        uint40 cumulativeWinnersCount;\\r\\n        TokenType prizeType;\\r\\n        uint8 prizeTier;\\r\\n        address prizeAddress;\\r\\n        uint256 prizeId;\\r\\n        uint256 prizeAmount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param owner The address of the battle owner.\\r\\n     * @param status The status of the battle.\\r\\n     * @param isMinimumEntriesFixed Whether the minimum number of entries is fixed.\\r\\n     * @param cutoffTime The time after which the battle cannot be entered.\\r\\n     * @param drawnAt The time at which the battle was drawn. It is still pending Chainlink to fulfill the randomness request.\\r\\n     * @param minimumEntries The minimum number of entries required to draw the battle.\\r\\n     * @param maximumEntriesPerParticipant The maximum number of entries allowed per participant.\\r\\n     * @param feeTokenAddress The address of the token to be used as a fee. If the fee token type is ETH, then this address is ignored.\\r\\n     * @param protocolFeeBp The protocol fee in basis points. It must be equal to the protocol fee basis points when the battle was created.\\r\\n     * @param claimableFees The amount of fees collected from selling entries.\\r\\n     * @param pricingOptions The pricing options for the battle.\\r\\n     * @param prizes The prizes to be distributed.\\r\\n     * @param entries The entries that have been sold.\\r\\n     * @param winners The winners of the battle.\\r\\n     */\\r\\n    struct Battle {\\r\\n        address owner;\\r\\n        BattleStatus status;\\r\\n        bool isMinimumEntriesFixed;\\r\\n        uint40 cutoffTime;\\r\\n        uint40 drawnAt;\\r\\n        uint40 minimumEntries;\\r\\n        uint40 maximumEntriesPerParticipant;\\r\\n        address feeTokenAddress;\\r\\n        uint16 protocolFeeBp;\\r\\n        uint208 claimableFees;\\r\\n        PricingOption[5] pricingOptions;\\r\\n        Prize[] prizes;\\r\\n        Entry[] entries;\\r\\n        Winner[] winners;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param amountPaid The amount paid by the participant.\\r\\n     * @param entriesCount The number of entries purchased by the participant.\\r\\n     * @param refunded Whether the participant has been refunded.\\r\\n     */\\r\\n    struct ParticipantStats {\\r\\n        uint208 amountPaid;\\r\\n        uint40 entriesCount;\\r\\n        bool refunded;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param battleId The id of the battle.\\r\\n     * @param pricingOptionIndex The index of the selected pricing option.\\r\\n     */\\r\\n    struct EntryCalldata {\\r\\n        uint256 battleId;\\r\\n        uint256 pricingOptionIndex;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param cutoffTime The time at which the battle will be closed.\\r\\n     * @param minimumEntries The minimum number of entries required to draw the battle.\\r\\n     * @param isMinimumEntriesFixed Whether the minimum number of entries is fixed.\\r\\n     * @param maximumEntriesPerParticipant The maximum number of entries allowed per participant.\\r\\n     * @param protocolFeeBp The protocol fee in basis points. It must be equal to the protocol fee basis points when the battle was created.\\r\\n     * @param feeTokenAddress The address of the token to be used as a fee. If the fee token type is ETH, then this address is ignored.\\r\\n     * @param prizes The prizes to be distributed.\\r\\n     * @param pricingOptions The pricing options for the battle.\\r\\n     */\\r\\n    struct CreateBattleCalldata {\\r\\n        uint40 cutoffTime;\\r\\n        bool isMinimumEntriesFixed;\\r\\n        uint40 minimumEntries;\\r\\n        uint40 maximumEntriesPerParticipant;\\r\\n        uint16 protocolFeeBp;\\r\\n        address feeTokenAddress;\\r\\n        Prize[] prizes;\\r\\n        PricingOption[5] pricingOptions;\\r\\n    }\\r\\n\\r\\n    struct ClaimPrizesCalldata {\\r\\n        uint256 battleId;\\r\\n        uint256[] winnerIndices;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param exists Whether the request exists.\\r\\n     * @param battleId The id of the battle.\\r\\n     * @param randomWord The random words returned by Chainlink VRF.\\r\\n     *                   If randomWord == 0, then the request is still pending.\\r\\n     */\\r\\n    struct RandomnessRequest {\\r\\n        bool exists;\\r\\n        uint248 randomWord;\\r\\n        uint256 battleId;\\r\\n    }\\r\\n\\r\\n    event CurrenciesStatusUpdated(address[] currencies, bool isAllowed);\\r\\n    event EntryRefunded(uint256 battleId, address buyer, uint208 amount);\\r\\n    event EntrySold(\\r\\n        uint256 battleId,\\r\\n        address buyer,\\r\\n        uint40 entriesCount,\\r\\n        uint208 price\\r\\n    );\\r\\n    event FeesClaimed(uint256 battleId, uint256 amount);\\r\\n    event PrizesClaimed(uint256 battleId, uint256[] winnerIndex);\\r\\n    event ProtocolFeeBpUpdated(uint16 protocolFeeBp);\\r\\n    event ProtocolFeeRecipientUpdated(address protocolFeeRecipient);\\r\\n    event BattleStatusUpdated(uint256 battleId, BattleStatus status);\\r\\n    event RandomnessRequested(uint256 battleId, uint256 requestId);\\r\\n\\r\\n    error AlreadyRefunded();\\r\\n    error CutoffTimeNotReached();\\r\\n    error CutoffTimeReached();\\r\\n    error DrawExpirationTimeNotReached();\\r\\n    error InsufficientNativeTokensSupplied();\\r\\n    error InvalidCaller();\\r\\n    error InvalidCurrency();\\r\\n    error InvalidCutoffTime();\\r\\n    error InvalidIndex();\\r\\n    error InvalidPricingOption();\\r\\n    error InvalidPrize();\\r\\n    error InvalidPrizesCount();\\r\\n    error InvalidProtocolFeeBp();\\r\\n    error InvalidProtocolFeeRecipient();\\r\\n    error InvalidStatus();\\r\\n    error InvalidWinnersCount();\\r\\n    error MaximumEntriesPerParticipantReached();\\r\\n    error MaximumEntriesReached();\\r\\n    error PrizeAlreadyClaimed();\\r\\n    error RandomnessRequestAlreadyExists();\\r\\n    error RandomnessRequestDoesNotExist();\\r\\n\\r\\n    /**\\r\\n     * @notice Creates a new battle.\\r\\n     * @param params The parameters of the battle.\\r\\n     * @return battleId The id of the newly created battle.\\r\\n     */\\r\\n    function createBattle(\\r\\n        CreateBattleCalldata calldata params\\r\\n    ) external payable returns (uint256 battleId);\\r\\n\\r\\n    function enterBattles(EntryCalldata[] calldata entries) external payable;\\r\\n\\r\\n    /**\\r\\n     * @notice Select the winners for a battle based on the random words returned by Chainlink.\\r\\n     * @param requestId The request id returned by Chainlink.\\r\\n     */\\r\\n    function selectWinners(uint256 requestId) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Claims the prizes for a winner. A winner can claim multiple prizes\\r\\n     *         from multiple battles in a single transaction.\\r\\n     * @param claimPrizesCalldata The calldata for claiming prizes.\\r\\n     */\\r\\n    function claimPrizes(\\r\\n        ClaimPrizesCalldata[] calldata claimPrizesCalldata\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Claims the fees collected for a battle.\\r\\n     * @param battleId The id of the battle.\\r\\n     */\\r\\n    function claimFees(uint256 battleId) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Cancels a battle beyond cut-off time without meeting minimum entries.\\r\\n     * @param battleId The id of the battle.\\r\\n     */\\r\\n    function cancel(uint256 battleId) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Cancels a battle after randomness request if the randomness request\\r\\n     *         does not arrive after a certain amount of time.\\r\\n     *         Only callable by contract owner.\\r\\n     * @param battleId The id of the battle.\\r\\n     */\\r\\n    function cancelAfterRandomnessRequest(uint256 battleId) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Withdraws the prizes for a battle after it has been marked as refundable.\\r\\n     * @param battleId The id of the battle.\\r\\n     */\\r\\n    function withdrawPrizes(uint256 battleId) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Claims the refund for a cancelled battle.\\r\\n     * @param battleIds The ids of the battles.\\r\\n     */\\r\\n    function claimRefund(uint256[] calldata battleIds) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Claims the protocol fees collected for a battle.\\r\\n     * @param currency The currency of the fees to be claimed.\\r\\n     */\\r\\n    function claimProtocolFees(address currency) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the protocol fee in basis points. Only callable by contract owner.\\r\\n     * @param protocolFeeBp The protocol fee in basis points.\\r\\n     */\\r\\n    function setProtocolFeeBp(uint16 protocolFeeBp) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the protocol fee recipient. Only callable by contract owner.\\r\\n     * @param protocolFeeRecipient The protocol fee recipient.\\r\\n     */\\r\\n    function setProtocolFeeRecipient(address protocolFeeRecipient) external;\\r\\n\\r\\n    /**\\r\\n     * @notice This function allows the owner to update currency statuses.\\r\\n     * @param currencies Currency addresses (address(0) for ETH)\\r\\n     * @param isAllowed Whether the currencies should be allowed for trading\\r\\n     * @dev Only callable by owner.\\r\\n     */\\r\\n    function updateCurrenciesStatus(\\r\\n        address[] calldata currencies,\\r\\n        bool isAllowed\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Toggle the contract's paused status. Only callable by contract owner.\\r\\n     */\\r\\n    function togglePaused() external;\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the winners for a battle.\\r\\n     * @param battleId The id of the battle.\\r\\n     * @return winners The winners of the battle.\\r\\n     */\\r\\n    function getWinners(\\r\\n        uint256 battleId\\r\\n    ) external view returns (Winner[] memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the pricing options for a battle.\\r\\n     * @param battleId The id of the battle.\\r\\n     * @return pricingOptions The pricing options for the battle.\\r\\n     */\\r\\n    function getPricingOptions(\\r\\n        uint256 battleId\\r\\n    ) external view returns (PricingOption[5] memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the prizes for a battle.\\r\\n     * @param battleId The id of the battle.\\r\\n     * @return prizes The prizes to be distributed.\\r\\n     */\\r\\n    function getPrizes(uint256 battleId) external view returns (Prize[] memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the entries for a battle.\\r\\n     * @param battleId The id of the battle.\\r\\n     * @return entries The entries entered for the battle.\\r\\n     */\\r\\n    function getEntries(\\r\\n        uint256 battleId\\r\\n    ) external view returns (Entry[] memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/Arrays.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.18;\\r\\n\\r\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to array types.\\r\\n *      Modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Arrays.sol\\r\\n */\\r\\nlibrary Arrays {\\r\\n    /**\\r\\n     * @dev Searches a sorted `array` and returns the first index that contains\\r\\n     * a value greater or equal to `element`. If no such index exists (i.e. all\\r\\n     * values in the array are strictly less than `element`), the array length is\\r\\n     * returned. Time complexity O(log n).\\r\\n     *\\r\\n     * `array` is expected to be sorted in ascending order, and to contain no\\r\\n     * repeated elements.\\r\\n     */\\r\\n    function findUpperBound(\\r\\n        uint256[] memory array,\\r\\n        uint256 element\\r\\n    ) internal pure returns (uint256) {\\r\\n        if (array.length == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 low = 0;\\r\\n        uint256 high = array.length;\\r\\n\\r\\n        while (low < high) {\\r\\n            uint256 mid = Math.average(low, high);\\r\\n\\r\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\r\\n            // because Math.average rounds down (it does integer division with truncation).\\r\\n            if (array[mid] > element) {\\r\\n                high = mid;\\r\\n            } else {\\r\\n                unchecked {\\r\\n                    low = mid + 1;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\\r\\n        if (low > 0 && array[low - 1] == element) {\\r\\n            unchecked {\\r\\n                return low - 1;\\r\\n            }\\r\\n        } else {\\r\\n            return low;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/WinningEntrySearchLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.18;\\r\\n\\r\\n/**\\r\\n * @title WinningEntrySearchLogic\\r\\n * @notice This contract contains the logic to search for a winning entry.\\r\\n * @author BadDogs team\\r\\n */\\r\\ncontract WinningEntrySearchLogic {\\r\\n    /**\\r\\n     * @param currentEntryIndex The current entry index.\\r\\n     * @param winningEntry The winning entry.\\r\\n     * @param winningEntriesBitmap The bitmap of winning entries.\\r\\n     */\\r\\n    function _incrementWinningEntryUntilThereIsNotADuplicate(\\r\\n        uint256 currentEntryIndex,\\r\\n        uint256 winningEntry,\\r\\n        uint256[] memory winningEntriesBitmap\\r\\n    ) internal pure returns (uint256, uint256[] memory) {\\r\\n        uint256 bucket = winningEntry >> 8;\\r\\n        uint256 mask = 1 << (winningEntry & 0xff);\\r\\n        while (winningEntriesBitmap[bucket] & mask != 0) {\\r\\n            if (winningEntry == currentEntryIndex) {\\r\\n                bucket = 0;\\r\\n                winningEntry = 0;\\r\\n            } else {\\r\\n                winningEntry += 1;\\r\\n                if (winningEntry % 256 == 0) {\\r\\n                    unchecked {\\r\\n                        bucket += 1;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            mask = 1 << (winningEntry & 0xff);\\r\\n        }\\r\\n\\r\\n        winningEntriesBitmap[bucket] |= mask;\\r\\n\\r\\n        return (winningEntry, winningEntriesBitmap);\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 8888\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_keyHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_subscriptionId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_vrfCoordinator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_protocolFeeRecipient\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_protocolFeeBp\",\"type\":\"uint16\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyRefunded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CutoffTimeNotReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CutoffTimeReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DrawExpirationTimeNotReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155SafeTransferFromFail\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20TransferFail\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20TransferFromFail\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721TransferFromFail\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientNativeTokensSupplied\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCurrency\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCutoffTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidIndex\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPricingOption\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPrize\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPrizesCount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProtocolFeeBp\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProtocolFeeRecipient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidStatus\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidWinnersCount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IsPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaximumEntriesPerParticipantReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaximumEntriesReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoOngoingTransferInProgress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotPaused\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"have\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"}],\"name\":\"OnlyCoordinatorCanFulfill\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PrizeAlreadyClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RandomnessRequestAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RandomnessRequestDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyFail\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RenouncementNotInProgress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferAlreadyInProgress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferNotInProgress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongPotentialOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"battleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum IBattle.BattleStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"BattleStatusUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CancelOwnershipTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"currencies\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAllowed\",\"type\":\"bool\"}],\"name\":\"CurrenciesStatusUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"battleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint208\",\"name\":\"amount\",\"type\":\"uint208\"}],\"name\":\"EntryRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"battleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"entriesCount\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"uint208\",\"name\":\"price\",\"type\":\"uint208\"}],\"name\":\"EntrySold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"battleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeesClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"InitiateOwnershipRenouncement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"potentialOwner\",\"type\":\"address\"}],\"name\":\"InitiateOwnershipTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"NewOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"battleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"winnerIndex\",\"type\":\"uint256[]\"}],\"name\":\"PrizesClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"protocolFeeBp\",\"type\":\"uint16\"}],\"name\":\"ProtocolFeeBpUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"protocolFeeRecipient\",\"type\":\"address\"}],\"name\":\"ProtocolFeeRecipientUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"battleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"RandomnessRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"KEY_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAXIMUM_NUMBER_OF_PRIZES_PER_BATTLE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAXIMUM_NUMBER_OF_WINNERS_PER_BATTLE\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAXIMUM_PROTOCOL_FEE_BP\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE_HOUR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE_HUNDRED_PERCENT_BP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE_WEEK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICING_OPTIONS_PER_BATTLE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REQUEST_CONFIRMATIONS\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUBSCRIPTION_ID\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VRF_COORDINATOR\",\"outputs\":[{\"internalType\":\"contract VRFCoordinatorV2Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"battles\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"enum IBattle.BattleStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isMinimumEntriesFixed\",\"type\":\"bool\"},{\"internalType\":\"uint40\",\"name\":\"cutoffTime\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"drawnAt\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"minimumEntries\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"maximumEntriesPerParticipant\",\"type\":\"uint40\"},{\"internalType\":\"address\",\"name\":\"feeTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"protocolFeeBp\",\"type\":\"uint16\"},{\"internalType\":\"uint208\",\"name\":\"claimableFees\",\"type\":\"uint208\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"battlesCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"battlesParticipantsStats\",\"outputs\":[{\"internalType\":\"uint208\",\"name\":\"amountPaid\",\"type\":\"uint208\"},{\"internalType\":\"uint40\",\"name\":\"entriesCount\",\"type\":\"uint40\"},{\"internalType\":\"bool\",\"name\":\"refunded\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"battleId\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"battleId\",\"type\":\"uint256\"}],\"name\":\"cancelAfterRandomnessRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"battleId\",\"type\":\"uint256\"}],\"name\":\"claimFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"battleId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"winnerIndices\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IBattle.ClaimPrizesCalldata[]\",\"name\":\"claimPrizesCalldata\",\"type\":\"tuple[]\"}],\"name\":\"claimPrizes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"claimProtocolFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"battleIds\",\"type\":\"uint256[]\"}],\"name\":\"claimRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confirmOwnershipRenouncement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confirmOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint40\",\"name\":\"cutoffTime\",\"type\":\"uint40\"},{\"internalType\":\"bool\",\"name\":\"isMinimumEntriesFixed\",\"type\":\"bool\"},{\"internalType\":\"uint40\",\"name\":\"minimumEntries\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"maximumEntriesPerParticipant\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"protocolFeeBp\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"feeTokenAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint40\",\"name\":\"winnersCount\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"cumulativeWinnersCount\",\"type\":\"uint40\"},{\"internalType\":\"enum IBattle.TokenType\",\"name\":\"prizeType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"prizeTier\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"prizeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"prizeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prizeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IBattle.Prize[]\",\"name\":\"prizes\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint40\",\"name\":\"entriesCount\",\"type\":\"uint40\"},{\"internalType\":\"uint208\",\"name\":\"price\",\"type\":\"uint208\"}],\"internalType\":\"struct IBattle.PricingOption[5]\",\"name\":\"pricingOptions\",\"type\":\"tuple[5]\"}],\"internalType\":\"struct IBattle.CreateBattleCalldata\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"createBattle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"battleId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"battleId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pricingOptionIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct IBattle.EntryCalldata[]\",\"name\":\"entries\",\"type\":\"tuple[]\"}],\"name\":\"enterBattles\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"battleId\",\"type\":\"uint256\"}],\"name\":\"getEntries\",\"outputs\":[{\"components\":[{\"internalType\":\"uint40\",\"name\":\"currentEntryIndex\",\"type\":\"uint40\"},{\"internalType\":\"address\",\"name\":\"participant\",\"type\":\"address\"}],\"internalType\":\"struct IBattle.Entry[]\",\"name\":\"entries\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"battleId\",\"type\":\"uint256\"}],\"name\":\"getPricingOptions\",\"outputs\":[{\"components\":[{\"internalType\":\"uint40\",\"name\":\"entriesCount\",\"type\":\"uint40\"},{\"internalType\":\"uint208\",\"name\":\"price\",\"type\":\"uint208\"}],\"internalType\":\"struct IBattle.PricingOption[5]\",\"name\":\"pricingOptions\",\"type\":\"tuple[5]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"battleId\",\"type\":\"uint256\"}],\"name\":\"getPrizes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint40\",\"name\":\"winnersCount\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"cumulativeWinnersCount\",\"type\":\"uint40\"},{\"internalType\":\"enum IBattle.TokenType\",\"name\":\"prizeType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"prizeTier\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"prizeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"prizeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prizeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IBattle.Prize[]\",\"name\":\"prizes\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"battleId\",\"type\":\"uint256\"}],\"name\":\"getWinners\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"participant\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"prizeIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint40\",\"name\":\"entryIndex\",\"type\":\"uint40\"}],\"internalType\":\"struct IBattle.Winner[]\",\"name\":\"winners\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initiateOwnershipRenouncement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPotentialOwner\",\"type\":\"address\"}],\"name\":\"initiateOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isCurrencyAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownershipStatus\",\"outputs\":[{\"internalType\":\"enum IOwnableTwoSteps.Status\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"potentialOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFeeBp\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFeeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"protocolFeeRecipientClaimableFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"randomnessRequests\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"uint248\",\"name\":\"randomWord\",\"type\":\"uint248\"},{\"internalType\":\"uint256\",\"name\":\"battleId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"selectWinners\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_protocolFeeBp\",\"type\":\"uint16\"}],\"name\":\"setProtocolFeeBp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_protocolFeeRecipient\",\"type\":\"address\"}],\"name\":\"setProtocolFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"togglePaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"currencies\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"isAllowed\",\"type\":\"bool\"}],\"name\":\"updateCurrenciesStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"battleId\",\"type\":\"uint256\"}],\"name\":\"withdrawPrizes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Battle", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "8888", "ConstructorArguments": "000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc28af398995b04c28e9951adb9721ef74c74f93e6a478f39e7e0777be13527e7ef0000000000000000000000000000000000000000000000000000000000000352000000000000000000000000271682deb8c4e0901d1a1550ad2e64d568e69909000000000000000000000000ff4b23e45a8a58c36f7fc28ac9ed830a56a4cf61000000000000000000000000ff4b23e45a8a58c36f7fc28ac9ed830a56a4cf6100000000000000000000000000000000000000000000000000000000000000fa", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}