{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/RaffleManager.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport \\\"../lib/airnode/packages/airnode-protocol/contracts/rrp/requesters/RrpRequesterV0.sol\\\";\\nimport {IWaveFactory} from \\\"./interfaces/IWaveFactory.sol\\\";\\nimport {IWaveContract} from \\\"./interfaces/IWaveContract.sol\\\";\\nimport {Ownable} from \\\"../lib/openzeppelin-contracts/contracts/access/Ownable.sol\\\";\\n\\ncontract RaffleManager is RrpRequesterV0, Ownable {\\n    event RequestedUint256Array(bytes32 indexed requestId, uint256 size);\\n    event ReceivedUint256Array(bytes32 indexed requestId, uint256[] response);\\n\\n    address public airnode;\\n    bytes32 public endpointIdUint256Array;\\n    address public sponsor;\\n    address public sponsorWallet;\\n\\n    IWaveFactory public waveFactory;\\n\\n    mapping(bytes32 => bool) public expectingRequestWithIdToBeFulfilled;\\n    mapping(bytes32 => address) public requestToRequester;\\n\\n    error OnlyRaffleWave();\\n\\n    modifier onlyRaffleWave() {\\n        if (!waveFactory.isRaffleWave(msg.sender)) revert OnlyRaffleWave();\\n        _;\\n    }\\n\\n    /// @dev RrpRequester sponsors itself, meaning that it can make requests\\n    /// that will be fulfilled by its sponsor wallet. See the Airnode protocol\\n    /// docs about sponsorship for more information.\\n    /// @param _airnodeRrp Airnode RRP contract address\\n    constructor(address _airnodeRrp, IWaveFactory _waveFactory) RrpRequesterV0(_airnodeRrp) Ownable() {\\n        waveFactory = _waveFactory;\\n    }\\n\\n    /// @notice Sets parameters used in requesting QRNG services\\n    /// @param _airnode Airnode address\\n    /// @param _endpointIdUint256Array Endpoint ID used to request a `uint256[]`\\n    /// @param _sponsor address used to sponsor this requester\\n    /// @param _sponsorWallet Sponsor wallet address, used for gas by Airnode\\n    function setRequestParameters(\\n        address _airnode,\\n        bytes32 _endpointIdUint256Array,\\n        address _sponsor,\\n        address _sponsorWallet\\n    ) external onlyOwner {\\n        airnode = _airnode;\\n        endpointIdUint256Array = _endpointIdUint256Array;\\n        sponsor = _sponsor;\\n        sponsorWallet = _sponsorWallet;\\n    }\\n\\n    /// @notice Requests a `uint256[]`\\n    /// @param size Size of the requested array\\n    function makeRequestUint256Array(uint256 size) external onlyRaffleWave() returns (bytes32 requestId) {\\n        requestId = airnodeRrp.makeFullRequest(\\n            airnode,\\n            endpointIdUint256Array,\\n            sponsor,\\n            sponsorWallet,\\n            address(this),\\n            this.fulfillUint256Array.selector,\\n            // @dev Using Airnode ABI to encode the parameters\\n            abi.encode(bytes32(\\\"1u\\\"), bytes32(\\\"size\\\"), size)\\n        );\\n        expectingRequestWithIdToBeFulfilled[requestId] = true;\\n        requestToRequester[requestId] = msg.sender;\\n        emit RequestedUint256Array(requestId, size);\\n    }\\n\\n    /// @notice Called by the Airnode through the AirnodeRrp contract to\\n    /// fulfill the request\\n    /// @param requestId Request ID\\n    /// @param data ABI-encoded response\\n    function fulfillUint256Array(bytes32 requestId, bytes calldata data) external onlyAirnodeRrp {\\n        require(expectingRequestWithIdToBeFulfilled[requestId], \\\"Request ID not known\\\");\\n        expectingRequestWithIdToBeFulfilled[requestId] = false;\\n        uint256[] memory _qrngUint256Array = abi.decode(data, (uint256[]));\\n        emit ReceivedUint256Array(requestId, _qrngUint256Array);\\n\\n        IWaveContract(requestToRequester[requestId]).fulfillRaffle(_qrngUint256Array);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/airnode/packages/airnode-protocol/contracts/rrp/requesters/RrpRequesterV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IAirnodeRrpV0.sol\\\";\\n\\n/// @title The contract to be inherited to make Airnode RRP requests\\ncontract RrpRequesterV0 {\\n    IAirnodeRrpV0 public immutable airnodeRrp;\\n\\n    /// @dev Reverts if the caller is not the Airnode RRP contract.\\n    /// Use it as a modifier for fulfill and error callback methods, but also\\n    /// check `requestId`.\\n    modifier onlyAirnodeRrp() {\\n        require(msg.sender == address(airnodeRrp), \\\"Caller not Airnode RRP\\\");\\n        _;\\n    }\\n\\n    /// @dev Airnode RRP address is set at deployment and is immutable.\\n    /// RrpRequester is made its own sponsor by default. RrpRequester can also\\n    /// be sponsored by others and use these sponsorships while making\\n    /// requests, i.e., using this default sponsorship is optional.\\n    /// @param _airnodeRrp Airnode RRP contract address\\n    constructor(address _airnodeRrp) {\\n        airnodeRrp = IAirnodeRrpV0(_airnodeRrp);\\n        IAirnodeRrpV0(_airnodeRrp).setSponsorshipStatus(address(this), true);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IWaveFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.21;\\npragma abicoder v2;\\n\\ninterface IWaveFactory {\\n    struct TokenRewards {\\n        uint256 rewardsLeft;\\n        uint256 amountPerUser;\\n        address token;\\n    }\\n\\n    function deployWave(\\n        string memory _name,\\n        string memory _symbol,\\n        string memory _baseURI,\\n        uint256 _startTimestamp,\\n        uint256 _endTimestamp,\\n        bool _isSoulbound,\\n        TokenRewards[] memory _claimRewards,\\n        TokenRewards[] memory _raffleRewards\\n    ) external;\\n\\n    function keeper() external view returns (address);\\n\\n    function verifier() external view returns (address);\\n\\n    function raffleManager() external view returns (address);\\n\\n    function isRaffleWave(address) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IWaveContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.21;\\npragma abicoder v2;\\n\\ninterface IWaveContract {\\n    struct TokenReward {\\n        uint256 count;\\n        uint256 amount;\\n        address token;\\n        bool isRaffle;\\n    }\\n\\n    /// @notice Allows the governance to set metadata base URI for all tokens\\n    /// @param _uri The base URI to set\\n    /// @param _customMetadata Whether the metadata is encoded with tokenId\\n    function changeBaseURI(string memory _uri, bool _customMetadata) external;\\n\\n    /// @notice Allows the owner to set the campaign start timestamp\\n    function setStartTimestamp(uint256 _startTimestamp) external;\\n\\n    /// @notice Allows the governance to set the campaign end timestamp\\n    function setEndTimestamp(uint256 _endTimestamp) external;\\n\\n    /// @notice Allows the owner to end the campaign early\\n    function endCampaign() external;\\n\\n    /// @notice Allows anyone to make the claim rewards funds\\n    /// return to the owner after the campaign is ended\\n    function withdrawClaimRewardsFunds() external;\\n\\n    /// @notice Execute the mint with permit by verifying the off-chain verifier signature\\n    /// @param deadline The deadline for the permit\\n    /// @param v The v component of the signature\\n    /// @param r The r component of the signature\\n    /// @param s The s component of the signature\\n    function claim(uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    /// @notice sends a request for random numbers to the raffle manager\\n    function startRaffle() external;\\n\\n    /// @notice fulfills the raffle by assigning random numbers to each reward\\n    /// and emitting the tokens. Then, returns the remaining funds for raffle rewards\\n    /// to the owner\\n    /// @param randomNumbers the random numbers to use for the raffle\\n    /// @dev the set of winning token ids per reward is generated by a single\\n    /// random number provided by the raffle manager\\n    function fulfillRaffle(uint256[] memory randomNumbers) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/airnode/packages/airnode-protocol/contracts/rrp/interfaces/IAirnodeRrpV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAuthorizationUtilsV0.sol\\\";\\nimport \\\"./ITemplateUtilsV0.sol\\\";\\nimport \\\"./IWithdrawalUtilsV0.sol\\\";\\n\\ninterface IAirnodeRrpV0 is\\n    IAuthorizationUtilsV0,\\n    ITemplateUtilsV0,\\n    IWithdrawalUtilsV0\\n{\\n    event SetSponsorshipStatus(\\n        address indexed sponsor,\\n        address indexed requester,\\n        bool sponsorshipStatus\\n    );\\n\\n    event MadeTemplateRequest(\\n        address indexed airnode,\\n        bytes32 indexed requestId,\\n        uint256 requesterRequestCount,\\n        uint256 chainId,\\n        address requester,\\n        bytes32 templateId,\\n        address sponsor,\\n        address sponsorWallet,\\n        address fulfillAddress,\\n        bytes4 fulfillFunctionId,\\n        bytes parameters\\n    );\\n\\n    event MadeFullRequest(\\n        address indexed airnode,\\n        bytes32 indexed requestId,\\n        uint256 requesterRequestCount,\\n        uint256 chainId,\\n        address requester,\\n        bytes32 endpointId,\\n        address sponsor,\\n        address sponsorWallet,\\n        address fulfillAddress,\\n        bytes4 fulfillFunctionId,\\n        bytes parameters\\n    );\\n\\n    event FulfilledRequest(\\n        address indexed airnode,\\n        bytes32 indexed requestId,\\n        bytes data\\n    );\\n\\n    event FailedRequest(\\n        address indexed airnode,\\n        bytes32 indexed requestId,\\n        string errorMessage\\n    );\\n\\n    function setSponsorshipStatus(address requester, bool sponsorshipStatus)\\n        external;\\n\\n    function makeTemplateRequest(\\n        bytes32 templateId,\\n        address sponsor,\\n        address sponsorWallet,\\n        address fulfillAddress,\\n        bytes4 fulfillFunctionId,\\n        bytes calldata parameters\\n    ) external returns (bytes32 requestId);\\n\\n    function makeFullRequest(\\n        address airnode,\\n        bytes32 endpointId,\\n        address sponsor,\\n        address sponsorWallet,\\n        address fulfillAddress,\\n        bytes4 fulfillFunctionId,\\n        bytes calldata parameters\\n    ) external returns (bytes32 requestId);\\n\\n    function fulfill(\\n        bytes32 requestId,\\n        address airnode,\\n        address fulfillAddress,\\n        bytes4 fulfillFunctionId,\\n        bytes calldata data,\\n        bytes calldata signature\\n    ) external returns (bool callSuccess, bytes memory callData);\\n\\n    function fail(\\n        bytes32 requestId,\\n        address airnode,\\n        address fulfillAddress,\\n        bytes4 fulfillFunctionId,\\n        string calldata errorMessage\\n    ) external;\\n\\n    function sponsorToRequesterToSponsorshipStatus(\\n        address sponsor,\\n        address requester\\n    ) external view returns (bool sponsorshipStatus);\\n\\n    function requesterToRequestCountPlusOne(address requester)\\n        external\\n        view\\n        returns (uint256 requestCountPlusOne);\\n\\n    function requestIsAwaitingFulfillment(bytes32 requestId)\\n        external\\n        view\\n        returns (bool isAwaitingFulfillment);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/airnode/packages/airnode-protocol/contracts/rrp/interfaces/IAuthorizationUtilsV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IAuthorizationUtilsV0 {\\n    function checkAuthorizationStatus(\\n        address[] calldata authorizers,\\n        address airnode,\\n        bytes32 requestId,\\n        bytes32 endpointId,\\n        address sponsor,\\n        address requester\\n    ) external view returns (bool status);\\n\\n    function checkAuthorizationStatuses(\\n        address[] calldata authorizers,\\n        address airnode,\\n        bytes32[] calldata requestIds,\\n        bytes32[] calldata endpointIds,\\n        address[] calldata sponsors,\\n        address[] calldata requesters\\n    ) external view returns (bool[] memory statuses);\\n}\\n\"\r\n    },\r\n    \"lib/airnode/packages/airnode-protocol/contracts/rrp/interfaces/ITemplateUtilsV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ITemplateUtilsV0 {\\n    event CreatedTemplate(\\n        bytes32 indexed templateId,\\n        address airnode,\\n        bytes32 endpointId,\\n        bytes parameters\\n    );\\n\\n    function createTemplate(\\n        address airnode,\\n        bytes32 endpointId,\\n        bytes calldata parameters\\n    ) external returns (bytes32 templateId);\\n\\n    function getTemplates(bytes32[] calldata templateIds)\\n        external\\n        view\\n        returns (\\n            address[] memory airnodes,\\n            bytes32[] memory endpointIds,\\n            bytes[] memory parameters\\n        );\\n\\n    function templates(bytes32 templateId)\\n        external\\n        view\\n        returns (\\n            address airnode,\\n            bytes32 endpointId,\\n            bytes memory parameters\\n        );\\n}\\n\"\r\n    },\r\n    \"lib/airnode/packages/airnode-protocol/contracts/rrp/interfaces/IWithdrawalUtilsV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IWithdrawalUtilsV0 {\\n    event RequestedWithdrawal(\\n        address indexed airnode,\\n        address indexed sponsor,\\n        bytes32 indexed withdrawalRequestId,\\n        address sponsorWallet\\n    );\\n\\n    event FulfilledWithdrawal(\\n        address indexed airnode,\\n        address indexed sponsor,\\n        bytes32 indexed withdrawalRequestId,\\n        address sponsorWallet,\\n        uint256 amount\\n    );\\n\\n    function requestWithdrawal(address airnode, address sponsorWallet) external;\\n\\n    function fulfillWithdrawal(\\n        bytes32 withdrawalRequestId,\\n        address airnode,\\n        address sponsor\\n    ) external payable;\\n\\n    function sponsorToWithdrawalRequestCount(address sponsor)\\n        external\\n        view\\n        returns (uint256 withdrawalRequestCount);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"airnode/=lib/airnode/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"lib/forge-std:ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/openzeppelin-contracts:ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/openzeppelin-contracts:erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"lib/openzeppelin-contracts:forge-std/=lib/openzeppelin-contracts/lib/forge-std/src/\",\r\n      \"lib/openzeppelin-contracts:openzeppelin/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_airnodeRrp\",\"type\":\"address\"},{\"internalType\":\"contract IWaveFactory\",\"name\":\"_waveFactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"OnlyRaffleWave\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"response\",\"type\":\"uint256[]\"}],\"name\":\"ReceivedUint256Array\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"RequestedUint256Array\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"airnode\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airnodeRrp\",\"outputs\":[{\"internalType\":\"contract IAirnodeRrpV0\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endpointIdUint256Array\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"expectingRequestWithIdToBeFulfilled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"fulfillUint256Array\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"makeRequestUint256Array\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"requestToRequester\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_airnode\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_endpointIdUint256Array\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_sponsor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sponsorWallet\",\"type\":\"address\"}],\"name\":\"setRequestParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sponsor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sponsorWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"waveFactory\",\"outputs\":[{\"internalType\":\"contract IWaveFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RaffleManager", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a0ad79d995ddeeb18a14eaef56a549a04e3aa1bd000000000000000000000000b9eef8ad0e332cd7f182243739dcf6aaf27a3b61", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}