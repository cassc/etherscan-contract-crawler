{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\n// copyright Dox || Etho Protocol || 2023 || contact: dox@ethoprotocol.com\r\npragma solidity ^0.8.0;\r\n\r\ncontract Token {\r\n    uint256 public totalSupply = 0;\r\n    address public owner;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => bool) public isIssuer;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event IssuerRights(address indexed issuer, bool value);\r\n    event TransferOwnership(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    function mint(address _to, uint256 _amount)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        totalSupply += _amount;\r\n        balanceOf[_to] += _amount;\r\n        emit Transfer(address(0), _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    function burnFrom(address _from, uint256 _amount)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        balanceOf[_from] -= _amount;\r\n        totalSupply -= _amount;\r\n        emit Transfer(_from, address(0), _amount);\r\n        return true;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public restricted {\r\n        require(_newOwner != address(0), \"Invalid address: should not be 0x0\");\r\n        emit TransferOwnership(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n\r\n    function setIssuerRights(address _issuer, bool _value) public restricted {\r\n        isIssuer[_issuer] = _value;\r\n        emit IssuerRights(_issuer, _value);\r\n    }\r\n    modifier restricted {\r\n        require(msg.sender == owner, \"This function is restricted to owner\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract MultiSigWallet {\r\n    address[] public owners;\r\n    uint public required;\r\n    mapping (address => bool) public isOwner;\r\n\r\n    function getOwners()\r\n        public\r\n\t\tview\r\n        returns (address[] memory)\r\n    {\r\n        return owners;\r\n    }\r\n}\r\n\r\ncontract MultiSig_Token_Owner_Verify {\r\n    event NewTransactionExecution(string transaction_id, address to, uint amount, uint fee,string event_name, address tx_submitter);\r\n    event TransactionFailure(string transaction_id, address to, uint amount, uint fee, string event_name, address tx_submitter);\r\n    event NetworkFailure(string transaction_id, address to, uint amount, uint fee, string event_name, address tx_submitter);\r\n    event SignatureCountFailure(string transaction_id, uint counted_signatures,uint required_signatures);\r\n\r\n    event DuplicateTransaction(string transaction_id, address tx_submitter);\r\n\r\n    address public multisig_contract_address;\r\n    address public token_contract_address;\r\n\r\n    bytes32 mintHash = keccak256(abi.encodePacked(\"mint\"));\r\n    bytes32 forceMintHash = keccak256(abi.encodePacked(\"forceMint\"));\r\n    bytes32 burnFromHash = keccak256(abi.encodePacked(\"burnFrom\"));\r\n    bytes32 transferOwnershipHash = keccak256(abi.encodePacked(\"transferOwnership\"));\r\n\r\n\r\n    mapping (string => bytes32) public function_names;\r\n\r\n    mapping (string => address) public validated_transactions; \r\n    \r\n    struct Transaction {\r\n        address to;\r\n        uint amount;\r\n        uint fee;\r\n        string tx_id;\r\n        string event_name;\r\n        uint256 target_network;\r\n    }\r\n\r\n    function getMessageHash(\r\n        Transaction memory transaction\r\n    ) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(transaction.to, transaction.amount, transaction.fee, transaction.tx_id, transaction.event_name, transaction.target_network));\r\n    }\r\n\r\n    function getEthSignedMessageHash(\r\n        bytes32 _messageHash\r\n    ) public pure returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _messageHash)\r\n            );\r\n    }\r\n\r\n    function recoverSigner(\r\n        bytes32 _ethSignedMessageHash,\r\n        bytes calldata _signature\r\n    ) public pure returns (address) {\r\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\r\n\r\n        return ecrecover(_ethSignedMessageHash, v, r, s);\r\n    }\r\n\r\n    function splitSignature(\r\n        bytes memory sig\r\n    ) public pure returns (bytes32 r, bytes32 s, uint8 v) {\r\n        require(sig.length == 65, \"invalid signature length\");\r\n\r\n        assembly {\r\n            // first 32 bytes, after the length prefix\r\n            r := mload(add(sig, 32))\r\n            // second 32 bytes\r\n            s := mload(add(sig, 64))\r\n            // final byte (first byte of the next 32 bytes)\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n    }\r\n\r\n    function checkOwner(address check_address) public view returns (bool) { \r\n\t\treturn MultiSigWallet(multisig_contract_address).isOwner(check_address) == true;\r\n    }\r\n\r\n    function getOwners() public view returns (address[] memory) {\r\n        return MultiSigWallet(multisig_contract_address).getOwners();\r\n    }\r\n\r\n    function getRequired() public view returns (uint) {\r\n        return MultiSigWallet(multisig_contract_address).required();\r\n    }\r\n\r\n\tfunction IsTransactionSubmitted(string calldata tx_id) public view returns (bool) {\r\n\t\treturn validated_transactions[tx_id] != address(0); \r\n\t}\r\n\r\n\tfunction GetTransactionSubmitter(string calldata tx_id) public view returns (address tx_submitter) { \r\n\t\treturn validated_transactions[tx_id];\r\n\t}\r\n\r\n    function setFunctionNames() internal  { \r\n        function_names[\"mint\"] = mintHash;\r\n        function_names[\"forceMint\"] = forceMintHash;\r\n        function_names[\"burnFrom\"] = burnFromHash;\r\n        function_names[\"transferOwnership\"] = transferOwnershipHash;\r\n\t}\r\n\r\n\r\n    function trigger_transaction(Transaction memory transaction) internal returns (bool) { \r\n\r\n        if (transaction.target_network == block.chainid) {\r\n            Token _token = Token(token_contract_address);\r\n            bytes32 eventHash = function_names[transaction.event_name];\r\n\r\n            if (eventHash == mintHash) {\r\n                _token.mint(transaction.to,transaction.amount-transaction.fee);\r\n            } else if (eventHash == burnFromHash) {\r\n                _token.burnFrom(transaction.to,transaction.amount);\r\n            } \r\n            else if (eventHash == forceMintHash) {\r\n                _token.mint(transaction.to,transaction.amount);\r\n \r\n            } else if (eventHash == transferOwnershipHash) { \r\n                _token.setIssuerRights(transaction.to,true); \r\n                _token.setIssuerRights(address(this),false); \r\n                _token.transferOwnership(transaction.to);\r\n            } else {\r\n                emit TransactionFailure(transaction.tx_id,transaction.to,transaction.amount,transaction.fee,transaction.event_name,msg.sender);\r\n                return false;\r\n            }\r\n        } else {\r\n            emit NetworkFailure(transaction.tx_id,transaction.to,transaction.amount,transaction.fee,transaction.event_name,msg.sender);\r\n            return false;\r\n        }\r\n\r\n        validated_transactions[transaction.tx_id] = msg.sender;\r\n\r\n        emit NewTransactionExecution(transaction.tx_id,transaction.to,transaction.amount,transaction.fee,transaction.event_name,msg.sender);\r\n        return true;\r\n\r\n    }\r\n\r\n    function submitSignaturePackage(string calldata _transaction_id, address _to, uint _amount, uint _fee, string memory _event_name, uint256 _target_network, bytes[] calldata signatures) public restricted returns (bool) { \r\n        \r\n        if (validated_transactions[_transaction_id] == address(0)) { \r\n            uint required_signatures = getRequired();\r\n            uint8 count_signatures = 1;\r\n\r\n            Transaction memory transaction = Transaction({to:_to,amount:_amount,fee:_fee,tx_id:_transaction_id,event_name:_event_name,target_network:_target_network});\r\n\r\n            bytes32 ethSignedMessageHash = getEthSignedMessageHash(getMessageHash(transaction));\r\n\r\n            address[] memory multisig_owners = getOwners();\r\n\r\n            for (uint8 i=0; i<signatures.length; i++) {\r\n\r\n                address signature_owner = recoverSigner(ethSignedMessageHash, signatures[i]);\r\n\r\n                for (uint8 j=0; j<multisig_owners.length; j++) {\r\n                    if (multisig_owners[j] == signature_owner) {\r\n                        count_signatures++;\r\n                        multisig_owners[j] = address(0);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            if (count_signatures >= required_signatures) {\r\n                return trigger_transaction(transaction);\r\n            }\r\n\r\n            emit SignatureCountFailure(_transaction_id,count_signatures,required_signatures);\r\n        } else {\r\n            emit DuplicateTransaction(_transaction_id,msg.sender);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    modifier restricted {\r\n        require(checkOwner(msg.sender), \"This function is restricted to owners of Multisig\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        multisig_contract_address = 0x1509c8F22b7a14bab4EA829324BFcc44371A5667;\r\n        token_contract_address = 0x0b5326Da634f9270FB84481DD6F94d3dC2cA7096;\r\n        setFunctionNames();\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"transaction_id\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tx_submitter\",\"type\":\"address\"}],\"name\":\"DuplicateTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"transaction_id\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"event_name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tx_submitter\",\"type\":\"address\"}],\"name\":\"NetworkFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"transaction_id\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"event_name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tx_submitter\",\"type\":\"address\"}],\"name\":\"NewTransactionExecution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"transaction_id\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"counted_signatures\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"required_signatures\",\"type\":\"uint256\"}],\"name\":\"SignatureCountFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"transaction_id\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"event_name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tx_submitter\",\"type\":\"address\"}],\"name\":\"TransactionFailure\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tx_id\",\"type\":\"string\"}],\"name\":\"GetTransactionSubmitter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tx_submitter\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tx_id\",\"type\":\"string\"}],\"name\":\"IsTransactionSubmitted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"check_address\",\"type\":\"address\"}],\"name\":\"checkOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"function_names\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_messageHash\",\"type\":\"bytes32\"}],\"name\":\"getEthSignedMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"tx_id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"event_name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"target_network\",\"type\":\"uint256\"}],\"internalType\":\"struct MultiSig_Token_Owner_Verify.Transaction\",\"name\":\"transaction\",\"type\":\"tuple\"}],\"name\":\"getMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRequired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multisig_contract_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_ethSignedMessageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"recoverSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"splitSignature\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_transaction_id\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_event_name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_target_network\",\"type\":\"uint256\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"}],\"name\":\"submitSignaturePackage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token_contract_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"validated_transactions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MultiSig_Token_Owner_Verify", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "300", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b89f7110b74213d7f9ae899b9769e71a32f5901c10256440bc84e2a6c9a85d83"}