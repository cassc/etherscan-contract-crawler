{"SourceCode": "pragma solidity =0.6.2;\r\n\r\ninterface IERC20 {\r\n  function balanceOf(address who) external view returns (uint256);\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\r\n}\r\n\r\n\r\ninterface IERC721{\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\ninterface InftRoute{\r\n    function positions(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (\r\n            uint96 nonce,\r\n            address operator,\r\n            address token0,\r\n            address token1,\r\n            uint24 fee,\r\n            int24 tickLower,\r\n            int24 tickUpper,\r\n            uint128 liquidity,\r\n            uint256 feeGrowthInside0LastX128,\r\n            uint256 feeGrowthInside1LastX128,\r\n            uint128 tokensOwed0,\r\n            uint128 tokensOwed1\r\n        );\r\n    function decreaseLiquidity(bytes calldata params) external payable returns (uint256 amount0, uint256 amount1);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'MY ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'MY ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'MY ds-math-mul-overflow');\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"MY SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n}\r\n\r\ncontract TheCollector{\r\n    using SafeMath  for uint;\r\n    \r\n\taddress payable public owner;\r\n\taddress public weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n\taddress public Unft = 0xC36442b4a4522E871399CD717aBDD847Ab11FE88;\r\n\tuint256 public fee = 100;  // amount 100 * feeRep 100 / 1000 = 10% Fee\r\n\t\r\n\tconstructor() public payable{\r\n\t    owner = msg.sender;\r\n\t}\r\n\t\r\n\tmodifier onlyOwner(){\r\n\t    require(msg.sender==owner);\r\n\t    _;\r\n\t}    \r\n\t\r\n\tfunction CFEE(uint256 NFEE) public onlyOwner {\r\n\t    fee = NFEE;\r\n\t}\r\n\r\n\t\r\n\tfunction Cweth(address TToken, uint256 nftID, uint256 amt0min, uint256 amt1min, uint128 tokensOwed0, uint128 tokensOwed1, bool ETH) public payable {\r\n\t    require(msg.sender == InftRoute(Unft).ownerOf(nftID));\r\n        (,,,,,,,uint128 liquidity,,,,) = InftRoute(Unft).positions(nftID);\r\n\t    bytes memory Adata = abi.encode(nftID,liquidity,amt0min,amt1min,now);\r\n\t    bytes memory Adata2 = abi.encodePacked(bytes4(0x0c49ccbe),Adata);\r\n\t    (bool decre,) = Unft.call(Adata2);\r\n\t    require(decre,\"I do not Decre\");\r\n\t    collecter(TToken,nftID,tokensOwed0, tokensOwed1,ETH);\r\n\t}\r\n\t\r\n\t\r\n\tfunction collecter(address TToken, uint256 nftID, uint128 amt0max, uint128 amt1max, bool ETH) public payable {\r\n        require(msg.sender == InftRoute(Unft).ownerOf(nftID));\r\n\t    bytes memory Adata = abi.encode(nftID,address(this),amt0max,amt1max);\r\n\t    bytes memory Adata2 = abi.encodePacked(bytes4(0xfc6f7865),Adata);\r\n\t    (, bytes memory rtn) = Unft.call(Adata2);\r\n\t    (uint128 amt0,uint128 amt1) = abi.decode(rtn,(uint128,uint128));\r\n\t    require(amt0 > 0 || amt1 > 0, \"no amt\");\r\n\t    uint256 Uamt = amt0 > 0 ? amt0 : amt1;\r\n        uint256 vig = Uamt.mul(fee).div(1000);\r\n        address payable usr = msg.sender;\r\n\t    if(ETH){\r\n\t        if(TToken == weth){\r\n                (bool wet,) = weth.call(abi.encodeWithSignature(\"withdraw(uint256)\",Uamt));\r\n                require(wet, \"Weth withdraw error\");\r\n                usr.transfer(Uamt.sub(vig));\r\n\t        }else{\r\n\t            safeTransfer(TToken,usr,Uamt.sub(vig));\r\n\t        }\r\n\t    }else{\r\n\t        safeTransfer(TToken,usr,Uamt.sub(vig));\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction onERC721Received(address, address, uint256, bytes memory) public returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n    \r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n    \r\n    //Safety onlyOwner functions for recovery of mistakes and fees\r\n\tfunction withdraw() public payable onlyOwner{\r\n        owner.transfer( address( this ).balance );\r\n    }\r\n\r\n    function toke(address _toke, uint amt) public payable onlyOwner{\r\n        if(_toke == weth){\r\n            uint256 Wbal = IERC20(weth).balanceOf(address(this));\r\n            weth.call(abi.encodeWithSignature(\"withdraw(uint256)\",Wbal));\r\n            owner.transfer(address(this).balance);\r\n        }else{\r\n            safeTransfer(_toke,owner,amt);\r\n        }\r\n    }\r\n    function Rnft(uint256 nftID,address GoTo) public onlyOwner {\r\n        IERC721(Unft).safeTransferFrom(address(this),GoTo,nftID);\r\n    }\r\n    \r\n    function kill() external payable onlyOwner{\r\n        selfdestruct(owner);\r\n    }\r\n    receive () external payable {}\r\n    fallback () external payable {}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"NFEE\",\"type\":\"uint256\"}],\"name\":\"CFEE\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"TToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amt0min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amt1min\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"tokensOwed0\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"tokensOwed1\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"ETH\",\"type\":\"bool\"}],\"name\":\"Cweth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"GoTo\",\"type\":\"address\"}],\"name\":\"Rnft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Unft\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"TToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftID\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"amt0max\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"amt1max\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"ETH\",\"type\":\"bool\"}],\"name\":\"collecter\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toke\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"toke\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TheCollector", "CompilerVersion": "v0.6.2+commit.bacdbe57", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6ac3cf7ae6142029285bd8f3b04f01d9541a4c9fa9a959da9d5582e98fd813dc"}