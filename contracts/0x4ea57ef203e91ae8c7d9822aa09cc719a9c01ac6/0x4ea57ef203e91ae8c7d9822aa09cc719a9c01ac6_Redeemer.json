{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Marketplace.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\nimport 'src/tokens/ERC5095.sol';\\nimport 'src/lib/Safe.sol';\\nimport 'src/lib/RevertMsgExtractor.sol';\\nimport 'src/errors/Exception.sol';\\n\\nimport 'src/interfaces/ILender.sol';\\nimport 'src/interfaces/ICreator.sol';\\nimport 'src/interfaces/IPool.sol';\\nimport 'src/interfaces/IPendleToken.sol';\\nimport 'src/interfaces/IAPWineToken.sol';\\nimport 'src/interfaces/IAPWineFutureVault.sol';\\n\\n/// @title MarketPlace\\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\\n/// @notice This contract is in charge of managing the available principals for each loan market.\\n/// @notice In addition, this contract routes swap orders between Illuminate PTs and their respective underlying to YieldSpace pools.\\ncontract MarketPlace {\\n    /// @notice the available principals\\n    /// @dev the order of this enum is used to select principals from the markets\\n    /// mapping (e.g. Illuminate => 0, Swivel => 1, and so on)\\n    enum Principals {\\n        Illuminate, // 0\\n        Swivel, // 1\\n        Yield, // 2\\n        Element, // 3\\n        Pendle, // 4\\n        Tempus, // 5\\n        Sense, // 6\\n        Apwine, // 7\\n        Notional // 8\\n    }\\n\\n    /// @notice markets are defined by a tuple that points to a fixed length array of principal token addresses.\\n    mapping(address => mapping(uint256 => address[9])) public markets;\\n\\n    /// @notice pools map markets to their respective YieldSpace pools for the MetaPrincipal token\\n    mapping(address => mapping(uint256 => address)) public pools;\\n\\n    /// @notice address that is allowed to create markets, set pools, etc. It is commonly used in the authorized modifier.\\n    address public admin;\\n    /// @notice address of the deployed redeemer contract\\n    address public immutable redeemer;\\n    /// @notice address of the deployed lender contract\\n    address public immutable lender;\\n    /// @notice address of the deployed creator contract\\n    address public immutable creator;\\n\\n    /// @notice emitted upon the creation of a new market\\n    event CreateMarket(\\n        address indexed underlying,\\n        uint256 indexed maturity,\\n        address[9] tokens,\\n        address element,\\n        address apwine\\n    );\\n    /// @notice emitted upon setting a principal token\\n    event SetPrincipal(\\n        address indexed underlying,\\n        uint256 indexed maturity,\\n        address indexed principal,\\n        uint8 protocol\\n    );\\n    /// @notice emitted upon swapping with the pool\\n    event Swap(\\n        address indexed underlying,\\n        uint256 indexed maturity,\\n        address sold,\\n        address bought,\\n        uint256 received,\\n        uint256 spent,\\n        address spender\\n    );\\n    /// @notice emitted upon minting tokens with the pool\\n    event Mint(\\n        address indexed underlying,\\n        uint256 indexed maturity,\\n        uint256 underlyingIn,\\n        uint256 principalTokensIn,\\n        uint256 minted,\\n        address minter\\n    );\\n    /// @notice emitted upon burning tokens with the pool\\n    event Burn(\\n        address indexed underlying,\\n        uint256 indexed maturity,\\n        uint256 tokensBurned,\\n        uint256 underlyingReceived,\\n        uint256 principalTokensReceived,\\n        address burner\\n    );\\n    /// @notice emitted upon changing the admin\\n    event SetAdmin(address indexed admin);\\n    /// @notice emitted upon setting a pool\\n    event SetPool(\\n        address indexed underlying,\\n        uint256 indexed maturity,\\n        address indexed pool\\n    );\\n\\n    /// @notice ensures that only a certain address can call the function\\n    /// @param a address that msg.sender must be to be authorized\\n    modifier authorized(address a) {\\n        if (msg.sender != a) {\\n            revert Exception(0, 0, 0, msg.sender, a);\\n        }\\n        _;\\n    }\\n\\n    /// @notice initializes the MarketPlace contract\\n    /// @param r address of the deployed redeemer contract\\n    /// @param l address of the deployed lender contract\\n    /// @param c address of the deployed creator contract\\n    constructor(address r, address l, address c) {\\n        admin = msg.sender;\\n        redeemer = r;\\n        lender = l;\\n        creator = c;\\n    }\\n\\n    /// @notice creates a new market for the given underlying token and maturity\\n    /// @param u address of an underlying asset\\n    /// @param m maturity (timestamp) of the market\\n    /// @param t principal token addresses for this market\\n    /// @param n name for the Illuminate token\\n    /// @param s symbol for the Illuminate token\\n    /// @param a address of the APWine router that corresponds to this market\\n    /// @param e address of the Element vault that corresponds to this market\\n    /// @param h address of a helper contract, used for Sense approvals if active in the market\\n    /// @param sensePeriphery address of the Sense periphery contract that must be approved by the lender\\n    /// @return bool true if successful\\n    function createMarket(\\n        address u,\\n        uint256 m,\\n        address[8] calldata t,\\n        string calldata n,\\n        string calldata s,\\n        address a,\\n        address e,\\n        address h,\\n        address sensePeriphery\\n    ) external authorized(admin) returns (bool) {\\n        {\\n            // Get the Illuminate principal token for this market (if one exists)\\n            address illuminate = markets[u][m][0];\\n\\n            // If illuminate PT already exists, a new market cannot be created\\n            if (illuminate != address(0)) {\\n                revert Exception(9, 0, 0, illuminate, address(0));\\n            }\\n        }\\n\\n        // Create an Illuminate principal token for the new market\\n        address illuminateToken = ICreator(creator).create(\\n            u,\\n            m,\\n            redeemer,\\n            lender,\\n            address(this),\\n            n,\\n            s\\n        );\\n\\n        {\\n            // create the principal tokens array\\n            address[9] memory market = [\\n                illuminateToken, // Illuminate\\n                t[0], // Swivel\\n                t[1], // Yield\\n                t[2], // Element\\n                t[3], // Pendle\\n                t[4], // Tempus\\n                t[5], // Sense\\n                t[6], // APWine\\n                t[7] // Notional\\n            ];\\n\\n            // Set the market\\n            markets[u][m] = market;\\n\\n            // Have the lender contract approve the several contracts\\n            ILender(lender).approve(u, a, e, t[7], sensePeriphery);\\n\\n            // Allow converter to spend interest bearing asset\\n            if (t[5] != address(0)) {\\n                IRedeemer(redeemer).approve(h);\\n            }\\n\\n            // Approve interest bearing token conversion to underlying for APWine\\n            if (t[6] != address(0)) {\\n                address futureVault = IAPWineToken(t[6]).futureVault();\\n                address interestBearingToken = IAPWineFutureVault(futureVault)\\n                    .getIBTAddress();\\n                IRedeemer(redeemer).approve(interestBearingToken);\\n            }\\n\\n            emit CreateMarket(u, m, market, e, a);\\n        }\\n        return true;\\n    }\\n\\n    /// @notice allows the admin to set an individual market\\n    /// @param p principal value according to the MarketPlace's Principals Enum\\n    /// @param u address of an underlying asset\\n    /// @param m maturity (timestamp) of the market\\n    /// @param a address of the new principal token\\n    /// @param h a supplementary address (apwine needs a router, element needs a vault, sense needs interest bearing asset)\\n    /// @param sensePeriphery address of the Sense periphery contract that must be approved by the lender\\n    /// @return bool true if the principal set, false otherwise\\n    function setPrincipal(\\n        uint8 p,\\n        address u,\\n        uint256 m,\\n        address a,\\n        address h,\\n        address sensePeriphery\\n    ) external authorized(admin) returns (bool) {\\n        // Set the principal token in the markets mapping\\n        markets[u][m][p] = a;\\n\\n        if (p == uint8(Principals.Element)) {\\n            // Approve Element vault if setting Element's principal token\\n            ILender(lender).approve(u, address(0), h, address(0), address(0));\\n        } else if (p == uint8(Principals.Sense)) {\\n            // Approve converter to transfer yield token for Sense's redeem\\n            IRedeemer(redeemer).approve(h);\\n\\n            // Approve Periphery to be used from Lender\\n            ILender(lender).approve(\\n                u,\\n                address(0),\\n                address(0),\\n                address(0),\\n                sensePeriphery\\n            );\\n        } else if (p == uint8(Principals.Apwine)) {\\n            // Approve converter to transfer yield token for APWine's redeem\\n            address futureVault = IAPWineToken(a).futureVault();\\n            address interestBearingToken = IAPWineFutureVault(futureVault)\\n                .getIBTAddress();\\n            IRedeemer(redeemer).approve(interestBearingToken);\\n\\n            // Approve APWine's router if setting APWine's principal token\\n            ILender(lender).approve(u, h, address(0), address(0), address(0));\\n        } else if (p == uint8(Principals.Notional)) {\\n            // Principal token must be approved for Notional's lend\\n            ILender(lender).approve(u, address(0), address(0), a, address(0));\\n        }\\n\\n        emit SetPrincipal(u, m, a, p);\\n        return true;\\n    }\\n\\n    /// @notice sets the admin address\\n    /// @param a Address of a new admin\\n    /// @return bool true if the admin set, false otherwise\\n    function setAdmin(address a) external authorized(admin) returns (bool) {\\n        admin = a;\\n        emit SetAdmin(a);\\n        return true;\\n    }\\n\\n    /// @notice sets the address for a pool\\n    /// @param u address of an underlying asset\\n    /// @param m maturity (timestamp) of the market\\n    /// @param a address of the pool\\n    /// @return bool true if the pool set, false otherwise\\n    function setPool(\\n        address u,\\n        uint256 m,\\n        address a\\n    ) external authorized(admin) returns (bool) {\\n        // Set the pool\\n        pools[u][m] = a;\\n\\n        // Get the principal token\\n        ERC5095 pt = ERC5095(markets[u][m][uint8(Principals.Illuminate)]);\\n\\n        // Set the pool for the principal token\\n        pt.setPool(a);\\n\\n        // Approve the marketplace to spend the principal and underlying tokens\\n        pt.approveMarketPlace();\\n\\n        emit SetPool(u, m, a);\\n        return true;\\n    }\\n\\n    /// @notice sells the PT for the underlying via the pool\\n    /// @param u address of an underlying asset\\n    /// @param m maturity (timestamp) of the market\\n    /// @param a amount of PTs to sell\\n    /// @param s slippage cap, minimum amount of underlying that must be received\\n    /// @return uint128 amount of underlying bought\\n    function sellPrincipalToken(\\n        address u,\\n        uint256 m,\\n        uint128 a,\\n        uint128 s\\n    ) external returns (uint128) {\\n        // Get the pool for the market\\n        IPool pool = IPool(pools[u][m]);\\n\\n        // Preview amount of underlying received by selling `a` PTs\\n        uint256 expected = pool.sellFYTokenPreview(a);\\n\\n        // Verify that the amount needed does not exceed the slippage parameter\\n        if (expected < s) {\\n            revert Exception(16, expected, s, address(0), address(0));\\n        }\\n\\n        // Transfer the principal tokens to the pool\\n        Safe.transferFrom(\\n            IERC20(address(pool.fyToken())),\\n            msg.sender,\\n            address(pool),\\n            a\\n        );\\n\\n        // Execute the swap\\n        uint128 received = pool.sellFYToken(msg.sender, s);\\n        emit Swap(u, m, address(pool.fyToken()), u, received, a, msg.sender);\\n\\n        return received;\\n    }\\n\\n    /// @notice buys the PT for the underlying via the pool\\n    /// @notice determines how many underlying to sell by using the preview\\n    /// @param u address of an underlying asset\\n    /// @param m maturity (timestamp) of the market\\n    /// @param a amount of PTs to be purchased\\n    /// @param s slippage cap, maximum number of underlying that can be sold\\n    /// @return uint128 amount of underlying sold\\n    function buyPrincipalToken(\\n        address u,\\n        uint256 m,\\n        uint128 a,\\n        uint128 s\\n    ) external returns (uint128) {\\n        // Get the pool for the market\\n        IPool pool = IPool(pools[u][m]);\\n\\n        // Get the amount of base hypothetically required to purchase `a` PTs\\n        uint128 expected = pool.buyFYTokenPreview(a);\\n\\n        // Verify that the amount needed does not exceed the slippage parameter\\n        if (expected > s) {\\n            revert Exception(16, expected, 0, address(0), address(0));\\n        }\\n\\n        // Transfer the underlying tokens to the pool\\n        Safe.transferFrom(\\n            IERC20(pool.base()),\\n            msg.sender,\\n            address(pool),\\n            expected\\n        );\\n\\n        // Execute the swap to purchase `a` base tokens\\n        uint128 spent = pool.buyFYToken(msg.sender, a, s);\\n\\n        emit Swap(u, m, u, address(pool.fyToken()), a, spent, msg.sender);\\n        return spent;\\n    }\\n\\n    /// @notice sells the underlying for the PT via the pool\\n    /// @param u address of an underlying asset\\n    /// @param m maturity (timestamp) of the market\\n    /// @param a amount of underlying to sell\\n    /// @param s slippage cap, minimum number of PTs that must be received\\n    /// @return uint128 amount of PT purchased\\n    function sellUnderlying(\\n        address u,\\n        uint256 m,\\n        uint128 a,\\n        uint128 s\\n    ) external returns (uint128) {\\n        // Get the pool for the market\\n        IPool pool = IPool(pools[u][m]);\\n\\n        // Get the number of PTs received for selling `a` underlying tokens\\n        uint128 expected = pool.sellBasePreview(a);\\n\\n        // Verify slippage does not exceed the one set by the user\\n        if (expected < s) {\\n            revert Exception(16, expected, 0, address(0), address(0));\\n        }\\n\\n        // Transfer the underlying tokens to the pool\\n        Safe.transferFrom(IERC20(pool.base()), msg.sender, address(pool), a);\\n\\n        // Execute the swap\\n        uint128 received = pool.sellBase(msg.sender, s);\\n\\n        emit Swap(u, m, u, address(pool.fyToken()), received, a, msg.sender);\\n        return received;\\n    }\\n\\n    /// @notice buys the underlying for the PT via the pool\\n    /// @notice determines how many PTs to sell by using the preview\\n    /// @param u address of an underlying asset\\n    /// @param m maturity (timestamp) of the market\\n    /// @param a amount of underlying to be purchased\\n    /// @param s slippage cap, maximum number of PTs that can be sold\\n    /// @return uint128 amount of PTs sold\\n    function buyUnderlying(\\n        address u,\\n        uint256 m,\\n        uint128 a,\\n        uint128 s\\n    ) external returns (uint128) {\\n        // Get the pool for the market\\n        IPool pool = IPool(pools[u][m]);\\n\\n        // Get the amount of PTs hypothetically required to purchase `a` underlying\\n        uint256 expected = pool.buyBasePreview(a);\\n\\n        // Verify that the amount needed does not exceed the slippage parameter\\n        if (expected > s) {\\n            revert Exception(16, expected, 0, address(0), address(0));\\n        }\\n\\n        // Transfer the principal tokens to the pool\\n        Safe.transferFrom(\\n            IERC20(address(pool.fyToken())),\\n            msg.sender,\\n            address(pool),\\n            expected\\n        );\\n\\n        // Execute the swap to purchase `a` underlying tokens\\n        uint128 spent = pool.buyBase(msg.sender, a, s);\\n\\n        emit Swap(u, m, address(pool.fyToken()), u, a, spent, msg.sender);\\n        return spent;\\n    }\\n\\n    /// @notice mint liquidity tokens in exchange for adding underlying and PT\\n    /// @dev amount of liquidity tokens to mint is calculated from the amount of unaccounted for PT in this contract.\\n    /// @dev A proportional amount of underlying tokens need to be present in this contract, also unaccounted for.\\n    /// @param u the address of the underlying token\\n    /// @param m the maturity of the principal token\\n    /// @param b number of base tokens\\n    /// @param p the principal token amount being sent\\n    /// @param minRatio minimum ratio of LP tokens to PT in the pool.\\n    /// @param maxRatio maximum ratio of LP tokens to PT in the pool.\\n    /// @return uint256 number of base tokens passed to the method\\n    /// @return uint256 number of yield tokens passed to the method\\n    /// @return uint256 the amount of tokens minted.\\n    function mint(\\n        address u,\\n        uint256 m,\\n        uint256 b,\\n        uint256 p,\\n        uint256 minRatio,\\n        uint256 maxRatio\\n    ) external returns (uint256, uint256, uint256) {\\n        // Get the pool for the market\\n        IPool pool = IPool(pools[u][m]);\\n\\n        // Transfer the underlying tokens to the pool\\n        Safe.transferFrom(IERC20(pool.base()), msg.sender, address(pool), b);\\n\\n        // Transfer the principal tokens to the pool\\n        Safe.transferFrom(\\n            IERC20(address(pool.fyToken())),\\n            msg.sender,\\n            address(pool),\\n            p\\n        );\\n\\n        // Mint the tokens and return the leftover assets to the caller\\n        (uint256 underlyingIn, uint256 principalTokensIn, uint256 minted) = pool\\n            .mint(msg.sender, msg.sender, minRatio, maxRatio);\\n\\n        emit Mint(u, m, underlyingIn, principalTokensIn, minted, msg.sender);\\n        return (underlyingIn, principalTokensIn, minted);\\n    }\\n\\n    /// @notice Mint liquidity tokens in exchange for adding only underlying\\n    /// @dev amount of liquidity tokens is calculated from the amount of PT to buy from the pool,\\n    /// plus the amount of unaccounted for PT in this contract.\\n    /// @param u the address of the underlying token\\n    /// @param m the maturity of the principal token\\n    /// @param a the underlying amount being sent\\n    /// @param p amount of `PT` being bought in the Pool, from this we calculate how much underlying it will be taken in.\\n    /// @param minRatio minimum ratio of LP tokens to PT in the pool.\\n    /// @param maxRatio maximum ratio of LP tokens to PT in the pool.\\n    /// @return uint256 number of base tokens passed to the method\\n    /// @return uint256 number of yield tokens passed to the method\\n    /// @return uint256 the amount of tokens minted.\\n    function mintWithUnderlying(\\n        address u,\\n        uint256 m,\\n        uint256 a,\\n        uint256 p,\\n        uint256 minRatio,\\n        uint256 maxRatio\\n    ) external returns (uint256, uint256, uint256) {\\n        // Get the pool for the market\\n        IPool pool = IPool(pools[u][m]);\\n\\n        // Transfer the underlying tokens to the pool\\n        Safe.transferFrom(IERC20(pool.base()), msg.sender, address(pool), a);\\n\\n        // Mint the tokens to the user\\n        (uint256 underlyingIn, , uint256 minted) = pool.mintWithBase(\\n            msg.sender,\\n            msg.sender,\\n            p,\\n            minRatio,\\n            maxRatio\\n        );\\n\\n        emit Mint(u, m, underlyingIn, 0, minted, msg.sender);\\n        return (underlyingIn, 0, minted);\\n    }\\n\\n    /// @notice burn liquidity tokens in exchange for underlying and PT.\\n    /// @param u the address of the underlying token\\n    /// @param m the maturity of the principal token\\n    /// @param a the amount of liquidity tokens to burn\\n    /// @param minRatio minimum ratio of LP tokens to PT in the pool\\n    /// @param maxRatio maximum ratio of LP tokens to PT in the pool\\n    /// @return uint256 amount of LP tokens burned\\n    /// @return uint256 amount of base tokens received\\n    /// @return uint256 amount of fyTokens received\\n    function burn(\\n        address u,\\n        uint256 m,\\n        uint256 a,\\n        uint256 minRatio,\\n        uint256 maxRatio\\n    ) external returns (uint256, uint256, uint256) {\\n        // Get the pool for the market\\n        IPool pool = IPool(pools[u][m]);\\n\\n        // Transfer the underlying tokens to the pool\\n        Safe.transferFrom(IERC20(address(pool)), msg.sender, address(pool), a);\\n\\n        // Burn the tokens\\n        (\\n            uint256 tokensBurned,\\n            uint256 underlyingReceived,\\n            uint256 principalTokensReceived\\n        ) = pool.burn(msg.sender, msg.sender, minRatio, maxRatio);\\n\\n        emit Burn(\\n            u,\\n            m,\\n            tokensBurned,\\n            underlyingReceived,\\n            principalTokensReceived,\\n            msg.sender\\n        );\\n        return (tokensBurned, underlyingReceived, principalTokensReceived);\\n    }\\n\\n    /// @notice burn liquidity tokens in exchange for underlying.\\n    /// @param u the address of the underlying token\\n    /// @param m the maturity of the principal token\\n    /// @param a the amount of liquidity tokens to burn\\n    /// @param minRatio minimum ratio of LP tokens to PT in the pool.\\n    /// @param maxRatio minimum ratio of LP tokens to PT in the pool.\\n    /// @return uint256 amount of PT tokens sent to the pool\\n    /// @return uint256 amount of underlying tokens returned\\n    function burnForUnderlying(\\n        address u,\\n        uint256 m,\\n        uint256 a,\\n        uint256 minRatio,\\n        uint256 maxRatio\\n    ) external returns (uint256, uint256) {\\n        // Get the pool for the market\\n        IPool pool = IPool(pools[u][m]);\\n\\n        // Transfer the underlying tokens to the pool\\n        Safe.transferFrom(IERC20(address(pool)), msg.sender, address(pool), a);\\n\\n        // Burn the tokens in exchange for underlying tokens\\n        (uint256 tokensBurned, uint256 underlyingReceived) = pool.burnForBase(\\n            msg.sender,\\n            minRatio,\\n            maxRatio\\n        );\\n\\n        emit Burn(u, m, tokensBurned, underlyingReceived, 0, msg.sender);\\n        return (tokensBurned, underlyingReceived);\\n    }\\n\\n    /// @notice Allows batched call to self (this contract).\\n    /// @param c An array of inputs for each call.\\n    function batch(\\n        bytes[] calldata c\\n    ) external payable returns (bytes[] memory results) {\\n        results = new bytes[](c.length);\\n        for (uint256 i; i < c.length; i++) {\\n            (bool success, bytes memory result) = address(this).delegatecall(\\n                c[i]\\n            );\\n            if (!success) revert(RevertMsgExtractor.getRevertMsg(result));\\n            results[i] = result;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Redeemer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\nimport 'src/Marketplace.sol';\\n\\nimport 'src/lib/Safe.sol';\\nimport 'src/lib/Maturities.sol';\\nimport 'src/errors/Exception.sol';\\n\\nimport 'src/interfaces/IERC5095.sol';\\nimport 'src/interfaces/IERC20.sol';\\nimport 'src/interfaces/ITempus.sol';\\nimport 'src/interfaces/ITempusToken.sol';\\nimport 'src/interfaces/IAPWineController.sol';\\nimport 'src/interfaces/IAPWineFutureVault.sol';\\nimport 'src/interfaces/IAPWineToken.sol';\\nimport 'src/interfaces/ISwivel.sol';\\nimport 'src/interfaces/ISwivelToken.sol';\\nimport 'src/interfaces/IElementToken.sol';\\nimport 'src/interfaces/IYieldToken.sol';\\nimport 'src/interfaces/INotional.sol';\\nimport 'src/interfaces/IPendleToken.sol';\\nimport 'src/interfaces/IPendleYieldToken.sol';\\nimport 'src/interfaces/IPendleSYToken.sol';\\nimport 'src/interfaces/ISensePeriphery.sol';\\nimport 'src/interfaces/ISenseDivider.sol';\\nimport 'src/interfaces/ISenseAdapter.sol';\\nimport 'src/interfaces/IConverter.sol';\\n\\n/// @title Redeemer\\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\\n/// @notice The Redeemer contract is used to redeem the underlying lent capital of a loan.\\n/// @notice Users may redeem their ERC-5095 tokens for the underlying asset represented by that token after maturity.\\ncontract Redeemer {\\n    /// @notice minimum wait before the admin may withdraw funds or change the fee rate\\n    uint256 public constant HOLD = 3 days;\\n\\n    /// @notice address that is allowed to set fees and contracts, etc. It is commonly used in the authorized modifier.\\n    address public admin;\\n    /// @notice address of the MarketPlace contract, used to access the markets mapping\\n    address public marketPlace;\\n    /// @notice address that custodies principal tokens for all markets\\n    address public lender;\\n    /// @notice address that converts compounding tokens to their underlying\\n    address public converter;\\n\\n    /// @notice third party contract needed to redeem Swivel PTs\\n    address public immutable swivelAddr;\\n    /// @notice third party contract needed to redeem Tempus PTs\\n    address public immutable tempusAddr;\\n\\n    /// @notice this value determines the amount of fees paid on auto redemptions\\n    uint256 public feenominator;\\n    /// @notice represents a point in time where the feenominator may change\\n    uint256 public feeChange;\\n    /// @notice represents a minimum that the feenominator must exceed\\n    uint256 public MIN_FEENOMINATOR = 500;\\n\\n    /// @notice mapping that indicates how much underlying has been redeemed by a market\\n    mapping(address => mapping(uint256 => uint256)) public holdings;\\n    /// @notice mapping that determines if a market's iPT can be redeemed\\n    mapping(address => mapping(uint256 => bool)) public paused;\\n\\n    /// @notice emitted upon redemption of a loan\\n    event Redeem(\\n        uint8 principal,\\n        address indexed underlying,\\n        uint256 indexed maturity,\\n        uint256 amount,\\n        uint256 burned,\\n        address sender\\n    );\\n    /// @notice emitted upon changing the admin\\n    event SetAdmin(address indexed admin);\\n    /// @notice emitted upon changing the converter\\n    event SetConverter(address indexed converter);\\n    /// @notice emitted upon setting the fee rate\\n    event SetFee(uint256 indexed fee);\\n    /// @notice emitted upon scheduling a fee change\\n    event ScheduleFeeChange(uint256 when);\\n    /// @notice emitted upon pausing of Illuminate PTs\\n    event PauseRedemptions(\\n        address indexed underlying,\\n        uint256 maturity,\\n        bool state\\n    );\\n\\n    /// @notice ensures that only a certain address can call the function\\n    /// @param a address that msg.sender must be to be authorized\\n    modifier authorized(address a) {\\n        if (msg.sender != a) {\\n            revert Exception(0, 0, 0, msg.sender, a);\\n        }\\n        _;\\n    }\\n\\n    /// @notice reverts on all markets where the paused mapping returns true\\n    /// @param u address of an underlying asset\\n    /// @param m maturity (timestamp) of the market\\n    modifier unpaused(address u, uint256 m) {\\n        if (paused[u][m] || ILender(lender).halted()) {\\n            revert Exception(17, m, 0, u, address(0));\\n        }\\n        _;\\n    }\\n\\n    /// @notice Initializes the Redeemer contract\\n    /// @param l the lender contract\\n    /// @param s the Swivel contract\\n    /// @param t the Tempus contract\\n    constructor(address l, address s, address t) {\\n        admin = msg.sender;\\n        lender = l;\\n        swivelAddr = s;\\n        tempusAddr = t;\\n        feenominator = 4000;\\n    }\\n\\n    /// @notice sets the admin address\\n    /// @param a Address of a new admin\\n    /// @return bool true if successful\\n    function setAdmin(address a) external authorized(admin) returns (bool) {\\n        admin = a;\\n        emit SetAdmin(a);\\n        return true;\\n    }\\n\\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\\n    /// @param m the address of the marketplace contract\\n    /// @return bool true if the address was set\\n    function setMarketPlace(\\n        address m\\n    ) external authorized(admin) returns (bool) {\\n        // MarketPlace may only be set once\\n        if (marketPlace != address(0)) {\\n            revert Exception(5, 0, 0, marketPlace, address(0));\\n        }\\n\\n        marketPlace = m;\\n        return true;\\n    }\\n\\n    /// @notice sets the converter address\\n    /// @param c address of the new converter\\n    /// @param i a list of interest bearing tokens the redeemer will approve\\n    /// @return bool true if successful\\n    function setConverter(\\n        address c,\\n        address[] memory i\\n    ) external authorized(admin) returns (bool) {\\n        // Set the new converter\\n        converter = c;\\n\\n        // Have the redeemer approve the new converter\\n        for (uint256 x; x != i.length; ) {\\n            // Approve the new converter to transfer the relevant tokens\\n            Safe.approve(IERC20(i[x]), c, type(uint256).max);\\n\\n            unchecked {\\n                x++;\\n            }\\n        }\\n\\n        emit SetConverter(c);\\n        return true;\\n    }\\n\\n    /// @notice sets the address of the lender contract which contains the addresses of all the fixed rate markets\\n    /// @param l the address of the lender contract\\n    /// @return bool true if the address was set\\n    function setLender(address l) external authorized(admin) returns (bool) {\\n        // Lender may only be set once\\n        if (lender != address(0)) {\\n            revert Exception(8, 0, 0, address(lender), address(0));\\n        }\\n\\n        lender = l;\\n        return true;\\n    }\\n\\n    /// @notice sets the feenominator to the given value\\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\\n    /// @return bool true if successful\\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\\n        // Cache the minimum timestamp for executing a fee rate change\\n        uint256 feeTime = feeChange;\\n\\n        // Check that a fee rate change has been scheduled\\n        if (feeTime == 0) {\\n            revert Exception(23, 0, 0, address(0), address(0));\\n\\n            // Check that the scheduled fee rate change time has been passed\\n        } else if (block.timestamp < feeTime) {\\n            revert Exception(\\n                24,\\n                block.timestamp,\\n                feeTime,\\n                address(0),\\n                address(0)\\n            );\\n            // Check the the new fee rate is not too high\\n        } else if (f < MIN_FEENOMINATOR) {\\n            revert Exception(25, 0, 0, address(0), address(0));\\n        }\\n\\n        // Set the new fee rate\\n        feenominator = f;\\n\\n        // Unschedule the fee rate change\\n        delete feeChange;\\n\\n        emit SetFee(f);\\n        return true;\\n    }\\n\\n    /// @notice allows the admin to schedule a change to the fee denominators\\n    function scheduleFeeChange() external authorized(admin) returns (bool) {\\n        // Calculate the timestamp that must be passed prior to setting thew new fee\\n        uint256 when = block.timestamp + HOLD;\\n\\n        // Store the timestamp that must be passed to update the fee rate\\n        feeChange = when;\\n\\n        emit ScheduleFeeChange(when);\\n\\n        return true;\\n    }\\n\\n    /// @notice allows admin to stop redemptions of Illuminate PTs for a given market\\n    /// @param u address of an underlying asset\\n    /// @param m maturity (timestamp) of the market\\n    /// @param b true to pause, false to unpause\\n    function pauseRedemptions(\\n        address u,\\n        uint256 m,\\n        bool b\\n    ) external authorized(admin) {\\n        paused[u][m] = b;\\n        emit PauseRedemptions(u, m, b);\\n    }\\n\\n    /// @notice approves the converter to spend the compounding asset\\n    /// @param i an interest bearing token that must be approved for conversion\\n    function approve(address i) external authorized(marketPlace) {\\n        if (i != address(0)) {\\n            Safe.approve(IERC20(i), address(converter), type(uint256).max);\\n        }\\n    }\\n\\n    /// @notice redeem method for Yield, Element, Pendle, APWine, Tempus and Notional protocols\\n    /// @param p principal value according to the MarketPlace's Principals Enum\\n    /// @param u address of an underlying asset\\n    /// @param m maturity (timestamp) of the market\\n    /// @return bool true if the redemption was successful\\n    function redeem(\\n        uint8 p,\\n        address u,\\n        uint256 m\\n    ) external unpaused(u, m) returns (bool) {\\n        // Get the principal token that is being redeemed by the user\\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\\n\\n        // Get the maturity for the given principal token\\n        uint256 maturity;\\n        if (p == uint8(MarketPlace.Principals.Yield)) {\\n            maturity = Maturities.yield(principal);\\n        } else if (p == uint8(MarketPlace.Principals.Element)) {\\n            maturity = Maturities.element(principal);\\n        } else if (p == uint8(MarketPlace.Principals.Pendle)) {\\n            maturity = Maturities.pendle(principal);\\n        } else if (p == uint8(MarketPlace.Principals.Tempus)) {\\n            maturity = Maturities.tempus(principal);\\n        } else if (p == uint8(MarketPlace.Principals.Apwine)) {\\n            maturity = Maturities.apwine(principal);\\n        } else if (p == uint8(MarketPlace.Principals.Notional)) {\\n            maturity = Maturities.notional(principal);\\n        } else {\\n            revert Exception(6, p, 0, address(0), address(0));\\n        }\\n\\n        // Verify that the token has matured\\n        if (maturity > block.timestamp) {\\n            revert Exception(7, maturity, 0, address(0), address(0));\\n        }\\n\\n        // Cache the lender to save gas on sload\\n        address cachedLender = lender;\\n\\n        // Get the amount of principal tokens held by the lender\\n        uint256 amount = IERC20(principal).balanceOf(cachedLender);\\n\\n        // For Pendle, we can transfer directly to the YT\\n        address destination = address(this);\\n        if (p == uint8(MarketPlace.Principals.Pendle)) {\\n            destination = IPendleToken(principal).YT();\\n        }\\n\\n        // Receive the principal token from the lender contract\\n        Safe.transferFrom(IERC20(principal), cachedLender, destination, amount);\\n\\n        // Get the starting balance of the underlying held by the redeemer\\n        uint256 starting = IERC20(u).balanceOf(address(this));\\n\\n        if (p == uint8(MarketPlace.Principals.Yield)) {\\n            // Redeems principal tokens from Yield\\n            IYieldToken(principal).redeem(address(this), amount);\\n        } else if (p == uint8(MarketPlace.Principals.Element)) {\\n            // Redeems principal tokens from Element\\n            IElementToken(principal).withdrawPrincipal(amount, address(this));\\n        } else if (p == uint8(MarketPlace.Principals.Pendle)) {\\n            // Retrieve the YT for the PT\\n            address yt = IPendleToken(principal).YT();\\n\\n            // Redeem the PTs to the SY token\\n            uint256 syRedeemed = IPendleYieldToken(yt).redeemPY(address(this));\\n\\n            // Retreive the SY token from the PT\\n            address sy = IPendleToken(principal).SY();\\n\\n            // Redeem the underlying by unwrapping the SY token\\n            IPendleSYToken(sy).redeem(address(this), syRedeemed, u, 0, false);\\n        } else if (p == uint8(MarketPlace.Principals.Tempus)) {\\n            // Retrieve the pool for the principal token\\n            address pool = ITempusToken(principal).pool();\\n\\n            // Redeems principal tokens from Tempus\\n            ITempus(tempusAddr).redeemToBacking(pool, amount, 0, address(this));\\n        } else if (p == uint8(MarketPlace.Principals.Apwine)) {\\n            apwineWithdraw(principal, u, amount);\\n        } else if (p == uint8(MarketPlace.Principals.Notional)) {\\n            // Redeems principal tokens from Notional\\n            INotional(principal).redeem(\\n                IERC20(principal).balanceOf(address(this)),\\n                address(this),\\n                address(this)\\n            );\\n        }\\n\\n        // Calculate how much underlying was redeemed\\n        uint256 redeemed = IERC20(u).balanceOf(address(this)) - starting;\\n\\n        // Update the holding for this market\\n        holdings[u][m] = holdings[u][m] + redeemed;\\n\\n        emit Redeem(p, u, m, redeemed, amount, msg.sender);\\n        return true;\\n    }\\n\\n    /// @notice redeem method signature for Swivel\\n    /// @param p principal value according to the MarketPlace's Principals Enum\\n    /// @param u address of an underlying asset\\n    /// @param m maturity (timestamp) of the market\\n    /// @return bool true if the redemption was successful\\n    function redeem(\\n        uint8 p,\\n        address u,\\n        uint256 m,\\n        uint8 protocol\\n    ) external unpaused(u, m) returns (bool) {\\n        // Check the principal is Swivel\\n        if (p != uint8(MarketPlace.Principals.Swivel)) {\\n            revert Exception(6, p, 0, address(0), address(0));\\n        }\\n\\n        // Get Swivel's principal token for this market\\n        address token = IMarketPlace(marketPlace).markets(u, m, p);\\n\\n        // Get the maturity of the token\\n        uint256 maturity = ISwivelToken(token).maturity();\\n\\n        // Verify that the token has matured\\n        if (maturity > block.timestamp) {\\n            revert Exception(7, maturity, 0, address(0), address(0));\\n        }\\n\\n        // Cache the lender to save on SLOAD operations\\n        address cachedLender = lender;\\n\\n        // Get the balance of tokens to be redeemed by the lenders\\n        uint256 amount = IERC20(token).balanceOf(cachedLender);\\n\\n        // Transfer the lenders' tokens to the redeem contract\\n        Safe.transferFrom(IERC20(token), cachedLender, address(this), amount);\\n\\n        // Get the starting balance to verify the amount received afterwards\\n        uint256 starting = IERC20(u).balanceOf(address(this));\\n\\n        // Redeem principal tokens from Swivel\\n        if (!ISwivel(swivelAddr).redeemZcToken(protocol, u, maturity, amount)) {\\n            revert Exception(15, 0, 0, address(0), address(0));\\n        }\\n\\n        // Retrieve unswapped premium from the Lender contract\\n        ILender(cachedLender).transferPremium(u, m);\\n\\n        // Calculate how much underlying was redeemed\\n        uint256 redeemed = IERC20(u).balanceOf(address(this)) - starting;\\n\\n        // Update the holding for this market\\n        holdings[u][m] = holdings[u][m] + redeemed;\\n\\n        emit Redeem(p, u, m, redeemed, amount, msg.sender);\\n        return true;\\n    }\\n\\n    /// @notice redeem method signature for Sense\\n    /// @param p principal value according to the MarketPlace's Principals Enum\\n    /// @param u address of an underlying asset\\n    /// @param m maturity (timestamp) of the market\\n    /// @param s Sense's maturity is needed to extract the pt address\\n    /// @param a Sense's adapter index\\n    /// @param periphery Sense's periphery contract, used to get the verified adapter\\n    /// @return bool true if the redemption was successful\\n    function redeem(\\n        uint8 p,\\n        address u,\\n        uint256 m,\\n        uint256 s,\\n        uint256 a,\\n        address periphery\\n    ) external unpaused(u, m) returns (bool) {\\n        // Get Sense's principal token for this market\\n        IERC20 token = IERC20(\\n            IMarketPlace(marketPlace).markets(\\n                u,\\n                m,\\n                uint8(MarketPlace.Principals.Sense)\\n            )\\n        );\\n\\n        // Confirm the periphery is verified by the lender\\n        if (IERC20(u).allowance(lender, periphery) == 0) {\\n            revert Exception(29, 0, 0, address(0), address(0));\\n        }\\n\\n        // Cache the lender to save on SLOAD operations\\n        address cachedLender = lender;\\n\\n        // Get the balance of tokens to be redeemed by the user\\n        uint256 amount = token.balanceOf(cachedLender);\\n\\n        // Transfer the user's tokens to the redeem contract\\n        Safe.transferFrom(token, cachedLender, address(this), amount);\\n\\n        // Calculate the balance of the redeemer contract\\n        uint256 redeemable = token.balanceOf(address(this));\\n\\n        // Get the starting balance to verify the amount received afterwards\\n        uint256 starting = IERC20(u).balanceOf(address(this));\\n\\n        // Get the existing balance of Sense PTs\\n        uint256 senseBalance = token.balanceOf(address(this));\\n\\n        // Get the divider from the periphery\\n        ISenseDivider divider = ISenseDivider(\\n            ISensePeriphery(periphery).divider()\\n        );\\n\\n        // Get the adapter from the divider\\n        address adapter = divider.adapterAddresses(a);\\n\\n        // Redeem the tokens from the Sense contract\\n        ISenseDivider(divider).redeem(adapter, s, senseBalance);\\n\\n        // Get the compounding token that is redeemed by Sense\\n        address compounding = ISenseAdapter(adapter).target();\\n\\n        // Redeem the compounding token back to the underlying\\n        IConverter(converter).convert(\\n            compounding,\\n            u,\\n            IERC20(compounding).balanceOf(address(this))\\n        );\\n\\n        // Get the amount received\\n        uint256 redeemed = IERC20(u).balanceOf(address(this)) - starting;\\n\\n        // Update the holdings for this market\\n        holdings[u][m] = holdings[u][m] + redeemed;\\n\\n        emit Redeem(p, u, m, redeemed, redeemable, msg.sender);\\n        return true;\\n    }\\n\\n    /// @notice burns Illuminate principal tokens and sends underlying to user\\n    /// @param u address of an underlying asset\\n    /// @param m maturity (timestamp) of the market\\n    function redeem(address u, uint256 m) external unpaused(u, m) {\\n        // Get Illuminate's principal token for this market\\n        IERC5095 token = IERC5095(\\n            IMarketPlace(marketPlace).markets(\\n                u,\\n                m,\\n                uint8(MarketPlace.Principals.Illuminate)\\n            )\\n        );\\n\\n        // Verify the token has matured\\n        if (block.timestamp < token.maturity()) {\\n            revert Exception(7, block.timestamp, m, address(0), address(0));\\n        }\\n\\n        // Get the amount of tokens to be redeemed from the sender\\n        uint256 amount = token.balanceOf(msg.sender);\\n\\n        // Calculate how many tokens the user should receive\\n        uint256 redeemed = (amount * holdings[u][m]) / token.totalSupply();\\n\\n        // Update holdings of underlying\\n        holdings[u][m] = holdings[u][m] - redeemed;\\n\\n        // Burn the user's principal tokens\\n        token.authBurn(msg.sender, amount);\\n\\n        // Transfer the original underlying token back to the user\\n        Safe.transfer(IERC20(u), msg.sender, redeemed);\\n\\n        emit Redeem(0, u, m, redeemed, amount, msg.sender);\\n    }\\n\\n    /// @notice implements the redeem method for the contract to fulfill the ERC-5095 interface\\n    /// @param u address of an underlying asset\\n    /// @param m maturity (timestamp) of the market\\n    /// @param f address from where the underlying asset will be burned\\n    /// @param t address to where the underlying asset will be transferred\\n    /// @param a amount of the Illuminate PT to be burned and redeemed\\n    /// @return uint256 amount of the underlying asset that was burned\\n    function authRedeem(\\n        address u,\\n        uint256 m,\\n        address f,\\n        address t,\\n        uint256 a\\n    )\\n        external\\n        authorized(IMarketPlace(marketPlace).markets(u, m, 0))\\n        unpaused(u, m)\\n        returns (uint256)\\n    {\\n        // Get the principal token for the given market\\n        IERC5095 pt = IERC5095(IMarketPlace(marketPlace).markets(u, m, 0));\\n\\n        // Make sure the market has matured\\n        uint256 maturity = pt.maturity();\\n        if (block.timestamp < maturity) {\\n            revert Exception(7, maturity, 0, address(0), address(0));\\n        }\\n\\n        // Calculate the amount redeemed\\n        uint256 redeemed = (a * holdings[u][m]) / pt.totalSupply();\\n\\n        // Update holdings of underlying\\n        holdings[u][m] = holdings[u][m] - redeemed;\\n\\n        // Burn the user's principal tokens\\n        pt.authBurn(f, a);\\n\\n        // Transfer the original underlying token back to the user\\n        Safe.transfer(IERC20(u), t, redeemed);\\n\\n        emit Redeem(0, u, m, redeemed, a, msg.sender);\\n        return a;\\n    }\\n\\n    /// @notice implements a redeem method to enable third-party redemptions\\n    /// @dev expects approvals from owners to redeemer\\n    /// @param u address of the underlying asset\\n    /// @param m maturity of the market\\n    /// @param f address from where the principal token will be burned\\n    /// @return uint256 amount of underlying yielded as a fee\\n    function autoRedeem(\\n        address u,\\n        uint256 m,\\n        address[] calldata f\\n    ) external unpaused(u, m) returns (uint256) {\\n        // Get the principal token for the given market\\n        IERC5095 pt = IERC5095(IMarketPlace(marketPlace).markets(u, m, 0));\\n\\n        // Make sure the market has matured\\n        if (block.timestamp < pt.maturity()) {\\n            revert Exception(7, pt.maturity(), 0, address(0), address(0));\\n        }\\n\\n        // Sum up the fees received by the caller\\n        uint256 incentiveFee;\\n\\n        // Loop through the provided arrays and mature each individual position\\n        for (uint256 i; i != f.length; ) {\\n            // Fetch the allowance set by the holder of the principal tokens\\n            uint256 allowance = pt.allowance(f[i], address(this));\\n\\n            // Get the amount of tokens held by the owner\\n            uint256 amount = pt.balanceOf(f[i]);\\n\\n            // Calculate how many tokens the user should receive\\n            uint256 redeemed = (amount * holdings[u][m]) / pt.totalSupply();\\n\\n            // Calculate the fees to be received\\n            uint256 fee = redeemed / feenominator;\\n\\n            // Verify allowance\\n            if (allowance < amount) {\\n                revert Exception(20, allowance, amount, address(0), address(0));\\n            }\\n\\n            // Burn the tokens from the user\\n            pt.authBurn(f[i], amount);\\n\\n            // Reduce the allowance of the burned tokens\\n            pt.authApprove(f[i], address(this), 0);\\n\\n            // Update the holdings for this market\\n            holdings[u][m] = holdings[u][m] - redeemed;\\n\\n            // Transfer the underlying to the user\\n            Safe.transfer(IERC20(u), f[i], redeemed - fee);\\n\\n            unchecked {\\n                // Track the fees gained by the caller\\n                incentiveFee += fee;\\n\\n                ++i;\\n            }\\n        }\\n\\n        // Transfer the fee to the caller\\n        Safe.transfer(IERC20(u), msg.sender, incentiveFee);\\n\\n        return incentiveFee;\\n    }\\n\\n    /// @notice Allows for external deposit of underlying for a market\\n    /// @notice This is to be used in emergency situations where the redeem method is not functioning for a market\\n    /// @param u address of the underlying asset\\n    /// @param m maturity of the market\\n    /// @param a amount of underlying to be deposited\\n    function depositHoldings(address u, uint256 m, uint256 a) external {\\n        // Receive the underlying asset from the admin\\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\\n\\n        // Update the holdings\\n        holdings[u][m] += a;\\n    }\\n\\n    /// @notice Execute the business logic for conducting an APWine redemption\\n    function apwineWithdraw(address p, address u, uint256 a) internal {\\n        // Retrieve the vault which executes the redemption in APWine\\n        address futureVault = IAPWineToken(p).futureVault();\\n\\n        // Retrieve the controller that will execute the withdrawal\\n        address controller = IAPWineFutureVault(futureVault)\\n            .getControllerAddress();\\n\\n        // Retrieve the next period index\\n        uint256 index = IAPWineFutureVault(futureVault).getCurrentPeriodIndex();\\n\\n        // Get the FYT address for the current period\\n        address fyt = IAPWineFutureVault(futureVault).getFYTofPeriod(index);\\n\\n        // Ensure there are sufficient FYTs to execute the redemption\\n        uint256 amount = IERC20(fyt).balanceOf(address(lender));\\n\\n        // Get the minimum between the FYT and PT balance to redeem\\n        if (amount > a) {\\n            amount = a;\\n        }\\n\\n        // Trigger claim to FYTs by executing transfer\\n        ILender(lender).transferFYTs(fyt, amount);\\n\\n        // Redeem the underlying token from APWine to Illuminate\\n        IAPWineController(controller).withdraw(futureVault, amount);\\n\\n        // Retrieve the interest bearing token\\n        address ibt = IAPWineFutureVault(futureVault).getIBTAddress();\\n\\n        // Convert the interest bearing token to underlying\\n        IConverter(converter).convert(\\n            IAPWineFutureVault(futureVault).getIBTAddress(),\\n            u,\\n            IERC20(ibt).balanceOf(address(this))\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/errors/Exception.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\n/// @dev A single custom error capable of indicating a wide range of detected errors by providing\\n/// an error code value whose string representation is documented in errors.txt, and any possible other values\\n/// that are pertinent to the error.\\nerror Exception(uint8, uint256, uint256, address, address);\\n\"\r\n    },\r\n    \"src/interfaces/IAPWineController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\ninterface IAPWineController {\\n    function getNextPeriodStart(uint256) external view returns (uint256);\\n\\n    function withdraw(address, uint256) external;\\n\\n    function createFYTDelegationTo(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IAPWineFutureVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\ninterface IAPWineFutureVault {\\n    function PERIOD_DURATION() external view returns (uint256);\\n\\n    function getControllerAddress() external view returns (address);\\n\\n    function getCurrentPeriodIndex() external view returns (uint256);\\n\\n    function getFYTofPeriod(uint256) external view returns (address);\\n\\n    function getIBTAddress() external view returns (address);\\n\\n    function startNewPeriod() external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IAPWineToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\ninterface IAPWineToken {\\n    function futureVault() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IAny.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\ninterface IAny {}\\n\"\r\n    },\r\n    \"src/interfaces/IConverter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\ninterface IConverter {\\n    function convert(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ICreator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\ninterface ICreator {\\n    function create(\\n        address,\\n        uint256,\\n        address,\\n        address,\\n        address,\\n        string calldata,\\n        string calldata\\n    ) external returns (address);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Returns the number of decimals the token uses - e.g. 8, means to\\n     * divide the token amount by 100000000 to get its user representation.\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\nimport 'src/interfaces/IERC20.sol';\\n\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC2612.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\nimport 'src/interfaces/IERC20Metadata.sol';\\n\\n/**\\n * @dev Interface of the ERC2612 standard as defined in the EIP.\\n *\\n * Adds the {permit} method, which can be used to change one's\\n * {IERC20-allowance} without having to send a transaction, by signing a\\n * message. This allows users to spend tokens without having to hold Ether.\\n *\\n * See https://eips.ethereum.org/EIPS/eip-2612.\\n */\\ninterface IERC2612 is IERC20Metadata {\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC5095.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\nimport 'src/interfaces/IERC2612.sol';\\n\\ninterface IERC5095 is IERC2612 {\\n    function maturity() external view returns (uint256);\\n\\n    function underlying() external view returns (address);\\n\\n    function convertToUnderlying(uint256) external view returns (uint256);\\n\\n    function convertToShares(uint256) external view returns (uint256);\\n\\n    function maxRedeem(address) external view returns (uint256);\\n\\n    function previewRedeem(uint256) external view returns (uint256);\\n\\n    function maxWithdraw(address) external view returns (uint256);\\n\\n    function previewWithdraw(uint256) external view returns (uint256);\\n\\n    function previewDeposit(uint256) external view returns (uint256);\\n\\n    function withdraw(\\n        uint256,\\n        address,\\n        address\\n    ) external returns (uint256);\\n\\n    function redeem(\\n        uint256,\\n        address,\\n        address\\n    ) external returns (uint256);\\n\\n    function deposit(uint256, address) external returns (uint256);\\n\\n    function mint(uint256, address) external returns (uint256);\\n\\n    function authMint(address, uint256) external returns (bool);\\n\\n    function authBurn(address, uint256) external returns (bool);\\n\\n    function authApprove(\\n        address,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IElementToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\ninterface IElementToken {\\n    function unlockTimestamp() external view returns (uint256);\\n\\n    function underlying() external returns (address);\\n\\n    function withdrawPrincipal(uint256 amount, address destination)\\n        external\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\ninterface ILender {\\n    function approve(\\n        address,\\n        address,\\n        address,\\n        address,\\n        address\\n    ) external;\\n\\n    function transferFYTs(address, uint256) external;\\n\\n    function transferPremium(address, uint256) external;\\n\\n    function paused(uint8) external returns (bool);\\n\\n    function halted() external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMarketPlace.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\ninterface IMarketPlace {\\n    function markets(\\n        address,\\n        uint256,\\n        uint256\\n    ) external returns (address);\\n\\n    function pools(address, uint256) external view returns (address);\\n\\n    function sellPrincipalToken(\\n        address,\\n        uint256,\\n        uint128,\\n        uint128\\n    ) external returns (uint128);\\n\\n    function buyPrincipalToken(\\n        address,\\n        uint256,\\n        uint128,\\n        uint128\\n    ) external returns (uint128);\\n\\n    function sellUnderlying(\\n        address,\\n        uint256,\\n        uint128,\\n        uint128\\n    ) external returns (uint128);\\n\\n    function buyUnderlying(\\n        address,\\n        uint256,\\n        uint128,\\n        uint128\\n    ) external returns (uint128);\\n\\n    function redeemer() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/INotional.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\nimport 'src/interfaces/IERC20.sol';\\n\\ninterface INotional {\\n    function getUnderlyingToken() external view returns (IERC20, int256);\\n\\n    function getMaturity() external view returns (uint40);\\n\\n    function deposit(uint256, address) external returns (uint256);\\n\\n    function maxRedeem(address) external returns (uint256);\\n\\n    function redeem(\\n        uint256,\\n        address,\\n        address\\n    ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPendleSYToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\ninterface IPendleSYToken {\\n    function redeem(\\n        address,\\n        uint256,\\n        address,\\n        uint256,\\n        bool\\n    ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPendleToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\ninterface IPendleToken {\\n    function SY() external view returns (address);\\n\\n    function YT() external view returns (address);\\n\\n    function expiry() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPendleYieldToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\ninterface IPendleYieldToken {\\n    function redeemPY(address) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.16;\\n\\nimport 'src/interfaces/IERC20.sol';\\nimport 'src/interfaces/IERC5095.sol';\\n\\ninterface IPool {\\n    function ts() external view returns (int128);\\n\\n    function g1() external view returns (int128);\\n\\n    function g2() external view returns (int128);\\n\\n    function maturity() external view returns (uint32);\\n\\n    function scaleFactor() external view returns (uint96);\\n\\n    function getCache()\\n        external\\n        view\\n        returns (\\n            uint112,\\n            uint112,\\n            uint32\\n        );\\n\\n    // NOTE This will be deprecated\\n    function base() external view returns (IERC20);\\n\\n    function baseToken() external view returns (address);\\n\\n    function fyToken() external view returns (IERC5095);\\n\\n    function getBaseBalance() external view returns (uint112);\\n\\n    function getFYTokenBalance() external view returns (uint112);\\n\\n    function retrieveBase(address) external returns (uint128 retrieved);\\n\\n    function retrieveFYToken(address) external returns (uint128 retrieved);\\n\\n    function sellBase(address, uint128) external returns (uint128);\\n\\n    function buyBase(\\n        address,\\n        uint128,\\n        uint128\\n    ) external returns (uint128);\\n\\n    function sellFYToken(address, uint128) external returns (uint128);\\n\\n    function buyFYToken(\\n        address,\\n        uint128,\\n        uint128\\n    ) external returns (uint128);\\n\\n    function sellBasePreview(uint128) external view returns (uint128);\\n\\n    function buyBasePreview(uint128) external view returns (uint128);\\n\\n    function sellFYTokenPreview(uint128) external view returns (uint128);\\n\\n    function buyFYTokenPreview(uint128) external view returns (uint128);\\n\\n    function mint(\\n        address,\\n        address,\\n        uint256,\\n        uint256\\n    )\\n        external\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function mintWithBase(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        uint256\\n    )\\n        external\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function burn(\\n        address,\\n        address,\\n        uint256,\\n        uint256\\n    )\\n        external\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function burnForBase(\\n        address,\\n        uint256,\\n        uint256\\n    ) external returns (uint256, uint256);\\n\\n    function cumulativeBalancesRatio() external view returns (uint256);\\n\\n    function sync() external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IRedeemer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.16;\\n\\ninterface IRedeemer {\\n    function authRedeem(\\n        address underlying,\\n        uint256 maturity,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (uint256);\\n\\n    function approve(address p) external;\\n\\n    function holdings(address u, uint256 m) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISenseAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\ninterface ISenseAdapter {\\n    function underlying() external view returns (address);\\n\\n    function divider() external view returns (address);\\n\\n    function target() external view returns (address);\\n\\n    function maxm() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISenseDivider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\ninterface ISenseDivider {\\n    function redeem(\\n        address,\\n        uint256,\\n        uint256\\n    ) external returns (uint256);\\n\\n    function pt(address, uint256) external view returns (address);\\n\\n    // only used by integration tests\\n    function settleSeries(address, uint256) external;\\n\\n    function adapterAddresses(uint256) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISensePeriphery.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\ninterface ISensePeriphery {\\n    function divider() external view returns (address);\\n\\n    function swapUnderlyingForPTs(\\n        address,\\n        uint256,\\n        uint256,\\n        uint256\\n    ) external returns (uint256);\\n\\n    function verified(address) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISwivel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\nimport 'src/lib/Swivel.sol';\\n\\ninterface ISwivel {\\n    function initiate(\\n        Swivel.Order[] calldata,\\n        uint256[] calldata,\\n        Swivel.Components[] calldata\\n    ) external returns (bool);\\n\\n    function redeemZcToken(\\n        uint8 p,\\n        address u,\\n        uint256 m,\\n        uint256 a\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISwivelToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\ninterface ISwivelToken {\\n    function maturity() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ITempus.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\nimport 'src/interfaces/IERC20Metadata.sol';\\nimport 'src/interfaces/IAny.sol';\\n\\ninterface ITempus {\\n    function depositAndFix(\\n        address,\\n        uint256,\\n        bool,\\n        uint256,\\n        uint256\\n    ) external;\\n\\n    function redeemToBacking(\\n        address,\\n        uint256,\\n        uint256,\\n        address\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ITempusPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\nimport 'src/interfaces/IERC20Metadata.sol';\\n\\ninterface ITempusPool {\\n    function maturityTime() external view returns (uint256);\\n\\n    function backingToken() external view returns (address);\\n\\n    function controller() external view returns (address);\\n\\n    // Used for integration testing\\n    function principalShare() external view returns (address);\\n\\n    function currentInterestRate() external view returns (uint256);\\n\\n    function initialInterestRate() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ITempusToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\ninterface ITempusToken {\\n    function balanceOf(address) external returns (uint256);\\n\\n    function pool() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IYield.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\nimport 'src/interfaces/IERC20.sol';\\n\\ninterface IYield {\\n    function maturity() external view returns (uint32);\\n\\n    function base() external view returns (IERC20);\\n\\n    function sellBase(address, uint128) external returns (uint128);\\n\\n    function sellBasePreview(uint128) external view returns (uint128);\\n\\n    function fyToken() external returns (address);\\n\\n    function sellFYToken(address, uint128) external returns (uint128);\\n\\n    function sellFYTokenPreview(uint128) external view returns (uint128);\\n\\n    function buyBase(\\n        address,\\n        uint128,\\n        uint128\\n    ) external returns (uint128);\\n\\n    function buyBasePreview(uint128) external view returns (uint128);\\n\\n    function buyFYToken(\\n        address,\\n        uint128,\\n        uint128\\n    ) external returns (uint128);\\n\\n    function buyFYTokenPreview(uint128) external view returns (uint128);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IYieldToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\ninterface IYieldToken {\\n    function redeem(address, uint256) external returns (uint256);\\n\\n    function underlying() external returns (address);\\n\\n    function maturity() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/lib/Cast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.13;\\n\\nlibrary Cast {\\n    /// @dev Safely cast an uint256 to an uint128\\n    /// @param n the u256 to cast to u128\\n    function u128(uint256 n) internal pure returns (uint128) {\\n        if (n > type(uint128).max) {\\n            revert();\\n        }\\n        return uint128(n);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/Maturities.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\nimport 'src/interfaces/IERC5095.sol';\\nimport 'src/interfaces/ISwivelToken.sol';\\nimport 'src/interfaces/IYieldToken.sol';\\nimport 'src/interfaces/IElementToken.sol';\\nimport 'src/interfaces/IPendleToken.sol';\\nimport 'src/interfaces/ITempusToken.sol';\\nimport 'src/interfaces/ITempusPool.sol';\\nimport 'src/interfaces/IAPWineToken.sol';\\nimport 'src/interfaces/IAPWineFutureVault.sol';\\nimport 'src/interfaces/IAPWineController.sol';\\nimport 'src/interfaces/INotional.sol';\\n\\nlibrary Maturities {\\n    /// @notice returns the maturity for an Illumiante principal token\\n    /// @param p address of the principal token contract\\n    /// @return uint256 maturity of the principal token\\n    function illuminate(address p) internal view returns (uint256) {\\n        return IERC5095(p).maturity();\\n    }\\n\\n    /// @notice returns the maturity for a Swivel principal token\\n    /// @param p address of the principal token contract\\n    /// @return uint256 maturity of the principal token\\n    function swivel(address p) internal view returns (uint256) {\\n        return ISwivelToken(p).maturity();\\n    }\\n\\n    function yield(address p) internal view returns (uint256) {\\n        return IYieldToken(p).maturity();\\n    }\\n\\n    /// @notice returns the maturity for an Element principal token\\n    /// @param p address of the principal token contract\\n    /// @return uint256 maturity of the principal token\\n    function element(address p) internal view returns (uint256) {\\n        return IElementToken(p).unlockTimestamp();\\n    }\\n\\n    /// @notice returns the maturity for a Pendle principal token\\n    /// @param p address of the principal token contract\\n    /// @return uint256 maturity of the principal token\\n    function pendle(address p) internal view returns (uint256) {\\n        return IPendleToken(p).expiry();\\n    }\\n\\n    /// @notice returns the maturity for a Tempus principal token\\n    /// @param p address of the principal token contract\\n    /// @return uint256 maturity of the principal token\\n    function tempus(address p) internal view returns (uint256) {\\n        return ITempusPool(ITempusToken(p).pool()).maturityTime();\\n    }\\n\\n    /// @notice returns the maturity for a APWine principal token\\n    /// @param p address of the principal token contract\\n    /// @return uint256 maturity of the principal token\\n    function apwine(address p) internal view returns (uint256) {\\n        address futureVault = IAPWineToken(p).futureVault();\\n\\n        address controller = IAPWineFutureVault(futureVault)\\n            .getControllerAddress();\\n\\n        uint256 duration = IAPWineFutureVault(futureVault).PERIOD_DURATION();\\n\\n        return IAPWineController(controller).getNextPeriodStart(duration);\\n    }\\n\\n    /// @notice returns the maturity for a Notional principal token\\n    /// @param p address of the principal token contract\\n    /// @return uint256 maturity of the principal token\\n    function notional(address p) internal view returns (uint256) {\\n        return INotional(p).getMaturity();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/RevertMsgExtractor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Taken from https://github.com/sushiswap/BoringSolidity/blob/441e51c0544cf2451e6116fe00515e71d7c42e2c/contracts/BoringBatchable.sol\\n\\npragma solidity >=0.6.0;\\n\\nlibrary RevertMsgExtractor {\\n    /// @dev Helper function to extract a useful revert message from a failed call.\\n    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\\n    function getRevertMsg(bytes memory returnData)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\\n        if (returnData.length < 68) return 'Transaction reverted silently';\\n\\n        assembly {\\n            // Slice the sighash.\\n            returnData := add(returnData, 0x04)\\n        }\\n        return abi.decode(returnData, (string)); // All that remains is the revert string\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/Safe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Adapted from: https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol\\n\\npragma solidity ^0.8.13;\\n\\nimport 'src/interfaces/IERC20.sol';\\n\\n/**\\n  @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n  @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\\n  @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n*/\\n\\nlibrary Safe {\\n    /// @param e Erc20 token to execute the call with\\n    /// @param t To address\\n    /// @param a Amount being transferred\\n    function transfer(\\n        IERC20 e,\\n        address t,\\n        uint256 a\\n    ) internal {\\n        bool result;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let pointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(\\n                pointer,\\n                0xa9059cbb00000000000000000000000000000000000000000000000000000000\\n            ) // Begin with the function selector.\\n            mstore(\\n                add(pointer, 4),\\n                and(t, 0xffffffffffffffffffffffffffffffffffffffff)\\n            ) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(pointer, 36), a) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            result := call(gas(), e, 0, pointer, 68, 0, 0)\\n        }\\n\\n        require(success(result), 'transfer failed');\\n    }\\n\\n    /// @param e Erc20 token to execute the call with\\n    /// @param f From address\\n    /// @param t To address\\n    /// @param a Amount being transferred\\n    function transferFrom(\\n        IERC20 e,\\n        address f,\\n        address t,\\n        uint256 a\\n    ) internal {\\n        bool result;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let pointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(\\n                pointer,\\n                0x23b872dd00000000000000000000000000000000000000000000000000000000\\n            ) // Begin with the function selector.\\n            mstore(\\n                add(pointer, 4),\\n                and(f, 0xffffffffffffffffffffffffffffffffffffffff)\\n            ) // Mask and append the \\\"from\\\" argument.\\n            mstore(\\n                add(pointer, 36),\\n                and(t, 0xffffffffffffffffffffffffffffffffffffffff)\\n            ) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(pointer, 68), a) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 100 because the calldata length is 4 + 32 * 3.\\n            result := call(gas(), e, 0, pointer, 100, 0, 0)\\n        }\\n\\n        require(success(result), 'transfer from failed');\\n    }\\n\\n    /// @notice normalize the acceptable values of true or null vs the unacceptable value of false (or something malformed)\\n    /// @param r Return value from the assembly `call()` to Erc20['selector']\\n    function success(bool r) private pure returns (bool) {\\n        bool result;\\n\\n        assembly {\\n            // Get how many bytes the call returned.\\n            let returnDataSize := returndatasize()\\n\\n            // If the call reverted:\\n            if iszero(r) {\\n                // Copy the revert message into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Revert with the same message.\\n                revert(0, returnDataSize)\\n            }\\n\\n            switch returnDataSize\\n            case 32 {\\n                // Copy the return data into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Set success to whether it returned true.\\n                result := iszero(iszero(mload(0)))\\n            }\\n            case 0 {\\n                // There was no return data.\\n                result := 1\\n            }\\n            default {\\n                // It returned some malformed input.\\n                result := 0\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    function approve(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(\\n                freeMemoryPointer,\\n                0x095ea7b300000000000000000000000000000000000000000000000000000000\\n            ) // Begin with the function selector.\\n            mstore(\\n                add(freeMemoryPointer, 4),\\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\\n            ) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), 'APPROVE_FAILED');\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function didLastOptionalReturnCallSucceed(bool callStatus)\\n        private\\n        pure\\n        returns (bool)\\n    {\\n        bool result;\\n        assembly {\\n            // Get how many bytes the call returned.\\n            let returnDataSize := returndatasize()\\n\\n            // If the call reverted:\\n            if iszero(callStatus) {\\n                // Copy the revert message into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Revert with the same message.\\n                revert(0, returnDataSize)\\n            }\\n\\n            switch returnDataSize\\n            case 32 {\\n                // Copy the return data into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Set success to whether it returned true.\\n                result := iszero(iszero(mload(0)))\\n            }\\n            case 0 {\\n                // There was no return data.\\n                result := 1\\n            }\\n            default {\\n                // It returned some malformed input.\\n                result := 0\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/Swivel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.13;\\n\\nlibrary Swivel {\\n    // the components of a ECDSA signature\\n    struct Components {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    struct Order {\\n        bytes32 key;\\n        uint8 protocol;\\n        address maker;\\n        address underlying;\\n        bool vault;\\n        bool exit;\\n        uint256 principal;\\n        uint256 premium;\\n        uint256 maturity;\\n        uint256 expiry;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Inspired on token.sol from DappHub. Natspec adpated from OpenZeppelin.\\npragma solidity 0.8.16;\\n\\nimport 'src/interfaces/IERC20Metadata.sol';\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Calls to {transferFrom} do not check for allowance if the caller is the owner\\n * of the funds. This allows to reduce the number of approvals that are necessary.\\n *\\n * Finally, {transferFrom} does not decrease the allowance if it is set to\\n * type(uint256).max. This reduces the gas costs without any likely impact.\\n */\\ncontract ERC20 is IERC20Metadata {\\n    uint256 internal _totalSupply;\\n    mapping(address => uint256) internal _balanceOf;\\n    mapping(address => mapping(address => uint256)) internal _allowance;\\n    string public override name = '???';\\n    string public override symbol = '???';\\n    uint8 public override decimals = 18;\\n\\n    /**\\n     *  @dev Sets the values for {name}, {symbol} and {decimals}.\\n     */\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_\\n    ) {\\n        name = name_;\\n        symbol = symbol_;\\n        decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() external view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address guy)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        return _balanceOf[guy];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        return _allowance[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     */\\n    function approve(address spender, uint256 wad)\\n        external\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return _setAllowance(msg.sender, spender, wad);\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have a balance of at least `wad`.\\n     */\\n    function transfer(address dst, uint256 wad)\\n        external\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return _transfer(msg.sender, dst, wad);\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `src` must have a balance of at least `wad`.\\n     * - the caller is not `src`, it must have allowance for ``src``'s tokens of at least\\n     * `wad`.\\n     */\\n    /// if_succeeds {:msg \\\"TransferFrom - decrease allowance\\\"} msg.sender != src ==> old(_allowance[src][msg.sender]) >= wad;\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 wad\\n    ) external virtual override returns (bool) {\\n        _decreaseAllowance(src, wad);\\n\\n        return _transfer(src, dst, wad);\\n    }\\n\\n    /**\\n     * @dev Moves tokens `wad` from `src` to `dst`.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `src` must have a balance of at least `amount`.\\n     */\\n    /// if_succeeds {:msg \\\"Transfer - src decrease\\\"} old(_balanceOf[src]) >= _balanceOf[src];\\n    /// if_succeeds {:msg \\\"Transfer - dst increase\\\"} _balanceOf[dst] >= old(_balanceOf[dst]);\\n    /// if_succeeds {:msg \\\"Transfer - supply\\\"} old(_balanceOf[src]) + old(_balanceOf[dst]) == _balanceOf[src] + _balanceOf[dst];\\n    function _transfer(\\n        address src,\\n        address dst,\\n        uint256 wad\\n    ) internal virtual returns (bool) {\\n        require(_balanceOf[src] >= wad, 'ERC20: Insufficient balance');\\n        unchecked {\\n            _balanceOf[src] = _balanceOf[src] - wad;\\n        }\\n        _balanceOf[dst] = _balanceOf[dst] + wad;\\n\\n        emit Transfer(src, dst, wad);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Sets the allowance granted to `spender` by `owner`.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     */\\n    function _setAllowance(\\n        address owner,\\n        address spender,\\n        uint256 wad\\n    ) internal virtual returns (bool) {\\n        _allowance[owner][spender] = wad;\\n        emit Approval(owner, spender, wad);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decreases the allowance granted to the caller by `src`, unless src == msg.sender or _allowance[src][msg.sender] == MAX\\n     *\\n     * Emits an {Approval} event indicating the updated allowance, if the allowance is updated.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` must have allowance for the caller of at least\\n     * `wad`, unless src == msg.sender\\n     */\\n    /// if_succeeds {:msg \\\"Decrease allowance - underflow\\\"} old(_allowance[src][msg.sender]) <= _allowance[src][msg.sender];\\n    function _decreaseAllowance(address src, uint256 wad)\\n        internal\\n        virtual\\n        returns (bool)\\n    {\\n        if (src != msg.sender) {\\n            uint256 allowed = _allowance[src][msg.sender];\\n            if (allowed != type(uint256).max) {\\n                require(allowed >= wad, 'ERC20: Insufficient approval');\\n                unchecked {\\n                    _setAllowance(src, msg.sender, allowed - wad);\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /** @dev Creates `wad` tokens and assigns them to `dst`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     */\\n    /// if_succeeds {:msg \\\"Mint - balance overflow\\\"} old(_balanceOf[dst]) >= _balanceOf[dst];\\n    /// if_succeeds {:msg \\\"Mint - supply overflow\\\"} old(_totalSupply) >= _totalSupply;\\n    function _mint(address dst, uint256 wad) internal virtual returns (bool) {\\n        _balanceOf[dst] = _balanceOf[dst] + wad;\\n        _totalSupply = _totalSupply + wad;\\n        emit Transfer(address(0), dst, wad);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Destroys `wad` tokens from `src`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `src` must have at least `wad` tokens.\\n     */\\n    /// if_succeeds {:msg \\\"Burn - balance underflow\\\"} old(_balanceOf[src]) <= _balanceOf[src];\\n    /// if_succeeds {:msg \\\"Burn - supply underflow\\\"} old(_totalSupply) <= _totalSupply;\\n    function _burn(address src, uint256 wad) internal virtual returns (bool) {\\n        unchecked {\\n            require(_balanceOf[src] >= wad, 'ERC20: Insufficient balance');\\n            _balanceOf[src] = _balanceOf[src] - wad;\\n            _totalSupply = _totalSupply - wad;\\n            emit Transfer(src, address(0), wad);\\n        }\\n\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tokens/ERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/contracts/token/ERC20/ERC20Permit.sol\\npragma solidity 0.8.16;\\n\\nimport 'src/tokens/ERC20.sol';\\nimport 'src/interfaces/IERC2612.sol';\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to use their tokens\\n * without sending any transactions by setting {IERC20-allowance} with a\\n * signature using the {permit} method, and then spend them via\\n * {IERC20-transferFrom}.\\n *\\n * The {permit} signature mechanism conforms to the {IERC2612} interface.\\n */\\nabstract contract ERC20Permit is ERC20, IERC2612 {\\n    mapping(address => uint256) public override nonces;\\n\\n    bytes32 public immutable PERMIT_TYPEHASH =\\n        keccak256(\\n            'Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)'\\n        );\\n    bytes32 private immutable _DOMAIN_SEPARATOR;\\n    uint256 public immutable deploymentChainId;\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_\\n    ) ERC20(name_, symbol_, decimals_) {\\n        deploymentChainId = block.chainid;\\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(block.chainid);\\n    }\\n\\n    /// @dev Calculate the DOMAIN_SEPARATOR.\\n    function _calculateDomainSeparator(uint256 chainId)\\n        private\\n        view\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\n                        'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\\n                    ),\\n                    keccak256(bytes(name)),\\n                    keccak256(bytes(version())),\\n                    chainId,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /// @dev Return the DOMAIN_SEPARATOR.\\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\\n        return\\n            block.chainid == deploymentChainId\\n                ? _DOMAIN_SEPARATOR\\n                : _calculateDomainSeparator(block.chainid);\\n    }\\n\\n    /// @dev Setting the version as a function so that it can be overriden\\n    function version() public pure virtual returns (string memory) {\\n        return '1';\\n    }\\n\\n    /**\\n     * @dev See {IERC2612-permit}.\\n     *\\n     * In cases where the free option is not a concern, deadline can simply be\\n     * set to uint(-1), so it should be seen as an optional parameter\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external virtual override {\\n        require(deadline >= block.timestamp, 'ERC20Permit: expired deadline');\\n\\n        bytes32 hashStruct = keccak256(\\n            abi.encode(\\n                PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                amount,\\n                nonces[owner]++,\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = keccak256(\\n            abi.encodePacked(\\n                '\\\\x19\\\\x01',\\n                block.chainid == deploymentChainId\\n                    ? _DOMAIN_SEPARATOR\\n                    : _calculateDomainSeparator(block.chainid),\\n                hashStruct\\n            )\\n        );\\n\\n        address signer = ecrecover(hash, v, r, s);\\n        require(\\n            signer != address(0) && signer == owner,\\n            'ERC20Permit: invalid signature'\\n        );\\n\\n        _setAllowance(owner, spender, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tokens/ERC5095.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport 'src/tokens/ERC20Permit.sol';\\nimport 'src/interfaces/IERC5095.sol';\\nimport 'src/interfaces/IRedeemer.sol';\\nimport 'src/interfaces/IMarketPlace.sol';\\nimport 'src/interfaces/IYield.sol';\\nimport 'src/errors/Exception.sol';\\n\\nimport 'src/lib/Cast.sol';\\nimport 'src/lib/Safe.sol';\\n\\ncontract ERC5095 is ERC20Permit, IERC5095 {\\n    /// @dev unix timestamp when the ERC5095 token can be redeemed\\n    uint256 public immutable override maturity;\\n    /// @dev address of the ERC20 token that is returned on ERC5095 redemption\\n    address public immutable override underlying;\\n    /// @dev address of the minting authority\\n    address public immutable lender;\\n    /// @dev address of the \\\"marketplace\\\" YieldSpace AMM router\\n    address public immutable marketplace;\\n    ///@dev Interface to interact with the pool\\n    address public pool;\\n\\n    /// @dev address and interface for an external custody contract (necessary for some project's backwards compatability)\\n    address public immutable redeemer;\\n\\n    /// @notice ensures that only a certain address can call the function\\n    /// @param a address that msg.sender must be to be authorized\\n    modifier authorized(address a) {\\n        if (msg.sender != a) {\\n            revert Exception(0, 0, 0, msg.sender, a);\\n        }\\n        _;\\n    }\\n\\n    constructor(\\n        address _underlying,\\n        uint256 _maturity,\\n        address _redeemer,\\n        address _lender,\\n        address _marketplace,\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_\\n    ) ERC20Permit(name_, symbol_, decimals_) {\\n        underlying = _underlying;\\n        maturity = _maturity;\\n        redeemer = _redeemer;\\n        lender = _lender;\\n        marketplace = _marketplace;\\n        pool = address(0);\\n    }\\n\\n    /// @notice Allows the marketplace to set the pool\\n    /// @param p Address of the pool\\n    /// @return bool True if successful\\n    function setPool(address p)\\n        external\\n        authorized(marketplace)\\n        returns (bool)\\n    {\\n        pool = p;\\n        return true;\\n    }\\n\\n    /// @notice Allows the marketplace to spend underlying, principal tokens held by the token\\n    /// @dev This is necessary when MarketPlace calls pool methods to swap tokens\\n    /// @return True if successful\\n    function approveMarketPlace()\\n        external\\n        authorized(marketplace)\\n        returns (bool)\\n    {\\n        // Approve the marketplace to spend the token's underlying\\n        Safe.approve(IERC20(underlying), marketplace, type(uint256).max);\\n\\n        // Approve the marketplace to spend illuminate PTs\\n        Safe.approve(IERC20(address(this)), marketplace, type(uint256).max);\\n\\n        return true;\\n    }\\n\\n    /// @notice Post or at maturity, converts an amount of principal tokens to an amount of underlying that would be returned.\\n    /// @param s The amount of principal tokens to convert\\n    /// @return uint256 The amount of underlying tokens returned by the conversion\\n    function convertToUnderlying(uint256 s)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        if (block.timestamp < maturity) {\\n            return previewRedeem(s);\\n        }\\n        return s;\\n    }\\n\\n    /// @notice Post or at maturity, converts a desired amount of underlying tokens returned to principal tokens needed.\\n    /// @param a The amount of underlying tokens to convert\\n    /// @return uint256 The amount of principal tokens returned by the conversion\\n    function convertToShares(uint256 a)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        if (block.timestamp < maturity) {\\n            return previewWithdraw(a);\\n        }\\n        return a;\\n    }\\n\\n    /// @notice Returns user's PT balance\\n    /// @param o The address of the owner for which redemption is calculated\\n    /// @return uint256 The maximum amount of principal tokens that `owner` can redeem.\\n    function maxRedeem(address o) external view override returns (uint256) {\\n        return _balanceOf[o];\\n    }\\n\\n    /// @notice Post or at maturity, returns user's PT balance. Prior to maturity, returns a previewRedeem for owner's PT balance.\\n    /// @param  o The address of the owner for which withdrawal is calculated\\n    /// @return uint256 maximum amount of underlying tokens that `owner` can withdraw.\\n    function maxWithdraw(address o) external view override returns (uint256) {\\n        if (block.timestamp < maturity) {\\n            return previewRedeem(_balanceOf[o]);\\n        }\\n        return _balanceOf[o];\\n    }\\n\\n    /// @notice After maturity, returns 0. Prior to maturity, returns the amount of `shares` when spending `a` in underlying on a YieldSpace AMM.\\n    /// @param a The amount of underlying spent\\n    /// @return uint256 The amount of PT purchased by spending `a` of underlying\\n    function previewDeposit(uint256 a) public view returns (uint256) {\\n        if (block.timestamp < maturity) {\\n            return IYield(pool).sellBasePreview(Cast.u128(a));\\n        }\\n        return 0;\\n    }\\n\\n    /// @notice After maturity, returns 0. Prior to maturity, returns the amount of `assets` in underlying spent on a purchase of `s` in PT on a YieldSpace AMM.\\n    /// @param s The amount of principal tokens bought in the simulation\\n    /// @return uint256 The amount of underlying required to purchase `s` of PT\\n    function previewMint(uint256 s) public view returns (uint256) {\\n        if (block.timestamp < maturity) {\\n            return IYield(pool).buyFYTokenPreview(Cast.u128(s));\\n        }\\n        return 0;\\n    }\\n\\n    /// @notice Post or at maturity, simulates the effects of redemption. Prior to maturity, returns the amount of `assets` from a sale of `s` PTs on a YieldSpace AMM.\\n    /// @param s The amount of principal tokens redeemed in the simulation\\n    /// @return uint256 The amount of underlying returned by `s` of PT redemption\\n    function previewRedeem(uint256 s) public view override returns (uint256) {\\n        if (block.timestamp >= maturity) {\\n            // After maturity, the amount redeemed is based on the Redeemer contract's holdings of the underlying\\n            return\\n                Cast.u128(\\n                    s *\\n                        Cast.u128(\\n                            IRedeemer(redeemer).holdings(underlying, maturity)\\n                        )\\n                ) / _totalSupply;\\n        }\\n\\n        // Prior to maturity, return a a preview of a swap on the pool\\n        return IYield(pool).sellFYTokenPreview(Cast.u128(s));\\n    }\\n\\n    /// @notice Post or at maturity, simulates the effects of withdrawal at the current block. Prior to maturity, simulates the amount of PTs necessary to receive `a` in underlying from the sale of PTs on a YieldSpace AMM.\\n    /// @param a The amount of underlying tokens withdrawn in the simulation\\n    /// @return uint256 The amount of principal tokens required for the withdrawal of `a`\\n    function previewWithdraw(uint256 a) public view override returns (uint256) {\\n        if (block.timestamp >= maturity) {\\n            // After maturity, the amount redeemed is based on the Redeemer contract's holdings of the underlying\\n            return\\n                (a * _totalSupply) /\\n                IRedeemer(redeemer).holdings(underlying, maturity);\\n        }\\n\\n        // Prior to maturity, return a a preview of a swap on the pool\\n        return IYield(pool).buyBasePreview(Cast.u128(a));\\n    }\\n\\n    /// @notice Before maturity spends `a` of underlying, and sends PTs to `r`. Post or at maturity, reverts.\\n    /// @param a The amount of underlying tokens deposited\\n    /// @param r The receiver of the principal tokens\\n    /// @param m Minimum number of shares that the user will receive\\n    /// @return uint256 The amount of principal tokens purchased\\n    function deposit(\\n        uint256 a,\\n        address r,\\n        uint256 m\\n    ) external returns (uint256) {\\n        // Execute the deposit\\n        return _deposit(r, a, m);\\n    }\\n\\n    /// @notice Before maturity spends `assets` of underlying, and sends `shares` of PTs to `receiver`. Post or at maturity, reverts.\\n    /// @param a The amount of underlying tokens deposited\\n    /// @param r The receiver of the principal tokens\\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\\n    function deposit(uint256 a, address r) external override returns (uint256) {\\n        // Execute the deposit\\n        return _deposit(r, a, 0);\\n    }\\n\\n    /// @notice Before maturity mints `s` of PTs to `r` by spending underlying. Post or at maturity, reverts.\\n    /// @param s The amount of shares being minted\\n    /// @param r The receiver of the underlying tokens being withdrawn\\n    /// @param m Maximum amount of underlying that the user will spend\\n    /// @return uint256 The amount of principal tokens purchased\\n    function mint(\\n        uint256 s,\\n        address r,\\n        uint256 m\\n    ) external returns (uint256) {\\n        // Execute the mint\\n        return _mint(r, s, m);\\n    }\\n\\n    /// @notice Before maturity mints `shares` of PTs to `receiver` by spending underlying. Post or at maturity, reverts.\\n    /// @param s The amount of shares being minted\\n    /// @param r The receiver of the underlying tokens being withdrawn\\n    /// @return uint256 The amount of principal tokens purchased\\n    function mint(uint256 s, address r) external override returns (uint256) {\\n        // Execute the mint\\n        return _mint(r, s, type(uint128).max);\\n    }\\n\\n    /// @notice At or after maturity, burns PTs from owner and sends `a` underlying to `r`. Before maturity, sends `a` by selling shares of PT on a YieldSpace AMM.\\n    /// @param a The amount of underlying tokens withdrawn\\n    /// @param r The receiver of the underlying tokens being withdrawn\\n    /// @param o The owner of the underlying tokens\\n    /// @param m Maximum amount of PTs to be sold\\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\\n    function withdraw(\\n        uint256 a,\\n        address r,\\n        address o,\\n        uint256 m\\n    ) external returns (uint256) {\\n        // Execute the withdrawal\\n        return _withdraw(a, r, o, m);\\n    }\\n\\n    /// @notice At or after maturity, burns PTs from owner and sends `a` underlying to `r`. Before maturity, sends `a` by selling shares of PT on a YieldSpace AMM.\\n    /// @param a The amount of underlying tokens withdrawn\\n    /// @param r The receiver of the underlying tokens being withdrawn\\n    /// @param o The owner of the underlying tokens\\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\\n    function withdraw(\\n        uint256 a,\\n        address r,\\n        address o\\n    ) external override returns (uint256) {\\n        // Execute the withdrawal\\n        return _withdraw(a, r, o, type(uint128).max);\\n    }\\n\\n    /// @notice At or after maturity, burns exactly `s` of Principal Tokens from `o` and sends underlying tokens to `r`. Before maturity, sends underlying by selling `s` of PT on a YieldSpace AMM.\\n    /// @param s The number of shares to be burned in exchange for the underlying asset\\n    /// @param r The receiver of the underlying tokens being withdrawn\\n    /// @param o Address of the owner of the shares being burned\\n    /// @param m Minimum amount of underlying that must be received\\n    /// @return uint256 The amount of underlying tokens distributed by the redemption\\n    function redeem(\\n        uint256 s,\\n        address r,\\n        address o,\\n        uint256 m\\n    ) external returns (uint256) {\\n        // Execute the redemption\\n        return _redeem(s, r, o, m);\\n    }\\n\\n    /// @notice At or after maturity, burns exactly `shares` of Principal Tokens from `owner` and sends `assets` of underlying tokens to `receiver`. Before maturity, sells `s` of PT on a YieldSpace AMM.\\n    /// @param s The number of shares to be burned in exchange for the underlying asset\\n    /// @param r The receiver of the underlying tokens being withdrawn\\n    /// @param o Address of the owner of the shares being burned\\n    /// @return uint256 The amount of underlying tokens distributed by the redemption\\n    function redeem(\\n        uint256 s,\\n        address r,\\n        address o\\n    ) external override returns (uint256) {\\n        // Execute the redemption\\n        return _redeem(s, r, o, 0);\\n    }\\n\\n    /// @param f Address to burn from\\n    /// @param a Amount to burn\\n    /// @return bool true if successful\\n    function authBurn(address f, uint256 a)\\n        external\\n        authorized(redeemer)\\n        returns (bool)\\n    {\\n        _burn(f, a);\\n        return true;\\n    }\\n\\n    /// @param t Address recieving the minted amount\\n    /// @param a The amount to mint\\n    /// @return bool True if successful\\n    function authMint(address t, uint256 a)\\n        external\\n        authorized(lender)\\n        returns (bool)\\n    {\\n        _mint(t, a);\\n        return true;\\n    }\\n\\n    /// @param o Address of the owner of the tokens\\n    /// @param s Address of the spender\\n    /// @param a Amount to be approved\\n    function authApprove(\\n        address o,\\n        address s,\\n        uint256 a\\n    ) external authorized(redeemer) returns (bool) {\\n        _allowance[o][s] = a;\\n        return true;\\n    }\\n\\n    function _deposit(\\n        address r,\\n        uint256 a,\\n        uint256 m\\n    ) internal returns (uint256) {\\n        // Revert if called at or after maturity\\n        if (block.timestamp >= maturity) {\\n            revert Exception(\\n                21,\\n                block.timestamp,\\n                maturity,\\n                address(0),\\n                address(0)\\n            );\\n        }\\n\\n        // Receive the funds from the sender\\n        Safe.transferFrom(IERC20(underlying), msg.sender, address(this), a);\\n\\n        // Sell the underlying assets for PTs\\n        uint128 returned = IMarketPlace(marketplace).sellUnderlying(\\n            underlying,\\n            maturity,\\n            Cast.u128(a),\\n            Cast.u128(m)\\n        );\\n\\n        // Pass the received shares onto the intended receiver\\n        _transfer(address(this), r, returned);\\n\\n        return returned;\\n    }\\n\\n    function _mint(\\n        address r,\\n        uint256 s,\\n        uint256 m\\n    ) internal returns (uint256) {\\n        // Revert if called at or after maturity\\n        if (block.timestamp >= maturity) {\\n            revert Exception(\\n                21,\\n                block.timestamp,\\n                maturity,\\n                address(0),\\n                address(0)\\n            );\\n        }\\n\\n        // Determine how many underlying tokens are needed to mint the shares\\n        uint256 required = IYield(pool).buyFYTokenPreview(Cast.u128(s));\\n\\n        // Transfer the underlying to the token\\n        Safe.transferFrom(\\n            IERC20(underlying),\\n            msg.sender,\\n            address(this),\\n            required\\n        );\\n\\n        // Swap the underlying for principal tokens via the pool\\n        uint128 sold = IMarketPlace(marketplace).buyPrincipalToken(\\n            underlying,\\n            maturity,\\n            Cast.u128(s),\\n            Cast.u128(m)\\n        );\\n\\n        // Transfer the principal tokens to the desired receiver\\n        _transfer(address(this), r, s);\\n\\n        return sold;\\n    }\\n\\n    function _withdraw(\\n        uint256 a,\\n        address r,\\n        address o,\\n        uint256 m\\n    ) internal returns (uint256) {\\n        // Determine how many principal tokens are needed to purchase the underlying\\n        uint256 needed = previewWithdraw(a);\\n\\n        // Pre maturity\\n        if (block.timestamp < maturity) {\\n            // Receive the shares from the caller\\n            _transfer(o, address(this), needed);\\n\\n            // If owner is the sender, sell PT without allowance check\\n            if (o == msg.sender) {\\n                uint128 returned = IMarketPlace(marketplace).buyUnderlying(\\n                    underlying,\\n                    maturity,\\n                    Cast.u128(a),\\n                    Cast.u128(m)\\n                );\\n\\n                // Transfer the underlying to the desired receiver\\n                Safe.transfer(IERC20(underlying), r, a);\\n\\n                return returned;\\n            } else {\\n                // Else, sell PT with allowance check\\n                // Get the allowance of the user spending the tokens\\n                uint256 allowance = _allowance[o][msg.sender];\\n\\n                // Check for sufficient allowance\\n                if (allowance < needed) {\\n                    revert Exception(20, allowance, a, address(0), address(0));\\n                }\\n\\n                // Update the caller's allowance\\n                _allowance[o][msg.sender] = allowance - needed;\\n\\n                // Sell the principal tokens for underlying\\n                uint128 returned = IMarketPlace(marketplace).buyUnderlying(\\n                    underlying,\\n                    maturity,\\n                    Cast.u128(a),\\n                    Cast.u128(m)\\n                );\\n\\n                // Transfer the underlying to the desired receiver\\n                Safe.transfer(IERC20(underlying), r, returned);\\n\\n                return returned;\\n            }\\n        }\\n        // Post maturity\\n        else {\\n            // If owner is the sender, redeem PT without allowance check\\n            if (o == msg.sender) {\\n                // Execute the redemption to the desired receiver\\n                return\\n                    IRedeemer(redeemer).authRedeem(\\n                        underlying,\\n                        maturity,\\n                        msg.sender,\\n                        r,\\n                        needed\\n                    );\\n            } else {\\n                // Get the allowance of the user spending the tokens\\n                uint256 allowance = _allowance[o][msg.sender];\\n\\n                // Check for sufficient allowance\\n                if (allowance < needed) {\\n                    revert Exception(\\n                        20,\\n                        allowance,\\n                        needed,\\n                        address(0),\\n                        address(0)\\n                    );\\n                }\\n\\n                // Update the callers's allowance\\n                _allowance[o][msg.sender] = allowance - needed;\\n\\n                // Execute the redemption to the desired receiver\\n                return\\n                    IRedeemer(redeemer).authRedeem(\\n                        underlying,\\n                        maturity,\\n                        o,\\n                        r,\\n                        needed\\n                    );\\n            }\\n        }\\n    }\\n\\n    function _redeem(\\n        uint256 s,\\n        address r,\\n        address o,\\n        uint256 m\\n    ) internal returns (uint256) {\\n        // Pre-maturity\\n        if (block.timestamp < maturity) {\\n            // Receive the funds from the user\\n            _transfer(o, address(this), s);\\n\\n            // If owner is the sender, sell PT without allowance check\\n            if (o == msg.sender) {\\n                // Swap principal tokens for the underlying asset\\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\\n                    underlying,\\n                    maturity,\\n                    Cast.u128(s),\\n                    Cast.u128(m)\\n                );\\n\\n                // Transfer underlying to the desired receiver\\n                Safe.transfer(IERC20(underlying), r, returned);\\n                return returned;\\n                // Else, sell PT with allowance check\\n            } else {\\n                // Get the allowance of the user spending the tokens\\n                uint256 allowance = _allowance[o][msg.sender];\\n\\n                // Check for sufficient allowance\\n                if (allowance < s) {\\n                    revert Exception(20, allowance, s, address(0), address(0));\\n                }\\n\\n                // Update the caller's allowance\\n                _allowance[o][msg.sender] = allowance - s;\\n\\n                // Sell the principal tokens for the underlying\\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\\n                    underlying,\\n                    maturity,\\n                    Cast.u128(s),\\n                    Cast.u128(m)\\n                );\\n\\n                // Transfer the underlying to the desired receiver\\n                Safe.transfer(IERC20(underlying), r, returned);\\n                return returned;\\n            }\\n            // Post-maturity\\n        } else {\\n            // If owner is the sender, redeem PT without allowance check\\n            if (o == msg.sender) {\\n                // Execute the redemption to the desired receiver\\n                return\\n                    IRedeemer(redeemer).authRedeem(\\n                        underlying,\\n                        maturity,\\n                        msg.sender,\\n                        r,\\n                        s\\n                    );\\n            } else {\\n                // Get the allowance of the user spending the tokens\\n                uint256 allowance = _allowance[o][msg.sender];\\n\\n                // Check for sufficient allowance\\n                if (allowance < s) {\\n                    revert Exception(20, allowance, s, address(0), address(0));\\n                }\\n\\n                // Update the caller's allowance\\n                _allowance[o][msg.sender] = allowance - s;\\n\\n                // Execute the redemption to the desired receiver\\n                return\\n                    IRedeemer(redeemer).authRedeem(\\n                        underlying,\\n                        maturity,\\n                        o,\\n                        r,\\n                        s\\n                    );\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"l\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"s\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Exception\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"PauseRedemptions\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"principal\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"ScheduleFeeChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"SetAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"converter\",\"type\":\"address\"}],\"name\":\"SetConverter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"SetFee\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"HOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_FEENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"i\",\"type\":\"address\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"f\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"authRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"f\",\"type\":\"address[]\"}],\"name\":\"autoRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"converter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"depositHoldings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"holdings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketPlace\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"pauseRedemptions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"protocol\",\"type\":\"uint8\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"periphery\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scheduleFeeChange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"c\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"i\",\"type\":\"address[]\"}],\"name\":\"setConverter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"f\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"l\",\"type\":\"address\"}],\"name\":\"setLender\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"m\",\"type\":\"address\"}],\"name\":\"setMarketPlace\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swivelAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tempusAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Redeemer", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000429b47c4aeadd42bbcb118651c8984086bfc4551000000000000000000000000373a06bd3067f8da90239a47f316f09312b7800f000000000000000000000000db5fd0678eed82246b599da6bc36b56157e4bed8", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}