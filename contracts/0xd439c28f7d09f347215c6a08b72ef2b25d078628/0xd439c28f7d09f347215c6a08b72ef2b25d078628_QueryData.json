{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/quote.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @title Pool state that never changes\\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\\n\\ninterface IUniswapV3PoolImmutables {\\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\\n    /// @return The contract address\\n    function factory() external view returns (address);\\n\\n    /// @notice The first of the two tokens of the pool, sorted by address\\n    /// @return The token contract address\\n    function token0() external view returns (address);\\n\\n    /// @notice The second of the two tokens of the pool, sorted by address\\n    /// @return The token contract address\\n    function token1() external view returns (address);\\n\\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\\n    /// @return The fee\\n    function fee() external view returns (uint24);\\n\\n    /// @notice The pool tick spacing\\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\\n    /// This value is an int24 to avoid casting even though it is always positive.\\n    /// @return The tick spacing\\n    function tickSpacing() external view returns (int24);\\n\\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\\n    /// @return The max amount of liquidity per tick\\n    function maxLiquidityPerTick() external view returns (uint128);\\n}\\n\\n/// @title Pool state that can change\\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\\n/// per transaction\\ninterface IUniswapV3PoolState {\\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\\n    /// when accessed externally.\\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\\n    /// boundary.\\n    /// observationIndex The index of the last oracle observation that was written,\\n    /// observationCardinality The current maximum number of observations stored in the pool,\\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\\n    /// feeProtocol The protocol fee for both tokens of the pool.\\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\\n    /// unlocked Whether the pool is currently locked to reentrancy\\n    function slot0()\\n        external\\n        view\\n        returns (\\n            uint160 sqrtPriceX96,\\n            int24 tick,\\n            uint16 observationIndex,\\n            uint16 observationCardinality,\\n            uint16 observationCardinalityNext,\\n            uint8 feeProtocol,\\n            bool unlocked\\n        );\\n\\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\\n    /// @dev This value can overflow the uint256\\n    function feeGrowthGlobal0X128() external view returns (uint256);\\n\\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\\n    /// @dev This value can overflow the uint256\\n    function feeGrowthGlobal1X128() external view returns (uint256);\\n\\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\\n    /// @dev Protocol fees will never exceed uint128 max in either token\\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\\n\\n    /// @notice The currently in range liquidity available to the pool\\n    /// @dev This value has no relationship to the total liquidity across all ticks\\n    function liquidity() external view returns (uint128);\\n\\n    /// @notice Look up information about a specific tick in the pool\\n    /// @param tick The tick to look up\\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\\n    /// tick upper,\\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\\n    /// a specific position.\\n    function ticks(int24 tick)\\n        external\\n        view\\n        returns (\\n            uint128 liquidityGross,\\n            int128 liquidityNet,\\n            uint256 feeGrowthOutside0X128,\\n            uint256 feeGrowthOutside1X128,\\n            int56 tickCumulativeOutside,\\n            uint160 secondsPerLiquidityOutsideX128,\\n            uint32 secondsOutside,\\n            bool initialized\\n        );\\n\\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\\n\\n    /// @notice Returns the information about a position by the position's key\\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\\n    /// @return _liquidity The amount of liquidity in the position,\\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\\n    function positions(bytes32 key)\\n        external\\n        view\\n        returns (\\n            uint128 _liquidity,\\n            uint256 feeGrowthInside0LastX128,\\n            uint256 feeGrowthInside1LastX128,\\n            uint128 tokensOwed0,\\n            uint128 tokensOwed1\\n        );\\n\\n    /// @notice Returns data about a specific observation index\\n    /// @param index The element of the observations array to fetch\\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\\n    /// ago, rather than at a specific index in the array.\\n    /// @return blockTimestamp The timestamp of the observation,\\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\\n    function observations(uint256 index)\\n        external\\n        view\\n        returns (\\n            uint32 blockTimestamp,\\n            int56 tickCumulative,\\n            uint160 secondsPerLiquidityCumulativeX128,\\n            bool initialized\\n        );\\n}\\n\\ninterface IZumiPool {\\n    function points(int24 tick) external view returns (uint256, int128, uint256, uint256, bool);\\n\\n    function pointDelta() external view returns (int24);\\n\\n    function orderOrEndpoint(int24 tick) external view returns (int24);\\n\\n    function limitOrderData(int24 point)\\n        external\\n        view\\n        returns (\\n            uint128 sellingX,\\n            uint128 earnY,\\n            uint256 accEarnY,\\n            uint256 legacyAccEarnY,\\n            uint128 legacyEarnY,\\n            uint128 sellingY,\\n            uint128 earnX,\\n            uint128 legacyEarnX,\\n            uint256 accEarnX,\\n            uint256 legacyAccEarnX\\n        );\\n\\n    function pointBitmap(int16 tick) external view returns (uint256);\\n\\n    function factory() external view returns (address);\\n}\\n\\ninterface IHorizonPool {\\n    function tickDistance() external view returns (int24);\\n\\n    function ticks(int24 tick)\\n        external\\n        view\\n        returns (\\n            uint128 liquidityGross,\\n            int128 liquidityNet,\\n            uint256 feeGrowthOutside,\\n            uint128 secondsPerLiquidityOutside\\n        );\\n\\n    function initializedTicks(int24 tick) external view returns (int24 previous, int24 next);\\n\\n    function getPoolState()\\n        external\\n        view\\n        returns (uint160 sqrtP, int24 currentTick, int24 nearestCurrentTick, bool locked);\\n}\\n\\n/// @title The interface for a Uniswap V3 Pool\\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\\n/// to the ERC20 specification\\n/// @dev The pool interface is broken up into many smaller pieces\\n\\ninterface IAlgebraPool {\\n    function globalState()\\n        external\\n        view\\n        returns (\\n            uint160 price,\\n            int24 tick,\\n            int24 prevInitializedTick,\\n            uint16 fee,\\n            uint16 timepointIndex,\\n            uint8 communityFee,\\n            bool unlocked\\n        );\\n\\n    function tickSpacing() external view returns (int24);\\n\\n    function ticks(int24 tick)\\n        external\\n        view\\n        returns (\\n            uint128 liquidityTotal,\\n            int128 liquidityDelta,\\n            uint256 outerFeeGrowth0Token,\\n            uint256 outerFeeGrowth1Token,\\n            int24 prevTick,\\n            int24 nextTick,\\n            uint160 outerSecondsPerLiquidity,\\n            uint32 outerSecondsSpent,\\n            bool hasLimitOrders\\n        );\\n\\n    function tickTable(int16 wordPosition) external view returns (uint256);\\n    function prevInitializedTick() external view returns (int24);\\n}\\n\\ninterface IAlgebraPoolV1_9 {\\n    function globalState()\\n        external\\n        view\\n        returns (\\n            uint160 price,\\n            int24 tick,\\n            int24 prevInitializedTick,\\n            uint16 fee,\\n            uint16 timepointIndex,\\n            uint8 communityFee,\\n            bool unlocked\\n        );\\n\\n    function tickSpacing() external view returns (int24);\\n    function ticks(int24 tick)\\n        external\\n        view\\n        returns (\\n            uint128 liquidityTotal,\\n            int128 liquidityDelta,\\n            uint256 outerFeeGrowth0Token,\\n            uint256 outerFeeGrowth1Token,\\n            int56 outerTickCumulative,\\n            uint160 outerSecondsPerLiquidity,\\n            uint32 outerSecondsSpent,\\n            bool initialized\\n        );\\n    function tickTable(int16 wordPosition) external view returns (uint256);\\n}\\n\\ninterface IUniswapV3Pool is IUniswapV3PoolImmutables, IUniswapV3PoolState {}\\n\\n/// @title DexNativeRouter\\n/// @notice Entrance of trading native token in web3-dex\\ncontract QueryData {\\n    int24 internal constant MIN_TICK_MINUS_1 = -887272 - 1;\\n    int24 internal constant MAX_TICK_PLUS_1 = 887272 + 1;\\n\\n    struct SuperVar {\\n        int24 tickSpacing;\\n        int24 currTick;\\n        int24 right;\\n        int24 left;\\n        int24 leftMost;\\n        int24 rightMost;\\n        uint256 initPoint;\\n        uint256 initPoint2;\\n    }\\n    /**\\n     * \u7b97\u6cd5\u903b\u8f91:\\n     * 1. \u67e5\u5230slot0\u5bf9\u5e94\u7684currTick\u548ctickSpacing\\n     * 2. \u6839\u636ecurrTick\u7b97\u51fa\u5f53\u524d\u7684word, \u5982\u679ccurrTick < 0, \u5219word--. \u539f\u56e0\u662f tick 1 \u548c tick -1\u5728\u9664\u4ee5256\u4e4b\u540e\u7684word\u90fd\u662f0, \u4e3a\u4e86\u533a\u522b, \u5c06tick -1 \u5b58\u653e\u5728 word=-1\u7684map\u4e0a\\n     * 3. \u67e5\u5230currTick\u5bf9\u5e94\u7684initPoint, \u5373currTick\u5728tickMap\u91cc\u9762\u7684index, index\u503c\u7684\u53d6\u503c\u8303\u56f4\u53ea\u80fd\u662f [0, 255], \u6240\u4ee5\u9700\u8981\u5bf9256 \u53d6\u6a21. \u5229\u7528\u7684\u662f currTick/tickSpacing = index + (currTick/tickSpacing//256 - 0 ? 1)* 256\\n     * 4. \u5206\u6210\u4e24\u4e2a\u65b9\u5411\u8fdb\u884c\u904d\u5386, \u7b2c\u4e00\u4e2a\u65b9\u5411\u4ece\u5c0f\u5230\u5927, \u7b2c\u4e8c\u4e2a\u65b9\u5411\u4ece\u5927\u5230\u5c0f\\n     * \u5047\u8bbetickMap\u67e5\u51fa\u6765\u7684\u7ed3\u679c\u5982\u4e0b: 10101010 (8bit \u65b9\u4fbf\u7406\u89e3), initPoint = 3, \u5373: 1010[1]010\\n     * 5. \u65b9\u5411\u4ece\u5c0f\u5230\u5927:\\n     * 5.1 \u9996\u5148\u628a\u7ed3\u679cres\u5411\u53f3\u79fb\u52a8initPoint\u4f4d,\u5f97\u5230\u65b0\u7684\u7ed3\u679c\u5982\u4e0b: 00010101. \u79fb\u52a8\u8fc7\u540e,\u5de6\u4fa7\u75280\u8865\u9f50\\n     * 5.2 \u53d6res\u4e2d\u7684\u6700\u53f3\u4fa7\u5143\u7d20\u4e0e0b00000001\u8fdb\u884c\u6bd4\u8f83, \u5982\u679c\u4e3atrue, \u6b64\u65f6\u6700\u53f3\u4fa7\u5143\u7d20\u7684index\u5373\u4e3a\u539f\u5148\u7684initPoint. \u5982\u679c\u4e3afalse, \u8bf4\u660e\u6ca1\u6709\u6d41\u52a8\u6027, \u5219\u8fdb\u884c\u4e0b\u4e00\u4e2a\u5faa\u73af\\n     * 5.3 \u7136\u540e\u6839\u636eindex \u548c right\u503c, \u91cd\u65b0\u5229\u7528\u516c\u5f0f (index + 256 * right) * tickSpacing = tick \u7b97\u51fatick\\n     * 5.4 \u6839\u636e\u7b97\u51fa\u7684tick\u62ff\u5230\u5bf9\u5e94\u7684delta L\u548c limitOrder\u7684\u6570\u636e\\n     * 5.5 \u5faa\u73af\u5f00\u59cb\u6761\u4ef6\u5373\u4e3a i = initPoint, \u5faa\u73af\u6b21\u6570\u5e94\u8be5\u4e3a: 256 - initPoint, \u5373\u5faa\u73af\u6761\u4ef6\u4e3a i < 256, \u65b9\u5411\u4e3a i++\\n     * 6. \u65b9\u5411\u4ece\u5927\u5230\u5c0f:\\n     * 6.1 \u9996\u5148\u628a\u7ed3\u679cres\u5411\u5de6\u79fb\u52a8256-initPoint\u4f4d, \u5f97\u5230\u65b0\u7684\u7ed3\u679c\u5982\u4e0b: 01000000, \u79fb\u52a8\u8fc7\u540e, \u53f3\u4fa7\u75280\u8865\u9f50\\n     * 6.2 \u53bbres\u4e2d\u7684\u6700\u5de6\u4fa7\u5143\u7d20\u4e0e0b10000000\u8fdb\u884c\u6bd4\u8f83, \u5982\u679c\u4e3atrue, \u8bf4\u660e\u6709\u6d41\u52a8\u6027. \u6ce8\u610f\u6b64\u65f6\u7684index\u4e3a\u539f\u5148\u7684initPoint - 1, \u800c\u4e0d\u662finitPoint. \u5982\u679c\u4e3afalse, \u8bf4\u660e\u6ca1\u6709\u6d41\u52a8\u6027, \u5219\u8fdb\u884c\u4e0b\u4e00\u4e2a\u5faa\u73af\\n     * 6.3 \u7136\u540e\u6839\u636eindex \u548c left, \u91cd\u65b0\u5229\u7528\u516c\u5f0f (index + 256 * left) * tickSpacing = tick \u7b97\u51fatick\\n     * 6.4 \u6839\u636e\u7b97\u51fa\u7684tick\u62ff\u5230\u5bf9\u5e94\u7684delta L\u548c limitOrder\u7684\u6570\u636e\\n     * 6.5 \u5faa\u73af\u7684\u5f00\u59cb\u6761\u4ef6\u5373\u4e3a i = initPoint - 1, \u5faa\u73af\u6b21\u6570\u4e3a: initPoint\u6b21, \u5373\u5faa\u73af\u6761\u4ef6\u4e3a i >= 0, \u65b9\u5411\u4e3a i--\\n     *\\n     * \u95ee\u9898\u662f:\\n     * initPoint = 0\u65f6, \u65b9\u5411\u4ece\u5927\u5230\u5c0f\u5e94\u8be5\u600e\u4e48\u5904\u7406? \u6b64\u65f6\u5e94\u8be5\u8fdb\u5165\u4e0b\u4e00\u4e2a\u5faa\u73af.\\n     */\\n\\n    function queryUniv3TicksSuperCompact(address pool, uint256 len) public view returns (bytes memory) {\\n        SuperVar memory tmp;\\n        tmp.tickSpacing = IUniswapV3Pool(pool).tickSpacing();\\n        // fix-bug: pancake pool's slot returns different types of params than uniV3, which will cause problem\\n        {\\n            (, bytes memory slot0) = pool.staticcall(abi.encodeWithSignature(\\\"slot0()\\\"));\\n            int24 currTick;\\n            assembly {\\n                currTick := mload(add(slot0, 64))\\n            }\\n            tmp.currTick = currTick;\\n        }\\n\\n        tmp.right = tmp.currTick / tmp.tickSpacing / int24(256);\\n        tmp.leftMost = -887272 / tmp.tickSpacing / int24(256) - 2;\\n        tmp.rightMost = 887272 / tmp.tickSpacing / int24(256) + 1;\\n\\n        if (tmp.currTick < 0) {\\n            tmp.initPoint = uint256(\\n                int256(tmp.currTick) / int256(tmp.tickSpacing)\\n                    - (int256(tmp.currTick) / int256(tmp.tickSpacing) / 256 - 1) * 256\\n            ) % 256;\\n        } else {\\n            tmp.initPoint = (uint256(int256(tmp.currTick)) / uint256(int256(tmp.tickSpacing))) % 256;\\n        }\\n        tmp.initPoint2 = tmp.initPoint;\\n\\n        if (tmp.currTick < 0) tmp.right--;\\n\\n        bytes memory tickInfo;\\n\\n        tmp.left = tmp.right;\\n\\n        uint256 index = 0;\\n\\n        while (index < len / 2 && tmp.right < tmp.rightMost) {\\n            uint256 res = IUniswapV3Pool(pool).tickBitmap(int16(tmp.right));\\n            if (res > 0) {\\n                res = res >> tmp.initPoint;\\n                for (uint256 i = tmp.initPoint; i < 256 && index < len / 2; i++) {\\n                    uint256 isInit = res & 0x01;\\n                    if (isInit > 0) {\\n                        int256 tick = int256((256 * tmp.right + int256(i)) * tmp.tickSpacing);\\n                        (, int128 liquidityNet,,,,,,) = IUniswapV3Pool(pool).ticks(int24(int256(tick)));\\n\\n                        int256 data = int256(uint256(int256(tick)) << 128)\\n                            + (int256(liquidityNet) & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff);\\n                        tickInfo = bytes.concat(tickInfo, bytes32(uint256(data)));\\n\\n                        index++;\\n                    }\\n\\n                    res = res >> 1;\\n                }\\n            }\\n            tmp.initPoint = 0;\\n            tmp.right++;\\n        }\\n        bool isInitPoint = true;\\n        while (index < len && tmp.left > tmp.leftMost) {\\n            uint256 res = IUniswapV3Pool(pool).tickBitmap(int16(tmp.left));\\n            if (res > 0 && tmp.initPoint2 != 0) {\\n                res = isInitPoint ? res << ((256 - tmp.initPoint2) % 256) : res;\\n                for (uint256 i = tmp.initPoint2 - 1; i >= 0 && index < len; i--) {\\n                    uint256 isInit = res & 0x8000000000000000000000000000000000000000000000000000000000000000;\\n                    if (isInit > 0) {\\n                        int256 tick = int256((256 * tmp.left + int256(i)) * tmp.tickSpacing);\\n                        (, int128 liquidityNet,,,,,,) = IUniswapV3Pool(pool).ticks(int24(int256(tick)));\\n\\n                        int256 data = int256(uint256(int256(tick)) << 128)\\n                            + (int256(liquidityNet) & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff);\\n                        tickInfo = bytes.concat(tickInfo, bytes32(uint256(data)));\\n\\n                        index++;\\n                    }\\n\\n                    res = res << 1;\\n                    if (i == 0) break;\\n                }\\n            }\\n            isInitPoint = false;\\n            tmp.initPoint2 = 256;\\n\\n            tmp.left--;\\n        }\\n        return tickInfo;\\n    }\\n\\n    function queryAlgebraTicksSuperCompact(address pool, uint256 len) public view returns (bytes memory) {\\n        SuperVar memory tmp;\\n\\n        (, tmp.currTick,,,,,) = IAlgebraPoolV1_9(pool).globalState();\\n        tmp.right = tmp.currTick / int24(256);\\n        tmp.leftMost = -887272 / int24(256) - 2;\\n        tmp.rightMost = 887272 / int24(256) + 1;\\n\\n        if (tmp.currTick < 0) {\\n            tmp.initPoint = (256 - (uint256(int256(-tmp.currTick)) % 256)) % 256;\\n        } else {\\n            tmp.initPoint = uint256(int256(tmp.currTick)) % 256;\\n        }\\n        tmp.initPoint2 = tmp.initPoint;\\n\\n        if (tmp.currTick < 0) tmp.right--;\\n\\n        bytes memory tickInfo;\\n\\n        tmp.left = tmp.right;\\n\\n        uint256 index = 0;\\n\\n        while (index < len / 2 && tmp.right < tmp.rightMost) {\\n            uint256 res = IAlgebraPoolV1_9(pool).tickTable(int16(tmp.right));\\n            if (res > 0) {\\n                res = res >> tmp.initPoint;\\n                for (uint256 i = tmp.initPoint; i < 256 && index < len / 2; i++) {\\n                    uint256 isInit = res & 0x01;\\n                    if (isInit > 0) {\\n                        int256 tick = int256((256 * tmp.right + int256(i)));\\n                        (, int128 liquidityNet,,,,,,) = IAlgebraPoolV1_9(pool).ticks(int24(int256(tick)));\\n\\n                        int256 data = int256(uint256(int256(tick)) << 128)\\n                            + (int256(liquidityNet) & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff);\\n                        tickInfo = bytes.concat(tickInfo, bytes32(uint256(data)));\\n\\n                        index++;\\n                    }\\n\\n                    res = res >> 1;\\n                }\\n            }\\n            tmp.initPoint = 0;\\n            tmp.right++;\\n        }\\n        bool isInitPoint = true;\\n        while (index < len && tmp.left > tmp.leftMost) {\\n            uint256 res = IAlgebraPoolV1_9(pool).tickTable(int16(tmp.left));\\n            if (res > 0 && tmp.initPoint2 != 0) {\\n                res = isInitPoint ? res << ((256 - tmp.initPoint2) % 256) : res;\\n\\n                for (uint256 i = tmp.initPoint2 - 1; i >= 0 && index < len; i--) {\\n                    uint256 isInit = res & 0x8000000000000000000000000000000000000000000000000000000000000000;\\n                    if (isInit > 0) {\\n                        int256 tick = int256((256 * tmp.left + int256(i)));\\n                        (, int128 liquidityNet,,,,,,) = IAlgebraPoolV1_9(pool).ticks(int24(int256(tick)));\\n\\n                        int256 data = int256(uint256(int256(tick)) << 128)\\n                            + (int256(liquidityNet) & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff);\\n                        tickInfo = bytes.concat(tickInfo, bytes32(uint256(data)));\\n\\n                        index++;\\n                    }\\n\\n                    res = res << 1;\\n                    if (i == 0) break;\\n                }\\n            }\\n            isInitPoint = false;\\n            tmp.initPoint2 = 256;\\n\\n            tmp.left--;\\n        }\\n        return tickInfo;\\n    }\\n\\n    function queryHorizonTicksSuperCompact(address pool, uint256 iteration) public view returns (bytes memory) {\\n        (,, int24 currTick,) = IHorizonPool(pool).getPoolState();\\n        int24 currTick2 = currTick;\\n        uint256 threshold = iteration / 2;\\n\\n        // travel from left to right\\n        bytes memory tickInfo;\\n\\n        while (currTick < MAX_TICK_PLUS_1 && iteration > threshold) {\\n            (, int128 liquidityNet,,) = IHorizonPool(pool).ticks(currTick);\\n\\n            int256 data = int256(uint256(int256(currTick)) << 128)\\n                + (int256(liquidityNet) & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff);\\n            tickInfo = bytes.concat(tickInfo, bytes32(uint256(data)));\\n            (, int24 nextTick) = IHorizonPool(pool).initializedTicks(currTick);\\n            if (currTick == nextTick) {\\n                break;\\n            }\\n            currTick = nextTick;\\n            iteration--;\\n        }\\n\\n        while (currTick2 > MIN_TICK_MINUS_1 && iteration > 0) {\\n            (, int128 liquidityNet,,) = IHorizonPool(pool).ticks(currTick2);\\n            int256 data = int256(uint256(int256(currTick2)) << 128)\\n                + (int256(liquidityNet) & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff);\\n            tickInfo = bytes.concat(tickInfo, bytes32(uint256(data)));\\n            (int24 prevTick,) = IHorizonPool(pool).initializedTicks(currTick2);\\n            if (prevTick == currTick2) {\\n                break;\\n            }\\n            currTick2 = prevTick;\\n            iteration--;\\n        }\\n\\n        return tickInfo;\\n    }\\n\\n    function queryAlgebraTicksSuperCompact2(address pool, uint256 iteration) public view returns (bytes memory) {\\n        int24 currTick;\\n        {\\n            (bool s, bytes memory res) = pool.staticcall(abi.encodeWithSignature(\\\"prevInitializedTick()\\\"));\\n            if (s) {\\n                currTick = abi.decode(res, (int24));\\n            } else {\\n                (s, res) = pool.staticcall(abi.encodeWithSignature(\\\"globalState()\\\"));\\n                if (s) {\\n                    assembly {\\n                        currTick := mload(add(res, 96))\\n                    }\\n                }\\n            }\\n        }\\n\\n        int24 currTick2 = currTick;\\n        uint256 threshold = iteration / 2;\\n        // travel from left to right\\n        bytes memory tickInfo;\\n\\n        while (currTick < MAX_TICK_PLUS_1 && iteration > threshold) {\\n            (, int128 liquidityNet,,, int24 prevTick, int24 nextTick,,,) = IAlgebraPool(pool).ticks(currTick);\\n\\n            int256 data = int256(uint256(int256(currTick)) << 128)\\n                + (int256(liquidityNet) & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff);\\n            tickInfo = bytes.concat(tickInfo, bytes32(uint256(data)));\\n\\n            if (currTick == nextTick) {\\n                break;\\n            }\\n            currTick = nextTick;\\n            iteration--;\\n        }\\n\\n        while (currTick2 > MIN_TICK_MINUS_1 && iteration > 0) {\\n            (, int128 liquidityNet,,, int24 prevTick, int24 nextTick,,,) = IAlgebraPool(pool).ticks(currTick2);\\n\\n            int256 data = int256(uint256(int256(currTick2)) << 128)\\n                + (int256(liquidityNet) & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff);\\n            tickInfo = bytes.concat(tickInfo, bytes32(uint256(data)));\\n\\n            if (currTick2 == prevTick) {\\n                break;\\n            }\\n            currTick2 = prevTick;\\n            iteration--;\\n        }\\n\\n        return tickInfo;\\n    }\\n\\n    function queryIzumiSuperCompact(address pool, uint256 len) public view returns (bytes memory, bytes memory) {\\n        SuperVar memory tmp;\\n        tmp.tickSpacing = IZumiPool(pool).pointDelta();\\n        {\\n            (, bytes memory slot0) = pool.staticcall(abi.encodeWithSignature(\\\"state()\\\"));\\n            int24 currTick;\\n            assembly {\\n                currTick := mload(add(slot0, 64))\\n            }\\n            tmp.currTick = currTick;\\n        }\\n\\n        tmp.right = tmp.currTick / tmp.tickSpacing / int24(256);\\n        tmp.leftMost = -887272 / tmp.tickSpacing / int24(256) - 2;\\n        tmp.rightMost = 887272 / tmp.tickSpacing / int24(256) + 1;\\n\\n        if (tmp.currTick < 0) {\\n            tmp.initPoint = uint256(\\n                int256(tmp.currTick) / int256(tmp.tickSpacing)\\n                    - (int256(tmp.currTick) / int256(tmp.tickSpacing) / 256 - 1) * 256\\n            ) % 256;\\n        } else {\\n            tmp.initPoint = (uint256(int256(tmp.currTick)) / uint256(int256(tmp.tickSpacing))) % 256;\\n        }\\n        tmp.initPoint2 = tmp.initPoint;\\n\\n        if (tmp.currTick < 0) tmp.right--;\\n\\n        bytes memory tickInfo;\\n        bytes memory limitOrderInfo;\\n\\n        tmp.left = tmp.right;\\n\\n        uint256 index = 0;\\n\\n        while (index < len / 2 && tmp.right < tmp.rightMost) {\\n            uint256 res = IZumiPool(pool).pointBitmap(int16(tmp.right));\\n            if (res > 0) {\\n                res = res >> tmp.initPoint;\\n                for (uint256 i = tmp.initPoint; i < 256; i++) {\\n                    uint256 isInit = res & 0x01;\\n                    if (isInit > 0) {\\n                        int24 tick = int24(int256((256 * tmp.right + int256(i)) * tmp.tickSpacing));\\n                        int24 orderOrEndpoint = IZumiPool(pool).orderOrEndpoint(tick / tmp.tickSpacing);\\n                        if (orderOrEndpoint & 0x01 == 0x01) {\\n                            (, int128 liquidityNet,,,) = IZumiPool(pool).points(tick);\\n                            if (liquidityNet != 0) {\\n                                int256 data = int256(uint256(int256(tick)) << 128)\\n                                    + (\\n                                        int256(liquidityNet)\\n                                            & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff\\n                                    );\\n                                tickInfo = bytes.concat(tickInfo, bytes32(uint256(data)));\\n\\n                                index++;\\n                            }\\n                        }\\n                        if (orderOrEndpoint & 0x02 == 0x02) {\\n                            (uint128 sellingX,,,,, uint128 sellingY,,,,) = IZumiPool(pool).limitOrderData(tick);\\n                            if (sellingX != 0 || sellingY != 0) {\\n                                bytes32 data =\\n                                    bytes32(abi.encodePacked(int32(tick), uint112(sellingX), uint112(sellingY)));\\n                                limitOrderInfo = bytes.concat(limitOrderInfo, data);\\n\\n                                index++;\\n                            }\\n                        }\\n                    }\\n\\n                    res = res >> 1;\\n                }\\n            }\\n            tmp.initPoint = 0;\\n            tmp.right++;\\n        }\\n        bool isInitPoint = true;\\n        while (index < len && tmp.left > tmp.leftMost) {\\n            uint256 res = IZumiPool(pool).pointBitmap(int16(tmp.left));\\n            if (res > 0 && tmp.initPoint2 != 0) {\\n                res = isInitPoint ? res << ((256 - tmp.initPoint2) % 256) : res;\\n                for (uint256 i = tmp.initPoint2 - 1; i >= 0 && index < len; i--) {\\n                    uint256 isInit = res & 0x8000000000000000000000000000000000000000000000000000000000000000;\\n                    if (isInit > 0) {\\n                        int24 tick = int24(int256((256 * tmp.left + int256(i)) * tmp.tickSpacing));\\n\\n                        int24 orderOrEndpoint = IZumiPool(pool).orderOrEndpoint(tick / tmp.tickSpacing);\\n                        if (orderOrEndpoint & 0x01 == 0x01) {\\n                            (, int128 liquidityNet,,,) = IZumiPool(pool).points(tick);\\n                            if (liquidityNet != 0) {\\n                                int256 data = int256(uint256(int256(tick)) << 128)\\n                                    + (\\n                                        int256(liquidityNet)\\n                                            & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff\\n                                    );\\n                                tickInfo = bytes.concat(tickInfo, bytes32(uint256(data)));\\n\\n                                index++;\\n                            }\\n                        }\\n                        if (orderOrEndpoint & 0x02 == 0x02) {\\n                            (uint128 sellingX,,,,, uint128 sellingY,,,,) = IZumiPool(pool).limitOrderData(tick);\\n                            if (sellingX != 0 || sellingY != 0) {\\n                                bytes32 data =\\n                                    bytes32(abi.encodePacked(int32(tick), uint112(sellingX), uint112(sellingY)));\\n                                limitOrderInfo = bytes.concat(limitOrderInfo, data);\\n\\n                                index++;\\n                            }\\n                        }\\n                    }\\n                    res = res << 1;\\n                    if (i == 0) break;\\n                }\\n            }\\n            isInitPoint = false;\\n            tmp.initPoint2 = 256;\\n\\n            tmp.left--;\\n        }\\n        return (tickInfo, limitOrderInfo);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@horizon/contracts/=lib/contracts/\",\r\n      \"@Algebra/contracts/=lib/Algebra/src/core/contracts/\",\r\n      \"@izumi/contracts/=lib/iZiSwap-core/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"@UniswapV3/core/contracts/=lib/v3-core/contracts/\",\r\n      \"Algebra/=lib/Algebra/src/\",\r\n      \"iZiSwap-core/=lib/iZiSwap-core/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"v3-core/=lib/v3-core/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"len\",\"type\":\"uint256\"}],\"name\":\"queryAlgebraTicksSuperCompact\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"iteration\",\"type\":\"uint256\"}],\"name\":\"queryAlgebraTicksSuperCompact2\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"iteration\",\"type\":\"uint256\"}],\"name\":\"queryHorizonTicksSuperCompact\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"len\",\"type\":\"uint256\"}],\"name\":\"queryIzumiSuperCompact\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"len\",\"type\":\"uint256\"}],\"name\":\"queryUniv3TicksSuperCompact\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "QueryData", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}