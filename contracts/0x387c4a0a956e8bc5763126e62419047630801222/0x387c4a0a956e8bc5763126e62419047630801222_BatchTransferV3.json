{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    function transferFrom(address from, address to, uint value) external ;\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n}\r\n\r\n\r\ncontract BatchTransferV3 {\r\n\r\n    mapping (address => bool) _isOperator;\r\n\r\n    event NewOperator(address oldOperator, address newOperator);\r\n\r\n    modifier onlyOperator() {\r\n        require(_isOperator[msg.sender], \"Only Operator Can Do This.\");\r\n        _;\r\n    }\r\n    \r\n    constructor(address[] memory operators) {\r\n        for (uint256 i = 0; i < operators.length; i++) {\r\n            _isOperator[operators[i]] = true;\r\n        }\r\n    }\r\n    \r\n    function isOperator(address testAddress) public view returns (bool) {\r\n        return _isOperator[testAddress];\r\n    }\r\n    \r\n    function changeOperator(address newOperator) external onlyOperator {\r\n        require(!_isOperator[newOperator], \"Already Is Operator.\");\r\n        _isOperator[msg.sender] = false;\r\n        _isOperator[newOperator] = true;\r\n        emit NewOperator(msg.sender, newOperator);\r\n    }\r\n\r\n    function multiOwnersTransfer(\r\n        address[] calldata owners,\r\n        address contractAddress,\r\n        address receiver,\r\n        uint256[] calldata amounts,\r\n        bytes[] calldata signatures\r\n    ) external onlyOperator {\r\n        require(owners.length <= 20, \"Too many owners.\");\r\n        require(owners.length == amounts.length, \"Parameter length wrong.\");\r\n        require(owners.length == signatures.length, \"Parameter length wrong.\");\r\n        for (uint256 i = 0; i < owners.length; i++) {\r\n            require(verifySig(receiver, signatures[i], owners[i]), \"Signature Wrong.\");\r\n            IERC20 token = IERC20(contractAddress);\r\n            require(token.balanceOf(owners[i]) >= amounts[i], \"Not Enough Balance.\");\r\n            require(token.allowance(owners[i], address(this)) >= amounts[i], \"Not Enough Permit.\");\r\n            token.transferFrom(owners[i], receiver, amounts[i]);\r\n        }\r\n    }\r\n\r\n    function getMessageHash(address receiver) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(receiver));\r\n    }\r\n\r\n    function getEthSignedMessageHash(bytes32 hashMessage) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hashMessage));\r\n    }\r\n\r\n    function verifySig(address receiver, bytes memory signature, address signer) internal pure returns (bool) {\r\n        bytes32 messageHash = getMessageHash(receiver);\r\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\r\n        return recoverSigner(ethSignedMessageHash, signature) == signer;\r\n    }\r\n\r\n    function getSigAddress(address receiver, bytes memory signature) internal pure returns (address) {\r\n        bytes32 messageHash = getMessageHash(receiver);\r\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\r\n        return recoverSigner(ethSignedMessageHash, signature);\r\n    }\r\n    \r\n    function recoverSigner(\r\n        bytes32 ethSignedMessageHash,\r\n        bytes memory signature\r\n    ) internal pure returns (address) {\r\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);\r\n        return ecrecover(ethSignedMessageHash, v, r, s);\r\n    }\r\n\r\n    function splitSignature(\r\n        bytes memory sig\r\n    ) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\r\n        require(sig.length == 65, \"Invalid Signature Length.\");\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n    }\r\n\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"operators\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"NewOperator\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"changeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"testAddress\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"}],\"name\":\"multiOwnersTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BatchTransferV3", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000200000000000000000000000077a3f9205a0b47be45379c9c9968867379be15610000000000000000000000009e2cfd785771af9780d9df1bcf5fe4cee7e54ae0", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://75d48bb66247cd911fc8b769f4ffc9b99991040e19dc094dfe511ea4944f5969"}