{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IAny2EVMMessageReceiver} from \\\"../interfaces/IAny2EVMMessageReceiver.sol\\\";\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\n\\nimport {IERC165} from \\\"../../vendor/openzeppelin-solidity/v4.8.0/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\\n  address internal immutable i_router;\\n\\n  constructor(address router) {\\n    if (router == address(0)) revert InvalidRouter(address(0));\\n    i_router = router;\\n  }\\n\\n  /// @notice IERC165 supports an interfaceId\\n  /// @param interfaceId The interfaceId to check\\n  /// @return true if the interfaceId is supported\\n  /// @dev Should indicate whether the contract implements IAny2EVMMessageReceiver\\n  /// e.g. return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId\\n  /// This allows CCIP to check if ccipReceive is available before calling it.\\n  /// If this returns false or reverts, only tokens are transferred to the receiver.\\n  /// If this returns true, tokens are transferred and ccipReceive is called atomically.\\n  /// Additionally, if the receiver address does not have code associated with\\n  /// it at the time of execution (EXTCODESIZE returns 0), only tokens will be transferred.\\n  function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\\n    return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\\n  }\\n\\n  /// @inheritdoc IAny2EVMMessageReceiver\\n  function ccipReceive(Client.Any2EVMMessage calldata message) external virtual override onlyRouter {\\n    _ccipReceive(message);\\n  }\\n\\n  /// @notice Override this function in your implementation.\\n  /// @param message Any2EVMMessage\\n  function _ccipReceive(Client.Any2EVMMessage memory message) internal virtual;\\n\\n  /////////////////////////////////////////////////////////////////////\\n  // Plumbing\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Return the current router\\n  /// @return i_router address\\n  function getRouter() public view returns (address) {\\n    return address(i_router);\\n  }\\n\\n  error InvalidRouter(address router);\\n\\n  /// @dev only calls from the set router are accepted.\\n  modifier onlyRouter() {\\n    if (msg.sender != address(i_router)) revert InvalidRouter(msg.sender);\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\n\\n/// @notice Application contracts that intend to receive messages from\\n/// the router should implement this interface.\\ninterface IAny2EVMMessageReceiver {\\n  /// @notice Called by the Router to deliver a message.\\n  /// If this reverts, any token transfers also revert. The message\\n  /// will move to a FAILED state and become available for manual execution.\\n  /// @param message CCIP Message\\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter\\n  function ccipReceive(Client.Any2EVMMessage calldata message) external;\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\n\\ninterface IRouterClient {\\n  error UnsupportedDestinationChain(uint64 destChainSelector);\\n  error InsufficientFeeTokenAmount();\\n  error InvalidMsgValue();\\n\\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\\n  /// @param chainSelector The chain to check.\\n  /// @return supported is true if it is supported, false if not.\\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\\n\\n  /// @notice Gets a list of all supported tokens which can be sent or received\\n  /// to/from a given chain id.\\n  /// @param chainSelector The chainSelector.\\n  /// @return tokens The addresses of all tokens that are supported.\\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\\n\\n  /// @param destinationChainSelector The destination chainSelector\\n  /// @param message The cross-chain CCIP message including data and/or tokens\\n  /// @return fee returns execution fee for the message\\n  /// delivery to destination chain, denominated in the feeToken specified in the message.\\n  /// @dev Reverts with appropriate reason upon invalid message.\\n  function getFee(\\n    uint64 destinationChainSelector,\\n    Client.EVM2AnyMessage memory message\\n  ) external view returns (uint256 fee);\\n\\n  /// @notice Request a message to be sent to the destination chain\\n  /// @param destinationChainSelector The destination chain ID\\n  /// @param message The cross-chain CCIP message including data and/or tokens\\n  /// @return messageId The message ID\\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\\n  /// the overpayment with no refund.\\n  /// @dev Reverts with appropriate reason upon invalid message.\\n  function ccipSend(\\n    uint64 destinationChainSelector,\\n    Client.EVM2AnyMessage calldata message\\n  ) external payable returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// End consumer library.\\nlibrary Client {\\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\\n  struct EVMTokenAmount {\\n    address token; // token address on the local chain.\\n    uint256 amount; // Amount of tokens.\\n  }\\n\\n  struct Any2EVMMessage {\\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\\n    uint64 sourceChainSelector; // Source chain selector.\\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\\n    bytes data; // payload sent in original message.\\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\\n  }\\n\\n  // If extraArgs is empty bytes, the default is 200k gas limit.\\n  struct EVM2AnyMessage {\\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\\n    bytes data; // Data payload\\n    EVMTokenAmount[] tokenAmounts; // Token transfers\\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\\n  }\\n\\n  // bytes4(keccak256(\\\"CCIP EVMExtraArgsV1\\\"));\\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\\n  struct EVMExtraArgsV1 {\\n    uint256 gasLimit;\\n  }\\n\\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts-ccip/src/v0.8/shared/access/ConfirmedOwnerWithProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IOwnable.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwnerWithProposal is IOwnable {\\n  address private s_owner;\\n  address private s_pendingOwner;\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    require(newOwner != address(0), \\\"Cannot set owner to zero\\\");\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows an owner to begin transferring ownership to a new address,\\n   * pending.\\n   */\\n  function transferOwnership(address to) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /**\\n   * @notice Allows an ownership transfer to be completed by the recipient.\\n   */\\n  function acceptOwnership() external override {\\n    require(msg.sender == s_pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Get the current owner\\n   */\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /**\\n   * @notice validate, transfer ownership, and emit relevant events\\n   */\\n  function _transferOwnership(address to) private {\\n    require(to != msg.sender, \\\"Cannot transfer to self\\\");\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /**\\n   * @notice validate access\\n   */\\n  function _validateOwnership() internal view {\\n    require(msg.sender == s_owner, \\\"Only callable by owner\\\");\\n  }\\n\\n  /**\\n   * @notice Reverts if called by anyone other than the contract owner.\\n   */\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts-ccip/src/v0.8/shared/interfaces/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IOwnable {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(address recipient) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.0/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `to`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address to, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `from` to `to` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.0/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\"\r\n    },\r\n    \"contracts/AmoTokenBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\n// External Dependencies\\nimport {IRouterClient} from \\\"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\\\";\\nimport {ConfirmedOwnerWithProposal} from \\\"@chainlink/contracts-ccip/src/v0.8/shared/access/ConfirmedOwnerWithProposal.sol\\\";\\nimport {Client} from \\\"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\\\";\\nimport {CCIPReceiver} from \\\"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\\\";\\nimport {IERC20} from \\\"@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.0/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * AMO - Token Bridge Contract\\n * Core Bridge contract built on top of CCIP Protocol to swap AMO tokens across chains.\\n */\\n\\n/// @title AMO Bridge Contract for transferring/receiving AMO tokens across chains.\\ncontract AmoTokenBridge is CCIPReceiver, ConfirmedOwnerWithProposal {\\n    // Custom errors to provide more descriptive revert messages.\\n    error NotEnoughApproval(address target, uint256 amountRequired); // Used to make sure contract has enough approval to withdraw token deposit.\\n    error NotEnoughBalance(uint256 expected, uint256 available); // Used to make sure contract has enough balance to cover the fees or withdraw.\\n    error NothingToWithdraw(); // Used when trying to withdraw Ether but there's nothing to withdraw.\\n    error FailedToWithdraw(address owner, address target, uint256 value); // Used when the transfer of Ether or token fails.\\n    error DestinationChainNotAllowed(uint64 destinationChainSelector); // Used when the destination chain has not been allowlisted by the contract owner.\\n    error SourceChainNotAllowed(uint64 sourceChainSelector); // Used when the source chain has not been allowlisted by the contract owner.\\n    error SenderNotAllowed(address sender); // Used when the sender has not been allowlisted by the contract owner.\\n\\n    // Event emitted when a message is sent to another chain.\\n    event MessageSent(\\n        bytes32 indexed messageId, // The unique ID of the CCIP message.\\n        uint64 indexed destinationChainSelector, // The chain selector of the destination chain.\\n        address receiver, // The address of the receiver on the destination chain.\\n        address tokenRecipient, // The address of the token recipient on the destination chain.\\n        address token, // The token address that was transferred.\\n        uint256 tokenAmount, // The token amount that was transferred.\\n        address feeToken, // the token address used to pay CCIP fees.\\n        uint256 fees // The fees paid for sending the message.\\n    );\\n\\n    // Event emitted when a message is received from another chain.\\n    event MessageReceived(\\n        bytes32 indexed messageId, // The unique ID of the CCIP message.\\n        uint64 indexed sourceChainSelector, // The chain selector of the source chain.\\n        address sender, // The address of the sender from the source chain.\\n        address tokenRecipient, // The address of the token recipient on the destination chain.\\n        address token, // The token address that was transferred.\\n        uint256 tokenAmount // The token amount that was transferred.\\n    );\\n\\n    bytes32 private s_lastReceivedMessageId; // Store the last received messageId.\\n    address private s_lastReceivedSender; // Store the last sender address.\\n    address private s_lastReceivedTokenRecipient; // Store the last received token recipient Address.\\n    address private s_lastReceivedTokenAddress; // Store the last received token address.\\n    uint256 private s_lastReceivedTokenAmount; // Store the last received amount.\\n\\n    IRouterClient private ccipRouter; // Router client instance to interact with cross-chain router.\\n    uint256 public maxGasLimit = 200000; // Maximum amount of gas CCIP can consume to execute ccipReceive() on dest chain.\\n\\n    // Mapping to keep track of allowlisted destination chains.\\n    mapping(uint64 => bool) public allowlistedDestinationChains;\\n\\n    // Mapping to keep track of allowlisted source chains.\\n    mapping(uint64 => bool) public allowlistedSourceChains;\\n\\n    // Mapping to keep track of allowlisted senders.\\n    mapping(address => bool) public allowlistedSenders;\\n\\n    /// @notice Constructor initializes the contract with the router address.\\n    /// @param _router The address of the router contract.\\n    constructor(address _router) CCIPReceiver(_router) ConfirmedOwnerWithProposal(msg.sender, address(0)){\\n        require(_router != address(0), \\\"Invalid router address\\\");\\n        ccipRouter = IRouterClient(_router);\\n    }\\n\\n    /// @dev Modifier that checks if the chain with the given destinationChainSelector is allowlisted.\\n    /// @param _destinationChainSelector The selector of the destination chain.\\n    modifier onlyAllowlistedDestinationChain(uint64 _destinationChainSelector) {\\n        if (!allowlistedDestinationChains[_destinationChainSelector])\\n            revert DestinationChainNotAllowed(_destinationChainSelector);\\n        _;\\n    }\\n\\n    /// @dev Modifier that checks if the chain with the given sourceChainSelector is allowlisted and if the sender is allowlisted.\\n    /// @param _sourceChainSelector The selector of the destination chain.\\n    /// @param _sender The address of the sender.\\n    modifier onlyAllowlisted(uint64 _sourceChainSelector, address _sender) {\\n        if (!allowlistedSourceChains[_sourceChainSelector])\\n            revert SourceChainNotAllowed(_sourceChainSelector);\\n        if (!allowlistedSenders[_sender]) revert SenderNotAllowed(_sender);\\n        _;\\n    }\\n\\n    /// @dev Updates the allowlist status of a destination chain for transactions.\\n    /// @notice This function can only be called by the owner.\\n    /// @param _destinationChainSelector The selector of the destination chain to be updated.\\n    /// @param allowed The allowlist status to be set for the destination chain.\\n    function allowlistDestinationChain( uint64 _destinationChainSelector, bool allowed) external onlyOwner {\\n        allowlistedDestinationChains[_destinationChainSelector] = allowed;\\n    }\\n\\n    /// @dev Updates the allowlist status of a source chain\\n    /// @notice This function can only be called by the owner.\\n    /// @param _sourceChainSelector The selector of the source chain to be updated.\\n    /// @param allowed The allowlist status to be set for the source chain.\\n    function allowlistSourceChain(uint64 _sourceChainSelector, bool allowed) external onlyOwner {\\n        allowlistedSourceChains[_sourceChainSelector] = allowed;\\n    }\\n\\n    /// @dev Updates the allowlist status of a sender for transactions.\\n    /// @notice This function can only be called by the owner.\\n    /// @param _sender The address of the sender to be updated.\\n    /// @param allowed The allowlist status to be set for the sender.\\n    function allowlistSender(address _sender, bool allowed) external onlyOwner {\\n        allowlistedSenders[_sender] = allowed;\\n    }\\n\\n\\n    /// @notice Sends data and transfer tokens to receiver on the destination chain.\\n    /// @notice Get estimate for fees in native gas.\\n    /// @dev Assumes your contract has sufficient native gas like ETH on Ethereum or MATIC on Polygon.\\n    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.\\n    /// @param _receiver The address of the recipient on the destination blockchain.\\n    /// @param _tokenRecipient The address of the token recipient on the destination chain.\\n    /// @param _token token address.\\n    /// @param _amount token amount.\\n    /// @return fees The fees required for sending this message.\\n    function estimateFees(\\n        uint64 _destinationChainSelector,\\n        address _receiver,\\n        address _tokenRecipient,\\n        address _token,\\n        uint256 _amount\\n    ) public view returns (uint256 fees) {\\n        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message\\n        // address(0) means fees are paid in native gas\\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\\n            _receiver,\\n            _tokenRecipient,\\n            _token,\\n            _amount,\\n            address(0)\\n        );\\n\\n        // Get and return the fees required to send the CCIP message\\n        return ccipRouter.getFee(\\n            _destinationChainSelector,\\n            evm2AnyMessage\\n        );\\n    }\\n\\n\\n    /// @notice Fetch the token allowance approved by the caller address \\n    /// @dev This function get the allowance against msg.sender and the contract address\\n    /// @param _token The token address to validate the approval provided.\\n    function getAllowance(address _token) public view returns (uint256 allowedAmount) {\\n        return IERC20(_token).allowance(msg.sender, address(this));\\n    }\\n\\n\\n    /// @notice Sends data and transfer tokens to receiver on the destination chain.\\n    /// @notice Pay for fees in native gas.\\n    /// @dev Assumes your contract has sufficient native gas like ETH on Ethereum or MATIC on Polygon.\\n    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.\\n    /// @param _receiver The address of the recipient on the destination blockchain.\\n    /// @param _tokenRecipient The address of the token recipient on the destination chain.\\n    /// @param _token token address.\\n    /// @param _amount token amount.\\n    /// @return messageId The ID of the CCIP message that was sent.\\n    function bridgeToken(\\n        uint64 _destinationChainSelector,\\n        address _receiver,\\n        address _tokenRecipient,\\n        address _token,\\n        uint256 _amount\\n    )\\n        external\\n        payable\\n        onlyAllowlistedDestinationChain(_destinationChainSelector)\\n        returns (bytes32 messageId)\\n    {\\n        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message\\n        // address(0) means fees are paid in native gas\\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\\n            _receiver,\\n            _tokenRecipient,\\n            _token,\\n            _amount,\\n            address(0)\\n        );\\n\\n        // Get the fee required and validate the msg.value provided to send the CCIP message\\n        uint256 fees = ccipRouter.getFee(_destinationChainSelector, evm2AnyMessage);\\n        if (fees > msg.value) revert NotEnoughBalance(fees, msg.value); \\n\\n        // Validate if the contract is approved to withdraw tokens on the user's behalf\\n        uint256 tokenAllowance = IERC20(_token).allowance(msg.sender, address(this));\\n        if (_amount > tokenAllowance) revert NotEnoughApproval(address(this), _amount - tokenAllowance);\\n\\n        // Transfer the user's native balance for the gas fees to the contract\\n        (bool sentEth, ) = address(this).call{value: msg.value}(\\\"\\\");\\n        if (!sentEth) revert FailedToWithdraw(msg.sender, address(this), msg.value);\\n\\n        // Transfer the user's bridge token amount to the contract\\n        bool sentToken = IERC20(_token).transferFrom(msg.sender, address(this), _amount);\\n        if (!sentToken) revert FailedToWithdraw(msg.sender, address(this), _amount);\\n\\n        // Approve the CCIP router to transfer tokens deposited by the user\\n        IERC20(_token).approve(address(ccipRouter), _amount);\\n\\n        // Send the message through the router and store the returned message ID\\n        messageId = ccipRouter.ccipSend{value: fees}(_destinationChainSelector, evm2AnyMessage);\\n\\n        // Emit an event with message details\\n        emit MessageSent( messageId, _destinationChainSelector, _receiver, _tokenRecipient, _token, _amount, address(0), fees);\\n\\n        // Return the message ID\\n        return messageId;\\n    }\\n\\n    \\n    /// @notice Allows the contract owner to change the CCIP router address from within the contract.\\n    /// @dev This function allows the owner to update the router in case the Chainlink router changes.\\n    /// It can only be called by the owner of the contract.\\n    /// @param _router The new address of the CCIP router to be set.\\n    function changeCCIPRouter(address _router) external onlyOwner {\\n        // Update the CCIP router client instance\\n        ccipRouter = IRouterClient(_router);\\n    }\\n\\n\\n    /// @notice Allows the contract owner to change the maximum gas limit set for CCIP messages.\\n    /// @dev This function updates the gas limit used when the bridge is triggered.\\n    /// It can only be called by the owner of the contract.\\n    /// @param _newLimit The new gas limit to be set.\\n    function changeGasLimit(uint256 _newLimit) external onlyOwner {\\n        maxGasLimit = _newLimit;\\n    }\\n\\n    /// @notice Allows the contract owner to withdraw a specified amount of Ether to a designated beneficiary address.\\n    /// @dev This function reverts if there are no funds to withdraw or if the transfer fails.\\n    /// It can only be called by the owner of the contract.\\n    /// @param _beneficiary The address to which the Ether should be sent.\\n    /// @param _requestAmount The amount of Ether to withdraw.\\n    function withdraw(address _beneficiary, uint256 _requestAmount) external onlyOwner{\\n        // Retrieve the native balance of this contract\\n        uint256 availableBalance = address(this).balance;\\n\\n        // Revert if there is nothing to withdraw\\n        if (availableBalance == 0) revert NothingToWithdraw();\\n\\n        // Revert if the requested amount is not available to withdraw\\n        if (_requestAmount > availableBalance)\\n            revert NotEnoughBalance(availableBalance, _requestAmount);\\n\\n        // Attempt to send the funds, capturing the success status and discarding any return data\\n        (bool sent, ) = _beneficiary.call{value: _requestAmount}(\\\"\\\");\\n\\n        // Revert if the send failed, with information about the attempted transfer\\n        if (!sent)\\n            revert FailedToWithdraw(\\n                msg.sender,\\n                _beneficiary,\\n                _requestAmount\\n            );\\n    }\\n\\n\\n    /// @notice Allows the contract owner to withdraw a specified amount of tokens to a designated beneficiary address.\\n    /// @dev This function reverts if there are no funds to withdraw or if the token transfer fails.\\n    /// It can only be called by the owner of the contract.\\n    /// @param _beneficiary The address to which the tokens should be sent.\\n    /// @param _token The address of the token to withdraw.\\n    /// @param _requestAmount The amount of tokens to withdraw.\\n    function withdraw(address _beneficiary, address _token,  uint256 _requestAmount) external onlyOwner{\\n        // Retrieve the token balance on this contract\\n        uint256 availableBalance = IERC20(_token).balanceOf(address(this));\\n\\n        // Revert if there is nothing to withdraw\\n        if (availableBalance == 0) revert NothingToWithdraw();\\n\\n        // Revert if the requested amount is not available to withdraw\\n        if (_requestAmount > availableBalance)\\n            revert NotEnoughBalance(availableBalance, _requestAmount);\\n\\n        // Transfer tokens to the beneficiary\\n        IERC20(_token).transfer(_beneficiary, _requestAmount);\\n    }\\n\\n\\n    /**\\n     * @notice Returns the details of the last CCIP received message.\\n     * @dev This function retrieves the ID, text, token address, and token amount of the last received CCIP message.\\n     * @return messageId The ID of the last received CCIP message.\\n     * @return sender The address of the sender triggered in the last received CCIP message.\\n     * @return tokenRecipient The token recipient of the token in the last received CCIP message.\\n     * @return tokenAddress The address of the token in the last CCIP received message.\\n     * @return tokenAmount The amount of the token in the last CCIP received message.\\n     */\\n    function getLastReceivedMessageDetails()\\n        public\\n        view\\n        returns (\\n            bytes32 messageId,\\n            address sender,\\n            address tokenRecipient,\\n            address tokenAddress,\\n            uint256 tokenAmount\\n        )\\n    {\\n        return (\\n            s_lastReceivedMessageId,\\n            s_lastReceivedSender,\\n            s_lastReceivedTokenRecipient,\\n            s_lastReceivedTokenAddress,\\n            s_lastReceivedTokenAmount\\n        );\\n    }\\n\\n\\n    /// handle a received message\\n    function _ccipReceive(Client.Any2EVMMessage memory any2EvmMessage)\\n        internal\\n        override\\n        onlyAllowlisted(\\n            any2EvmMessage.sourceChainSelector,\\n            abi.decode(any2EvmMessage.sender, (address))\\n        ) // Make sure source chain and sender are allowlisted\\n    {\\n        s_lastReceivedMessageId = any2EvmMessage.messageId; // fetch the messageId\\n        s_lastReceivedSender = abi.decode(any2EvmMessage.sender, (address)); // abi-decoding of the sender address\\n        s_lastReceivedTokenRecipient = abi.decode(any2EvmMessage.data,(address)); // abi-decoding of the sent address\\n        // Expect one token to be transferred at once, but you can transfer several tokens.\\n        s_lastReceivedTokenAddress = any2EvmMessage.destTokenAmounts[0].token;\\n        s_lastReceivedTokenAmount = any2EvmMessage.destTokenAmounts[0].amount;\\n\\n        // Perform ERC-20 token transfer to the token recipient\\n        IERC20(s_lastReceivedTokenAddress).transfer(\\n            s_lastReceivedTokenRecipient,\\n            s_lastReceivedTokenAmount\\n        );\\n\\n        emit MessageReceived(\\n            any2EvmMessage.messageId,\\n            any2EvmMessage.sourceChainSelector, // fetch the source chain identifier (aka selector)\\n            s_lastReceivedSender,\\n            s_lastReceivedTokenRecipient,\\n            s_lastReceivedTokenAddress,\\n            s_lastReceivedTokenAmount\\n        );\\n    }\\n\\n\\n    /// @notice Construct a CCIP message.\\n    /// @dev This function will create an EVM2AnyMessage struct with all the necessary information for programmable tokens transfer.\\n    /// @param _receiver The address of the receiver.\\n    /// @param _tokenRecipient The address of the token recipient to receive the token.\\n    /// @param _token The token to be transferred.\\n    /// @param _amount The amount of the token to be transferred.\\n    /// @param _feeTokenAddress The address of the token used for fees. Set address(0) for native gas.\\n    /// @return Client.EVM2AnyMessage Returns an EVM2AnyMessage struct which contains information for sending a CCIP message.\\n    function _buildCCIPMessage(\\n        address _receiver,\\n        address _tokenRecipient,\\n        address _token,\\n        uint256 _amount,\\n        address _feeTokenAddress\\n    ) internal view returns (Client.EVM2AnyMessage memory) {\\n        // Set the token amounts\\n        Client.EVMTokenAmount[]\\n            memory tokenAmounts = new Client.EVMTokenAmount[](1);\\n        tokenAmounts[0] = Client.EVMTokenAmount({\\n            token: _token,\\n            amount: _amount\\n        });\\n        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message\\n        return\\n            Client.EVM2AnyMessage({\\n                receiver: abi.encode(_receiver), // ABI-encoded receiver address\\n                data: abi.encode(_tokenRecipient), // ABI-encoded token recipient address\\n                tokenAmounts: tokenAmounts, // The amount and type of token being transferred\\n                extraArgs: Client._argsToBytes(\\n                    // Additional arguments, setting gas limit and non-strict sequencing mode\\n                    Client.EVMExtraArgsV1({gasLimit: maxGasLimit})\\n                ),\\n                // Set the feeToken to a feeTokenAddress, indicating specific asset will be used for fees\\n                feeToken: _feeTokenAddress\\n            });\\n    }\\n\\n\\n    /// @notice Fallback function to allow the contract to receive Ether.\\n    /// @dev This function has no function body, making it a default function for receiving Ether.\\n    /// It is automatically called when Ether is sent to the contract without any data.\\n    receive() external payable {}\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"yulDetails\": {\r\n          \"optimizerSteps\": \"u\"\r\n        }\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"destinationChainSelector\",\"type\":\"uint64\"}],\"name\":\"DestinationChainNotAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"FailedToWithdraw\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"InvalidRouter\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountRequired\",\"type\":\"uint256\"}],\"name\":\"NotEnoughApproval\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"}],\"name\":\"NotEnoughBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NothingToWithdraw\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"SenderNotAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"sourceChainSelector\",\"type\":\"uint64\"}],\"name\":\"SourceChainNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"sourceChainSelector\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"MessageReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"destinationChainSelector\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"}],\"name\":\"MessageSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_destinationChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"allowlistDestinationChain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"allowlistSender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_sourceChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"allowlistSourceChain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"allowlistedDestinationChains\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowlistedSenders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"allowlistedSourceChains\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_destinationChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"bridgeToken\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"sourceChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"sender\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Client.EVMTokenAmount[]\",\"name\":\"destTokenAmounts\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Client.Any2EVMMessage\",\"name\":\"message\",\"type\":\"tuple\"}],\"name\":\"ccipReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"changeCCIPRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"changeGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_destinationChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"estimateFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"allowedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastReceivedMessageDetails\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxGasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_requestAmount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_requestAmount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "AmoTokenBridge", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000080226fc0ee2b096224eeac085bb9a8cba1146f7d", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}