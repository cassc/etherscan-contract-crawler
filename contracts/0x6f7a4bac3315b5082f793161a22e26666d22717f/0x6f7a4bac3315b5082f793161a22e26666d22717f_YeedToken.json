{"SourceCode": "pragma solidity ^0.4.11;\r\n/**\r\n    ERC20 Interface\r\n    @author DongOk Peter Ryu - <odin@yggdrash.io>\r\n*/\r\ncontract ERC20 {\r\n    function totalSupply() public constant returns (uint supply);\r\n    function balanceOf( address who ) public constant returns (uint value);\r\n    function allowance( address owner, address spender ) public constant returns (uint _allowance);\r\n\r\n    function transfer( address to, uint value) public returns (bool ok);\r\n    function transferFrom( address from, address to, uint value) public returns (bool ok);\r\n    function approve( address spender, uint value ) public returns (bool ok);\r\n\r\n    event Transfer( address indexed from, address indexed to, uint value);\r\n    event Approval( address indexed owner, address indexed spender, uint value);\r\n}\r\n/**\r\n    LOCKABLE TOKEN\r\n    @author DongOk Peter Ryu - <odin@yggdrash.io>\r\n*/\r\ncontract Lockable {\r\n    uint public creationTime;\r\n    bool public lock;\r\n    bool public tokenTransfer;\r\n    address public owner;\r\n    mapping( address => bool ) public unlockaddress;\r\n    // lockaddress List\r\n    mapping( address => bool ) public lockaddress;\r\n\r\n    // LOCK EVENT\r\n    event Locked(address lockaddress,bool status);\r\n    // UNLOCK EVENT\r\n    event Unlocked(address unlockedaddress, bool status);\r\n\r\n\r\n    // if Token transfer\r\n    modifier isTokenTransfer {\r\n        // if token transfer is not allow\r\n        if(!tokenTransfer) {\r\n            require(unlockaddress[msg.sender]);\r\n        }\r\n        _;\r\n    }\r\n\r\n    // This modifier check whether the contract should be in a locked\r\n    // or unlocked state, then acts and updates accordingly if\r\n    // necessary\r\n    modifier checkLock {\r\n        assert(!lockaddress[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier isOwner\r\n    {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    function Lockable()\r\n    public\r\n    {\r\n        creationTime = now;\r\n        tokenTransfer = false;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // Lock Address\r\n    function lockAddress(address target, bool status)\r\n    external\r\n    isOwner\r\n    {\r\n        require(owner != target);\r\n        lockaddress[target] = status;\r\n        Locked(target, status);\r\n    }\r\n\r\n    // UnLock Address\r\n    function unlockAddress(address target, bool status)\r\n    external\r\n    isOwner\r\n    {\r\n        unlockaddress[target] = status;\r\n        Unlocked(target, status);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n}\r\n/**\r\n    YGGDRASH Token\r\n    @author DongOk Peter Ryu - <odin@yggdrash.io>\r\n*/\r\ncontract YeedToken is ERC20, Lockable {\r\n\r\n    // ADD INFORMATION\r\n    string public constant name = \"YGGDRASH\";\r\n    string public constant symbol = \"YEED\";\r\n    uint8 public constant decimals = 18;  // 18 is the most common number of decimal places\r\n\r\n    using SafeMath for uint;\r\n\r\n    mapping( address => uint ) _balances;\r\n    mapping( address => mapping( address => uint ) ) _approvals;\r\n    uint _supply;\r\n    address public walletAddress;\r\n\r\n    event TokenBurned(address burnAddress, uint amountOfTokens);\r\n    event TokenTransfer();\r\n\r\n    modifier onlyFromWallet {\r\n        require(msg.sender != walletAddress);\r\n        _;\r\n    }\r\n\r\n    function YeedToken( uint initial_balance, address wallet)\r\n    public\r\n    {\r\n        require(wallet != 0);\r\n        require(initial_balance != 0);\r\n        _balances[msg.sender] = initial_balance;\r\n        _supply = initial_balance;\r\n        walletAddress = wallet;\r\n    }\r\n\r\n    function totalSupply() public constant returns (uint supply) {\r\n        return _supply;\r\n    }\r\n\r\n    function balanceOf( address who ) public constant returns (uint value) {\r\n        return _balances[who];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public constant returns (uint _allowance) {\r\n        return _approvals[owner][spender];\r\n    }\r\n\r\n    function transfer( address to, uint value)\r\n    public\r\n    isTokenTransfer\r\n    checkLock\r\n    returns (bool success) {\r\n\r\n        require( _balances[msg.sender] >= value );\r\n\r\n        _balances[msg.sender] = _balances[msg.sender].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        Transfer( msg.sender, to, value );\r\n        return true;\r\n    }\r\n\r\n    function transferFrom( address from, address to, uint value)\r\n    public\r\n    isTokenTransfer\r\n    checkLock\r\n    returns (bool success) {\r\n        // if you don't have enough balance, throw\r\n        require( _balances[from] >= value );\r\n        // if you don't have approval, throw\r\n        require( _approvals[from][msg.sender] >= value );\r\n        // transfer and return true\r\n        _approvals[from][msg.sender] = _approvals[from][msg.sender].sub(value);\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        Transfer( from, to, value );\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint value)\r\n    public\r\n    checkLock\r\n    returns (bool success) {\r\n        _approvals[msg.sender][spender] = value;\r\n        Approval( msg.sender, spender, value );\r\n        return true;\r\n    }\r\n\r\n    // burnToken burn tokensAmount for sender balance\r\n    function burnTokens(uint tokensAmount)\r\n    public\r\n    isTokenTransfer\r\n    {\r\n        require( _balances[msg.sender] >= tokensAmount );\r\n\r\n        _balances[msg.sender] = _balances[msg.sender].sub(tokensAmount);\r\n        _supply = _supply.sub(tokensAmount);\r\n        TokenBurned(msg.sender, tokensAmount);\r\n\r\n    }\r\n\r\n\r\n    function enableTokenTransfer()\r\n    external\r\n    onlyFromWallet\r\n    {\r\n        tokenTransfer = true;\r\n        TokenTransfer();\r\n    }\r\n\r\n    function disableTokenTransfer()\r\n    external\r\n    onlyFromWallet\r\n    {\r\n        tokenTransfer = false;\r\n        TokenTransfer();\r\n    }\r\n\r\n    /* This unnamed function is called whenever someone tries to send ether to it */\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"supply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableTokenTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"unlockAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokensAmount\",\"type\":\"uint256\"}],\"name\":\"burnTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockaddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creationTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"_allowance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableTokenTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"unlockaddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"lockAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"initial_balance\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"burnAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"TokenBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TokenTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"lockaddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"unlockedaddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"Unlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "YeedToken", "CompilerVersion": "v0.4.19+commit.c4cbbb05", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000204fce5e3e250261100000000000000000000000000000000000c72e03a01cd93b2b68b5e08b7bfd49182b3a", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://bc44e13eaff5f0cf51e4adf29b7095d4df9b8bf3d2a064a3d3d7bf2823c1944f"}