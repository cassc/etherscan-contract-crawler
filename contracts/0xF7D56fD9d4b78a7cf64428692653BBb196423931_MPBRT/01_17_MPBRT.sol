//SPDX-License-Identifier: MIT
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @dev: @brougkr
 */
pragma solidity 0.8.16;
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import {IERC721} from "@openzeppelin/contracts/interfaces/IERC721.sol";
import {MerkleProof} from "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import {IArtBlocks} from "./IArtBlocks.sol";
import {ERC721MP} from "./ERC721MP.sol";
contract MPBRT is ERC721MP, Ownable, ReentrancyGuard
{
    struct MintPassInformation
    {
        address _ArtBlocksMintingContract;  // [0] -> _ArtBlocksMintingContract
        uint _ArtBlocksProjectID;           // [1] -> _ArtBlocksProjectID
        uint _Price;                        // [2] -> _Price
        uint _TotalAvailableForPurchase;    // [3] -> _TotalAvailableForPurchase
        uint _UnixSaleStartTimeBrightlist;  // [4] -> _UnixSaleStartTimeBrightlist
        uint _UnixSaleStartTimePublic;      // [5] -> _UnixSaleStartTimePublic
        uint _UnixUserRedeemTimestamp;      // [6] -> _UnixUserRedeemTimestamp
        uint _UnixUserMintTimestamp;        // [7] -> _UnixUserMintTimestamp
        uint _MaxPurchaseAmountPerTx;       // [8] -> _MaxPurchaseAmountPerTx
        bytes32 _Root;                      // [9] -> _Root
        bytes32 _MINTER_ROLE;               // [10] -> _MINTER_ROLE
    }
    MintPassInformation public MintPassInfo = MintPassInformation(
        0x7b9a45E278b5B374bb2d96C65665d4360C97BF01,                         // [0] -> _ArtBlocksMintingContract
        13,                                                                 // [1] -> _ArtBlocksProjectID
        0.18 ether,                                                         // [2] -> _Price
        100,                                                                // [3] -> _TotalAvailableForPurchase
        1662490800,                                                         // [4] -> _UnixSaleStartTimeBrightlist
        1662492600,                                                         // [5] -> _UnixSaleStartTimePublic
        6942000000,                                                         // [6] -> _UnixUserRedeemTimestamp
        6942000000,                                                         // [7] -> _UnixUserMintTimestamp
        1,                                                                  // [8] -> _MaxPurchaseAmountPerTx
        0xbd7b1eefed66cb95d819d2ade0a9b803f73d573b72e3299e0bae71ef200bea20, // [9] -> _Root
        keccak256("MINTER_ROLE")                                            // [10] -> _MINTER_ROLE
    );
    string public baseURI = "ipfs://QmNnrXgnP95DqnNhcJQpMFRkedEztCAKM515aaeS7Drtf7/";
    mapping(address=>bytes32) private _Role;
    mapping(uint=>bool) private _Minted;
    mapping(uint=>bool) private _DelegateStatus;
    event DelegateStatusChanged(address indexed Redeemer, uint TokenID);
    event Purchased(address indexed Recipient, uint Amount, uint Value);
    event LiveMintCompleteArtist(address Recipient, uint ArtBlocksProjectID, uint TokenID, uint MintedWorkNumber, bool DelegateStatus);
    /**
     * @dev Constructor 
     */
    constructor() ERC721MP("WirwarMP", "WirwarMP") 
    { 
        _mint(0x18B7511938FBe2EE08ADf3d4A24edB00A5C9B783, 4); 
        _WhitelistedSender[0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700] = true; // operator.brightmoments.eth
        _transferOwnership(0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700); // operator.brightmoments.eth
    }
    
    /******************
    *  USER FUNCTIONS *
    *******************/

    /**
     * @dev Registers Delegate Status
     */
    function RegisterDelegateStatus(uint[] calldata TokenIDs, bool State) external nonReentrant
    {
        for(uint TokenID; TokenID < TokenIDs.length; TokenID++)
        {
            require(IERC721(address(this)).ownerOf(TokenIDs[TokenID]) == msg.sender, "IERC721: Sender Is Not Owner");
            _DelegateStatus[TokenIDs[TokenID]] = State;
            emit DelegateStatusChanged(msg.sender, TokenIDs[TokenID]);
        }
    }

    /**
     * @dev Purchases Mint Pass
     */
    function Purchase(uint Amount, bool Status) external payable nonReentrant
    {
        require(block.timestamp >= MintPassInfo._UnixSaleStartTimePublic, "MP: Sale Not Active For Public Purchases");
        require(Amount == MintPassInfo._MaxPurchaseAmountPerTx, "MP: Amount Too High");
        if(_totalMinted() + Amount > MintPassInfo._TotalAvailableForPurchase) { Amount = MintPassInfo._TotalAvailableForPurchase - _totalMinted(); }
        require(Amount > 0, "MP: Sold Out");
        require(_totalMinted() + Amount <= MintPassInfo._TotalAvailableForPurchase, "MP: Overflow");
        require(msg.value == Amount * MintPassInfo._Price, "MP: Invalid Price");
        for(uint x = _totalMinted(); x < _totalMinted() + Amount; x++) { _DelegateStatus[x] = Status; }
        _mint(msg.sender, Amount);
        emit Purchased(msg.sender, Amount, msg.value);
        if(Status) { emit DelegateStatusChanged(msg.sender, _totalMinted()); }
    }

    /**
     * @dev Purchases Mint Pass From BrightList
     */
    function PurchaseBrightList(uint Amount, bool Status, bytes32[] calldata Proof) external payable nonReentrant
    {
        require(block.timestamp >= MintPassInfo._UnixSaleStartTimeBrightlist, "Sale Not Active For Brightlist Purchases");
        require(Amount == MintPassInfo._MaxPurchaseAmountPerTx, "MP: Amount Too High");
        if(_totalMinted() + Amount > MintPassInfo._TotalAvailableForPurchase) { Amount = MintPassInfo._TotalAvailableForPurchase - _totalMinted(); }
        require(Amount > 0, "MP: Sold Out");
        require(_totalMinted() + Amount <= MintPassInfo._TotalAvailableForPurchase, "MP: Overflow");
        require(msg.value == Amount * MintPassInfo._Price, "MP: Invalid Price");
        require(viewBrightListAllocation(msg.sender, Proof), "MP: User Not On Brightlist");
        for(uint x = _totalMinted(); x < _totalMinted() + Amount; x++) { _DelegateStatus[x] = Status; }
        _mint(msg.sender, Amount);
        emit Purchased(msg.sender, Amount, msg.value);
        if(Status) { emit DelegateStatusChanged(msg.sender, _totalMinted()); }
    }

    /**
     * @dev Redeems User's Mint Passes For Minted Work
     */
    function BurnToRedeemMintPass(uint TokenID) external nonReentrant
    {
        require(block.timestamp >= MintPassInfo._UnixUserRedeemTimestamp, "MP: Cannot Redeem Pass Unitl After The Start Time");
        if(_exists(TokenID))
        {
            require(IERC721(address(this)).ownerOf(TokenID) == msg.sender, "MP: `msg.sender` Is Not MintPass Owner Of Input TokenID");
            require(!_Minted[TokenID], "MP: TokenID Minted");
            _Minted[TokenID] = true;
            _burn(TokenID);
            uint _MintedWorkNumber = IArtBlocks(MintPassInfo._ArtBlocksMintingContract).purchaseTo(msg.sender, MintPassInfo._ArtBlocksProjectID);
            emit LiveMintCompleteArtist(msg.sender, MintPassInfo._ArtBlocksProjectID, TokenID, _MintedWorkNumber, _DelegateStatus[TokenID]);
        }
    }

    /**
     * @dev Redeems User's Mint Passes For Minted Work
     */
    function BurnToRedeemMintPasses() external nonReentrant
    {
        require(block.timestamp >= MintPassInfo._UnixUserRedeemTimestamp, "MP: Cannot Redeem Pass Unitl After The Start Time");
        for(uint TokenID; TokenID < MintPassInfo._TotalAvailableForPurchase; TokenID++)
        {
            if(_exists(TokenID))
            {
                if(IERC721(address(this)).ownerOf(TokenID) == msg.sender) 
                {
                    require(IERC721(address(this)).ownerOf(TokenID) == msg.sender, "MP: Invalid State");
                    require(!_Minted[TokenID], "MP: TokenID Minted");
                    _Minted[TokenID] = true;
                    _burn(TokenID);
                    uint _MintedWorkNumber = IArtBlocks(MintPassInfo._ArtBlocksMintingContract).purchaseTo(msg.sender, MintPassInfo._ArtBlocksProjectID);
                    emit LiveMintCompleteArtist(msg.sender, MintPassInfo._ArtBlocksProjectID, TokenID, _MintedWorkNumber, _DelegateStatus[TokenID]);
                }
            }
        }
    }

    /**
     * @dev Mints A Work Directly
     */
    function PurchaseMint(uint Amount) external payable nonReentrant
    {
        require(block.timestamp >= MintPassInfo._UnixUserMintTimestamp, "MP: Cannot LiveMint Until After The Start Time"); 
        require(msg.value == MintPassInfo._Price * Amount, "MP: Invalid `msg.value` Sent");
        for(uint x; x < Amount; x++)
        {
            uint _MintedWorkNumber = IArtBlocks(MintPassInfo._ArtBlocksMintingContract).purchaseTo(msg.sender, MintPassInfo._ArtBlocksProjectID);
            emit LiveMintCompleteArtist(msg.sender, MintPassInfo._ArtBlocksProjectID, 69420, _MintedWorkNumber, _DelegateStatus[69420]);
        }
    }

    /****************** 
    *    onlyMinter   *
    *******************/

    /**
     * @dev Mints Token To MP Owner
     */
    function _LiveMintArtist(uint[] calldata TicketIDs) external onlyMinter
    {
        for(uint TokenID; TokenID < TicketIDs.length; TokenID++)
        {
            if(_exists(TicketIDs[TokenID]))
            {
                if(IERC721(address(this)).ownerOf(TicketIDs[TokenID]) != address(0))
                {
                    require(!_Minted[TicketIDs[TokenID]], "MP: TokenID Minted");
                    _Minted[TicketIDs[TokenID]] = true;
                    address Recipient = IERC721(address(this)).ownerOf(TicketIDs[TokenID]);
                    _burn(TicketIDs[TokenID]);
                    uint _MintedWorkNumber = IArtBlocks(MintPassInfo._ArtBlocksMintingContract).purchaseTo(Recipient, MintPassInfo._ArtBlocksProjectID);
                    emit LiveMintCompleteArtist(Recipient, MintPassInfo._ArtBlocksProjectID, TicketIDs[TokenID], _MintedWorkNumber, _DelegateStatus[TokenID]);
                }
            }
        }
    }

    /****************** 
    *    OnlyOwner    *
    *******************/

    /**
     * @dev LiveMints All Artist Passes
     */
    function __LiveMintAllArtistPasses() external onlyOwner
    {
        for(uint _TicketID; _TicketID < _totalMinted(); _TicketID++)
        {
            if(_exists(_TicketID))
            {
                if(IERC721(address(this)).ownerOf(_TicketID) != address(0))
                {
                    require(!_Minted[_TicketID], "MP: _TicketID Minted");
                    _Minted[_TicketID] = true;
                    address Recipient = IERC721(address(this)).ownerOf(_TicketID);
                    _burn(_TicketID);
                    uint _MintedWorkNumber = IArtBlocks(MintPassInfo._ArtBlocksMintingContract).purchaseTo(Recipient, MintPassInfo._ArtBlocksProjectID);
                    emit LiveMintCompleteArtist(Recipient, MintPassInfo._ArtBlocksProjectID, _TicketID, _MintedWorkNumber, _DelegateStatus[_TicketID]);
                }
            }
        }
    }

    /**
     * @dev Mints Metadata Token Upon Sale Conclusion
     */
    function __OwnerMintTombstone() external onlyOwner { _mint(msg.sender, 1); }

    /**
     * @dev Batch Approves BRT For Purchasing
     */
    function __BatchApproveERC20(address[] calldata ERC20s, address[] calldata Operators, uint[] calldata Amounts) external onlyOwner
    {
        require(ERC20s.length == Operators.length && Operators.length == Amounts.length, "LiveMint: Arrays Must Be Equal Length");
        for(uint i; i < ERC20s.length; i++)
        {
            IERC20(ERC20s[i]).approve(Operators[i], Amounts[i]);
        }
    }

    /**
     * @dev Changes ArtBlocks Minting Contract Address
     */
    function __NewArtBlocksMintingContract(address NewContract) external onlyOwner { MintPassInfo._ArtBlocksMintingContract = NewContract; }

    /**
     * @dev Changes The ArtBlocks ProjectID
     */
    function __NewArtBlocksProjectID(uint NewID) external onlyOwner { MintPassInfo._ArtBlocksProjectID = NewID; }

    /**
     * @dev Changes Price Of Sale
     */
    function __NewPrice(uint NewPrice) external onlyOwner { MintPassInfo._Price = NewPrice; }

    /**
     * @dev Changes Available Amount To Purchase
     */
    function __NewAvailableToPurchase(uint NewAmount) external onlyOwner { MintPassInfo._TotalAvailableForPurchase = NewAmount; }

    /**
     * @dev Changes The Unix Start Time Of The Brightlist Sale
     */
    function __NewUnixStartTimeBrightlist(uint Timestamp) external onlyOwner { MintPassInfo._UnixSaleStartTimeBrightlist = Timestamp; }
    
    /**
     * @dev Changes The Unix Start Time Of The Public Sale
     */
    function __NewUnixStartTimePublic(uint Timestamp) external onlyOwner { MintPassInfo._UnixSaleStartTimePublic = Timestamp; }

    /**
     * @dev Changes The Unix Start Time Of User LiveMint Redeems
     */
    function __NewUnixStartTimeUserRedeems(uint Timestamp) external onlyOwner { MintPassInfo._UnixUserRedeemTimestamp = Timestamp; }
    
    /**
     * @dev Changes The Unix Start Time Of User Direct ArtBlocks Mints
     */
    function __NewUnixStartTimeUserDirectMints(uint Timestamp) external onlyOwner { MintPassInfo._UnixUserMintTimestamp = Timestamp; }

    /**
     * @dev Changes Unix Start Times Of Both Sales
     */
    function __NewUnixSaleStartTimes(uint Public, uint Brightlist) external onlyOwner
    {
        MintPassInfo._UnixSaleStartTimePublic = Public;
        MintPassInfo._UnixSaleStartTimeBrightlist = Brightlist;
    }

    /**
     * @dev Changes The Max Purchase Amount
     */
    function __NewMaxPurchaseAmountPerTx(uint Amount) external onlyOwner { MintPassInfo._MaxPurchaseAmountPerTx = Amount; }

    /**
     * @dev Changes Merkle Roothash
     */
    function __NewRoot(bytes32 NewRoot) external onlyOwner { MintPassInfo._Root = NewRoot; }

    /**
     * @dev Changes BaseURI
     */
    function __NewURI(string calldata NewURI) external onlyOwner { baseURI = NewURI; }

    /**
     * @dev Changes Whitelisted Contract Address State
     */
    function __NewWhitelistedContract(address ContractAddress) external onlyOwner 
    { 
        _WhitelistedSender[ContractAddress] = !_WhitelistedSender[ContractAddress]; 
    }

    /**
     * @dev Removes A Minter
     */
    function __MinterRemove(address Minter) external onlyOwner { _Role[Minter] = 0x0; }
    
    /**
     * @dev Adds A Minter
     */
    function __MinterAdd(address Minter) external onlyOwner { _Role[Minter] = MintPassInfo._MINTER_ROLE; }

    /**
     * @dev Withdraws Ether From Contract To Message Sender
     */
    function __Withdraw() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }

    /**
     * @dev Withdraws Ether From Contract To Address
     */
    function __WithdrawToAddress(address payable recipient) external onlyOwner 
    {
        uint balance = address(this).balance;
        (bool success, ) = recipient.call{value: balance}("");
        require(success, "Unable to Withdraw, Recipient May Have Reverted");
    }

    /**
     * @dev Withdraws ERC20 From Contract To Address
     */
    function __WithdrawERC20ToAddress(address Recipient, address ContractAddress) external onlyOwner
    {
        IERC20 ERC20 = IERC20(ContractAddress);
        ERC20.transferFrom(address(this), Recipient, ERC20.balanceOf(address(this)));
    }


    /**************** 
    *  PUBLIC VIEW  *
    *****************/

    /**
     * @dev Checks BrightList Allocation
     */
    function viewBrightListAllocation(address Wallet, bytes32[] memory Proof) public view returns(bool)
    { 
        bytes32 Leaf = keccak256(abi.encodePacked(Wallet));
        return MerkleProof.verify(Proof, MintPassInfo._Root, Leaf);
    }

    /**
     * @dev Returns Sale State Information
     */
    function viewSaleState() public view returns ( 
        uint StartTimePublic,
        uint StartTimeBrightlist,
        uint Price,
        uint TotalMinted
    ) {
        return(
            MintPassInfo._UnixSaleStartTimePublic,
            MintPassInfo._UnixSaleStartTimeBrightlist,
            MintPassInfo._Price,
            _totalMinted()
        );
    }

    /**
     * @dev Returns Sale Information
     */
    function viewSaleInfo(
        address Wallet, 
        bytes32[] calldata Proof
    ) public view returns (
        uint StartTimePublic,
        uint StartTimeBrightlist,
        uint Price,
        uint TotalMinted,
        bool BrightListEligible
    ) { return (
            MintPassInfo._UnixSaleStartTimePublic,
            MintPassInfo._UnixSaleStartTimeBrightlist,
            MintPassInfo._Price,
            _totalMinted(),
            viewBrightListAllocation(Wallet, Proof)
        );
    }

    /**
     * @dev Returns Wallet Holdings And Delegate Status
     */
    function viewWalletHoldingsAndDelegateStatus(address Wallet) public view returns (
        uint[] memory TokenIDs,
        bool[] memory DelegateStatus
    ) {
        uint[] memory _TokenIDs = new uint[](MintPassInfo._TotalAvailableForPurchase);
        bool[] memory _DelegateStatuses = new bool[](MintPassInfo._TotalAvailableForPurchase);
        uint _Found;
        for(uint x; x < MintPassInfo._TotalAvailableForPurchase; x++)
        {
            if(_exists(x))
            {
                if(IERC721(address(this)).ownerOf(x) == Wallet)
                {
                    _TokenIDs[_Found] = x;
                    _DelegateStatuses[_Found] = _DelegateStatus[x];
                    _Found++;
                }
            }
        }
        uint[] memory _OwnedTokenIDs = new uint[](_Found);
        bool[] memory _OwnedDelegateStatuses = new bool[](_Found);
        for(uint y; y < _Found; y++)
        {
            _OwnedTokenIDs[y] = _TokenIDs[y];
            _OwnedDelegateStatuses[y] = _DelegateStatuses[y];
        }
        return(_OwnedTokenIDs, _OwnedDelegateStatuses);
    }

    /****************** 
    *  INTERNAL VIEW  *
    ******************/

    /**
     * @dev Returns Base URI
     */
    function _baseURI() internal view virtual override returns (string memory) { return baseURI; }

    /************* 
    *  MODIFIER  *
    **************/

    modifier onlyMinter
    {
        require(_Role[msg.sender] == MintPassInfo._MINTER_ROLE, "OnlyMinter: Caller Is Not Approved BRT Minter");
        _;
    }
}