{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/implementation/Lockable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title A contract that provides modifiers to prevent reentrancy to state-changing and view-only methods. This contract\\n * is inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\\n * and https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol.\\n */\\ncontract Lockable {\\n    bool private _notEntered;\\n\\n    constructor() {\\n        // Storing an initial non-zero value makes deployment a bit more expensive, but in exchange the refund on every\\n        // call to nonReentrant will be lower in amount. Since refunds are capped to a percentage of the total\\n        // transaction's gas, it is best to keep them low in cases like this one, to increase the likelihood of the full\\n        // refund coming into effect.\\n        _notEntered = true;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant` function is not supported. It is possible to\\n     * prevent this from happening by making the `nonReentrant` function external, and making it call a `private`\\n     * function that does the actual state modification.\\n     */\\n    modifier nonReentrant() {\\n        _preEntranceCheck();\\n        _preEntranceSet();\\n        _;\\n        _postEntranceReset();\\n    }\\n\\n    /**\\n     * @dev Designed to prevent a view-only method from being re-entered during a call to a `nonReentrant()` state-changing method.\\n     */\\n    modifier nonReentrantView() {\\n        _preEntranceCheck();\\n        _;\\n    }\\n\\n    // Internal methods are used to avoid copying the require statement's bytecode to every `nonReentrant()` method.\\n    // On entry into a function, `_preEntranceCheck()` should always be called to check if the function is being\\n    // re-entered. Then, if the function modifies state, it should call `_postEntranceSet()`, perform its logic, and\\n    // then call `_postEntranceReset()`.\\n    // View-only methods can simply call `_preEntranceCheck()` to make sure that it is not being re-entered.\\n    function _preEntranceCheck() internal view {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\n    }\\n\\n    function _preEntranceSet() internal {\\n        // Any calls to nonReentrant after this point will fail\\n        _notEntered = false;\\n    }\\n\\n    function _postEntranceReset() internal {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _notEntered = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cross-chain-oracle/chain-adapters/Arbitrum_ParentMessenger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../insured-bridge/avm/Arbitrum_CrossDomainEnabled.sol\\\";\\nimport \\\"../interfaces/ParentMessengerInterface.sol\\\";\\nimport \\\"../interfaces/ParentMessengerConsumerInterface.sol\\\";\\nimport \\\"./ParentMessengerBase.sol\\\";\\nimport \\\"../../common/implementation/Lockable.sol\\\";\\n\\n/**\\n * @notice Sends cross chain messages from Ethereum L1 to Arbitrum L2 network.\\n * @dev This contract is ownable and should be owned by the DVM governor.\\n */\\ncontract Arbitrum_ParentMessenger is\\n    Arbitrum_CrossDomainEnabled,\\n    ParentMessengerInterface,\\n    ParentMessengerBase,\\n    Lockable\\n{\\n    event SetDefaultGasLimit(uint32 newDefaultGasLimit);\\n    event SetDefaultMaxSubmissionCost(uint256 newMaxSubmissionCost);\\n    event SetDefaultGasPrice(uint256 newDefaultGasPrice);\\n    event SetRefundL2Address(address newRefundL2Address);\\n    event MessageSentToChild(\\n        bytes data,\\n        address indexed targetSpoke,\\n        uint256 l1CallValue,\\n        uint32 gasLimit,\\n        uint256 gasPrice,\\n        uint256 maxSubmissionCost,\\n        address refundL2Address,\\n        address indexed childMessenger,\\n        uint256 sequenceNumber\\n    );\\n    event MessageReceivedFromChild(bytes data, address indexed childMessenger, address indexed targetHub);\\n\\n    // Gas limit for immediate L2 execution attempt (can be estimated via NodeInterface.estimateRetryableTicket).\\n    // NodeInterface precompile interface exists at L2 address 0x00000000000000000000000000000000000000C8\\n    uint32 public defaultGasLimit = 5_000_000;\\n\\n    // Amount of ETH allocated to pay for the base submission fee. The base submission fee is a parameter unique to\\n    // retryable transactions; the user is charged the base submission fee to cover the storage costs of keeping their\\n    // ticket\u2019s calldata in the retry buffer. (current base submission fee is queryable via\\n    // ArbRetryableTx.getSubmissionPrice). ArbRetryableTicket precompile interface exists at L2 address\\n    // 0x000000000000000000000000000000000000006E.\\n    uint256 public defaultMaxSubmissionCost = 0.1e18;\\n\\n    // L2 Gas price bid for immediate L2 execution attempt (queryable via standard eth*gasPrice RPC)\\n    uint256 public defaultGasPrice = 10e9; // 10 gWei\\n\\n    // This address on L2 receives extra ETH that is left over after relaying a message via the inbox.\\n    address public refundL2Address;\\n\\n    /**\\n     * @notice Construct the Optimism_ParentMessenger contract.\\n     * @param _inbox Contract that sends generalized messages to the Arbitrum chain.\\n     * @param _childChainId The chain id of the Optimism L2 network this messenger should connect to.\\n     **/\\n    constructor(address _inbox, uint256 _childChainId)\\n        Arbitrum_CrossDomainEnabled(_inbox)\\n        ParentMessengerBase(_childChainId)\\n    {\\n        refundL2Address = owner();\\n    }\\n\\n    /**\\n     * @notice Changes the refund address on L2 that receives excess gas or the full msg.value if the retryable\\n     * ticket reverts.\\n     * @dev The caller of this function must be the owner, which should be set to the DVM governor.\\n     * @param newRefundl2Address the new refund address to set. This should be set to an L2 address that is trusted by\\n     * the owner as it can spend Arbitrum L2 refunds for excess gas when sending transactions on Arbitrum.\\n     */\\n    function setRefundL2Address(address newRefundl2Address) public onlyOwner nonReentrant() {\\n        refundL2Address = newRefundl2Address;\\n        emit SetRefundL2Address(refundL2Address);\\n    }\\n\\n    /**\\n     * @notice Changes the default gas limit that is sent along with transactions to Arbitrum.\\n     * @dev The caller of this function must be the owner, which should be set to the DVM governor.\\n     * @param newDefaultGasLimit the new L2 gas limit to be set.\\n     */\\n    function setDefaultGasLimit(uint32 newDefaultGasLimit) public onlyOwner nonReentrant() {\\n        defaultGasLimit = newDefaultGasLimit;\\n        emit SetDefaultGasLimit(newDefaultGasLimit);\\n    }\\n\\n    /**\\n     * @notice Changes the default gas price that is sent along with transactions to Arbitrum.\\n     * @dev The caller of this function must be the owner, which should be set to the DVM governor.\\n     * @param newDefaultGasPrice the new L2 gas price to be set.\\n     */\\n    function setDefaultGasPrice(uint256 newDefaultGasPrice) public onlyOwner nonReentrant() {\\n        defaultGasPrice = newDefaultGasPrice;\\n        emit SetDefaultGasPrice(newDefaultGasPrice);\\n    }\\n\\n    /**\\n     * @notice Changes the default max submission cost that is sent along with transactions to Arbitrum.\\n     * @dev The caller of this function must be the owner, which should be set to the DVM governor.\\n     * @param newDefaultMaxSubmissionCost the new L2 max submission cost to be set.\\n     */\\n    function setDefaultMaxSubmissionCost(uint256 newDefaultMaxSubmissionCost) public onlyOwner nonReentrant() {\\n        defaultMaxSubmissionCost = newDefaultMaxSubmissionCost;\\n        emit SetDefaultMaxSubmissionCost(newDefaultMaxSubmissionCost);\\n    }\\n\\n    /**\\n     * @notice Changes the address of the oracle spoke on L2 via the child messenger.\\n     * @dev The caller of this function must be the owner, which should be set to the DVM governor.\\n     * @dev This function will only succeed if this contract has enough ETH to cover the approximate L1 call value.\\n     * @param newOracleSpoke the new oracle spoke address set on L2.\\n     */\\n    function setChildOracleSpoke(address newOracleSpoke) public onlyOwner nonReentrant() {\\n        bytes memory dataSentToChild = abi.encodeWithSignature(\\\"setOracleSpoke(address)\\\", newOracleSpoke);\\n        _sendMessageToChild(dataSentToChild, childMessenger);\\n    }\\n\\n    /**\\n     * @notice Changes the address of the parent messenger on L2 via the child messenger.\\n     * @dev The caller of this function must be the owner, which should be set to the DVM governor.\\n     * @dev This function will only succeed if this contract has enough ETH to cover the approximate L1 call value.\\n     * @param newParentMessenger the new parent messenger contract to be set on L2.\\n     */\\n    function setChildParentMessenger(address newParentMessenger) public onlyOwner nonReentrant() {\\n        bytes memory dataSentToChild = abi.encodeWithSignature(\\\"setParentMessenger(address)\\\", newParentMessenger);\\n        _sendMessageToChild(dataSentToChild, childMessenger);\\n    }\\n\\n    /**\\n     * @notice Sends a message to the child messenger via the canonical message bridge.\\n     * @dev The caller must be the either the OracleHub or the GovernorHub. This is to send either a\\n     * price or initiate a governance action to the OracleSpoke or GovernorSpoke on the child network.\\n     * @dev The recipient of this message is the child messenger. The messenger must implement processMessageFromParent\\n     * which then forwards the data to the target either the OracleSpoke or the governorSpoke depending on the caller.\\n     * @dev This function will only succeed if this contract has enough ETH to cover the approximate L1 call value.\\n     * @param data data message sent to the child messenger. Should be an encoded function call or packed data.\\n     */\\n    function sendMessageToChild(bytes memory data) external override onlyHubContract() nonReentrant() {\\n        address target = msg.sender == oracleHub ? oracleSpoke : governorSpoke;\\n        bytes memory dataSentToChild =\\n            abi.encodeWithSignature(\\\"processMessageFromCrossChainParent(bytes,address)\\\", data, target);\\n        _sendMessageToChild(dataSentToChild, target);\\n    }\\n\\n    /**\\n     * @notice Process a received message from the child messenger via the canonical message bridge.\\n     * @dev The caller must be the the child messenger, sent over the canonical message bridge.\\n     * @dev Note that only the OracleHub can receive messages from the child messenger. Therefore we can always forward\\n     * these messages to this contract. The OracleHub must implement processMessageFromChild to handle this message.\\n     * @param data data message sent from the child messenger. Should be an encoded function call or packed data.\\n     */\\n    function processMessageFromCrossChainChild(bytes memory data)\\n        public\\n        onlyFromCrossDomainAccount(childMessenger)\\n        nonReentrant()\\n    {\\n        ParentMessengerConsumerInterface(oracleHub).processMessageFromChild(childChainId, data);\\n        emit MessageReceivedFromChild(data, childMessenger, oracleHub);\\n    }\\n\\n    /**\\n     * @notice This function is expected to be queried by Hub contracts that need to determine how much ETH\\n     * to include in msg.value when calling `sendMessageToChild`.\\n     * @return Amount of msg.value to include to send cross-chain message.\\n     */\\n    function getL1CallValue()\\n        public\\n        view\\n        override(ParentMessengerBase, ParentMessengerInterface)\\n        nonReentrantView()\\n        returns (uint256)\\n    {\\n        return _getL1CallValue();\\n    }\\n\\n    // We need to allow this contract to receive ETH, so that it can include some msg.value amount on external calls\\n    // to the `sendMessageToChild` function. We shouldn't expect the owner of this contract to send\\n    // ETH because the owner is intended to be a contract (e.g. the Governor) and we don't want to change the\\n    // Governor interface.\\n    fallback() external payable {}\\n\\n    // Used to determine how much ETH to include in msg.value when calling admin functions like\\n    // `setChildParentMessenger` and sending messages across the bridge.\\n    function _getL1CallValue() internal view returns (uint256) {\\n        // This could overflow if these values are set too high, but since they are configurable by trusted owner\\n        // we won't catch this case.\\n        return defaultMaxSubmissionCost + defaultGasPrice * defaultGasLimit;\\n    }\\n\\n    // This function will only succeed if this contract has enough ETH to cover the approximate L1 call value.\\n    function _sendMessageToChild(bytes memory data, address target) internal {\\n        uint256 requiredL1CallValue = _getL1CallValue();\\n        require(address(this).balance >= requiredL1CallValue, \\\"Insufficient ETH balance\\\");\\n\\n        uint256 seqNumber =\\n            sendTxToL2NoAliassing(\\n                childMessenger,\\n                refundL2Address,\\n                requiredL1CallValue,\\n                defaultMaxSubmissionCost,\\n                defaultGasLimit,\\n                defaultGasPrice,\\n                data\\n            );\\n        emit MessageSentToChild(\\n            data,\\n            target,\\n            requiredL1CallValue,\\n            defaultGasLimit,\\n            defaultGasPrice,\\n            defaultMaxSubmissionCost,\\n            refundL2Address,\\n            childMessenger,\\n            seqNumber\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cross-chain-oracle/chain-adapters/ParentMessengerBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../interfaces/ParentMessengerInterface.sol\\\";\\n\\nabstract contract ParentMessengerBase is Ownable, ParentMessengerInterface {\\n    uint256 public childChainId;\\n\\n    address public childMessenger;\\n\\n    address public oracleHub;\\n    address public governorHub;\\n\\n    address public oracleSpoke;\\n    address public governorSpoke;\\n\\n    event SetChildMessenger(address indexed childMessenger);\\n    event SetOracleHub(address indexed oracleHub);\\n    event SetGovernorHub(address indexed governorHub);\\n    event SetOracleSpoke(address indexed oracleSpoke);\\n    event SetGovernorSpoke(address indexed governorSpoke);\\n\\n    modifier onlyHubContract() {\\n        require(msg.sender == oracleHub || msg.sender == governorHub, \\\"Only privileged caller\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Construct the ParentMessengerBase contract.\\n     * @param _childChainId The chain id of the L2 network this messenger should connect to.\\n     **/\\n    constructor(uint256 _childChainId) {\\n        childChainId = _childChainId;\\n    }\\n\\n    /*******************\\n     *  OWNER METHODS  *\\n     *******************/\\n\\n    /**\\n     * @notice Changes the stored address of the child messenger, deployed on L2.\\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\\n     * @param newChildMessenger address of the new child messenger, deployed on L2.\\n     */\\n    function setChildMessenger(address newChildMessenger) public onlyOwner {\\n        childMessenger = newChildMessenger;\\n        emit SetChildMessenger(childMessenger);\\n    }\\n\\n    /**\\n     * @notice Changes the stored address of the Oracle hub, deployed on L1.\\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\\n     * @param newOracleHub address of the new oracle hub, deployed on L1 Ethereum.\\n     */\\n    function setOracleHub(address newOracleHub) public onlyOwner {\\n        oracleHub = newOracleHub;\\n        emit SetOracleHub(oracleHub);\\n    }\\n\\n    /**\\n     * @notice Changes the stored address of the Governor hub, deployed on L1.\\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\\n     * @param newGovernorHub address of the new governor hub, deployed on L1 Ethereum.\\n     */\\n    function setGovernorHub(address newGovernorHub) public onlyOwner {\\n        governorHub = newGovernorHub;\\n        emit SetGovernorHub(governorHub);\\n    }\\n\\n    /**\\n     * @notice Changes the stored address of the oracle spoke, deployed on L2.\\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\\n     * @param newOracleSpoke address of the new oracle spoke, deployed on L2.\\n     */\\n    function setOracleSpoke(address newOracleSpoke) public onlyOwner {\\n        oracleSpoke = newOracleSpoke;\\n        emit SetOracleSpoke(oracleSpoke);\\n    }\\n\\n    /**\\n     * @notice Changes the stored address of the governor spoke, deployed on L2.\\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\\n     * @param newGovernorSpoke address of the new governor spoke, deployed on L2.\\n     */\\n    function setGovernorSpoke(address newGovernorSpoke) public onlyOwner {\\n        governorSpoke = newGovernorSpoke;\\n        emit SetGovernorSpoke(governorSpoke);\\n    }\\n\\n    /**\\n     * @notice Returns the amount of ETH required for a caller to pass as msg.value when calling `sendMessageToChild`.\\n     * @return The amount of ETH required for a caller to pass as msg.value when calling `sendMessageToChild`.\\n     */\\n    function getL1CallValue() external view virtual override returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cross-chain-oracle/interfaces/ParentMessengerConsumerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\ninterface ParentMessengerConsumerInterface {\\n    // Function called on Oracle hub to pass in data send from L2, with chain ID.\\n    function processMessageFromChild(uint256 chainId, bytes memory data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/cross-chain-oracle/interfaces/ParentMessengerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\ninterface ParentMessengerInterface {\\n    // Should send cross-chain message to Child messenger contract or revert.\\n    function sendMessageToChild(bytes memory data) external;\\n\\n    // Informs Hub how much msg.value they need to include to call `sendMessageToChild`.\\n    function getL1CallValue() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/external/avm/interfaces/iArbitrum_Inbox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\ninterface IBridge {\\n    function activeOutbox() external view returns (address);\\n}\\n\\ninterface iArbitrum_Inbox {\\n    // Retryable tickets are the Arbitrum protocol\u2019s canonical method for passing generalized messages from Ethereum to\\n    // Arbitrum. A retryable ticket is an L2 message encoded and delivered by L1; if gas is provided, it will be executed\\n    // immediately. If no gas is provided or the execution reverts, it will be placed in the L2 retry buffer,\\n    // where any user can re-execute for some fixed period (roughly one week).\\n    // Retryable tickets are created by calling Inbox.createRetryableTicket.\\n    // More details here: https://developer.offchainlabs.com/docs/l1_l2_messages#ethereum-to-arbitrum-retryable-tickets\\n    function createRetryableTicketNoRefundAliasRewrite(\\n        address destAddr,\\n        uint256 l2CallValue,\\n        uint256 maxSubmissionCost,\\n        address excessFeeRefundAddress,\\n        address callValueRefundAddress,\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    function bridge() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/external/avm/interfaces/iArbitrum_Outbox.sol\": {\r\n      \"content\": \"// Copied logic from https://github.com/OffchainLabs/arbitrum-tutorials/blob/4761fa1ba1f1eca95e8c03f24f1442ed5aecd8bd/packages/arb-shared-dependencies/contracts/Outbox.sol\\n// with changes only to the solidity version.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.0;\\n\\ninterface iArbitrum_Outbox {\\n    function l2ToL1Sender() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/insured-bridge/avm/Arbitrum_CrossDomainEnabled.sol\": {\r\n      \"content\": \"// Copied logic from https://github.com/makerdao/arbitrum-dai-bridge/blob/34acc39bc6f3a2da0a837ea3c5dbc634ec61c7de/contracts/l1/L1CrossDomainEnabled.sol\\n// with a change to the solidity version.\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../external/avm/interfaces/iArbitrum_Inbox.sol\\\";\\nimport \\\"../../external/avm/interfaces/iArbitrum_Outbox.sol\\\";\\n\\nabstract contract Arbitrum_CrossDomainEnabled {\\n    iArbitrum_Inbox public immutable inbox;\\n\\n    /**\\n     * @param _inbox Contract that sends generalized messages to the Arbitrum chain.\\n     */\\n    constructor(address _inbox) {\\n        inbox = iArbitrum_Inbox(_inbox);\\n    }\\n\\n    // More details about retryable ticket parameters here: https://developer.offchainlabs.com/docs/l1_l2_messages#parameters\\n    // This function will not apply aliassing to the `user` address on L2.\\n    // Note: If `l1CallValue > 0`, then this contract must contain at least that much ETH to send as msg.value to the\\n    // inbox.\\n    function sendTxToL2NoAliassing(\\n        address target, // Address where transaction will initiate on L2.\\n        address user, // Address where excess gas is credited on L2.\\n        uint256 l1CallValue, // msg.value deposited to `user` on L2.\\n        uint256 maxSubmissionCost, // Amount of ETH allocated to pay for base submission fee. The user is charged this\\n        // fee to cover the storage costs of keeping their retryable ticket's calldata in the retry buffer. This should\\n        // also cover the `l2CallValue`, but we set that to 0. This amount is proportional to the size of `data`.\\n        uint256 maxGas, // Gas limit for immediate L2 execution attempt.\\n        uint256 gasPriceBid, // L2 gas price bid for immediate L2 execution attempt.\\n        bytes memory data // ABI encoded data to send to target.\\n    ) internal returns (uint256) {\\n        // createRetryableTicket API: https://developer.offchainlabs.com/docs/sol_contract_docs/md_docs/arb-bridge-eth/bridge/inbox#createretryableticketaddress-destaddr-uint256-l2callvalue-uint256-maxsubmissioncost-address-excessfeerefundaddress-address-callvaluerefundaddress-uint256-maxgas-uint256-gaspricebid-bytes-data-%E2%86%92-uint256-external\\n        // - address destAddr: destination L2 contract address\\n        // - uint256 l2CallValue: call value for retryable L2 message\\n        // - uint256 maxSubmissionCost: Max gas deducted from user's L2 balance to cover base submission fee\\n        // - address excessFeeRefundAddress: maxgas x gasprice - execution cost gets credited here on L2\\n        // - address callValueRefundAddress: l2CallValue gets credited here on L2 if retryable txn times out or gets cancelled\\n        // - uint256 maxGas: Max gas deducted from user's L2 balance to cover L2 execution\\n        // - uint256 gasPriceBid: price bid for L2 execution\\n        // - bytes data: ABI encoded data of L2 message\\n        uint256 seqNum =\\n            inbox.createRetryableTicketNoRefundAliasRewrite{ value: l1CallValue }(\\n                target,\\n                0, // we always assume that l2CallValue = 0\\n                maxSubmissionCost,\\n                user,\\n                user,\\n                maxGas,\\n                gasPriceBid,\\n                data\\n            );\\n        return seqNum;\\n    }\\n\\n    // Copied mostly from: https://github.com/makerdao/arbitrum-dai-bridge/blob/34acc39bc6f3a2da0a837ea3c5dbc634ec61c7de/contracts/l1/L1CrossDomainEnabled.sol#L31\\n    modifier onlyFromCrossDomainAccount(address l2Counterpart) {\\n        // a message coming from the counterpart gateway was executed by the bridge\\n        IBridge bridge = IBridge(inbox.bridge());\\n        require(msg.sender == address(bridge), \\\"NOT_FROM_BRIDGE\\\");\\n\\n        // and the outbox reports that the L2 address of the sender is the counterpart gateway\\n        address l2ToL1Sender = iArbitrum_Outbox(bridge.activeOutbox()).l2ToL1Sender();\\n        require(l2ToL1Sender == l2Counterpart, \\\"ONLY_COUNTERPART_GATEWAY\\\");\\n        _;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_inbox\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_childChainId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"childMessenger\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"targetHub\",\"type\":\"address\"}],\"name\":\"MessageReceivedFromChild\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"targetSpoke\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"l1CallValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"gasLimit\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSubmissionCost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"refundL2Address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"childMessenger\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sequenceNumber\",\"type\":\"uint256\"}],\"name\":\"MessageSentToChild\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"childMessenger\",\"type\":\"address\"}],\"name\":\"SetChildMessenger\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newDefaultGasLimit\",\"type\":\"uint32\"}],\"name\":\"SetDefaultGasLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDefaultGasPrice\",\"type\":\"uint256\"}],\"name\":\"SetDefaultGasPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxSubmissionCost\",\"type\":\"uint256\"}],\"name\":\"SetDefaultMaxSubmissionCost\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"governorHub\",\"type\":\"address\"}],\"name\":\"SetGovernorHub\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"governorSpoke\",\"type\":\"address\"}],\"name\":\"SetGovernorSpoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracleHub\",\"type\":\"address\"}],\"name\":\"SetOracleHub\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracleSpoke\",\"type\":\"address\"}],\"name\":\"SetOracleSpoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRefundL2Address\",\"type\":\"address\"}],\"name\":\"SetRefundL2Address\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"childChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"childMessenger\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultGasLimit\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultGasPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultMaxSubmissionCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getL1CallValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governorHub\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governorSpoke\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inbox\",\"outputs\":[{\"internalType\":\"contract iArbitrum_Inbox\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleHub\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleSpoke\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"processMessageFromCrossChainChild\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refundL2Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendMessageToChild\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newChildMessenger\",\"type\":\"address\"}],\"name\":\"setChildMessenger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOracleSpoke\",\"type\":\"address\"}],\"name\":\"setChildOracleSpoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newParentMessenger\",\"type\":\"address\"}],\"name\":\"setChildParentMessenger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"newDefaultGasLimit\",\"type\":\"uint32\"}],\"name\":\"setDefaultGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDefaultGasPrice\",\"type\":\"uint256\"}],\"name\":\"setDefaultGasPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDefaultMaxSubmissionCost\",\"type\":\"uint256\"}],\"name\":\"setDefaultMaxSubmissionCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernorHub\",\"type\":\"address\"}],\"name\":\"setGovernorHub\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernorSpoke\",\"type\":\"address\"}],\"name\":\"setGovernorSpoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOracleHub\",\"type\":\"address\"}],\"name\":\"setOracleHub\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOracleSpoke\",\"type\":\"address\"}],\"name\":\"setOracleSpoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRefundl2Address\",\"type\":\"address\"}],\"name\":\"setRefundL2Address\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Arbitrum_ParentMessenger", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "0000000000000000000000004dbd4fc535ac27206064b68ffcf827b0a60bab3f000000000000000000000000000000000000000000000000000000000000a4b1", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}