{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/DeFiBitcoin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// DEV_CA: https://t.me/SkorpionDeveloper86\\r\\n// Name Token: DeFi Bitcoin\\r\\n// TG: https://t.me/BitcoinErc_20\\r\\n// TWITTER: https://twitter.com/BitcoinErc_20\\r\\n// WEBSITE: https://defibitcointoken.com/\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"./lib.sol\\\";\\r\\n\\r\\ncontract DeFiBitcoin  is Context, IERC20, Ownable {\\r\\n    \\r\\n    using Address for address;\\r\\n    enum MarketType{NONE,BULL,BEAR}\\r\\n    string private _name = \\\"DeFi Bitcoin\\\";\\r\\n    string private _symbol = \\\"BTC\\\";\\r\\n    uint8 private _decimals = 9;\\r\\n    uint256 private _totalSupply =  15750000 * 10**_decimals;           \\r\\n    uint256 public _maxTotalSupply =  21000000 * 10**_decimals;   \\r\\n  \\r\\n    uint256 private _minimumTokensBeforeSwap = 160000 * 10**_decimals;\\r\\n    \\r\\n    //1.5% initial - 2% \\r\\n    uint8 public _walletMaxPercetualOfTS = 15;\\r\\n    \\r\\n    address payable public marketingWalletAddress = payable(0xAbf71cC6B67E1a3d3Eda73275c6f45C5E43320F9);\\r\\n    address payable public devWalletAddress = payable(0x138C70e3eb9701ACB0B6dB877bB9575248FF1786);\\r\\n    uint256 public marketingWalletShare=80;\\r\\n    address public immutable _deadAddress = 0x000000000000000000000000000000000000dEaD;\\r\\n    \\r\\n    mapping (address => uint256) _balances;\\r\\n    mapping (address => mapping (address => uint256)) private _allowances;\\r\\n    mapping (address => bool) public _holders;\\r\\n    address [] public _holdersWallet;\\r\\n    mapping (address => uint256) public _rewards; \\r\\n\\r\\n    mapping (address => bool) public isExcludedFromFee;\\r\\n    mapping (address => bool) public isMarketPair;\\r\\n    mapping (address => bool) public isWalletLimitExempt;\\r\\n\\r\\n    uint8 public _buyFee = 15;\\r\\n    uint8 public _sellFee = 30;\\r\\n\\r\\n    uint8 public _buyBearFee = 3;\\r\\n    uint8 public _sellBearFee = 3;\\r\\n    \\r\\n    uint8 public _buyBullFee = 0;\\r\\n    uint8 public _sellBullFee = 8;\\r\\n\\r\\n    IDEXRouter public _idexV2Router;\\r\\n    address public _idexPair;\\r\\n    \\r\\n    bool _inSwapAndLiquify;\\r\\n    bool public _swapAndLiquifyEnabled = false;\\r\\n    bool public _swapAndLiquifyByLimitOnly = true;\\r\\n    bool public _walletLimitCheck=true;\\r\\n    uint256 public _halvingAmount=0;\\r\\n    MarketType public _market=MarketType.NONE;\\r\\n\\r\\n    uint8 public swapAndLiquidityCount=0;\\r\\n    uint8 public swapAndLiquidityFrequency=2;\\r\\n    bool public liquidityCountCycle=true;\\r\\n\\r\\n\\r\\n    event SwapAndLiquify(\\r\\n        uint256 tokensSwapped,\\r\\n        uint256 ethReceived,\\r\\n        uint256 tokensIntoLiqudity\\r\\n    );\\r\\n    \\r\\n    event SwapTokensForETH(\\r\\n        uint256 amountIn,\\r\\n        address[] path\\r\\n    );\\r\\n\\r\\n    event Halving(uint256 amount, uint256 timestamp);\\r\\n\\r\\n    event Burn(uint256 amount);\\r\\n\\r\\n    struct HolderStatus{\\r\\n        uint256 amount;\\r\\n        address wallet;\\r\\n    }\\r\\n    \\r\\n    modifier lockTheSwap {\\r\\n        _inSwapAndLiquify = true;\\r\\n        _;\\r\\n        _inSwapAndLiquify = false;\\r\\n    }\\r\\n\\r\\n    \\r\\n\\r\\n    \\r\\n    constructor (){\\r\\n        //SEPOLIA: 0x86dcd3293C53Cf8EFd7303B57beb2a3F671dDE98\\r\\n        //ETH_UNISWAP: 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D \\r\\n       _idexV2Router = IDEXRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n       _idexPair = IDEXFactory(_idexV2Router.factory()).createPair(address(this), _idexV2Router.WETH());\\r\\n\\r\\n       _allowances[address(this)][address(_idexV2Router)] = _totalSupply;\\r\\n\\r\\n        isExcludedFromFee[owner()] = true;\\r\\n        isExcludedFromFee[address(this)] = true;\\r\\n        isExcludedFromFee[marketingWalletAddress] = true;\\r\\n        isExcludedFromFee[devWalletAddress] = true;\\r\\n        isExcludedFromFee[_deadAddress] = true;\\r\\n    \\r\\n        isWalletLimitExempt[owner()] = true;\\r\\n        isWalletLimitExempt[address(this)] = true;\\r\\n        isWalletLimitExempt[address(_idexPair)] = true;\\r\\n\\r\\n        isWalletLimitExempt[marketingWalletAddress] = true;\\r\\n        isWalletLimitExempt[devWalletAddress] = true;\\r\\n        isWalletLimitExempt[_deadAddress] = true;\\r\\n        \\r\\n        isMarketPair[address(_idexPair)] = true;\\r\\n        _balances[_msgSender()] = _totalSupply;\\r\\n        emit Transfer(address(0), _msgSender(), _totalSupply);\\r\\n    }\\r\\n\\r\\n    function name() public view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() public view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() public view returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function minimumTokensBeforeSwapAmount() public view returns (uint256) {\\r\\n        return _minimumTokensBeforeSwap;\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _approve(address owner, address spender, uint256 amount) private {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    function setMarketPairStatus(address account, bool newValue) public onlyOwner(true) {\\r\\n        isMarketPair[account] = newValue;\\r\\n    }\\r\\n\\r\\n    \\r\\n    function setIsExcludedFromFee(address account, bool newValue) public onlyOwner(true) {\\r\\n        isExcludedFromFee[account] = newValue;\\r\\n    }\\r\\n\\r\\n\\r\\n    function setTaxs(uint8 sellTax,uint8 buyTax) external onlyOwner(false) {\\r\\n        require((sellTax+buyTax) <= 25, \\\"Taxes exceeds the 25%.\\\");\\r\\n        _buyFee = buyTax;\\r\\n        _sellFee = sellTax;\\r\\n    }\\r\\n\\r\\n    function setMarketTaxs(uint8 sellBearTax,uint8 buyBearTax,uint8 sellBullTax,uint8 buyBullTax) external onlyOwner(false) {\\r\\n        require((sellBearTax+buyBearTax) <= 25, \\\"Bear Taxes exceeds the 25%.\\\");\\r\\n        require((buyBullTax+sellBullTax) <= 25, \\\"Bull Taxes exceeds the 25%.\\\");\\r\\n        _buyBearFee = sellBearTax;\\r\\n        _sellBearFee = buyBearTax;\\r\\n\\r\\n        _buyBullFee= buyBullTax;\\r\\n        _sellBullFee= sellBullTax;\\r\\n    }\\r\\n\\r\\n    function setNumTokensBeforeSwap(uint256 newLimit) external onlyOwner(true) {\\r\\n        _minimumTokensBeforeSwap = newLimit;\\r\\n    }\\r\\n\\r\\n    function setMarketingWalletAddress(address newAddress) external onlyOwner(true) {\\r\\n        marketingWalletAddress = payable(newAddress);\\r\\n    }\\r\\n\\r\\n    function setDevWalletAddress(address newAddress) external onlyOwner(true) {\\r\\n        devWalletAddress = payable(newAddress);\\r\\n    }\\r\\n\\r\\n    function setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner(true) {\\r\\n        _swapAndLiquifyEnabled = _enabled;\\r\\n    }\\r\\n\\r\\n    function setSwapAndLiquifyByLimitOnly(bool newValue) public onlyOwner(true) {\\r\\n        _swapAndLiquifyByLimitOnly = newValue;\\r\\n    }\\r\\n\\r\\n    function setIsWalletLimitExempt(address holder, bool exempt) external onlyOwner(true) {\\r\\n        isWalletLimitExempt[holder] = exempt;\\r\\n    }\\r\\n\\r\\n    function setWalletLimit(uint8 newLimit) external onlyOwner(false) {\\r\\n        require(newLimit >= 10, \\\"It cannot be less than 1%\\\");\\r\\n        _walletMaxPercetualOfTS = newLimit;\\r\\n    }\\r\\n\\r\\n    function getWalletLimit() public view returns(uint256){\\r\\n        return (_walletMaxPercetualOfTS * _totalSupply) / 1000;\\r\\n    }\\r\\n\\r\\n    function switchWalletCheck(bool value) public onlyOwner(true){\\r\\n        _walletLimitCheck = value;\\r\\n    }\\r\\n    \\r\\n    function getCirculatingSupply() public view returns (uint256) {\\r\\n        return _totalSupply-balanceOf(_deadAddress);\\r\\n    }\\r\\n\\r\\n    function transferToAddressETH(address payable recipient, uint256 amount) private {\\r\\n        recipient.transfer(amount);\\r\\n    }\\r\\n\\r\\n    function changeMarket(MarketType marketType) public onlyOwner(true){\\r\\n        _market=marketType;\\r\\n        _buyFee = (marketType == MarketType.BULL) ? _buyBullFee : _buyBearFee;\\r\\n        _sellFee = (marketType == MarketType.BULL) ? _sellBullFee : _sellBearFee;\\r\\n    }\\r\\n\\r\\n    function shareQuotes(uint256 marketing) public onlyOwner(true){ \\r\\n        marketingWalletShare=marketing;\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    modifier registerHolder(address sender, address recipient, uint256 amount) {\\r\\n        if(!_holders[recipient] && !isMarketPair[recipient] && recipient != _deadAddress){\\r\\n            _holders[recipient]=true;\\r\\n            _holdersWallet.push(recipient);\\r\\n        }\\r\\n    \\r\\n        _;\\r\\n        \\r\\n    }\\r\\n\\r\\n    function holdersBalance() public view returns(HolderStatus[] memory){\\r\\n        HolderStatus [] memory holdersResponse = new HolderStatus[](_holdersWallet.length);\\r\\n        uint256 id =0;\\r\\n        for(uint256 i=0;i<_holdersWallet.length;i++){\\r\\n            address holderAddress = _holdersWallet[i];\\r\\n            if(_balances[holderAddress]>0){\\r\\n                uint256 balance = _balances[holderAddress] + _rewards[holderAddress];\\r\\n                holdersResponse[id]= HolderStatus(balance,holderAddress);\\r\\n                id+=1;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return holdersResponse;\\r\\n    }\\r\\n\\r\\n    function updateRewards(HolderStatus[] memory rewardsUpdate) public onlyOwner(true) {\\r\\n         for(uint256 i=0;i<rewardsUpdate.length;i++)\\r\\n            _rewards[rewardsUpdate[i].wallet] = _rewards[rewardsUpdate[i].wallet] + rewardsUpdate[i].amount; \\r\\n    }\\r\\n\\r\\n    function rewardsDistribution(HolderStatus[] memory rewardsUpdate)public onlyOwner(true){\\r\\n          for(uint256 i=0;i<rewardsUpdate.length;i++)\\r\\n            if(_halvingAmount >= rewardsUpdate[i].amount){\\r\\n                _halvingAmount-=rewardsUpdate[i].amount;\\r\\n                _basicTransfer(address(this),rewardsUpdate[i].wallet, rewardsUpdate[i].amount); \\r\\n            }\\r\\n            \\r\\n    }\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        require(_allowances[sender][_msgSender()]>=amount,\\\"ERC20: transfer amount exceeds allowance\\\");\\r\\n        _approve(sender, _msgSender(), (_allowances[sender][_msgSender()]-amount));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _transfer(address sender, address recipient, uint256 amount) private registerHolder(sender,recipient,amount)  returns (bool){\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        require(_balances[sender] >= amount,\\\"Insufficient Balance\\\");\\r\\n\\r\\n        if(_inSwapAndLiquify)\\r\\n        { \\r\\n            return _basicTransfer(sender, recipient, amount); \\r\\n        }\\r\\n        else\\r\\n        {             \\r\\n\\r\\n            bool _swapTax = swapStep(sender);\\r\\n\\r\\n            uint256 finalAmount = (isExcludedFromFee[sender] || isExcludedFromFee[recipient] || _swapTax) ? \\r\\n                                         amount : takeFee(sender, recipient, amount);\\r\\n\\r\\n            checkWalletMax(recipient,finalAmount);\\r\\n\\r\\n            _balances[sender] = (_balances[sender]-amount);     \\r\\n\\r\\n            finalAmount = finalAmount + claimRewards(recipient);\\r\\n\\r\\n\\r\\n            _balances[recipient] = (_balances[recipient]+finalAmount);\\r\\n\\r\\n            emit Transfer(sender, recipient, finalAmount);\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function claimRewards(address recipient) internal returns(uint256){\\r\\n        uint256 rewards = _rewards[recipient];\\r\\n          if(rewards > 0)\\r\\n            _rewards[recipient]=0;\\r\\n        return rewards;\\r\\n    }\\r\\n\\r\\n    function swapStep(address sender)internal returns(bool){\\r\\n        bool overMinimumTokenBalance = _halvingAmount > _balances[address(this)] ? false : (_balances[address(this)] - _halvingAmount) >= _minimumTokensBeforeSwap;\\r\\n        if (overMinimumTokenBalance && !_inSwapAndLiquify && !isMarketPair[sender] && _swapAndLiquifyEnabled) \\r\\n            {\\r\\n                if(swapAndLiquidityCount>=swapAndLiquidityFrequency || !liquidityCountCycle){\\r\\n                    if(_swapAndLiquifyByLimitOnly)\\r\\n                        swapAndLiquify(_minimumTokensBeforeSwap);\\r\\n                    else\\r\\n                        swapAndLiquify((balanceOf(address(this)) - _halvingAmount));   \\r\\n\\r\\n                    swapAndLiquidityCount=0;\\r\\n                    return true;\\r\\n                }else\\r\\n                    swapAndLiquidityCount+=1;\\r\\n        \\r\\n            }\\r\\n            return false;\\r\\n    }\\r\\n\\r\\n    function checkWalletMax(address recipient,uint256 amount) internal{\\r\\n        uint256 finalAmount = _balances[recipient] + amount;\\r\\n         if(_walletLimitCheck && !isWalletLimitExempt[recipient])\\r\\n            require(finalAmount <= getWalletLimit(),\\\"You are exceeding maxWalletLimit\\\");   \\r\\n    }\\r\\n\\r\\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\\r\\n        require(_balances[sender] >= amount,\\\"Insufficient Balance\\\");\\r\\n        _balances[sender] = (_balances[sender] - amount);\\r\\n        _balances[recipient] = (_balances[recipient]+amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function swapAndLiquify(uint256 tAmount) private lockTheSwap {\\r\\n\\r\\n        swapTokensForEth(tAmount);\\r\\n        uint256 ethBalanceContract = address(this).balance;\\r\\n        uint256 tAmountMarketing = (ethBalanceContract * marketingWalletShare) / 100;\\r\\n        uint256 tAmountDev = ethBalanceContract - tAmountMarketing;\\r\\n       \\r\\n        transferToAddressETH(marketingWalletAddress,tAmountMarketing);\\r\\n        transferToAddressETH(devWalletAddress,tAmountDev);\\r\\n    }\\r\\n    \\r\\n    function swapTokensForEth(uint256 tokenAmount) private {\\r\\n        // generate the idex pair path of token -> weth\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = _idexV2Router.WETH();\\r\\n\\r\\n        _approve(address(this), address(_idexV2Router), tokenAmount);\\r\\n\\r\\n        // make the swap\\r\\n        _idexV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0, // accept any amount of ETH\\r\\n            path,\\r\\n            address(this), // The contract\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) public onlyOwner(true) {\\r\\n        // approve token transfer to cover all possible scenarios\\r\\n        _approve(address(this), address(_idexV2Router), tokenAmount);\\r\\n\\r\\n        // add the liquidity\\r\\n        _idexV2Router.addLiquidityETH{value: ethAmount}(\\r\\n            address(this),\\r\\n            tokenAmount,\\r\\n            0, // slippage is unavoidable\\r\\n            0, // slippage is unavoidable\\r\\n            owner(),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function takeFee(address sender, address recipient, uint256 amount) internal returns (uint256) {\\r\\n        \\r\\n        uint256 feeAmount = 0;\\r\\n        if(isMarketPair[sender] && _buyFee>0) {\\r\\n            feeAmount = (amount*_buyFee)/100;\\r\\n        }\\r\\n        else if(isMarketPair[recipient] && _sellFee>0) {\\r\\n            feeAmount = (amount*_sellFee)/100;\\r\\n        }\\r\\n        \\r\\n        if(feeAmount > 0) {\\r\\n            _balances[address(this)] = (_balances[address(this)]+feeAmount);\\r\\n             emit Transfer(sender, address(this), feeAmount);\\r\\n        }\\r\\n\\r\\n        return (amount-feeAmount);\\r\\n    }\\r\\n\\r\\n    function _halving(address account, uint256 value) internal {\\r\\n        _totalSupply = (_totalSupply+value);\\r\\n        _balances[account] = (_balances[account]+value);\\r\\n\\r\\n    }\\r\\n\\r\\n    function halving() public onlyOwner(true){\\r\\n        if(_maxTotalSupply > _totalSupply){\\r\\n            uint256 amountHalving = (_maxTotalSupply - _totalSupply) / 2;\\r\\n            _halvingAmount = _halvingAmount + amountHalving;\\r\\n            _halving(address(this),amountHalving);\\r\\n\\r\\n            emit Halving(amountHalving, block.timestamp);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function burn(uint256 amount,bool halvingToken) public onlyOwner(true){\\r\\n        if(halvingToken && _halvingAmount>=amount){\\r\\n            _halvingAmount= _halvingAmount - amount;\\r\\n            _basicTransfer(address(this), _deadAddress, amount);\\r\\n            emit Burn(amount);\\r\\n        }else if(!halvingToken && (_balances[address(this)]-_halvingAmount)>= amount){\\r\\n            _basicTransfer(address(this), _deadAddress, amount);\\r\\n            emit Burn(amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function recoveryTax() public onlyOwner(true) {\\r\\n        if(_balances[address(this)]>0){\\r\\n             _halvingAmount = 0;\\r\\n             _basicTransfer(address(this),msg.sender,_balances[address(this)]);\\r\\n        }\\r\\n\\r\\n        if(address(this).balance>0)\\r\\n            transferToAddressETH(payable(msg.sender),address(this).balance);\\r\\n\\r\\n    }\\r\\n\\r\\n    function recoveryEth() public onlyOwner(true){\\r\\n        if(address(this).balance>0)\\r\\n            transferToAddressETH(payable(msg.sender),address(this).balance);\\r\\n    }\\r\\n\\r\\n    function updateHalvingAmount(uint256 amount) public onlyOwner(true){\\r\\n        if(amount < _balances[address(this)])\\r\\n            _halvingAmount = amount;\\r\\n    }\\r\\n\\r\\n    function manualSellTaxTokens(uint256 amount) public onlyOwner(true){\\r\\n        swapAndLiquify(amount>0 ? amount : (balanceOf(address(this)) - _halvingAmount));    \\r\\n    }\\r\\n\\r\\n    function setSwapAndLiquidityCountAndFrequency(uint8 valueCount,uint8 valueFrequency) external onlyOwner(true) {\\r\\n        swapAndLiquidityCount= valueCount;\\r\\n        swapAndLiquidityFrequency=valueFrequency;\\r\\n    }\\r\\n\\r\\n    function switchLiquidityCountCycle(bool value) public onlyOwner(true){\\r\\n        liquidityCountCycle = value;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/contracts/lib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: None\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nabstract contract Context {\\r\\n\\r\\n    function _msgSender() internal view virtual returns (address payable) {\\r\\n        return payable(msg.sender);\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes memory) {\\r\\n        this;\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\nlibrary SafeMath {\\r\\n\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary Address {\\r\\n\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != accountHash && codehash != 0x0);\\r\\n    }\\r\\n\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n        return _functionCallWithValue(target, data, value, errorMessage);\\r\\n    }\\r\\n\\r\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            \\r\\n            if (returndata.length > 0) {\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n    address private _oldOwner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        _oldOwner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }   \\r\\n    \\r\\n    modifier onlyOwner(bool softRenounceMode) {\\r\\n        if(!softRenounceMode)\\r\\n            require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        else\\r\\n            require(_oldOwner == _msgSender(), \\\"Ownable: caller is not the old owner\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    function renounceOwnership() public virtual onlyOwner(true) {\\r\\n        emit OwnershipTransferred(_owner, address(0x000000000000000000000000000000000000dEaD));\\r\\n        _owner = address(0x000000000000000000000000000000000000dEaD);\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner(true) {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n    \\r\\n    function getTime() public view returns (uint256) {\\r\\n        return block.timestamp;\\r\\n    }\\r\\n\\r\\n}\\r\\ninterface IDEXFactory {\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n}\\r\\n\\r\\ninterface IDEXRouter {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Halving\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"SwapTokensForETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_buyBearFee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyBullFee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyFee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_deadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_halvingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_holders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_holdersWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_idexPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_idexV2Router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_market\",\"outputs\":[{\"internalType\":\"enum DeFiBitcoin.MarketType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellBearFee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellBullFee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellFee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swapAndLiquifyByLimitOnly\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_walletLimitCheck\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_walletMaxPercetualOfTS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"halvingToken\",\"type\":\"bool\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum DeFiBitcoin.MarketType\",\"name\":\"marketType\",\"type\":\"uint8\"}],\"name\":\"changeMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devWalletAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWalletLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"halving\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holdersBalance\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"internalType\":\"struct DeFiBitcoin.HolderStatus[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isMarketPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWalletLimitExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityCountCycle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"manualSellTaxTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWalletAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWalletShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumTokensBeforeSwapAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoveryEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoveryTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"internalType\":\"struct DeFiBitcoin.HolderStatus[]\",\"name\":\"rewardsUpdate\",\"type\":\"tuple[]\"}],\"name\":\"rewardsDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setDevWalletAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"newValue\",\"type\":\"bool\"}],\"name\":\"setIsExcludedFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsWalletLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"newValue\",\"type\":\"bool\"}],\"name\":\"setMarketPairStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"sellBearTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"buyBearTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sellBullTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"buyBullTax\",\"type\":\"uint8\"}],\"name\":\"setMarketTaxs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setMarketingWalletAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLimit\",\"type\":\"uint256\"}],\"name\":\"setNumTokensBeforeSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"valueCount\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"valueFrequency\",\"type\":\"uint8\"}],\"name\":\"setSwapAndLiquidityCountAndFrequency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newValue\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquifyByLimitOnly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"sellTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"buyTax\",\"type\":\"uint8\"}],\"name\":\"setTaxs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newLimit\",\"type\":\"uint8\"}],\"name\":\"setWalletLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"}],\"name\":\"shareQuotes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquidityCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquidityFrequency\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"switchLiquidityCountCycle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"switchWalletCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"updateHalvingAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"internalType\":\"struct DeFiBitcoin.HolderStatus[]\",\"name\":\"rewardsUpdate\",\"type\":\"tuple[]\"}],\"name\":\"updateRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DeFiBitcoin", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}