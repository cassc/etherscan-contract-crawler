{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@ensdomains/buffer/contracts/Buffer.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\n/**\\n* @dev A library for working with mutable byte buffers in Solidity.\\n*\\n* Byte buffers are mutable and expandable, and provide a variety of primitives\\n* for writing to them. At any time you can fetch a bytes object containing the\\n* current contents of the buffer. The bytes object should not be stored between\\n* operations, as it may change due to resizing of the buffer.\\n*/\\nlibrary Buffer {\\n    /**\\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\\n    *      a capacity. The capacity may be longer than the current value, in\\n    *      which case it can be extended without the need to allocate more memory.\\n    */\\n    struct buffer {\\n        bytes buf;\\n        uint capacity;\\n    }\\n\\n    /**\\n    * @dev Initializes a buffer with an initial capacity.\\n    * @param buf The buffer to initialize.\\n    * @param capacity The number of bytes of space to allocate the buffer.\\n    * @return The buffer, for chaining.\\n    */\\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\\n        if (capacity % 32 != 0) {\\n            capacity += 32 - (capacity % 32);\\n        }\\n        // Allocate space for the buffer data\\n        buf.capacity = capacity;\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(buf, ptr)\\n            mstore(ptr, 0)\\n            mstore(0x40, add(32, add(ptr, capacity)))\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Initializes a new buffer from an existing bytes object.\\n    *      Changes to the buffer may mutate the original value.\\n    * @param b The bytes object to initialize the buffer with.\\n    * @return A new buffer.\\n    */\\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\\n        buffer memory buf;\\n        buf.buf = b;\\n        buf.capacity = b.length;\\n        return buf;\\n    }\\n\\n    function resize(buffer memory buf, uint capacity) private pure {\\n        bytes memory oldbuf = buf.buf;\\n        init(buf, capacity);\\n        append(buf, oldbuf);\\n    }\\n\\n    function max(uint a, uint b) private pure returns(uint) {\\n        if (a > b) {\\n            return a;\\n        }\\n        return b;\\n    }\\n\\n    /**\\n    * @dev Sets buffer length to 0.\\n    * @param buf The buffer to truncate.\\n    * @return The original buffer, for chaining..\\n    */\\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\\n        assembly {\\n            let bufptr := mload(buf)\\n            mstore(bufptr, 0)\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The start offset to write to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to copy.\\n    * @return The original buffer, for chaining.\\n    */\\n    function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns(buffer memory) {\\n        require(len <= data.length);\\n\\n        if (off + len > buf.capacity) {\\n            resize(buf, max(buf.capacity, len + off) * 2);\\n        }\\n\\n        uint dest;\\n        uint src;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Start address = buffer address + offset + sizeof(buffer length)\\n            dest := add(add(bufptr, 32), off)\\n            // Update buffer length if we're extending it\\n            if gt(add(len, off), buflen) {\\n                mstore(bufptr, add(len, off))\\n            }\\n            src := add(data, 32)\\n        }\\n\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        unchecked {\\n            uint mask = (256 ** (32 - len)) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask))\\n                let destpart := and(mload(dest), mask)\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to copy.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, data, len);\\n    }\\n\\n    /**\\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, data, data.length);\\n    }\\n\\n    /**\\n    * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\\n    *      capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The offset to write the byte at.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function writeUint8(buffer memory buf, uint off, uint8 data) internal pure returns(buffer memory) {\\n        if (off >= buf.capacity) {\\n            resize(buf, buf.capacity * 2);\\n        }\\n\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Address = buffer address + sizeof(buffer length) + off\\n            let dest := add(add(bufptr, off), 32)\\n            mstore8(dest, data)\\n            // Update buffer length if we extended it\\n            if eq(off, buflen) {\\n                mstore(bufptr, add(buflen, 1))\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\\n    *      capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\\n        return writeUint8(buf, buf.buf.length, data);\\n    }\\n\\n    /**\\n    * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\\n    *      exceed the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The offset to write at.\\n    * @param data The data to append.\\n    * @param len The number of bytes to write (left-aligned).\\n    * @return The original buffer, for chaining.\\n    */\\n    function write(buffer memory buf, uint off, bytes32 data, uint len) private pure returns(buffer memory) {\\n        if (len + off > buf.capacity) {\\n            resize(buf, (len + off) * 2);\\n        }\\n\\n        unchecked {\\n            uint mask = (256 ** len) - 1;\\n            // Right-align data\\n            data = data >> (8 * (32 - len));\\n            assembly {\\n                // Memory address of the buffer data\\n                let bufptr := mload(buf)\\n                // Address = buffer address + sizeof(buffer length) + off + len\\n                let dest := add(add(bufptr, off), len)\\n                mstore(dest, or(and(mload(dest), not(mask)), data))\\n                // Update buffer length if we extended it\\n                if gt(add(off, len), mload(bufptr)) {\\n                    mstore(bufptr, add(off, len))\\n                }\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\\n    *      capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The offset to write at.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function writeBytes20(buffer memory buf, uint off, bytes20 data) internal pure returns (buffer memory) {\\n        return write(buf, off, bytes32(data), 20);\\n    }\\n\\n    /**\\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chhaining.\\n    */\\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, bytes32(data), 20);\\n    }\\n\\n    /**\\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, data, 32);\\n    }\\n\\n    /**\\n    * @dev Writes an integer to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The offset to write at.\\n    * @param data The data to append.\\n    * @param len The number of bytes to write (right-aligned).\\n    * @return The original buffer, for chaining.\\n    */\\n    function writeInt(buffer memory buf, uint off, uint data, uint len) private pure returns(buffer memory) {\\n        if (len + off > buf.capacity) {\\n            resize(buf, (len + off) * 2);\\n        }\\n\\n        uint mask = (256 ** len) - 1;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Address = buffer address + off + sizeof(buffer length) + len\\n            let dest := add(add(bufptr, off), len)\\n            mstore(dest, or(and(mload(dest), not(mask)), data))\\n            // Update buffer length if we extended it\\n            if gt(add(off, len), mload(bufptr)) {\\n                mstore(bufptr, add(off, len))\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\n     * exceed the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param data The data to append.\\n     * @return The original buffer.\\n     */\\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\\n        return writeInt(buf, buf.buf.length, data, len);\\n    }\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/dnssec-oracle/BytesUtils.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\nlibrary BytesUtils {\\n    /*\\n    * @dev Returns the keccak-256 hash of a byte range.\\n    * @param self The byte string to hash.\\n    * @param offset The position to start hashing at.\\n    * @param len The number of bytes to hash.\\n    * @return The hash of the byte range.\\n    */\\n    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {\\n        require(offset + len <= self.length);\\n        assembly {\\n            ret := keccak256(add(add(self, 32), offset), len)\\n        }\\n    }\\n\\n\\n    /*\\n    * @dev Returns a positive number if `other` comes lexicographically after\\n    *      `self`, a negative number if it comes before, or zero if the\\n    *      contents of the two bytes are equal.\\n    * @param self The first bytes to compare.\\n    * @param other The second bytes to compare.\\n    * @return The result of the comparison.\\n    */\\n    function compare(bytes memory self, bytes memory other) internal pure returns (int) {\\n        return compare(self, 0, self.length, other, 0, other.length);\\n    }\\n\\n    /*\\n    * @dev Returns a positive number if `other` comes lexicographically after\\n    *      `self`, a negative number if it comes before, or zero if the\\n    *      contents of the two bytes are equal. Comparison is done per-rune,\\n    *      on unicode codepoints.\\n    * @param self The first bytes to compare.\\n    * @param offset The offset of self.\\n    * @param len    The length of self.\\n    * @param other The second bytes to compare.\\n    * @param otheroffset The offset of the other string.\\n    * @param otherlen    The length of the other string.\\n    * @return The result of the comparison.\\n    */\\n    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {\\n        uint shortest = len;\\n        if (otherlen < len)\\n        shortest = otherlen;\\n\\n        uint selfptr;\\n        uint otherptr;\\n\\n        assembly {\\n            selfptr := add(self, add(offset, 32))\\n            otherptr := add(other, add(otheroffset, 32))\\n        }\\n        for (uint idx = 0; idx < shortest; idx += 32) {\\n            uint a;\\n            uint b;\\n            assembly {\\n                a := mload(selfptr)\\n                b := mload(otherptr)\\n            }\\n            if (a != b) {\\n                // Mask out irrelevant bytes and check again\\n                uint mask;\\n                if (shortest > 32) {\\n                    mask = type(uint256).max;\\n                } else {\\n                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\\n                }\\n                int diff = int(a & mask) - int(b & mask);\\n                if (diff != 0)\\n                return diff;\\n            }\\n            selfptr += 32;\\n            otherptr += 32;\\n        }\\n\\n        return int(len) - int(otherlen);\\n    }\\n\\n    /*\\n    * @dev Returns true if the two byte ranges are equal.\\n    * @param self The first byte range to compare.\\n    * @param offset The offset into the first byte range.\\n    * @param other The second byte range to compare.\\n    * @param otherOffset The offset into the second byte range.\\n    * @param len The number of bytes to compare\\n    * @return True if the byte ranges are equal, false otherwise.\\n    */\\n    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {\\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\\n    }\\n\\n    /*\\n    * @dev Returns true if the two byte ranges are equal with offsets.\\n    * @param self The first byte range to compare.\\n    * @param offset The offset into the first byte range.\\n    * @param other The second byte range to compare.\\n    * @param otherOffset The offset into the second byte range.\\n    * @return True if the byte ranges are equal, false otherwise.\\n    */\\n    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {\\n        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);\\n    }\\n\\n    /*\\n    * @dev Compares a range of 'self' to all of 'other' and returns True iff\\n    *      they are equal.\\n    * @param self The first byte range to compare.\\n    * @param offset The offset into the first byte range.\\n    * @param other The second byte range to compare.\\n    * @return True if the byte ranges are equal, false otherwise.\\n    */\\n    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {\\n        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);\\n    }\\n\\n    /*\\n    * @dev Returns true if the two byte ranges are equal.\\n    * @param self The first byte range to compare.\\n    * @param other The second byte range to compare.\\n    * @return True if the byte ranges are equal, false otherwise.\\n    */\\n    function equals(bytes memory self, bytes memory other) internal pure returns(bool) {\\n        return self.length == other.length && equals(self, 0, other, 0, self.length);\\n    }\\n\\n    /*\\n    * @dev Returns the 8-bit number at the specified index of self.\\n    * @param self The byte string.\\n    * @param idx The index into the bytes\\n    * @return The specified 8 bits of the string, interpreted as an integer.\\n    */\\n    function readUint8(bytes memory self, uint idx) internal pure returns (uint8 ret) {\\n        return uint8(self[idx]);\\n    }\\n\\n    /*\\n    * @dev Returns the 16-bit number at the specified index of self.\\n    * @param self The byte string.\\n    * @param idx The index into the bytes\\n    * @return The specified 16 bits of the string, interpreted as an integer.\\n    */\\n    function readUint16(bytes memory self, uint idx) internal pure returns (uint16 ret) {\\n        require(idx + 2 <= self.length);\\n        assembly {\\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\\n        }\\n    }\\n\\n    /*\\n    * @dev Returns the 32-bit number at the specified index of self.\\n    * @param self The byte string.\\n    * @param idx The index into the bytes\\n    * @return The specified 32 bits of the string, interpreted as an integer.\\n    */\\n    function readUint32(bytes memory self, uint idx) internal pure returns (uint32 ret) {\\n        require(idx + 4 <= self.length);\\n        assembly {\\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\\n        }\\n    }\\n\\n    /*\\n    * @dev Returns the 32 byte value at the specified index of self.\\n    * @param self The byte string.\\n    * @param idx The index into the bytes\\n    * @return The specified 32 bytes of the string.\\n    */\\n    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {\\n        require(idx + 32 <= self.length);\\n        assembly {\\n            ret := mload(add(add(self, 32), idx))\\n        }\\n    }\\n\\n    /*\\n    * @dev Returns the 32 byte value at the specified index of self.\\n    * @param self The byte string.\\n    * @param idx The index into the bytes\\n    * @return The specified 32 bytes of the string.\\n    */\\n    function readBytes20(bytes memory self, uint idx) internal pure returns (bytes20 ret) {\\n        require(idx + 20 <= self.length);\\n        assembly {\\n            ret := and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)\\n        }\\n    }\\n\\n    /*\\n    * @dev Returns the n byte value at the specified index of self.\\n    * @param self The byte string.\\n    * @param idx The index into the bytes.\\n    * @param len The number of bytes.\\n    * @return The specified 32 bytes of the string.\\n    */\\n    function readBytesN(bytes memory self, uint idx, uint len) internal pure returns (bytes32 ret) {\\n        require(len <= 32);\\n        require(idx + len <= self.length);\\n        assembly {\\n            let mask := not(sub(exp(256, sub(32, len)), 1))\\n            ret := and(mload(add(add(self, 32), idx)),  mask)\\n        }\\n    }\\n\\n    function memcpy(uint dest, uint src, uint len) private pure {\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        unchecked {\\n            uint mask = (256 ** (32 - len)) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask))\\n                let destpart := and(mload(dest), mask)\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n    }\\n\\n    /*\\n    * @dev Copies a substring into a new byte string.\\n    * @param self The byte string to copy from.\\n    * @param offset The offset to start copying at.\\n    * @param len The number of bytes to copy.\\n    */\\n    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes memory) {\\n        require(offset + len <= self.length);\\n\\n        bytes memory ret = new bytes(len);\\n        uint dest;\\n        uint src;\\n\\n        assembly {\\n            dest := add(ret, 32)\\n            src := add(add(self, 32), offset)\\n        }\\n        memcpy(dest, src, len);\\n\\n        return ret;\\n    }\\n\\n    // Maps characters from 0x30 to 0x7A to their base32 values.\\n    // 0xFF represents invalid characters in that range.\\n    bytes constant base32HexTable = hex'00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F';\\n\\n    /**\\n     * @dev Decodes unpadded base32 data of up to one word in length.\\n     * @param self The data to decode.\\n     * @param off Offset into the string to start at.\\n     * @param len Number of characters to decode.\\n     * @return The decoded data, left aligned.\\n     */\\n    function base32HexDecodeWord(bytes memory self, uint off, uint len) internal pure returns(bytes32) {\\n        require(len <= 52);\\n\\n        uint ret = 0;\\n        uint8 decoded;\\n        for(uint i = 0; i < len; i++) {\\n            bytes1 char = self[off + i];\\n            require(char >= 0x30 && char <= 0x7A);\\n            decoded = uint8(base32HexTable[uint(uint8(char)) - 0x30]);\\n            require(decoded <= 0x20);\\n            if(i == len - 1) {\\n                break;\\n            }\\n            ret = (ret << 5) | decoded;\\n        }\\n\\n        uint bitlen = len * 5;\\n        if(len % 8 == 0) {\\n            // Multiple of 8 characters, no padding\\n            ret = (ret << 5) | decoded;\\n        } else if(len % 8 == 2) {\\n            // Two extra characters - 1 byte\\n            ret = (ret << 3) | (decoded >> 2);\\n            bitlen -= 2;\\n        } else if(len % 8 == 4) {\\n            // Four extra characters - 2 bytes\\n            ret = (ret << 1) | (decoded >> 4);\\n            bitlen -= 4;\\n        } else if(len % 8 == 5) {\\n            // Five extra characters - 3 bytes\\n            ret = (ret << 4) | (decoded >> 1);\\n            bitlen -= 1;\\n        } else if(len % 8 == 7) {\\n            // Seven extra characters - 4 bytes\\n            ret = (ret << 2) | (decoded >> 3);\\n            bitlen -= 3;\\n        } else {\\n            revert();\\n        }\\n\\n        return bytes32(ret << (256 - bitlen));\\n    }\\n}\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/dnssec-oracle/RRUtils.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\nimport \\\"./BytesUtils.sol\\\";\\nimport \\\"@ensdomains/buffer/contracts/Buffer.sol\\\";\\n\\n/**\\n* @dev RRUtils is a library that provides utilities for parsing DNS resource records.\\n*/\\nlibrary RRUtils {\\n    using BytesUtils for *;\\n    using Buffer for *;\\n\\n    /**\\n    * @dev Returns the number of bytes in the DNS name at 'offset' in 'self'.\\n    * @param self The byte array to read a name from.\\n    * @param offset The offset to start reading at.\\n    * @return The length of the DNS name at 'offset', in bytes.\\n    */\\n    function nameLength(bytes memory self, uint offset) internal pure returns(uint) {\\n        uint idx = offset;\\n        while (true) {\\n            assert(idx < self.length);\\n            uint labelLen = self.readUint8(idx);\\n            idx += labelLen + 1;\\n            if (labelLen == 0) {\\n                break;\\n            }\\n        }\\n        return idx - offset;\\n    }\\n\\n    /**\\n    * @dev Returns a DNS format name at the specified offset of self.\\n    * @param self The byte array to read a name from.\\n    * @param offset The offset to start reading at.\\n    * @return ret The name.\\n    */\\n    function readName(bytes memory self, uint offset) internal pure returns(bytes memory ret) {\\n        uint len = nameLength(self, offset);\\n        return self.substring(offset, len);\\n    }\\n\\n    /**\\n    * @dev Returns the number of labels in the DNS name at 'offset' in 'self'.\\n    * @param self The byte array to read a name from.\\n    * @param offset The offset to start reading at.\\n    * @return The number of labels in the DNS name at 'offset', in bytes.\\n    */\\n    function labelCount(bytes memory self, uint offset) internal pure returns(uint) {\\n        uint count = 0;\\n        while (true) {\\n            assert(offset < self.length);\\n            uint labelLen = self.readUint8(offset);\\n            offset += labelLen + 1;\\n            if (labelLen == 0) {\\n                break;\\n            }\\n            count += 1;\\n        }\\n        return count;\\n    }\\n\\n    uint constant RRSIG_TYPE = 0;\\n    uint constant RRSIG_ALGORITHM = 2;\\n    uint constant RRSIG_LABELS = 3;\\n    uint constant RRSIG_TTL = 4;\\n    uint constant RRSIG_EXPIRATION = 8;\\n    uint constant RRSIG_INCEPTION = 12;\\n    uint constant RRSIG_KEY_TAG = 16;\\n    uint constant RRSIG_SIGNER_NAME = 18;\\n\\n    struct SignedSet {\\n        uint16 typeCovered;\\n        uint8 algorithm;\\n        uint8 labels;\\n        uint32 ttl;\\n        uint32 expiration;\\n        uint32 inception;\\n        uint16 keytag;\\n        bytes signerName;\\n        bytes data;\\n        bytes name;\\n    }\\n\\n    function readSignedSet(bytes memory data) internal pure returns(SignedSet memory self) {\\n        self.typeCovered = data.readUint16(RRSIG_TYPE);\\n        self.algorithm = data.readUint8(RRSIG_ALGORITHM);\\n        self.labels = data.readUint8(RRSIG_LABELS);\\n        self.ttl = data.readUint32(RRSIG_TTL);\\n        self.expiration = data.readUint32(RRSIG_EXPIRATION);\\n        self.inception = data.readUint32(RRSIG_INCEPTION);\\n        self.keytag = data.readUint16(RRSIG_KEY_TAG);\\n        self.signerName = readName(data, RRSIG_SIGNER_NAME);\\n        self.data = data.substring(RRSIG_SIGNER_NAME + self.signerName.length, data.length - RRSIG_SIGNER_NAME - self.signerName.length);\\n    }\\n\\n    function rrs(SignedSet memory rrset) internal pure returns(RRIterator memory) {\\n        return iterateRRs(rrset.data, 0);\\n    }\\n\\n    /**\\n    * @dev An iterator over resource records.\\n    */\\n    struct RRIterator {\\n        bytes data;\\n        uint offset;\\n        uint16 dnstype;\\n        uint16 class;\\n        uint32 ttl;\\n        uint rdataOffset;\\n        uint nextOffset;\\n    }\\n\\n    /**\\n    * @dev Begins iterating over resource records.\\n    * @param self The byte string to read from.\\n    * @param offset The offset to start reading at.\\n    * @return ret An iterator object.\\n    */\\n    function iterateRRs(bytes memory self, uint offset) internal pure returns (RRIterator memory ret) {\\n        ret.data = self;\\n        ret.nextOffset = offset;\\n        next(ret);\\n    }\\n\\n    /**\\n    * @dev Returns true iff there are more RRs to iterate.\\n    * @param iter The iterator to check.\\n    * @return True iff the iterator has finished.\\n    */\\n    function done(RRIterator memory iter) internal pure returns(bool) {\\n        return iter.offset >= iter.data.length;\\n    }\\n\\n    /**\\n    * @dev Moves the iterator to the next resource record.\\n    * @param iter The iterator to advance.\\n    */\\n    function next(RRIterator memory iter) internal pure {\\n        iter.offset = iter.nextOffset;\\n        if (iter.offset >= iter.data.length) {\\n            return;\\n        }\\n\\n        // Skip the name\\n        uint off = iter.offset + nameLength(iter.data, iter.offset);\\n\\n        // Read type, class, and ttl\\n        iter.dnstype = iter.data.readUint16(off);\\n        off += 2;\\n        iter.class = iter.data.readUint16(off);\\n        off += 2;\\n        iter.ttl = iter.data.readUint32(off);\\n        off += 4;\\n\\n        // Read the rdata\\n        uint rdataLength = iter.data.readUint16(off);\\n        off += 2;\\n        iter.rdataOffset = off;\\n        iter.nextOffset = off + rdataLength;\\n    }\\n\\n    /**\\n    * @dev Returns the name of the current record.\\n    * @param iter The iterator.\\n    * @return A new bytes object containing the owner name from the RR.\\n    */\\n    function name(RRIterator memory iter) internal pure returns(bytes memory) {\\n        return iter.data.substring(iter.offset, nameLength(iter.data, iter.offset));\\n    }\\n\\n    /**\\n    * @dev Returns the rdata portion of the current record.\\n    * @param iter The iterator.\\n    * @return A new bytes object containing the RR's RDATA.\\n    */\\n    function rdata(RRIterator memory iter) internal pure returns(bytes memory) {\\n        return iter.data.substring(iter.rdataOffset, iter.nextOffset - iter.rdataOffset);\\n    }\\n\\n    uint constant DNSKEY_FLAGS = 0;\\n    uint constant DNSKEY_PROTOCOL = 2;\\n    uint constant DNSKEY_ALGORITHM = 3;\\n    uint constant DNSKEY_PUBKEY = 4;\\n\\n    struct DNSKEY {\\n        uint16 flags;\\n        uint8 protocol;\\n        uint8 algorithm;\\n        bytes publicKey;\\n    }\\n\\n    function readDNSKEY(bytes memory data, uint offset, uint length) internal pure returns(DNSKEY memory self) {\\n        self.flags = data.readUint16(offset + DNSKEY_FLAGS);\\n        self.protocol = data.readUint8(offset + DNSKEY_PROTOCOL);\\n        self.algorithm = data.readUint8(offset + DNSKEY_ALGORITHM);\\n        self.publicKey = data.substring(offset + DNSKEY_PUBKEY, length - DNSKEY_PUBKEY);\\n    } \\n\\n    uint constant DS_KEY_TAG = 0;\\n    uint constant DS_ALGORITHM = 2;\\n    uint constant DS_DIGEST_TYPE = 3;\\n    uint constant DS_DIGEST = 4;\\n\\n    struct DS {\\n        uint16 keytag;\\n        uint8 algorithm;\\n        uint8 digestType;\\n        bytes digest;\\n    }\\n\\n    function readDS(bytes memory data, uint offset, uint length) internal pure returns(DS memory self) {\\n        self.keytag = data.readUint16(offset + DS_KEY_TAG);\\n        self.algorithm = data.readUint8(offset + DS_ALGORITHM);\\n        self.digestType = data.readUint8(offset + DS_DIGEST_TYPE);\\n        self.digest = data.substring(offset + DS_DIGEST, length - DS_DIGEST);\\n    }\\n\\n    struct NSEC3 {\\n        uint8 hashAlgorithm;\\n        uint8 flags;\\n        uint16 iterations;\\n        bytes salt;\\n        bytes32 nextHashedOwnerName;\\n        bytes typeBitmap;\\n    }\\n\\n    uint constant NSEC3_HASH_ALGORITHM = 0;\\n    uint constant NSEC3_FLAGS = 1;\\n    uint constant NSEC3_ITERATIONS = 2;\\n    uint constant NSEC3_SALT_LENGTH = 4;\\n    uint constant NSEC3_SALT = 5;\\n\\n    function readNSEC3(bytes memory data, uint offset, uint length) internal pure returns(NSEC3 memory self) {\\n        uint end = offset + length;\\n        self.hashAlgorithm = data.readUint8(offset + NSEC3_HASH_ALGORITHM);\\n        self.flags = data.readUint8(offset + NSEC3_FLAGS);\\n        self.iterations = data.readUint16(offset + NSEC3_ITERATIONS);\\n        uint8 saltLength = data.readUint8(offset + NSEC3_SALT_LENGTH);\\n        offset = offset + NSEC3_SALT;\\n        self.salt = data.substring(offset, saltLength);\\n        offset += saltLength;\\n        uint8 nextLength = data.readUint8(offset);\\n        require(nextLength <= 32);\\n        offset += 1;\\n        self.nextHashedOwnerName = data.readBytesN(offset, nextLength);\\n        offset += nextLength;\\n        self.typeBitmap = data.substring(offset, end - offset);\\n    }\\n\\n    function checkTypeBitmap(NSEC3 memory self, uint16 rrtype) internal pure returns(bool) {\\n        return checkTypeBitmap(self.typeBitmap, 0, rrtype);\\n    }\\n\\n    /**\\n    * @dev Checks if a given RR type exists in a type bitmap.\\n    * @param bitmap The byte string to read the type bitmap from.\\n    * @param offset The offset to start reading at.\\n    * @param rrtype The RR type to check for.\\n    * @return True if the type is found in the bitmap, false otherwise.\\n    */\\n    function checkTypeBitmap(bytes memory bitmap, uint offset, uint16 rrtype) internal pure returns (bool) {\\n        uint8 typeWindow = uint8(rrtype >> 8);\\n        uint8 windowByte = uint8((rrtype & 0xff) / 8);\\n        uint8 windowBitmask = uint8(uint8(1) << (uint8(7) - uint8(rrtype & 0x7)));\\n        for (uint off = offset; off < bitmap.length;) {\\n            uint8 window = bitmap.readUint8(off);\\n            uint8 len = bitmap.readUint8(off + 1);\\n            if (typeWindow < window) {\\n                // We've gone past our window; it's not here.\\n                return false;\\n            } else if (typeWindow == window) {\\n                // Check this type bitmap\\n                if (len <= windowByte) {\\n                    // Our type is past the end of the bitmap\\n                    return false;\\n                }\\n                return (bitmap.readUint8(off + windowByte + 2) & windowBitmask) != 0;\\n            } else {\\n                // Skip this type bitmap\\n                off += len + 2;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    function compareNames(bytes memory self, bytes memory other) internal pure returns (int) {\\n        if (self.equals(other)) {\\n            return 0;\\n        }\\n\\n        uint off;\\n        uint otheroff;\\n        uint prevoff;\\n        uint otherprevoff;\\n        uint counts = labelCount(self, 0);\\n        uint othercounts = labelCount(other, 0);\\n\\n        // Keep removing labels from the front of the name until both names are equal length\\n        while (counts > othercounts) {\\n            prevoff = off;\\n            off = progress(self, off);\\n            counts--;\\n        }\\n\\n        while (othercounts > counts) {\\n            otherprevoff = otheroff;\\n            otheroff = progress(other, otheroff);\\n            othercounts--;\\n        }\\n\\n        // Compare the last nonequal labels to each other\\n        while (counts > 0 && !self.equals(off, other, otheroff)) {\\n            prevoff = off;\\n            off = progress(self, off);\\n            otherprevoff = otheroff;\\n            otheroff = progress(other, otheroff);\\n            counts -= 1;\\n        }\\n\\n        if (off == 0) {\\n            return -1;\\n        }\\n        if(otheroff == 0) {\\n            return 1;\\n        }\\n\\n        return self.compare(prevoff + 1, self.readUint8(prevoff), other, otherprevoff + 1, other.readUint8(otherprevoff));\\n    }\\n\\n    /**\\n     * @dev Compares two serial numbers using RFC1982 serial number math.\\n     */\\n    function serialNumberGte(uint32 i1, uint32 i2) internal pure returns(bool) {\\n        return int32(i1) - int32(i2) >= 0;\\n    }\\n\\n    function progress(bytes memory body, uint off) internal pure returns(uint) {\\n        return off + 1 + body.readUint8(off);\\n    }\\n\\n    /**\\n     * @dev Computes the keytag for a chunk of data.\\n     * @param data The data to compute a keytag for.\\n     * @return The computed key tag.\\n     */\\n    function computeKeytag(bytes memory data) internal pure returns (uint16) {\\n        /* This function probably deserves some explanation.\\n         * The DNSSEC keytag function is a checksum that relies on summing up individual bytes\\n         * from the input string, with some mild bitshifting. Here's a Naive solidity implementation:\\n         *\\n         *     function computeKeytag(bytes memory data) internal pure returns (uint16) {\\n         *         uint ac;\\n         *         for (uint i = 0; i < data.length; i++) {\\n         *             ac += i & 1 == 0 ? uint16(data.readUint8(i)) << 8 : data.readUint8(i);\\n         *         }\\n         *         return uint16(ac + (ac >> 16));\\n         *     }\\n         *\\n         * The EVM, with its 256 bit words, is exceedingly inefficient at doing byte-by-byte operations;\\n         * the code above, on reasonable length inputs, consumes over 100k gas. But we can make the EVM's\\n         * large words work in our favour.\\n         *\\n         * The code below works by treating the input as a series of 256 bit words. It first masks out\\n         * even and odd bytes from each input word, adding them to two separate accumulators `ac1` and `ac2`.\\n         * The bytes are separated by empty bytes, so as long as no individual sum exceeds 2^16-1, we're\\n         * effectively summing 16 different numbers with each EVM ADD opcode.\\n         *\\n         * Once it's added up all the inputs, it has to add all the 16 bit values in `ac1` and `ac2` together.\\n         * It does this using the same trick - mask out every other value, shift to align them, add them together.\\n         * After the first addition on both accumulators, there's enough room to add the two accumulators together,\\n         * and the remaining sums can be done just on ac1.\\n         */\\n        unchecked {\\n            require(data.length <= 8192, \\\"Long keys not permitted\\\");\\n            uint ac1;\\n            uint ac2;\\n            for(uint i = 0; i < data.length + 31; i += 32) {\\n                uint word;\\n                assembly {\\n                    word := mload(add(add(data, 32), i))\\n                }\\n                if(i + 32 > data.length) {\\n                    uint unused = 256 - (data.length - i) * 8;\\n                    word = (word >> unused) << unused;\\n                }\\n                ac1 += (word & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8;\\n                ac2 += (word & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF);\\n            }\\n            ac1 = (ac1 & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF)\\n                + ((ac1 & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16);\\n            ac2 = (ac2 & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF)\\n                + ((ac2 & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16);\\n            ac1 = (ac1 << 8) + ac2;\\n            ac1 = (ac1 & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF)\\n                + ((ac1 & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32);\\n            ac1 = (ac1 & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF)\\n                + ((ac1 & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64);\\n            ac1 = (ac1 & 0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n                + (ac1 >> 128);\\n            ac1 += (ac1 >> 16) & 0xFFFF;\\n            return uint16(ac1);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/registry/ENS.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.4;\\n\\ninterface ENS {\\n\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n    // Logged when an operator is added or removed.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external virtual;\\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual;\\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external virtual returns(bytes32);\\n    function setResolver(bytes32 node, address resolver) external virtual;\\n    function setOwner(bytes32 node, address owner) external virtual;\\n    function setTTL(bytes32 node, uint64 ttl) external virtual;\\n    function setApprovalForAll(address operator, bool approved) external virtual;\\n    function owner(bytes32 node) external virtual view returns (address);\\n    function resolver(bytes32 node) external virtual view returns (address);\\n    function ttl(bytes32 node) external virtual view returns (uint64);\\n    function recordExists(bytes32 node) external virtual view returns (bool);\\n    function isApprovedForAll(address owner, address operator) external virtual view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/registry/ENSRegistry.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.4;\\n\\nimport \\\"./ENS.sol\\\";\\n\\n/**\\n * The ENS registry contract.\\n */\\ncontract ENSRegistry is ENS {\\n\\n    struct Record {\\n        address owner;\\n        address resolver;\\n        uint64 ttl;\\n    }\\n\\n    mapping (bytes32 => Record) records;\\n    mapping (address => mapping(address => bool)) operators;\\n\\n    // Permits modifications only by the owner of the specified node.\\n    modifier authorised(bytes32 node) {\\n        address owner = records[node].owner;\\n        require(owner == msg.sender || operators[owner][msg.sender]);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Constructs a new ENS registrar.\\n     */\\n    constructor() public {\\n        records[0x0].owner = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Sets the record for a node.\\n     * @param node The node to update.\\n     * @param owner The address of the new owner.\\n     * @param resolver The address of the resolver.\\n     * @param ttl The TTL in seconds.\\n     */\\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external virtual override {\\n        setOwner(node, owner);\\n        _setResolverAndTTL(node, resolver, ttl);\\n    }\\n\\n    /**\\n     * @dev Sets the record for a subnode.\\n     * @param node The parent node.\\n     * @param label The hash of the label specifying the subnode.\\n     * @param owner The address of the new owner.\\n     * @param resolver The address of the resolver.\\n     * @param ttl The TTL in seconds.\\n     */\\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual override {\\n        bytes32 subnode = setSubnodeOwner(node, label, owner);\\n        _setResolverAndTTL(subnode, resolver, ttl);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of a node to a new address. May only be called by the current owner of the node.\\n     * @param node The node to transfer ownership of.\\n     * @param owner The address of the new owner.\\n     */\\n    function setOwner(bytes32 node, address owner) public virtual override authorised(node) {\\n        _setOwner(node, owner);\\n        emit Transfer(node, owner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of a subnode keccak256(node, label) to a new address. May only be called by the owner of the parent node.\\n     * @param node The parent node.\\n     * @param label The hash of the label specifying the subnode.\\n     * @param owner The address of the new owner.\\n     */\\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public virtual override authorised(node) returns(bytes32) {\\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\\n        _setOwner(subnode, owner);\\n        emit NewOwner(node, label, owner);\\n        return subnode;\\n    }\\n\\n    /**\\n     * @dev Sets the resolver address for the specified node.\\n     * @param node The node to update.\\n     * @param resolver The address of the resolver.\\n     */\\n    function setResolver(bytes32 node, address resolver) public virtual override authorised(node) {\\n        emit NewResolver(node, resolver);\\n        records[node].resolver = resolver;\\n    }\\n\\n    /**\\n     * @dev Sets the TTL for the specified node.\\n     * @param node The node to update.\\n     * @param ttl The TTL in seconds.\\n     */\\n    function setTTL(bytes32 node, uint64 ttl) public virtual override authorised(node) {\\n        emit NewTTL(node, ttl);\\n        records[node].ttl = ttl;\\n    }\\n\\n    /**\\n     * @dev Enable or disable approval for a third party (\\\"operator\\\") to manage\\n     *  all of `msg.sender`'s ENS records. Emits the ApprovalForAll event.\\n     * @param operator Address to add to the set of authorized operators.\\n     * @param approved True if the operator is approved, false to revoke approval.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external virtual override {\\n        operators[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Returns the address that owns the specified node.\\n     * @param node The specified node.\\n     * @return address of the owner.\\n     */\\n    function owner(bytes32 node) public virtual override view returns (address) {\\n        address addr = records[node].owner;\\n        if (addr == address(this)) {\\n            return address(0x0);\\n        }\\n\\n        return addr;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the resolver for the specified node.\\n     * @param node The specified node.\\n     * @return address of the resolver.\\n     */\\n    function resolver(bytes32 node) public virtual override view returns (address) {\\n        return records[node].resolver;\\n    }\\n\\n    /**\\n     * @dev Returns the TTL of a node, and any records associated with it.\\n     * @param node The specified node.\\n     * @return ttl of the node.\\n     */\\n    function ttl(bytes32 node) public virtual override view returns (uint64) {\\n        return records[node].ttl;\\n    }\\n\\n    /**\\n     * @dev Returns whether a record has been imported to the registry.\\n     * @param node The specified node.\\n     * @return Bool if record exists\\n     */\\n    function recordExists(bytes32 node) public virtual override view returns (bool) {\\n        return records[node].owner != address(0x0);\\n    }\\n\\n    /**\\n     * @dev Query if an address is an authorized operator for another address.\\n     * @param owner The address that owns the records.\\n     * @param operator The address that acts on behalf of the owner.\\n     * @return True if `operator` is an approved operator for `owner`, false otherwise.\\n     */\\n    function isApprovedForAll(address owner, address operator) external virtual override view returns (bool) {\\n        return operators[owner][operator];\\n    }\\n\\n    function _setOwner(bytes32 node, address owner) internal virtual {\\n        records[node].owner = owner;\\n    }\\n\\n    function _setResolverAndTTL(bytes32 node, address resolver, uint64 ttl) internal {\\n        if(resolver != records[node].resolver) {\\n            records[node].resolver = resolver;\\n            emit NewResolver(node, resolver);\\n        }\\n\\n        if(ttl != records[node].ttl) {\\n            records[node].ttl = ttl;\\n            emit NewTTL(node, ttl);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/IMulticallable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IMulticallable {\\n    function multicall(bytes[] calldata data) external returns(bytes[] memory results);\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/ISupportsInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface ISupportsInterface {\\n    function supportsInterface(bytes4 interfaceID) external pure returns(bool);\\n}\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/Multicallable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./IMulticallable.sol\\\";\\nimport \\\"./SupportsInterface.sol\\\";\\n\\nabstract contract Multicallable is IMulticallable, SupportsInterface {\\n    function multicall(bytes[] calldata data) external override returns(bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for(uint i = 0; i < data.length; i++) {\\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\\n            require(success);\\n            results[i] = result;\\n        }\\n        return results;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) public override virtual pure returns(bool) {\\n        return interfaceID == type(IMulticallable).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/PublicResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"../registry/ENS.sol\\\";\\nimport \\\"./profiles/ABIResolver.sol\\\";\\nimport \\\"./profiles/AddrResolver.sol\\\";\\nimport \\\"./profiles/ContentHashResolver.sol\\\";\\nimport \\\"./profiles/DNSResolver.sol\\\";\\nimport \\\"./profiles/InterfaceResolver.sol\\\";\\nimport \\\"./profiles/NameResolver.sol\\\";\\nimport \\\"./profiles/PubkeyResolver.sol\\\";\\nimport \\\"./profiles/TextResolver.sol\\\";\\nimport \\\"./Multicallable.sol\\\";\\n\\ninterface INameWrapper {\\n    function ownerOf(uint256 id) external view returns (address);\\n}\\n\\n/**\\n * A simple resolver anyone can use; only allows the owner of a node to set its\\n * address.\\n */\\ncontract PublicResolver is Multicallable, ABIResolver, AddrResolver, ContentHashResolver, DNSResolver, InterfaceResolver, NameResolver, PubkeyResolver, TextResolver {\\n    ENS ens;\\n    INameWrapper nameWrapper;\\n\\n    /**\\n     * A mapping of operators. An address that is authorised for an address\\n     * may make any changes to the name that the owner could, but may not update\\n     * the set of authorisations.\\n     * (owner, operator) => approved\\n     */\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Logged when an operator is added or removed.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    constructor(ENS _ens, INameWrapper wrapperAddress){\\n        ens = _ens;\\n        nameWrapper = wrapperAddress;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external{\\n        require(\\n            msg.sender != operator,\\n            \\\"ERC1155: setting approval status for self\\\"\\n        );\\n\\n        _operatorApprovals[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isAuthorised(bytes32 node) internal override view returns(bool) {\\n        address owner = ens.owner(node);\\n        if(owner == address(nameWrapper) ){\\n            owner = nameWrapper.ownerOf(uint256(node));\\n        }\\n        return owner == msg.sender || isApprovedForAll(owner, msg.sender);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view returns (bool){\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) public override(Multicallable, ABIResolver, AddrResolver, ContentHashResolver, DNSResolver, InterfaceResolver, NameResolver, PubkeyResolver, TextResolver) pure returns(bool) {\\n        return interfaceID == type(IMulticallable).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/ResolverBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"./SupportsInterface.sol\\\";\\n\\nabstract contract ResolverBase is SupportsInterface {\\n    function isAuthorised(bytes32 node) internal virtual view returns(bool);\\n\\n    modifier authorised(bytes32 node) {\\n        require(isAuthorised(node));\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/SupportsInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./ISupportsInterface.sol\\\";\\n\\nabstract contract SupportsInterface is ISupportsInterface {\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == type(ISupportsInterface).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/ABIResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"./IABIResolver.sol\\\";\\nimport \\\"../ResolverBase.sol\\\";\\n\\nabstract contract ABIResolver is IABIResolver, ResolverBase {\\n    mapping(bytes32=>mapping(uint256=>bytes)) abis;\\n\\n    /**\\n     * Sets the ABI associated with an ENS node.\\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\\n     * the empty string.\\n     * @param node The node to update.\\n     * @param contentType The content type of the ABI\\n     * @param data The ABI data.\\n     */\\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) virtual external authorised(node) {\\n        // Content types must be powers of 2\\n        require(((contentType - 1) & contentType) == 0);\\n\\n        abis[node][contentType] = data;\\n        emit ABIChanged(node, contentType);\\n    }\\n\\n    /**\\n     * Returns the ABI associated with an ENS node.\\n     * Defined in EIP205.\\n     * @param node The ENS node to query\\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\\n     * @return contentType The content type of the return value\\n     * @return data The ABI data\\n     */\\n    function ABI(bytes32 node, uint256 contentTypes) virtual override external view returns (uint256, bytes memory) {\\n        mapping(uint256=>bytes) storage abiset = abis[node];\\n\\n        for (uint256 contentType = 1; contentType <= contentTypes; contentType <<= 1) {\\n            if ((contentType & contentTypes) != 0 && abiset[contentType].length > 0) {\\n                return (contentType, abiset[contentType]);\\n            }\\n        }\\n\\n        return (0, bytes(\\\"\\\"));\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == type(IABIResolver).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/AddrResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"../ResolverBase.sol\\\";\\nimport \\\"./IAddrResolver.sol\\\";\\nimport \\\"./IAddressResolver.sol\\\";\\n\\nabstract contract AddrResolver is IAddrResolver, IAddressResolver, ResolverBase {\\n    uint constant private COIN_TYPE_ETH = 60;\\n\\n    mapping(bytes32=>mapping(uint=>bytes)) _addresses;\\n\\n    /**\\n     * Sets the address associated with an ENS node.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param a The address to set.\\n     */\\n    function setAddr(bytes32 node, address a) virtual external authorised(node) {\\n        setAddr(node, COIN_TYPE_ETH, addressToBytes(a));\\n    }\\n\\n    /**\\n     * Returns the address associated with an ENS node.\\n     * @param node The ENS node to query.\\n     * @return The associated address.\\n     */\\n    function addr(bytes32 node) virtual override public view returns (address payable) {\\n        bytes memory a = addr(node, COIN_TYPE_ETH);\\n        if(a.length == 0) {\\n            return payable(0);\\n        }\\n        return bytesToAddress(a);\\n    }\\n\\n    function setAddr(bytes32 node, uint coinType, bytes memory a) virtual public authorised(node) {\\n        emit AddressChanged(node, coinType, a);\\n        if(coinType == COIN_TYPE_ETH) {\\n            emit AddrChanged(node, bytesToAddress(a));\\n        }\\n        _addresses[node][coinType] = a;\\n    }\\n\\n    function addr(bytes32 node, uint coinType) virtual override public view returns(bytes memory) {\\n        return _addresses[node][coinType];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == type(IAddrResolver).interfaceId || interfaceID == type(IAddressResolver).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n\\n    function bytesToAddress(bytes memory b) internal pure returns(address payable a) {\\n        require(b.length == 20);\\n        assembly {\\n            a := div(mload(add(b, 32)), exp(256, 12))\\n        }\\n    }\\n\\n    function addressToBytes(address a) internal pure returns(bytes memory b) {\\n        b = new bytes(20);\\n        assembly {\\n            mstore(add(b, 32), mul(a, exp(256, 12)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/ContentHashResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"../ResolverBase.sol\\\";\\nimport \\\"./IContentHashResolver.sol\\\";\\n\\nabstract contract ContentHashResolver is IContentHashResolver, ResolverBase {\\n    mapping(bytes32=>bytes) hashes;\\n\\n    /**\\n     * Sets the contenthash associated with an ENS node.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param hash The contenthash to set\\n     */\\n    function setContenthash(bytes32 node, bytes calldata hash) virtual external authorised(node) {\\n        hashes[node] = hash;\\n        emit ContenthashChanged(node, hash);\\n    }\\n\\n    /**\\n     * Returns the contenthash associated with an ENS node.\\n     * @param node The ENS node to query.\\n     * @return The associated contenthash.\\n     */\\n    function contenthash(bytes32 node) virtual external override view returns (bytes memory) {\\n        return hashes[node];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == type(IContentHashResolver).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/DNSResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"../ResolverBase.sol\\\";\\nimport \\\"../../dnssec-oracle/RRUtils.sol\\\";\\nimport \\\"./IDNSRecordResolver.sol\\\";\\nimport \\\"./IDNSZoneResolver.sol\\\";\\n\\nabstract contract DNSResolver is IDNSRecordResolver, IDNSZoneResolver, ResolverBase {\\n    using RRUtils for *;\\n    using BytesUtils for bytes;\\n\\n    // Zone hashes for the domains.\\n    // A zone hash is an EIP-1577 content hash in binary format that should point to a\\n    // resource containing a single zonefile.\\n    // node => contenthash\\n    mapping(bytes32=>bytes) private zonehashes;\\n\\n    // Version the mapping for each zone.  This allows users who have lost\\n    // track of their entries to effectively delete an entire zone by bumping\\n    // the version number.\\n    // node => version\\n    mapping(bytes32=>uint256) private versions;\\n\\n    // The records themselves.  Stored as binary RRSETs\\n    // node => version => name => resource => data\\n    mapping(bytes32=>mapping(uint256=>mapping(bytes32=>mapping(uint16=>bytes)))) private records;\\n\\n    // Count of number of entries for a given name.  Required for DNS resolvers\\n    // when resolving wildcards.\\n    // node => version => name => number of records\\n    mapping(bytes32=>mapping(uint256=>mapping(bytes32=>uint16))) private nameEntriesCount;\\n\\n    /**\\n     * Set one or more DNS records.  Records are supplied in wire-format.\\n     * Records with the same node/name/resource must be supplied one after the\\n     * other to ensure the data is updated correctly. For example, if the data\\n     * was supplied:\\n     *     a.example.com IN A 1.2.3.4\\n     *     a.example.com IN A 5.6.7.8\\n     *     www.example.com IN CNAME a.example.com.\\n     * then this would store the two A records for a.example.com correctly as a\\n     * single RRSET, however if the data was supplied:\\n     *     a.example.com IN A 1.2.3.4\\n     *     www.example.com IN CNAME a.example.com.\\n     *     a.example.com IN A 5.6.7.8\\n     * then this would store the first A record, the CNAME, then the second A\\n     * record which would overwrite the first.\\n     *\\n     * @param node the namehash of the node for which to set the records\\n     * @param data the DNS wire format records to set\\n     */\\n    function setDNSRecords(bytes32 node, bytes calldata data) virtual external authorised(node) {\\n        uint16 resource = 0;\\n        uint256 offset = 0;\\n        bytes memory name;\\n        bytes memory value;\\n        bytes32 nameHash;\\n        // Iterate over the data to add the resource records\\n        for (RRUtils.RRIterator memory iter = data.iterateRRs(0); !iter.done(); iter.next()) {\\n            if (resource == 0) {\\n                resource = iter.dnstype;\\n                name = iter.name();\\n                nameHash = keccak256(abi.encodePacked(name));\\n                value = bytes(iter.rdata());\\n            } else {\\n                bytes memory newName = iter.name();\\n                if (resource != iter.dnstype || !name.equals(newName)) {\\n                    setDNSRRSet(node, name, resource, data, offset, iter.offset - offset, value.length == 0);\\n                    resource = iter.dnstype;\\n                    offset = iter.offset;\\n                    name = newName;\\n                    nameHash = keccak256(name);\\n                    value = bytes(iter.rdata());\\n                }\\n            }\\n        }\\n        if (name.length > 0) {\\n            setDNSRRSet(node, name, resource, data, offset, data.length - offset, value.length == 0);\\n        }\\n    }\\n\\n    /**\\n     * Obtain a DNS record.\\n     * @param node the namehash of the node for which to fetch the record\\n     * @param name the keccak-256 hash of the fully-qualified name for which to fetch the record\\n     * @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\\n     * @return the DNS record in wire format if present, otherwise empty\\n     */\\n    function dnsRecord(bytes32 node, bytes32 name, uint16 resource) virtual override public view returns (bytes memory) {\\n        return records[node][versions[node]][name][resource];\\n    }\\n\\n    /**\\n     * Check if a given node has records.\\n     * @param node the namehash of the node for which to check the records\\n     * @param name the namehash of the node for which to check the records\\n     */\\n    function hasDNSRecords(bytes32 node, bytes32 name) virtual public view returns (bool) {\\n        return (nameEntriesCount[node][versions[node]][name] != 0);\\n    }\\n\\n    /**\\n     * Clear all information for a DNS zone.\\n     * @param node the namehash of the node for which to clear the zone\\n     */\\n    function clearDNSZone(bytes32 node) virtual public authorised(node) {\\n        versions[node]++;\\n        emit DNSZoneCleared(node);\\n    }\\n\\n    /**\\n     * setZonehash sets the hash for the zone.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param hash The zonehash to set\\n     */\\n    function setZonehash(bytes32 node, bytes calldata hash) virtual external authorised(node) {\\n        bytes memory oldhash = zonehashes[node];\\n        zonehashes[node] = hash;\\n        emit DNSZonehashChanged(node, oldhash, hash);\\n    }\\n\\n    /**\\n     * zonehash obtains the hash for the zone.\\n     * @param node The ENS node to query.\\n     * @return The associated contenthash.\\n     */\\n    function zonehash(bytes32 node) virtual override external view returns (bytes memory) {\\n        return zonehashes[node];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == type(IDNSRecordResolver).interfaceId ||\\n               interfaceID == type(IDNSZoneResolver).interfaceId ||\\n               super.supportsInterface(interfaceID);\\n    }\\n\\n    function setDNSRRSet(\\n        bytes32 node,\\n        bytes memory name,\\n        uint16 resource,\\n        bytes memory data,\\n        uint256 offset,\\n        uint256 size,\\n        bool deleteRecord) private\\n    {\\n        uint256 version = versions[node];\\n        bytes32 nameHash = keccak256(name);\\n        bytes memory rrData = data.substring(offset, size);\\n        if (deleteRecord) {\\n            if (records[node][version][nameHash][resource].length != 0) {\\n                nameEntriesCount[node][version][nameHash]--;\\n            }\\n            delete(records[node][version][nameHash][resource]);\\n            emit DNSRecordDeleted(node, name, resource);\\n        } else {\\n            if (records[node][version][nameHash][resource].length == 0) {\\n                nameEntriesCount[node][version][nameHash]++;\\n            }\\n            records[node][version][nameHash][resource] = rrData;\\n            emit DNSRecordChanged(node, name, resource, rrData);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IABIResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"./IABIResolver.sol\\\";\\nimport \\\"../ResolverBase.sol\\\";\\n\\ninterface IABIResolver {\\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\\n    /**\\n     * Returns the ABI associated with an ENS node.\\n     * Defined in EIP205.\\n     * @param node The ENS node to query\\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\\n     * @return contentType The content type of the return value\\n     * @return data The ABI data\\n     */\\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory);\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddrResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/**\\n * Interface for the legacy (ETH-only) addr function.\\n */\\ninterface IAddrResolver {\\n    event AddrChanged(bytes32 indexed node, address a);\\n\\n    /**\\n     * Returns the address associated with an ENS node.\\n     * @param node The ENS node to query.\\n     * @return The associated address.\\n     */\\n    function addr(bytes32 node) external view returns (address payable);\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddressResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/**\\n * Interface for the new (multicoin) addr function.\\n */\\ninterface IAddressResolver {\\n    event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);\\n\\n    function addr(bytes32 node, uint coinType) external view returns(bytes memory);\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IContentHashResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface IContentHashResolver {\\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\\n\\n    /**\\n     * Returns the contenthash associated with an ENS node.\\n     * @param node The ENS node to query.\\n     * @return The associated contenthash.\\n     */\\n    function contenthash(bytes32 node) external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IDNSRecordResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface IDNSRecordResolver {\\n    // DNSRecordChanged is emitted whenever a given node/name/resource's RRSET is updated.\\n    event DNSRecordChanged(bytes32 indexed node, bytes name, uint16 resource, bytes record);\\n    // DNSRecordDeleted is emitted whenever a given node/name/resource's RRSET is deleted.\\n    event DNSRecordDeleted(bytes32 indexed node, bytes name, uint16 resource);\\n    // DNSZoneCleared is emitted whenever a given node's zone information is cleared.\\n    event DNSZoneCleared(bytes32 indexed node);\\n\\n    /**\\n     * Obtain a DNS record.\\n     * @param node the namehash of the node for which to fetch the record\\n     * @param name the keccak-256 hash of the fully-qualified name for which to fetch the record\\n     * @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\\n     * @return the DNS record in wire format if present, otherwise empty\\n     */\\n    function dnsRecord(bytes32 node, bytes32 name, uint16 resource) external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IDNSZoneResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface IDNSZoneResolver {\\n    // DNSZonehashChanged is emitted whenever a given node's zone hash is updated.\\n    event DNSZonehashChanged(bytes32 indexed node, bytes lastzonehash, bytes zonehash);\\n\\n    /**\\n     * zonehash obtains the hash for the zone.\\n     * @param node The ENS node to query.\\n     * @return The associated contenthash.\\n     */\\n    function zonehash(bytes32 node) external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IInterfaceResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface IInterfaceResolver {\\n    event InterfaceChanged(bytes32 indexed node, bytes4 indexed interfaceID, address implementer);\\n\\n    /**\\n     * Returns the address of a contract that implements the specified interface for this name.\\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\\n     * contract implements EIP165 and returns `true` for the specified interfaceID, its address\\n     * will be returned.\\n     * @param node The ENS node to query.\\n     * @param interfaceID The EIP 165 interface ID to check for.\\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\\n     */\\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/INameResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface INameResolver {\\n    event NameChanged(bytes32 indexed node, string name);\\n\\n    /**\\n     * Returns the name associated with an ENS node, for reverse records.\\n     * Defined in EIP181.\\n     * @param node The ENS node to query.\\n     * @return The associated name.\\n     */\\n    function name(bytes32 node) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IPubkeyResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface IPubkeyResolver {\\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\\n\\n    /**\\n     * Returns the SECP256k1 public key associated with an ENS node.\\n     * Defined in EIP 619.\\n     * @param node The ENS node to query\\n     * @return x The X coordinate of the curve point for the public key.\\n     * @return y The Y coordinate of the curve point for the public key.\\n     */\\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/ITextResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface ITextResolver {\\n    event TextChanged(bytes32 indexed node, string indexed indexedKey, string key);\\n\\n    /**\\n     * Returns the text data associated with an ENS node and key.\\n     * @param node The ENS node to query.\\n     * @param key The text data key to query.\\n     * @return The associated text data.\\n     */\\n    function text(bytes32 node, string calldata key) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/InterfaceResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"../ResolverBase.sol\\\";\\nimport \\\"../ISupportsInterface.sol\\\";\\nimport \\\"./AddrResolver.sol\\\";\\nimport \\\"./IInterfaceResolver.sol\\\";\\n\\nabstract contract InterfaceResolver is IInterfaceResolver, AddrResolver {\\n    mapping(bytes32=>mapping(bytes4=>address)) interfaces;\\n\\n    /**\\n     * Sets an interface associated with a name.\\n     * Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support.\\n     * @param node The node to update.\\n     * @param interfaceID The EIP 165 interface ID.\\n     * @param implementer The address of a contract that implements this interface for this node.\\n     */\\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) virtual external authorised(node) {\\n        interfaces[node][interfaceID] = implementer;\\n        emit InterfaceChanged(node, interfaceID, implementer);\\n    }\\n\\n    /**\\n     * Returns the address of a contract that implements the specified interface for this name.\\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\\n     * contract implements EIP165 and returns `true` for the specified interfaceID, its address\\n     * will be returned.\\n     * @param node The ENS node to query.\\n     * @param interfaceID The EIP 165 interface ID to check for.\\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\\n     */\\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) virtual override external view returns (address) {\\n        address implementer = interfaces[node][interfaceID];\\n        if(implementer != address(0)) {\\n            return implementer;\\n        }\\n\\n        address a = addr(node);\\n        if(a == address(0)) {\\n            return address(0);\\n        }\\n\\n        (bool success, bytes memory returnData) = a.staticcall(abi.encodeWithSignature(\\\"supportsInterface(bytes4)\\\", type(ISupportsInterface).interfaceId));\\n        if(!success || returnData.length < 32 || returnData[31] == 0) {\\n            // EIP 165 not supported by target\\n            return address(0);\\n        }\\n\\n        (success, returnData) = a.staticcall(abi.encodeWithSignature(\\\"supportsInterface(bytes4)\\\", interfaceID));\\n        if(!success || returnData.length < 32 || returnData[31] == 0) {\\n            // Specified interface not supported by target\\n            return address(0);\\n        }\\n\\n        return a;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == type(IInterfaceResolver).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/NameResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"../ResolverBase.sol\\\";\\nimport \\\"./INameResolver.sol\\\";\\n\\nabstract contract NameResolver is INameResolver, ResolverBase {\\n    mapping(bytes32=>string) names;\\n\\n    /**\\n     * Sets the name associated with an ENS node, for reverse records.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     */\\n    function setName(bytes32 node, string calldata newName) virtual external authorised(node) {\\n        names[node] = newName;\\n        emit NameChanged(node, newName);\\n    }\\n\\n    /**\\n     * Returns the name associated with an ENS node, for reverse records.\\n     * Defined in EIP181.\\n     * @param node The ENS node to query.\\n     * @return The associated name.\\n     */\\n    function name(bytes32 node) virtual override external view returns (string memory) {\\n        return names[node];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == type(INameResolver).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/PubkeyResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"../ResolverBase.sol\\\";\\nimport \\\"./IPubkeyResolver.sol\\\";\\n\\nabstract contract PubkeyResolver is IPubkeyResolver, ResolverBase {\\n    struct PublicKey {\\n        bytes32 x;\\n        bytes32 y;\\n    }\\n\\n    mapping(bytes32=>PublicKey) pubkeys;\\n\\n    /**\\n     * Sets the SECP256k1 public key associated with an ENS node.\\n     * @param node The ENS node to query\\n     * @param x the X coordinate of the curve point for the public key.\\n     * @param y the Y coordinate of the curve point for the public key.\\n     */\\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) virtual external authorised(node) {\\n        pubkeys[node] = PublicKey(x, y);\\n        emit PubkeyChanged(node, x, y);\\n    }\\n\\n    /**\\n     * Returns the SECP256k1 public key associated with an ENS node.\\n     * Defined in EIP 619.\\n     * @param node The ENS node to query\\n     * @return x The X coordinate of the curve point for the public key.\\n     * @return y The Y coordinate of the curve point for the public key.\\n     */\\n    function pubkey(bytes32 node) virtual override external view returns (bytes32 x, bytes32 y) {\\n        return (pubkeys[node].x, pubkeys[node].y);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == type(IPubkeyResolver).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/TextResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"../ResolverBase.sol\\\";\\nimport \\\"./ITextResolver.sol\\\";\\n\\nabstract contract TextResolver is ITextResolver, ResolverBase {\\n    mapping(bytes32=>mapping(string=>string)) texts;\\n\\n    /**\\n     * Sets the text data associated with an ENS node and key.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param key The key to set.\\n     * @param value The text data value to set.\\n     */\\n    function setText(bytes32 node, string calldata key, string calldata value) virtual external authorised(node) {\\n        texts[node][key] = value;\\n        emit TextChanged(node, key, key);\\n    }\\n\\n    /**\\n     * Returns the text data associated with an ENS node and key.\\n     * @param node The ENS node to query.\\n     * @param key The text data key to query.\\n     * @return The associated text data.\\n     */\\n    function text(bytes32 node, string calldata key) virtual override external view returns (string memory) {\\n        return texts[node][key];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == type(ITextResolver).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"\r\n    },\r\n    \"@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain\\n/// @author Richard Meissner - <richard@gnosis.io>\\ninterface IProxy {\\n    function masterCopy() external view returns (address);\\n}\\n\\n/// @title GnosisSafeProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\\n/// @author Stefan George - <stefan@gnosis.io>\\n/// @author Richard Meissner - <richard@gnosis.io>\\ncontract GnosisSafeProxy {\\n    // singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\\n    address internal singleton;\\n\\n    /// @dev Constructor function sets address of singleton contract.\\n    /// @param _singleton Singleton address.\\n    constructor(address _singleton) {\\n        require(_singleton != address(0), \\\"Invalid singleton address provided\\\");\\n        singleton = _singleton;\\n    }\\n\\n    /// @dev Fallback function forwards all transactions and returns all received return data.\\n    fallback() external payable {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let _singleton := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\\n            // 0xa619486e == keccak(\\\"masterCopy()\\\"). The value is right padded to 32-bytes with 0s\\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\\n                mstore(0, _singleton)\\n                return(0, 0x20)\\n            }\\n            calldatacopy(0, 0, calldatasize())\\n            let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            if eq(success, 0) {\\n                revert(0, returndatasize())\\n            }\\n            return(0, returndatasize())\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\nimport \\\"./GnosisSafeProxy.sol\\\";\\nimport \\\"./IProxyCreationCallback.sol\\\";\\n\\n/// @title Proxy Factory - Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\\n/// @author Stefan George - <stefan@gnosis.pm>\\ncontract GnosisSafeProxyFactory {\\n    event ProxyCreation(GnosisSafeProxy proxy, address singleton);\\n\\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\\n    /// @param singleton Address of singleton contract.\\n    /// @param data Payload for message call sent to new proxy contract.\\n    function createProxy(address singleton, bytes memory data) public returns (GnosisSafeProxy proxy) {\\n        proxy = new GnosisSafeProxy(singleton);\\n        if (data.length > 0)\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                if eq(call(gas(), proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) {\\n                    revert(0, 0)\\n                }\\n            }\\n        emit ProxyCreation(proxy, singleton);\\n    }\\n\\n    /// @dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.\\n    function proxyRuntimeCode() public pure returns (bytes memory) {\\n        return type(GnosisSafeProxy).runtimeCode;\\n    }\\n\\n    /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\\n    function proxyCreationCode() public pure returns (bytes memory) {\\n        return type(GnosisSafeProxy).creationCode;\\n    }\\n\\n    /// @dev Allows to create new proxy contact using CREATE2 but it doesn't run the initializer.\\n    ///      This method is only meant as an utility to be called from other methods\\n    /// @param _singleton Address of singleton contract.\\n    /// @param initializer Payload for message call sent to new proxy contract.\\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\\n    function deployProxyWithNonce(\\n        address _singleton,\\n        bytes memory initializer,\\n        uint256 saltNonce\\n    ) internal returns (GnosisSafeProxy proxy) {\\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));\\n        bytes memory deploymentData = abi.encodePacked(type(GnosisSafeProxy).creationCode, uint256(uint160(_singleton)));\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\\n        }\\n        require(address(proxy) != address(0), \\\"Create2 call failed\\\");\\n    }\\n\\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\\n    /// @param _singleton Address of singleton contract.\\n    /// @param initializer Payload for message call sent to new proxy contract.\\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\\n    function createProxyWithNonce(\\n        address _singleton,\\n        bytes memory initializer,\\n        uint256 saltNonce\\n    ) public returns (GnosisSafeProxy proxy) {\\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\\n        if (initializer.length > 0)\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                if eq(call(gas(), proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) {\\n                    revert(0, 0)\\n                }\\n            }\\n        emit ProxyCreation(proxy, _singleton);\\n    }\\n\\n    /// @dev Allows to create new proxy contact, execute a message call to the new proxy and call a specified callback within one transaction\\n    /// @param _singleton Address of singleton contract.\\n    /// @param initializer Payload for message call sent to new proxy contract.\\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\\n    /// @param callback Callback that will be invoced after the new proxy contract has been successfully deployed and initialized.\\n    function createProxyWithCallback(\\n        address _singleton,\\n        bytes memory initializer,\\n        uint256 saltNonce,\\n        IProxyCreationCallback callback\\n    ) public returns (GnosisSafeProxy proxy) {\\n        uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback)));\\n        proxy = createProxyWithNonce(_singleton, initializer, saltNonceWithCallback);\\n        if (address(callback) != address(0)) callback.proxyCreated(proxy, _singleton, initializer, saltNonce);\\n    }\\n\\n    /// @dev Allows to get the address for a new proxy contact created via `createProxyWithNonce`\\n    ///      This method is only meant for address calculation purpose when you use an initializer that would revert,\\n    ///      therefore the response is returned with a revert. When calling this method set `from` to the address of the proxy factory.\\n    /// @param _singleton Address of singleton contract.\\n    /// @param initializer Payload for message call sent to new proxy contract.\\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\\n    function calculateCreateProxyWithNonceAddress(\\n        address _singleton,\\n        bytes calldata initializer,\\n        uint256 saltNonce\\n    ) external returns (GnosisSafeProxy proxy) {\\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\\n        revert(string(abi.encodePacked(proxy)));\\n    }\\n}\\n\"\r\n    },\r\n    \"@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\nimport \\\"./GnosisSafeProxy.sol\\\";\\n\\ninterface IProxyCreationCallback {\\n    function proxyCreated(\\n        GnosisSafeProxy proxy,\\n        address _singleton,\\n        bytes calldata initializer,\\n        uint256 saltNonce\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = _allowances[owner][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[45] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = _allowances[owner][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721Holder is IERC721Receiver {\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@prb/math/contracts/PRBMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\n/// @notice Emitted when the result overflows uint256.\\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\\n\\n/// @notice Emitted when the result overflows uint256.\\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\\n\\n/// @notice Emitted when one of the inputs is type(int256).min.\\nerror PRBMath__MulDivSignedInputTooSmall();\\n\\n/// @notice Emitted when the intermediary absolute result overflows int256.\\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the input is MIN_SD59x18.\\nerror PRBMathSD59x18__AbsInputTooSmall();\\n\\n/// @notice Emitted when ceiling a number overflows SD59x18.\\nerror PRBMathSD59x18__CeilOverflow(int256 x);\\n\\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\\nerror PRBMathSD59x18__DivInputTooSmall();\\n\\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the input is greater than 133.084258667509499441.\\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\\n\\n/// @notice Emitted when the input is greater than 192.\\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\\n\\n/// @notice Emitted when flooring a number underflows SD59x18.\\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\\n\\n/// @notice Emitted when the product of the inputs is negative.\\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\\n\\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\\n\\n/// @notice Emitted when the input is less than or equal to zero.\\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\\n\\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\\nerror PRBMathSD59x18__MulInputTooSmall();\\n\\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the input is negative.\\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\\n\\n/// @notice Emitted when the calculating the square root overflows SD59x18.\\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\\n\\n/// @notice Emitted when addition overflows UD60x18.\\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\\n\\n/// @notice Emitted when ceiling a number overflows UD60x18.\\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\\n\\n/// @notice Emitted when the input is greater than 133.084258667509499441.\\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\\n\\n/// @notice Emitted when the input is greater than 192.\\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\\n\\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\\n\\n/// @notice Emitted when the input is less than 1.\\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\\n\\n/// @notice Emitted when the calculating the square root overflows UD60x18.\\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\\n\\n/// @notice Emitted when subtraction underflows UD60x18.\\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\\n\\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\\nlibrary PRBMath {\\n    /// STRUCTS ///\\n\\n    struct SD59x18 {\\n        int256 value;\\n    }\\n\\n    struct UD60x18 {\\n        uint256 value;\\n    }\\n\\n    /// STORAGE ///\\n\\n    /// @dev How many trailing decimals can be represented.\\n    uint256 internal constant SCALE = 1e18;\\n\\n    /// @dev Largest power of two divisor of SCALE.\\n    uint256 internal constant SCALE_LPOTD = 262144;\\n\\n    /// @dev SCALE inverted mod 2^256.\\n    uint256 internal constant SCALE_INVERSE =\\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\\n\\n    /// FUNCTIONS ///\\n\\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\\n    /// @dev Has to use 192.64-bit fixed-point numbers.\\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp2(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            // Start from 0.5 in the 192.64-bit fixed-point format.\\n            result = 0x800000000000000000000000000000000000000000000000;\\n\\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\\n            if (x & 0x8000000000000000 > 0) {\\n                result = (result * 0x16A09E667F3BCC909) >> 64;\\n            }\\n            if (x & 0x4000000000000000 > 0) {\\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\\n            }\\n            if (x & 0x2000000000000000 > 0) {\\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\\n            }\\n            if (x & 0x1000000000000000 > 0) {\\n                result = (result * 0x10B5586CF9890F62A) >> 64;\\n            }\\n            if (x & 0x800000000000000 > 0) {\\n                result = (result * 0x1059B0D31585743AE) >> 64;\\n            }\\n            if (x & 0x400000000000000 > 0) {\\n                result = (result * 0x102C9A3E778060EE7) >> 64;\\n            }\\n            if (x & 0x200000000000000 > 0) {\\n                result = (result * 0x10163DA9FB33356D8) >> 64;\\n            }\\n            if (x & 0x100000000000000 > 0) {\\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\\n            }\\n            if (x & 0x80000000000000 > 0) {\\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\\n            }\\n            if (x & 0x40000000000000 > 0) {\\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\\n            }\\n            if (x & 0x20000000000000 > 0) {\\n                result = (result * 0x100162F3904051FA1) >> 64;\\n            }\\n            if (x & 0x10000000000000 > 0) {\\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\\n            }\\n            if (x & 0x8000000000000 > 0) {\\n                result = (result * 0x100058BA01FB9F96D) >> 64;\\n            }\\n            if (x & 0x4000000000000 > 0) {\\n                result = (result * 0x10002C5CC37DA9492) >> 64;\\n            }\\n            if (x & 0x2000000000000 > 0) {\\n                result = (result * 0x1000162E525EE0547) >> 64;\\n            }\\n            if (x & 0x1000000000000 > 0) {\\n                result = (result * 0x10000B17255775C04) >> 64;\\n            }\\n            if (x & 0x800000000000 > 0) {\\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\\n            }\\n            if (x & 0x400000000000 > 0) {\\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\\n            }\\n            if (x & 0x200000000000 > 0) {\\n                result = (result * 0x10000162E43F4F831) >> 64;\\n            }\\n            if (x & 0x100000000000 > 0) {\\n                result = (result * 0x100000B1721BCFC9A) >> 64;\\n            }\\n            if (x & 0x80000000000 > 0) {\\n                result = (result * 0x10000058B90CF1E6E) >> 64;\\n            }\\n            if (x & 0x40000000000 > 0) {\\n                result = (result * 0x1000002C5C863B73F) >> 64;\\n            }\\n            if (x & 0x20000000000 > 0) {\\n                result = (result * 0x100000162E430E5A2) >> 64;\\n            }\\n            if (x & 0x10000000000 > 0) {\\n                result = (result * 0x1000000B172183551) >> 64;\\n            }\\n            if (x & 0x8000000000 > 0) {\\n                result = (result * 0x100000058B90C0B49) >> 64;\\n            }\\n            if (x & 0x4000000000 > 0) {\\n                result = (result * 0x10000002C5C8601CC) >> 64;\\n            }\\n            if (x & 0x2000000000 > 0) {\\n                result = (result * 0x1000000162E42FFF0) >> 64;\\n            }\\n            if (x & 0x1000000000 > 0) {\\n                result = (result * 0x10000000B17217FBB) >> 64;\\n            }\\n            if (x & 0x800000000 > 0) {\\n                result = (result * 0x1000000058B90BFCE) >> 64;\\n            }\\n            if (x & 0x400000000 > 0) {\\n                result = (result * 0x100000002C5C85FE3) >> 64;\\n            }\\n            if (x & 0x200000000 > 0) {\\n                result = (result * 0x10000000162E42FF1) >> 64;\\n            }\\n            if (x & 0x100000000 > 0) {\\n                result = (result * 0x100000000B17217F8) >> 64;\\n            }\\n            if (x & 0x80000000 > 0) {\\n                result = (result * 0x10000000058B90BFC) >> 64;\\n            }\\n            if (x & 0x40000000 > 0) {\\n                result = (result * 0x1000000002C5C85FE) >> 64;\\n            }\\n            if (x & 0x20000000 > 0) {\\n                result = (result * 0x100000000162E42FF) >> 64;\\n            }\\n            if (x & 0x10000000 > 0) {\\n                result = (result * 0x1000000000B17217F) >> 64;\\n            }\\n            if (x & 0x8000000 > 0) {\\n                result = (result * 0x100000000058B90C0) >> 64;\\n            }\\n            if (x & 0x4000000 > 0) {\\n                result = (result * 0x10000000002C5C860) >> 64;\\n            }\\n            if (x & 0x2000000 > 0) {\\n                result = (result * 0x1000000000162E430) >> 64;\\n            }\\n            if (x & 0x1000000 > 0) {\\n                result = (result * 0x10000000000B17218) >> 64;\\n            }\\n            if (x & 0x800000 > 0) {\\n                result = (result * 0x1000000000058B90C) >> 64;\\n            }\\n            if (x & 0x400000 > 0) {\\n                result = (result * 0x100000000002C5C86) >> 64;\\n            }\\n            if (x & 0x200000 > 0) {\\n                result = (result * 0x10000000000162E43) >> 64;\\n            }\\n            if (x & 0x100000 > 0) {\\n                result = (result * 0x100000000000B1721) >> 64;\\n            }\\n            if (x & 0x80000 > 0) {\\n                result = (result * 0x10000000000058B91) >> 64;\\n            }\\n            if (x & 0x40000 > 0) {\\n                result = (result * 0x1000000000002C5C8) >> 64;\\n            }\\n            if (x & 0x20000 > 0) {\\n                result = (result * 0x100000000000162E4) >> 64;\\n            }\\n            if (x & 0x10000 > 0) {\\n                result = (result * 0x1000000000000B172) >> 64;\\n            }\\n            if (x & 0x8000 > 0) {\\n                result = (result * 0x100000000000058B9) >> 64;\\n            }\\n            if (x & 0x4000 > 0) {\\n                result = (result * 0x10000000000002C5D) >> 64;\\n            }\\n            if (x & 0x2000 > 0) {\\n                result = (result * 0x1000000000000162E) >> 64;\\n            }\\n            if (x & 0x1000 > 0) {\\n                result = (result * 0x10000000000000B17) >> 64;\\n            }\\n            if (x & 0x800 > 0) {\\n                result = (result * 0x1000000000000058C) >> 64;\\n            }\\n            if (x & 0x400 > 0) {\\n                result = (result * 0x100000000000002C6) >> 64;\\n            }\\n            if (x & 0x200 > 0) {\\n                result = (result * 0x10000000000000163) >> 64;\\n            }\\n            if (x & 0x100 > 0) {\\n                result = (result * 0x100000000000000B1) >> 64;\\n            }\\n            if (x & 0x80 > 0) {\\n                result = (result * 0x10000000000000059) >> 64;\\n            }\\n            if (x & 0x40 > 0) {\\n                result = (result * 0x1000000000000002C) >> 64;\\n            }\\n            if (x & 0x20 > 0) {\\n                result = (result * 0x10000000000000016) >> 64;\\n            }\\n            if (x & 0x10 > 0) {\\n                result = (result * 0x1000000000000000B) >> 64;\\n            }\\n            if (x & 0x8 > 0) {\\n                result = (result * 0x10000000000000006) >> 64;\\n            }\\n            if (x & 0x4 > 0) {\\n                result = (result * 0x10000000000000003) >> 64;\\n            }\\n            if (x & 0x2 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n            if (x & 0x1 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n\\n            // We're doing two things at the same time:\\n            //\\n            //   1. Multiply the result by 2^n + 1, where \\\"2^n\\\" is the integer part and the one is added to account for\\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\\n            //      rather than 192.\\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\\n            //\\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \\\"ip\\\" is the integer part \\\"2^n\\\".\\n            result *= SCALE;\\n            result >>= (191 - (x >> 64));\\n        }\\n    }\\n\\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\\n    /// @dev See the note on msb in the \\\"Find First Set\\\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\n    /// @param x The uint256 number for which to find the index of the most significant bit.\\n    /// @return msb The index of the most significant bit as an uint256.\\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\\n        if (x >= 2**128) {\\n            x >>= 128;\\n            msb += 128;\\n        }\\n        if (x >= 2**64) {\\n            x >>= 64;\\n            msb += 64;\\n        }\\n        if (x >= 2**32) {\\n            x >>= 32;\\n            msb += 32;\\n        }\\n        if (x >= 2**16) {\\n            x >>= 16;\\n            msb += 16;\\n        }\\n        if (x >= 2**8) {\\n            x >>= 8;\\n            msb += 8;\\n        }\\n        if (x >= 2**4) {\\n            x >>= 4;\\n            msb += 4;\\n        }\\n        if (x >= 2**2) {\\n            x >>= 2;\\n            msb += 2;\\n        }\\n        if (x >= 2**1) {\\n            // No need to shift x any more.\\n            msb += 1;\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\u00f7denominator) with full precision.\\n    ///\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\\n    ///\\n    /// Requirements:\\n    /// - The denominator cannot be zero.\\n    /// - The result must fit within uint256.\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers.\\n    ///\\n    /// @param x The multiplicand as an uint256.\\n    /// @param y The multiplier as an uint256.\\n    /// @param denominator The divisor as an uint256.\\n    /// @return result The result as an uint256.\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2^256 + prod0.\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division.\\n        if (prod1 == 0) {\\n            unchecked {\\n                result = prod0 / denominator;\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n        if (prod1 >= denominator) {\\n            revert PRBMath__MulDivOverflow(prod1, denominator);\\n        }\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0].\\n        uint256 remainder;\\n        assembly {\\n            // Compute remainder using mulmod.\\n            remainder := mulmod(x, y, denominator)\\n\\n            // Subtract 256 bit number from 512 bit number.\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n        // See https://cs.stackexchange.com/q/138556/92363.\\n        unchecked {\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 lpotdod = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by lpotdod.\\n                denominator := div(denominator, lpotdod)\\n\\n                // Divide [prod1 prod0] by lpotdod.\\n                prod0 := div(prod0, lpotdod)\\n\\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * lpotdod;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\u00f71e18) with full precision.\\n    ///\\n    /// @dev Variant of \\\"mulDiv\\\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\\n    /// being rounded to 1e-18.  See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717.\\n    ///\\n    /// Requirements:\\n    /// - The result must fit within uint256.\\n    ///\\n    /// Caveats:\\n    /// - The body is purposely left uncommented; see the NatSpec comments in \\\"PRBMath.mulDiv\\\" to understand how this works.\\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\\n    ///     1. x * y = type(uint256).max * SCALE\\n    ///     2. (x * y) % SCALE >= SCALE / 2\\n    ///\\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        uint256 prod0;\\n        uint256 prod1;\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        if (prod1 >= SCALE) {\\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\\n        }\\n\\n        uint256 remainder;\\n        uint256 roundUpUnit;\\n        assembly {\\n            remainder := mulmod(x, y, SCALE)\\n            roundUpUnit := gt(remainder, 499999999999999999)\\n        }\\n\\n        if (prod1 == 0) {\\n            unchecked {\\n                result = (prod0 / SCALE) + roundUpUnit;\\n                return result;\\n            }\\n        }\\n\\n        assembly {\\n            result := add(\\n                mul(\\n                    or(\\n                        div(sub(prod0, remainder), SCALE_LPOTD),\\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\\n                    ),\\n                    SCALE_INVERSE\\n                ),\\n                roundUpUnit\\n            )\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\u00f7denominator) with full precision.\\n    ///\\n    /// @dev An extension of \\\"mulDiv\\\" for signed numbers. Works by computing the signs and the absolute values separately.\\n    ///\\n    /// Requirements:\\n    /// - None of the inputs can be type(int256).min.\\n    /// - The result must fit within int256.\\n    ///\\n    /// @param x The multiplicand as an int256.\\n    /// @param y The multiplier as an int256.\\n    /// @param denominator The divisor as an int256.\\n    /// @return result The result as an int256.\\n    function mulDivSigned(\\n        int256 x,\\n        int256 y,\\n        int256 denominator\\n    ) internal pure returns (int256 result) {\\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\\n            revert PRBMath__MulDivSignedInputTooSmall();\\n        }\\n\\n        // Get hold of the absolute values of x, y and the denominator.\\n        uint256 ax;\\n        uint256 ay;\\n        uint256 ad;\\n        unchecked {\\n            ax = x < 0 ? uint256(-x) : uint256(x);\\n            ay = y < 0 ? uint256(-y) : uint256(y);\\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\\n        }\\n\\n        // Compute the absolute value of (x*y)\u00f7denominator. The result must fit within int256.\\n        uint256 rAbs = mulDiv(ax, ay, ad);\\n        if (rAbs > uint256(type(int256).max)) {\\n            revert PRBMath__MulDivSignedOverflow(rAbs);\\n        }\\n\\n        // Get the signs of x, y and the denominator.\\n        uint256 sx;\\n        uint256 sy;\\n        uint256 sd;\\n        assembly {\\n            sx := sgt(x, sub(0, 1))\\n            sy := sgt(y, sub(0, 1))\\n            sd := sgt(denominator, sub(0, 1))\\n        }\\n\\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\\n        // If yes, the result should be negative.\\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\\n    }\\n\\n    /// @notice Calculates the square root of x, rounding down.\\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers.\\n    ///\\n    /// @param x The uint256 number for which to calculate the square root.\\n    /// @return result The result as an uint256.\\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        // Set the initial guess to the least power of two that is greater than or equal to sqrt(x).\\n        uint256 xAux = uint256(x);\\n        result = 1;\\n        if (xAux >= 0x100000000000000000000000000000000) {\\n            xAux >>= 128;\\n            result <<= 64;\\n        }\\n        if (xAux >= 0x10000000000000000) {\\n            xAux >>= 64;\\n            result <<= 32;\\n        }\\n        if (xAux >= 0x100000000) {\\n            xAux >>= 32;\\n            result <<= 16;\\n        }\\n        if (xAux >= 0x10000) {\\n            xAux >>= 16;\\n            result <<= 8;\\n        }\\n        if (xAux >= 0x100) {\\n            xAux >>= 8;\\n            result <<= 4;\\n        }\\n        if (xAux >= 0x10) {\\n            xAux >>= 4;\\n            result <<= 2;\\n        }\\n        if (xAux >= 0x8) {\\n            result <<= 1;\\n        }\\n\\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\\n        unchecked {\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1; // Seven iterations should be enough\\n            uint256 roundedDownResult = x / result;\\n            return result >= roundedDownResult ? roundedDownResult : result;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@prb/math/contracts/PRBMathUD60x18.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\nimport \\\"./PRBMath.sol\\\";\\n\\n/// @title PRBMathUD60x18\\n/// @author Paul Razvan Berg\\n/// @notice Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18\\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\\n/// maximum values permitted by the Solidity type uint256.\\nlibrary PRBMathUD60x18 {\\n    /// @dev Half the SCALE number.\\n    uint256 internal constant HALF_SCALE = 5e17;\\n\\n    /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\\n    uint256 internal constant LOG2_E = 1_442695040888963407;\\n\\n    /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\\n    uint256 internal constant MAX_UD60x18 =\\n        115792089237316195423570985008687907853269984665640564039457_584007913129639935;\\n\\n    /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\\n    uint256 internal constant MAX_WHOLE_UD60x18 =\\n        115792089237316195423570985008687907853269984665640564039457_000000000000000000;\\n\\n    /// @dev How many trailing decimals can be represented.\\n    uint256 internal constant SCALE = 1e18;\\n\\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The arithmetic average as an unsigned 60.18-decimal fixed-point number.\\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        // The operations can never overflow.\\n        unchecked {\\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\\n        }\\n    }\\n\\n    /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\\n    ///\\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n    ///\\n    /// Requirements:\\n    /// - x must be less than or equal to MAX_WHOLE_UD60x18.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number to ceil.\\n    /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\\n    function ceil(uint256 x) internal pure returns (uint256 result) {\\n        if (x > MAX_WHOLE_UD60x18) {\\n            revert PRBMathUD60x18__CeilOverflow(x);\\n        }\\n        assembly {\\n            // Equivalent to \\\"x % SCALE\\\" but faster.\\n            let remainder := mod(x, SCALE)\\n\\n            // Equivalent to \\\"SCALE - remainder\\\" but faster.\\n            let delta := sub(SCALE, remainder)\\n\\n            // Equivalent to \\\"x + delta * (remainder > 0 ? 1 : 0)\\\" but faster.\\n            result := add(x, mul(delta, gt(remainder, 0)))\\n        }\\n    }\\n\\n    /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\\n    ///\\n    /// @dev Uses mulDiv to enable overflow-safe multiplication and division.\\n    ///\\n    /// Requirements:\\n    /// - The denominator cannot be zero.\\n    ///\\n    /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\\n    /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        result = PRBMath.mulDiv(x, SCALE, y);\\n    }\\n\\n    /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\\n    function e() internal pure returns (uint256 result) {\\n        result = 2_718281828459045235;\\n    }\\n\\n    /// @notice Calculates the natural exponent of x.\\n    ///\\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    /// - x must be less than 133.084258667509499441.\\n    ///\\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp(uint256 x) internal pure returns (uint256 result) {\\n        // Without this check, the value passed to \\\"exp2\\\" would be greater than 192.\\n        if (x >= 133_084258667509499441) {\\n            revert PRBMathUD60x18__ExpInputTooBig(x);\\n        }\\n\\n        // Do the fixed-point multiplication inline to save gas.\\n        unchecked {\\n            uint256 doubleScaleProduct = x * LOG2_E;\\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\\n        }\\n    }\\n\\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\\n    ///\\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\\n    ///\\n    /// Requirements:\\n    /// - x must be 192 or less.\\n    /// - The result must fit within MAX_UD60x18.\\n    ///\\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp2(uint256 x) internal pure returns (uint256 result) {\\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\\n        if (x >= 192e18) {\\n            revert PRBMathUD60x18__Exp2InputTooBig(x);\\n        }\\n\\n        unchecked {\\n            // Convert x to the 192.64-bit fixed-point format.\\n            uint256 x192x64 = (x << 64) / SCALE;\\n\\n            // Pass x to the PRBMath.exp2 function, which uses the 192.64-bit fixed-point number representation.\\n            result = PRBMath.exp2(x192x64);\\n        }\\n    }\\n\\n    /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n    /// @param x The unsigned 60.18-decimal fixed-point number to floor.\\n    /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\\n    function floor(uint256 x) internal pure returns (uint256 result) {\\n        assembly {\\n            // Equivalent to \\\"x % SCALE\\\" but faster.\\n            let remainder := mod(x, SCALE)\\n\\n            // Equivalent to \\\"x - remainder * (remainder > 0 ? 1 : 0)\\\" but faster.\\n            result := sub(x, mul(remainder, gt(remainder, 0)))\\n        }\\n    }\\n\\n    /// @notice Yields the excess beyond the floor of x.\\n    /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\\n    /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\\n    /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\\n    function frac(uint256 x) internal pure returns (uint256 result) {\\n        assembly {\\n            result := mod(x, SCALE)\\n        }\\n    }\\n\\n    /// @notice Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation.\\n    ///\\n    /// @dev Requirements:\\n    /// - x must be less than or equal to MAX_UD60x18 divided by SCALE.\\n    ///\\n    /// @param x The basic integer to convert.\\n    /// @param result The same number in unsigned 60.18-decimal fixed-point representation.\\n    function fromUint(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            if (x > MAX_UD60x18 / SCALE) {\\n                revert PRBMathUD60x18__FromUintOverflow(x);\\n            }\\n            result = x * SCALE;\\n        }\\n    }\\n\\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\\n    ///\\n    /// @dev Requirements:\\n    /// - x * y must fit within MAX_UD60x18, lest it overflows.\\n    ///\\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        unchecked {\\n            // Checking for overflow this way is faster than letting Solidity do it.\\n            uint256 xy = x * y;\\n            if (xy / x != y) {\\n                revert PRBMathUD60x18__GmOverflow(x, y);\\n            }\\n\\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\\n            // during multiplication. See the comments within the \\\"sqrt\\\" function.\\n            result = PRBMath.sqrt(xy);\\n        }\\n    }\\n\\n    /// @notice Calculates 1 / x, rounding toward zero.\\n    ///\\n    /// @dev Requirements:\\n    /// - x cannot be zero.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\\n    /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\\n    function inv(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 1e36 is SCALE * SCALE.\\n            result = 1e36 / x;\\n        }\\n    }\\n\\n    /// @notice Calculates the natural logarithm of x.\\n    ///\\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"log2\\\".\\n    /// - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\\n    /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function ln(uint256 x) internal pure returns (uint256 result) {\\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\\n        // can return is 196205294292027477728.\\n        unchecked {\\n            result = (log2(x) * SCALE) / LOG2_E;\\n        }\\n    }\\n\\n    /// @notice Calculates the common logarithm of x.\\n    ///\\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\\n    /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function log10(uint256 x) internal pure returns (uint256 result) {\\n        if (x < SCALE) {\\n            revert PRBMathUD60x18__LogInputTooSmall(x);\\n        }\\n\\n        // Note that the \\\"mul\\\" in this block is the assembly multiplication operation, not the \\\"mul\\\" function defined\\n        // in this contract.\\n        // prettier-ignore\\n        assembly {\\n            switch x\\n            case 1 { result := mul(SCALE, sub(0, 18)) }\\n            case 10 { result := mul(SCALE, sub(1, 18)) }\\n            case 100 { result := mul(SCALE, sub(2, 18)) }\\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\\n            case 1000000000000000000 { result := 0 }\\n            case 10000000000000000000 { result := SCALE }\\n            case 100000000000000000000 { result := mul(SCALE, 2) }\\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\\n            default {\\n                result := MAX_UD60x18\\n            }\\n        }\\n\\n        if (result == MAX_UD60x18) {\\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\\n            unchecked {\\n                result = (log2(x) * SCALE) / 3_321928094887362347;\\n            }\\n        }\\n    }\\n\\n    /// @notice Calculates the binary logarithm of x.\\n    ///\\n    /// @dev Based on the iterative approximation algorithm.\\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n    ///\\n    /// Requirements:\\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\\n    ///\\n    /// Caveats:\\n    /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function log2(uint256 x) internal pure returns (uint256 result) {\\n        if (x < SCALE) {\\n            revert PRBMathUD60x18__LogInputTooSmall(x);\\n        }\\n        unchecked {\\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\\n            uint256 n = PRBMath.mostSignificantBit(x / SCALE);\\n\\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\\n            // because n is maximum 255 and SCALE is 1e18.\\n            result = n * SCALE;\\n\\n            // This is y = x * 2^(-n).\\n            uint256 y = x >> n;\\n\\n            // If y = 1, the fractional part is zero.\\n            if (y == SCALE) {\\n                return result;\\n            }\\n\\n            // Calculate the fractional part via the iterative approximation.\\n            // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\\n                y = (y * y) / SCALE;\\n\\n                // Is y^2 > 2 and so in the range [2,4)?\\n                if (y >= 2 * SCALE) {\\n                    // Add the 2^(-m) factor to the logarithm.\\n                    result += delta;\\n\\n                    // Corresponds to z/2 on Wikipedia.\\n                    y >>= 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\\n    /// fixed-point number.\\n    /// @dev See the documentation for the \\\"PRBMath.mulDivFixedPoint\\\" function.\\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The product as an unsigned 60.18-decimal fixed-point number.\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        result = PRBMath.mulDivFixedPoint(x, y);\\n    }\\n\\n    /// @notice Returns PI as an unsigned 60.18-decimal fixed-point number.\\n    function pi() internal pure returns (uint256 result) {\\n        result = 3_141592653589793238;\\n    }\\n\\n    /// @notice Raises x to the power of y.\\n    ///\\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"exp2\\\", \\\"log2\\\" and \\\"mul\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"exp2\\\", \\\"log2\\\" and \\\"mul\\\".\\n    /// - Assumes 0^0 is 1.\\n    ///\\n    /// @param x Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result x raised to power y, as an unsigned 60.18-decimal fixed-point number.\\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            result = y == 0 ? SCALE : uint256(0);\\n        } else {\\n            result = exp2(mul(log2(x), y));\\n        }\\n    }\\n\\n    /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\\n    /// famous algorithm \\\"exponentiation by squaring\\\".\\n    ///\\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\\n    ///\\n    /// Requirements:\\n    /// - The result must fit within MAX_UD60x18.\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"mul\\\".\\n    /// - Assumes 0^0 is 1.\\n    ///\\n    /// @param x The base as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The exponent as an uint256.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        // Calculate the first iteration of the loop in advance.\\n        result = y & 1 > 0 ? x : SCALE;\\n\\n        // Equivalent to \\\"for(y /= 2; y > 0; y /= 2)\\\" but faster.\\n        for (y >>= 1; y > 0; y >>= 1) {\\n            x = PRBMath.mulDivFixedPoint(x, x);\\n\\n            // Equivalent to \\\"y % 2 == 1\\\" but faster.\\n            if (y & 1 > 0) {\\n                result = PRBMath.mulDivFixedPoint(result, x);\\n            }\\n        }\\n    }\\n\\n    /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\\n    function scale() internal pure returns (uint256 result) {\\n        result = SCALE;\\n    }\\n\\n    /// @notice Calculates the square root of x, rounding down.\\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n    ///\\n    /// Requirements:\\n    /// - x must be less than MAX_UD60x18 / SCALE.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point .\\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            if (x > MAX_UD60x18 / SCALE) {\\n                revert PRBMathUD60x18__SqrtOverflow(x);\\n            }\\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\\n            // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\\n            result = PRBMath.sqrt(x * SCALE);\\n        }\\n    }\\n\\n    /// @notice Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process.\\n    /// @param x The unsigned 60.18-decimal fixed-point number to convert.\\n    /// @return result The same number in basic integer form.\\n    function toUint(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            result = x / SCALE;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@reality.eth/contracts/development/contracts/IBalanceHolder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.8.10;\\n\\ninterface IBalanceHolder {\\n  function withdraw (  ) external;\\n  function balanceOf ( address ) external view returns ( uint256 );\\n}\\n\"\r\n    },\r\n    \"@reality.eth/contracts/development/contracts/IRealityETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.8.10;\\n\\nimport './IBalanceHolder.sol';\\n\\ninterface IRealityETH is IBalanceHolder {\\n     event LogAnswerReveal (bytes32 indexed question_id, address indexed user, bytes32 indexed answer_hash, bytes32 answer, uint256 nonce, uint256 bond);\\n     event LogCancelArbitration (bytes32 indexed question_id);\\n     event LogClaim (bytes32 indexed question_id, address indexed user, uint256 amount);\\n     event LogFinalize (bytes32 indexed question_id, bytes32 indexed answer);\\n     event LogFundAnswerBounty (bytes32 indexed question_id, uint256 bounty_added, uint256 bounty, address indexed user);\\n     event LogMinimumBond (bytes32 indexed question_id, uint256 min_bond);\\n     event LogNewAnswer (bytes32 answer, bytes32 indexed question_id, bytes32 history_hash, address indexed user, uint256 bond, uint256 ts, bool is_commitment);\\n     event LogNewQuestion (bytes32 indexed question_id, address indexed user, uint256 template_id, string question, bytes32 indexed content_hash, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce, uint256 created);\\n     event LogNewTemplate (uint256 indexed template_id, address indexed user, string question_text);\\n     event LogNotifyOfArbitrationRequest (bytes32 indexed question_id, address indexed user);\\n     event LogReopenQuestion (bytes32 indexed question_id, bytes32 indexed reopened_question_id);\\n     event LogSetQuestionFee (address arbitrator, uint256 amount);\\n\\n     function assignWinnerAndSubmitAnswerByArbitrator (bytes32 question_id, bytes32 answer, address payee_if_wrong, bytes32 last_history_hash, bytes32 last_answer_or_commitment_id, address last_answerer) external;\\n     function cancelArbitration (bytes32 question_id) external;\\n     function claimMultipleAndWithdrawBalance (bytes32[] calldata question_ids, uint256[] calldata lengths, bytes32[] calldata hist_hashes, address[] calldata addrs, uint256[] calldata bonds, bytes32[] calldata answers) external;\\n     function claimWinnings (bytes32 question_id, bytes32[] calldata history_hashes, address[] calldata addrs, uint256[] calldata bonds, bytes32[] calldata answers) external;\\n     function createTemplate (string calldata content) external returns (uint256);\\n     function notifyOfArbitrationRequest (bytes32 question_id, address requester, uint256 max_previous) external;\\n     function setQuestionFee (uint256 fee) external;\\n     function submitAnswerByArbitrator (bytes32 question_id, bytes32 answer, address answerer) external;\\n     function submitAnswerReveal (bytes32 question_id, bytes32 answer, uint256 nonce, uint256 bond) external;\\n     function askQuestion (uint256 template_id, string calldata question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce) external payable returns (bytes32);\\n     function askQuestionWithMinBond (uint256 template_id, string calldata question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce, uint256 min_bond) external payable returns (bytes32);\\n     function createTemplateAndAskQuestion (string calldata content, string calldata question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce) external payable returns (bytes32);\\n     function fundAnswerBounty (bytes32 question_id) external payable;\\n     function reopenQuestion (uint256 template_id, string calldata question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce, uint256 min_bond, bytes32 reopens_question_id) external payable returns (bytes32);\\n     function submitAnswer (bytes32 question_id, bytes32 answer, uint256 max_previous) external payable;\\n     function submitAnswerCommitment (bytes32 question_id, bytes32 answer_hash, uint256 max_previous, address _answerer) external payable;\\n     function submitAnswerFor (bytes32 question_id, bytes32 answer, uint256 max_previous, address answerer) external payable;\\n     function arbitrator_question_fees (address) external view returns (uint256);\\n     function commitments (bytes32) external view returns (uint32 reveal_ts, bool is_revealed, bytes32 revealed_answer);\\n     function getArbitrator (bytes32 question_id) external view returns (address);\\n     function getBestAnswer (bytes32 question_id) external view returns (bytes32);\\n     function getBond (bytes32 question_id) external view returns (uint256);\\n     function getBounty (bytes32 question_id) external view returns (uint256);\\n     function getContentHash (bytes32 question_id) external view returns (bytes32);\\n     function getFinalAnswer (bytes32 question_id) external view returns (bytes32);\\n     function getFinalAnswerIfMatches (bytes32 question_id, bytes32 content_hash, address arbitrator, uint32 min_timeout, uint256 min_bond) external view returns (bytes32);\\n     function getFinalizeTS (bytes32 question_id) external view returns (uint32);\\n     function getHistoryHash (bytes32 question_id) external view returns (bytes32);\\n     function getMinBond (bytes32 question_id) external view returns (uint256);\\n     function getOpeningTS (bytes32 question_id) external view returns (uint32);\\n     function getTimeout (bytes32 question_id) external view returns (uint32);\\n     function isFinalized (bytes32 question_id) external view returns (bool);\\n     function isPendingArbitration (bytes32 question_id) external view returns (bool);\\n     function isSettledTooSoon (bytes32 question_id) external view returns (bool);\\n     function question_claims (bytes32) external view returns (address payee, uint256 last_bond, uint256 queued_funds);\\n     function questions (bytes32) external view returns (bytes32 content_hash, address arbitrator, uint32 opening_ts, uint32 timeout, uint32 finalize_ts, bool is_pending_arbitration, uint256 bounty, bytes32 best_answer, bytes32 history_hash, uint256 bond, uint256 min_bond);\\n     function reopened_questions (bytes32) external view returns (bytes32);\\n     function reopener_questions (bytes32) external view returns (bool);\\n     function resultFor (bytes32 question_id) external view returns (bytes32);\\n     function resultForOnceSettled (bytes32 question_id) external view returns (bytes32);\\n     function template_hashes (uint256) external view returns (bytes32);\\n     function templates (uint256) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/implementations/ClearingHouseV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@prb/math/contracts/PRBMathUD60x18.sol\\\";\\n\\nimport \\\"../interfaces/IClearingHouseV2.sol\\\";\\nimport \\\"../library/SigRecovery.sol\\\";\\n\\ncontract ClearingHouseV2 is IClearingHouseV2, Ownable, Pausable {\\n  using SafeERC20 for ERC20;\\n  using SafeERC20 for IWETH;\\n  using PRBMathUD60x18 for uint256;\\n\\n  //###############\\n  //#### STATE ####\\n  //Cause token address => CauseInformation\\n  mapping(ERC20Singleton => CauseInformation) public override causeInformation;\\n  //Cause ID => KYC ID => Running total of amount per user (by KYC ID)\\n  mapping(uint256 => mapping(bytes => uint256)) public override withdrawnAmount;\\n  //Message hash => boolean. To track if a message has been used for purchase previously\\n  mapping(bytes32 => bool) public override usedSignatures;\\n\\n  DonationsRouter public override donationsRouter;\\n  BuyInTokenData public override buyInToken;\\n  StakingRewards public override staking;\\n  IWETH public override WETH;\\n  address public override zeroXSwapTarget;\\n  address public override governor;\\n\\n  // A backend wallet that can generate valid signatures for KYC.\\n  // This address should be used to generate KYC signatures.\\n  address public KYCAuthenticatedSigner;\\n\\n  constructor(\\n    address _owner,\\n    address _donationsRouter,\\n    address _buyInToken,\\n    address _staking,\\n    address _WETH,\\n    address _swapTarget\\n  ) {\\n    _checkZeroAddress(_owner);\\n    _checkZeroAddress(_donationsRouter);\\n    _checkZeroAddress(_buyInToken);\\n    _checkZeroAddress(_staking);\\n    _checkZeroAddress(_WETH);\\n    _checkZeroAddress(_swapTarget);\\n\\n    donationsRouter = DonationsRouter(_donationsRouter);\\n    buyInToken = BuyInTokenData({\\n      tokenAddress: ERC20(_buyInToken),\\n      decimals: ERC20(_buyInToken).decimals()\\n    });\\n    staking = StakingRewards(_staking);\\n    WETH = IWETH(_WETH);\\n    zeroXSwapTarget = _swapTarget;\\n    _transferOwnership(_owner);\\n  }\\n\\n  receive() external payable {}\\n\\n  //############################\\n  //#### INTERNAL FUNCTIONS ####\\n\\n  function _checkZeroAddress(address _address) internal pure {\\n    if (_address == address(0)) {\\n      revert CannotBeZeroAddress();\\n    }\\n  }\\n\\n  function _checkIfCauseOwner(ERC20Singleton _childDaoToken) internal view {\\n    (address causeOwner, , , ) = donationsRouter.causeRecords(\\n      donationsRouter.tokenCauseIds(address(_childDaoToken))\\n    );\\n    if (msg.sender != causeOwner) {\\n      revert AccountNotDaoOwner();\\n    }\\n  }\\n\\n  function _verifySignature(\\n    bytes memory _KYCId,\\n    address _user,\\n    uint256 _causeId,\\n    uint256 _expiry,\\n    bytes memory _signature\\n  ) internal {\\n    if (block.timestamp > _expiry) {\\n      revert ApprovalExpired();\\n    }\\n    (address messageSigner, bytes32 messageHash) = SigRecovery.recoverApproval(\\n      _KYCId,\\n      _user,\\n      _causeId,\\n      _expiry,\\n      _signature\\n    );\\n    if (messageSigner != KYCAuthenticatedSigner) {\\n      revert InvalidSignature();\\n    }\\n    if (usedSignatures[messageHash]) {\\n      revert InvalidSignature();\\n    }\\n    usedSignatures[messageHash] = true;\\n  }\\n\\n  function _checkChildDaoRegistered(uint256 _causeId) internal pure {\\n    if (_causeId == 0) {\\n      revert ChildDaoNotRegistered();\\n    }\\n  }\\n\\n  function _checkReleaseStarted(uint256 _release) internal view {\\n    if (block.timestamp < _release) {\\n      revert ChildDaoReleaseNotStarted();\\n    }\\n  }\\n\\n  function _checkMaxPerUser(\\n    uint256 _amount,\\n    uint256 _maxPerUser,\\n    uint256 _withdrawnAmount\\n  ) internal view {\\n    if (_withdrawnAmount + _amount > _maxPerUser && msg.sender != owner()) {\\n      revert UserAmountExceeded();\\n    }\\n  }\\n\\n  function _mintDaoToken(\\n    uint256 _daoAmount,\\n    ERC20Singleton _childDaoToken,\\n    bool _autoStaking\\n  ) internal {\\n    if (_autoStaking) {\\n      _childDaoToken.mint(address(this), _daoAmount);\\n      staking.stakeOnBehalf(msg.sender, address(_childDaoToken), _daoAmount);\\n    }\\n    _childDaoToken.mint(msg.sender, _daoAmount);\\n  }\\n\\n  function _transferBuyInToken(\\n    uint256 _daoAmount,\\n    uint256 _daoExchangeRate,\\n    address _treasuryAddress,\\n    BuyInTokenData memory _buyInToken,\\n    bool _fromSwap\\n  ) internal {\\n    uint256 buyAmount;\\n    if (_buyInToken.decimals < 18) {\\n      buyAmount = _daoAmount.mul(_daoExchangeRate).mul(\\n        10**_buyInToken.decimals\\n      );\\n    } else {\\n      buyAmount = _daoAmount.mul(_daoExchangeRate);\\n    }\\n    if (_fromSwap) {\\n      _buyInToken.tokenAddress.safeTransfer(_treasuryAddress, buyAmount);\\n    } else {\\n      _buyInToken.tokenAddress.safeTransferFrom(\\n        msg.sender,\\n        _treasuryAddress,\\n        buyAmount\\n      );\\n    }\\n  }\\n\\n  function _returnExtraBuy(SwapData calldata _swapData, uint256 _amountBought)\\n    internal\\n  {\\n    if (_amountBought > _swapData.buyAmount) {\\n      _swapData.buyToken.safeTransfer(\\n        msg.sender,\\n        _amountBought - _swapData.buyAmount\\n      );\\n    }\\n  }\\n\\n  function _callZeroXSwap(SwapData calldata _swapData)\\n    internal\\n    returns (uint256 amountBought)\\n  {\\n    if (_swapData.swapTarget != zeroXSwapTarget) {\\n      revert WrongSwapTarget();\\n    }\\n    (bool success, bytes memory returnData) = _swapData.swapTarget.call(\\n      _swapData.swapTxData\\n    );\\n    if (!success) {\\n      revert ZeroXSwapFailed();\\n    }\\n    amountBought = abi.decode(returnData, ((uint256)));\\n  }\\n\\n  function _swapToken(SwapData calldata _swapData) internal {\\n    _swapData.sellToken.safeTransferFrom(\\n      msg.sender,\\n      address(this),\\n      _swapData.sellAmount\\n    );\\n    uint256 sellBalanceBefore = _swapData.sellToken.balanceOf(address(this)) -\\n      _swapData.sellAmount;\\n    _swapData.sellToken.approve(_swapData.swapTarget, type(uint256).max);\\n    uint256 amountBought = _callZeroXSwap(_swapData);\\n    uint256 sellBalanceAfter = _swapData.sellToken.balanceOf(address(this));\\n    if (sellBalanceAfter > 0) {\\n      _swapData.sellToken.safeTransfer(\\n        msg.sender,\\n        sellBalanceAfter - sellBalanceBefore\\n      );\\n    }\\n    _returnExtraBuy(_swapData, amountBought);\\n  }\\n\\n  function _swapETH(SwapData calldata _swapData) internal {\\n    uint256 sellBalanceBefore = WETH.balanceOf(address(this));\\n    WETH.deposit{value: msg.value}();\\n    WETH.approve(_swapData.swapTarget, type(uint256).max);\\n\\n    uint256 amountBought = _callZeroXSwap(_swapData);\\n    uint256 sellBalanceAfter = _swapData.sellToken.balanceOf(address(this));\\n\\n    if (sellBalanceAfter > 0) {\\n      WETH.withdraw(sellBalanceAfter);\\n\\n      (bool transferSuccess, ) = msg.sender.call{\\n        value: sellBalanceAfter - sellBalanceBefore\\n      }(\\\"\\\");\\n\\n      if (!transferSuccess) {\\n        revert EthTransferFailed();\\n      }\\n    }\\n    _returnExtraBuy(_swapData, amountBought);\\n  }\\n\\n  function _checkInvariants(\\n    ERC20Singleton _childDaoToken,\\n    uint256 _amount,\\n    bytes calldata _KYCId,\\n    uint256 _expiry,\\n    bytes memory _signature\\n  )\\n    internal\\n    returns (\\n      CauseInformation memory causeInfo,\\n      address defaultWallet,\\n      address owner\\n    )\\n  {\\n    uint256 causeId = donationsRouter.tokenCauseIds(address(_childDaoToken));\\n\\n    _checkChildDaoRegistered(causeId);\\n\\n    causeInfo = causeInformation[_childDaoToken];\\n    if (causeInfo.paused) {\\n      revert CausePaused();\\n    }\\n    _checkReleaseStarted(causeInfo.release);\\n\\n    uint256 withdrawnTotal = withdrawnAmount[causeId][_KYCId];\\n    if (causeInfo.kycEnabled) {\\n      _verifySignature(_KYCId, msg.sender, causeId, _expiry, _signature);\\n      _checkMaxPerUser(_amount, causeInfo.maxPerUser, withdrawnTotal);\\n    } else {\\n      _checkMaxPerUser(_amount, causeInfo.maxPerUser, 0);\\n    }\\n    withdrawnAmount[causeId][_KYCId] = withdrawnTotal + _amount;\\n\\n    (owner, defaultWallet, , ) = donationsRouter.causeRecords(causeId);\\n  }\\n\\n  function _normaliseExchangeRate(uint256 _rate)\\n    internal\\n    view\\n    returns (uint256 normalisedRate)\\n  {\\n    BuyInTokenData memory buyInTokenData = buyInToken;\\n    if (buyInTokenData.decimals < 18) {\\n      normalisedRate = (_rate * 10**(18 - buyInTokenData.decimals));\\n    } else {\\n      normalisedRate = _rate;\\n    }\\n  }\\n\\n  function _checkIfGovernor() internal view {\\n    if (msg.sender != governor) {\\n      revert AccountNotGovernor();\\n    }\\n  }\\n\\n  //###################\\n  //#### MODIFIERS ####\\n\\n  modifier onlyCauseOwner(ERC20Singleton _childDaoToken) {\\n    _checkIfCauseOwner(_childDaoToken);\\n    _;\\n  }\\n\\n  modifier onlyGovernor() {\\n    _checkIfGovernor();\\n    _;\\n  }\\n\\n  //###################\\n  //#### FUNCTIONS ####\\n\\n  function registerChildDao(\\n    ERC20Singleton _childDaoToken,\\n    bool _autoStaking,\\n    bool _kycEnabled,\\n    uint256 _maxSupply,\\n    uint256 _maxSwap,\\n    uint256 _release,\\n    uint256 _exchangeRate\\n  ) external override onlyGovernor whenNotPaused {\\n    causeInformation[_childDaoToken] = CauseInformation({\\n      release: _release,\\n      maxSupply: _maxSupply,\\n      maxPerUser: _maxSwap,\\n      exchangeRate: _normaliseExchangeRate(_exchangeRate),\\n      childDaoRegistry: true,\\n      autoStaking: _autoStaking,\\n      kycEnabled: _kycEnabled,\\n      paused: false\\n    });\\n\\n    emit ChildDaoRegistered(address(_childDaoToken));\\n    _childDaoToken.approve(address(staking), type(uint256).max);\\n  }\\n\\n  function purchaseToken(\\n    ERC20Singleton _childDaoToken,\\n    uint256 _amount,\\n    bytes calldata _KYCId,\\n    uint256 _expiry,\\n    bytes memory _signature\\n  ) external override whenNotPaused {\\n    (CauseInformation memory causeInfo, , address owner) = _checkInvariants(\\n      _childDaoToken,\\n      _amount,\\n      _KYCId,\\n      _expiry,\\n      _signature\\n    );\\n    _mintDaoToken(_amount, _childDaoToken, causeInfo.autoStaking);\\n    BuyInTokenData memory buyInTokenData = buyInToken;\\n    _transferBuyInToken(\\n      _amount,\\n      causeInfo.exchangeRate,\\n      owner,\\n      buyInTokenData,\\n      false\\n    );\\n    emit DaoTokenPurchased(_amount, msg.sender, causeInfo.autoStaking);\\n  }\\n\\n  function mintTokens(\\n    ERC20Singleton _childDaoToken,\\n    uint256 _amount,\\n    bytes calldata _KYCId,\\n    uint256 _expiry,\\n    bytes memory _signature\\n  ) external override whenNotPaused {\\n    (CauseInformation memory causeInfo, ,) = _checkInvariants(\\n      _childDaoToken,\\n      _amount,\\n      _KYCId,\\n      _expiry,\\n      _signature\\n    );\\n\\n    _mintDaoToken(_amount, _childDaoToken, causeInfo.autoStaking);\\n\\n    emit DaoTokenPurchased(_amount, msg.sender, causeInfo.autoStaking);\\n  }\\n\\n  function swapAndPurchaseToken(\\n    ERC20Singleton _childDaoToken,\\n    uint256 _amount,\\n    bytes calldata _KYCId,\\n    uint256 _expiry,\\n    bytes memory _signature,\\n    SwapData calldata _swapData\\n  ) external override whenNotPaused {\\n    BuyInTokenData memory buyInTokenData = buyInToken;\\n\\n    (\\n      CauseInformation memory causeInfo,\\n      address defaultWallet,\\n\\n    ) = _checkInvariants(_childDaoToken, _amount, _KYCId, _expiry, _signature);\\n    _swapToken(_swapData);\\n    _mintDaoToken(_amount, _childDaoToken, causeInfo.autoStaking);\\n    _transferBuyInToken(\\n      _amount,\\n      causeInfo.exchangeRate,\\n      defaultWallet,\\n      buyInTokenData,\\n      true\\n    );\\n    emit DaoTokenPurchased(_amount, msg.sender, causeInfo.autoStaking);\\n  }\\n\\n  function swapETHAndPurchaseToken(\\n    ERC20Singleton _childDaoToken,\\n    uint256 _amount,\\n    bytes calldata _KYCId,\\n    uint256 _expiry,\\n    bytes memory _signature,\\n    SwapData calldata _swapData\\n  ) external payable override whenNotPaused {\\n    BuyInTokenData memory buyInTokenData = buyInToken;\\n\\n    if (_swapData.buyToken != buyInTokenData.tokenAddress) {\\n      revert WrongBuyToken();\\n    }\\n    if (address(_swapData.sellToken) != address(WETH)) {\\n      revert WrongSellToken();\\n    }\\n    (\\n      CauseInformation memory causeInfo,\\n      address defaultWallet,\\n\\n    ) = _checkInvariants(_childDaoToken, _amount, _KYCId, _expiry, _signature);\\n    _swapETH(_swapData);\\n    _mintDaoToken(_amount, _childDaoToken, causeInfo.autoStaking);\\n    _transferBuyInToken(\\n      _amount,\\n      causeInfo.exchangeRate,\\n      defaultWallet,\\n      buyInTokenData,\\n      true\\n    );\\n    emit DaoTokenPurchased(_amount, msg.sender, causeInfo.autoStaking);\\n  }\\n\\n  //##########################\\n  //#### SETTER FUNCTIONS ####\\n\\n  function setAutoStake(ERC20Singleton _childDaoToken, bool _state)\\n    external\\n    override\\n    onlyCauseOwner(_childDaoToken)\\n  {\\n    causeInformation[_childDaoToken].autoStaking = _state;\\n  }\\n\\n  function enableKyc(ERC20Singleton _childDaoToken)\\n    external\\n    override\\n    onlyCauseOwner(_childDaoToken)\\n  {\\n    causeInformation[_childDaoToken].kycEnabled = true;\\n  }\\n\\n  function setMaxPerUser(ERC20Singleton _childDaoToken, uint256 _max)\\n    external\\n    override\\n    onlyCauseOwner(_childDaoToken)\\n  {\\n    causeInformation[_childDaoToken].maxPerUser = _max;\\n  }\\n\\n  function setExchangeRate(ERC20Singleton _childDaoToken, uint256 _rate)\\n    external\\n    override\\n    onlyCauseOwner(_childDaoToken)\\n  {\\n    causeInformation[_childDaoToken].exchangeRate = _normaliseExchangeRate(\\n      _rate\\n    );\\n  }\\n\\n  function pauseCause(ERC20Singleton _childDaoToken)\\n    external\\n    override\\n    onlyCauseOwner(_childDaoToken)\\n  {\\n    causeInformation[_childDaoToken].paused = true;\\n  }\\n\\n  function unpauseCause(ERC20Singleton _childDaoToken)\\n    external\\n    override\\n    onlyCauseOwner(_childDaoToken)\\n  {\\n    causeInformation[_childDaoToken].paused = false;\\n  }\\n\\n  function setDonationsRouter(DonationsRouter _implementation)\\n    external\\n    override\\n    onlyOwner\\n  {\\n    _checkZeroAddress(address(_implementation));\\n    donationsRouter = _implementation;\\n  }\\n\\n  function setBuyInToken(ERC20 _implementation) external override onlyOwner {\\n    _checkZeroAddress(address(_implementation));\\n    buyInToken = BuyInTokenData({\\n      tokenAddress: _implementation,\\n      decimals: _implementation.decimals()\\n    });\\n  }\\n\\n  function setAuthenticatedKYCSigner(address _newSigner)\\n    external\\n    override\\n    onlyOwner\\n  {\\n    _checkZeroAddress(_newSigner);\\n    KYCAuthenticatedSigner = _newSigner;\\n  }\\n\\n  function setStakingRewards(StakingRewards _implementation)\\n    external\\n    override\\n    onlyOwner\\n  {\\n    _checkZeroAddress(address(_implementation));\\n    staking = _implementation;\\n  }\\n\\n  function setSwapTarget(address _implementation) external override onlyOwner {\\n    _checkZeroAddress(_implementation);\\n    zeroXSwapTarget = _implementation;\\n  }\\n\\n  function setGovernor(address _implementation) external onlyOwner {\\n    _checkZeroAddress(_implementation);\\n    governor = _implementation;\\n  }\\n\\n  function pause() external override onlyOwner {\\n    _pause();\\n  }\\n\\n  function unpause() external override onlyOwner {\\n    _unpause();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/implementations/DaoResellQueue.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"../interfaces/IDaoResellQueue.sol\\\";\\n\\ncontract DaoResellQueue is IDaoResellQueue {\\n  mapping(address => uint32) public override causeSplitId;\\n  mapping(uint32 => uint256) public override split;\\n  mapping(address => mapping(uint256 => SaleItem)) public override saleItems;\\n  mapping(address => CumulativeTotals) public override cumulativeTotals;\\n  uint256 public override saleItemCounter;\\n\\n  address public override clearingHouse;\\n\\n  constructor(address _clearingHouse) {\\n    _checkZeroAddress(_clearingHouse);\\n    clearingHouse = _clearingHouse;\\n  }\\n\\n  function _checkZeroAddress(address _address) internal pure {\\n    if (_address == address(0)) {\\n      revert CannotBeZeroAddress();\\n    }\\n  }\\n\\n  function _incremenetSaleItemCounter()\\n    internal\\n    returns (uint256 incrementedCount)\\n  {}\\n\\n  function enqueue(address _causeToken, uint128 _amount) external override {}\\n\\n  function dequeue(address _causeToken, uint128 _saleId) external override {}\\n\\n  function purchaseAvailable(address _causeToken, uint256 _amount)\\n    external\\n    override\\n    returns (PurchaseItem[] memory purchaseItems)\\n  {}\\n\\n  function forceDequeue(address _causeToken, uint128[] calldata _listingIds)\\n    external\\n    override\\n  {}\\n\\n  function setSaleSplit(address _causeToken, uint256 _splitAmount)\\n    external\\n    override\\n  {}\\n\\n  function validateProceedsClaim(address _causeToken, uint256 _saleItemId)\\n    external\\n    override\\n  {}\\n}\\n\"\r\n    },\r\n    \"contracts/implementations/DonationsRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@prb/math/contracts/PRBMathUD60x18.sol\\\";\\nimport \\\"../interfaces/IDonationsRouter.sol\\\";\\nimport \\\"../interfaces/IStakingRewards.sol\\\";\\nimport \\\"../interfaces/IThinWallet.sol\\\";\\nimport \\\"./Queue.sol\\\";\\n\\ncontract DonationsRouter is IDonationsRouter, Ownable, Queue {\\n  using PRBMathUD60x18 for uint256;\\n\\n  ERC20 public immutable override baseToken;\\n  IStakingRewards public immutable override stakingContract;\\n\\n  address public immutable override walletImplementation;\\n\\n  uint256 public override causeId;\\n  uint256 public override platformFee;\\n\\n  /// Cause ID => Cause record\\n  mapping(uint256 => CauseRecord) public override causeRecords;\\n\\n  /// Token => CauseID\\n  mapping(address => uint256) public override tokenCauseIds;\\n\\n  /// Thin wallet salt => thin wallet address\\n  mapping(bytes32 => address) public override deployedWallets;\\n  // keccak(owner, token) => is registered\\n  mapping(bytes32 => bool) public isRegistered;\\n\\n  constructor(\\n    address _baseToken,\\n    address _stakingContract,\\n    address _owner,\\n    address _walletImplementation\\n  ) {\\n    require(_baseToken != address(0), \\\"invalid base token\\\");\\n    require(_stakingContract != address(0), \\\"invalid staking contract\\\");\\n    require(_owner != address(0), \\\"invalid owner\\\");\\n    require(_walletImplementation != address(0), \\\"invalid implementation\\\");\\n\\n    baseToken = ERC20(_baseToken);\\n    stakingContract = IStakingRewards(_stakingContract);\\n    walletImplementation = _walletImplementation;\\n\\n    _transferOwnership(_owner);\\n  }\\n\\n  function setPlatformFee(uint256 _fee) external override onlyOwner {\\n    emit UpdateFee(platformFee, _fee);\\n    platformFee = _fee;\\n  }\\n\\n  function registerCause(CauseRegistrationRequest calldata _cause)\\n    external\\n    override\\n  {\\n    require(_cause.owner != address(0), \\\"invalid owner\\\");\\n    require(_cause.daoToken != address(0), \\\"invalid token\\\");\\n\\n    bytes32 causeRegistrationHash = keccak256(\\n      abi.encode(_cause.owner, _cause.daoToken)\\n    );\\n    require(!isRegistered[causeRegistrationHash], \\\"cause exists\\\");\\n    isRegistered[causeRegistrationHash] = true;\\n\\n    uint256 id = ++causeId; // Increments then returns, thus causeId starts at 1\\n\\n    CauseRecord memory cause = CauseRecord({\\n      owner: _cause.owner,\\n      rewardPercentage: _cause.rewardPercentage,\\n      daoToken: _cause.daoToken,\\n      defaultWallet: calculateThinWallet(\\n        ThinWalletID({ causeId: id, thinWalletId: abi.encode(id) })\\n      )\\n    });\\n\\n    causeRecords[id] = cause;\\n\\n    emit RegisterCause(_cause.owner, _cause.daoToken, id);\\n\\n    tokenCauseIds[_cause.daoToken] = id;\\n    address[] memory owners = new address[](1);\\n    owners[0] = _cause.owner;\\n    _deployWallet(\\n      _getSalt(ThinWalletID({ causeId: id, thinWalletId: abi.encode(id) })),\\n      owners\\n    );\\n\\n    ERC20(_cause.daoToken).approve(address(stakingContract), type(uint256).max);\\n  }\\n\\n  function updateCause(uint256 _causeId, CauseUpdateRequest calldata _cause)\\n    external\\n    override\\n  {\\n    require(_causeId <= causeId, \\\"invalid cause\\\");\\n    CauseRecord memory cause = causeRecords[_causeId];\\n    require(msg.sender == cause.owner, \\\"not authorized\\\");\\n    require(_cause.owner != address(0), \\\"invalid owner\\\");\\n\\n    cause.owner = _cause.owner;\\n    cause.rewardPercentage = _cause.rewardPercentage;\\n\\n    causeRecords[_causeId] = cause;\\n\\n    emit UpdateCause(cause);\\n  }\\n\\n  function calculateThinWallet(ThinWalletID memory _walletId)\\n    public\\n    view\\n    override\\n    returns (address wallet)\\n  {\\n    wallet = Clones.predictDeterministicAddress(\\n      walletImplementation,\\n      _getSalt(_walletId)\\n    );\\n  }\\n\\n  function registerThinWallet(\\n    ThinWalletID calldata _walletId,\\n    address[] calldata _owners\\n  ) external override {\\n    bytes32 salt = _getSalt(_walletId);\\n    require(deployedWallets[salt] == address(0), \\\"already deployed\\\");\\n    require(_owners.length >= 1, \\\"invalid owners\\\");\\n    CauseRecord memory cause = causeRecords[_walletId.causeId];\\n\\n    require(_walletId.causeId <= causeId, \\\"invalid cause\\\");\\n    require(msg.sender == cause.owner, \\\"unauthorized\\\");\\n\\n    address wallet = calculateThinWallet(_walletId);\\n\\n    emit RegisterWallet(wallet, _walletId);\\n\\n    _deployWallet(salt, _owners);\\n  }\\n\\n  function withdrawFromThinWallet(\\n    ThinWalletID calldata _walletId,\\n    WithdrawalRequest calldata _withdrawal,\\n    bytes32 _proposalId\\n  ) external override {\\n    require(_walletId.causeId <= causeId, \\\"invalid cause\\\");\\n    CauseRecord memory cause = causeRecords[_walletId.causeId];\\n\\n    require(msg.sender == cause.owner, \\\"unauthorized\\\");\\n    require(_proposalId != \\\"\\\", \\\"invalid proposal id\\\");\\n    uint128 queueToWithdraw = getFront(_walletId.causeId);\\n    QueueItem memory item = getQueueItem(_walletId.causeId, queueToWithdraw);\\n    if (\\n      item.isUnclaimed &&\\n      item.id == keccak256(abi.encode(_walletId.causeId, _proposalId))\\n    ) {\\n      dequeue(_walletId.causeId);\\n    } else {\\n      revert(\\\"not head of queue\\\");\\n    }\\n\\n    bytes32 salt = _getSalt(_walletId);\\n    IThinWallet wallet = IThinWallet(deployedWallets[salt]);\\n\\n    if (address(wallet) == address(0)) {\\n      address[] memory owners = new address[](1);\\n      owners[0] = cause.owner;\\n      wallet = IThinWallet(_deployWallet(salt, owners));\\n\\n      emit RegisterWallet(address(wallet), _walletId);\\n    }\\n\\n    emit WithdrawFromWallet(_walletId, _withdrawal);\\n\\n    address rewardToken = address(baseToken);\\n\\n    if (_withdrawal.token == rewardToken) {\\n      uint256 rewardAmount = _withdrawal.amount.mul(cause.rewardPercentage);\\n      uint256 feeAmount = _withdrawal.amount.mul(platformFee);\\n\\n      IThinWallet.TokenMovement[]\\n        memory transfers = new IThinWallet.TokenMovement[](3);\\n      transfers[0] = IThinWallet.TokenMovement({\\n        token: rewardToken,\\n        recipient: owner(),\\n        amount: feeAmount\\n      });\\n      transfers[1] = IThinWallet.TokenMovement({\\n        token: rewardToken,\\n        recipient: _withdrawal.recipient,\\n        amount: _withdrawal.amount - (feeAmount + rewardAmount)\\n      });\\n      transfers[2] = IThinWallet.TokenMovement({\\n        token: rewardToken,\\n        recipient: address(this),\\n        amount: rewardAmount\\n      });\\n\\n      wallet.transferERC20(transfers);\\n\\n      (stakingContract.rewardToken()).increaseAllowance(\\n        address(stakingContract),\\n        rewardAmount\\n      );\\n      stakingContract.distributeRewards(cause.daoToken, rewardAmount);\\n    } else {\\n      IThinWallet.TokenMovement[]\\n        memory transfers = new IThinWallet.TokenMovement[](1);\\n      transfers[0] = IThinWallet.TokenMovement({\\n        token: rewardToken,\\n        recipient: _withdrawal.recipient,\\n        amount: _withdrawal.amount\\n      });\\n      wallet.transferERC20(transfers);\\n    }\\n  }\\n\\n  function addToQueue(uint256 _causeId, bytes32 _proposalId) external {\\n    require(_proposalId != bytes32(0), \\\"invalid proposal id\\\");\\n    CauseRecord memory cause = causeRecords[_causeId];\\n    require(msg.sender == cause.owner, \\\"unauthorized\\\");\\n    bytes32 queueId = keccak256(abi.encode(_causeId, _proposalId));\\n    enqueue(_causeId, queueId);\\n  }\\n\\n  function removeFromQueue(\\n    uint256 _causeId,\\n    bytes32 _proposalId,\\n    uint128 _index\\n  ) external {\\n    CauseRecord memory cause = causeRecords[_causeId];\\n    require(msg.sender == cause.owner, \\\"unauthorized\\\");\\n\\n    bytes32 queueId = keccak256(abi.encode(_causeId, _proposalId));\\n    QueueItem memory item = getQueueItem(_causeId, _index);\\n    require(item.id == queueId, \\\"id does not match index item\\\");\\n\\n    dequeue(_causeId, _index);\\n  }\\n\\n  function getQueueAtIndex(uint256 _causeId, uint128 _index)\\n    external\\n    view\\n    returns (QueuedItem memory item)\\n  {\\n    QueueItem memory retrievedItem = getQueueItem(_causeId, _index);\\n    item = QueuedItem({\\n      next: retrievedItem.next,\\n      previous: retrievedItem.previous,\\n      id: retrievedItem.id,\\n      isUnclaimed: retrievedItem.isUnclaimed\\n    });\\n  }\\n\\n  function getFirstInQueue(uint256 _causeId)\\n    external\\n    view\\n    returns (uint128 queueFront)\\n  {\\n    queueFront = getFront(_causeId);\\n  }\\n\\n  function getLastInQueue(uint256 _causeId)\\n    external\\n    view\\n    returns (uint128 queueBack)\\n  {\\n    queueBack = getBack(_causeId);\\n  }\\n\\n  /// ### Internal functions\\n  function _getSalt(ThinWalletID memory _walletId)\\n    internal\\n    pure\\n    returns (bytes32 salt)\\n  {\\n    salt = keccak256(abi.encode(_walletId));\\n  }\\n\\n  function _deployWallet(bytes32 salt, address[] memory owners)\\n    internal\\n    returns (address wallet)\\n  {\\n    wallet = Clones.cloneDeterministic(walletImplementation, salt);\\n\\n    deployedWallets[salt] = wallet;\\n\\n    IThinWallet(wallet).initialize(address(this), owners);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/implementations/ERC20Singleton.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\nimport \\\"../interfaces/IERC20Singleton.sol\\\";\\n\\ncontract ERC20Singleton is\\n  IERC20Singleton,\\n  Initializable,\\n  ERC20Upgradeable,\\n  OwnableUpgradeable\\n{\\n  error MaxSupplyReached();\\n\\n  uint256 maxSupply;\\n\\n  constructor() initializer {\\n    __ERC20_init(\\\"Singleton Base\\\", \\\"BASE\\\");\\n    __Ownable_init();\\n    maxSupply = 1 ether;\\n    transferOwnership(address(1));\\n  }\\n\\n  function initialize(\\n    bytes calldata _name,\\n    bytes calldata _symbol,\\n    uint256 _maxSupply,\\n    address _owner,\\n    address _preMintDestination,\\n    uint256 _preMintAmount\\n  ) external initializer {\\n    if (_preMintAmount > _maxSupply) {\\n      revert MaxSupplyReached();\\n    }\\n    if (_preMintAmount > 0) {\\n      _mint(_preMintDestination, _preMintAmount);\\n    }\\n    __ERC20_init(string(_name), string(_symbol));\\n    __Ownable_init();\\n    maxSupply = _maxSupply;\\n    transferOwnership(_owner);\\n  }\\n\\n  function mint(address account, uint256 amount) external override onlyOwner {\\n    if (this.totalSupply() + amount > maxSupply) {\\n      revert MaxSupplyReached();\\n    }\\n    _mint(account, amount);\\n  }\\n\\n  function burn(address account, uint256 amount) external override onlyOwner {\\n    _burn(account, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/implementations/Governor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\\\";\\n\\nimport \\\"./ERC20Singleton.sol\\\";\\nimport \\\"../interfaces/IGovernor.sol\\\";\\nimport \\\"../interfaces/IModuleProxyFactory.sol\\\";\\nimport \\\"../vendors/IGnosisSafe.sol\\\";\\nimport \\\"@reality.eth/contracts/development/contracts/IRealityETH.sol\\\";\\n\\ncontract Governor is IGovernor, Ownable, ERC721Holder {\\n  PublicResolver public override ensResolver;\\n  ENSRegistry public override ensRegistry;\\n  IENSRegistrar public override ensRegistrar;\\n  GnosisSafeProxyFactory public override gnosisFactory;\\n  address public override gnosisSafeSingleton;\\n  address public override erc20Singleton;\\n  uint256 public override ensDomainNFTId;\\n  IClearingHouseV2 public clearingHouse;\\n  IDonationsRouter public donationsRouter;\\n\\n  constructor(ConstructorParams memory _params) {\\n    require(\\n      address(_params.ensResolver) != address(0),\\n      \\\"invalid resolver address\\\"\\n    );\\n    require(\\n      address(_params.ensRegistry) != address(0),\\n      \\\"invalid registry address\\\"\\n    );\\n    require(\\n      address(_params.ensRegistrar) != address(0),\\n      \\\"invalid registrar address\\\"\\n    );\\n    require(\\n      address(_params.gnosisFactory) != address(0),\\n      \\\"invalid factory address\\\"\\n    );\\n    require(\\n      _params.gnosisSafeSingleton != address(0),\\n      \\\"invalid safe singleton address\\\"\\n    );\\n    require(\\n      _params.erc20Singleton != address(0),\\n      \\\"invalid token singleton address\\\"\\n    );\\n    require(_params.parentDao != address(0), \\\"invalid owner\\\");\\n    require(\\n      address(_params.clearingHouse) != address(0),\\n      \\\"invalid clearing house address\\\"\\n    );\\n    require(\\n      address(_params.donationsRouter) != address(0),\\n      \\\"invalid donations router address\\\"\\n    );\\n\\n    ensResolver = _params.ensResolver;\\n    ensRegistry = _params.ensRegistry;\\n    ensRegistrar = _params.ensRegistrar;\\n    gnosisFactory = _params.gnosisFactory;\\n    gnosisSafeSingleton = _params.gnosisSafeSingleton;\\n    erc20Singleton = _params.erc20Singleton;\\n    clearingHouse = _params.clearingHouse;\\n    donationsRouter = _params.donationsRouter;\\n\\n    transferOwnership(_params.parentDao);\\n  }\\n\\n  receive() external payable {}\\n\\n  function addENSDomain(uint256 _domainNFTId) external override onlyOwner {\\n    require(ensDomainNFTId == 0, \\\"ens domain already set\\\");\\n    ensDomainNFTId = _domainNFTId;\\n    ensRegistrar.safeTransferFrom(\\n      address(msg.sender),\\n      address(this),\\n      _domainNFTId\\n    );\\n\\n    ensRegistrar.reclaim(_domainNFTId, address(this));\\n  }\\n\\n  function withdrawENSDomain(address _destination) external override onlyOwner {\\n    require(ensDomainNFTId > 0, \\\"ens domain not set\\\");\\n    uint256 _domainNFTId = ensDomainNFTId;\\n    delete ensDomainNFTId;\\n    ensRegistrar.safeTransferFrom(address(this), _destination, _domainNFTId);\\n  }\\n\\n  function createChildDAO(\\n    Token calldata _tokenData,\\n    Safe calldata _safeData,\\n    Subdomain calldata _subdomain\\n  ) external override {\\n    require(ensDomainNFTId > 0, \\\"ENS domain unavailable\\\");\\n\\n    // Need to disable auto staking initially\\n    require(_tokenData.autoStaking == false, \\\"disable auto staking\\\");\\n\\n    /// Gnosis multi sig\\n    (address safe, ) = _createGnosisSafe(\\n      _safeData.safe,\\n      _safeData.zodiac,\\n      uint256(keccak256(abi.encodePacked(_subdomain.subdomain, address(this))))\\n    );\\n\\n    /// Token\\n    address token = _createERC20Clone(\\n      _tokenData.tokenName,\\n      _tokenData.tokenSymbol,\\n      _tokenData.maxSupply,\\n      safe,\\n      _tokenData.mintingAmount\\n    );\\n\\n    /// Register the token in the clearing house contract\\n    clearingHouse.registerChildDao(\\n      ERC20Singleton(token),\\n      _tokenData.autoStaking,\\n      _tokenData.kycRequired,\\n      _tokenData.maxSupply,\\n      _tokenData.maxSwap,\\n      _tokenData.release,\\n      _tokenData.exchangeRate\\n    );\\n    /// ENS Subdomain + Snapshot text record\\n    bytes32 node = _createENSSubdomain(\\n      safe,\\n      _subdomain.subdomain,\\n      _subdomain.snapshotKey,\\n      _subdomain.snapshotValue\\n    );\\n\\n    emit ChildDaoCreated(safe, token, node);\\n\\n    try\\n      donationsRouter.registerCause(\\n        IDonationsRouter.CauseRegistrationRequest({\\n          owner: address(safe),\\n          rewardPercentage: _tokenData.rewardPercentage,\\n          daoToken: address(token)\\n        })\\n      )\\n    {} catch (bytes memory reason) {\\n      emit RegisterCauseFailure(reason);\\n    }\\n  }\\n\\n  function _checkZeroAddress(address _address) internal pure {\\n    if (_address == address(0)) {\\n      revert CannotBeZeroAddress();\\n    }\\n  }\\n\\n  function _createGnosisSafe(\\n    SafeCreationParams memory safeData,\\n    ZodiacParams memory zodiacData,\\n    uint256 safeDeploymentSalt\\n  ) internal returns (address safe, address module) {\\n    address[] memory initialOwners = new address[](safeData.owners.length + 1);\\n    uint256 i;\\n    for (i = 0; i < safeData.owners.length; ++i) {\\n      initialOwners[i] = safeData.owners[i];\\n    }\\n    initialOwners[initialOwners.length - 1] = address(this);\\n    safe = address(\\n      gnosisFactory.createProxyWithNonce(\\n        gnosisSafeSingleton,\\n        _getSafeInitializer(\\n          SafeCreationParams({\\n            owners: initialOwners,\\n            threshold: 1,\\n            to: safeData.to,\\n            data: \\\"\\\",\\n            fallbackHandler: safeData.fallbackHandler,\\n            paymentToken: safeData.paymentToken,\\n            payment: safeData.payment,\\n            paymentReceiver: safeData.paymentReceiver\\n          })\\n        ),\\n        safeDeploymentSalt\\n      )\\n    );\\n    /// @dev The reality module requires a template. This will create, or reuse an existing one.\\n    uint256 templateId;\\n    if (bytes(zodiacData.template).length > 0) {\\n      templateId = IRealityETH(zodiacData.oracle).createTemplate(\\n        zodiacData.template\\n      );\\n    } else {\\n      // @dev reality template IDs start at 0;\\n      templateId = zodiacData.templateId;\\n    }\\n\\n    module = IModuleProxyFactory(zodiacData.zodiacFactory).deployModule(\\n      zodiacData.moduleMasterCopy,\\n      _getZodiacInitializer(safe, templateId, zodiacData),\\n      uint256(keccak256(abi.encode(safeDeploymentSalt)))\\n    );\\n    /// @dev Enable the newly deployed module on our safe\\n    IGnosisSafe(safe).execTransaction(\\n      safe,\\n      0,\\n      abi.encodeWithSignature(\\\"enableModule(address)\\\", module),\\n      IGnosisSafe.Operation.Call,\\n      0,\\n      0,\\n      0,\\n      address(0),\\n      payable(msg.sender),\\n      _getApprovedHashSignature()\\n    );\\n    /// @dev Remove this contract as an owner in the safe\\n    IGnosisSafe(safe).execTransaction(\\n      safe,\\n      0,\\n      abi.encodeWithSignature(\\n        \\\"removeOwner(address,address,uint256)\\\",\\n        initialOwners[initialOwners.length - 2],\\n        initialOwners[initialOwners.length - 1],\\n        safeData.threshold\\n      ),\\n      IGnosisSafe.Operation.Call,\\n      0,\\n      0,\\n      0,\\n      address(0),\\n      payable(msg.sender),\\n      _getApprovedHashSignature()\\n    );\\n    emit ZodiacModuleEnabled(safe, module, templateId);\\n  }\\n\\n  function _getApprovedHashSignature()\\n    internal\\n    view\\n    returns (bytes memory signature)\\n  {\\n    signature = abi.encodePacked(\\n      bytes32(uint256(uint160(address(this)))),\\n      bytes32(0),\\n      uint8(1)\\n    );\\n  }\\n\\n  function _getZodiacInitializer(\\n    address safe,\\n    uint256 templateId,\\n    ZodiacParams memory zodiacData\\n  ) internal pure returns (bytes memory initializer) {\\n    initializer = abi.encodeWithSignature(\\n      \\\"setUp(bytes)\\\",\\n      abi.encode(\\n        safe,\\n        safe,\\n        safe,\\n        zodiacData.oracle,\\n        zodiacData.timeout,\\n        zodiacData.cooldown,\\n        zodiacData.expiration,\\n        zodiacData.bond,\\n        templateId,\\n        zodiacData.arbitrator == address(0) ? safe : zodiacData.arbitrator\\n      )\\n    );\\n  }\\n\\n  function _getSafeInitializer(SafeCreationParams memory safeData)\\n    internal\\n    pure\\n    returns (bytes memory initData)\\n  {\\n    initData = abi.encodeWithSignature(\\n      \\\"setup(address[],uint256,address,bytes,address,address,uint256,address)\\\",\\n      safeData.owners,\\n      safeData.threshold,\\n      safeData.to,\\n      safeData.data,\\n      safeData.fallbackHandler,\\n      safeData.paymentToken,\\n      safeData.payment,\\n      safeData.paymentReceiver\\n    );\\n  }\\n\\n  function _createERC20Clone(\\n    bytes memory _name,\\n    bytes memory _symbol,\\n    uint256 _maxSupply,\\n    address _preMintDestination,\\n    uint256 _preMint\\n  ) internal returns (address token) {\\n    token = Clones.cloneDeterministic(\\n      erc20Singleton,\\n      keccak256(abi.encodePacked(_name, _symbol, _maxSupply))\\n    );\\n    ERC20Singleton(token).initialize(\\n      _name,\\n      _symbol,\\n      _maxSupply,\\n      address(clearingHouse),\\n      _preMintDestination,\\n      _preMint\\n    );\\n  }\\n\\n  function _calculateENSNode(bytes32 baseNode, bytes32 childNode)\\n    internal\\n    pure\\n    returns (bytes32 ensNode)\\n  {\\n    ensNode = keccak256(abi.encodePacked(baseNode, childNode));\\n  }\\n\\n  function _createENSSubdomain(\\n    address _owner,\\n    bytes memory _name,\\n    bytes memory _key,\\n    bytes memory _value\\n  ) internal returns (bytes32 childNode) {\\n    bytes32 labelHash = keccak256(_name);\\n\\n    bytes32 ensBaseNode = ensRegistrar.baseNode();\\n    bytes32 parentNode = _calculateENSNode(\\n      ensBaseNode,\\n      bytes32(ensDomainNFTId)\\n    );\\n    childNode = _calculateENSNode(parentNode, labelHash);\\n\\n    ensRegistry.setSubnodeRecord(\\n      parentNode,\\n      labelHash,\\n      address(this),\\n      address(ensResolver),\\n      3600\\n    );\\n\\n    ensResolver.setAddr(childNode, _owner);\\n\\n    ensResolver.setText(childNode, string(_key), string(_value));\\n  }\\n\\n  function getPredictedAddresses(\\n    Token calldata _tokenData,\\n    Safe calldata _safeData,\\n    bytes calldata _subdomain\\n  )\\n    external\\n    returns (\\n      address token,\\n      address safe,\\n      address realityModule\\n    )\\n  {\\n    token = Clones.predictDeterministicAddress(\\n      erc20Singleton,\\n      keccak256(\\n        abi.encodePacked(\\n          _tokenData.tokenName,\\n          _tokenData.tokenSymbol,\\n          _tokenData.maxSupply\\n        )\\n      )\\n    );\\n    (safe, realityModule) = _createGnosisSafe(\\n      _safeData.safe,\\n      _safeData.zodiac,\\n      uint256(keccak256(abi.encodePacked(_subdomain, address(this))))\\n    );\\n  }\\n\\n  function setENSRecord(\\n    bytes calldata _name,\\n    bytes calldata _key,\\n    bytes calldata _value\\n  ) external {\\n    bytes32 labelHash = keccak256(_name);\\n\\n    bytes32 ensBaseNode = ensRegistrar.baseNode();\\n    bytes32 parentNode = _calculateENSNode(\\n      ensBaseNode,\\n      bytes32(ensDomainNFTId)\\n    );\\n    bytes32 childNode = _calculateENSNode(parentNode, labelHash);\\n    ensResolver.setText(childNode, string(_key), string(_value));\\n\\n    emit ENSTextRecordSet(_name, _key, _value);\\n\\n    require(msg.sender == ensResolver.addr(childNode), \\\"Invalid owner\\\");\\n  }\\n\\n  function setEnsResolver(PublicResolver _implementation)\\n    external\\n    override\\n    onlyOwner\\n  {\\n    _checkZeroAddress(address(_implementation));\\n    ensResolver = _implementation;\\n  }\\n\\n  function setEnsRegistry(ENSRegistry _implementation) external onlyOwner {\\n    _checkZeroAddress(address(_implementation));\\n    ensRegistry = _implementation;\\n  } //#\\n\\n  function setEnsRegistrar(IENSRegistrar _implementation) external onlyOwner {\\n    _checkZeroAddress(address(_implementation));\\n    ensRegistrar = _implementation;\\n  }\\n\\n  function setGnosisFactory(GnosisSafeProxyFactory _implementation)\\n    external\\n    onlyOwner\\n  {\\n    _checkZeroAddress(address(_implementation));\\n    gnosisFactory = _implementation;\\n  }\\n\\n  function setGnosisSafeSingleton(address _implementation) external onlyOwner {\\n    _checkZeroAddress(address(_implementation));\\n    gnosisSafeSingleton = _implementation;\\n  }\\n\\n  function setErc20Singleton(address _implementation) external onlyOwner {\\n    _checkZeroAddress(address(_implementation));\\n    erc20Singleton = _implementation;\\n  }\\n\\n  function setClearingHouse(IClearingHouseV2 _implementation)\\n    external\\n    onlyOwner\\n  {\\n    _checkZeroAddress(address(_implementation));\\n    clearingHouse = _implementation;\\n  }\\n\\n  function setDonationsRouter(IDonationsRouter _implementation)\\n    external\\n    onlyOwner\\n  {\\n    _checkZeroAddress(address(_implementation));\\n    donationsRouter = _implementation;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/implementations/Queue.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nabstract contract Queue {\\n    struct QueueManager {\\n        uint128 front;\\n        uint128 back;\\n    }\\n    struct QueueItem {\\n        uint128 next; // The next item to be claimed in the queue. If this is the last item (at back of queue), next should be 0\\n        uint128 previous; // The previous item in the queue. If this is the first item (at the front of the queue), previous should be 0\\n        bytes32 id; // An unique identifier for the queue item. This will link the add to queue and withdrawal functions.\\n        bool isUnclaimed; // Set to true when enqueuing. We can delete the struct when dequeueing, saving some gas.\\n    }\\n\\n    // Cause ID => queue manager\\n    mapping(uint256 => QueueManager) private queueManagers;\\n\\n    // Queue is operating in reverse and simulates an array with a mapping for gas reasons. It's an implementation of a doubly linked list.\\n    // [(front) 1][2][(back) 3] (add item) => [(front) 1][2][3][(back) 4]\\n    // [(front) 1][2][(back) 3] (remove item) => [(front) 2][(back) 3]\\n    // keccak(causeID, index) => queue item\\n    mapping(bytes32 => QueueItem) private queueItems;\\n\\n    /// @notice Adds a new item to the cause queue\\n    /// @dev _id should not be reused\\n    /// @param _causeId  The cause to queue an item for\\n    /// @param _id  The unique ID to use when linking enqueue and withdrawal transactions\\n    function enqueue(uint256 _causeId, bytes32 _id) internal {\\n        uint128 currentHead = getFront(_causeId);\\n        uint128 currentTail = getBack(_causeId);\\n        uint128 newTail = currentTail + 1;\\n\\n        if (currentHead == 0){\\n            currentHead = newTail;\\n        }\\n\\n        queueItems[keccak256(abi.encode(_causeId, newTail))] = QueueItem({\\n            next: 0,\\n            previous: currentTail,\\n            id: _id,\\n            isUnclaimed: true\\n        });\\n\\n        if (currentTail != 0) {\\n            QueueItem memory item = getQueueItem(_causeId, currentTail);\\n            uint128 prev = item.previous;\\n            bytes32 id = item.id;\\n            \\n            queueItems[keccak256(abi.encode(_causeId, currentTail))] = QueueItem({\\n                next: newTail,\\n                previous: prev,\\n                id: id,\\n                isUnclaimed: true\\n            });\\n        }\\n\\n        queueManagers[_causeId] = QueueManager({\\n            front: currentHead,\\n            back: newTail\\n        });\\n    }\\n\\n    /// @notice Removes an item from the queue\\n    /// @param _causeId  the cause to dequeue an item for\\n    function dequeue(uint256 _causeId) internal {\\n        _removeFromQueue(_causeId, getFront(_causeId));\\n    }\\n\\n    /// @notice Removes an arbitrarily placed item from the queue\\n    /// @param _causeId  the cause to dequeue an item for\\n    /// @param _index  The index of the item to dequeue. This should be the queue front, unless it's being used to remove an arbitrarily located item from the queue (ie from the middle)\\n    function dequeue(uint256 _causeId, uint128 _index) internal {\\n        _removeFromQueue(_causeId, _index);\\n    }\\n\\n    /// @notice Removes an item from the cause queue\\n    /// @param _causeId  the cause to dequeue an item for\\n    /// @param _index  The index of the item to dequeue. This should be the queue front, unless it's being used to remove an arbitrarily located item from the queue (ie from the middle)\\n    function _removeFromQueue(uint256 _causeId, uint128 _index) private {\\n        uint128 currentHead = getFront(_causeId);\\n        uint128 currentTail = getBack(_causeId);\\n\\n        bytes32 id = keccak256(abi.encode(_causeId, _index));\\n\\n        QueueItem memory item = getQueueItem(_causeId, _index);\\n        uint128 next = item.next;\\n        uint128 previous = item.previous;\\n    \\n        QueueManager storage manager = queueManagers[_causeId];\\n        uint128 newPrevious = next; uint128 newNext = previous;\\n        if (_index == currentHead){\\n            newPrevious = 0;\\n            manager.front = next;\\n        }\\n        if(_index == currentTail){\\n            newNext = 0;\\n            manager.back = previous;\\n        }\\n\\n        queueItems[keccak256(abi.encode(_causeId, next))].previous = newPrevious;\\n        queueItems[keccak256(abi.encode(_causeId, previous))].next = newNext;\\n    \\n        delete queueItems[id];\\n    }\\n\\n    /// @notice Returns the current ID at the front of the queue\\n    function getFront(uint256 _causeId)\\n        internal\\n        view\\n        returns (uint128 queueFront)\\n    {\\n        QueueManager memory manager = queueManagers[_causeId];\\n        queueFront = manager.front;\\n    }\\n\\n    /// @notice Returns the current ID at the back of the queue\\n    function getBack(uint256 _causeId)\\n        internal\\n        view\\n        returns (uint128 queueBack)\\n    {\\n        QueueManager memory manager = queueManagers[_causeId];\\n        queueBack = manager.back;\\n    }\\n\\n    /// @notice Returns the queue item at a given index\\n    function getQueueItem(uint256 _causeId, uint128 _index)\\n        internal\\n        view\\n        returns (QueueItem memory item)\\n    {\\n        item = queueItems[keccak256(abi.encode(_causeId, _index))];\\n    }\\n}\"\r\n    },\r\n    \"contracts/implementations/StakingRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@prb/math/contracts/PRBMathUD60x18.sol\\\";\\nimport \\\"../interfaces/IStakingRewards.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\ncontract StakingRewards is IStakingRewards, Ownable {\\n  using SafeERC20 for ERC20;\\n  using PRBMathUD60x18 for uint256;\\n\\n  ERC20 public immutable override rewardToken;\\n\\n  // Dao token => dao reward data\\n  mapping(address => RewardDistribution) public override daoRewards;\\n  // Dao token => user address => user stake data\\n  mapping(address => mapping(address => UserStake)) public override userStakes;\\n\\n  uint256 public lockupPeriod;\\n\\n  constructor(\\n    address _rewardToken,\\n    address _owner,\\n    uint256 _lockupPeriod\\n  ) {\\n    require(_rewardToken != address(0), \\\"invalid reward token\\\");\\n    rewardToken = ERC20(_rewardToken);\\n    lockupPeriod = _lockupPeriod;\\n    transferOwnership(_owner);\\n  }\\n\\n  modifier isUnlocked(address _daoToken) {\\n    UserStake memory user = userStakes[_daoToken][msg.sender];\\n    require(\\n      block.timestamp >= user.timeStaked + lockupPeriod,\\n      \\\"stake still locked\\\"\\n    );\\n    _;\\n  }\\n\\n  function setLockupPeriod(uint256 _lockupPeriod) external override onlyOwner {\\n    lockupPeriod = _lockupPeriod;\\n  }\\n\\n  function stake(address _daoToken, uint256 _amount) external override {\\n    _processStake(msg.sender, _daoToken, _amount);\\n  }\\n\\n  function stakeOnBehalf(\\n    address _user,\\n    address _daoToken,\\n    uint256 _amount\\n  ) external override {\\n    require(_user != address(0), \\\"invalid user\\\");\\n    _processStake(_user, _daoToken, _amount);\\n  }\\n\\n  function unstake(\\n    address _daoToken,\\n    uint256 _amount,\\n    address _to\\n  ) external override isUnlocked(_daoToken) {\\n    require(_daoToken != address(0), \\\"invalid token\\\");\\n    require(_amount > 0, \\\"invalid amount\\\");\\n    require(_to != address(0), \\\"invalid destination\\\");\\n\\n    RewardDistribution memory dao = daoRewards[_daoToken];\\n    UserStake memory user = userStakes[_daoToken][msg.sender];\\n\\n    require(_amount <= user.stakedAmount, \\\"invalid unstake amount\\\");\\n\\n    // Save their currently earned reward entitlement\\n    user.pendingRewards += _getRewardAmount(\\n      user.stakedAmount,\\n      dao.rewardPerToken,\\n      user.rewardEntry\\n    );\\n\\n    user.stakedAmount -= _amount;\\n    user.rewardEntry = dao.rewardPerToken;\\n    dao.totalStake -= _amount;\\n\\n    if (dao.totalStake == 0) {\\n      // Last man out the door resets the staking contract for that DAO.\\n      dao.rewardPerToken = 0;\\n    }\\n\\n    daoRewards[_daoToken] = dao;\\n    userStakes[_daoToken][msg.sender] = user;\\n\\n    emit Unstake(msg.sender, _daoToken, _amount);\\n\\n    ERC20(_daoToken).safeTransfer(_to, _amount);\\n  }\\n\\n  function claimRewards(address _daoToken, address _to) external override {\\n    require(_daoToken != address(0), \\\"invalid dao token\\\");\\n    require(_to != address(0), \\\"invalid destination\\\");\\n\\n    RewardDistribution memory dao = daoRewards[_daoToken];\\n    UserStake memory user = userStakes[_daoToken][msg.sender];\\n\\n    uint256 entitlement = _getRewardAmount(\\n      user.stakedAmount,\\n      dao.rewardPerToken,\\n      user.rewardEntry\\n    ) + user.pendingRewards;\\n\\n    user.pendingRewards = 0;\\n    user.rewardEntry = dao.rewardPerToken;\\n\\n    userStakes[_daoToken][msg.sender] = user;\\n\\n    emit ClaimRewards(msg.sender, _daoToken, entitlement);\\n\\n    rewardToken.safeTransfer(_to, entitlement);\\n  }\\n\\n  function emergencyEject(address _daoToken, address _to)\\n    external\\n    override\\n    isUnlocked(_daoToken)\\n  {\\n    require(_daoToken != address(0), \\\"invalid dao token\\\");\\n    require(_to != address(0), \\\"invalid destination\\\");\\n\\n    RewardDistribution memory dao = daoRewards[_daoToken];\\n    UserStake memory user = userStakes[_daoToken][msg.sender];\\n\\n    uint256 entitlement = _getRewardAmount(\\n      user.stakedAmount,\\n      dao.rewardPerToken,\\n      user.rewardEntry\\n    ) + user.pendingRewards;\\n\\n    uint256 ejectAmount = user.stakedAmount;\\n    user.stakedAmount = 0;\\n    user.rewardEntry = 0;\\n    user.pendingRewards = 0;\\n    dao.totalStake -= ejectAmount;\\n\\n    if (dao.totalStake > 0) {\\n      // Distribute user's lost rewards to everyone else.\\n      dao.rewardPerToken = _calculateRewardPerToken(\\n        dao.rewardPerToken,\\n        entitlement,\\n        dao.totalStake\\n      );\\n    } else {\\n      // Last man out the door resets the dao\\n      dao.rewardPerToken = 0;\\n    }\\n\\n    daoRewards[_daoToken] = dao;\\n    userStakes[_daoToken][msg.sender] = user;\\n\\n    emit Eject(msg.sender, _daoToken, ejectAmount);\\n\\n    ERC20(_daoToken).safeTransfer(_to, ejectAmount);\\n  }\\n\\n  function distributeRewards(address _daoToken, uint256 _amount)\\n    external\\n    override\\n  {\\n    require(_daoToken != address(0), \\\"invalid dao\\\");\\n    require(_amount > 0, \\\"invalid amount\\\");\\n\\n    RewardDistribution memory dao = daoRewards[_daoToken];\\n\\n    if (dao.totalStake == 0) {\\n      dao.rewardPerToken += _amount;\\n    } else {\\n      dao.rewardPerToken = _calculateRewardPerToken(\\n        dao.rewardPerToken,\\n        _amount,\\n        dao.totalStake\\n      );\\n    }\\n\\n    daoRewards[_daoToken] = dao;\\n\\n    // Emit event\\n    emit Distribution(_daoToken, _amount);\\n\\n    rewardToken.safeTransferFrom(msg.sender, address(this), _amount);\\n  }\\n\\n  function pendingRewards(address _user, address _daoToken)\\n    external\\n    view\\n    override\\n    returns (uint256 rewardAmount)\\n  {\\n    RewardDistribution memory dao = daoRewards[_daoToken];\\n    UserStake memory user = userStakes[_daoToken][_user];\\n\\n    rewardAmount =\\n      _getRewardAmount(\\n        user.stakedAmount,\\n        dao.rewardPerToken,\\n        user.rewardEntry\\n      ) +\\n      user.pendingRewards;\\n  }\\n\\n  /// ### Internal functions\\n\\n  /// @notice Processes the stake for both stake and stake on behalf functions\\n  /// @param _user The user the tokens are being staked on behalf for\\n  /// @param _daoToken The governance token of the dao to be staked.\\n  /// @param _amount The amount of governance token to be staked\\n  function _processStake(\\n    address _user,\\n    address _daoToken,\\n    uint256 _amount\\n  ) internal {\\n    require(_daoToken != address(0), \\\"invalid token\\\");\\n    require(_amount > 0, \\\"invalid amount\\\");\\n\\n    RewardDistribution memory dao = daoRewards[_daoToken];\\n    UserStake memory user = userStakes[_daoToken][_user];\\n\\n    if (dao.totalStake == 0) {\\n      // Distribute reward amount equally across the first staker's tokens\\n      if (dao.rewardPerToken > 0) {\\n        user.pendingRewards = dao.rewardPerToken;\\n        dao.rewardPerToken = _calculateRewardPerToken(\\n          0,\\n          dao.rewardPerToken,\\n          _amount\\n        );\\n      }\\n    } else {\\n      user.pendingRewards += _getRewardAmount(\\n        user.stakedAmount,\\n        dao.rewardPerToken,\\n        user.rewardEntry\\n      );\\n    }\\n\\n    user.rewardEntry = dao.rewardPerToken;\\n    user.stakedAmount += _amount;\\n    user.timeStaked = block.timestamp;\\n    dao.totalStake += _amount;\\n\\n    daoRewards[_daoToken] = dao;\\n    userStakes[_daoToken][_user] = user;\\n\\n    emit Stake(_user, _daoToken, _amount);\\n\\n    ERC20(_daoToken).safeTransferFrom(msg.sender, address(this), _amount);\\n  }\\n\\n  /// @notice Calculates the actual amount of reward token that a user is entitled to\\n  /// @param _userStake  The number of tokens a user has currently staked\\n  /// @param _rewardPerToken  The current reward per token A 60.18 fixed point number\\n  /// @param _userRewardEntry  The reward per token the last time the user modified their stake. A 60.18 fixed point number\\n  function _getRewardAmount(\\n    uint256 _userStake,\\n    uint256 _rewardPerToken,\\n    uint256 _userRewardEntry\\n  ) internal pure returns (uint256 rewardAmount) {\\n    if (_userStake == 0 || _rewardPerToken == _userRewardEntry) return 0;\\n    rewardAmount = PRBMathUD60x18.toUint(\\n      (_userStake.mul(_rewardPerToken) - (_userStake.mul(_userRewardEntry)))\\n    );\\n  }\\n\\n  /// @notice Calculates the reward per token\\n  /// @param _currentRewardPerToken The current reward token per staked token\\n  /// @param _distribution  The amount to distribute\\n  /// @param _totalStake  The total amount of tokens staked\\n  function _calculateRewardPerToken(\\n    uint256 _currentRewardPerToken,\\n    uint256 _distribution,\\n    uint256 _totalStake\\n  ) internal pure returns (uint256 rewardPerToken) {\\n    rewardPerToken =\\n      _currentRewardPerToken +\\n      (PRBMathUD60x18.fromUint(_distribution).div(_totalStake));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IClearingHouseV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"../implementations/ERC20Singleton.sol\\\";\\nimport \\\"../implementations/Governor.sol\\\";\\nimport \\\"../implementations/StakingRewards.sol\\\";\\nimport \\\"../implementations/DonationsRouter.sol\\\";\\nimport \\\"../implementations/DaoResellQueue.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../vendors/IWETH.sol\\\";\\n\\n/// @title Earth Fund Clearing House V2\\n/// @author Sean Long\\n/// @notice Used as part of the Earth Fund ecosystem to manage purchase and resell of DAO tokens\\ninterface IClearingHouseV2 {\\n  //################\\n  //#### STRUCTS ###\\n\\n  /// @notice Used to track cause DAO information\\n  /// @param release Unix time of when DAO tokens are released\\n  /// @param maxSupply Maximum supply of the DAO. **This may be able to be removed**\\n  /// @param maxPerUser Max amount of token per user\\n  /// @param exchangeRate Buy in rate for the DAO token\\n  /// @param childDaoRegistry Used to check if DAO is registered (hard coded to true by setter)\\n  /// @param autoStaking If tokens should automatically be staked\\n  /// @param kycEnabled If KYC is enabled for this cause\\n  /// @param paused Is this cause paused\\n  struct CauseInformation {\\n    uint256 release;\\n    uint256 maxSupply;\\n    uint256 maxPerUser;\\n    uint256 exchangeRate;\\n    bool childDaoRegistry;\\n    bool autoStaking;\\n    bool kycEnabled;\\n    bool paused;\\n  }\\n  /// @notice Input data for swapping a token\\n  /// @param sellToken The token that is being sold (taken) through the swap\\n  /// @param buyToken The token that is being bought (given to caller) through swap\\n  /// @param buyAmount The amount of tokenm to buy\\n  /// @param sellAmount The amount of token to sell\\n  /// @param spender The address taht will be taking the funds from the calling account\\n  /// @param swapTarget The address to send the actual call to\\n  /// @param swapTxData The transaction data to send to the target\\n  struct SwapData {\\n    ERC20 sellToken;\\n    ERC20 buyToken;\\n    uint256 buyAmount;\\n    uint256 sellAmount;\\n    address spender;\\n    address payable swapTarget;\\n    bytes swapTxData;\\n  }\\n\\n  struct BuyInTokenData {\\n    ERC20 tokenAddress;\\n    uint8 decimals;\\n  }\\n\\n  //################\\n  //#### EVENTS ####\\n\\n  /// @notice Emitted when a Child DAO is registered\\n  event ChildDaoRegistered(address childDaoToken);\\n\\n  /// @notice Emitted when a Child DAO token is purchased\\n  event DaoTokenPurchased(uint256 amount, address buyer, bool autoStake);\\n\\n  /// @notice Emitted when max supply is set for a Child Dao\\n  event MaxSupplySet(uint256 maxSupply, ERC20Singleton token);\\n\\n  /// @notice Emitted when max swap (effectively max per user) is set for a Child Dao\\n  event MaxSwapSet(uint256 maxSwap, ERC20Singleton token);\\n\\n  //################\\n  //#### ERRORS ####\\n  /// @dev Thrown if an address value is the zero address\\n  error CannotBeZeroAddress();\\n\\n  /// @dev Thrown if block.timestamp is greater than expiry in provided message for DAO purchase\\n  error ApprovalExpired();\\n\\n  /// @dev Thrown if: message sig already used, message hashes don't match, recoverd signer of message != owner()\\n  error InvalidSignature();\\n\\n  /// @dev Thrown if cumulative withdrawals would exceed maxPerUser w/ KYC on OR transaction purchase amount would exceed maxPerUser w/ KYC off\\n  error UserAmountExceeded();\\n\\n  /// @dev Thrown if the child DAO is not registered\\n  error ChildDaoNotRegistered();\\n\\n  /// @dev Thrown if release of the Child DAO token hasn't started yet\\n  error ChildDaoReleaseNotStarted();\\n\\n  /// @dev Thrown if an account that isn't the DAO owner tries to change DAO configuration\\n  error AccountNotDaoOwner();\\n\\n  /// @dev Thrown if a swap through 0x fails\\n  error ZeroXSwapFailed();\\n\\n  /// @dev Thrown if ETH transfer fails\\n  error EthTransferFailed();\\n\\n  /// @dev Thrown if the token being swap to (bought) is not the platform buyInToken\\n  error WrongBuyToken();\\n\\n  /// @dev Thrown if the sell token != WETH when swapping ETH to buyInTOken\\n  error WrongSellToken();\\n\\n  /// @dev Thrown if pausable operations of a Child DAO token are called while paused\\n  error CausePaused();\\n\\n  /// @dev Thrown if the provided swap target does not match the known target stored in state\\n  error WrongSwapTarget();\\n\\n  /// @dev Thrown if registerChildDao is called by an account != governor stored in state\\n  error AccountNotGovernor();\\n\\n  //###################\\n  //#### FUNCTIONS ####\\n\\n  /// @notice Used to register a child DAO\\n  /// @dev Only callable by Governor. Reverts if paused\\n  /// @param _childDaoToken Address of the Child DAO token\\n  /// @param _autoStaking Auto-stasking enabled\\n  /// @param _kycEnabled KYC enabled\\n  /// @param _maxSupply Max supply for DAO token\\n  /// @param _maxSwap Max amount of DAO token per user or per transaction if KYC is disabled\\n  /// @param _release Unix time tokens should be released\\n  /// @param _exchangeRate Amount of buyInToken tokens => 1 DAO token\\n  function registerChildDao(\\n    ERC20Singleton _childDaoToken,\\n    bool _autoStaking,\\n    bool _kycEnabled,\\n    uint256 _maxSupply,\\n    uint256 _maxSwap,\\n    uint256 _release,\\n    uint256 _exchangeRate\\n  ) external;\\n\\n  /// @notice Used to purchase DAO token of a cause\\n  /// @dev Reverts if paused\\n  /// @param _childDaoToken Address of the DAO token to buy\\n  /// @param _amount Amount of token to buy\\n  /// @param _KYCId KYC ID generated by the back-end\\n  /// @param _expiry Expiry of the signature\\n  /// @param _signature Signature of the above parameters\\n  function purchaseToken(\\n    ERC20Singleton _childDaoToken,\\n    uint256 _amount,\\n    bytes memory _KYCId,\\n    uint256 _expiry,\\n    bytes memory _signature\\n  ) external;\\n\\n  /// @notice Used to mint DAO token of a cause\\n  /// @dev Reverts if paused\\n  /// @param _childDaoToken Address of the DAO token to mint\\n  /// @param _amount Amount of token to buy\\n  /// @param _KYCId KYC ID generated by the back-end\\n  /// @param _expiry Expiry of the signature\\n  /// @param _signature Signature of the above parameters\\n  function mintTokens(\\n    ERC20Singleton _childDaoToken,\\n    uint256 _amount,\\n    bytes memory _KYCId,\\n    uint256 _expiry,\\n    bytes memory _signature\\n  ) external;\\n\\n  /// @notice Used to complete a 0x swap of any token to the platform buy in token and then use the swapped funds to purhcase DAO tokens\\n  /// @dev If the swap results in some sell tokens being left over these will be returned to the calling account\\n  /// @dev If the swap results in extra buy tokens these will be returned to the calling account\\n  /// @dev Must be called with 0x protocal quote info relevant to the swap being completed\\n  /// @param _childDaoToken Address of the DAO token to buy\\n  /// @param _amount Amount of token to buy\\n  /// @param _KYCId KYC ID generated by the back-end\\n  /// @param _expiry Expiry of the signature\\n  /// @param _signature Signature of the above parameters\\n  /// @param _swapData Swap data - see SwapData struct for further details\\n  function swapAndPurchaseToken(\\n    ERC20Singleton _childDaoToken,\\n    uint256 _amount,\\n    bytes calldata _KYCId,\\n    uint256 _expiry,\\n    bytes memory _signature,\\n    SwapData calldata _swapData\\n  ) external;\\n\\n  /// @notice Used to complete a 0x swap of ETH to platform buy in token. This is achieved by wrapping and unwrapping ETH on the way in/out\\n  /// @dev If the swap results in left over ETH this will be unwrapped and returned to the calling account\\n  /// @dev If the swap results in extra buy tokens these will be returned to the calling account\\n  /// @param _childDaoToken Address of the DAO token to buy\\n  /// @param _amount Amount of token to buy\\n  /// @param _KYCId KYC ID generated by the back-end\\n  /// @param _expiry Expiry of the signature\\n  /// @param _signature Signature of the above parameters\\n  /// @param _swapData Swap data - see SwapData struct for further details\\n  function swapETHAndPurchaseToken(\\n    ERC20Singleton _childDaoToken,\\n    uint256 _amount,\\n    bytes calldata _KYCId,\\n    uint256 _expiry,\\n    bytes memory _signature,\\n    SwapData calldata _swapData\\n  ) external payable;\\n\\n  /// @notice Enable / disable auto-staking\\n  /// @dev Only callable by the cause owner\\n  /// @param _childDaoToken Address of the Child DAO token to change\\n  /// @param _state What to set it to\\n  function setAutoStake(ERC20Singleton _childDaoToken, bool _state) external;\\n\\n  /// @notice Enable KYC for a cause\\n  /// @dev Only callable by the cause owner. Cannot be disabled\\n  /// @param _childDaoToken Address of the Child DAO token to change\\n  function enableKyc(ERC20Singleton _childDaoToken) external;\\n\\n  /// @notice Set max amount of DAO token per user\\n  /// @dev Only callable by the cause owner\\n  /// @param _childDaoToken Address of the Child DAO token to change\\n  /// @param _max Maxmimum amount of tokens per user\\n  function setMaxPerUser(ERC20Singleton _childDaoToken, uint256 _max) external;\\n\\n  /// @notice Set exchange rate (amount of token a user needs to swap per DAO token)\\n  /// @dev Only callable by the cause owner\\n  /// @param _childDaoToken Address of the Child DAO token to change\\n  /// @param _rate Exchange rate\\n  function setExchangeRate(ERC20Singleton _childDaoToken, uint256 _rate)\\n    external;\\n\\n  /// @notice Pause a specific cause\\n  /// @dev Only callable by the cause owner\\n  /// @param _childDaoToken The address of the DAO token for the cause\\n  function pauseCause(ERC20Singleton _childDaoToken) external;\\n\\n  /// @notice Unpause a specific cause\\n  /// @dev Only callable by the cause owner\\n  /// @param _childDaoToken The address of the DAO token for the cause\\n  function unpauseCause(ERC20Singleton _childDaoToken) external;\\n\\n  /// @notice Set the donations router contract\\n  /// @dev Only callable by platform owner\\n  /// @param _implementation Contract address\\n  function setDonationsRouter(DonationsRouter _implementation) external;\\n\\n  /// @notice Set the token the platform uses for DAO token buy in\\n  /// @dev Only callable by platform owner\\n  /// @param _implementation Contract address\\n  function setBuyInToken(ERC20 _implementation) external;\\n\\n  /// @notice Set the staking contract\\n  /// @dev Only callable by platform owner\\n  /// @param _implementation Contract address\\n  function setStakingRewards(StakingRewards _implementation) external;\\n\\n  /// @notice Pause the contract\\n  /// @dev Only callable by platform owner\\n  function pause() external;\\n\\n  /// @notice Unpause the contract\\n  /// @dev Only callable by platform owner\\n  function unpause() external;\\n\\n  /// @notice Set the 0x swap target\\n  /// @dev Used to prevent a user from having this contract execute calls on arbitrary contracts\\n  /// @param _implementation New address for the 0x exchange proxy contract\\n  function setSwapTarget(address _implementation) external;\\n\\n  /// @notice Set the address of the governor contract\\n  /// @dev Only callable by platform owner\\n  /// @param _implementation Address of the governor implementation\\n  function setGovernor(address _implementation) external;\\n\\n  /// @notice Sets the authenticated signer for kyc signature generation.\\n  /// @param _newSigner the new signer address\\n  function setAuthenticatedKYCSigner(address _newSigner) external;\\n\\n  //################################\\n  //#### AUTO-GENERATED GETTERS ####\\n\\n  function causeInformation(ERC20Singleton _causeToken)\\n    external\\n    view\\n    returns (\\n      uint256 release,\\n      uint256 maxSupply,\\n      uint256 maxPerUser,\\n      uint256 exchangeRate,\\n      bool childDaoRegistry,\\n      bool autoStaking,\\n      bool kycEnabled,\\n      bool paused\\n    );\\n\\n  function withdrawnAmount(uint256 _causeId, bytes calldata _kycId)\\n    external\\n    view\\n    returns (uint256 amount);\\n\\n  function donationsRouter()\\n    external\\n    view\\n    returns (DonationsRouter implementation);\\n\\n  function staking() external view returns (StakingRewards implementation);\\n\\n  function buyInToken()\\n    external\\n    view\\n    returns (ERC20 tokenAddress, uint8 decimals);\\n\\n  function WETH() external view returns (IWETH implementaiton);\\n\\n  function usedSignatures(bytes32 _message) external returns (bool used);\\n\\n  function zeroXSwapTarget() external view returns (address _implementation);\\n\\n  function governor() external view returns (address _implementation);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDaoResellQueue.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface IDaoResellQueue {\\n  //################\\n  //#### STRUCTS ####\\n\\n  struct SaleItem {\\n    address owner;\\n    uint32 splitId;\\n    uint128 amount;\\n    uint128 claimThreshold;\\n  }\\n\\n  struct PurchaseItem {\\n    address owner;\\n    uint256 split;\\n    uint256 amount;\\n  }\\n\\n  struct CumulativeTotals {\\n    uint128 cumulativeSold;\\n    uint128 cumulativeDeleted;\\n  }\\n\\n  //################\\n  //#### EVENTS ####\\n\\n  event SaleItemQueued(address causeToken, address owner, uint256 saleItem);\\n\\n  event SaleItemDequeued(address causeToken, address owner, uint128 amount);\\n\\n  //################\\n  //#### ERRORS ####\\n\\n  error CannotBeZeroAddress();\\n\\n  //###################\\n  //#### FUNCTIONS ####\\n  function enqueue(address _causeToken, uint128 _amount) external;\\n\\n  function dequeue(address _causeToken, uint128 _saleId) external;\\n\\n  function purchaseAvailable(address _causeToken, uint256 _amount)\\n    external\\n    returns (PurchaseItem[] memory purchaseItems);\\n\\n  // function setMinimumSaleAmount(address _causeToken, uint128 _amount) external;\\n\\n  function forceDequeue(address _causeToken, uint128[] calldata _listingIds)\\n    external;\\n\\n  function setSaleSplit(address _causeToken, uint256 _splitAmount) external;\\n\\n  //################################\\n  //#### AUTO-GENERATED GETTERS ####\\n\\n  function causeSplitId(address _causeToken)\\n    external\\n    view\\n    returns (uint32 splitId);\\n\\n  function split(uint32 _splitId) external view returns (uint256 split);\\n\\n  function saleItems(address _causeToken, uint256 _saleItemId)\\n    external\\n    view\\n    returns (\\n      address owner,\\n      uint32 splitId,\\n      uint128 amount,\\n      uint128 claimThreshold\\n    );\\n\\n  function cumulativeTotals(address _causeToken)\\n    external\\n    view\\n    returns (uint128 totalSold, uint128 totalDeleted);\\n\\n  function clearingHouse() external view returns (address clearingHouse);\\n\\n  function saleItemCounter() external view returns (uint256 id);\\n\\n  function validateProceedsClaim(address _causeToken, uint256 _saleItemId)\\n    external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDonationsRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\nimport \\\"../interfaces/IStakingRewards.sol\\\";\\n\\ninterface IDonationsRouter {\\n  /// ### Structs\\n  struct CauseRegistrationRequest {\\n    address owner;\\n    uint256 rewardPercentage;\\n    address daoToken;\\n  }\\n  struct CauseUpdateRequest {\\n    address owner;\\n    uint256 rewardPercentage;\\n  }\\n\\n  struct CauseRecord {\\n    address owner;\\n    address defaultWallet; /// Default wallet is calculated with cause Id and thin wallet id being equal to each other\\n    address daoToken;\\n    uint256 rewardPercentage; /// A PRBMath 60.18 fixed point number. 1e16 == 1% and 1e18 == 100%\\n  }\\n\\n  struct WithdrawalRequest {\\n    address token;\\n    address recipient;\\n    uint256 amount;\\n  }\\n\\n  struct ThinWalletID {\\n    uint256 causeId;\\n    bytes thinWalletId;\\n  }\\n\\n  struct QueuedItem {\\n    uint128 next; // The next item to be claimed in the queue. If this is the last item (at back of queue), next should be 0\\n    uint128 previous; // The previous item in the queue. If this is the first item (at the front of the queue), previous should be 0\\n    bytes32 id; // An unique identifier for the queue item. This will link the add to queue and withdrawal functions.\\n    bool isUnclaimed; // Set to true when enqueuing. We can delete the struct when dequeueing, saving some gas.\\n  }\\n\\n  /// ### Events\\n\\n  event RegisterCause(\\n    address indexed owner,\\n    address indexed daoToken,\\n    uint256 causeId\\n  );\\n  event RegisterWallet(address indexed walletAddress, ThinWalletID walletId);\\n  event WithdrawFromWallet(ThinWalletID wallet, WithdrawalRequest request);\\n  event UpdateCause(CauseRecord cause);\\n  event UpdateRewardAddress(\\n    address indexed oldRewardAddress,\\n    address indexed newAddress\\n  );\\n  event UpdateFee(uint256 oldFee, uint256 newFee);\\n\\n  /// ### Functions\\n\\n  /// @notice Creates a cause so that it can start using thin wallets that it controls\\n  /// @dev This should be an open function\\n  /// @param _cause  The cause to be registered\\n  function registerCause(CauseRegistrationRequest calldata _cause) external;\\n\\n  /// @notice Updates a cause\\n  /// @dev Can only be called by the current owner of the cause\\n  /// @param _causeId  The cause to update\\n  /// @param _cause  The new details of the cause\\n  function updateCause(uint256 _causeId, CauseUpdateRequest calldata _cause)\\n    external;\\n\\n  /// @notice Sets the address of the staking contract so rewards can be distributed\\n  /// @dev This should be secured\\n  /// @param _rewardContract  The new staking contract\\n  // function setRewardAddress(address _rewardContract) external;\\n\\n  /// @notice Calculates the address that a given thin wallet is or will be deployed to\\n  /// @param _walletId  The wallet parameters to calculate the address from\\n  function calculateThinWallet(ThinWalletID calldata _walletId)\\n    external\\n    view\\n    returns (address wallet);\\n\\n  /// @notice Deploys a thin wallet to the address derived from the parameters given\\n  /// @param _walletId  The wallet parameters\\n  /// @param _owners  The wallet owners to set. These accounts can transfer funds, so they should be limited\\n  function registerThinWallet(\\n    ThinWalletID calldata _walletId,\\n    address[] calldata _owners\\n  ) external;\\n\\n  /// @notice Withdraws funds from the specified thin wallet\\n  /// @param _walletId  The wallet address parameters\\n  /// @param _withdrawal  An array of withdrawal requests for the wallet to process\\n  function withdrawFromThinWallet(\\n    ThinWalletID calldata _walletId,\\n    WithdrawalRequest calldata _withdrawal,\\n    bytes32 _proposalId\\n  ) external;\\n\\n  /// @notice Allows the platform owner to set the platform fee\\n  /// @dev Only the platform owner should be able to call this\\n  /// @param _fee  The new platform fee\\n  function setPlatformFee(uint256 _fee) external;\\n\\n  /// @notice Adds a queue which is linked to a unique identifier using the hash of combined causeID and proposalID\\n  /// @param _causeId The cause id\\n  /// @param _proposalId The proposal id\\n  function addToQueue(uint256 _causeId, bytes32 _proposalId) external;\\n\\n  /// @notice Removes a queue arbitrarily at specified index\\n  /// @param _causeId The cause id\\n  /// @param _proposalId The proposal id\\n  /// @param _index The queue index\\n  function removeFromQueue(\\n    uint256 _causeId,\\n    bytes32 _proposalId,\\n    uint128 _index\\n  ) external;\\n\\n  /// @notice Gets queue item at specific index\\n  /// @param _causeId The cause id\\n  /// @param _index The queue index\\n  function getQueueAtIndex(uint256 _causeId, uint128 _index)\\n    external\\n    view\\n    returns (QueuedItem memory item);\\n\\n  /// @notice Gets first item in queue\\n  /// @param _causeId The cause id\\n  function getFirstInQueue(uint256 _causeId)\\n    external\\n    view\\n    returns (uint128 queueFront);\\n\\n  /// @notice Gets last item in queue\\n  /// @param _causeId The cause id\\n  function getLastInQueue(uint256 _causeId)\\n    external\\n    view\\n    returns (uint128 queueBack);\\n\\n  /// ### Autogenerated getters\\n\\n  function baseToken() external view returns (ERC20 baseToken);\\n\\n  function stakingContract()\\n    external\\n    view\\n    returns (IStakingRewards stakingContract);\\n\\n  function causeId() external view returns (uint256 causeId);\\n\\n  function tokenCauseIds(address token) external view returns (uint256 causeId);\\n\\n  function causeRecords(uint256 causeId)\\n    external\\n    view\\n    returns (\\n      address owner,\\n      address defaultWallet,\\n      address daoToken,\\n      uint256 rewardPercentage\\n    );\\n\\n  function platformFee() external view returns (uint256 fee);\\n\\n  function deployedWallets(bytes32 _salt)\\n    external\\n    view\\n    returns (address wallet);\\n\\n  function walletImplementation()\\n    external\\n    view\\n    returns (address walletImplementation);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Singleton.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\ninterface IERC20Singleton {\\n  function initialize(\\n    bytes calldata _name,\\n    bytes calldata _symbol,\\n    uint256 _maxSupply,\\n    address _owner,\\n    address _preMintDestination,\\n    uint256 _preMintAmount\\n  ) external;\\n\\n  function mint(address account, uint256 amount) external;\\n\\n  function burn(address account, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGovernor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\nimport \\\"@ensdomains/ens-contracts/contracts/resolvers/PublicResolver.sol\\\";\\nimport \\\"@ensdomains/ens-contracts/contracts/registry/ENSRegistry.sol\\\";\\nimport \\\"@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"../vendors/IENSRegistrar.sol\\\";\\nimport \\\"./IClearingHouseV2.sol\\\";\\nimport \\\"./IDonationsRouter.sol\\\";\\n\\ninterface IGovernor {\\n  error CannotBeZeroAddress();\\n  /// Structs\\n  struct ConstructorParams {\\n    PublicResolver ensResolver;\\n    ENSRegistry ensRegistry;\\n    IENSRegistrar ensRegistrar;\\n    GnosisSafeProxyFactory gnosisFactory;\\n    address gnosisSafeSingleton;\\n    address erc20Singleton;\\n    address parentDao;\\n    IClearingHouseV2 clearingHouse;\\n    IDonationsRouter donationsRouter;\\n  }\\n\\n  struct Token {\\n    bytes tokenName;\\n    bytes tokenSymbol;\\n    uint256 maxSupply;\\n    uint256 maxSwap;\\n    uint256 release;\\n    bool autoStaking;\\n    bool kycRequired;\\n    uint256 mintingAmount;\\n    uint256 rewardPercentage;\\n    bytes KYCId;\\n    uint256 expiry;\\n    bytes signature;\\n    uint256 exchangeRate;\\n  }\\n\\n  struct Safe {\\n    SafeCreationParams safe;\\n    ZodiacParams zodiac;\\n  }\\n  struct ZodiacParams {\\n    address zodiacFactory; // The factory to deploy from\\n    address moduleMasterCopy; // The module we want cloned\\n    address oracle; // The public reality.eth oracle contract\\n    uint32 timeout;\\n    uint32 cooldown;\\n    uint32 expiration;\\n    uint256 bond;\\n    uint256 templateId; // To be used to reuse a template\\n    string template; // If this.length > 0, it will be used to create a new template\\n    address arbitrator; // Should probably be kleros general court, or earthfund dao safe.\\n  }\\n\\n  struct SafeCreationParams {\\n    address[] owners;\\n    uint256 threshold;\\n    address to;\\n    bytes data;\\n    address fallbackHandler;\\n    address paymentToken;\\n    uint256 payment;\\n    address payable paymentReceiver;\\n  }\\n\\n  struct Subdomain {\\n    bytes subdomain;\\n    bytes snapshotKey;\\n    bytes snapshotValue;\\n  }\\n\\n  /// Events\\n  event ChildDaoCreated(\\n    address indexed safe,\\n    address indexed token,\\n    bytes32 node\\n  );\\n\\n  event ZodiacModuleEnabled(\\n    address indexed safe,\\n    address indexed module,\\n    uint256 oracleTemplateId\\n  );\\n\\n  event RegisterCauseFailure(bytes failure);\\n\\n  event ENSTextRecordSet(bytes subdomain, bytes key, bytes value);\\n\\n  /// Functions\\n\\n  /// @notice Creates the constituent components of a child dao\\n  /// @param _tokenData The details of the ERC20 token to create\\n  /// @param _safeData The details of the Gnosis safe to create\\n  /// @param _subdomain The details of the ens subdomain to create\\n  function createChildDAO(\\n    Token calldata _tokenData,\\n    Safe calldata _safeData,\\n    Subdomain calldata _subdomain\\n  ) external;\\n\\n  /// @notice Transfers an ENS NFT into the contract for use with subdomains\\n  /// @param _domainNFTId The ENS NFT to transfer in\\n  function addENSDomain(uint256 _domainNFTId) external;\\n\\n  /// @notice Removes the ENS domain from the contract\\n  /// @param _destination The account to transfer the domain to\\n  function withdrawENSDomain(address _destination) external;\\n\\n  function setENSRecord(\\n    bytes calldata _name,\\n    bytes calldata _key,\\n    bytes calldata _value\\n  ) external;\\n\\n  /// @notice Gets the predicted addresses required to create the correct snapshot k/v pair\\n  /// @dev This returns the address in the revert string. abi.decode(address,address,address) returns (token, safe, realityModule)\\n  /// @dev Call off chain using callstatic, and catching the revert string.\\n  /// @param _tokenData  The token creation parameters\\n  /// @param _safeData  The safe creation parameters\\n  /// @param _subdomain  The desired subdomain to be added to the earthfund ens record\\n  function getPredictedAddresses(\\n    Token calldata _tokenData,\\n    Safe calldata _safeData,\\n    bytes calldata _subdomain\\n  )\\n    external\\n    returns (\\n      address token,\\n      address safe,\\n      address realityModule\\n    );\\n\\n  /// @notice Set ENS Resolver contract\\n  /// @dev Only callable by contract owner\\n  /// @param _implementation Contract address\\n  function setEnsResolver(PublicResolver _implementation) external;\\n\\n  /// @notice Set ENS Registry contract\\n  /// @dev Only callable by contract owner\\n  /// @param _implementation Contract address\\n  function setEnsRegistry(ENSRegistry _implementation) external;\\n\\n  /// @notice Set ENS Registrar contract\\n  /// @dev Only callable by contract owner\\n  /// @param _implementation Contract address\\n  function setEnsRegistrar(IENSRegistrar _implementation) external;\\n\\n  /// @notice Set Gnosis Safe Factory contract\\n  /// @dev Only callable by contract owner\\n  /// @param _implementation Contract address\\n  function setGnosisFactory(GnosisSafeProxyFactory _implementation) external;\\n\\n  /// @notice Set Gnosis Safe Singleton contract\\n  /// @dev Only callable by contract owner\\n  /// @param _implementation Contract address\\n  function setGnosisSafeSingleton(address _implementation) external;\\n\\n  /// @notice Set ERC20 Singleton contract\\n  /// @dev Only callable by contract owner\\n  /// @param _implementation Contract address\\n  function setErc20Singleton(address _implementation) external;\\n\\n  /// @notice Set Clearing House contract\\n  /// @dev Only callable by contract owner\\n  /// @param _implementation Contract address\\n  function setClearingHouse(IClearingHouseV2 _implementation) external;\\n\\n  /// @notice Set Donations Router  contract\\n  /// @dev Only callable by contract owner\\n  /// @param _implementation Contract address\\n  function setDonationsRouter(IDonationsRouter _implementation) external;\\n\\n  /// @notice Autogenerated getters\\n  function ensResolver() external view returns (PublicResolver);\\n\\n  function ensRegistry() external view returns (ENSRegistry);\\n\\n  function ensRegistrar() external view returns (IENSRegistrar);\\n\\n  function gnosisFactory() external view returns (GnosisSafeProxyFactory);\\n\\n  function gnosisSafeSingleton() external view returns (address);\\n\\n  function erc20Singleton() external view returns (address);\\n\\n  function clearingHouse()\\n    external\\n    view\\n    returns (IClearingHouseV2 implementation);\\n\\n  function donationsRouter() external view returns (IDonationsRouter);\\n\\n  function ensDomainNFTId() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IModuleProxyFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Source: https://github.com/gnosis/zodiac/blob/master/contracts/factory/ModuleProxyFactory.sol\\npragma solidity 0.8.13;\\n\\ninterface IModuleProxyFactory {\\n  function deployModule(\\n    address masterCopy,\\n    bytes memory initializer,\\n    uint256 saltNonce\\n  ) external returns (address proxy);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStakingRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\ninterface IStakingRewards {\\n    /// ### Structs\\n    struct RewardDistribution {\\n        uint256 totalStake;\\n        uint256 rewardPerToken; // Needs to be boosted by 1e18 before storing so we don't lose precision\\n    }\\n    // If totalstake is 0, first staker gets everything. When ejecting, or withdrawing, and totalstake becomes 0, reward per token should also be set to 0.\\n    struct UserStake {\\n        uint256 stakedAmount;\\n        uint256 rewardEntry;\\n        uint256 pendingRewards;\\n        uint256 timeStaked;\\n    }\\n\\n    /// ### Events\\n    event Stake(address indexed user, address indexed daoToken, uint256 amount);\\n    event Unstake(\\n        address indexed user,\\n        address indexed daoToken,\\n        uint256 amount\\n    );\\n    event ClaimRewards(\\n        address indexed user,\\n        address indexed daoToken,\\n        uint256 amount\\n    );\\n    event Distribution(address indexed daoToken, uint256 amount);\\n    event Eject(\\n        address indexed sender,\\n        address indexed daoToken,\\n        uint256 amount\\n    );\\n\\n    /// ### Functions\\n    /// @notice Updates the lock up period in state\\n    /// @param _lockupPeriod The new \\n    function setLockupPeriod(uint256 _lockupPeriod) external;\\n\\n    /// @notice Stakes amount of dao token into the contract\\n    /// @param _daoToken The governance token of the dao to be staked.\\n    /// @param _amount The amount of governance token to be staked\\n    function stake(address _daoToken, uint256 _amount) external;\\n\\n    /// @notice Stakes amount of dao token into the contract for a user\\n    /// @param _user The user the tokens are being staked on behalf for\\n    /// @param _daoToken The governance token of the dao to be staked.\\n    /// @param _amount The amount of governance token to be staked\\n    function stakeOnBehalf(address _user, address _daoToken, uint256 _amount) external;\\n\\n    /// @notice Unstakes and transfers out a given amount of dao governance tokens\\n    /// @dev This function will also claim any outstanding rewards for the user\\n    /// @param _daoToken The dao governance token to unstake\\n    /// @param _amount The amount to remove\\n    /// @param _to The destination for the dao tokens and rewards\\n    function unstake(\\n        address _daoToken,\\n        uint256 _amount,\\n        address _to\\n    ) external;\\n\\n    /// @notice Claims all outstanding rewards for the user for the specified dao\\n    /// @param _daoToken The dao to claim rewards for.\\n    /// @param _to The destination for the rewards\\n    function claimRewards(address _daoToken, address _to) external;\\n\\n    /// @notice Withdraws the user's dao governance tokens without claiming any outstanding rewards\\n    /// @dev To be used as an emergency exit hatch for users. This will permanently lock any outstanding rewards for the user in the contract.\\n    /// @param _daoToken The dao governance token to eject.\\n    /// @param _to The destination wallet for the ejected tokens\\n    function emergencyEject(address _daoToken, address _to) external;\\n\\n    /// @notice Updates the dao distribution to include an additional amount\\n    /// @dev This should pull tokens from the caller's account\\n    /// @dev This should be coded in such a way as to not require any kind of authorization other than providing an amount of reward tokens.\\n    /// @dev This should handle cases where there aren't any tokens staked: first staker gets everything.\\n    /// @param _daoToken The dao to distribute rewards to\\n    /// @param _amount The amount of reward token to distribute\\n    function distributeRewards(address _daoToken, uint256 _amount) external;\\n\\n    /// @notice Returns the amount of claimable reward tokens for a user for a given dao\\n    /// @param _user The user who staked the tokens\\n    /// @param _daoToken The governance token of the dao the user has staked\\n    /// @return rewardAmount The amount of the reward token that the user is entitled to\\n    function pendingRewards(address _user, address _daoToken)\\n        external\\n        view\\n        returns (uint256 rewardAmount);\\n\\n    /// ### Autogenerated getter functions\\n\\n    function lockupPeriod() external view returns (uint256);\\n\\n    function rewardToken() external view returns (ERC20 rewardToken);\\n\\n    function daoRewards(address _daoToken)\\n        external\\n        view\\n        returns (uint256 totalStake, uint256 rewardPerToken);\\n\\n    function userStakes(address _daoToken, address _user)\\n        external\\n        view\\n        returns (\\n            uint256 stakedAmount,\\n            uint256 rewardEntry,\\n            uint256 pendingRewards,\\n            uint256 timeStaked\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IThinWallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface IThinWallet {\\n    error InvalidPermissions(address _user);\\n    error InvalidAddress();\\n\\n    struct TokenMovement {\\n        address token;\\n        address recipient;\\n        uint256 amount;\\n    }\\n\\n    struct EtherPaymentTransfer {\\n        address recipient;\\n        uint256 amount;\\n    }\\n\\n    /// ### Events\\n    event TransferERC20(TokenMovement[] transfers);\\n    event TransferEther(EtherPaymentTransfer[] transfers);\\n\\n    /// ### Functions\\n    /// @notice Initializes the thin wallet clone with the accounts that can control it\\n    /// @param _admin  This is should be set as the default admin. This will be the donation router\\n    /// @param _owners  The accounts that can call the transfer functions\\n    function initialize(address _admin, address[] calldata _owners) external;\\n\\n    /// @notice Transfers amounts of an ERC20 to one or more recipients\\n    /// @dev If the `setApprove` field is true, the contract should approve that recipient for type(uint256).max\\n    /// @param _transfers  An array of transfers. Each transfer object specifies the amount and recipient to send tokens to\\n    function transferERC20(TokenMovement[] calldata _transfers) external;\\n\\n    /// @notice Transfers amounts of ether to one or more recipeints\\n    /// @dev This should use address(recipient).call to transfer the ether\\n    /// @param _transfers  The ether transfers\\n    function transferEther(EtherPaymentTransfer[] calldata _transfers) external;\\n\\n    /// @notice Transfers the current balance of a token to a destination without processing a split\\n    /// @param _token  The token to transfer\\n    /// @param _destination  The acccount to send the tokens to\\n    function emergencyEjectERC20(address _token, address _destination) external;\\n\\n    /// @notice Transfers the current balance of Ether to the destination without processing a split\\n    /// @param _destination  The account to send the ether to.\\n    function emergencyEjectEth(address _destination) external;\\n}\\n\"\r\n    },\r\n    \"contracts/library/SigRecovery.sol\": {\r\n      \"content\": \"pragma solidity 0.8.13;\\n\\n/**\\n * Helper library to recover admin signatures approving certain user's\\n * as KYCed in the earthfund ecosystem.\\n */\\n\\nlibrary SigRecovery {\\n  function recoverApproval(\\n    bytes memory _KYCId,\\n    address _user,\\n    uint256 _causeId,\\n    uint256 _expiry,\\n    bytes memory _signature\\n  ) internal pure returns (address recoveredAddress, bytes32 messageHash) {\\n    messageHash = recreateApprovalHash(_KYCId, _user, _causeId, _expiry);\\n\\n    (bytes32 r, bytes32 s, uint8 v) = _splitSignature(_signature);\\n\\n    recoveredAddress = ecrecover(messageHash, v, r, s);\\n  }\\n\\n  function recreateApprovalHash(\\n    bytes memory _KYCId,\\n    address _user,\\n    uint256 _causeId,\\n    uint256 _expiry\\n  ) internal pure returns (bytes32 messageHash) {\\n    messageHash = keccak256(\\n      abi.encodePacked(\\n        \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n        keccak256(abi.encode(_KYCId, _user, _causeId, _expiry))\\n      )\\n    );\\n  }\\n\\n  /// @notice Helper function for splitting the signature into its three parts; r s v.\\n  /// @dev This functions output is used when calling the ecrecover helper function\\n  /// @param sig  The signature to split\\n  /// @return r Output from the ECDSA signature\\n  /// @return s The other output from the ECDSA signature\\n  /// @return v The signature recovery ID\\n  function _splitSignature(bytes memory sig)\\n    private\\n    pure\\n    returns (\\n      bytes32 r,\\n      bytes32 s,\\n      uint8 v\\n    )\\n  {\\n    require(sig.length == 65, \\\"Sig: Invalid signature length\\\");\\n\\n    assembly {\\n      // First 32 bytes holds the signature length, skips first 32 bytes as that is the prefix\\n      r := mload(add(sig, 32))\\n      // Gets the following 32 bytes of the signature\\n      s := mload(add(sig, 64))\\n      // Get the final byte (first byte of the next 32 bytes)\\n      v := byte(0, mload(add(sig, 96)))\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/vendors/IENSRegistrar.sol\": {\r\n      \"content\": \"import \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface IENSRegistrar is IERC721 {\\n    function reclaim(uint256 id, address owner) external;\\n\\n    function ens() external returns (address ens);\\n\\n    function baseNode() external view returns (bytes32 base);\\n}\\n\"\r\n    },\r\n    \"contracts/vendors/IGnosisSafe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface IGnosisSafe {\\n  enum Operation {\\n    Call,\\n    DelegateCall\\n  }\\n\\n  function getThreshold() external view returns (uint256);\\n\\n  function isOwner(address owner) external view returns (bool);\\n\\n  /// @dev Returns array of owners.\\n  /// @return Array of Safe owners.\\n  function getOwners() external view returns (address[] memory);\\n\\n  function isModuleEnabled(address module) external view returns (bool);\\n\\n  /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\\n  ///      Note: The fees are always transferred, even if the user transaction fails.\\n  /// @param to Destination address of Safe transaction.\\n  /// @param value Ether value of Safe transaction.\\n  /// @param data Data payload of Safe transaction.\\n  /// @param operation Operation type of Safe transaction.\\n  /// @param safeTxGas Gas that should be used for the Safe transaction.\\n  /// @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\\n  /// @param gasPrice Gas price that should be used for the payment calculation.\\n  /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\\n  /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\\n  /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\\n  function execTransaction(\\n    address to,\\n    uint256 value,\\n    bytes calldata data,\\n    Operation operation,\\n    uint256 safeTxGas,\\n    uint256 baseGas,\\n    uint256 gasPrice,\\n    address gasToken,\\n    address payable refundReceiver,\\n    bytes memory signatures\\n  ) external payable returns (bool success);\\n\\n  /// @dev Allows to remove an owner from the Safe and update the threshold at the same time.\\n  ///      This can only be done via a Safe transaction.\\n  /// @notice Removes the owner `owner` from the Safe and updates the threshold to `_threshold`.\\n  /// @param prevOwner Owner that pointed to the owner to be removed in the linked list\\n  /// @param owner Owner address to be removed.\\n  /// @param _threshold New threshold.\\n  function removeOwner(\\n    address prevOwner,\\n    address owner,\\n    uint256 _threshold\\n  ) external;\\n\\n  /// @dev Setup function sets initial storage of contract.\\n  /// @param _owners List of Safe owners.\\n  /// @param _threshold Number of required confirmations for a Safe transaction.\\n  /// @param to Contract address for optional delegate call.\\n  /// @param data Data payload for optional delegate call.\\n  /// @param fallbackHandler Handler for fallback calls to this contract\\n  /// @param paymentToken Token that should be used for the payment (0 is ETH)\\n  /// @param payment Value that should be paid\\n  /// @param paymentReceiver Address that should receive the payment (or 0 if tx.origin)\\n  function setup(\\n    address[] calldata _owners,\\n    uint256 _threshold,\\n    address to,\\n    bytes calldata data,\\n    address fallbackHandler,\\n    address paymentToken,\\n    uint256 payment,\\n    address payable paymentReceiver\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/vendors/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n  function deposit() external payable;\\n\\n  function withdraw(uint256 amount) external;\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_donationsRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_buyInToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_staking\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_swapTarget\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccountNotDaoOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AccountNotGovernor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotBeZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CausePaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ChildDaoNotRegistered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ChildDaoReleaseNotStarted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EthTransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"prod1\",\"type\":\"uint256\"}],\"name\":\"PRBMath__MulDivFixedPointOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UserAmountExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongBuyToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongSellToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongSwapTarget\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroXSwapFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"childDaoToken\",\"type\":\"address\"}],\"name\":\"ChildDaoRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"autoStake\",\"type\":\"bool\"}],\"name\":\"DaoTokenPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"contract ERC20Singleton\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"MaxSupplySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSwap\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"contract ERC20Singleton\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"MaxSwapSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"KYCAuthenticatedSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyInToken\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20Singleton\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"causeInformation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"release\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPerUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exchangeRate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"childDaoRegistry\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"autoStaking\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"kycEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"donationsRouter\",\"outputs\":[{\"internalType\":\"contract DonationsRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20Singleton\",\"name\":\"_childDaoToken\",\"type\":\"address\"}],\"name\":\"enableKyc\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20Singleton\",\"name\":\"_childDaoToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_KYCId\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"mintTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20Singleton\",\"name\":\"_childDaoToken\",\"type\":\"address\"}],\"name\":\"pauseCause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20Singleton\",\"name\":\"_childDaoToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_KYCId\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"purchaseToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20Singleton\",\"name\":\"_childDaoToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_autoStaking\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_kycEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxSwap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_release\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_exchangeRate\",\"type\":\"uint256\"}],\"name\":\"registerChildDao\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newSigner\",\"type\":\"address\"}],\"name\":\"setAuthenticatedKYCSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20Singleton\",\"name\":\"_childDaoToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setAutoStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"setBuyInToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract DonationsRouter\",\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"setDonationsRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20Singleton\",\"name\":\"_childDaoToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setExchangeRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"setGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20Singleton\",\"name\":\"_childDaoToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_max\",\"type\":\"uint256\"}],\"name\":\"setMaxPerUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract StakingRewards\",\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"setStakingRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"setSwapTarget\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staking\",\"outputs\":[{\"internalType\":\"contract StakingRewards\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20Singleton\",\"name\":\"_childDaoToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_KYCId\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"contract ERC20\",\"name\":\"sellToken\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"buyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"swapTarget\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapTxData\",\"type\":\"bytes\"}],\"internalType\":\"struct IClearingHouseV2.SwapData\",\"name\":\"_swapData\",\"type\":\"tuple\"}],\"name\":\"swapAndPurchaseToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20Singleton\",\"name\":\"_childDaoToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_KYCId\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"contract ERC20\",\"name\":\"sellToken\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"buyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"swapTarget\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapTxData\",\"type\":\"bytes\"}],\"internalType\":\"struct IClearingHouseV2.SwapData\",\"name\":\"_swapData\",\"type\":\"tuple\"}],\"name\":\"swapETHAndPurchaseToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20Singleton\",\"name\":\"_childDaoToken\",\"type\":\"address\"}],\"name\":\"unpauseCause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"usedSignatures\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"withdrawnAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zeroXSwapTarget\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ClearingHouseV2", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000009a147a969a1c742cfaf947b23ebbb6b33508efb6000000000000000000000000fa4d03b62e3a7d193b112eb048b54b29718774f1000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec700000000000000000000000086d26041eab403d5653ad9d1c6a1ecc80d39c1a9000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000def1c0ded9bec7f1a1670819833240f027b25eff", "EVMVersion": "london", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}