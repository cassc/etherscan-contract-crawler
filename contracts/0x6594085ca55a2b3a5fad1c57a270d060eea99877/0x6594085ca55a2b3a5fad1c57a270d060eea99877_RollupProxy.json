{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967Upgrade {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overriden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/bridge/IBridge.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\nimport \\\"./IOwnable.sol\\\";\\n\\ninterface IBridge {\\n    event MessageDelivered(\\n        uint256 indexed messageIndex,\\n        bytes32 indexed beforeInboxAcc,\\n        address inbox,\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash,\\n        uint256 baseFeeL1,\\n        uint64 timestamp\\n    );\\n\\n    event BridgeCallTriggered(\\n        address indexed outbox,\\n        address indexed to,\\n        uint256 value,\\n        bytes data\\n    );\\n\\n    event InboxToggle(address indexed inbox, bool enabled);\\n\\n    event OutboxToggle(address indexed outbox, bool enabled);\\n\\n    event SequencerInboxUpdated(address newSequencerInbox);\\n\\n    event RollupUpdated(address rollup);\\n\\n    function allowedDelayedInboxList(uint256) external returns (address);\\n\\n    function allowedOutboxList(uint256) external returns (address);\\n\\n    /// @dev Accumulator for delayed inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\\n    function delayedInboxAccs(uint256) external view returns (bytes32);\\n\\n    /// @dev Accumulator for sequencer inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\\n    function sequencerInboxAccs(uint256) external view returns (bytes32);\\n\\n    function rollup() external view returns (IOwnable);\\n\\n    function sequencerInbox() external view returns (address);\\n\\n    function activeOutbox() external view returns (address);\\n\\n    function allowedDelayedInboxes(address inbox) external view returns (bool);\\n\\n    function allowedOutboxes(address outbox) external view returns (bool);\\n\\n    function sequencerReportedSubMessageCount() external view returns (uint256);\\n\\n    function executeCall(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData);\\n\\n    function delayedMessageCount() external view returns (uint256);\\n\\n    function sequencerMessageCount() external view returns (uint256);\\n\\n    // ---------- onlySequencerInbox functions ----------\\n\\n    function enqueueSequencerMessage(\\n        bytes32 dataHash,\\n        uint256 afterDelayedMessagesRead,\\n        uint256 prevMessageCount,\\n        uint256 newMessageCount\\n    )\\n        external\\n        returns (\\n            uint256 seqMessageIndex,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 acc\\n        );\\n\\n    /**\\n     * @dev Allows the sequencer inbox to submit a delayed message of the batchPostingReport type\\n     *      This is done through a separate function entrypoint instead of allowing the sequencer inbox\\n     *      to call `enqueueDelayedMessage` to avoid the gas overhead of an extra SLOAD in either\\n     *      every delayed inbox or every sequencer inbox call.\\n     */\\n    function submitBatchSpendingReport(address batchPoster, bytes32 dataHash)\\n        external\\n        returns (uint256 msgNum);\\n\\n    // ---------- onlyRollupOrOwner functions ----------\\n\\n    function setSequencerInbox(address _sequencerInbox) external;\\n\\n    function setDelayedInbox(address inbox, bool enabled) external;\\n\\n    function setOutbox(address inbox, bool enabled) external;\\n\\n    function updateRollupAddress(IOwnable _rollup) external;\\n}\\n\"\r\n    },\r\n    \"src/bridge/IDelayedMessageProvider.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\ninterface IDelayedMessageProvider {\\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\\n\\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\\n    /// same as InboxMessageDelivered but the batch data is available in tx.input\\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\\n}\\n\"\r\n    },\r\n    \"src/bridge/IInboxBase.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\nimport \\\"./IBridge.sol\\\";\\nimport \\\"./IDelayedMessageProvider.sol\\\";\\nimport \\\"./ISequencerInbox.sol\\\";\\n\\ninterface IInboxBase is IDelayedMessageProvider {\\n    function bridge() external view returns (IBridge);\\n\\n    function sequencerInbox() external view returns (ISequencerInbox);\\n\\n    function maxDataSize() external view returns (uint256);\\n\\n    /**\\n     * @notice Send a generic L2 message to the chain\\n     * @dev This method is an optimization to avoid having to emit the entirety of the messageData in a log. Instead validators are expected to be able to parse the data from the transaction's input\\n     * @param messageData Data of the message being sent\\n     */\\n    function sendL2MessageFromOrigin(bytes calldata messageData) external returns (uint256);\\n\\n    /**\\n     * @notice Send a generic L2 message to the chain\\n     * @dev This method can be used to send any type of message that doesn't require L1 validation\\n     * @param messageData Data of the message being sent\\n     */\\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\\n\\n    function sendUnsignedTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 nonce,\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (uint256);\\n\\n    function sendContractTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Get the L1 fee for submitting a retryable\\n     * @dev This fee can be paid by funds already in the L2 aliased address or by the current message value\\n     * @dev This formula may change in the future, to future proof your code query this method instead of inlining!!\\n     * @param dataLength The length of the retryable's calldata, in bytes\\n     * @param baseFee The block basefee when the retryable is included in the chain, if 0 current block.basefee will be used\\n     */\\n    function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee)\\n        external\\n        view\\n        returns (uint256);\\n\\n    // ---------- onlyRollupOrOwner functions ----------\\n\\n    /// @notice pauses all inbox functionality\\n    function pause() external;\\n\\n    /// @notice unpauses all inbox functionality\\n    function unpause() external;\\n\\n    /// @notice add or remove users from allowList\\n    function setAllowList(address[] memory user, bool[] memory val) external;\\n\\n    /// @notice enable or disable allowList\\n    function setAllowListEnabled(bool _allowListEnabled) external;\\n\\n    /// @notice check if user is in allowList\\n    function isAllowed(address user) external view returns (bool);\\n\\n    /// @notice check if allowList is enabled\\n    function allowListEnabled() external view returns (bool);\\n\\n    function initialize(IBridge _bridge, ISequencerInbox _sequencerInbox) external;\\n\\n    /// @notice returns the current admin\\n    function getProxyAdmin() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/bridge/IOutbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\nimport \\\"./IBridge.sol\\\";\\n\\ninterface IOutbox {\\n    event SendRootUpdated(bytes32 indexed outputRoot, bytes32 indexed l2BlockHash);\\n    event OutBoxTransactionExecuted(\\n        address indexed to,\\n        address indexed l2Sender,\\n        uint256 indexed zero,\\n        uint256 transactionIndex\\n    );\\n\\n    function initialize(IBridge _bridge) external;\\n\\n    function rollup() external view returns (address); // the rollup contract\\n\\n    function bridge() external view returns (IBridge); // the bridge contract\\n\\n    function spent(uint256) external view returns (bytes32); // packed spent bitmap\\n\\n    function roots(bytes32) external view returns (bytes32); // maps root hashes => L2 block hash\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function OUTBOX_VERSION() external view returns (uint128); // the outbox version\\n\\n    function updateSendRoot(bytes32 sendRoot, bytes32 l2BlockHash) external;\\n\\n    function updateRollupAddress() external;\\n\\n    /// @notice When l2ToL1Sender returns a nonzero address, the message was originated by an L2 account\\n    ///         When the return value is zero, that means this is a system message\\n    /// @dev the l2ToL1Sender behaves as the tx.origin, the msg.sender should be validated to protect against reentrancies\\n    function l2ToL1Sender() external view returns (address);\\n\\n    /// @return l2Block return L2 block when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\\n    function l2ToL1Block() external view returns (uint256);\\n\\n    /// @return l1Block return L1 block when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\\n    function l2ToL1EthBlock() external view returns (uint256);\\n\\n    /// @return timestamp return L2 timestamp when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\\n    function l2ToL1Timestamp() external view returns (uint256);\\n\\n    /// @return outputId returns the unique output identifier of the L2 to L1 tx or 0 if no L2 to L1 transaction is active\\n    function l2ToL1OutputId() external view returns (bytes32);\\n\\n    /**\\n     * @notice Executes a messages in an Outbox entry.\\n     * @dev Reverts if dispute period hasn't expired, since the outbox entry\\n     *      is only created once the rollup confirms the respective assertion.\\n     * @dev it is not possible to execute any L2-to-L1 transaction which contains data\\n     *      to a contract address without any code (as enforced by the Bridge contract).\\n     * @param proof Merkle proof of message inclusion in send root\\n     * @param index Merkle path to message\\n     * @param l2Sender sender if original message (i.e., caller of ArbSys.sendTxToL1)\\n     * @param to destination address for L1 contract call\\n     * @param l2Block l2 block number at which sendTxToL1 call was made\\n     * @param l1Block l1 block number at which sendTxToL1 call was made\\n     * @param l2Timestamp l2 Timestamp at which sendTxToL1 call was made\\n     * @param value wei in L1 message\\n     * @param data abi-encoded L1 message data\\n     */\\n    function executeTransaction(\\n        bytes32[] calldata proof,\\n        uint256 index,\\n        address l2Sender,\\n        address to,\\n        uint256 l2Block,\\n        uint256 l1Block,\\n        uint256 l2Timestamp,\\n        uint256 value,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     *  @dev function used to simulate the result of a particular function call from the outbox\\n     *       it is useful for things such as gas estimates. This function includes all costs except for\\n     *       proof validation (which can be considered offchain as a somewhat of a fixed cost - it's\\n     *       not really a fixed cost, but can be treated as so with a fixed overhead for gas estimation).\\n     *       We can't include the cost of proof validation since this is intended to be used to simulate txs\\n     *       that are included in yet-to-be confirmed merkle roots. The simulation entrypoint could instead pretend\\n     *       to confirm a pending merkle root, but that would be less practical for integrating with tooling.\\n     *       It is only possible to trigger it when the msg sender is address zero, which should be impossible\\n     *       unless under simulation in an eth_call or eth_estimateGas\\n     */\\n    function executeTransactionSimulation(\\n        uint256 index,\\n        address l2Sender,\\n        address to,\\n        uint256 l2Block,\\n        uint256 l1Block,\\n        uint256 l2Timestamp,\\n        uint256 value,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @param index Merkle path to message\\n     * @return true if the message has been spent\\n     */\\n    function isSpent(uint256 index) external view returns (bool);\\n\\n    function calculateItemHash(\\n        address l2Sender,\\n        address to,\\n        uint256 l2Block,\\n        uint256 l1Block,\\n        uint256 l2Timestamp,\\n        uint256 value,\\n        bytes calldata data\\n    ) external pure returns (bytes32);\\n\\n    function calculateMerkleRoot(\\n        bytes32[] memory proof,\\n        uint256 path,\\n        bytes32 item\\n    ) external pure returns (bytes32);\\n\\n    /**\\n     * @dev function to be called one time during the outbox upgrade process\\n     *      this is used to fix the storage slots\\n     */\\n    function postUpgradeInit() external;\\n}\\n\"\r\n    },\r\n    \"src/bridge/IOwnable.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.4.21 <0.9.0;\\n\\ninterface IOwnable {\\n    function owner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/bridge/ISequencerInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../libraries/IGasRefunder.sol\\\";\\nimport \\\"./IDelayedMessageProvider.sol\\\";\\nimport \\\"./IBridge.sol\\\";\\n\\ninterface ISequencerInbox is IDelayedMessageProvider {\\n    struct MaxTimeVariation {\\n        uint256 delayBlocks;\\n        uint256 futureBlocks;\\n        uint256 delaySeconds;\\n        uint256 futureSeconds;\\n    }\\n\\n    struct TimeBounds {\\n        uint64 minTimestamp;\\n        uint64 maxTimestamp;\\n        uint64 minBlockNumber;\\n        uint64 maxBlockNumber;\\n    }\\n\\n    enum BatchDataLocation {\\n        TxInput,\\n        SeparateBatchEvent,\\n        NoData\\n    }\\n\\n    event SequencerBatchDelivered(\\n        uint256 indexed batchSequenceNumber,\\n        bytes32 indexed beforeAcc,\\n        bytes32 indexed afterAcc,\\n        bytes32 delayedAcc,\\n        uint256 afterDelayedMessagesRead,\\n        TimeBounds timeBounds,\\n        BatchDataLocation dataLocation\\n    );\\n\\n    event OwnerFunctionCalled(uint256 indexed id);\\n\\n    /// @dev a separate event that emits batch data when this isn't easily accessible in the tx.input\\n    event SequencerBatchData(uint256 indexed batchSequenceNumber, bytes data);\\n\\n    /// @dev a valid keyset was added\\n    event SetValidKeyset(bytes32 indexed keysetHash, bytes keysetBytes);\\n\\n    /// @dev a keyset was invalidated\\n    event InvalidateKeyset(bytes32 indexed keysetHash);\\n\\n    function totalDelayedMessagesRead() external view returns (uint256);\\n\\n    function bridge() external view returns (IBridge);\\n\\n    /// @dev The size of the batch header\\n    // solhint-disable-next-line func-name-mixedcase\\n    function HEADER_LENGTH() external view returns (uint256);\\n\\n    /// @dev If the first batch data byte after the header has this bit set,\\n    ///      the sequencer inbox has authenticated the data. Currently not used.\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DATA_AUTHENTICATED_FLAG() external view returns (bytes1);\\n\\n    function rollup() external view returns (IOwnable);\\n\\n    function isBatchPoster(address) external view returns (bool);\\n\\n    function isSequencer(address) external view returns (bool);\\n\\n    function maxDataSize() external view returns (uint256);\\n\\n    struct DasKeySetInfo {\\n        bool isValidKeyset;\\n        uint64 creationBlock;\\n    }\\n\\n    function maxTimeVariation()\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function dasKeySetInfo(bytes32) external view returns (bool, uint64);\\n\\n    /// @notice Remove force inclusion delay after a L1 chainId fork\\n    function removeDelayAfterFork() external;\\n\\n    /// @notice Force messages from the delayed inbox to be included in the chain\\n    ///         Callable by any address, but message can only be force-included after maxTimeVariation.delayBlocks and\\n    ///         maxTimeVariation.delaySeconds has elapsed. As part of normal behaviour the sequencer will include these\\n    ///         messages so it's only necessary to call this if the sequencer is down, or not including any delayed messages.\\n    /// @param _totalDelayedMessagesRead The total number of messages to read up to\\n    /// @param kind The kind of the last message to be included\\n    /// @param l1BlockAndTime The l1 block and the l1 timestamp of the last message to be included\\n    /// @param baseFeeL1 The l1 gas price of the last message to be included\\n    /// @param sender The sender of the last message to be included\\n    /// @param messageDataHash The messageDataHash of the last message to be included\\n    function forceInclusion(\\n        uint256 _totalDelayedMessagesRead,\\n        uint8 kind,\\n        uint64[2] calldata l1BlockAndTime,\\n        uint256 baseFeeL1,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external;\\n\\n    function inboxAccs(uint256 index) external view returns (bytes32);\\n\\n    function batchCount() external view returns (uint256);\\n\\n    function isValidKeysetHash(bytes32 ksHash) external view returns (bool);\\n\\n    /// @notice the creation block is intended to still be available after a keyset is deleted\\n    function getKeysetCreationBlock(bytes32 ksHash) external view returns (uint256);\\n\\n    // ---------- BatchPoster functions ----------\\n\\n    function addSequencerL2BatchFromOrigin(\\n        uint256 sequenceNumber,\\n        bytes calldata data,\\n        uint256 afterDelayedMessagesRead,\\n        IGasRefunder gasRefunder\\n    ) external;\\n\\n    function addSequencerL2Batch(\\n        uint256 sequenceNumber,\\n        bytes calldata data,\\n        uint256 afterDelayedMessagesRead,\\n        IGasRefunder gasRefunder,\\n        uint256 prevMessageCount,\\n        uint256 newMessageCount\\n    ) external;\\n\\n    // ---------- onlyRollupOrOwner functions ----------\\n\\n    /**\\n     * @notice Set max delay for sequencer inbox\\n     * @param maxTimeVariation_ the maximum time variation parameters\\n     */\\n    function setMaxTimeVariation(MaxTimeVariation memory maxTimeVariation_) external;\\n\\n    /**\\n     * @notice Updates whether an address is authorized to be a batch poster at the sequencer inbox\\n     * @param addr the address\\n     * @param isBatchPoster_ if the specified address should be authorized as a batch poster\\n     */\\n    function setIsBatchPoster(address addr, bool isBatchPoster_) external;\\n\\n    /**\\n     * @notice Makes Data Availability Service keyset valid\\n     * @param keysetBytes bytes of the serialized keyset\\n     */\\n    function setValidKeyset(bytes calldata keysetBytes) external;\\n\\n    /**\\n     * @notice Invalidates a Data Availability Service keyset\\n     * @param ksHash hash of the keyset\\n     */\\n    function invalidateKeysetHash(bytes32 ksHash) external;\\n\\n    /**\\n     * @notice Updates whether an address is authorized to be a sequencer.\\n     * @dev The IsSequencer information is used only off-chain by the nitro node to validate sequencer feed signer.\\n     * @param addr the address\\n     * @param isSequencer_ if the specified address should be authorized as a sequencer\\n     */\\n    function setIsSequencer(address addr, bool isSequencer_) external;\\n\\n    // ---------- initializer ----------\\n\\n    function initialize(IBridge bridge_, MaxTimeVariation calldata maxTimeVariation_) external;\\n\\n    function updateRollupAddress() external;\\n}\\n\"\r\n    },\r\n    \"src/challenge/ChallengeLib.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../state/Machine.sol\\\";\\nimport \\\"../state/GlobalState.sol\\\";\\n\\nlibrary ChallengeLib {\\n    using MachineLib for Machine;\\n    using ChallengeLib for Challenge;\\n\\n    /// @dev It's assumed that that uninitialzed challenges have mode NONE\\n    enum ChallengeMode {\\n        NONE,\\n        BLOCK,\\n        EXECUTION\\n    }\\n\\n    struct Participant {\\n        address addr;\\n        uint256 timeLeft;\\n    }\\n\\n    struct Challenge {\\n        Participant current;\\n        Participant next;\\n        uint256 lastMoveTimestamp;\\n        bytes32 wasmModuleRoot;\\n        bytes32 challengeStateHash;\\n        uint64 maxInboxMessages;\\n        ChallengeMode mode;\\n    }\\n\\n    struct SegmentSelection {\\n        uint256 oldSegmentsStart;\\n        uint256 oldSegmentsLength;\\n        bytes32[] oldSegments;\\n        uint256 challengePosition;\\n    }\\n\\n    function timeUsedSinceLastMove(Challenge storage challenge) internal view returns (uint256) {\\n        return block.timestamp - challenge.lastMoveTimestamp;\\n    }\\n\\n    function isTimedOut(Challenge storage challenge) internal view returns (bool) {\\n        return challenge.timeUsedSinceLastMove() > challenge.current.timeLeft;\\n    }\\n\\n    function getStartMachineHash(bytes32 globalStateHash, bytes32 wasmModuleRoot)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        // Start the value stack with the function call ABI for the entrypoint\\n        Value[] memory startingValues = new Value[](3);\\n        startingValues[0] = ValueLib.newRefNull();\\n        startingValues[1] = ValueLib.newI32(0);\\n        startingValues[2] = ValueLib.newI32(0);\\n        ValueArray memory valuesArray = ValueArray({inner: startingValues});\\n        ValueStack memory values = ValueStack({proved: valuesArray, remainingHash: 0});\\n        ValueStack memory internalStack;\\n        StackFrameWindow memory frameStack;\\n\\n        Machine memory mach = Machine({\\n            status: MachineStatus.RUNNING,\\n            valueStack: values,\\n            internalStack: internalStack,\\n            frameStack: frameStack,\\n            globalStateHash: globalStateHash,\\n            moduleIdx: 0,\\n            functionIdx: 0,\\n            functionPc: 0,\\n            modulesRoot: wasmModuleRoot\\n        });\\n        return mach.hash();\\n    }\\n\\n    function getEndMachineHash(MachineStatus status, bytes32 globalStateHash)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        if (status == MachineStatus.FINISHED) {\\n            return keccak256(abi.encodePacked(\\\"Machine finished:\\\", globalStateHash));\\n        } else if (status == MachineStatus.ERRORED) {\\n            return keccak256(abi.encodePacked(\\\"Machine errored:\\\"));\\n        } else if (status == MachineStatus.TOO_FAR) {\\n            return keccak256(abi.encodePacked(\\\"Machine too far:\\\"));\\n        } else {\\n            revert(\\\"BAD_BLOCK_STATUS\\\");\\n        }\\n    }\\n\\n    function extractChallengeSegment(SegmentSelection calldata selection)\\n        internal\\n        pure\\n        returns (uint256 segmentStart, uint256 segmentLength)\\n    {\\n        uint256 oldChallengeDegree = selection.oldSegments.length - 1;\\n        segmentLength = selection.oldSegmentsLength / oldChallengeDegree;\\n        // Intentionally done before challengeLength is potentially added to for the final segment\\n        segmentStart = selection.oldSegmentsStart + segmentLength * selection.challengePosition;\\n        if (selection.challengePosition == selection.oldSegments.length - 2) {\\n            segmentLength += selection.oldSegmentsLength % oldChallengeDegree;\\n        }\\n    }\\n\\n    function hashChallengeState(\\n        uint256 segmentsStart,\\n        uint256 segmentsLength,\\n        bytes32[] memory segments\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(segmentsStart, segmentsLength, segments));\\n    }\\n\\n    function blockStateHash(MachineStatus status, bytes32 globalStateHash)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        if (status == MachineStatus.FINISHED) {\\n            return keccak256(abi.encodePacked(\\\"Block state:\\\", globalStateHash));\\n        } else if (status == MachineStatus.ERRORED) {\\n            return keccak256(abi.encodePacked(\\\"Block state, errored:\\\", globalStateHash));\\n        } else if (status == MachineStatus.TOO_FAR) {\\n            return keccak256(abi.encodePacked(\\\"Block state, too far:\\\"));\\n        } else {\\n            revert(\\\"BAD_BLOCK_STATUS\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/challenge/IChallengeManager.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../state/Machine.sol\\\";\\nimport \\\"../bridge/IBridge.sol\\\";\\nimport \\\"../bridge/ISequencerInbox.sol\\\";\\nimport \\\"../osp/IOneStepProofEntry.sol\\\";\\n\\nimport \\\"./IChallengeResultReceiver.sol\\\";\\n\\nimport \\\"./ChallengeLib.sol\\\";\\n\\ninterface IChallengeManager {\\n    enum ChallengeTerminationType {\\n        TIMEOUT,\\n        BLOCK_PROOF,\\n        EXECUTION_PROOF,\\n        CLEARED\\n    }\\n\\n    event InitiatedChallenge(\\n        uint64 indexed challengeIndex,\\n        GlobalState startState,\\n        GlobalState endState\\n    );\\n\\n    event Bisected(\\n        uint64 indexed challengeIndex,\\n        bytes32 indexed challengeRoot,\\n        uint256 challengedSegmentStart,\\n        uint256 challengedSegmentLength,\\n        bytes32[] chainHashes\\n    );\\n\\n    event ExecutionChallengeBegun(uint64 indexed challengeIndex, uint256 blockSteps);\\n    event OneStepProofCompleted(uint64 indexed challengeIndex);\\n\\n    event ChallengeEnded(uint64 indexed challengeIndex, ChallengeTerminationType kind);\\n\\n    function initialize(\\n        IChallengeResultReceiver resultReceiver_,\\n        ISequencerInbox sequencerInbox_,\\n        IBridge bridge_,\\n        IOneStepProofEntry osp_\\n    ) external;\\n\\n    function createChallenge(\\n        bytes32 wasmModuleRoot_,\\n        MachineStatus[2] calldata startAndEndMachineStatuses_,\\n        GlobalState[2] calldata startAndEndGlobalStates_,\\n        uint64 numBlocks,\\n        address asserter_,\\n        address challenger_,\\n        uint256 asserterTimeLeft_,\\n        uint256 challengerTimeLeft_\\n    ) external returns (uint64);\\n\\n    function challengeInfo(uint64 challengeIndex_)\\n        external\\n        view\\n        returns (ChallengeLib.Challenge memory);\\n\\n    function currentResponder(uint64 challengeIndex) external view returns (address);\\n\\n    function isTimedOut(uint64 challengeIndex) external view returns (bool);\\n\\n    function clearChallenge(uint64 challengeIndex_) external;\\n\\n    function timeout(uint64 challengeIndex_) external;\\n}\\n\"\r\n    },\r\n    \"src/challenge/IChallengeResultReceiver.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\ninterface IChallengeResultReceiver {\\n    function completeChallenge(\\n        uint256 challengeIndex,\\n        address winner,\\n        address loser\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/libraries/AdminFallbackProxy.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/proxy/Proxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/StorageSlot.sol\\\";\\n\\n/// @notice An extension to OZ's ERC1967Upgrade implementation to support two logic contracts\\nabstract contract DoubleLogicERC1967Upgrade is ERC1967Upgrade {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.implementation.secondary\\\" subtracted by 1\\n    bytes32 internal constant _IMPLEMENTATION_SECONDARY_SLOT =\\n        0x2b1dbce74324248c222f0ec2d5ed7bd323cfc425b336f0253c5ccfda7265546d;\\n\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback.secondary\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SECONDARY_SLOT =\\n        0x49bd798cd84788856140a4cd5030756b4d08a9e4d55db725ec195f232d262a89;\\n\\n    /**\\n     * @dev Emitted when the secondary implementation is upgraded.\\n     */\\n    event UpgradedSecondary(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current secondary implementation address.\\n     */\\n    function _getSecondaryImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SECONDARY_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setSecondaryImplementation(address newImplementation) private {\\n        require(\\n            Address.isContract(newImplementation),\\n            \\\"ERC1967: new secondary implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SECONDARY_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform secondary implementation upgrade\\n     *\\n     * Emits an {UpgradedSecondary} event.\\n     */\\n    function _upgradeSecondaryTo(address newImplementation) internal {\\n        _setSecondaryImplementation(newImplementation);\\n        emit UpgradedSecondary(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform secondary implementation upgrade with additional setup call.\\n     *\\n     * Emits an {UpgradedSecondary} event.\\n     */\\n    function _upgradeSecondaryToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeSecondaryTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform secondary implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {UpgradedSecondary} event.\\n     */\\n    function _upgradeSecondaryToAndCallUUPS(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SECONDARY_SLOT).value) {\\n            _setSecondaryImplementation(newImplementation);\\n        } else {\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(\\n                    slot == _IMPLEMENTATION_SECONDARY_SLOT,\\n                    \\\"ERC1967Upgrade: unsupported secondary proxiableUUID\\\"\\n                );\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new secondary implementation is not UUPS\\\");\\n            }\\n            _upgradeSecondaryToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n}\\n\\n/// @notice similar to TransparentUpgradeableProxy but allows the admin to fallback to a separate logic contract using DoubleLogicERC1967Upgrade\\n/// @dev this follows the UUPS pattern for upgradeability - read more at https://github.com/OpenZeppelin/openzeppelin-contracts/tree/v4.5.0/contracts/proxy#transparent-vs-uups-proxies\\ncontract AdminFallbackProxy is Proxy, DoubleLogicERC1967Upgrade {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `adminLogic` and a secondary\\n     * logic implementation specified by `userLogic`\\n     *\\n     * Only the `adminAddr` is able to use the `adminLogic` functions\\n     * All other addresses can interact with the `userLogic` functions\\n     */\\n    function _initialize(\\n        address adminLogic,\\n        bytes memory adminData,\\n        address userLogic,\\n        bytes memory userData,\\n        address adminAddr\\n    ) internal {\\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\n        assert(\\n            _IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1)\\n        );\\n        assert(\\n            _IMPLEMENTATION_SECONDARY_SLOT ==\\n                bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation.secondary\\\")) - 1)\\n        );\\n        _changeAdmin(adminAddr);\\n        _upgradeToAndCall(adminLogic, adminData, false);\\n        _upgradeSecondaryToAndCall(userLogic, userData, false);\\n    }\\n\\n    /// @inheritdoc Proxy\\n    function _implementation() internal view override returns (address) {\\n        require(msg.data.length >= 4, \\\"NO_FUNC_SIG\\\");\\n        // if the sender is the proxy's admin, delegate to admin logic\\n        // if the admin is disabled, all calls will be forwarded to user logic\\n        // admin affordances can be disabled by setting to a no-op smart contract\\n        // since there is a check for contract code before updating the value\\n        address target = _getAdmin() != msg.sender\\n            ? DoubleLogicERC1967Upgrade._getSecondaryImplementation()\\n            : ERC1967Upgrade._getImplementation();\\n        // implementation setters do an existence check, but we protect against selfdestructs this way\\n        require(Address.isContract(target), \\\"TARGET_NOT_CONTRACT\\\");\\n        return target;\\n    }\\n\\n    /**\\n     * @dev unlike transparent upgradeable proxies, this does allow the admin to fallback to a logic contract\\n     * the admin is expected to interact only with the primary logic contract, which handles contract\\n     * upgrades using the UUPS approach\\n     */\\n    function _beforeFallback() internal override {\\n        super._beforeFallback();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/IGasRefunder.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\ninterface IGasRefunder {\\n    function onGasSpent(\\n        address payable spender,\\n        uint256 gasUsed,\\n        uint256 calldataSize\\n    ) external returns (bool success);\\n}\\n\\nabstract contract GasRefundEnabled {\\n    /// @dev this refunds the sender for execution costs of the tx\\n    /// calldata costs are only refunded if `msg.sender == tx.origin` to guarantee the value refunded relates to charging\\n    /// for the `tx.input`. this avoids a possible attack where you generate large calldata from a contract and get over-refunded\\n    modifier refundsGas(IGasRefunder gasRefunder) {\\n        uint256 startGasLeft = gasleft();\\n        _;\\n        if (address(gasRefunder) != address(0)) {\\n            uint256 calldataSize = msg.data.length;\\n            uint256 calldataWords = (calldataSize + 31) / 32;\\n            // account for the CALLDATACOPY cost of the proxy contract, including the memory expansion cost\\n            startGasLeft += calldataWords * 6 + (calldataWords**2) / 512;\\n            // if triggered in a contract call, the spender may be overrefunded by appending dummy data to the call\\n            // so we check if it is a top level call, which would mean the sender paid calldata as part of tx.input\\n            // solhint-disable-next-line avoid-tx-origin\\n            if (msg.sender != tx.origin) {\\n                // We can't be sure if this calldata came from the top level tx,\\n                // so to be safe we tell the gas refunder there was no calldata.\\n                calldataSize = 0;\\n            }\\n            gasRefunder.onGasSpent(payable(msg.sender), startGasLeft - gasleft(), calldataSize);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/osp/IOneStepProofEntry.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IOneStepProver.sol\\\";\\n\\nlibrary OneStepProofEntryLib {\\n    uint256 internal constant MAX_STEPS = 1 << 43;\\n}\\n\\ninterface IOneStepProofEntry {\\n    function proveOneStep(\\n        ExecutionContext calldata execCtx,\\n        uint256 machineStep,\\n        bytes32 beforeHash,\\n        bytes calldata proof\\n    ) external view returns (bytes32 afterHash);\\n}\\n\"\r\n    },\r\n    \"src/osp/IOneStepProver.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../state/Machine.sol\\\";\\nimport \\\"../state/Module.sol\\\";\\nimport \\\"../state/Instructions.sol\\\";\\nimport \\\"../state/GlobalState.sol\\\";\\nimport \\\"../bridge/ISequencerInbox.sol\\\";\\nimport \\\"../bridge/IBridge.sol\\\";\\n\\nstruct ExecutionContext {\\n    uint256 maxInboxMessagesRead;\\n    IBridge bridge;\\n}\\n\\nabstract contract IOneStepProver {\\n    function executeOneStep(\\n        ExecutionContext memory execCtx,\\n        Machine calldata mach,\\n        Module calldata mod,\\n        Instruction calldata instruction,\\n        bytes calldata proof\\n    ) external view virtual returns (Machine memory result, Module memory resultMod);\\n}\\n\"\r\n    },\r\n    \"src/rollup/Config.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../state/GlobalState.sol\\\";\\nimport \\\"../state/Machine.sol\\\";\\nimport \\\"../bridge/ISequencerInbox.sol\\\";\\nimport \\\"../bridge/IBridge.sol\\\";\\nimport \\\"../bridge/IOutbox.sol\\\";\\nimport \\\"../bridge/IInboxBase.sol\\\";\\nimport \\\"./IRollupEventInbox.sol\\\";\\nimport \\\"./IRollupLogic.sol\\\";\\nimport \\\"../challenge/IChallengeManager.sol\\\";\\n\\nstruct Config {\\n    uint64 confirmPeriodBlocks;\\n    uint64 extraChallengeTimeBlocks;\\n    address stakeToken;\\n    uint256 baseStake;\\n    bytes32 wasmModuleRoot;\\n    address owner;\\n    address loserStakeEscrow;\\n    uint256 chainId;\\n    string chainConfig;\\n    uint64 genesisBlockNum;\\n    ISequencerInbox.MaxTimeVariation sequencerInboxMaxTimeVariation;\\n}\\n\\nstruct ContractDependencies {\\n    IBridge bridge;\\n    ISequencerInbox sequencerInbox;\\n    IInboxBase inbox;\\n    IOutbox outbox;\\n    IRollupEventInbox rollupEventInbox;\\n    IChallengeManager challengeManager;\\n    address rollupAdminLogic;\\n    IRollupUser rollupUserLogic;\\n    // misc contracts that are useful when interacting with the rollup\\n    address validatorUtils;\\n    address validatorWalletCreator;\\n}\\n\"\r\n    },\r\n    \"src/rollup/IRollupAdmin.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IRollupCore.sol\\\";\\nimport \\\"../bridge/ISequencerInbox.sol\\\";\\nimport \\\"../bridge/IOutbox.sol\\\";\\nimport \\\"../bridge/IOwnable.sol\\\";\\nimport \\\"./Config.sol\\\";\\n\\ninterface IRollupAdmin {\\n    event OwnerFunctionCalled(uint256 indexed id);\\n\\n    function initialize(Config calldata config, ContractDependencies calldata connectedContracts)\\n        external;\\n\\n    /**\\n     * @notice Add a contract authorized to put messages into this rollup's inbox\\n     * @param _outbox Outbox contract to add\\n     */\\n    function setOutbox(IOutbox _outbox) external;\\n\\n    /**\\n     * @notice Disable an old outbox from interacting with the bridge\\n     * @param _outbox Outbox contract to remove\\n     */\\n    function removeOldOutbox(address _outbox) external;\\n\\n    /**\\n     * @notice Enable or disable an inbox contract\\n     * @param _inbox Inbox contract to add or remove\\n     * @param _enabled New status of inbox\\n     */\\n    function setDelayedInbox(address _inbox, bool _enabled) external;\\n\\n    /**\\n     * @notice Pause interaction with the rollup contract\\n     */\\n    function pause() external;\\n\\n    /**\\n     * @notice Resume interaction with the rollup contract\\n     */\\n    function resume() external;\\n\\n    /**\\n     * @notice Set the addresses of the validator whitelist\\n     * @dev It is expected that both arrays are same length, and validator at\\n     * position i corresponds to the value at position i\\n     * @param _validator addresses to set in the whitelist\\n     * @param _val value to set in the whitelist for corresponding address\\n     */\\n    function setValidator(address[] memory _validator, bool[] memory _val) external;\\n\\n    /**\\n     * @notice Set a new owner address for the rollup proxy\\n     * @param newOwner address of new rollup owner\\n     */\\n    function setOwner(address newOwner) external;\\n\\n    /**\\n     * @notice Set minimum assertion period for the rollup\\n     * @param newPeriod new minimum period for assertions\\n     */\\n    function setMinimumAssertionPeriod(uint256 newPeriod) external;\\n\\n    /**\\n     * @notice Set number of blocks until a node is considered confirmed\\n     * @param newConfirmPeriod new number of blocks until a node is confirmed\\n     */\\n    function setConfirmPeriodBlocks(uint64 newConfirmPeriod) external;\\n\\n    /**\\n     * @notice Set number of extra blocks after a challenge\\n     * @param newExtraTimeBlocks new number of blocks\\n     */\\n    function setExtraChallengeTimeBlocks(uint64 newExtraTimeBlocks) external;\\n\\n    /**\\n     * @notice Set base stake required for an assertion\\n     * @param newBaseStake maximum avmgas to be used per block\\n     */\\n    function setBaseStake(uint256 newBaseStake) external;\\n\\n    /**\\n     * @notice Set the token used for stake, where address(0) == eth\\n     * @dev Before changing the base stake token, you might need to change the\\n     * implementation of the Rollup User logic!\\n     * @param newStakeToken address of token used for staking\\n     */\\n    function setStakeToken(address newStakeToken) external;\\n\\n    /**\\n     * @notice Upgrades the implementation of a beacon controlled by the rollup\\n     * @param beacon address of beacon to be upgraded\\n     * @param newImplementation new address of implementation\\n     */\\n    function upgradeBeacon(address beacon, address newImplementation) external;\\n\\n    function forceResolveChallenge(address[] memory stackerA, address[] memory stackerB) external;\\n\\n    function forceRefundStaker(address[] memory stacker) external;\\n\\n    function forceCreateNode(\\n        uint64 prevNode,\\n        uint256 prevNodeInboxMaxCount,\\n        Assertion memory assertion,\\n        bytes32 expectedNodeHash\\n    ) external;\\n\\n    function forceConfirmNode(\\n        uint64 nodeNum,\\n        bytes32 blockHash,\\n        bytes32 sendRoot\\n    ) external;\\n\\n    function setLoserStakeEscrow(address newLoserStakerEscrow) external;\\n\\n    /**\\n     * @notice Set the proving WASM module root\\n     * @param newWasmModuleRoot new module root\\n     */\\n    function setWasmModuleRoot(bytes32 newWasmModuleRoot) external;\\n\\n    /**\\n     * @notice set a new sequencer inbox contract\\n     * @param _sequencerInbox new address of sequencer inbox\\n     */\\n    function setSequencerInbox(address _sequencerInbox) external;\\n\\n    /**\\n     * @notice set the validatorWhitelistDisabled flag\\n     * @param _validatorWhitelistDisabled new value of validatorWhitelistDisabled, i.e. true = disabled\\n     */\\n    function setValidatorWhitelistDisabled(bool _validatorWhitelistDisabled) external;\\n}\\n\"\r\n    },\r\n    \"src/rollup/IRollupCore.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Node.sol\\\";\\nimport \\\"../bridge/IBridge.sol\\\";\\nimport \\\"../bridge/IOutbox.sol\\\";\\nimport \\\"../bridge/IInboxBase.sol\\\";\\nimport \\\"./IRollupEventInbox.sol\\\";\\nimport \\\"../challenge/IChallengeManager.sol\\\";\\n\\ninterface IRollupCore {\\n    struct Staker {\\n        uint256 amountStaked;\\n        uint64 index;\\n        uint64 latestStakedNode;\\n        // currentChallenge is 0 if staker is not in a challenge\\n        uint64 currentChallenge;\\n        bool isStaked;\\n    }\\n\\n    event RollupInitialized(bytes32 machineHash, uint256 chainId);\\n\\n    event NodeCreated(\\n        uint64 indexed nodeNum,\\n        bytes32 indexed parentNodeHash,\\n        bytes32 indexed nodeHash,\\n        bytes32 executionHash,\\n        Assertion assertion,\\n        bytes32 afterInboxBatchAcc,\\n        bytes32 wasmModuleRoot,\\n        uint256 inboxMaxCount\\n    );\\n\\n    event NodeConfirmed(uint64 indexed nodeNum, bytes32 blockHash, bytes32 sendRoot);\\n\\n    event NodeRejected(uint64 indexed nodeNum);\\n\\n    event RollupChallengeStarted(\\n        uint64 indexed challengeIndex,\\n        address asserter,\\n        address challenger,\\n        uint64 challengedNode\\n    );\\n\\n    event UserStakeUpdated(address indexed user, uint256 initialBalance, uint256 finalBalance);\\n\\n    event UserWithdrawableFundsUpdated(\\n        address indexed user,\\n        uint256 initialBalance,\\n        uint256 finalBalance\\n    );\\n\\n    function confirmPeriodBlocks() external view returns (uint64);\\n\\n    function extraChallengeTimeBlocks() external view returns (uint64);\\n\\n    function chainId() external view returns (uint256);\\n\\n    function baseStake() external view returns (uint256);\\n\\n    function wasmModuleRoot() external view returns (bytes32);\\n\\n    function bridge() external view returns (IBridge);\\n\\n    function sequencerInbox() external view returns (ISequencerInbox);\\n\\n    function outbox() external view returns (IOutbox);\\n\\n    function rollupEventInbox() external view returns (IRollupEventInbox);\\n\\n    function challengeManager() external view returns (IChallengeManager);\\n\\n    function loserStakeEscrow() external view returns (address);\\n\\n    function stakeToken() external view returns (address);\\n\\n    function minimumAssertionPeriod() external view returns (uint256);\\n\\n    function isValidator(address) external view returns (bool);\\n\\n    function validatorWhitelistDisabled() external view returns (bool);\\n\\n    /**\\n     * @notice Get the Node for the given index.\\n     */\\n    function getNode(uint64 nodeNum) external view returns (Node memory);\\n\\n    /**\\n     * @notice Returns the block in which the given node was created for looking up its creation event.\\n     * Unlike the Node's createdAtBlock field, this will be the ArbSys blockNumber if the host chain is an Arbitrum chain.\\n     * That means that the block number returned for this is usable for event queries.\\n     * This function will revert if the given node number does not exist.\\n     * @dev This function is meant for internal use only and has no stability guarantees.\\n     */\\n    function getNodeCreationBlockForLogLookup(uint64 nodeNum) external view returns (uint256);\\n\\n    /**\\n     * @notice Check if the specified node has been staked on by the provided staker.\\n     * Only accurate at the latest confirmed node and afterwards.\\n     */\\n    function nodeHasStaker(uint64 nodeNum, address staker) external view returns (bool);\\n\\n    /**\\n     * @notice Get the address of the staker at the given index\\n     * @param stakerNum Index of the staker\\n     * @return Address of the staker\\n     */\\n    function getStakerAddress(uint64 stakerNum) external view returns (address);\\n\\n    /**\\n     * @notice Check whether the given staker is staked\\n     * @param staker Staker address to check\\n     * @return True or False for whether the staker was staked\\n     */\\n    function isStaked(address staker) external view returns (bool);\\n\\n    /**\\n     * @notice Get the latest staked node of the given staker\\n     * @param staker Staker address to lookup\\n     * @return Latest node staked of the staker\\n     */\\n    function latestStakedNode(address staker) external view returns (uint64);\\n\\n    /**\\n     * @notice Get the current challenge of the given staker\\n     * @param staker Staker address to lookup\\n     * @return Current challenge of the staker\\n     */\\n    function currentChallenge(address staker) external view returns (uint64);\\n\\n    /**\\n     * @notice Get the amount staked of the given staker\\n     * @param staker Staker address to lookup\\n     * @return Amount staked of the staker\\n     */\\n    function amountStaked(address staker) external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieves stored information about a requested staker\\n     * @param staker Staker address to retrieve\\n     * @return A structure with information about the requested staker\\n     */\\n    function getStaker(address staker) external view returns (Staker memory);\\n\\n    /**\\n     * @notice Get the original staker address of the zombie at the given index\\n     * @param zombieNum Index of the zombie to lookup\\n     * @return Original staker address of the zombie\\n     */\\n    function zombieAddress(uint256 zombieNum) external view returns (address);\\n\\n    /**\\n     * @notice Get Latest node that the given zombie at the given index is staked on\\n     * @param zombieNum Index of the zombie to lookup\\n     * @return Latest node that the given zombie is staked on\\n     */\\n    function zombieLatestStakedNode(uint256 zombieNum) external view returns (uint64);\\n\\n    /// @return Current number of un-removed zombies\\n    function zombieCount() external view returns (uint256);\\n\\n    function isZombie(address staker) external view returns (bool);\\n\\n    /**\\n     * @notice Get the amount of funds withdrawable by the given address\\n     * @param owner Address to check the funds of\\n     * @return Amount of funds withdrawable by owner\\n     */\\n    function withdrawableFunds(address owner) external view returns (uint256);\\n\\n    /**\\n     * @return Index of the first unresolved node\\n     * @dev If all nodes have been resolved, this will be latestNodeCreated + 1\\n     */\\n    function firstUnresolvedNode() external view returns (uint64);\\n\\n    /// @return Index of the latest confirmed node\\n    function latestConfirmed() external view returns (uint64);\\n\\n    /// @return Index of the latest rollup node created\\n    function latestNodeCreated() external view returns (uint64);\\n\\n    /// @return Ethereum block that the most recent stake was created\\n    function lastStakeBlock() external view returns (uint64);\\n\\n    /// @return Number of active stakers currently staked\\n    function stakerCount() external view returns (uint64);\\n}\\n\"\r\n    },\r\n    \"src/rollup/IRollupEventInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../bridge/IBridge.sol\\\";\\n\\ninterface IRollupEventInbox {\\n    function bridge() external view returns (IBridge);\\n\\n    function initialize(IBridge _bridge) external;\\n\\n    function rollup() external view returns (address);\\n\\n    function updateRollupAddress() external;\\n\\n    function rollupInitialized(uint256 chainId, string calldata chainConfig) external;\\n}\\n\"\r\n    },\r\n    \"src/rollup/IRollupLogic.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IRollupCore.sol\\\";\\nimport \\\"../bridge/ISequencerInbox.sol\\\";\\nimport \\\"../bridge/IOutbox.sol\\\";\\nimport \\\"../bridge/IOwnable.sol\\\";\\n\\ninterface IRollupUserAbs is IRollupCore, IOwnable {\\n    /// @dev the user logic just validated configuration and shouldn't write to state during init\\n    /// this allows the admin logic to ensure consistency on parameters.\\n    function initialize(address stakeToken) external view;\\n\\n    function removeWhitelistAfterFork() external;\\n\\n    function removeWhitelistAfterValidatorAfk() external;\\n\\n    function isERC20Enabled() external view returns (bool);\\n\\n    function rejectNextNode(address stakerAddress) external;\\n\\n    function confirmNextNode(bytes32 blockHash, bytes32 sendRoot) external;\\n\\n    function stakeOnExistingNode(uint64 nodeNum, bytes32 nodeHash) external;\\n\\n    function stakeOnNewNode(\\n        Assertion memory assertion,\\n        bytes32 expectedNodeHash,\\n        uint256 prevNodeInboxMaxCount\\n    ) external;\\n\\n    function returnOldDeposit(address stakerAddress) external;\\n\\n    function reduceDeposit(uint256 target) external;\\n\\n    function removeZombie(uint256 zombieNum, uint256 maxNodes) external;\\n\\n    function removeOldZombies(uint256 startIndex) external;\\n\\n    function requiredStake(\\n        uint256 blockNumber,\\n        uint64 firstUnresolvedNodeNum,\\n        uint64 latestCreatedNode\\n    ) external view returns (uint256);\\n\\n    function currentRequiredStake() external view returns (uint256);\\n\\n    function countStakedZombies(uint64 nodeNum) external view returns (uint256);\\n\\n    function countZombiesStakedOnChildren(uint64 nodeNum) external view returns (uint256);\\n\\n    function requireUnresolvedExists() external view;\\n\\n    function requireUnresolved(uint256 nodeNum) external view;\\n\\n    function withdrawStakerFunds() external returns (uint256);\\n\\n    function createChallenge(\\n        address[2] calldata stakers,\\n        uint64[2] calldata nodeNums,\\n        MachineStatus[2] calldata machineStatuses,\\n        GlobalState[2] calldata globalStates,\\n        uint64 numBlocks,\\n        bytes32 secondExecutionHash,\\n        uint256[2] calldata proposedTimes,\\n        bytes32[2] calldata wasmModuleRoots\\n    ) external;\\n}\\n\\ninterface IRollupUser is IRollupUserAbs {\\n    function newStakeOnExistingNode(uint64 nodeNum, bytes32 nodeHash) external payable;\\n\\n    function newStakeOnNewNode(\\n        Assertion calldata assertion,\\n        bytes32 expectedNodeHash,\\n        uint256 prevNodeInboxMaxCount\\n    ) external payable;\\n\\n    function addToDeposit(address stakerAddress) external payable;\\n}\\n\\ninterface IRollupUserERC20 is IRollupUserAbs {\\n    function newStakeOnExistingNode(\\n        uint256 tokenAmount,\\n        uint64 nodeNum,\\n        bytes32 nodeHash\\n    ) external;\\n\\n    function newStakeOnNewNode(\\n        uint256 tokenAmount,\\n        Assertion calldata assertion,\\n        bytes32 expectedNodeHash,\\n        uint256 prevNodeInboxMaxCount\\n    ) external;\\n\\n    function addToDeposit(address stakerAddress, uint256 tokenAmount) external;\\n}\\n\"\r\n    },\r\n    \"src/rollup/Node.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../state/GlobalState.sol\\\";\\nimport \\\"../state/Machine.sol\\\";\\n\\nstruct ExecutionState {\\n    GlobalState globalState;\\n    MachineStatus machineStatus;\\n}\\n\\nstruct Assertion {\\n    ExecutionState beforeState;\\n    ExecutionState afterState;\\n    uint64 numBlocks;\\n}\\n\\nstruct Node {\\n    // Hash of the state of the chain as of this node\\n    bytes32 stateHash;\\n    // Hash of the data that can be challenged\\n    bytes32 challengeHash;\\n    // Hash of the data that will be committed if this node is confirmed\\n    bytes32 confirmData;\\n    // Index of the node previous to this one\\n    uint64 prevNum;\\n    // Deadline at which this node can be confirmed\\n    uint64 deadlineBlock;\\n    // Deadline at which a child of this node can be confirmed\\n    uint64 noChildConfirmedBeforeBlock;\\n    // Number of stakers staked on this node. This includes real stakers and zombies\\n    uint64 stakerCount;\\n    // Number of stakers staked on a child node. This includes real stakers and zombies\\n    uint64 childStakerCount;\\n    // This value starts at zero and is set to a value when the first child is created. After that it is constant until the node is destroyed or the owner destroys pending nodes\\n    uint64 firstChildBlock;\\n    // The number of the latest child of this node to be created\\n    uint64 latestChildNumber;\\n    // The block number when this node was created\\n    uint64 createdAtBlock;\\n    // A hash of all the data needed to determine this node's validity, to protect against reorgs\\n    bytes32 nodeHash;\\n}\\n\\n/**\\n * @notice Utility functions for Node\\n */\\nlibrary NodeLib {\\n    /**\\n     * @notice Initialize a Node\\n     * @param _stateHash Initial value of stateHash\\n     * @param _challengeHash Initial value of challengeHash\\n     * @param _confirmData Initial value of confirmData\\n     * @param _prevNum Initial value of prevNum\\n     * @param _deadlineBlock Initial value of deadlineBlock\\n     * @param _nodeHash Initial value of nodeHash\\n     */\\n    function createNode(\\n        bytes32 _stateHash,\\n        bytes32 _challengeHash,\\n        bytes32 _confirmData,\\n        uint64 _prevNum,\\n        uint64 _deadlineBlock,\\n        bytes32 _nodeHash\\n    ) internal view returns (Node memory) {\\n        Node memory node;\\n        node.stateHash = _stateHash;\\n        node.challengeHash = _challengeHash;\\n        node.confirmData = _confirmData;\\n        node.prevNum = _prevNum;\\n        node.deadlineBlock = _deadlineBlock;\\n        node.noChildConfirmedBeforeBlock = _deadlineBlock;\\n        node.createdAtBlock = uint64(block.number);\\n        node.nodeHash = _nodeHash;\\n        return node;\\n    }\\n\\n    /**\\n     * @notice Update child properties\\n     * @param number The child number to set\\n     */\\n    function childCreated(Node storage self, uint64 number) internal {\\n        if (self.firstChildBlock == 0) {\\n            self.firstChildBlock = uint64(block.number);\\n        }\\n        self.latestChildNumber = number;\\n    }\\n\\n    /**\\n     * @notice Update the child confirmed deadline\\n     * @param deadline The new deadline to set\\n     */\\n    function newChildConfirmDeadline(Node storage self, uint64 deadline) internal {\\n        self.noChildConfirmedBeforeBlock = deadline;\\n    }\\n\\n    /**\\n     * @notice Check whether the current block number has met or passed the node's deadline\\n     */\\n    function requirePastDeadline(Node memory self) internal view {\\n        require(block.number >= self.deadlineBlock, \\\"BEFORE_DEADLINE\\\");\\n    }\\n\\n    /**\\n     * @notice Check whether the current block number has met or passed deadline for children of this node to be confirmed\\n     */\\n    function requirePastChildConfirmDeadline(Node memory self) internal view {\\n        require(block.number >= self.noChildConfirmedBeforeBlock, \\\"CHILD_TOO_RECENT\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/rollup/RollupProxy.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../libraries/AdminFallbackProxy.sol\\\";\\nimport \\\"./IRollupAdmin.sol\\\";\\nimport \\\"./Config.sol\\\";\\n\\ncontract RollupProxy is AdminFallbackProxy {\\n    function initializeProxy(Config memory config, ContractDependencies memory connectedContracts)\\n        external\\n    {\\n        if (\\n            _getAdmin() == address(0) &&\\n            _getImplementation() == address(0) &&\\n            _getSecondaryImplementation() == address(0)\\n        ) {\\n            _initialize(\\n                address(connectedContracts.rollupAdminLogic),\\n                abi.encodeWithSelector(\\n                    IRollupAdmin.initialize.selector,\\n                    config,\\n                    connectedContracts\\n                ),\\n                address(connectedContracts.rollupUserLogic),\\n                abi.encodeWithSelector(IRollupUserAbs.initialize.selector, config.stakeToken),\\n                config.owner\\n            );\\n        } else {\\n            _fallback();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/GlobalState.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nstruct GlobalState {\\n    bytes32[2] bytes32Vals;\\n    uint64[2] u64Vals;\\n}\\n\\nlibrary GlobalStateLib {\\n    uint16 internal constant BYTES32_VALS_NUM = 2;\\n    uint16 internal constant U64_VALS_NUM = 2;\\n\\n    function hash(GlobalState memory state) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"Global state:\\\",\\n                    state.bytes32Vals[0],\\n                    state.bytes32Vals[1],\\n                    state.u64Vals[0],\\n                    state.u64Vals[1]\\n                )\\n            );\\n    }\\n\\n    function getBlockHash(GlobalState memory state) internal pure returns (bytes32) {\\n        return state.bytes32Vals[0];\\n    }\\n\\n    function getSendRoot(GlobalState memory state) internal pure returns (bytes32) {\\n        return state.bytes32Vals[1];\\n    }\\n\\n    function getInboxPosition(GlobalState memory state) internal pure returns (uint64) {\\n        return state.u64Vals[0];\\n    }\\n\\n    function getPositionInMessage(GlobalState memory state) internal pure returns (uint64) {\\n        return state.u64Vals[1];\\n    }\\n\\n    function isEmpty(GlobalState calldata state) internal pure returns (bool) {\\n        return (state.bytes32Vals[0] == bytes32(0) &&\\n            state.bytes32Vals[1] == bytes32(0) &&\\n            state.u64Vals[0] == 0 &&\\n            state.u64Vals[1] == 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/Instructions.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nstruct Instruction {\\n    uint16 opcode;\\n    uint256 argumentData;\\n}\\n\\nlibrary Instructions {\\n    uint16 internal constant UNREACHABLE = 0x00;\\n    uint16 internal constant NOP = 0x01;\\n    uint16 internal constant RETURN = 0x0F;\\n    uint16 internal constant CALL = 0x10;\\n    uint16 internal constant CALL_INDIRECT = 0x11;\\n    uint16 internal constant LOCAL_GET = 0x20;\\n    uint16 internal constant LOCAL_SET = 0x21;\\n    uint16 internal constant GLOBAL_GET = 0x23;\\n    uint16 internal constant GLOBAL_SET = 0x24;\\n\\n    uint16 internal constant I32_LOAD = 0x28;\\n    uint16 internal constant I64_LOAD = 0x29;\\n    uint16 internal constant F32_LOAD = 0x2A;\\n    uint16 internal constant F64_LOAD = 0x2B;\\n    uint16 internal constant I32_LOAD8_S = 0x2C;\\n    uint16 internal constant I32_LOAD8_U = 0x2D;\\n    uint16 internal constant I32_LOAD16_S = 0x2E;\\n    uint16 internal constant I32_LOAD16_U = 0x2F;\\n    uint16 internal constant I64_LOAD8_S = 0x30;\\n    uint16 internal constant I64_LOAD8_U = 0x31;\\n    uint16 internal constant I64_LOAD16_S = 0x32;\\n    uint16 internal constant I64_LOAD16_U = 0x33;\\n    uint16 internal constant I64_LOAD32_S = 0x34;\\n    uint16 internal constant I64_LOAD32_U = 0x35;\\n\\n    uint16 internal constant I32_STORE = 0x36;\\n    uint16 internal constant I64_STORE = 0x37;\\n    uint16 internal constant F32_STORE = 0x38;\\n    uint16 internal constant F64_STORE = 0x39;\\n    uint16 internal constant I32_STORE8 = 0x3A;\\n    uint16 internal constant I32_STORE16 = 0x3B;\\n    uint16 internal constant I64_STORE8 = 0x3C;\\n    uint16 internal constant I64_STORE16 = 0x3D;\\n    uint16 internal constant I64_STORE32 = 0x3E;\\n\\n    uint16 internal constant MEMORY_SIZE = 0x3F;\\n    uint16 internal constant MEMORY_GROW = 0x40;\\n\\n    uint16 internal constant DROP = 0x1A;\\n    uint16 internal constant SELECT = 0x1B;\\n    uint16 internal constant I32_CONST = 0x41;\\n    uint16 internal constant I64_CONST = 0x42;\\n    uint16 internal constant F32_CONST = 0x43;\\n    uint16 internal constant F64_CONST = 0x44;\\n    uint16 internal constant I32_EQZ = 0x45;\\n    uint16 internal constant I32_RELOP_BASE = 0x46;\\n    uint16 internal constant IRELOP_EQ = 0;\\n    uint16 internal constant IRELOP_NE = 1;\\n    uint16 internal constant IRELOP_LT_S = 2;\\n    uint16 internal constant IRELOP_LT_U = 3;\\n    uint16 internal constant IRELOP_GT_S = 4;\\n    uint16 internal constant IRELOP_GT_U = 5;\\n    uint16 internal constant IRELOP_LE_S = 6;\\n    uint16 internal constant IRELOP_LE_U = 7;\\n    uint16 internal constant IRELOP_GE_S = 8;\\n    uint16 internal constant IRELOP_GE_U = 9;\\n    uint16 internal constant IRELOP_LAST = IRELOP_GE_U;\\n\\n    uint16 internal constant I64_EQZ = 0x50;\\n    uint16 internal constant I64_RELOP_BASE = 0x51;\\n\\n    uint16 internal constant I32_UNOP_BASE = 0x67;\\n    uint16 internal constant IUNOP_CLZ = 0;\\n    uint16 internal constant IUNOP_CTZ = 1;\\n    uint16 internal constant IUNOP_POPCNT = 2;\\n    uint16 internal constant IUNOP_LAST = IUNOP_POPCNT;\\n\\n    uint16 internal constant I32_ADD = 0x6A;\\n    uint16 internal constant I32_SUB = 0x6B;\\n    uint16 internal constant I32_MUL = 0x6C;\\n    uint16 internal constant I32_DIV_S = 0x6D;\\n    uint16 internal constant I32_DIV_U = 0x6E;\\n    uint16 internal constant I32_REM_S = 0x6F;\\n    uint16 internal constant I32_REM_U = 0x70;\\n    uint16 internal constant I32_AND = 0x71;\\n    uint16 internal constant I32_OR = 0x72;\\n    uint16 internal constant I32_XOR = 0x73;\\n    uint16 internal constant I32_SHL = 0x74;\\n    uint16 internal constant I32_SHR_S = 0x75;\\n    uint16 internal constant I32_SHR_U = 0x76;\\n    uint16 internal constant I32_ROTL = 0x77;\\n    uint16 internal constant I32_ROTR = 0x78;\\n\\n    uint16 internal constant I64_UNOP_BASE = 0x79;\\n\\n    uint16 internal constant I64_ADD = 0x7C;\\n    uint16 internal constant I64_SUB = 0x7D;\\n    uint16 internal constant I64_MUL = 0x7E;\\n    uint16 internal constant I64_DIV_S = 0x7F;\\n    uint16 internal constant I64_DIV_U = 0x80;\\n    uint16 internal constant I64_REM_S = 0x81;\\n    uint16 internal constant I64_REM_U = 0x82;\\n    uint16 internal constant I64_AND = 0x83;\\n    uint16 internal constant I64_OR = 0x84;\\n    uint16 internal constant I64_XOR = 0x85;\\n    uint16 internal constant I64_SHL = 0x86;\\n    uint16 internal constant I64_SHR_S = 0x87;\\n    uint16 internal constant I64_SHR_U = 0x88;\\n    uint16 internal constant I64_ROTL = 0x89;\\n    uint16 internal constant I64_ROTR = 0x8A;\\n\\n    uint16 internal constant I32_WRAP_I64 = 0xA7;\\n    uint16 internal constant I64_EXTEND_I32_S = 0xAC;\\n    uint16 internal constant I64_EXTEND_I32_U = 0xAD;\\n\\n    uint16 internal constant I32_REINTERPRET_F32 = 0xBC;\\n    uint16 internal constant I64_REINTERPRET_F64 = 0xBD;\\n    uint16 internal constant F32_REINTERPRET_I32 = 0xBE;\\n    uint16 internal constant F64_REINTERPRET_I64 = 0xBF;\\n\\n    uint16 internal constant I32_EXTEND_8S = 0xC0;\\n    uint16 internal constant I32_EXTEND_16S = 0xC1;\\n    uint16 internal constant I64_EXTEND_8S = 0xC2;\\n    uint16 internal constant I64_EXTEND_16S = 0xC3;\\n    uint16 internal constant I64_EXTEND_32S = 0xC4;\\n\\n    uint16 internal constant INIT_FRAME = 0x8002;\\n    uint16 internal constant ARBITRARY_JUMP = 0x8003;\\n    uint16 internal constant ARBITRARY_JUMP_IF = 0x8004;\\n    uint16 internal constant MOVE_FROM_STACK_TO_INTERNAL = 0x8005;\\n    uint16 internal constant MOVE_FROM_INTERNAL_TO_STACK = 0x8006;\\n    uint16 internal constant DUP = 0x8008;\\n    uint16 internal constant CROSS_MODULE_CALL = 0x8009;\\n    uint16 internal constant CALLER_MODULE_INTERNAL_CALL = 0x800A;\\n\\n    uint16 internal constant GET_GLOBAL_STATE_BYTES32 = 0x8010;\\n    uint16 internal constant SET_GLOBAL_STATE_BYTES32 = 0x8011;\\n    uint16 internal constant GET_GLOBAL_STATE_U64 = 0x8012;\\n    uint16 internal constant SET_GLOBAL_STATE_U64 = 0x8013;\\n\\n    uint16 internal constant READ_PRE_IMAGE = 0x8020;\\n    uint16 internal constant READ_INBOX_MESSAGE = 0x8021;\\n    uint16 internal constant HALT_AND_SET_FINISHED = 0x8022;\\n\\n    uint256 internal constant INBOX_INDEX_SEQUENCER = 0;\\n    uint256 internal constant INBOX_INDEX_DELAYED = 1;\\n\\n    function hash(Instruction memory inst) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"Instruction:\\\", inst.opcode, inst.argumentData));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/Machine.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ValueStack.sol\\\";\\nimport \\\"./Instructions.sol\\\";\\nimport \\\"./StackFrame.sol\\\";\\n\\nenum MachineStatus {\\n    RUNNING,\\n    FINISHED,\\n    ERRORED,\\n    TOO_FAR\\n}\\n\\nstruct Machine {\\n    MachineStatus status;\\n    ValueStack valueStack;\\n    ValueStack internalStack;\\n    StackFrameWindow frameStack;\\n    bytes32 globalStateHash;\\n    uint32 moduleIdx;\\n    uint32 functionIdx;\\n    uint32 functionPc;\\n    bytes32 modulesRoot;\\n}\\n\\nlibrary MachineLib {\\n    using StackFrameLib for StackFrameWindow;\\n    using ValueStackLib for ValueStack;\\n\\n    function hash(Machine memory mach) internal pure returns (bytes32) {\\n        // Warning: the non-running hashes are replicated in Challenge\\n        if (mach.status == MachineStatus.RUNNING) {\\n            return\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"Machine running:\\\",\\n                        mach.valueStack.hash(),\\n                        mach.internalStack.hash(),\\n                        mach.frameStack.hash(),\\n                        mach.globalStateHash,\\n                        mach.moduleIdx,\\n                        mach.functionIdx,\\n                        mach.functionPc,\\n                        mach.modulesRoot\\n                    )\\n                );\\n        } else if (mach.status == MachineStatus.FINISHED) {\\n            return keccak256(abi.encodePacked(\\\"Machine finished:\\\", mach.globalStateHash));\\n        } else if (mach.status == MachineStatus.ERRORED) {\\n            return keccak256(abi.encodePacked(\\\"Machine errored:\\\"));\\n        } else if (mach.status == MachineStatus.TOO_FAR) {\\n            return keccak256(abi.encodePacked(\\\"Machine too far:\\\"));\\n        } else {\\n            revert(\\\"BAD_MACH_STATUS\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/Module.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ModuleMemoryCompact.sol\\\";\\n\\nstruct Module {\\n    bytes32 globalsMerkleRoot;\\n    ModuleMemory moduleMemory;\\n    bytes32 tablesMerkleRoot;\\n    bytes32 functionsMerkleRoot;\\n    uint32 internalsOffset;\\n}\\n\\nlibrary ModuleLib {\\n    using ModuleMemoryCompactLib for ModuleMemory;\\n\\n    function hash(Module memory mod) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"Module:\\\",\\n                    mod.globalsMerkleRoot,\\n                    mod.moduleMemory.hash(),\\n                    mod.tablesMerkleRoot,\\n                    mod.functionsMerkleRoot,\\n                    mod.internalsOffset\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/ModuleMemoryCompact.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nstruct ModuleMemory {\\n    uint64 size;\\n    uint64 maxSize;\\n    bytes32 merkleRoot;\\n}\\n\\nlibrary ModuleMemoryCompactLib {\\n    function hash(ModuleMemory memory mem) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"Memory:\\\", mem.size, mem.maxSize, mem.merkleRoot));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/StackFrame.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Value.sol\\\";\\n\\nstruct StackFrame {\\n    Value returnPc;\\n    bytes32 localsMerkleRoot;\\n    uint32 callerModule;\\n    uint32 callerModuleInternals;\\n}\\n\\nstruct StackFrameWindow {\\n    StackFrame[] proved;\\n    bytes32 remainingHash;\\n}\\n\\nlibrary StackFrameLib {\\n    using ValueLib for Value;\\n\\n    function hash(StackFrame memory frame) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"Stack frame:\\\",\\n                    frame.returnPc.hash(),\\n                    frame.localsMerkleRoot,\\n                    frame.callerModule,\\n                    frame.callerModuleInternals\\n                )\\n            );\\n    }\\n\\n    function hash(StackFrameWindow memory window) internal pure returns (bytes32 h) {\\n        h = window.remainingHash;\\n        for (uint256 i = 0; i < window.proved.length; i++) {\\n            h = keccak256(abi.encodePacked(\\\"Stack frame stack:\\\", hash(window.proved[i]), h));\\n        }\\n    }\\n\\n    function peek(StackFrameWindow memory window) internal pure returns (StackFrame memory) {\\n        require(window.proved.length == 1, \\\"BAD_WINDOW_LENGTH\\\");\\n        return window.proved[0];\\n    }\\n\\n    function pop(StackFrameWindow memory window) internal pure returns (StackFrame memory frame) {\\n        require(window.proved.length == 1, \\\"BAD_WINDOW_LENGTH\\\");\\n        frame = window.proved[0];\\n        window.proved = new StackFrame[](0);\\n    }\\n\\n    function push(StackFrameWindow memory window, StackFrame memory frame) internal pure {\\n        StackFrame[] memory newProved = new StackFrame[](window.proved.length + 1);\\n        for (uint256 i = 0; i < window.proved.length; i++) {\\n            newProved[i] = window.proved[i];\\n        }\\n        newProved[window.proved.length] = frame;\\n        window.proved = newProved;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/Value.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nenum ValueType {\\n    I32,\\n    I64,\\n    F32,\\n    F64,\\n    REF_NULL,\\n    FUNC_REF,\\n    INTERNAL_REF\\n}\\n\\nstruct Value {\\n    ValueType valueType;\\n    uint256 contents;\\n}\\n\\nlibrary ValueLib {\\n    function hash(Value memory val) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"Value:\\\", val.valueType, val.contents));\\n    }\\n\\n    function maxValueType() internal pure returns (ValueType) {\\n        return ValueType.INTERNAL_REF;\\n    }\\n\\n    function assumeI32(Value memory val) internal pure returns (uint32) {\\n        uint256 uintval = uint256(val.contents);\\n        require(val.valueType == ValueType.I32, \\\"NOT_I32\\\");\\n        require(uintval < (1 << 32), \\\"BAD_I32\\\");\\n        return uint32(uintval);\\n    }\\n\\n    function assumeI64(Value memory val) internal pure returns (uint64) {\\n        uint256 uintval = uint256(val.contents);\\n        require(val.valueType == ValueType.I64, \\\"NOT_I64\\\");\\n        require(uintval < (1 << 64), \\\"BAD_I64\\\");\\n        return uint64(uintval);\\n    }\\n\\n    function newRefNull() internal pure returns (Value memory) {\\n        return Value({valueType: ValueType.REF_NULL, contents: 0});\\n    }\\n\\n    function newI32(uint32 x) internal pure returns (Value memory) {\\n        return Value({valueType: ValueType.I32, contents: uint256(x)});\\n    }\\n\\n    function newI64(uint64 x) internal pure returns (Value memory) {\\n        return Value({valueType: ValueType.I64, contents: uint256(x)});\\n    }\\n\\n    function newBoolean(bool x) internal pure returns (Value memory) {\\n        if (x) {\\n            return newI32(uint32(1));\\n        } else {\\n            return newI32(uint32(0));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/ValueArray.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Value.sol\\\";\\n\\nstruct ValueArray {\\n    Value[] inner;\\n}\\n\\nlibrary ValueArrayLib {\\n    function get(ValueArray memory arr, uint256 index) internal pure returns (Value memory) {\\n        return arr.inner[index];\\n    }\\n\\n    function set(\\n        ValueArray memory arr,\\n        uint256 index,\\n        Value memory val\\n    ) internal pure {\\n        arr.inner[index] = val;\\n    }\\n\\n    function length(ValueArray memory arr) internal pure returns (uint256) {\\n        return arr.inner.length;\\n    }\\n\\n    function push(ValueArray memory arr, Value memory val) internal pure {\\n        Value[] memory newInner = new Value[](arr.inner.length + 1);\\n        for (uint256 i = 0; i < arr.inner.length; i++) {\\n            newInner[i] = arr.inner[i];\\n        }\\n        newInner[arr.inner.length] = val;\\n        arr.inner = newInner;\\n    }\\n\\n    function pop(ValueArray memory arr) internal pure returns (Value memory popped) {\\n        popped = arr.inner[arr.inner.length - 1];\\n        Value[] memory newInner = new Value[](arr.inner.length - 1);\\n        for (uint256 i = 0; i < newInner.length; i++) {\\n            newInner[i] = arr.inner[i];\\n        }\\n        arr.inner = newInner;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/ValueStack.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Value.sol\\\";\\nimport \\\"./ValueArray.sol\\\";\\n\\nstruct ValueStack {\\n    ValueArray proved;\\n    bytes32 remainingHash;\\n}\\n\\nlibrary ValueStackLib {\\n    using ValueLib for Value;\\n    using ValueArrayLib for ValueArray;\\n\\n    function hash(ValueStack memory stack) internal pure returns (bytes32 h) {\\n        h = stack.remainingHash;\\n        uint256 len = stack.proved.length();\\n        for (uint256 i = 0; i < len; i++) {\\n            h = keccak256(abi.encodePacked(\\\"Value stack:\\\", stack.proved.get(i).hash(), h));\\n        }\\n    }\\n\\n    function peek(ValueStack memory stack) internal pure returns (Value memory) {\\n        uint256 len = stack.proved.length();\\n        return stack.proved.get(len - 1);\\n    }\\n\\n    function pop(ValueStack memory stack) internal pure returns (Value memory) {\\n        return stack.proved.pop();\\n    }\\n\\n    function push(ValueStack memory stack, Value memory val) internal pure {\\n        return stack.proved.push(val);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"UpgradedSecondary\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"confirmPeriodBlocks\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"extraChallengeTimeBlocks\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseStake\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"wasmModuleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"loserStakeEscrow\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"chainConfig\",\"type\":\"string\"},{\"internalType\":\"uint64\",\"name\":\"genesisBlockNum\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"delayBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delaySeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureSeconds\",\"type\":\"uint256\"}],\"internalType\":\"struct ISequencerInbox.MaxTimeVariation\",\"name\":\"sequencerInboxMaxTimeVariation\",\"type\":\"tuple\"}],\"internalType\":\"struct Config\",\"name\":\"config\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"contract IBridge\",\"name\":\"bridge\",\"type\":\"address\"},{\"internalType\":\"contract ISequencerInbox\",\"name\":\"sequencerInbox\",\"type\":\"address\"},{\"internalType\":\"contract IInboxBase\",\"name\":\"inbox\",\"type\":\"address\"},{\"internalType\":\"contract IOutbox\",\"name\":\"outbox\",\"type\":\"address\"},{\"internalType\":\"contract IRollupEventInbox\",\"name\":\"rollupEventInbox\",\"type\":\"address\"},{\"internalType\":\"contract IChallengeManager\",\"name\":\"challengeManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rollupAdminLogic\",\"type\":\"address\"},{\"internalType\":\"contract IRollupUser\",\"name\":\"rollupUserLogic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"validatorUtils\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"validatorWalletCreator\",\"type\":\"address\"}],\"internalType\":\"struct ContractDependencies\",\"name\":\"connectedContracts\",\"type\":\"tuple\"}],\"name\":\"initializeProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "RollupProxy", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0x0ae4dd666748bf0f6db5c149eab1d8ad27820a6a", "SwarmSource": ""}