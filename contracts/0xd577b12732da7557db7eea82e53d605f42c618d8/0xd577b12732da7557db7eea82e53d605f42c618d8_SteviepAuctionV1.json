{"SourceCode": "{\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n\\nabstract contract Ownable {\\n  address private _owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n  constructor() {\\n    _setOwner(msg.sender);\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view virtual returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(owner() == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby removing any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n      _setOwner(address(0));\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n    _setOwner(newOwner);\\n  }\\n\\n  function _setOwner(address newOwner) private {\\n    address oldOwner = _owner;\\n    _owner = newOwner;\\n    emit OwnershipTransferred(oldOwner, newOwner);\\n  }\\n}\"},\"SteviepAuctionV1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n/*\\n\\n   \u2588\u2588\u2588\u2588\u2588  \u2588\u2588    \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588    \u2588\u2588\\n  \u2588\u2588   \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588         \u2588\u2588    \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588   \u2588\u2588\\n  \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588         \u2588\u2588    \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588\\n  \u2588\u2588   \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588         \u2588\u2588    \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588\\n  \u2588\u2588   \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588    \u2588\u2588    \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588   \u2588\u2588\u2588\u2588\\n\\n  contract by steviep.eth\\n\\n*/\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n\\npragma solidity ^0.8.17;\\n\\n\\ninterface IWETH {\\n  function deposit() external payable;\\n  function withdraw(uint256 wad) external;\\n  function transfer(address to, uint256 value) external returns (bool);\\n}\\n\\ninterface TokenContract {\\n  function mint(address to, uint256 tokenId) external;\\n  function ownerOf(uint256 tokenId) external view returns (address);\\n  function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n  function getApproved(uint256 tokenId) external view returns (address);\\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\\ninterface AllowList {\\n  function balanceOf(address owner) external view returns (uint256);\\n}\\n\\ninterface RewardMinter {\\n  function mint(address to) external;\\n}\\n\\n\\ncontract SteviepAuctionV1 is Ownable {\\n  IWETH public immutable weth = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\\n\\n  uint256 public auctionCount;\\n\\n  struct Auction {\\n    bool tokenExists;\\n    uint256 duration;\\n    uint256 bidIncreaseBps;\\n    uint256 bidTimeExtension;\\n    uint256 minBid;\\n    uint256 tokenId;\\n    uint256 startTime;\\n    address beneficiary;\\n    bool approveFutureTransfer;\\n    TokenContract tokenContract;\\n    RewardMinter rewardContract;\\n    AllowList allowListContract;\\n  }\\n\\n  struct Bid {\\n    uint128 amount;\\n    uint128 timestamp;\\n    address bidder;\\n  }\\n\\n  event BidMade(uint256 indexed auctionId, address indexed bidder, uint256 amount, uint256 timestamp);\\n  event Settled(uint256 indexed auctionId, uint256 timestamp);\\n\\n  mapping(uint256 =\\u003e Auction) public auctionIdToAuction;\\n  mapping(uint256 =\\u003e Bid) public auctionIdToHighestBid;\\n  mapping(uint256 =\\u003e bool) public isSettled;\\n\\n  function create(\\n    bool tokenExists,\\n    uint256 duration,\\n    uint256 bidIncreaseBps,\\n    uint256 bidTimeExtension,\\n    uint256 minBid,\\n    uint256 tokenId,\\n    address beneficiary,\\n    bool approveFutureTransfer,\\n    TokenContract tokenContract,\\n    RewardMinter rewardContract,\\n    AllowList allowListContract\\n  ) external onlyOwner {\\n    require(duration \\u003e 0, \\u0027Auction must have duration\\u0027);\\n    require(bidIncreaseBps \\u003e 0, \\u0027Bid increase cannot be 0\\u0027);\\n    require(address(tokenContract) != address(0), \\u0027Must include token address\\u0027);\\n    if (tokenExists) {\\n      require(\\n        tokenContract.getApproved(tokenId) == address(this) || tokenContract.isApprovedForAll(msg.sender, address(this)),\\n        \\u0027Token must be approved\\u0027\\n      );\\n    }\\n\\n    auctionIdToAuction[auctionCount].tokenExists = tokenExists;\\n    auctionIdToAuction[auctionCount].duration = duration;\\n    auctionIdToAuction[auctionCount].bidIncreaseBps = bidIncreaseBps;\\n    auctionIdToAuction[auctionCount].bidTimeExtension = bidTimeExtension;\\n    if (minBid == 0) auctionIdToAuction[auctionCount].minBid = 1;\\n    else auctionIdToAuction[auctionCount].minBid = minBid;\\n    auctionIdToAuction[auctionCount].tokenId = tokenId;\\n    auctionIdToAuction[auctionCount].beneficiary = beneficiary;\\n    auctionIdToAuction[auctionCount].tokenContract = tokenContract;\\n    auctionIdToAuction[auctionCount].rewardContract = rewardContract;\\n    auctionIdToAuction[auctionCount].allowListContract = allowListContract;\\n    auctionIdToAuction[auctionCount].approveFutureTransfer = approveFutureTransfer;\\n\\n    if (tokenExists \\u0026\\u0026 !approveFutureTransfer) {\\n      tokenContract.safeTransferFrom(msg.sender, address(this), tokenId);\\n    }\\n\\n    auctionCount++;\\n  }\\n\\n  function bid(uint256 auctionId, bool wantsReward) external payable {\\n    _bid(auctionId, wantsReward);\\n  }\\n\\n  function bid(uint256 auctionId) external payable {\\n    _bid(auctionId, false);\\n  }\\n\\n  function _bid(uint256 auctionId, bool wantsReward) private {\\n    Auction storage auction = auctionIdToAuction[auctionId];\\n    Bid storage highestBid = auctionIdToHighestBid[auctionId];\\n\\n    require(_isActive(auctionId, auction, highestBid), \\u0027Auction is not active\\u0027);\\n\\n    if (address(auction.allowListContract) != address(0)) {\\n      require(auction.allowListContract.balanceOf(msg.sender) \\u003e 0, \\u0027Bidder not on allow list\\u0027);\\n    }\\n\\n    require(\\n      msg.value \\u003e= (highestBid.amount * (10000 + auction.bidIncreaseBps) / 10000)\\n      \\u0026\\u0026 msg.value \\u003e= auction.minBid,\\n      \\u0027Bid not high enough\\u0027\\n    );\\n\\n    uint256 refundAmount;\\n    address refundBidder;\\n\\n    if (highestBid.timestamp \\u003e 0) {\\n      refundAmount = highestBid.amount;\\n      refundBidder = highestBid.bidder;\\n    } else {\\n      auction.startTime = block.timestamp;\\n    }\\n\\n    highestBid.timestamp = uint128(block.timestamp);\\n    highestBid.amount = uint128(msg.value);\\n    highestBid.bidder = msg.sender;\\n\\n    if (wantsReward \\u0026\\u0026 address(auction.rewardContract) != address(0)) {\\n      auction.rewardContract.mint(msg.sender);\\n    }\\n\\n    emit BidMade(auctionId, msg.sender, msg.value, block.timestamp);\\n\\n    if (refundAmount \\u003e 0) _safeTransferETH(refundBidder, refundAmount);\\n  }\\n\\n  function cancel(uint256 auctionId) external onlyOwner {\\n    Bid memory highestBid = auctionIdToHighestBid[auctionId];\\n    Auction storage auction = auctionIdToAuction[auctionId];\\n\\n    require(auction.duration \\u003e 0, \\u0027Auction does not exist\\u0027);\\n    require(!isSettled[auctionId], \\u0027Auction is not active\\u0027);\\n    require(highestBid.timestamp == 0, \\u0027Auction has started\\u0027);\\n\\n    if (auction.tokenExists) {\\n      auction.tokenContract.safeTransferFrom(address(this), msg.sender, auction.tokenId);\\n    }\\n\\n    isSettled[auctionId] = true;\\n  }\\n\\n  function settle(uint256 auctionId) external {\\n    Auction storage auction = auctionIdToAuction[auctionId];\\n    Bid storage highestBid = auctionIdToHighestBid[auctionId];\\n\\n    require(!isSettled[auctionId], \\u0027Auction has already been settled\\u0027);\\n    require(!_isActive(auctionId, auction, highestBid), \\u0027Auction is still active\\u0027);\\n\\n    isSettled[auctionId] = true;\\n\\n    emit Settled(auctionId, block.timestamp);\\n\\n    if (auction.tokenExists) {\\n      if (auction.approveFutureTransfer) {\\n\\n        try auction.tokenContract.safeTransferFrom(\\n          auction.tokenContract.ownerOf(auction.tokenId),\\n          highestBid.bidder,\\n          auction.tokenId\\n        ) {\\n          payable(auction.beneficiary).transfer(highestBid.amount);\\n        } catch {\\n          payable(highestBid.bidder).transfer(highestBid.amount);\\n        }\\n\\n      } else {\\n\\n        try auction.tokenContract.safeTransferFrom(\\n          address(this),\\n          highestBid.bidder,\\n          auction.tokenId\\n        ) {\\n          payable(auction.beneficiary).transfer(highestBid.amount);\\n        } catch {\\n          payable(highestBid.bidder).transfer(highestBid.amount);\\n        }\\n\\n      }\\n    } else {\\n      try auction.tokenContract.mint(highestBid.bidder, auction.tokenId) {\\n        payable(auction.beneficiary).transfer(highestBid.amount);\\n      } catch {\\n        payable(highestBid.bidder).transfer(highestBid.amount);\\n      }\\n    }\\n  }\\n\\n  function isActive(uint256 auctionId) public view returns (bool) {\\n    Auction memory auction = auctionIdToAuction[auctionId];\\n    Bid memory highestBid = auctionIdToHighestBid[auctionId];\\n\\n    return _isActive(auctionId, auction, highestBid);\\n  }\\n\\n  function _isActive(uint256 auctionId, Auction memory auction, Bid memory highestBid) private view returns (bool) {\\n    if (highestBid.timestamp == 0) return !isSettled[auctionId] \\u0026\\u0026 auction.duration \\u003e 0;\\n\\n    return (\\n      block.timestamp \\u003c _naturalEndTime(auction)\\n      || block.timestamp \\u003c _bidderEndTime(highestBid, auction)\\n    );\\n  }\\n\\n  function auctionEndTime(uint256 auctionId) external view returns (uint256) {\\n    Auction memory auction = auctionIdToAuction[auctionId];\\n    Bid memory highestBid = auctionIdToHighestBid[auctionId];\\n\\n    uint256 naturalEndTime = _naturalEndTime(auction);\\n    uint256 bidderEndTime = _bidderEndTime(highestBid, auction);\\n\\n    return naturalEndTime \\u003e bidderEndTime ? naturalEndTime : bidderEndTime;\\n  }\\n\\n  function _naturalEndTime(Auction memory auction) private pure returns (uint256) {\\n    return auction.startTime \\u003e 0\\n      ? auction.startTime + auction.duration\\n      : 0;\\n  }\\n\\n  function _bidderEndTime(Bid memory highestBid, Auction memory auction) private pure returns (uint256) {\\n    return auction.startTime \\u003e 0\\n      ? highestBid.timestamp + auction.bidTimeExtension\\n      : 0;\\n  }\\n\\n  /**\\n   * @notice Transfer ETH. If the ETH transfer fails, wrap the ETH and try send it as WETH.\\n   */\\n  function _safeTransferETHWithFallback(address to, uint256 amount) internal {\\n    if (!_safeTransferETH(to, amount)) {\\n      weth.deposit{ value: amount }();\\n      weth.transfer(to, amount);\\n    }\\n  }\\n\\n  /**\\n   * @notice Transfer ETH and return the success status.\\n   * @dev This function only forwards 30,000 gas to the callee.\\n   */\\n  function _safeTransferETH(address to, uint256 value) internal returns (bool) {\\n    (bool success, ) = to.call{ value: value, gas: 30_000 }(new bytes(0));\\n    return success;\\n  }\\n\\n  function onERC721Received(address, address, uint256, bytes calldata) external pure returns(bytes4) {\\n    return this.onERC721Received.selector;\\n  }\\n}\\n\"}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"BidMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Settled\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"auctionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"auctionEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctionIdToAuction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"tokenExists\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidIncreaseBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidTimeExtension\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approveFutureTransfer\",\"type\":\"bool\"},{\"internalType\":\"contract TokenContract\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"contract RewardMinter\",\"name\":\"rewardContract\",\"type\":\"address\"},{\"internalType\":\"contract AllowList\",\"name\":\"allowListContract\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctionIdToHighestBid\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"timestamp\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"wantsReward\",\"type\":\"bool\"}],\"name\":\"bid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"tokenExists\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidIncreaseBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidTimeExtension\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approveFutureTransfer\",\"type\":\"bool\"},{\"internalType\":\"contract TokenContract\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"contract RewardMinter\",\"name\":\"rewardContract\",\"type\":\"address\"},{\"internalType\":\"contract AllowList\",\"name\":\"allowListContract\",\"type\":\"address\"}],\"name\":\"create\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isSettled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"settle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SteviepAuctionV1", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4cbdec6db87e45000eb2b957a18f09a6d235b63ed02ed6b6786b9301ed62ce8b"}