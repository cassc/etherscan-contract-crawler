{"SourceCode": "// File: @openzeppelin/contracts/math/Math.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IVat.sol\r\n\r\npragma solidity ^0.6.10;\r\n\r\n\r\n/// @dev Interface to interact with the vat contract from MakerDAO\r\n/// Taken from https://github.com/makerdao/developerguides/blob/master/devtools/working-with-dsproxy/working-with-dsproxy.md\r\ninterface IVat {\r\n    // function can(address, address) external view returns (uint);\r\n    function hope(address) external;\r\n    function nope(address) external;\r\n    function live() external view returns (uint);\r\n    function ilks(bytes32) external view returns (uint, uint, uint, uint, uint);\r\n    function urns(bytes32, address) external view returns (uint, uint);\r\n    function gem(bytes32, address) external view returns (uint);\r\n    // function dai(address) external view returns (uint);\r\n    function frob(bytes32, address, address, address, int, int) external;\r\n    function fork(bytes32, address, address, int, int) external;\r\n    function move(address, address, uint) external;\r\n    function flux(bytes32, address, address, uint) external;\r\n}\r\n\r\n// File: contracts/interfaces/IPot.sol\r\n\r\npragma solidity ^0.6.10;\r\n\r\n\r\n/// @dev interface for the pot contract from MakerDao\r\n/// Taken from https://github.com/makerdao/developerguides/blob/master/dai/dsr-integration-guide/dsr.sol\r\ninterface IPot {\r\n    function chi() external view returns (uint256);\r\n    function pie(address) external view returns (uint256); // Not a function, but a public variable.\r\n    function rho() external returns (uint256);\r\n    function drip() external returns (uint256);\r\n    function join(uint256) external;\r\n    function exit(uint256) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/interfaces/IWeth.sol\r\n\r\npragma solidity ^0.6.10;\r\n\r\n\r\ninterface IWeth {\r\n    function deposit() external payable;\r\n    function withdraw(uint) external;\r\n    function approve(address, uint) external returns (bool) ;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IGemJoin.sol\r\n\r\npragma solidity ^0.6.10;\r\n\r\n\r\n/// @dev Interface to interact with the `Join.sol` contract from MakerDAO using ERC20\r\ninterface IGemJoin {\r\n    function rely(address usr) external;\r\n    function deny(address usr) external;\r\n    function cage() external;\r\n    function join(address usr, uint WAD) external;\r\n    function exit(address usr, uint WAD) external;\r\n}\r\n\r\n// File: contracts/interfaces/IDaiJoin.sol\r\n\r\npragma solidity ^0.6.10;\r\n\r\n\r\n/// @dev Interface to interact with the `Join.sol` contract from MakerDAO using Dai\r\ninterface IDaiJoin {\r\n    function rely(address usr) external;\r\n    function deny(address usr) external;\r\n    function cage() external;\r\n    function join(address usr, uint WAD) external;\r\n    function exit(address usr, uint WAD) external;\r\n}\r\n\r\n// File: contracts/interfaces/IChai.sol\r\n\r\npragma solidity ^0.6.10;\r\n\r\n\r\n/// @dev interface for the chai contract\r\n/// Taken from https://github.com/makerdao/developerguides/blob/master/dai/dsr-integration-guide/dsr.sol\r\ninterface IChai {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address dst, uint wad) external returns (bool);\r\n    function move(address src, address dst, uint wad) external returns (bool);\r\n    function transferFrom(address src, address dst, uint wad) external returns (bool);\r\n    function approve(address usr, uint wad) external returns (bool);\r\n    function dai(address usr) external returns (uint wad);\r\n    function join(address dst, uint wad) external;\r\n    function exit(address src, uint wad) external;\r\n    function draw(address src, uint wad) external;\r\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) external;\r\n    function nonces(address account) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/interfaces/ITreasury.sol\r\n\r\npragma solidity ^0.6.10;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface ITreasury {\r\n    function debt() external view returns(uint256);\r\n    function savings() external view returns(uint256);\r\n    function pushDai(address user, uint256 dai) external;\r\n    function pullDai(address user, uint256 dai) external;\r\n    function pushChai(address user, uint256 chai) external;\r\n    function pullChai(address user, uint256 chai) external;\r\n    function pushWeth(address to, uint256 weth) external;\r\n    function pullWeth(address to, uint256 weth) external;\r\n    function shutdown() external;\r\n    function live() external view returns(bool);\r\n\r\n    function vat() external view returns (IVat);\r\n    function weth() external view returns (IWeth);\r\n    function dai() external view returns (IERC20);\r\n    function daiJoin() external view returns (IDaiJoin);\r\n    function wethJoin() external view returns (IGemJoin);\r\n    function pot() external view returns (IPot);\r\n    function chai() external view returns (IChai);\r\n}\r\n\r\n// File: contracts/interfaces/IDelegable.sol\r\n\r\npragma solidity ^0.6.10;\r\n\r\n\r\ninterface IDelegable {\r\n    function addDelegate(address) external;\r\n    function addDelegateBySignature(address, address, uint, uint8, bytes32, bytes32) external;\r\n}\r\n\r\n// File: contracts/interfaces/IERC2612.sol\r\n\r\n// Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC2612 standard as defined in the EIP.\r\n *\r\n * Adds the {permit} method, which can be used to change one's\r\n * {IERC20-allowance} without having to send a transaction, by signing a\r\n * message. This allows users to spend tokens without having to hold Ether.\r\n *\r\n * See https://eips.ethereum.org/EIPS/eip-2612.\r\n */\r\ninterface IERC2612 {\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\r\n     * given `owner`'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    /**\r\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/interfaces/IFYDai.sol\r\n\r\npragma solidity ^0.6.10;\r\n\r\n\r\n\r\ninterface IFYDai is IERC20, IERC2612 {\r\n    function isMature() external view returns(bool);\r\n    function maturity() external view returns(uint);\r\n    function chi0() external view returns(uint);\r\n    function rate0() external view returns(uint);\r\n    function chiGrowth() external view returns(uint);\r\n    function rateGrowth() external view returns(uint);\r\n    function mature() external;\r\n    function unlocked() external view returns (uint);\r\n    function mint(address, uint) external;\r\n    function burn(address, uint) external;\r\n    function flashMint(uint, bytes calldata) external;\r\n    function redeem(address, address, uint256) external returns (uint256);\r\n    // function transfer(address, uint) external returns (bool);\r\n    // function transferFrom(address, address, uint) external returns (bool);\r\n    // function approve(address, uint) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IController.sol\r\n\r\npragma solidity ^0.6.10;\r\n\r\n\r\n\r\n\r\n\r\ninterface IController is IDelegable {\r\n    function treasury() external view returns (ITreasury);\r\n    function series(uint256) external view returns (IFYDai);\r\n    function seriesIterator(uint256) external view returns (uint256);\r\n    function totalSeries() external view returns (uint256);\r\n    function containsSeries(uint256) external view returns (bool);\r\n    function posted(bytes32, address) external view returns (uint256);\r\n    function debtFYDai(bytes32, uint256, address) external view returns (uint256);\r\n    function debtDai(bytes32, uint256, address) external view returns (uint256);\r\n    function totalDebtDai(bytes32, address) external view returns (uint256);\r\n    function isCollateralized(bytes32, address) external view returns (bool);\r\n    function inDai(bytes32, uint256, uint256) external view returns (uint256);\r\n    function inFYDai(bytes32, uint256, uint256) external view returns (uint256);\r\n    function erase(bytes32, address) external returns (uint256, uint256);\r\n    function shutdown() external;\r\n    function post(bytes32, address, address, uint256) external;\r\n    function withdraw(bytes32, address, address, uint256) external;\r\n    function borrow(bytes32, uint256, address, address, uint256) external;\r\n    function repayFYDai(bytes32, uint256, address, address, uint256) external returns (uint256);\r\n    function repayDai(bytes32, uint256, address, address, uint256) external returns (uint256);\r\n}\r\n\r\n// File: contracts/helpers/Delegable.sol\r\n\r\npragma solidity ^0.6.10;\r\n\r\n\r\n\r\n/// @dev Delegable enables users to delegate their account management to other users.\r\n/// Delegable implements addDelegateBySignature, to add delegates using a signature instead of a separate transaction.\r\ncontract Delegable is IDelegable {\r\n    event Delegate(address indexed user, address indexed delegate, bool enabled);\r\n\r\n    // keccak256(\"Signature(address user,address delegate,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public immutable SIGNATURE_TYPEHASH = 0x0d077601844dd17f704bafff948229d27f33b57445915754dfe3d095fda2beb7;\r\n    bytes32 public immutable DELEGABLE_DOMAIN;\r\n    mapping(address => uint) public signatureCount;\r\n\r\n    mapping(address => mapping(address => bool)) public delegated;\r\n\r\n    constructor () public {\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n\r\n        DELEGABLE_DOMAIN = keccak256(\r\n            abi.encode(\r\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                keccak256(bytes('Yield')),\r\n                keccak256(bytes('1')),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    /// @dev Require that msg.sender is the account holder or a delegate\r\n    modifier onlyHolderOrDelegate(address holder, string memory errorMessage) {\r\n        require(\r\n            msg.sender == holder || delegated[holder][msg.sender],\r\n            errorMessage\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Enable a delegate to act on the behalf of caller\r\n    function addDelegate(address delegate) public override {\r\n        _addDelegate(msg.sender, delegate);\r\n    }\r\n\r\n    /// @dev Stop a delegate from acting on the behalf of caller\r\n    function revokeDelegate(address delegate) public {\r\n        _revokeDelegate(msg.sender, delegate);\r\n    }\r\n\r\n    /// @dev Add a delegate through an encoded signature\r\n    function addDelegateBySignature(address user, address delegate, uint deadline, uint8 v, bytes32 r, bytes32 s) public override {\r\n        require(deadline >= block.timestamp, 'Delegable: Signature expired');\r\n\r\n        bytes32 hashStruct = keccak256(\r\n            abi.encode(\r\n                SIGNATURE_TYPEHASH,\r\n                user,\r\n                delegate,\r\n                signatureCount[user]++,\r\n                deadline\r\n            )\r\n        );\r\n\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                DELEGABLE_DOMAIN,\r\n                hashStruct\r\n            )\r\n        );\r\n        address signer = ecrecover(digest, v, r, s);\r\n        require(\r\n            signer != address(0) && signer == user,\r\n            'Delegable: Invalid signature'\r\n        );\r\n\r\n        _addDelegate(user, delegate);\r\n    }\r\n\r\n    /// @dev Enable a delegate to act on the behalf of an user\r\n    function _addDelegate(address user, address delegate) internal {\r\n        require(!delegated[user][delegate], \"Delegable: Already delegated\");\r\n        delegated[user][delegate] = true;\r\n        emit Delegate(user, delegate, true);\r\n    }\r\n\r\n    /// @dev Stop a delegate from acting on the behalf of an user\r\n    function _revokeDelegate(address user, address delegate) internal {\r\n        require(delegated[user][delegate], \"Delegable: Already undelegated\");\r\n        delegated[user][delegate] = false;\r\n        emit Delegate(user, delegate, false);\r\n    }\r\n}\r\n\r\n// File: contracts/helpers/DecimalMath.sol\r\n\r\npragma solidity ^0.6.10;\r\n\r\n\r\n\r\n/// @dev Implements simple fixed point math mul and div operations for 27 decimals.\r\ncontract DecimalMath {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant public UNIT = 1e27;\r\n\r\n    /// @dev Multiplies x and y, assuming they are both fixed point with 27 digits.\r\n    function muld(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x.mul(y).div(UNIT);\r\n    }\r\n\r\n    /// @dev Divides x between y, assuming they are both fixed point with 27 digits.\r\n    function divd(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x.mul(UNIT).div(y);\r\n    }\r\n\r\n    /// @dev Multiplies x and y, rounding up to the closest representable number.\r\n    /// Assumes x and y are both fixed point with `decimals` digits.\r\n    function muldrup(uint256 x, uint256 y) internal pure returns (uint256)\r\n    {\r\n        uint256 z = x.mul(y);\r\n        return z.mod(UNIT) == 0 ? z.div(UNIT) : z.div(UNIT).add(1);\r\n    }\r\n\r\n    /// @dev Divides x between y, rounding up to the closest representable number.\r\n    /// Assumes x and y are both fixed point with `decimals` digits.\r\n    function divdrup(uint256 x, uint256 y) internal pure returns (uint256)\r\n    {\r\n        uint256 z = x.mul(UNIT);\r\n        return z.mod(y) == 0 ? z.div(y) : z.div(y).add(1);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/helpers/Orchestrated.sol\r\n\r\npragma solidity ^0.6.10;\r\n\r\n\r\n\r\n/**\r\n * @dev Orchestrated allows to define static access control between multiple contracts.\r\n * This contract would be used as a parent contract of any contract that needs to restrict access to some methods,\r\n * which would be marked with the `onlyOrchestrated` modifier.\r\n * During deployment, the contract deployer (`owner`) can register any contracts that have privileged access by calling `orchestrate`.\r\n * Once deployment is completed, `owner` should call `transferOwnership(address(0))` to avoid any more contracts ever gaining privileged access.\r\n */\r\n\r\ncontract Orchestrated is Ownable {\r\n    event GrantedAccess(address access, bytes4 signature);\r\n\r\n    mapping(address => mapping (bytes4 => bool)) public orchestration;\r\n\r\n    constructor () public Ownable() {}\r\n\r\n    /// @dev Restrict usage to authorized users\r\n    /// @param err The error to display if the validation fails \r\n    modifier onlyOrchestrated(string memory err) {\r\n        require(orchestration[msg.sender][msg.sig], err);\r\n        _;\r\n    }\r\n\r\n    /// @dev Add orchestration\r\n    /// @param user Address of user or contract having access to this contract.\r\n    /// @param signature bytes4 signature of the function we are giving orchestrated access to.\r\n    /// It seems to me a bad idea to give access to humans, and would use this only for predictable smart contracts.\r\n    function orchestrate(address user, bytes4 signature) public onlyOwner {\r\n        orchestration[user][signature] = true;\r\n        emit GrantedAccess(user, signature);\r\n    }\r\n\r\n    /// @dev Adds orchestration for the provided function signatures\r\n    function batchOrchestrate(address user, bytes4[] memory signatures) public onlyOwner {\r\n        for (uint256 i = 0; i < signatures.length; i++) {\r\n            orchestrate(user, signatures[i]);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/Controller.sol\r\n\r\npragma solidity ^0.6.10;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev The Controller manages collateral and debt levels for all users, and it is a major user entry point for the Yield protocol.\r\n * Controller keeps track of a number of fyDai contracts.\r\n * Controller allows users to post and withdraw Chai and Weth collateral.\r\n * Any transactions resulting in a user weth collateral below dust are reverted.\r\n * Controller allows users to borrow fyDai against their Chai and Weth collateral.\r\n * Controller allows users to repay their fyDai debt with fyDai or with Dai.\r\n * Controller integrates with fyDai contracts for minting fyDai on borrowing, and burning fyDai on repaying debt with fyDai.\r\n * Controller relies on Treasury for all other asset transfers.\r\n * Controller allows orchestrated contracts to erase any amount of debt or collateral for an user. This is to be used during liquidations or during unwind.\r\n * Users can delegate the control of their accounts in Controllers to any address.\r\n */\r\ncontract Controller is IController, Orchestrated(), Delegable(), DecimalMath {\r\n    using SafeMath for uint256;\r\n\r\n    event Posted(bytes32 indexed collateral, address indexed user, int256 amount);\r\n    event Borrowed(bytes32 indexed collateral, uint256 indexed maturity, address indexed user, int256 amount);\r\n\r\n    bytes32 public constant CHAI = \"CHAI\";\r\n    bytes32 public constant WETH = \"ETH-A\";\r\n    uint256 public constant DUST = 50e15; // 0.05 ETH\r\n\r\n    IVat public vat;\r\n    IPot public pot;\r\n    ITreasury public override treasury;\r\n\r\n    mapping(uint256 => IFYDai) public override series;                 // FYDai series, indexed by maturity\r\n    uint256[] public override seriesIterator;                         // We need to know all the series\r\n\r\n    mapping(bytes32 => mapping(address => uint256)) public override posted;                        // Collateral posted by each user\r\n    mapping(bytes32 => mapping(uint256 => mapping(address => uint256))) public override debtFYDai;  // Debt owed by each user, by series\r\n\r\n    bool public live = true;\r\n\r\n    /// @dev Set up addresses for vat, pot and Treasury.\r\n    constructor (\r\n        address treasury_,\r\n        address[] memory fyDais\r\n\r\n    ) public {\r\n        treasury = ITreasury(treasury_);\r\n        vat = treasury.vat();\r\n        pot = treasury.pot();\r\n        for (uint256 i = 0; i < fyDais.length; i += 1) {\r\n            addSeries(fyDais[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev Modified functions only callable while the Controller is not unwinding due to a MakerDAO shutdown.\r\n    modifier onlyLive() {\r\n        require(live == true, \"Controller: Not available during unwind\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Only valid collateral types are Weth and Chai.\r\n    modifier validCollateral(bytes32 collateral) {\r\n        require(\r\n            collateral == WETH || collateral == CHAI,\r\n            \"Controller: Unrecognized collateral\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Only series added through `addSeries` are valid.\r\n    modifier validSeries(uint256 maturity) {\r\n        require(\r\n            containsSeries(maturity),\r\n            \"Controller: Unrecognized series\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Safe casting from uint256 to int256\r\n    function toInt256(uint256 x) internal pure returns(int256) {\r\n        require(\r\n            x <= uint256(type(int256).max),\r\n            \"Controller: Cast overflow\"\r\n        );\r\n        return int256(x);\r\n    }\r\n\r\n    /// @dev Disables post, withdraw, borrow and repay. To be called only when Treasury shuts down.\r\n    function shutdown() public override {\r\n        require(\r\n            treasury.live() == false,\r\n            \"Controller: Treasury is live\"\r\n        );\r\n        live = false;\r\n    }\r\n\r\n    /// @dev Return if the borrowing power for a given collateral of a user is equal or greater\r\n    /// than its debt for the same collateral\r\n    /// @param collateral Valid collateral type\r\n    /// @param user Address of the user vault\r\n    function isCollateralized(bytes32 collateral, address user) public view override returns (bool) {\r\n        return powerOf(collateral, user) >= totalDebtDai(collateral, user);\r\n    }\r\n\r\n    /// @dev Return if the collateral of an user is between zero and the dust level\r\n    /// @param collateral Valid collateral type\r\n    /// @param user Address of the user vault\r\n    function aboveDustOrZero(bytes32 collateral, address user) public view returns (bool) {\r\n        uint256 postedCollateral = posted[collateral][user];\r\n        return postedCollateral == 0 || DUST < postedCollateral;\r\n    }\r\n\r\n    /// @dev Return the total number of series registered\r\n    function totalSeries() public view override returns (uint256) {\r\n        return seriesIterator.length;\r\n    }\r\n\r\n    /// @dev Returns if a series has been added to the Controller.\r\n    /// @param maturity Maturity of the series to verify.\r\n    function containsSeries(uint256 maturity) public view override returns (bool) {\r\n        return address(series[maturity]) != address(0);\r\n    }\r\n\r\n    /// @dev Adds an fyDai series to this Controller\r\n    /// After deployment, ownership should be renounced, so that no more series can be added.\r\n    /// @param fyDaiContract Address of the fyDai series to add.\r\n    function addSeries(address fyDaiContract) private {\r\n        uint256 maturity = IFYDai(fyDaiContract).maturity();\r\n        require(\r\n            !containsSeries(maturity),\r\n            \"Controller: Series already added\"\r\n        );\r\n        series[maturity] = IFYDai(fyDaiContract);\r\n        seriesIterator.push(maturity);\r\n    }\r\n\r\n    /// @dev Dai equivalent of an fyDai amount.\r\n    /// After maturity, the Dai value of an fyDai grows according to either the stability fee (for WETH collateral) or the Dai Saving Rate (for Chai collateral).\r\n    /// @param collateral Valid collateral type\r\n    /// @param maturity Maturity of an added series\r\n    /// @param fyDaiAmount Amount of fyDai to convert.\r\n    /// @return Dai equivalent of an fyDai amount.\r\n    function inDai(bytes32 collateral, uint256 maturity, uint256 fyDaiAmount)\r\n        public view override\r\n        validCollateral(collateral)\r\n        returns (uint256)\r\n    {\r\n        IFYDai fyDai = series[maturity];\r\n        if (fyDai.isMature()){\r\n            if (collateral == WETH){\r\n                return muld(fyDaiAmount, fyDai.rateGrowth());\r\n            } else if (collateral == CHAI) {\r\n                return muld(fyDaiAmount, fyDai.chiGrowth());\r\n            }\r\n        } else {\r\n            return fyDaiAmount;\r\n        }\r\n    }\r\n\r\n    /// @dev fyDai equivalent of a Dai amount.\r\n    /// After maturity, the fyDai value of a Dai decreases according to either the stability fee (for WETH collateral) or the Dai Saving Rate (for Chai collateral).\r\n    /// @param collateral Valid collateral type\r\n    /// @param maturity Maturity of an added series\r\n    /// @param daiAmount Amount of Dai to convert.\r\n    /// @return fyDai equivalent of a Dai amount.\r\n    function inFYDai(bytes32 collateral, uint256 maturity, uint256 daiAmount)\r\n        public view override\r\n        validCollateral(collateral)\r\n        returns (uint256)\r\n    {\r\n        IFYDai fyDai = series[maturity];\r\n        if (fyDai.isMature()){\r\n            if (collateral == WETH){\r\n                return divd(daiAmount, fyDai.rateGrowth());\r\n            } else if (collateral == CHAI) {\r\n                return divd(daiAmount, fyDai.chiGrowth());\r\n            }\r\n        } else {\r\n            return daiAmount;\r\n        }\r\n    }\r\n\r\n    /// @dev Debt in dai of an user\r\n    /// After maturity, the Dai debt of a position grows according to either the stability fee (for WETH collateral) or the Dai Saving Rate (for Chai collateral).\r\n    /// @param collateral Valid collateral type\r\n    /// @param maturity Maturity of an added series\r\n    /// @param user Address of the user vault\r\n    /// @return Debt in dai of an user\r\n    //\r\n    //                        rate_now\r\n    // debt_now = debt_mat * ----------\r\n    //                        rate_mat\r\n    //\r\n    function debtDai(bytes32 collateral, uint256 maturity, address user) public view override returns (uint256) {\r\n        return inDai(collateral, maturity, debtFYDai[collateral][maturity][user]);\r\n    }\r\n\r\n    /// @dev Total debt of an user across all series, in Dai\r\n    /// The debt is summed across all series, taking into account interest on the debt after a series matures.\r\n    /// This function loops through all maturities, limiting the contract to hundreds of maturities.\r\n    /// @param collateral Valid collateral type\r\n    /// @param user Address of the user vault\r\n    /// @return Total debt of an user across all series, in Dai\r\n    function totalDebtDai(bytes32 collateral, address user) public view override returns (uint256) {\r\n        uint256 totalDebt;\r\n        uint256[] memory _seriesIterator = seriesIterator;\r\n        for (uint256 i = 0; i < _seriesIterator.length; i += 1) {\r\n            if (debtFYDai[collateral][_seriesIterator[i]][user] > 0) {\r\n                totalDebt = totalDebt.add(debtDai(collateral, _seriesIterator[i], user));\r\n            }\r\n        } // We don't expect hundreds of maturities per controller\r\n        return totalDebt;\r\n    }\r\n\r\n    /// @dev Borrowing power (in dai) of a user for a specific series and collateral.\r\n    /// @param collateral Valid collateral type\r\n    /// @param user Address of the user vault\r\n    /// @return Borrowing power of an user in dai.\r\n    //\r\n    // powerOf[user](wad) = posted[user](wad) * price()(ray)\r\n    //\r\n    function powerOf(bytes32 collateral, address user) public view returns (uint256) {\r\n        // dai = price * collateral\r\n        if (collateral == WETH){\r\n            (,, uint256 spot,,) = vat.ilks(WETH);  // Stability fee and collateralization ratio for Weth\r\n            return muld(posted[collateral][user], spot);\r\n        } else if (collateral == CHAI) {\r\n            uint256 chi = pot.chi();\r\n            return muld(posted[collateral][user], chi);\r\n        } else {\r\n            revert(\"Controller: Invalid collateral type\");\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the amount of collateral locked in borrowing operations.\r\n    /// @param collateral Valid collateral type.\r\n    /// @param user Address of the user vault.\r\n    function locked(bytes32 collateral, address user)\r\n        public view\r\n        validCollateral(collateral)\r\n        returns (uint256)\r\n    {\r\n        if (collateral == WETH){\r\n            (,, uint256 spot,,) = vat.ilks(WETH);  // Stability fee and collateralization ratio for Weth\r\n            return divdrup(totalDebtDai(collateral, user), spot);\r\n        } else if (collateral == CHAI) {\r\n            return divdrup(totalDebtDai(collateral, user), pot.chi());\r\n        }\r\n    }\r\n\r\n    /// @dev Takes collateral assets from `from` address, and credits them to `to` collateral account.\r\n    /// `from` can delegate to other addresses to take assets from him. Also needs to use `ERC20.approve`.\r\n    /// Calling ERC20.approve for Treasury contract is a prerequisite to this function\r\n    /// @param collateral Valid collateral type.\r\n    /// @param from Wallet to take collateral from.\r\n    /// @param to Yield vault to put the collateral in.\r\n    /// @param amount Amount of collateral to move.\r\n    // from --- Token ---> us(to)\r\n    function post(bytes32 collateral, address from, address to, uint256 amount)\r\n        public override \r\n        validCollateral(collateral)\r\n        onlyHolderOrDelegate(from, \"Controller: Only Holder Or Delegate\")\r\n        onlyLive\r\n    {\r\n        posted[collateral][to] = posted[collateral][to].add(amount);\r\n\r\n        if (collateral == WETH){\r\n            require(\r\n                aboveDustOrZero(collateral, to),\r\n                \"Controller: Below dust\"\r\n            );\r\n            treasury.pushWeth(from, amount);\r\n        } else if (collateral == CHAI) {\r\n            treasury.pushChai(from, amount);\r\n        }\r\n        \r\n        emit Posted(collateral, to, toInt256(amount));\r\n    }\r\n\r\n    /// @dev Returns collateral to `to` wallet, taking it from `from` Yield vault account.\r\n    /// `from` can delegate to other addresses to take assets from him.\r\n    /// @param collateral Valid collateral type.\r\n    /// @param from Yield vault to take collateral from.\r\n    /// @param to Wallet to put the collateral in.\r\n    /// @param amount Amount of collateral to move.\r\n    // us(from) --- Token ---> to\r\n    function withdraw(bytes32 collateral, address from, address to, uint256 amount)\r\n        public override\r\n        validCollateral(collateral)\r\n        onlyHolderOrDelegate(from, \"Controller: Only Holder Or Delegate\")\r\n        onlyLive\r\n    {\r\n        posted[collateral][from] = posted[collateral][from].sub(amount); // Will revert if not enough posted\r\n\r\n        require(\r\n            isCollateralized(collateral, from),\r\n            \"Controller: Too much debt\"\r\n        );\r\n\r\n        if (collateral == WETH){\r\n            require(\r\n                aboveDustOrZero(collateral, from),\r\n                \"Controller: Below dust\"\r\n            );\r\n            treasury.pullWeth(to, amount);\r\n        } else if (collateral == CHAI) {\r\n            treasury.pullChai(to, amount);\r\n        }\r\n\r\n        emit Posted(collateral, from, -toInt256(amount));\r\n    }\r\n\r\n    /// @dev Mint fyDai for a given series for wallet `to` by increasing the user debt in Yield vault `from`\r\n    /// `from` can delegate to other addresses to borrow using his vault.\r\n    /// The collateral needed changes according to series maturity and MakerDAO rate and chi, depending on collateral type.\r\n    /// @param collateral Valid collateral type.\r\n    /// @param maturity Maturity of an added series\r\n    /// @param from Yield vault that gets an increased debt.\r\n    /// @param to Wallet to put the fyDai in.\r\n    /// @param fyDaiAmount Amount of fyDai to borrow.\r\n    //\r\n    // posted[user](wad) >= (debtFYDai[user](wad)) * amount (wad)) * collateralization (ray)\r\n    //\r\n    // us(from) --- fyDai ---> to\r\n    // debt++\r\n    function borrow(bytes32 collateral, uint256 maturity, address from, address to, uint256 fyDaiAmount)\r\n        public override\r\n        validCollateral(collateral)\r\n        validSeries(maturity)\r\n        onlyHolderOrDelegate(from, \"Controller: Only Holder Or Delegate\")\r\n        onlyLive\r\n    {\r\n        IFYDai fyDai = series[maturity];\r\n\r\n        debtFYDai[collateral][maturity][from] = debtFYDai[collateral][maturity][from].add(fyDaiAmount);\r\n\r\n        require(\r\n            isCollateralized(collateral, from),\r\n            \"Controller: Too much debt\"\r\n        );\r\n\r\n        fyDai.mint(to, fyDaiAmount);\r\n        emit Borrowed(collateral, maturity, from, toInt256(fyDaiAmount));\r\n    }\r\n\r\n    /// @dev Burns fyDai from `from` wallet to repay debt in a Yield Vault.\r\n    /// User debt is decreased for the given collateral and fyDai series, in Yield vault `to`.\r\n    /// `from` can delegate to other addresses to take fyDai from him for the repayment.\r\n    /// @param collateral Valid collateral type.\r\n    /// @param maturity Maturity of an added series\r\n    /// @param from Wallet providing the fyDai for repayment.\r\n    /// @param to Yield vault to repay debt for.\r\n    /// @param fyDaiAmount Amount of fyDai to use for debt repayment.\r\n    //\r\n    //                                                  debt_nominal\r\n    // debt_discounted = debt_nominal - repay_amount * ---------------\r\n    //                                                  debt_now\r\n    //\r\n    // user(from) --- fyDai ---> us(to)\r\n    // debt--\r\n    function repayFYDai(bytes32 collateral, uint256 maturity, address from, address to, uint256 fyDaiAmount)\r\n        public override\r\n        validCollateral(collateral)\r\n        validSeries(maturity)\r\n        onlyHolderOrDelegate(from, \"Controller: Only Holder Or Delegate\")\r\n        onlyLive\r\n        returns (uint256)\r\n    {\r\n        uint256 toRepay = Math.min(fyDaiAmount, debtFYDai[collateral][maturity][to]);\r\n        series[maturity].burn(from, toRepay);\r\n        _repay(collateral, maturity, to, toRepay);\r\n        return toRepay;\r\n    }\r\n\r\n    /// @dev Burns Dai from `from` wallet to repay debt in a Yield Vault.\r\n    /// User debt is decreased for the given collateral and fyDai series, in Yield vault `to`.\r\n    /// The amount of debt repaid changes according to series maturity and MakerDAO rate and chi, depending on collateral type.\r\n    /// `from` can delegate to other addresses to take Dai from him for the repayment.\r\n    /// Calling ERC20.approve for Treasury contract is a prerequisite to this function\r\n    /// @param collateral Valid collateral type.\r\n    /// @param maturity Maturity of an added series\r\n    /// @param from Wallet providing the Dai for repayment.\r\n    /// @param to Yield vault to repay debt for.\r\n    /// @param daiAmount Amount of Dai to use for debt repayment.\r\n    //\r\n    //                                                  debt_nominal\r\n    // debt_discounted = debt_nominal - repay_amount * ---------------\r\n    //                                                  debt_now\r\n    //\r\n    // user --- dai ---> us\r\n    // debt--\r\n    function repayDai(bytes32 collateral, uint256 maturity, address from, address to, uint256 daiAmount)\r\n        public override\r\n        validCollateral(collateral)\r\n        validSeries(maturity)\r\n        onlyHolderOrDelegate(from, \"Controller: Only Holder Or Delegate\")\r\n        onlyLive\r\n        returns (uint256)\r\n    {\r\n        uint256 toRepay = Math.min(daiAmount, debtDai(collateral, maturity, to));\r\n        treasury.pushDai(from, toRepay);                                      // Have Treasury process the dai\r\n        _repay(collateral, maturity, to, inFYDai(collateral, maturity, toRepay));\r\n        return toRepay;\r\n    }\r\n\r\n    /// @dev Removes an amount of debt from an user's vault.\r\n    /// Internal function.\r\n    /// @param collateral Valid collateral type.\r\n    /// @param maturity Maturity of an added series\r\n    /// @param user Yield vault to repay debt for.\r\n    /// @param fyDaiAmount Amount of fyDai to use for debt repayment.\r\n\r\n    //\r\n    //                                                principal\r\n    // principal_repayment = gross_repayment * ----------------------\r\n    //                                          principal + interest\r\n    //    \r\n    function _repay(bytes32 collateral, uint256 maturity, address user, uint256 fyDaiAmount) internal {\r\n        debtFYDai[collateral][maturity][user] = debtFYDai[collateral][maturity][user].sub(fyDaiAmount);\r\n\r\n        emit Borrowed(collateral, maturity, user, -toInt256(fyDaiAmount));\r\n    }\r\n\r\n    /// @dev Removes all collateral and debt for an user, for a given collateral type.\r\n    /// This function can only be called by other Yield contracts, not users directly.\r\n    /// @param collateral Valid collateral type.\r\n    /// @param user Address of the user vault\r\n    /// @return The amounts of collateral and debt removed from Controller.\r\n    function erase(bytes32 collateral, address user)\r\n        public override\r\n        validCollateral(collateral)\r\n        onlyOrchestrated(\"Controller: Not Authorized\")\r\n        returns (uint256, uint256)\r\n    {\r\n        uint256 userCollateral = posted[collateral][user];\r\n        delete posted[collateral][user];\r\n\r\n        uint256 userDebt;\r\n        uint256[] memory _seriesIterator = seriesIterator;\r\n        for (uint256 i = 0; i < _seriesIterator.length; i += 1) {\r\n            uint256 maturity = _seriesIterator[i];\r\n            userDebt = userDebt.add(debtDai(collateral, maturity, user)); // SafeMath shouldn't be needed\r\n            delete debtFYDai[collateral][maturity][user];\r\n        } // We don't expect hundreds of maturities per controller\r\n\r\n        return (userCollateral, userDebt);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"treasury_\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"fyDais\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"collateral\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"}],\"name\":\"Borrowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"Delegate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"access\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"signature\",\"type\":\"bytes4\"}],\"name\":\"GrantedAccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"collateral\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"}],\"name\":\"Posted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CHAI\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DELEGABLE_DOMAIN\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DUST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SIGNATURE_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateral\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"aboveDustOrZero\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"addDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"addDelegateBySignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"signatures\",\"type\":\"bytes4[]\"}],\"name\":\"batchOrchestrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateral\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fyDaiAmount\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"}],\"name\":\"containsSeries\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateral\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"debtDai\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"debtFYDai\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateral\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"erase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateral\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fyDaiAmount\",\"type\":\"uint256\"}],\"name\":\"inDai\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateral\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daiAmount\",\"type\":\"uint256\"}],\"name\":\"inFYDai\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateral\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isCollateralized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"live\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateral\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"signature\",\"type\":\"bytes4\"}],\"name\":\"orchestrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"orchestration\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateral\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"post\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"posted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pot\",\"outputs\":[{\"internalType\":\"contract IPot\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateral\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"powerOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateral\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"daiAmount\",\"type\":\"uint256\"}],\"name\":\"repayDai\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateral\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fyDaiAmount\",\"type\":\"uint256\"}],\"name\":\"repayFYDai\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"revokeDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"series\",\"outputs\":[{\"internalType\":\"contract IFYDai\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"seriesIterator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shutdown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"signatureCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateral\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"totalDebtDai\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSeries\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"contract ITreasury\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vat\",\"outputs\":[{\"internalType\":\"contract IVat\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateral\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Controller", "CompilerVersion": "v0.6.10+commit.00c0fcaf", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000fa21de6f225c25b8f13264f1bff5e1e44a37f96e0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000600000000000000000000000092c25c17c0c908e52b16627f353f1004543f8a32000000000000000000000000f2c9c61487d796032cdb9d57f770121218ac5f910000000000000000000000003deca9af98f59ed5125d1f697abad2af45036332000000000000000000000000e523442a6c083016e2f430ab0780250ef4438536000000000000000000000000269a30e0fd5231438017dc0438f818a80dc4464b0000000000000000000000009d7e85d095934471a2788f485a3c765d0a463bd7", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1ad9ff342cb23b9171656068ca9b0516b7b59bb6b3a0d67eb00a4dc62b248fad"}