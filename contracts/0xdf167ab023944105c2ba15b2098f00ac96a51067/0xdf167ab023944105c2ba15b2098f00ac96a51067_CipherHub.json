{"SourceCode": "{\"MainContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"./SharedStruct.sol\\\";\\nimport \\\"./SharedState.sol\\\";\\nimport \\\"./Pool.sol\\\";\\nimport \\\"./TicketOptions.sol\\\";\\nimport \\\"./Ticket.sol\\\";\\n\\ncontract CipherHub is SharedState {\\n    using SharedStruct for SharedStruct.TicketOption;\\n    using SharedStruct for SharedStruct.Pool;\\n\\n    Pool private poolContract;\\n    TicketOption private ticketOptionContract;\\n    Ticket private ticketContract;\\n\\n    mapping(address =\\u003e uint) public creatorPayment;\\n    bool private emergencyStop;\\n    uint private latestPoolCreatedAt;\\n\\n    modifier isNotStopped() {\\n        require(!emergencyStop, \\\"There has been an emergency stop, please stand by for further details.\\\");\\n        _;\\n    }\\n\\n    function changePoolContract(address _poolAddress) public hasAuthority {\\n        poolContract = Pool(_poolAddress);\\n    }\\n\\n    function changeTicketContract(address _ticketAddress) public hasAuthority {\\n        ticketContract = Ticket(_ticketAddress);\\n    }\\n\\n    function changeTicketOptionContract(address _ticketOptionAddress) public hasAuthority {\\n        ticketOptionContract = TicketOption(_ticketOptionAddress);\\n    }\\n\\n    function setEmergencyStop(bool _emergencyStop) public hasAuthority {\\n        emergencyStop = _emergencyStop;\\n    }\\n\\n    function getEmergencyStop() public view returns (bool) {\\n        return emergencyStop;\\n    }\\n\\n    function createTicketOption(uint baseTickets, uint additionalTickets) public hasAuthority {\\n        ticketOptionContract.createTicketOption(baseTickets, additionalTickets);\\n    }\\n\\n    function changeUsabilityTicketOption(uint _ticketOptionIdx, bool newVal) public hasAuthority {\\n        ticketOptionContract.switchUsabilityTicketOption(_ticketOptionIdx, newVal);\\n    }\\n\\n    function createPool(uint8 multiplier) public isNotStopped payable {\\n        require(msg.value \\u003e= baseCreationFee * multiplier, \\\"You did not send enough ETH to create a pool.\\\");\\n        uint256 joiningEnd = block.timestamp + baseJoiningPeriod;\\n        uint256 activationEnd = block.timestamp + baseJoiningPeriod + baseActivationPeriod;\\n        poolContract.createPool(msg.sender, multiplier, msg.value, joiningEnd, activationEnd);\\n        latestPoolCreatedAt = block.timestamp;\\n    }\\n\\n    function purchaseTicket(uint poolIdx, uint8 ticketOptionIdx, string memory encryptedRes, bytes32 hashedRes) public payable {\\n        SharedStruct.Pool memory chosenpool = poolContract.getPool(poolIdx);\\n        require(block.timestamp \\u003c chosenpool.joiningPeriodEnd, \\\"Joining period has ended for this pool\\\");\\n        SharedStruct.TicketOption memory ticketOpt = ticketOptionContract.getTicketOptionDetails(ticketOptionIdx);\\n        require(msg.value \\u003e= ticketOpt.baseTickets * chosenpool.multiplier * baseJoiningFee, \\\"You did not send enough ETH.\\\");\\n        uint totalNumbers = ticketOpt.baseTickets + ticketOpt.additionalTickets;\\n        uint addToPool = (msg.value / 100 * (100 - poolCreatorFeePercentage - cipherHubFeePercentage));\\n        ticketContract.purchaseTicket(msg.sender, poolIdx, totalNumbers, encryptedRes, hashedRes);\\n        poolContract.addPurchaseData(poolIdx, totalNumbers, addToPool);\\n        creatorPayment[chosenpool.creator] += msg.value / 100 * poolCreatorFeePercentage;\\n        addToManagementPool(msg.value / 100 * cipherHubFeePercentage);\\n    }\\n\\n    function activateTicket(uint poolIdx, uint ticketIdx, uint8[] memory salt, uint32[] memory data) public {\\n        require(poolContract.canActivate(poolIdx), \\\"You\\u0027re not in the activation period.\\\");\\n        SharedStruct.Ticket memory ticket = ticketContract.getTicketByIdx(msg.sender, poolIdx, ticketIdx);\\n        uint32[] memory dataBasedOnTicketCount = new uint32[](ticket.numberCount);\\n        for (uint i = 0; i \\u003c ticket.numberCount; i++) {\\n            dataBasedOnTicketCount[i] = data[i];\\n        }\\n        ticketContract.activateTicket(msg.sender, poolIdx, ticketIdx, salt, data, dataBasedOnTicketCount);\\n        poolContract.addNumbers(poolIdx, dataBasedOnTicketCount);\\n    }\\n\\n    function claimWinningEth(uint poolIdx) public nonReentrant {\\n        poolContract.checkWinner(poolIdx, claimingPeriodEnd);\\n        SharedStruct.Pool memory pool = poolContract.getPool(poolIdx);\\n        require(ticketContract.validateWinner(msg.sender, poolIdx, pool.lowestUniqueNumber), \\\"You do not have the winning number\\\");\\n        poolContract.setWinner(msg.sender, poolIdx);\\n        (bool success,) = payable(msg.sender).call{value: pool.amountWinnable}(\\\"\\\");\\n        require(success, \\\"Claiming failed\\\");\\n        poolContract.setAsClaimed(poolIdx);\\n    }\\n\\n    function claimAsPoolCreator() public nonReentrant {\\n        require(creatorPayment[msg.sender] \\u003e 0, \\\"There is nothing to claim\\\");\\n        (bool success,) = payable(msg.sender).call{value: creatorPayment[msg.sender]}(\\\"\\\");\\n        require(success, \\\"Claiming failed\\\");\\n        creatorPayment[msg.sender] = 0;\\n    }\\n\\n    function claimAsCipherHub(uint poolIdx) public hasAuthority nonReentrant {\\n        SharedStruct.Pool memory pool = poolContract.getPool(poolIdx);\\n        require(!pool.claimed, \\\"This pool has already been claimed.\\\");\\n        require(block.timestamp \\u003e (pool.activationPeriodEnd + claimingPeriodEnd), \\\"Claiming period has not ended yet.\\\");\\n        (bool success,) = payable(msg.sender).call{value: pool.amountWinnable}(\\\"\\\");\\n        require(success, \\\"Claiming failed\\\");\\n        poolContract.setAsClaimed(poolIdx);\\n    }\\n\\n    function claimLastResort() public hasAuthority nonReentrant {\\n        uint halfYear = 3 * 30 days;\\n        require(block.timestamp \\u003e (latestPoolCreatedAt + halfYear), \\\"There are still pools being created.\\\");\\n        (bool success,) = payable(msg.sender).call{value: address(this).balance}(\\\"\\\");\\n        require(success, \\\"Claiming failed\\\");\\n    }\\n}\"},\"Ownership.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n\\ncontract Ownership {\\n    uint public managementPool;\\n    mapping(address =\\u003e bool) public owners;\\n    bool private locked;\\n\\n    modifier hasAuthority() {\\n        require(verifyOwner(), \\\"You are not authorized to do this action.\\\");\\n        _;\\n    }\\n\\n    modifier nonReentrant() {\\n        require(!locked, \\\"No re-entrancy.\\\");\\n        locked = true;\\n        _;\\n        locked = false;\\n    }\\n\\n    constructor() {\\n        owners[msg.sender] = true;\\n    }\\n\\n    function verifyOwner() public view returns (bool) {\\n        return owners[msg.sender];\\n    }\\n\\n    function addOwner(address _owner) public hasAuthority {\\n        require(owners[_owner] == false, \\\"This address already belongs to an owner.\\\");\\n        owners[_owner] = true;\\n    }\\n\\n    function removeOwner(address _owner) public hasAuthority {\\n        require(owners[_owner] == true, \\\"There is no owner with this address.\\\");\\n        owners[_owner] = false;\\n    }\\n\\n    function claimManagementPool() public hasAuthority nonReentrant {\\n        require(managementPool \\u003e 0, \\\"There are no funds in the pool\\\");\\n        payable(msg.sender).transfer(managementPool);\\n        managementPool = 0;\\n    }\\n\\n    function addToManagementPool(uint amount) internal {\\n        managementPool += amount;\\n    }\\n\\n    receive() external payable {\\n        addToManagementPool(msg.value);\\n    }\\n}\\n\"},\"Pool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"./SharedStruct.sol\\\";\\n\\ncontract Pool {\\n    using SharedStruct for SharedStruct.Pool;\\n\\n    address public mainContract;\\n\\n    SharedStruct.Pool[] public allPools;\\n    mapping(uint =\\u003e uint[]) public numberDumpPerPool;\\n    mapping(uint =\\u003e mapping(uint =\\u003e uint)) private numberCount;\\n    mapping(uint =\\u003e uint[]) private uniqueNumbers;\\n\\n    modifier isMainContract() {\\n        require(msg.sender == mainContract, \\\"You called this contract directly.\\\");\\n        _;\\n    }\\n\\n    modifier poolExists(uint _poolId) {\\n        require(isPool(_poolId), \\\"There is no pool with this index.\\\");\\n        _;\\n    }\\n\\n    constructor(address _mainContract) {\\n        mainContract = _mainContract;\\n    }\\n\\n    function isPool(uint poolIdx) public view returns (bool) {\\n        return poolIdx \\u003c allPools.length;\\n    }\\n\\n    function getPool(uint poolIdx) public view poolExists(poolIdx) returns (SharedStruct.Pool memory) {\\n        return allPools[poolIdx];\\n    }\\n\\n    function canPurchase(uint poolIdx) public view poolExists(poolIdx) returns (bool) {\\n        SharedStruct.Pool memory pool = allPools[poolIdx];\\n        return block.timestamp \\u003c pool.joiningPeriodEnd;\\n    }\\n\\n    function canActivate(uint poolIdx) public view poolExists(poolIdx) returns (bool) {\\n        SharedStruct.Pool memory pool = allPools[poolIdx];\\n        return block.timestamp \\u003e pool.joiningPeriodEnd \\u0026\\u0026 block.timestamp \\u003c pool.activationPeriodEnd;\\n    }\\n\\n    function createPool(address creator, uint8 multiplier, uint winnableAmount, uint joiningEnd, uint activationEnd) public isMainContract {\\n        SharedStruct.Pool memory newPool;\\n        newPool.idx = allPools.length;\\n        newPool.amountWinnable = winnableAmount;\\n        newPool.winner = address(0);\\n        newPool.lowestUniqueNumber = 1_000_000;\\n        newPool.claimed = false;\\n        newPool.joiningPeriodEnd = joiningEnd;\\n        newPool.activationPeriodEnd = activationEnd;\\n        newPool.creator = creator;\\n        newPool.ticketsSold = 0;\\n        newPool.multiplier = multiplier;\\n        allPools.push(newPool);\\n    }\\n\\n    function getAllPools() public view returns (SharedStruct.Pool[] memory) {\\n        return allPools;\\n    }\\n\\n    function getTicketCount(uint poolIdx) public view poolExists(poolIdx) returns (uint) {\\n        return allPools[poolIdx].ticketsSold;\\n    }\\n\\n    function addNumbers(uint poolIdx, uint32[] memory data) public isMainContract poolExists(poolIdx) {\\n        for (uint8 idx = 0; idx \\u003c data.length; idx++) {\\n            uint32 currNumber = data[idx];\\n            if (currNumber \\u003e 0 \\u0026\\u0026 currNumber \\u003c 1_000_000) {\\n                numberDumpPerPool[poolIdx].push(currNumber);\\n                numberCount[poolIdx][currNumber]++;\\n                if (numberCount[poolIdx][currNumber] == 1) {\\n                    uniqueNumbers[poolIdx].push(currNumber);\\n                }\\n            }\\n        }\\n    }\\n\\n    function getNumberDumpForPool(uint256 poolIdx) public view poolExists(poolIdx) returns (uint256[] memory) {\\n        SharedStruct.Pool memory pool = allPools[poolIdx];\\n        require(block.timestamp \\u003e pool.joiningPeriodEnd, \\\"There is no activation of tickets yet\\\");\\n        return numberDumpPerPool[poolIdx];\\n    }\\n\\n    function setLowestUniqueNumber(uint256 poolIdx) public poolExists(poolIdx) {\\n        SharedStruct.Pool storage pool = allPools[poolIdx];\\n        require(block.timestamp \\u003e pool.activationPeriodEnd, \\\"Activation period has not ended yet.\\\");\\n        require(pool.lowestUniqueNumber == 1_000_000, \\\"Lowest number has already been calculated.\\\");\\n        uint256 lowestNumber = pool.lowestUniqueNumber;\\n        for (uint256 idx = 0; idx \\u003c uniqueNumbers[poolIdx].length; idx++) {\\n            if (numberCount[poolIdx][uniqueNumbers[poolIdx][idx]] == 1 \\u0026\\u0026 uniqueNumbers[poolIdx][idx] \\u003c lowestNumber) {\\n                lowestNumber = uniqueNumbers[poolIdx][idx];\\n            }\\n        }\\n        pool.lowestUniqueNumber = lowestNumber;\\n    }\\n\\n    function getLowestUniqueNumber(uint poolIdx) public view poolExists(poolIdx) returns (uint) {\\n        SharedStruct.Pool memory pool = allPools[poolIdx];\\n        return pool.lowestUniqueNumber;\\n    }\\n\\n    function addPurchaseData(uint poolIdx, uint totalNumbers, uint addToPool) public isMainContract poolExists(poolIdx) {\\n        SharedStruct.Pool storage pool = allPools[poolIdx];\\n        pool.ticketsSold += totalNumbers;\\n        pool.amountWinnable += addToPool;\\n    }\\n\\n    function setWinner(address winner, uint poolIdx) public isMainContract poolExists(poolIdx) {\\n        SharedStruct.Pool storage pool = allPools[poolIdx];\\n        pool.winner = winner;\\n    }\\n\\n    function setAsClaimed(uint poolIdx) public isMainContract poolExists(poolIdx) {\\n        SharedStruct.Pool storage pool = allPools[poolIdx];\\n        pool.claimed = true;\\n    }\\n\\n    function checkWinner(uint poolIdx, uint claimingPeriodEnd) public view isMainContract poolExists(poolIdx) {\\n        SharedStruct.Pool memory pool = allPools[poolIdx];\\n        require(block.timestamp \\u003e pool.activationPeriodEnd, \\\"Activation period has not ended yet.\\\");\\n        require(block.timestamp \\u003c (pool.activationPeriodEnd + claimingPeriodEnd), \\\"Claiming window has ended\\\");\\n        require(!pool.claimed, \\\"This pool has already been claimed.\\\");\\n        require(pool.lowestUniqueNumber \\u003c 1_000_000, \\\"There is no winner.\\\");\\n    }\\n}\"},\"SharedState.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"./Ownership.sol\\\";\\nimport \\\"./SharedStruct.sol\\\";\\n\\ncontract SharedState is Ownership {\\n    using SharedStruct for SharedStruct.FeeOverview;\\n\\n    uint internal baseCreationFee = 0.1 ether;\\n    uint internal baseJoiningFee = 0.001 ether;\\n    uint internal baseJoiningPeriod = 2 minutes;\\n    uint internal baseActivationPeriod = 2 minutes;\\n    uint internal claimingPeriodEnd = 2 minutes;\\n\\n    uint internal cipherHubFeePercentage = 4;\\n    uint internal poolCreatorFeePercentage = 6;\\n\\n    function updateBaseCreationFee(uint _creationAmount) public hasAuthority {\\n        baseCreationFee = _creationAmount;\\n    }\\n\\n    function updateBaseJoiningFee(uint _joiningFee) public hasAuthority {\\n        baseJoiningFee = _joiningFee;\\n    }\\n\\n    function updateBaseJoiningPeriod(uint _joiningPeriod) public hasAuthority {\\n        baseJoiningPeriod = _joiningPeriod * (1 minutes);\\n    }\\n\\n    function updateBaseActionPeriod(uint _activationPeriod) public hasAuthority {\\n        baseActivationPeriod = _activationPeriod * (1 minutes);\\n    }\\n\\n    function updateClaimingPeriodEnd(uint _claimingPeriodEnd) public hasAuthority {\\n        claimingPeriodEnd = _claimingPeriodEnd * (1 minutes);\\n    }\\n\\n    function updateCipherhubFeePercentage(uint _cipherHubFeePercentage) public hasAuthority {\\n        cipherHubFeePercentage = _cipherHubFeePercentage;\\n    }\\n\\n    function updatePoolCreatorFee(uint _poolCreatorFeePercentage) public hasAuthority {\\n        poolCreatorFeePercentage = _poolCreatorFeePercentage;\\n    }\\n\\n    function getFeeOverview() public view returns (SharedStruct.FeeOverview memory){\\n        SharedStruct.FeeOverview memory fees;\\n        fees.claimingPeriodEnd = claimingPeriodEnd;\\n        fees.activationPeriod = baseActivationPeriod;\\n        fees.joiningFee = baseJoiningFee;\\n        fees.creationFee = baseCreationFee;\\n        fees.joiningPeriod = baseJoiningPeriod;\\n        return fees;\\n    }\\n}\\n\"},\"SharedStruct.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nlibrary SharedStruct {\\n    struct FeeOverview {\\n        uint creationFee;\\n        uint joiningFee;\\n        uint joiningPeriod;\\n        uint activationPeriod;\\n        uint claimingPeriodEnd;\\n    }\\n\\n    struct Ticket {\\n        uint idx;\\n        uint numberCount;\\n        string encryptedData;\\n        bytes32 hashedData;\\n        bool activated;\\n        uint32[] unlockedValues;\\n    }\\n\\n    struct TicketOption {\\n        uint idx;\\n        uint baseTickets;\\n        uint additionalTickets;\\n        bool active;\\n    }\\n\\n    struct Pool {\\n        uint idx;\\n        uint joiningPeriodEnd;\\n        uint activationPeriodEnd;\\n        uint amountWinnable;\\n        uint lowestUniqueNumber;\\n        uint ticketsSold;\\n        uint8 multiplier;\\n        address creator;\\n        address winner;\\n        bool claimed;\\n    }\\n}\"},\"Ticket.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"./SharedStruct.sol\\\";\\n\\ncontract Ticket {\\n    using SharedStruct for SharedStruct.Ticket;\\n\\n    mapping(address =\\u003e mapping(uint =\\u003e SharedStruct.Ticket[])) private addressTickets;\\n    address public mainContract;\\n\\n    modifier isMainContract() {\\n        require(msg.sender == mainContract, \\\"You called this contract directly.\\\");\\n        _;\\n    }\\n\\n    modifier ticketExists(address buyer, uint poolIdx, uint ticketIdx) {\\n        require(ticketIdx \\u003c addressTickets[buyer][poolIdx].length, \\\"There is no such ticket\\\");\\n        _;\\n    }\\n\\n    constructor(address _mainContract) {\\n        mainContract = _mainContract;\\n    }\\n\\n    function getTicketByIdx(address buyer, uint poolIdx, uint ticketIdx) public view ticketExists(buyer, poolIdx, ticketIdx) returns (SharedStruct.Ticket memory) {\\n        return addressTickets[buyer][poolIdx][ticketIdx];\\n    }\\n\\n    function getNewTicket(uint poolIdx, uint ticketIdx) public view ticketExists(msg.sender, poolIdx, ticketIdx) returns (SharedStruct.Ticket memory) {\\n        return addressTickets[msg.sender][poolIdx][ticketIdx];\\n    }\\n\\n    function getMyTickets(uint poolIdx) public view returns (SharedStruct.Ticket[] memory){\\n        return addressTickets[msg.sender][poolIdx];\\n    }\\n\\n    function getMyTicketCount(uint poolIdx) public view returns (uint) {\\n        return addressTickets[msg.sender][poolIdx].length;\\n    }\\n\\n    function purchaseTicket(address buyer, uint poolIdx, uint _numberCount, string memory encryptedRes, bytes32 hashedRes) public isMainContract {\\n        SharedStruct.Ticket memory newTicket;\\n        newTicket.idx = addressTickets[buyer][poolIdx].length;\\n        newTicket.numberCount = _numberCount;\\n        newTicket.encryptedData = encryptedRes;\\n        newTicket.hashedData = hashedRes;\\n        newTicket.activated = false;\\n        addressTickets[buyer][poolIdx].push(newTicket);\\n    }\\n\\n    function activateTicket(address buyer, uint poolIdx, uint ticketIdx, uint8[] memory salt, uint32[] memory data, uint32[] memory dataBasedOnTicketCount) public isMainContract ticketExists(buyer, poolIdx, ticketIdx) {\\n        SharedStruct.Ticket storage ticketToActivate = addressTickets[buyer][poolIdx][ticketIdx];\\n        require(!ticketToActivate.activated, \\\"This ticket has already been activated.\\\");\\n        require(ticketToActivate.hashedData == keccak256(abi.encodePacked(salt, data)), \\\"The data does not match.\\\");\\n        ticketToActivate.activated = true;\\n        ticketToActivate.unlockedValues = dataBasedOnTicketCount;\\n    }\\n\\n    function validateWinner(address buyer, uint poolIdx, uint lowestNumber) public view isMainContract returns (bool){\\n        bool isWinner;\\n        SharedStruct.Ticket[] memory ticketLst = addressTickets[buyer][poolIdx];\\n        for (uint idx = 0; idx \\u003c ticketLst.length; idx++) {\\n            SharedStruct.Ticket memory ticket = ticketLst[idx];\\n            if (ticket.activated) {\\n                for (uint numberIdx = 0; numberIdx \\u003c ticket.unlockedValues.length; numberIdx++) {\\n                    if (ticket.unlockedValues[numberIdx] == lowestNumber) {\\n                        isWinner = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return isWinner;\\n    }\\n}\\n\"},\"TicketOptions.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"./SharedStruct.sol\\\";\\n\\ncontract TicketOption {\\n    using SharedStruct for SharedStruct.TicketOption;\\n\\n    SharedStruct.TicketOption[] public allTicketOptions;\\n\\n    address public mainContract;\\n\\n    modifier ticketOptionExists(uint _ticketOptionIdx) {\\n        require(isTicketOption(_ticketOptionIdx), \\\"There is no ticket with this index.\\\");\\n        _;\\n    }\\n\\n    modifier isMainContract() {\\n        require(msg.sender == mainContract, \\\"You called this contract directly.\\\");\\n        _;\\n    }\\n\\n    constructor(address _mainContract) {\\n        mainContract = _mainContract;\\n    }\\n\\n    function createTicketOption(uint baseTickets, uint additionalTickets) public isMainContract {\\n        SharedStruct.TicketOption memory ticketOpt;\\n        ticketOpt.idx = allTicketOptions.length;\\n        ticketOpt.baseTickets = baseTickets;\\n        ticketOpt.additionalTickets = additionalTickets;\\n        ticketOpt.active = true;\\n        allTicketOptions.push(ticketOpt);\\n    }\\n\\n    function isTicketOption(uint ticketIdx) private view returns (bool) {\\n        return ticketIdx \\u003c allTicketOptions.length;\\n    }\\n\\n    function isActiveTicketOption(uint ticketIdx) public view ticketOptionExists(ticketIdx) returns (bool) {\\n        SharedStruct.TicketOption memory ticketOpt = allTicketOptions[ticketIdx];\\n        return ticketOpt.active;\\n    }\\n\\n    function getTicketOptionDetails(uint ticketIdx) public view ticketOptionExists(ticketIdx) returns (SharedStruct.TicketOption memory) {\\n        require(isActiveTicketOption(ticketIdx), \\\"This ticket is currently unavailable\\\");\\n        return allTicketOptions[ticketIdx];\\n    }\\n\\n    function getAllTicketOptions() public view returns (SharedStruct.TicketOption[] memory) {\\n        return allTicketOptions;\\n    }\\n\\n    function switchUsabilityTicketOption(uint _ticketOptionIdx, bool newVal) public isMainContract ticketOptionExists(_ticketOptionIdx) {\\n        SharedStruct.TicketOption storage foundTicketOption = allTicketOptions[_ticketOptionIdx];\\n        foundTicketOption.active = newVal;\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolIdx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ticketIdx\",\"type\":\"uint256\"},{\"internalType\":\"uint8[]\",\"name\":\"salt\",\"type\":\"uint8[]\"},{\"internalType\":\"uint32[]\",\"name\":\"data\",\"type\":\"uint32[]\"}],\"name\":\"activateTicket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolAddress\",\"type\":\"address\"}],\"name\":\"changePoolContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ticketAddress\",\"type\":\"address\"}],\"name\":\"changeTicketContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ticketOptionAddress\",\"type\":\"address\"}],\"name\":\"changeTicketOptionContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ticketOptionIdx\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"newVal\",\"type\":\"bool\"}],\"name\":\"changeUsabilityTicketOption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolIdx\",\"type\":\"uint256\"}],\"name\":\"claimAsCipherHub\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAsPoolCreator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimLastResort\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimManagementPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolIdx\",\"type\":\"uint256\"}],\"name\":\"claimWinningEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"multiplier\",\"type\":\"uint8\"}],\"name\":\"createPool\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"baseTickets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"additionalTickets\",\"type\":\"uint256\"}],\"name\":\"createTicketOption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"creatorPayment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEmergencyStop\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeOverview\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"creationFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"joiningFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"joiningPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activationPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimingPeriodEnd\",\"type\":\"uint256\"}],\"internalType\":\"struct SharedStruct.FeeOverview\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managementPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolIdx\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"ticketOptionIdx\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"encryptedRes\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"hashedRes\",\"type\":\"bytes32\"}],\"name\":\"purchaseTicket\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_emergencyStop\",\"type\":\"bool\"}],\"name\":\"setEmergencyStop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_activationPeriod\",\"type\":\"uint256\"}],\"name\":\"updateBaseActionPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_creationAmount\",\"type\":\"uint256\"}],\"name\":\"updateBaseCreationFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_joiningFee\",\"type\":\"uint256\"}],\"name\":\"updateBaseJoiningFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_joiningPeriod\",\"type\":\"uint256\"}],\"name\":\"updateBaseJoiningPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cipherHubFeePercentage\",\"type\":\"uint256\"}],\"name\":\"updateCipherhubFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_claimingPeriodEnd\",\"type\":\"uint256\"}],\"name\":\"updateClaimingPeriodEnd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolCreatorFeePercentage\",\"type\":\"uint256\"}],\"name\":\"updatePoolCreatorFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verifyOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CipherHub", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f6d572ed6dd6595b06c62e94bf4c98cc77590ef839c88e6092abe860d741b476"}