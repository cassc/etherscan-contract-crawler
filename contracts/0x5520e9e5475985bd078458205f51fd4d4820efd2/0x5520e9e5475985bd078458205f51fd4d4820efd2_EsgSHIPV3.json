{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/EsgSHIPV3.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./EIP20Interface.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\ncontract EsgSHIPV3{\\n    using SafeMath for uint256;\\n    /// @notice ESG token\\n    EIP20Interface public esg;\\n\\n    /// @notice Emitted when referral set invitee\\n    event SetInvitee(address inviteeAddress);\\n\\n    /// @notice Emitted when owner set invitee\\n    event SetInviteeByOwner(address referrerAddress, address inviteeAddress);\\n\\n    /// @notice Emitted when ESG is invest  \\n    event EsgInvest(address account, uint amount, uint price);\\n\\n    /// @notice Emitted when ESG is invest by owner \\n    event EsgInvestByOwner(address account, uint amount, uint price);\\n\\n    /// @notice Emitted when ESG is claimed \\n    event EsgClaimed(address account, uint amount, uint price);\\n\\n    /// @notice Emitted when change Lock info\\n    event EsgChangeLockInfo(address _user, uint256 _rate, uint256 i);\\n\\n    /// @notice Emitted when change Investment info\\n    event EsgChangeInvestmentInfo(address _user, uint256 _userTotalValue, uint256 _withdraw, uint256 _lastCollectionTime);\\n\\n    /// @notice Emitted when change Referrer info\\n    event EsgChangeReferrerInfo(address _user, uint256 _totalInvestment, uint256 _referrerRewardLimit, uint256 _totalReferrerRaward, uint256 _teamRewardTime, uint256 _teamRewardRate, uint256 _noExtract);\\n\\n    struct Lock {\\n        uint256 amount;\\n        uint256 esgPrice;\\n        uint256 value;\\n        uint256 start;\\n        uint256 end;\\n        uint256 investDays;\\n        uint256 releaseRate;\\n    }\\n    mapping(address => Lock[]) public locks;\\n\\n    struct Investment {\\n        uint256 userTotalValue;\\n        uint256 withdraw; \\n        uint256 lastCollectionTime;\\n    }\\n    mapping(address => Investment) public investments;\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Only owner can call this function.\\\");\\n        _;\\n    }\\n\\n    struct Referrer {\\n        address[] referrals;\\n        uint256 totalInvestment;\\n        uint256 referrerRewardLimit;\\n        uint256 totalReferrerRaward;\\n        uint256 teamRewardTime;\\n        uint256 teamRewardRate;\\n        uint256 noExtract;\\n    }\\n    mapping(address => Referrer) public referrers;//1:n\\n\\n    struct User {\\n        address referrer_addr;\\n    }\\n    mapping (address => User) public referrerlist;//1:1\\n\\n    address private feeWallet; \\n    uint256 public fee = 5;\\n    uint256 public invest_days1 = 350;\\n    uint256 public invest_days2 = 350;\\n    uint256 public invest_days3 = 350;\\n    uint256 public invest_days4 = 350;\\n    uint256 public invest_days5 = 300;\\n    uint256 public referralThreshold = 1000 * 1e24;\\n    uint256 public total_deposited;\\n    uint256 public total_user;\\n    uint256 public total_amount;\\n    uint256 public total_extracted;\\n    uint256 public total_claim_amount;\\n    uint256 public lockRates = 100; \\n    uint256 public staticRewardRate = 10;\\n    uint256 public dynamicRewardRate = 10;\\n    uint256 public teamRewardThreshold = 30000 * 1e24;\\n    uint256 public teamRewardThresholdRate = 30 * 1e24;\\n    uint256 public teamRewardThresholdStep = 10000 * 1e24;\\n    uint256 public teamRewardThresholdStepRate = 10 * 1e24;\\n    uint256 public price;\\n    bool public investEnabled;\\n    bool public claimEnabled;\\n    address public owner;\\n\\n    constructor(address esgAddress, address feeWalletAddress) public {\\n        owner = msg.sender;\\n        investEnabled = true;\\n        claimEnabled = true;\\n        esg = EIP20Interface(esgAddress);\\n        feeWallet = feeWalletAddress;\\n    }\\n\\n    function setPrice(uint256 _price) onlyOwner public {\\n        require(_price > 0, \\\"Price must be positive\\\");\\n        price = _price;\\n    }\\n\\n    function setFee(uint256 _fee) onlyOwner public {\\n        require(_fee > 0, \\\"Fee must be positive\\\");\\n        fee = _fee;\\n    }\\n\\n    function setInvestEnabled(bool _investEnabled) onlyOwner public {\\n        investEnabled = _investEnabled;\\n    }\\n\\n    function setClaimEnabled(bool _claimEnabled) onlyOwner public {\\n        claimEnabled = _claimEnabled;\\n    }\\n\\n    function setInvestDays(uint256 days1, uint256 days2, uint256 days3, uint256 days4, uint256 days5) onlyOwner public {\\n        require(days1 > 0, \\\"days1 should be greater than 0\\\");\\n        require(days2 > 0, \\\"days2 should be greater than 0\\\");\\n        require(days3 > 0, \\\"days3 should be greater than 0\\\");\\n        require(days4 > 0, \\\"days4 should be greater than 0\\\");\\n        require(days5 > 0, \\\"days5 should be greater than 0\\\");\\n        invest_days1 = days1;\\n        invest_days2 = days2;\\n        invest_days3 = days3;\\n        invest_days4 = days4;\\n        invest_days5 = days5;\\n    }\\n\\n    function setLockRates(uint256 _lockRates) onlyOwner public {\\n        lockRates = _lockRates;\\n    }\\n\\n    function setReferralThreshold(uint256 _referralThreshold) onlyOwner public {\\n        referralThreshold = _referralThreshold;\\n    }\\n\\n    function setStaticRewardRate(uint256 _staticRewardRate) onlyOwner public {\\n        staticRewardRate = _staticRewardRate;\\n    }\\n\\n    function setDynamicRewardRate(uint256 _dynamicRewardRate) onlyOwner public {\\n        dynamicRewardRate = _dynamicRewardRate;\\n    }\\n\\n    function setTeamRewardThreshold(uint256 _teamRewardThreshold) onlyOwner public {\\n        teamRewardThreshold = _teamRewardThreshold;\\n    }\\n\\n    function setTeamRewardThresholdRate(uint256 _teamRewardThresholdRate) onlyOwner public {\\n        teamRewardThresholdRate = _teamRewardThresholdRate;\\n    }\\n\\n    function setTeamRewardThresholdStep(uint256 _teamRewardThresholdStep) onlyOwner public {\\n        teamRewardThresholdStep = _teamRewardThresholdStep;\\n    }\\n\\n    function setTeamRewardThresholdStepRate(uint256 _teamRewardThresholdStepRate) onlyOwner public {\\n        teamRewardThresholdStepRate = _teamRewardThresholdStepRate;\\n    }\\n\\n    function setInvitee(address inviteeAddress) public returns (bool) {\\n        require(inviteeAddress != address(0), \\\"inviteeAddress cannot be 0x0.\\\");\\n\\n        User storage user = referrerlist[inviteeAddress];\\n        require(user.referrer_addr == address(0), \\\"This account had been invited!\\\");\\n        \\n        Investment storage investment = investments[msg.sender];\\n        require(investment.userTotalValue.mul(lockRates).div(100).add(investment.userTotalValue).sub(investment.withdraw) >= referralThreshold, \\\"Referrer has no referral qualification.\\\");\\n\\n        Lock[] storage inviteeLocks = locks[inviteeAddress];\\n        require(inviteeLocks.length == 0, \\\"This account had staked!\\\");\\n        \\n        Referrer storage referrer = referrers[msg.sender];\\n        referrer.referrals.push(inviteeAddress);\\n        if(referrer.referrerRewardLimit == 0){\\n            referrer.referrerRewardLimit = investment.userTotalValue.mul(lockRates).div(100).add(investment.userTotalValue);\\n        }\\n\\n        User storage _user = referrerlist[inviteeAddress];\\n        _user.referrer_addr = msg.sender;\\n\\n        emit SetInvitee(inviteeAddress);\\n        return true;   \\n    }\\n\\n    function setInviteeByOwner(address referrerAddress, address inviteeAddress) public onlyOwner returns (bool) {\\n        require(referrerAddress != address(0), \\\"referrerAddress cannot be 0x0.\\\");\\n        require(inviteeAddress != address(0), \\\"inviteeAddress cannot be 0x0.\\\");\\n\\n        User storage user = referrerlist[inviteeAddress];\\n        require(user.referrer_addr == address(0), \\\"This account had been invited!\\\");\\n        \\n        Investment storage investment = investments[referrerAddress];\\n        require(investment.userTotalValue.mul(lockRates).div(100).add(investment.userTotalValue).sub(investment.withdraw) >= referralThreshold, \\\"Referrer has no referral qualification.\\\");\\n\\n        Lock[] storage inviteeLocks = locks[inviteeAddress];\\n        require(inviteeLocks.length == 0, \\\"This account had staked!\\\");\\n        \\n        Referrer storage referrer = referrers[referrerAddress];\\n        referrer.referrals.push(inviteeAddress);\\n        if(referrer.referrerRewardLimit == 0){\\n            referrer.referrerRewardLimit = investment.userTotalValue.mul(lockRates).div(100).add(investment.userTotalValue);\\n        }\\n\\n        User storage _user = referrerlist[inviteeAddress];\\n        _user.referrer_addr = referrerAddress;\\n\\n        emit SetInviteeByOwner(referrerAddress, inviteeAddress);\\n        return true;   \\n    }\\n\\n    function getInviteelist(address referrerAddress) public view returns (address[] memory) {\\n        require(referrerAddress != address(0), \\\"referrerAddress cannot be 0x0.\\\");\\n        Referrer storage referrer = referrers[referrerAddress];\\n        return referrer.referrals;\\n    }\\n\\n    function getReferrer(address inviteeAddress) public view returns (address) {\\n        require(inviteeAddress != address(0), \\\"inviteeAddress cannot be 0x0.\\\");\\n        User storage user = referrerlist[inviteeAddress];\\n        return user.referrer_addr;\\n    }\\n\\n    function invest(uint256 _amount) public returns (bool) {\\n        require(investEnabled == true, \\\"No invest allowed!\\\");\\n        require(_amount > 0, \\\"Invalid amount.\\\");\\n\\n        esg.transferFrom(msg.sender, address(this), _amount);\\n\\n        uint256 nowTime = block.timestamp;\\n        Lock[] storage user_locks = locks[msg.sender];\\n        if(user_locks.length > 0){\\n            Investment storage user_investment = investments[msg.sender];\\n            uint256 userDeposit = user_investment.userTotalValue.mul(lockRates).div(100).add(user_investment.userTotalValue);\\n            uint256 userWithdraw = user_investment.withdraw;\\n            if(userDeposit == userWithdraw){\\n                user_investment.lastCollectionTime = nowTime;\\n            }\\n        }\\n\\n        uint256 invest_days = 0;\\n        uint256 deposit = _amount.mul(price);\\n        if(deposit < 500 * 1e24){\\n            invest_days = invest_days1;\\n        }else if(deposit >= 500 * 1e24 && deposit < 2000 * 1e24){\\n            invest_days = invest_days2;\\n        }else if(deposit >= 2000 * 1e24 && deposit < 5000 * 1e24){\\n            invest_days = invest_days3;\\n        }else if(deposit >= 5000 * 1e24 && deposit < 10000 * 1e24){\\n            invest_days = invest_days4;\\n        }else if(deposit >= 10000 * 1e24){\\n            invest_days = invest_days5;\\n        }\\n        \\n        locks[msg.sender].push(\\n            Lock(\\n                _amount,\\n                price,\\n                deposit,\\n                nowTime,\\n                nowTime + (invest_days * 86400),\\n                invest_days,\\n                (deposit.mul(lockRates).div(100).add(deposit)).div(invest_days).div(86400)\\n            )\\n        );\\n\\n        Investment storage investment = investments[msg.sender];\\n        if(investment.userTotalValue == 0){\\n            investment.lastCollectionTime = nowTime;\\n            total_user = total_user + 1;\\n        }\\n        investment.userTotalValue += deposit;\\n\\n        total_deposited = total_deposited + deposit;\\n        total_amount = total_amount + _amount;\\n\\n        Referrer storage userReferrer = referrers[msg.sender];\\n        if(userReferrer.referrals.length > 0){\\n            userReferrer.referrerRewardLimit = investment.userTotalValue.mul(lockRates).div(100).add(investment.userTotalValue);\\n            if(userReferrer.totalInvestment >= teamRewardThreshold){\\n                uint256 statistics = 0;\\n                if(userReferrer.teamRewardTime == 0){\\n                    userReferrer.teamRewardTime = block.timestamp;\\n                    statistics = (userReferrer.totalInvestment.sub(teamRewardThreshold)).div(teamRewardThresholdStep);\\n                    userReferrer.teamRewardRate = teamRewardThresholdStepRate.mul(statistics).div(86400);\\n                    userReferrer.teamRewardRate += teamRewardThresholdRate.div(86400);\\n                }\\n            }\\n        }\\n            \\n        User storage user = referrerlist[msg.sender];\\n\\n        if(user.referrer_addr != address(0)){\\n            referrers[user.referrer_addr].totalInvestment += deposit;\\n            uint256 staticReward = deposit.mul(staticRewardRate).div(100);\\n            Referrer storage referrer = referrers[user.referrer_addr];\\n\\n            Lock[] storage userLocks = locks[user.referrer_addr];\\n            if(referrer.totalReferrerRaward < referrer.referrerRewardLimit){\\n                if(referrer.totalReferrerRaward + staticReward < referrer.referrerRewardLimit){\\n                    referrer.noExtract += staticReward;\\n                    if(referrer.noExtract >= referrer.referrerRewardLimit){\\n                        for (uint256 i = 0; i < userLocks.length; i++) {\\n                            Lock storage lock = userLocks[i];\\n                            lock.releaseRate = 0;\\n                        }\\n                    }\\n                }else{\\n                    referrer.noExtract = referrer.referrerRewardLimit - referrer.totalReferrerRaward;\\n                    for (uint256 i = 0; i < userLocks.length; i++) {\\n                        Lock storage lock = userLocks[i];\\n                        lock.releaseRate = 0;\\n                    }\\n                }\\n            }\\n            \\n            if(referrer.totalInvestment >= teamRewardThreshold){\\n                uint256 statistics = 0;\\n                if(referrer.teamRewardTime == 0){\\n                    referrer.teamRewardTime = block.timestamp;\\n                    statistics = (referrer.totalInvestment.sub(teamRewardThreshold)).div(teamRewardThresholdStep);\\n                    referrer.teamRewardRate = teamRewardThresholdStepRate.mul(statistics).div(86400);\\n                    referrer.teamRewardRate += teamRewardThresholdRate.div(86400);\\n                }else{\\n                    uint256 team_reward = (block.timestamp.sub(referrer.teamRewardTime)).mul(referrer.teamRewardRate);\\n                    if(referrer.totalReferrerRaward < referrer.referrerRewardLimit){\\n                        if(referrer.totalReferrerRaward + team_reward < referrer.referrerRewardLimit){\\n                            referrer.noExtract += team_reward;\\n                            if(referrer.noExtract >= referrer.referrerRewardLimit){\\n                                for (uint256 i = 0; i < userLocks.length; i++) {\\n                                    Lock storage lock = userLocks[i];\\n                                    lock.releaseRate = 0;\\n                                }\\n                            }\\n                        }else{\\n                            referrer.noExtract = referrer.referrerRewardLimit - referrer.totalReferrerRaward;\\n                            for (uint256 i = 0; i < userLocks.length; i++) {\\n                                Lock storage lock = userLocks[i];\\n                                lock.releaseRate = 0;\\n                            }\\n                        }\\n                        referrer.teamRewardTime = block.timestamp;\\n                        statistics = (referrer.totalInvestment.sub(teamRewardThreshold)).div(teamRewardThresholdStep);\\n                        referrer.teamRewardRate = teamRewardThresholdStepRate.mul(statistics).div(86400);\\n                        referrer.teamRewardRate += teamRewardThresholdRate.div(86400);\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit EsgInvest(msg.sender, _amount, price);\\n        return true;\\n    }\\n\\n    function investByOwner(address investAddress, uint256 _amount) public onlyOwner returns (bool) {\\n        require(investEnabled == true, \\\"No invest allowed!\\\");\\n        require(_amount > 0, \\\"Invalid amount.\\\");\\n\\n        uint256 invest_days = 0;\\n        uint256 deposit = _amount.mul(price);\\n        if(deposit < 500 * 1e24){\\n            invest_days = invest_days1;\\n        }else if(deposit >= 500 * 1e24 && deposit < 2000 * 1e24){\\n            invest_days = invest_days2;\\n        }else if(deposit >= 2000 * 1e24 && deposit < 5000 * 1e24){\\n            invest_days = invest_days3;\\n        }else if(deposit >= 5000 * 1e24 && deposit < 10000 * 1e24){\\n            invest_days = invest_days4;\\n        }else if(deposit >= 10000 * 1e24){\\n            invest_days = invest_days5;\\n        }\\n\\n        uint256 nowTime = block.timestamp;\\n        Lock[] storage user_locks = locks[msg.sender];\\n        if(user_locks.length > 0){\\n            Investment storage user_investment = investments[msg.sender];\\n            uint256 userDeposit = user_investment.userTotalValue.mul(lockRates).div(100).add(user_investment.userTotalValue);\\n            uint256 userWithdraw = user_investment.withdraw;\\n            if(userDeposit == userWithdraw){\\n                user_investment.lastCollectionTime = nowTime;\\n            }\\n        }\\n\\n        locks[investAddress].push(\\n            Lock(\\n                _amount,\\n                price,\\n                deposit,\\n                nowTime,\\n                nowTime + (invest_days * 86400),\\n                invest_days,\\n                (deposit.mul(lockRates).div(100).add(deposit)).div(invest_days).div(86400)\\n            )\\n        );\\n\\n        Investment storage investment = investments[investAddress];\\n        if(investment.userTotalValue == 0){\\n            investment.lastCollectionTime = nowTime;\\n            total_user = total_user + 1;\\n        }\\n        investment.userTotalValue += deposit;\\n\\n        total_deposited = total_deposited + deposit;\\n        total_amount = total_amount + _amount;\\n\\n        Referrer storage userReferrer = referrers[msg.sender];\\n        if(userReferrer.referrals.length > 0){\\n            userReferrer.referrerRewardLimit = investment.userTotalValue.mul(lockRates).div(100).add(investment.userTotalValue);\\n            if(userReferrer.totalInvestment >= teamRewardThreshold){\\n                uint256 statistics = 0;\\n                if(userReferrer.teamRewardTime == 0){\\n                    userReferrer.teamRewardTime = block.timestamp;\\n                    statistics = (userReferrer.totalInvestment.sub(teamRewardThreshold)).div(teamRewardThresholdStep);\\n                    userReferrer.teamRewardRate = teamRewardThresholdStepRate.mul(statistics).div(86400);\\n                    userReferrer.teamRewardRate += teamRewardThresholdRate.div(86400);\\n                }\\n            }\\n        }\\n            \\n        User storage user = referrerlist[investAddress];\\n\\n        if(user.referrer_addr != address(0)){\\n            referrers[user.referrer_addr].totalInvestment += deposit;\\n            uint256 staticReward = deposit.mul(staticRewardRate).div(100);\\n            Referrer storage referrer = referrers[user.referrer_addr];\\n            Lock[] storage userLocks = locks[user.referrer_addr];\\n            if(referrer.totalReferrerRaward < referrer.referrerRewardLimit){\\n                if(referrer.totalReferrerRaward + staticReward < referrer.referrerRewardLimit){\\n                    referrer.noExtract += staticReward;\\n                    if(referrer.noExtract >= referrer.referrerRewardLimit){\\n                        for (uint256 i = 0; i < userLocks.length; i++) {\\n                            Lock storage lock = userLocks[i];\\n                            lock.releaseRate = 0;\\n                        }\\n                    }\\n                }else{\\n                    referrer.noExtract = referrer.referrerRewardLimit - referrer.totalReferrerRaward;\\n                    for (uint256 i = 0; i < userLocks.length; i++) {\\n                        Lock storage lock = userLocks[i];\\n                        lock.releaseRate = 0;\\n                    }\\n                }\\n            }\\n            \\n            if(referrer.totalInvestment >= teamRewardThreshold){\\n                uint256 statistics = 0;\\n                if(referrer.teamRewardTime == 0){\\n                    referrer.teamRewardTime = block.timestamp;\\n                    statistics = (referrer.totalInvestment.sub(teamRewardThreshold)).div(teamRewardThresholdStep);\\n                    referrer.teamRewardRate = teamRewardThresholdStepRate.mul(statistics).div(86400);\\n                    referrer.teamRewardRate += teamRewardThresholdRate.div(86400);\\n                }else{\\n                    uint256 team_reward = (block.timestamp.sub(referrer.teamRewardTime)).mul(referrer.teamRewardRate);\\n                    if(referrer.totalReferrerRaward < referrer.referrerRewardLimit){\\n                        if(referrer.totalReferrerRaward + team_reward < referrer.referrerRewardLimit){\\n                            referrer.noExtract += team_reward;\\n                            if(referrer.noExtract >= referrer.referrerRewardLimit){\\n                                for (uint256 i = 0; i < userLocks.length; i++) {\\n                                    Lock storage lock = userLocks[i];\\n                                    lock.releaseRate = 0;\\n                                }\\n                            }\\n                        }else{\\n                            referrer.noExtract = referrer.referrerRewardLimit - referrer.totalReferrerRaward;\\n                            for (uint256 i = 0; i < userLocks.length; i++) {\\n                                Lock storage lock = userLocks[i];\\n                                lock.releaseRate = 0;\\n                            }\\n                        }\\n                        referrer.teamRewardTime = block.timestamp;\\n                        statistics = (referrer.totalInvestment.sub(teamRewardThreshold)).div(teamRewardThresholdStep);\\n                        referrer.teamRewardRate = teamRewardThresholdStepRate.mul(statistics).div(86400);\\n                        referrer.teamRewardRate += teamRewardThresholdRate.div(86400);\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit EsgInvestByOwner(investAddress, _amount, price);\\n        return true;\\n    }\\n\\n    function claim() public returns (bool) {\\n        require(claimEnabled == true, \\\"No claim allowed!\\\");\\n        Lock[] storage userLocks = locks[msg.sender];\\n        require(userLocks.length > 0, \\\"No locked amount.\\\");\\n\\n        uint256 totalInterest = 0;\\n        Investment storage investment = investments[msg.sender];\\n        uint256 userDeposit = investment.userTotalValue.mul(lockRates).div(100).add(investment.userTotalValue);\\n        uint256 userWithdraw = investment.withdraw;\\n        require(userDeposit > userWithdraw, \\\"All investments have been fully withdrawn\\\");\\n\\n        for (uint256 i = 0; i < userLocks.length; i++) {\\n            Lock storage lock = userLocks[i];\\n            uint256 interest = (block.timestamp.sub(investment.lastCollectionTime)).mul(lock.releaseRate);\\n            if (interest > 0) {\\n                totalInterest += interest;\\n            }\\n        }\\n\\n        Referrer storage referrer_user = referrers[msg.sender];\\n        if(userDeposit - userWithdraw >= referralThreshold){\\n            if(referrer_user.totalInvestment > 0){\\n                if(referrer_user.totalReferrerRaward + referrer_user.noExtract <= referrer_user.referrerRewardLimit){\\n                    totalInterest += referrer_user.noExtract;\\n                    referrer_user.totalReferrerRaward += referrer_user.noExtract;\\n                    if(referrer_user.totalReferrerRaward > referrer_user.referrerRewardLimit){\\n                        referrer_user.totalReferrerRaward = referrer_user.referrerRewardLimit;\\n                    }\\n                    referrer_user.noExtract = 0;\\n                }else{\\n                    if(referrer_user.referrerRewardLimit > referrer_user.totalReferrerRaward){\\n                        totalInterest += referrer_user.referrerRewardLimit - referrer_user.totalReferrerRaward;\\n                    }\\n                    referrer_user.totalReferrerRaward = referrer_user.referrerRewardLimit;\\n                    referrer_user.noExtract = 0;\\n                }\\n                \\n                uint256 team_reward = (block.timestamp.sub(referrer_user.teamRewardTime)).mul(referrer_user.teamRewardRate);\\n                if(referrer_user.teamRewardTime > 0 && referrer_user.teamRewardRate > 0){\\n                    if(referrer_user.totalReferrerRaward + team_reward <= referrer_user.referrerRewardLimit){\\n                        totalInterest += team_reward;\\n                        referrer_user.totalReferrerRaward += team_reward;\\n                        if(referrer_user.totalReferrerRaward > referrer_user.referrerRewardLimit){\\n                            referrer_user.totalReferrerRaward = referrer_user.referrerRewardLimit;\\n                        }\\n                        referrer_user.teamRewardTime = block.timestamp;\\n                    }else{\\n                        if(referrer_user.referrerRewardLimit > referrer_user.totalReferrerRaward){\\n                            totalInterest += referrer_user.referrerRewardLimit - referrer_user.totalReferrerRaward;\\n                        }\\n                        referrer_user.totalReferrerRaward = referrer_user.referrerRewardLimit;\\n                        referrer_user.teamRewardTime = block.timestamp;\\n                    }\\n                }\\n            }\\n        }\\n        require(totalInterest > 0, \\\"No interest to claim.\\\");\\n        investment.lastCollectionTime = block.timestamp;\\n\\n        uint256 transfer_amount = 0;\\n        uint256 feeAmount = 0;\\n        uint256 total_withdraw = investment.withdraw + totalInterest;\\n        if(total_withdraw >= userDeposit){\\n            transfer_amount = (userDeposit.sub(userWithdraw)).div(price);\\n            investment.withdraw = userDeposit;\\n            feeAmount = transfer_amount.mul(fee).div(100);\\n            esg.transfer(feeWallet, feeAmount);   \\n            esg.transfer(msg.sender, transfer_amount.sub(feeAmount));\\n            for (uint256 i = 0; i < userLocks.length; i++) {\\n                Lock storage user_lock = userLocks[i];\\n                user_lock.releaseRate = 0;\\n            }\\n            if(referrer_user.totalInvestment > 0){\\n                referrer_user.teamRewardTime = 0;\\n                referrer_user.teamRewardRate = 0;\\n            }\\n        }else{\\n            transfer_amount = totalInterest.div(price);\\n            investment.withdraw += totalInterest;\\n            feeAmount = transfer_amount.mul(fee).div(100);\\n            esg.transfer(feeWallet, feeAmount);\\n            esg.transfer(msg.sender, transfer_amount.sub(feeAmount));\\n        }\\n        total_claim_amount += transfer_amount;\\n        total_extracted += transfer_amount.mul(price);\\n        \\n        User storage user = referrerlist[msg.sender];\\n        if (user.referrer_addr != address(0)) {\\n            Referrer storage referrer = referrers[user.referrer_addr];\\n            uint256 dynamic_reward = totalInterest.mul(dynamicRewardRate).div(100);\\n            Lock[] storage referrerLocks = locks[user.referrer_addr];\\n            if(referrer.totalReferrerRaward < referrer.referrerRewardLimit){\\n                if(referrer.totalReferrerRaward + dynamic_reward < referrer.referrerRewardLimit){\\n                    referrer.noExtract += dynamic_reward;\\n                    if(referrer.noExtract >= referrer.referrerRewardLimit){\\n                        for (uint256 i = 0; i < userLocks.length; i++) {\\n                            Lock storage lock = userLocks[i];\\n                            lock.releaseRate = 0;\\n                        }\\n                    }\\n                }else{\\n                    referrer.noExtract = referrer.referrerRewardLimit - referrer.totalReferrerRaward;\\n                    for (uint256 i = 0; i < referrerLocks.length; i++) {\\n                        Lock storage referrer_lock = referrerLocks[i];\\n                        referrer_lock.releaseRate = 0;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit EsgClaimed (msg.sender, transfer_amount, price); \\n        return true;\\n    }\\n\\n    function getClaimAmount(address _user) public view returns (uint256) {\\n        require(_user != address(0), \\\"_user cannot be 0x0.\\\");\\n        Lock[] storage userLocks = locks[_user];\\n        uint256 totalInterest = 0;\\n        Investment storage investment = investments[_user];\\n        uint256 userDeposit = investment.userTotalValue.mul(lockRates).div(100).add(investment.userTotalValue);\\n        uint256 userWithdraw = investment.withdraw;\\n        if(userWithdraw >= userDeposit){\\n            return 0;\\n        }\\n\\n        for (uint256 i = 0; i < userLocks.length; i++) {\\n            Lock storage lock = userLocks[i];\\n            uint256 interest = (block.timestamp.sub(investment.lastCollectionTime)).mul(lock.releaseRate);\\n            if (interest > 0) {\\n                totalInterest += interest;\\n            }\\n        }\\n\\n        Referrer storage referrer_user = referrers[_user];\\n        uint256 total_reward = referrer_user.totalReferrerRaward;\\n        if(userDeposit.sub(userWithdraw) >= referralThreshold){\\n            if(referrer_user.totalInvestment > 0){\\n                if(total_reward + referrer_user.noExtract <= referrer_user.referrerRewardLimit){\\n                    totalInterest += referrer_user.noExtract;\\n                    total_reward += referrer_user.noExtract;\\n                }else{\\n                    if(referrer_user.referrerRewardLimit > referrer_user.totalReferrerRaward){\\n                        totalInterest += referrer_user.referrerRewardLimit - referrer_user.totalReferrerRaward;\\n                        total_reward = referrer_user.referrerRewardLimit;\\n                    }\\n                }\\n                \\n                uint256 team_reward = (block.timestamp.sub(referrer_user.teamRewardTime)).mul(referrer_user.teamRewardRate);\\n                if(referrer_user.teamRewardTime > 0 && referrer_user.teamRewardRate > 0){\\n                    if(total_reward + team_reward <= referrer_user.referrerRewardLimit){\\n                        totalInterest += team_reward;\\n                    }else{\\n                        if(referrer_user.referrerRewardLimit > referrer_user.totalReferrerRaward){\\n                            totalInterest += referrer_user.referrerRewardLimit - referrer_user.totalReferrerRaward;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        uint256 total_withdraw = investment.withdraw + totalInterest;\\n        uint256 transfer_amount = 0;\\n        if(total_withdraw >= userDeposit){   \\n            transfer_amount = userDeposit.sub(userWithdraw);\\n        }else{\\n            transfer_amount = totalInterest;\\n        }\\n        return transfer_amount;\\n    }\\n\\n    function getNoExtract(address _user) public view returns (uint256) {\\n        require(_user != address(0), \\\"_user cannot be 0x0.\\\");\\n        uint256 totalInterest = 0;\\n        Investment storage investment = investments[_user];\\n        uint256 userDeposit = investment.userTotalValue.mul(lockRates).div(100).add(investment.userTotalValue);\\n        uint256 userWithdraw = investment.withdraw;\\n        if(userWithdraw >= userDeposit){\\n            return 0;\\n        }\\n\\n        Referrer storage referrer_user = referrers[_user];\\n        uint256 total_reward = referrer_user.totalReferrerRaward;\\n        if(userDeposit.sub(userWithdraw) >= referralThreshold){\\n            if(referrer_user.totalInvestment > 0){\\n                if(total_reward + referrer_user.noExtract <= referrer_user.referrerRewardLimit){\\n                    totalInterest += referrer_user.noExtract;\\n                    total_reward += referrer_user.noExtract;\\n                }else{\\n                    if(referrer_user.referrerRewardLimit > referrer_user.totalReferrerRaward){\\n                        totalInterest += referrer_user.referrerRewardLimit - referrer_user.totalReferrerRaward;\\n                        total_reward = referrer_user.referrerRewardLimit;\\n                    }\\n                }\\n                \\n                uint256 team_reward = (block.timestamp.sub(referrer_user.teamRewardTime)).mul(referrer_user.teamRewardRate);\\n                if(referrer_user.teamRewardTime > 0 && referrer_user.teamRewardRate > 0){\\n                    if(total_reward + team_reward <= referrer_user.referrerRewardLimit){\\n                        totalInterest += team_reward;\\n                    }else{\\n                        if(referrer_user.referrerRewardLimit > referrer_user.totalReferrerRaward){\\n                            totalInterest += referrer_user.referrerRewardLimit - referrer_user.totalReferrerRaward;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        uint256 total_withdraw = investment.withdraw + totalInterest;\\n        uint256 transfer_amount = 0;\\n        if(total_withdraw >= userDeposit){\\n            transfer_amount = userDeposit.sub(userWithdraw); \\n        }else{\\n            transfer_amount = totalInterest;\\n        }\\n        return transfer_amount;\\n    }\\n\\n    function changeLockInfo(address _user, uint256 _rate, uint256 i) public onlyOwner returns (bool) {\\n        require(_user != address(0), \\\"_user cannot be 0x0.\\\");\\n        Lock storage userLocks = locks[_user][i];\\n        userLocks.releaseRate = _rate;\\n\\n        emit EsgChangeLockInfo(_user, _rate, i);\\n        return true;\\n    }\\n\\n    function changeInvestmentInfo(address _user, uint256 _userTotalValue, uint256 _withdraw, uint256 _lastCollectionTime) public onlyOwner returns (bool) {\\n        require(_user != address(0), \\\"_user cannot be 0x0.\\\");\\n        Investment storage investment = investments[_user];\\n        investment.userTotalValue = _userTotalValue;\\n        investment.withdraw = _withdraw;\\n        investment.lastCollectionTime = _lastCollectionTime;\\n\\n        emit EsgChangeInvestmentInfo(_user, _userTotalValue, _withdraw, _lastCollectionTime);\\n        return true;\\n    }\\n\\n    function changeReferrerInfo(address _user, uint256 _totalInvestment, uint256 _referrerRewardLimit, uint256 _totalReferrerRaward, uint256 _teamRewardTime, uint256 _teamRewardRate, uint256 _noExtract) public onlyOwner returns (bool) {\\n        require(_user != address(0), \\\"_user cannot be 0x0.\\\");\\n        Referrer storage referrer = referrers[_user];\\n        referrer.totalInvestment = _totalInvestment;\\n        referrer.referrerRewardLimit = _referrerRewardLimit;\\n        referrer.totalReferrerRaward = _totalReferrerRaward;\\n        referrer.teamRewardTime = _teamRewardTime;\\n        referrer.teamRewardRate = _teamRewardRate;\\n        referrer.noExtract = _noExtract;\\n\\n        emit EsgChangeReferrerInfo(_user, _totalInvestment, _referrerRewardLimit, _totalReferrerRaward, _teamRewardTime, _teamRewardRate, _noExtract);\\n        return true;\\n    }\\n\\n    function getLockInfo(address _user) public view returns (\\n            uint256[] memory,\\n            uint256[] memory,\\n            uint256[] memory,\\n            uint256[] memory,\\n            uint256[] memory,\\n            uint256[] memory,\\n            uint256[] memory\\n        )\\n    {\\n        Lock[] storage userLocks = locks[_user];\\n        uint256 length = userLocks.length;\\n\\n        uint256[] memory amounts = new uint256[](length);\\n        uint256[] memory esgprices = new uint256[](length);\\n        uint256[] memory values = new uint256[](length);\\n        uint256[] memory starts = new uint256[](length);\\n        uint256[] memory ends = new uint256[](length);\\n        uint256[] memory investdays = new uint256[](length);\\n        uint256[] memory rates = new uint256[](length);\\n\\n        for (uint256 i = 0; i < length; i++) {\\n            Lock storage lock = userLocks[i];\\n            amounts[i] = lock.amount;\\n            esgprices[i] = lock.esgPrice;\\n            values[i] = lock.value;\\n            starts[i] = lock.start;\\n            ends[i] = lock.end;\\n            investdays[i] = lock.investDays;\\n            rates[i] = lock.releaseRate;\\n        }\\n\\n        return (amounts, esgprices, values, starts, ends, investdays, rates);\\n    }\\n\\n    function transferOwnership(address newOwner) onlyOwner public {\\n        if (newOwner != address(0)) {\\n        owner = newOwner;\\n      }\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\\n// Subject to the MIT license.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction underflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n\\n    /**\\n   * @dev gives square root of given x.\\n   */\\n  function sqrt(uint256 x) internal pure returns(uint256 y) {\\n        uint256 z = ((add(x, 1)) / 2);\\n        y = x;\\n        while (z < y) {\\n            y = z;\\n            z = ((add((x / z), z)) / 2);\\n        }\\n  }\\n\\n  /**\\n   * @dev gives square. multiplies x by x\\n   */\\n  function sq(uint256 x) internal pure returns(uint256) {\\n       return (mul(x, x));\\n  }\\n\\n  /**\\n   * @dev x to the power of y\\n   */\\n  function pwr(uint256 x, uint256 y) internal pure returns(uint256) {\\n    if (x == 0)\\n      return (0);\\n    else if (y == 0)\\n      return (1);\\n    else {\\n      uint256 z = x;\\n      for (uint256 i = 1; i < y; i++)\\n        z = mul(z, x);\\n      return (z);\\n    }\\n  }\\n}\"\r\n    },\r\n    \"/contracts/EIP20Interface.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n/**\\n * @title ERC 20 Token Standard Interface\\n *  https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface EIP20Interface {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n      * @notice Get the total number of tokens in circulation\\n      * @return The supply of tokens\\n      */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the balance of the specified address\\n     * @param owner The address from which the balance will be retrieved\\n     * @return The balance\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      * @return Whether or not the transfer succeeded\\n      */\\n    function transfer(address dst, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `src` to `dst`\\n      * @param src The address of the source account\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      * @return Whether or not the transfer succeeded\\n      */\\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Approve `spender` to transfer up to `amount` from `src`\\n      * @dev This will overwrite the approval amount for `spender`\\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n      * @param spender The address of the account which may transfer tokens\\n      * @param amount The number of tokens that are approved (-1 means infinite)\\n      * @return Whether or not the approval succeeded\\n      */\\n    function approve(address spender, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Get the current allowance from `owner` for `spender`\\n      * @param owner The address of the account which owns the tokens to be spent\\n      * @param spender The address of the account which may transfer tokens\\n      * @return The number of tokens allowed to be spent (-1 means infinite)\\n      */\\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 300\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"esgAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeWalletAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_userTotalValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_withdraw\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_lastCollectionTime\",\"type\":\"uint256\"}],\"name\":\"EsgChangeInvestmentInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"EsgChangeLockInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalInvestment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_referrerRewardLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalReferrerRaward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_teamRewardTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_teamRewardRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_noExtract\",\"type\":\"uint256\"}],\"name\":\"EsgChangeReferrerInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"EsgClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"EsgInvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"EsgInvestByOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inviteeAddress\",\"type\":\"address\"}],\"name\":\"SetInvitee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referrerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inviteeAddress\",\"type\":\"address\"}],\"name\":\"SetInviteeByOwner\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_userTotalValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastCollectionTime\",\"type\":\"uint256\"}],\"name\":\"changeInvestmentInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"changeLockInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_totalInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_referrerRewardLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalReferrerRaward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_teamRewardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_teamRewardRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_noExtract\",\"type\":\"uint256\"}],\"name\":\"changeReferrerInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dynamicRewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"esg\",\"outputs\":[{\"internalType\":\"contract EIP20Interface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getClaimAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrerAddress\",\"type\":\"address\"}],\"name\":\"getInviteelist\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getLockInfo\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getNoExtract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"inviteeAddress\",\"type\":\"address\"}],\"name\":\"getReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"invest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"investAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"investByOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"invest_days1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"invest_days2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"invest_days3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"invest_days4\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"invest_days5\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"investments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"userTotalValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastCollectionTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockRates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"locks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"esgPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releaseRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referralThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrerlist\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer_addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerRewardLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReferrerRaward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamRewardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamRewardRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"noExtract\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_claimEnabled\",\"type\":\"bool\"}],\"name\":\"setClaimEnabled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dynamicRewardRate\",\"type\":\"uint256\"}],\"name\":\"setDynamicRewardRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"days1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"days2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"days3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"days4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"days5\",\"type\":\"uint256\"}],\"name\":\"setInvestDays\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_investEnabled\",\"type\":\"bool\"}],\"name\":\"setInvestEnabled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"inviteeAddress\",\"type\":\"address\"}],\"name\":\"setInvitee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inviteeAddress\",\"type\":\"address\"}],\"name\":\"setInviteeByOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockRates\",\"type\":\"uint256\"}],\"name\":\"setLockRates\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_referralThreshold\",\"type\":\"uint256\"}],\"name\":\"setReferralThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_staticRewardRate\",\"type\":\"uint256\"}],\"name\":\"setStaticRewardRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_teamRewardThreshold\",\"type\":\"uint256\"}],\"name\":\"setTeamRewardThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_teamRewardThresholdRate\",\"type\":\"uint256\"}],\"name\":\"setTeamRewardThresholdRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_teamRewardThresholdStep\",\"type\":\"uint256\"}],\"name\":\"setTeamRewardThresholdStep\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_teamRewardThresholdStepRate\",\"type\":\"uint256\"}],\"name\":\"setTeamRewardThresholdStepRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"staticRewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamRewardThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamRewardThresholdRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamRewardThresholdStep\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamRewardThresholdStepRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_claim_amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_deposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_extracted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_user\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "EsgSHIPV3", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "1", "Runs": "300", "ConstructorArguments": "00000000000000000000000020cd2e7ec8f5d8b337fe46a4f565ccef1561b9a9000000000000000000000000aac08d7cf5e7d9b0418e841d1e68cb5a2904a08c", "EVMVersion": "istanbul", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}