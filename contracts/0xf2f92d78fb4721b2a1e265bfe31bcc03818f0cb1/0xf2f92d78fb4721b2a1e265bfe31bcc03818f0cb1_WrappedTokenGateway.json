{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/WrappedTokenGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.19;\\n\\nimport {IWrappedToken} from \\\"./interfaces/IWrappedToken.sol\\\";\\nimport {IMaxApyVault} from \\\"./interfaces/IMaxApyVault.sol\\\";\\n\\nimport {SafeTransferLib} from \\\"solady/utils/SafeTransferLib.sol\\\";\\n\\n/*KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK\\nKKKKK0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO0KKKKKKK\\nKK0dcclllllllllllllllllllllllllllllccccccccccccccccccclx0KKK\\nKOc,dKNWWWWWWWWWWWWWWWWWWWWWWWWWWWWNNNNNNNNNNNNNNNNNXOl';xKK\\nKd'oWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMX; ,kK\\nKo'xMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNc .dK\\nKo'dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNc .oK\\nKd'oWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNc .oK\\nKO:,xXWWWWWWWWWWWWWWWWWWWWMMMMMMMMMMMMMMMMMMMMMMMMMMMMNc .oK\\nKKOl,',;;,,,,,,;;,,,,,,,;;cxXMMMMMMMMMMMMMMMMMMMMMMMMMNc .oK\\nKKKKOoc;;;;;;;;;;;;;;;;;;;,.cXMMMMMMMMMMMMMMMMMMMMMMMMNc .oK\\nKKKKKKKKKKKKKKKKKKKK00O00K0:,0MMMMMMMMMMMMMMMMMMMMMMMMNc .oK\\nKKKKKKKKKKKKKKKKKKklcccccld;,0MMMMMMMMMMMMMMMMMMMMMMMMNc .oK\\nKKKKKKKKKKKKKKKKkl;ckXNXOc. '0MMMMMMMMMMMMMMMMMMMMMMMMNc .oK\\nKKKKKKKKKKKKKKkc;l0WMMMMMX; .oKNMMMMMMMMMMMMMMMMMMMMMMNc .oK\\nKKKKKKKKKKKKkc;l0WMMMMMMMWd.  .,lddddddxONMMMMMMMMMMMMNc .oK\\nKKKKKKKKKKkc;l0WMMMMMMMMMMWOl::;'.  .....:0WMMMMMMMMMMNc .oK\\nKKKKKKK0xc;o0WMMMMMMMMMMMMMMMMMWNk'.;xkko'lNMMMMMMMMMMNc .oK\\nKKKKK0x:;oKWMMMMMMMMMMMMMMMMMMMMMWd..lKKk,lNMMMMMMMMMMNc .oK\\nKKK0x:;oKWMMMMMMMMMMMMMMMMMMMMMMWO,  c0Kk,lNMMMMMMMMMMNc .oK\\nKKx:;dKWMMMMMMMMMMMMMMMMMMMMMWN0c.  ;kKKk,lNMMMMMMMMMMNc .oK\\nKx,:KWMMMMMMMMMMMMMMMMMMMMMW0c,.  'oOKKKk,lNMMMMMMMMMMNc .oK\\nKo'xMMMMMMMMMMMMMMMMMMMMMW0c.   'oOKKKKKk,lNMMMMMMMMMMNc .oK\\nKo'xMMMMMMMMMMMMMMMMMMMW0c.  ':oOKKKKKKKk,lNMMMMMMMMMMNc .oK\\nKo'xMMMMMMMMMMMMMMMMMW0l.  'oOKKKKKKKKKKk,cNMMMMMMMMMMNc .oK\\nKo'xMMMMMMMMMMMMMMMW0l.  'oOKKKKKKKKKKKKk,lNMMMMMMMMMMNc .oK\\nKo'dWMMMMMMMMMMMMW0l.  'oOKKKKKKKKKKKKKKk,cNMMMMMMMMMMX: .oK\\nKO:,xXNWWWWWWWWNOl.  'oOKKKKKKKKKKKKKKKK0c,xNMMMMMMMMNd. .dK\\nKKOl''',,,,,,,,..  'oOKKKKKKKKKKKKKKKKKKKOl,,ccccccc:'  .c0K\\nKKKKOoc:;;;;;;;;:ldOKKKKKKKKKKKKKKKKKKKKKKKkl;'......',cx0KK\\nKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK0OOOOOOO0KKK*/\\n\\n/// @notice Helper contract to interact with a MaxApy Vault utilizing the chain's native token the protocol\\n/// has been deployed to\\n/// @author MaxApy\\ncontract WrappedTokenGateway {\\n    using SafeTransferLib for address;\\n\\n    ////////////////////////////////////////////////////////////////\\n    ///                       CONSTANTS                          ///\\n    ////////////////////////////////////////////////////////////////\\n\\n    /// @notice The chain's wrapped native token\\n    IWrappedToken public immutable wrappedToken;\\n    /// @notice The MaxApy vault linked to this Gateway contract\\n    IMaxApyVault public immutable vault;\\n\\n    ////////////////////////////////////////////////////////////////\\n    ///                        ERRORS                            ///\\n    ////////////////////////////////////////////////////////////////\\n    error InvalidZeroValue();\\n    error FailedNativeTransfer();\\n    error ReceiveNotAllowed();\\n\\n    ////////////////////////////////////////////////////////////////\\n    ///                        EVENTS                            ///\\n    ////////////////////////////////////////////////////////////////\\n\\n    /// @notice Emitted on native vault deposits\\n    event DepositNative(address indexed recipient, uint256 shares, uint256 amount);\\n\\n    /// @notice Emitted on native vault withdrawals\\n    event WithdrawNative(address indexed recipient, uint256 shares, uint256 amount);\\n\\n    /// @dev `keccak256(bytes(\\\"DepositNative(address,uint256,uint256)\\\"))`.\\n    uint256 internal constant _DEPOSIT_NATIVE_EVENT_SIGNATURE =\\n        0x6bb902f8baf2580ae3dae24e58f4b874ecca85152076af921bfd172dce1c7e28;\\n\\n    /// @dev `keccak256(bytes(\\\"WithdrawNative(address,uint256,uint256)\\\"))`.\\n    uint256 internal constant _WITHDRAW_NATIVE_EVENT_SIGNATURE =\\n        0x5cb35f4e7dbc40dd34f0d58cec4f5548fc47638cb46d7964e4f07c48e97e4c7d;\\n\\n    ////////////////////////////////////////////////////////////////\\n    ///                      CONSTRUCTOR                         ///\\n    ////////////////////////////////////////////////////////////////\\n\\n    /// @notice Create the WrappedToken Gateway\\n    /// @param _wrappedToken The wrapped token of the chain the contract will be deployed to\\n    /// @param _vault The MaxApy vault linked to this Gateway contract\\n    constructor(IWrappedToken _wrappedToken, IMaxApyVault _vault) {\\n        wrappedToken = _wrappedToken;\\n        vault = _vault;\\n        address(_wrappedToken).safeApprove(address(_vault), type(uint256).max);\\n    }\\n\\n    ////////////////////////////////////////////////////////////////\\n    ///                 GATEWAY CORE LOGIC                       ///\\n    ////////////////////////////////////////////////////////////////\\n\\n    /// @notice  Deposits `msg.value` of `_wrappedToken`, issuing shares to `recipient`\\n    /// @param recipient The address to issue the shares from MaxApy's Vault to\\n    function depositNative(address recipient) external payable returns (uint256) {\\n        // Cache `wrappedToken` and `vault` due to assembly's immutable access restrictions\\n        address cachedWrappedToken = address(wrappedToken);\\n        address cachedVault = address(vault);\\n\\n        assembly (\\\"memory-safe\\\") {\\n            // Check if `msg.value` is 0\\n            if iszero(callvalue()) {\\n                // Throw the `InvalidZeroValue()` error\\n                mstore(0x00, 0xef7a63d0)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Cache the free memory pointer\\n            let m := mload(0x40)\\n\\n            // Store Wrapped Token's `deposit()` function selector:\\n            // `bytes4(keccak256(\\\"deposit()\\\"))`\\n            mstore(0x00, 0xd0e30db0)\\n\\n            // Deposit native token in exchange for wrapped native token\\n            // Note: using some wrapped tokens' fallback function for deposit allows saving the previous\\n            // selector loading into memory to call wrappedToken's `deposit()`.\\n            // This is avoided due to some chain's wrapped native versions not allowing such behaviour\\n            if iszero(\\n                call(\\n                    gas(), // Remaining amount of gas\\n                    cachedWrappedToken, // Address of `wrappedToken`\\n                    callvalue(), // `msg.value`\\n                    0x1c, // byte offset in memory where calldata starts\\n                    0x24, // size of the calldata to copy\\n                    0x00, // byte offset in memory to store the return data\\n                    0x00 // size of the return data\\n                )\\n            ) {\\n                // Throw the `WrappedTokenDepositFailed()` error\\n                mstore(0x00, 0x22cd2378)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Store MaxApy vault's `deposit()` function selector:\\n            // `bytes4(keccak256(\\\"deposit(uint256,address)\\\"))`\\n            mstore(0x00, 0x6e553f65)\\n            mstore(0x20, callvalue()) // Append the `amount` argument\\n            mstore(0x40, recipient) // Append the `recipient` argument\\n\\n            // Deposit into MaxApy vault\\n            if iszero(\\n                call(\\n                    gas(), // Remaining amount of gas\\n                    cachedVault, // Address of `vault`\\n                    0, // `msg.value`\\n                    0x1c, // byte offset in memory where calldata starts\\n                    0x44, // size of the calldata to copy\\n                    0x00, // byte offset in memory to store the return data\\n                    0x20 // size of the return data\\n                )\\n            ) {\\n                // If call failed, throw the error thrown in the previous `call`\\n                revert(0x00, 0x04)\\n            }\\n\\n            // Emit the `DepositNative` event\\n            mstore(0x20, callvalue())\\n            log2(0x00, 0x40, _DEPOSIT_NATIVE_EVENT_SIGNATURE, recipient)\\n\\n            mstore(0x40, m) // Restore the free memory pointer\\n\\n            return(0x00, 0x20) // Return `shares` value stored in 0x00 from previous from call's\\n        }\\n    }\\n\\n    /// @notice Withdraws the calling account's tokens from MaxApy's Vault, redeeming\\n    /// amount `shares` for the corresponding amount of tokens, which will be transferred to\\n    /// `recipient` in the form of the chain's native token\\n    /// @param shares How many shares to try and redeem for tokens\\n    /// @param recipient The address to issue the shares from MaxApy's Vault to\\n    /// @param maxLoss The maximum acceptable loss to sustain on withdrawal. Up to loss specified amount of shares may be\\n    /// burnt to cover losses on withdrawal\\n    function withdrawNative(uint256 shares, address recipient, uint256 maxLoss) external returns (uint256) {\\n        // Cache `wrappedToken` and `vault` due to assembly's immutable access restrictions\\n        address cachedWrappedToken = address(wrappedToken);\\n        address cachedVault = address(vault);\\n\\n        assembly (\\\"memory-safe\\\") {\\n            // Check if `shares` passed by user is `type(uint256).max`\\n            if eq(shares, not(0)) {\\n                // Store `vault`'s `balanceOf()` function selector:\\n                // `bytes4(keccak256(\\\"balanceOf(address)\\\"))`\\n                mstore(0x00, 0x70a08231)\\n                mstore(0x20, caller()) // append the `owner` argument as `msg.sender`\\n\\n                // query `vault`'s `msg.sender` `balanceOf()`\\n                if iszero(\\n                    staticcall(\\n                        gas(), // Remaining amount of gas\\n                        cachedVault, // Address of `vault`\\n                        0x1c, // byte offset in memory where calldata starts\\n                        0x24, // size of the calldata to copy\\n                        0x00, // byte offset in memory to store the return data\\n                        0x20 // size of the return data\\n                    )\\n                ) {\\n                    // Revert if balance query fails\\n                    revert(0x00, 0x04)\\n                }\\n\\n                // Store `msg.sender`'s balance returned by staticcall into `shares`\\n                shares := mload(0x00)\\n            }\\n        }\\n\\n        // Transfer caller shares\\n        address(vault).safeTransferFrom(msg.sender, address(this), shares);\\n\\n        uint256 amountWithdrawn;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            // Cache the free memory pointer\\n            let m := mload(0x40)\\n\\n            // Store `vault`'s `withdraw()` function selector:\\n            // `bytes4(keccak256(\\\"withdraw(address)\\\"))`\\n            mstore(0x00, 0xe63697c8)\\n            mstore(0x20, shares) // append the `shares` argument\\n            mstore(0x40, address()) // append the `address(this)` argument\\n            mstore(0x60, maxLoss) // append the `maxLoss` argument\\n\\n            // Withdraw from MaxApy vault\\n            if iszero(\\n                call(\\n                    gas(), // Remaining amount of gas\\n                    cachedVault, // Address of `vault`\\n                    0, // `msg.value`\\n                    0x1c, // byte offset in memory where calldata starts\\n                    0x64, // size of the calldata to copy\\n                    0x00, // byte offset in memory to store the return data\\n                    0x20 // size of the return data\\n                )\\n            ) {\\n                // If call failed, throw the error thrown in the previous `call`\\n                revert(0x00, 0x04)\\n            }\\n\\n            // Store `amountWithdrawn` returned by the previous call to `withdraw()`\\n            amountWithdrawn := mload(0x00)\\n\\n            // Store `wrappedToken`'s `withdraw()` function selector:\\n            // `bytes4(keccak256(\\\"withdraw(uint256)\\\"))`\\n            mstore(0x00, 0x2e1a7d4d)\\n            mstore(0x20, amountWithdrawn) // append the `amountWithdrawn` argument\\n\\n            // Withdraw from wrapped token\\n            if iszero(\\n                call(\\n                    gas(), // Remaining amount of gas\\n                    cachedWrappedToken, // Address of `vault`\\n                    0, // `msg.value`\\n                    0x1c, // byte offset in memory where calldata starts\\n                    0x24, // size of the calldata to copy\\n                    0x00, // byte offset in memory to store the return data\\n                    0x20 // size of the return data\\n                )\\n            ) {\\n                // If call failed, throw the error thrown in the previous `call`\\n                revert(0x00, 0x04)\\n            }\\n\\n            // Transfer native token back to user\\n            if iszero(call(gas(), recipient, amountWithdrawn, 0x00, 0x00, 0x00, 0x00)) {\\n                // If call failed, throw the `FailedNativeTransfer()` error\\n                mstore(0x00, 0x3c3f4130)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Emit the `WithdrawNative` event\\n            mstore(0x00, shares)\\n            mstore(0x20, amountWithdrawn)\\n            log2(0x00, 0x40, _WITHDRAW_NATIVE_EVENT_SIGNATURE, recipient)\\n\\n            mstore(0x60, 0) // Restore the zero slot\\n            mstore(0x40, m) // Restore the free memory pointer\\n\\n            return(0x20, 0x20) // Return `amountWithdrawn` value stored in 0x00 from previous from call's\\n        }\\n    }\\n\\n    ////////////////////////////////////////////////////////////////\\n    ///                 RECEIVE()  function                      ///\\n    ////////////////////////////////////////////////////////////////\\n\\n    /// @notice Receive function to accept native transfers\\n    /// @dev Note only the chain's wrapped token will be able to perform native token transfers\\n    /// to this contract\\n    receive() external payable {\\n        // Cache `wrappedToken` due to assembly immutable access restrictions\\n        address cachedWrappedToken = address(wrappedToken);\\n\\n        assembly {\\n            // Check if caller is not the `wrappedToken`\\n            if iszero(eq(caller(), cachedWrappedToken)) {\\n                // Throw the `ReceiveNotAllowed()` error\\n                mstore(0x00, 0xcb263c3f)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IWrappedToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.19;\\n\\ninterface IWrappedToken {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMaxApyVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.19;\\n\\nimport {StrategyData} from \\\"../helpers/VaultTypes.sol\\\";\\n\\n/**\\n * @notice MaxApyVault contains the main interface for MaxApy Vaults\\n */\\ninterface IMaxApyVault {\\n    /// User-facing vault functions\\n    function deposit(uint256 amount, address recipient) external returns (uint256);\\n\\n    function withdraw(uint256 shares, address recipient, uint256 maxLoss) external returns (uint256);\\n\\n    function report(uint128 gain, uint128 loss, uint128 debtPayment) external returns (uint256);\\n\\n    /// ERC20 Token functions\\n    function name() external returns (string memory);\\n\\n    function symbol() external returns (string memory);\\n\\n    function decimals() external returns (uint8);\\n\\n    function underlyingAsset() external view returns (address);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address user) external view returns (uint256);\\n\\n    /// Ownership\\n    function transferOwnership(address newOwner) external payable;\\n\\n    function renounceOwnership() external payable;\\n\\n    function requestOwnershipHandover() external payable;\\n\\n    function cancelOwnershipHandover() external payable;\\n\\n    function completeOwnershipHandover(address pendingOwner) external payable;\\n\\n    /// View ownership\\n    function ownershipHandoverExpiresAt(address pendingOwner) external view returns (uint256);\\n\\n    function ownershipHandoverValidFor() external view returns (uint64);\\n\\n    function owner() external view returns (address result);\\n\\n    /// Roles\\n    function grantRoles(address user, uint256 roles) external payable;\\n\\n    function revokeRoles(address user, uint256 roles) external payable;\\n\\n    function renounceRoles(uint256 roles) external payable;\\n\\n    /// View roles\\n    function ADMIN_ROLE() external returns (uint256);\\n\\n    function EMERGENCY_ADMIN_ROLE() external returns (uint256);\\n\\n    function KEEPER_ROLE() external returns (uint256);\\n\\n    function STRATEGY_ROLE() external returns (uint256);\\n\\n    function hasAnyRole(address user, uint256 roles) external view returns (bool result);\\n\\n    function hasAllRoles(address user, uint256 roles) external view returns (bool result);\\n\\n    function rolesOf(address user) external view returns (uint256 roles);\\n\\n    function rolesFromOrdinals(uint8[] memory ordinals) external pure returns (uint256 roles);\\n\\n    function ordinalsFromRoles(uint256 roles) external pure returns (uint8[] memory ordinals);\\n\\n    /// Vault configuration\\n    function debtRatio() external returns (uint256);\\n\\n    function totalDebt() external returns (uint256);\\n\\n    function totalIdle() external returns (uint256);\\n\\n    function strategies(address strategy) external returns (StrategyData memory);\\n\\n    function withdrawalQueue(uint256 index) external returns (address);\\n\\n    function emergencyShutdown() external returns (bool);\\n\\n    /// Vault management\\n    function setEmergencyShutdown(bool _emergencyShutdown) external;\\n\\n    function addStrategy(\\n        address newStrategy,\\n        uint256 strategyDebtRatio,\\n        uint256 strategyMaxDebtPerHarvest,\\n        uint256 strategyMinDebtPerHarvest,\\n        uint256 strategyPerformanceFee\\n    ) external;\\n\\n    function revokeStrategy(address strategy) external;\\n\\n    function removeStrategy(address strategy) external;\\n\\n    function updateStrategyData(\\n        address strategy,\\n        uint256 newDebtRatio,\\n        uint256 newMaxDebtPerHarvest,\\n        uint256 newMinDebtPerHarvest,\\n        uint256 newPerformanceFee\\n    ) external;\\n\\n    function setWithdrawalQueue(address[20] calldata queue) external;\\n\\n    function setPerformanceFee(uint256 _performanceFee) external;\\n\\n    function setManagementFee(uint256 _managementFee) external;\\n\\n    function setLockedProfitDegradation(uint256 _lockedProfitDegradation) external;\\n\\n    function setDepositLimit(uint256 _depositLimit) external;\\n\\n    function setTreasury(address _treasury) external;\\n\\n    /// Vault view functions\\n    function performanceFee() external returns (uint256);\\n\\n    function managementFee() external returns (uint256);\\n\\n    function lockedProfitDegradation() external view returns (uint256);\\n\\n    function depositLimit() external returns (uint256);\\n\\n    function MAXIMUM_STRATEGIES() external returns (uint256);\\n\\n    function DEGRADATION_COEFFICIENT() external view returns (uint256);\\n\\n    function shareValue(uint256 shares) external view returns (uint256);\\n\\n    function sharesForAmount(uint256 amount) external view returns (uint256 shares);\\n\\n    function debtOutstanding(address strategy) external view returns (uint256);\\n\\n    function totalAssets() external view returns (uint256);\\n\\n    function lastReport() external view returns (uint256);\\n\\n    function lockedProfit() external view returns (uint256);\\n\\n    function treasury() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH\\n    /// that disallows any storage writes.\\n    uint256 internal constant _GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    /// Multiply by a small constant (e.g. 2), if needed.\\n    uint256 internal constant _GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    /// The `gasStipend` can be set to a low enough value to prevent\\n    /// storage writes or gas griefing.\\n    ///\\n    /// If sending via the normal procedure fails, force sends the ETH by\\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n    ///\\n    /// Reverts if the current contract has insufficient balance.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If insufficient balance, revert.\\n            if lt(selfbalance(), amount) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(gasStipend, to, amount, 0, 0, 0, 0)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                // We can directly use `SELFDESTRUCT` in the contract creation.\\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    // For better gas estimation.\\n                    if iszero(gt(gas(), 1000000)) { revert(0, 0) }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend\\n    /// equal to `_GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default\\n    /// for 99% of cases and can be overriden with the three-argument version of this\\n    /// function if necessary.\\n    ///\\n    /// If sending via the normal procedure fails, force sends the ETH by\\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n    ///\\n    /// Reverts if the current contract has insufficient balance.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        // Manually inlined because the compiler doesn't inline functions with branches.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If insufficient balance, revert.\\n            if lt(selfbalance(), amount) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(_GAS_STIPEND_NO_GRIEF, to, amount, 0, 0, 0, 0)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                // We can directly use `SELFDESTRUCT` in the contract creation.\\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    // For better gas estimation.\\n                    if iszero(gt(gas(), 1000000)) { revert(0, 0) }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    /// The `gasStipend` can be set to a low enough value to prevent\\n    /// storage writes or gas griefing.\\n    ///\\n    /// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.\\n    ///\\n    /// Note: Does NOT revert upon failure.\\n    /// Returns whether the transfer of ETH is successful instead.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and check if it succeeded or not.\\n            success := call(gasStipend, to, amount, 0, 0, 0, 0)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            // Store the function selector of `transferFrom(address,address,uint256)`.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            // Store the function selector of `balanceOf(address)`.\\n            mstore(0x0c, 0x70a08231000000000000000000000000)\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Store the function selector of `transferFrom(address,address,uint256)`.\\n            mstore(0x00, 0x23b872dd)\\n            // The `amount` argument is already written to the memory word at 0x6c.\\n            amount := mload(0x60)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            // Store the function selector of `transfer(address,uint256)`.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x14, to) // Store the `to` argument.\\n            // The `amount` argument is already written to the memory word at 0x34.\\n            amount := mload(0x34)\\n            // Store the function selector of `transfer(address,uint256)`.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            // Store the function selector of `approve(address,uint256)`.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `ApproveFailed()`.\\n                mstore(0x00, 0x3e3f8f73)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            // Store the function selector of `balanceOf(address)`.\\n            mstore(0x00, 0x70a08231000000000000000000000000)\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/helpers/VaultTypes.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.19;\\n\\n/// @notice Stores all data from a single strategy\\n/// @dev Packed in two slots\\nstruct StrategyData {\\n    /// Slot 0\\n    /// @notice Maximum percentage available to be lent to strategies(in BPS)\\n    /// @dev in BPS. uint16 is enough to cover the max BPS value of 10_000\\n    uint16 strategyDebtRatio;\\n    /// @notice The performance fee\\n    /// @dev in BPS. uint16 is enough to cover the max BPS value of 10_000\\n    uint16 strategyPerformanceFee;\\n    /// @notice Timestamp when the strategy was added.\\n    /// @dev Overflowing July 21, 2554\\n    uint48 strategyActivation;\\n    /// @notice block.timestamp of the last time a report occured\\n    /// @dev Overflowing July 21, 2554\\n    uint48 strategyLastReport;\\n    /// @notice Upper limit on the increase of debt since last harvest\\n    /// @dev max debt per harvest to be set to a maximum value of 4,722,366,482,869,645,213,695\\n    uint128 strategyMaxDebtPerHarvest;\\n    /// Slot 1\\n    /// @notice Lower limit on the increase of debt since last harvest\\n    /// @dev min debt per harvest to be set to a maximum value of 16,777,215\\n    uint128 strategyMinDebtPerHarvest;\\n    /// @notice Total returns that Strategy has realized for Vault\\n    /// @dev max strategy total gain of 79,228,162,514,264,337,593,543,950,335\\n    uint128 strategyTotalGain;\\n    /// Slot 2\\n    /// @notice Total outstanding debt that Strategy has\\n    /// @dev max total debt of 79,228,162,514,264,337,593,543,950,335\\n    uint128 strategyTotalDebt;\\n    /// @notice Total losses that Strategy has realized for Vault\\n    /// @dev max strategy total loss of 79,228,162,514,264,337,593,543,950,335\\n    uint128 strategyTotalLoss;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"solady/=lib/solady/src/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IWrappedToken\",\"name\":\"_wrappedToken\",\"type\":\"address\"},{\"internalType\":\"contract IMaxApyVault\",\"name\":\"_vault\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"FailedNativeTransfer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidZeroValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReceiveNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositNative\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawNative\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"depositNative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract IMaxApyVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxLoss\",\"type\":\"uint256\"}],\"name\":\"withdrawNative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrappedToken\",\"outputs\":[{\"internalType\":\"contract IWrappedToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "WrappedTokenGateway", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000005da197c9bc9cfc36cd35c5f49954eae7527604c3", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}