{"SourceCode": "pragma solidity ^0.4.19;\r\n\r\ncontract Token {\r\n    bytes32 public standard;\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint256 public totalSupply;\r\n    uint8 public decimals;\r\n    bool public allowTransactions;\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n}\r\n\r\ncontract EthermiumAffiliates {\r\n    mapping(address => address[]) public referrals; // mapping of affiliate address to referral addresses\r\n    mapping(address => address) public affiliates; // mapping of referrals addresses to affiliate addresses\r\n    mapping(address => bool) public admins; // mapping of admin accounts\r\n    string[] public affiliateList;\r\n    address public owner;\r\n\r\n    function setOwner(address newOwner);\r\n    function setAdmin(address admin, bool isAdmin) public;\r\n    function assignReferral (address affiliate, address referral) public;\r\n\r\n    function getAffiliateCount() returns (uint);\r\n    function getAffiliate(address refferal) public returns (address);\r\n    function getReferrals(address affiliate) public returns (address[]);\r\n}\r\n\r\ncontract EthermiumTokenList {\r\n    function isTokenInList(address tokenAddress) public constant returns (bool);\r\n}\r\n\r\n\r\ncontract Exchange {\r\n    function assert(bool assertion) {\r\n        if (!assertion) throw;\r\n    }\r\n    function safeMul(uint a, uint b) returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n    address public owner;\r\n    mapping (address => uint256) public invalidOrder;\r\n\r\n    event SetOwner(address indexed previousOwner, address indexed newOwner);\r\n    modifier onlyOwner {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n    function setOwner(address newOwner) onlyOwner {\r\n        SetOwner(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n    function getOwner() returns (address out) {\r\n        return owner;\r\n    }\r\n    function invalidateOrdersBefore(address user, uint256 nonce) onlyAdmin {\r\n        if (nonce < invalidOrder[user]) throw;\r\n        invalidOrder[user] = nonce;\r\n    }\r\n\r\n    mapping (address => mapping (address => uint256)) public tokens; //mapping of token addresses to mapping of account balances\r\n\r\n    mapping (address => bool) public admins;\r\n    mapping (address => uint256) public lastActiveTransaction;\r\n    mapping (bytes32 => uint256) public orderFills;\r\n    address public feeAccount;\r\n    uint256 public feeAffiliate; // percentage times (1 ether)\r\n    uint256 public inactivityReleasePeriod;\r\n    mapping (bytes32 => bool) public traded;\r\n    mapping (bytes32 => bool) public withdrawn;\r\n    uint256 public makerFee; // fraction * 1 ether\r\n    uint256 public takerFee; // fraction * 1 ether\r\n    uint256 public affiliateFee; // fraction as proportion of 1 ether\r\n    uint256 public makerAffiliateFee; // wei deductible from makerFee\r\n    uint256 public takerAffiliateFee; // wei deductible form takerFee\r\n\r\n    mapping (address => address) public referrer;  // mapping of user addresses to their referrer addresses\r\n\r\n    address public affiliateContract;\r\n    address public tokenListContract;\r\n\r\n\r\n    enum Errors {\r\n        INVLID_PRICE,           // Order prices don't match\r\n        INVLID_SIGNATURE,       // Signature is invalid\r\n        TOKENS_DONT_MATCH,      // Maker/taker tokens don't match\r\n        ORDER_ALREADY_FILLED,   // Order was already filled\r\n        GAS_TOO_HIGH            // Too high gas fee\r\n    }\r\n\r\n    //event Order(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s);\r\n    //event Cancel(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s);\r\n    event Trade(\r\n        address takerTokenBuy, uint256 takerAmountBuy,\r\n        address takerTokenSell, uint256 takerAmountSell,\r\n        address maker, address indexed taker,\r\n        uint256 makerFee, uint256 takerFee,\r\n        uint256 makerAmountTaken, uint256 takerAmountTaken,\r\n        bytes32 indexed makerOrderHash, bytes32 indexed takerOrderHash\r\n    );\r\n    event Deposit(address indexed token, address indexed user, uint256 amount, uint256 balance, address indexed referrerAddress);\r\n    event Withdraw(address indexed token, address indexed user, uint256 amount, uint256 balance, uint256 withdrawFee);\r\n    event FeeChange(uint256 indexed makerFee, uint256 indexed takerFee, uint256 indexed affiliateFee);\r\n    //event AffiliateFeeChange(uint256 newAffiliateFee);\r\n    event LogError(uint8 indexed errorId, bytes32 indexed makerOrderHash, bytes32 indexed takerOrderHash);\r\n    event CancelOrder(\r\n        bytes32 indexed cancelHash,\r\n        bytes32 indexed orderHash,\r\n        address indexed user,\r\n        address tokenSell,\r\n        uint256 amountSell,\r\n        uint256 cancelFee\r\n    );\r\n\r\n    function setInactivityReleasePeriod(uint256 expiry) onlyAdmin returns (bool success) {\r\n        if (expiry > 1000000) throw;\r\n        inactivityReleasePeriod = expiry;\r\n        return true;\r\n    }\r\n\r\n    function Exchange(address feeAccount_, uint256 makerFee_, uint256 takerFee_, uint256 affiliateFee_, address affiliateContract_, address tokenListContract_) {\r\n        owner = msg.sender;\r\n        feeAccount = feeAccount_;\r\n        inactivityReleasePeriod = 100000;\r\n        makerFee = makerFee_;\r\n        takerFee = takerFee_;\r\n        affiliateFee = affiliateFee_;\r\n\r\n\r\n\r\n        makerAffiliateFee = safeMul(makerFee, affiliateFee_) / (1 ether);\r\n        takerAffiliateFee = safeMul(takerFee, affiliateFee_) / (1 ether);\r\n\r\n        affiliateContract = affiliateContract_;\r\n        tokenListContract = tokenListContract_;\r\n    }\r\n\r\n    function setFees(uint256 makerFee_, uint256 takerFee_, uint256 affiliateFee_) onlyOwner {\r\n        require(makerFee_ < 10 finney && takerFee_ < 10 finney);\r\n        require(affiliateFee_ > affiliateFee);\r\n        makerFee = makerFee_;\r\n        takerFee = takerFee_;\r\n        affiliateFee = affiliateFee_;\r\n        makerAffiliateFee = safeMul(makerFee, affiliateFee_) / (1 ether);\r\n        takerAffiliateFee = safeMul(takerFee, affiliateFee_) / (1 ether);\r\n\r\n        FeeChange(makerFee, takerFee, affiliateFee_);\r\n    }\r\n\r\n    function setAdmin(address admin, bool isAdmin) onlyOwner {\r\n        admins[admin] = isAdmin;\r\n    }\r\n\r\n    modifier onlyAdmin {\r\n        if (msg.sender != owner && !admins[msg.sender]) throw;\r\n        _;\r\n    }\r\n\r\n    function() external {\r\n        throw;\r\n    }\r\n\r\n    function depositToken(address token, uint256 amount, address referrerAddress) {\r\n        //require(EthermiumTokenList(tokenListContract).isTokenInList(token));\r\n        if (referrerAddress == msg.sender) referrerAddress = address(0);\r\n        if (referrer[msg.sender] == address(0x0))   {\r\n            if (referrerAddress != address(0x0) && EthermiumAffiliates(affiliateContract).getAffiliate(msg.sender) == address(0))\r\n            {\r\n                referrer[msg.sender] = referrerAddress;\r\n                EthermiumAffiliates(affiliateContract).assignReferral(referrerAddress, msg.sender);\r\n            }\r\n            else\r\n            {\r\n                referrer[msg.sender] = EthermiumAffiliates(affiliateContract).getAffiliate(msg.sender);\r\n            }\r\n        }\r\n        tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\r\n        lastActiveTransaction[msg.sender] = block.number;\r\n        if (!Token(token).transferFrom(msg.sender, this, amount)) throw;\r\n        Deposit(token, msg.sender, amount, tokens[token][msg.sender], referrer[msg.sender]);\r\n    }\r\n\r\n    function deposit(address referrerAddress) payable {\r\n        if (referrerAddress == msg.sender) referrerAddress = address(0);\r\n        if (referrer[msg.sender] == address(0x0))   {\r\n            if (referrerAddress != address(0x0) && EthermiumAffiliates(affiliateContract).getAffiliate(msg.sender) == address(0))\r\n            {\r\n                referrer[msg.sender] = referrerAddress;\r\n                EthermiumAffiliates(affiliateContract).assignReferral(referrerAddress, msg.sender);\r\n            }\r\n            else\r\n            {\r\n                referrer[msg.sender] = EthermiumAffiliates(affiliateContract).getAffiliate(msg.sender);\r\n            }\r\n        }\r\n        tokens[address(0)][msg.sender] = safeAdd(tokens[address(0)][msg.sender], msg.value);\r\n        lastActiveTransaction[msg.sender] = block.number;\r\n        Deposit(address(0), msg.sender, msg.value, tokens[address(0)][msg.sender], referrer[msg.sender]);\r\n    }\r\n\r\n    function withdraw(address token, uint256 amount) returns (bool success) {\r\n        if (safeSub(block.number, lastActiveTransaction[msg.sender]) < inactivityReleasePeriod) throw;\r\n        if (tokens[token][msg.sender] < amount) throw;\r\n        tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\r\n        if (token == address(0)) {\r\n            if (!msg.sender.send(amount)) throw;\r\n        } else {\r\n            if (!Token(token).transfer(msg.sender, amount)) throw;\r\n        }\r\n        Withdraw(token, msg.sender, amount, tokens[token][msg.sender], 0);\r\n    }\r\n\r\n    function adminWithdraw(address token, uint256 amount, address user, uint256 nonce, uint8 v, bytes32 r, bytes32 s, uint256 feeWithdrawal) onlyAdmin returns (bool success) {\r\n        bytes32 hash = keccak256(this, token, amount, user, nonce);\r\n        if (withdrawn[hash]) throw;\r\n        withdrawn[hash] = true;\r\n        if (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) != user) throw;\r\n        if (feeWithdrawal > 50 finney) feeWithdrawal = 50 finney;\r\n        if (tokens[token][user] < amount) throw;\r\n        tokens[token][user] = safeSub(tokens[token][user], amount);\r\n        tokens[address(0)][user] = safeSub(tokens[address(0x0)][user], feeWithdrawal);\r\n        //tokens[token][feeAccount] = safeAdd(tokens[token][feeAccount], safeMul(feeWithdrawal, amount) / 1 ether);\r\n        tokens[address(0)][feeAccount] = safeAdd(tokens[address(0)][feeAccount], feeWithdrawal);\r\n\r\n        //amount = safeMul((1 ether - feeWithdrawal), amount) / 1 ether;\r\n        if (token == address(0)) {\r\n            if (!user.send(amount)) throw;\r\n        } else {\r\n            if (!Token(token).transfer(user, amount)) throw;\r\n        }\r\n        lastActiveTransaction[user] = block.number;\r\n        Withdraw(token, user, amount, tokens[token][user], feeWithdrawal);\r\n    }\r\n\r\n    function balanceOf(address token, address user) constant returns (uint256) {\r\n        return tokens[token][user];\r\n    }\r\n\r\n    struct OrderPair {\r\n        uint256 makerAmountBuy;\r\n        uint256 makerAmountSell;\r\n        uint256 makerNonce;\r\n        uint256 takerAmountBuy;\r\n        uint256 takerAmountSell;\r\n        uint256 takerNonce;\r\n        uint256 takerGasFee;\r\n\r\n        address makerTokenBuy;\r\n        address makerTokenSell;\r\n        address maker;\r\n        address takerTokenBuy;\r\n        address takerTokenSell;\r\n        address taker;\r\n\r\n        bytes32 makerOrderHash;\r\n        bytes32 takerOrderHash;\r\n    }\r\n\r\n    struct TradeValues {\r\n        uint256 qty;\r\n        uint256 invQty;\r\n        uint256 makerAmountTaken;\r\n        uint256 takerAmountTaken;\r\n        address makerReferrer;\r\n        address takerReferrer;\r\n    }\r\n\r\n\r\n\r\n\r\n    function trade(\r\n        uint8[2] v,\r\n        bytes32[4] rs,\r\n        uint256[7] tradeValues,\r\n        address[6] tradeAddresses\r\n    ) onlyAdmin returns (uint filledTakerTokenAmount)\r\n    {\r\n\r\n        /* tradeValues\r\n          [0] makerAmountBuy\r\n          [1] makerAmountSell\r\n          [2] makerNonce\r\n          [3] takerAmountBuy\r\n          [4] takerAmountSell\r\n          [5] takerNonce\r\n          [6] takerGasFee\r\n\r\n          tradeAddresses\r\n          [0] makerTokenBuy\r\n          [1] makerTokenSell\r\n          [2] maker\r\n          [3] takerTokenBuy\r\n          [4] takerTokenSell\r\n          [5] taker\r\n        */\r\n\r\n        OrderPair memory t  = OrderPair({\r\n            makerAmountBuy  : tradeValues[0],\r\n            makerAmountSell : tradeValues[1],\r\n            makerNonce      : tradeValues[2],\r\n            takerAmountBuy  : tradeValues[3],\r\n            takerAmountSell : tradeValues[4],\r\n            takerNonce      : tradeValues[5],\r\n            takerGasFee     : tradeValues[6],\r\n\r\n            makerTokenBuy   : tradeAddresses[0],\r\n            makerTokenSell  : tradeAddresses[1],\r\n            maker           : tradeAddresses[2],\r\n            takerTokenBuy   : tradeAddresses[3],\r\n            takerTokenSell  : tradeAddresses[4],\r\n            taker           : tradeAddresses[5],\r\n\r\n            makerOrderHash  : keccak256(this, tradeAddresses[0], tradeValues[0], tradeAddresses[1], tradeValues[1], tradeValues[2], tradeAddresses[2]),\r\n            takerOrderHash  : keccak256(this, tradeAddresses[3], tradeValues[3], tradeAddresses[4], tradeValues[4], tradeValues[5], tradeAddresses[5])\r\n        });\r\n\r\n        //bytes32 makerOrderHash = keccak256(this, tradeAddresses[0], tradeValues[0], tradeAddresses[1], tradeValues[1], tradeValues[2], tradeAddresses[2]);\r\n        //bytes32 makerOrderHash = \u00a7\r\n        if (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", t.makerOrderHash), v[0], rs[0], rs[1]) != t.maker)\r\n        {\r\n            LogError(uint8(Errors.INVLID_SIGNATURE), t.makerOrderHash, t.takerOrderHash);\r\n            return 0;\r\n        }\r\n        //bytes32 takerOrderHash = keccak256(this, tradeAddresses[3], tradeValues[3], tradeAddresses[4], tradeValues[4], tradeValues[5], tradeAddresses[5]);\r\n        //bytes32 takerOrderHash = keccak256(this, t.takerTokenBuy, t.takerAmountBuy, t.takerTokenSell, t.takerAmountSell, t.takerNonce, t.taker);\r\n        if (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", t.takerOrderHash), v[1], rs[2], rs[3]) != t.taker)\r\n        {\r\n            LogError(uint8(Errors.INVLID_SIGNATURE), t.makerOrderHash, t.takerOrderHash);\r\n            return 0;\r\n        }\r\n\r\n        if (t.makerTokenBuy != t.takerTokenSell || t.makerTokenSell != t.takerTokenBuy)\r\n        {\r\n            LogError(uint8(Errors.TOKENS_DONT_MATCH), t.makerOrderHash, t.takerOrderHash);\r\n            return 0;\r\n        } // tokens don't match\r\n\r\n        if (t.takerGasFee > 100 finney)\r\n        {\r\n            LogError(uint8(Errors.GAS_TOO_HIGH), t.makerOrderHash, t.takerOrderHash);\r\n            return 0;\r\n        } // takerGasFee too high\r\n\r\n\r\n\r\n        if (!(\r\n        (t.makerTokenBuy != address(0x0) && safeMul(t.makerAmountSell, 1 ether) / t.makerAmountBuy >= safeMul(t.takerAmountBuy, 1 ether) / t.takerAmountSell)\r\n        ||\r\n        (t.makerTokenBuy == address(0x0) && safeMul(t.makerAmountBuy, 1 ether) / t.makerAmountSell <= safeMul(t.takerAmountSell, 1 ether) / t.takerAmountBuy)\r\n        ))\r\n        {\r\n            LogError(uint8(Errors.INVLID_PRICE), t.makerOrderHash, t.takerOrderHash);\r\n            return 0; // prices don't match\r\n        }\r\n\r\n        TradeValues memory tv = TradeValues({\r\n            qty                 : 0,\r\n            invQty              : 0,\r\n            makerAmountTaken    : 0,\r\n            takerAmountTaken    : 0,\r\n            makerReferrer       : referrer[t.maker],\r\n            takerReferrer       : referrer[t.taker]\r\n        });\r\n\r\n        if (tv.makerReferrer == address(0x0)) tv.makerReferrer = feeAccount;\r\n        if (tv.takerReferrer == address(0x0)) tv.takerReferrer = feeAccount;\r\n\r\n\r\n\r\n        // maker buy, taker sell\r\n        if (t.makerTokenBuy != address(0x0))\r\n        {\r\n\r\n\r\n            tv.qty = min(safeSub(t.makerAmountBuy, orderFills[t.makerOrderHash]), safeSub(t.takerAmountSell, safeMul(orderFills[t.takerOrderHash], t.takerAmountSell) / t.takerAmountBuy));\r\n            if (tv.qty == 0)\r\n            {\r\n                LogError(uint8(Errors.ORDER_ALREADY_FILLED), t.makerOrderHash, t.takerOrderHash);\r\n                return 0;\r\n            }\r\n\r\n            tv.invQty = safeMul(tv.qty, t.makerAmountSell) / t.makerAmountBuy;\r\n\r\n            tokens[t.makerTokenSell][t.maker]           = safeSub(tokens[t.makerTokenSell][t.maker],           tv.invQty);\r\n            tv.makerAmountTaken                         = safeSub(tv.qty, safeMul(tv.qty, makerFee) / (1 ether));\r\n            tokens[t.makerTokenBuy][t.maker]            = safeAdd(tokens[t.makerTokenBuy][t.maker],            tv.makerAmountTaken);\r\n            tokens[t.makerTokenBuy][tv.makerReferrer]   = safeAdd(tokens[t.makerTokenBuy][tv.makerReferrer],   safeMul(tv.qty,    makerAffiliateFee) / (1 ether));\r\n\r\n            tokens[t.takerTokenSell][t.taker]           = safeSub(tokens[t.takerTokenSell][t.taker],           tv.qty);\r\n            tv.takerAmountTaken                         = safeSub(safeSub(tv.invQty, safeMul(tv.invQty, takerFee) / (1 ether)), safeMul(tv.invQty, t.takerGasFee) / (1 ether));\r\n            tokens[t.takerTokenBuy][t.taker]            = safeAdd(tokens[t.takerTokenBuy][t.taker],            tv.takerAmountTaken);\r\n            tokens[t.takerTokenBuy][tv.takerReferrer]   = safeAdd(tokens[t.takerTokenBuy][tv.takerReferrer],   safeMul(tv.invQty, takerAffiliateFee) / (1 ether));\r\n\r\n            tokens[t.makerTokenBuy][feeAccount]     = safeAdd(tokens[t.makerTokenBuy][feeAccount],      safeMul(tv.qty,    safeSub(makerFee, makerAffiliateFee)) / (1 ether));\r\n            tokens[t.takerTokenBuy][feeAccount]     = safeAdd(tokens[t.takerTokenBuy][feeAccount],      safeAdd(safeMul(tv.invQty, safeSub(takerFee, takerAffiliateFee)) / (1 ether), safeMul(tv.invQty, t.takerGasFee) / (1 ether)));\r\n\r\n\r\n            orderFills[t.makerOrderHash]            = safeAdd(orderFills[t.makerOrderHash], tv.qty);\r\n            orderFills[t.takerOrderHash]            = safeAdd(orderFills[t.takerOrderHash], safeMul(tv.qty, t.takerAmountBuy) / t.takerAmountSell);\r\n            lastActiveTransaction[t.maker]          = block.number;\r\n            lastActiveTransaction[t.taker]          = block.number;\r\n\r\n            Trade(\r\n                t.takerTokenBuy, tv.qty,\r\n                t.takerTokenSell, tv.invQty,\r\n                t.maker, t.taker,\r\n                makerFee, takerFee,\r\n                tv.makerAmountTaken , tv.takerAmountTaken,\r\n                t.makerOrderHash, t.takerOrderHash\r\n            );\r\n            return tv.qty;\r\n        }\r\n        // maker sell, taker buy\r\n        else\r\n        {\r\n\r\n            tv.qty = min(safeSub(t.makerAmountSell,  safeMul(orderFills[t.makerOrderHash], t.makerAmountSell) / t.makerAmountBuy), safeSub(t.takerAmountBuy, orderFills[t.takerOrderHash]));\r\n            if (tv.qty == 0)\r\n            {\r\n                LogError(uint8(Errors.ORDER_ALREADY_FILLED), t.makerOrderHash, t.takerOrderHash);\r\n                return 0;\r\n            }\r\n\r\n            tv.invQty = safeMul(tv.qty, t.makerAmountBuy) / t.makerAmountSell;\r\n\r\n            tokens[t.makerTokenSell][t.maker]           = safeSub(tokens[t.makerTokenSell][t.maker],           tv.qty);\r\n            tv.makerAmountTaken                         = safeSub(tv.invQty, safeMul(tv.invQty, makerFee) / (1 ether));\r\n            tokens[t.makerTokenBuy][t.maker]            = safeAdd(tokens[t.makerTokenBuy][t.maker],            tv.makerAmountTaken);\r\n            tokens[t.makerTokenBuy][tv.makerReferrer]   = safeAdd(tokens[t.makerTokenBuy][tv.makerReferrer],   safeMul(tv.invQty, makerAffiliateFee) / (1 ether));\r\n\r\n            tokens[t.takerTokenSell][t.taker]           = safeSub(tokens[t.takerTokenSell][t.taker],           tv.invQty);\r\n            tv.takerAmountTaken                         = safeSub(safeSub(tv.qty,    safeMul(tv.qty, takerFee) / (1 ether)), safeMul(tv.qty, t.takerGasFee) / (1 ether));\r\n            tokens[t.takerTokenBuy][t.taker]            = safeAdd(tokens[t.takerTokenBuy][t.taker],            tv.takerAmountTaken);\r\n            tokens[t.takerTokenBuy][tv.takerReferrer]   = safeAdd(tokens[t.takerTokenBuy][tv.takerReferrer],   safeMul(tv.qty,    takerAffiliateFee) / (1 ether));\r\n\r\n            tokens[t.makerTokenBuy][feeAccount]     = safeAdd(tokens[t.makerTokenBuy][feeAccount],      safeMul(tv.invQty, safeSub(makerFee, makerAffiliateFee)) / (1 ether));\r\n            tokens[t.takerTokenBuy][feeAccount]     = safeAdd(tokens[t.takerTokenBuy][feeAccount],      safeAdd(safeMul(tv.qty,    safeSub(takerFee, takerAffiliateFee)) / (1 ether), safeMul(tv.qty, t.takerGasFee) / (1 ether)));\r\n\r\n            orderFills[t.makerOrderHash]            = safeAdd(orderFills[t.makerOrderHash], tv.invQty);\r\n            orderFills[t.takerOrderHash]            = safeAdd(orderFills[t.takerOrderHash], tv.qty); //safeMul(qty, tradeValues[takerAmountBuy]) / tradeValues[takerAmountSell]);\r\n\r\n            lastActiveTransaction[t.maker]          = block.number;\r\n            lastActiveTransaction[t.taker]          = block.number;\r\n\r\n            Trade(\r\n                t.takerTokenBuy, tv.qty,\r\n                t.takerTokenSell, tv.invQty,\r\n                t.maker, t.taker,\r\n                makerFee, takerFee,\r\n                tv.makerAmountTaken , tv.takerAmountTaken,\r\n                t.makerOrderHash, t.takerOrderHash\r\n            );\r\n            return tv.qty;\r\n        }\r\n    }\r\n\r\n    function batchOrderTrade(\r\n        uint8[2][] v,\r\n        bytes32[4][] rs,\r\n        uint256[7][] tradeValues,\r\n        address[6][] tradeAddresses\r\n    )\r\n    {\r\n        for (uint i = 0; i < tradeAddresses.length; i++) {\r\n            trade(\r\n                v[i],\r\n                rs[i],\r\n                tradeValues[i],\r\n                tradeAddresses[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    function cancelOrder(\r\n\t\t/*\r\n\t\t[0] orderV\r\n\t\t[1] cancelV\r\n\t\t*/\r\n\t    uint8[2] v,\r\n\r\n\t\t/*\r\n\t\t[0] orderR\r\n\t\t[1] orderS\r\n\t\t[2] cancelR\r\n\t\t[3] cancelS\r\n\t\t*/\r\n\t    bytes32[4] rs,\r\n\r\n\t\t/*\r\n\t\t[0] orderAmountBuy\r\n\t\t[1] orderAmountSell\r\n\t\t[2] orderNonce\r\n\t\t[3] cancelNonce\r\n\t\t[4] cancelFee\r\n\t\t*/\r\n\t\tuint256[5] cancelValues,\r\n\r\n\t\t/*\r\n\t\t[0] orderTokenBuy\r\n\t\t[1] orderTokenSell\r\n\t\t[2] orderUser\r\n\t\t[3] cancelUser\r\n\t\t*/\r\n\t\taddress[4] cancelAddresses\r\n    ) public onlyAdmin {\r\n        // Order values should be valid and signed by order owner\r\n        bytes32 orderHash = keccak256(\r\n\t        this, cancelAddresses[0], cancelValues[0], cancelAddresses[1],\r\n\t        cancelValues[1], cancelValues[2], cancelAddresses[2]\r\n        );\r\n        require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", orderHash), v[0], rs[0], rs[1]) == cancelAddresses[2]);\r\n\r\n        // Cancel action should be signed by cancel's initiator\r\n        bytes32 cancelHash = keccak256(this, orderHash, cancelAddresses[3], cancelValues[3]);\r\n        require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", cancelHash), v[1], rs[2], rs[3]) == cancelAddresses[3]);\r\n\r\n        // Order owner should be same as cancel's initiator\r\n        require(cancelAddresses[2] == cancelAddresses[3]);\r\n\r\n        // Do not allow to cancel already canceled or filled orders\r\n        require(orderFills[orderHash] != cancelValues[0]);\r\n\r\n        // Limit cancel fee\r\n        if (cancelValues[4] > 50 finney) {\r\n            cancelValues[4] = 50 finney;\r\n        }\r\n\r\n        // Take cancel fee\r\n        // This operation throw an error if fee amount is more than user balance\r\n        tokens[address(0)][cancelAddresses[3]] = safeSub(tokens[address(0)][cancelAddresses[3]], cancelValues[4]);\r\n\r\n        // Cancel order by filling it with amount buy value\r\n        orderFills[orderHash] = cancelValues[0];\r\n\r\n        // Emit cancel order\r\n        CancelOrder(cancelHash, orderHash, cancelAddresses[3], cancelAddresses[1], cancelValues[1], cancelValues[4]);\r\n    }\r\n\r\n    function min(uint a, uint b) private pure returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"affiliateContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"assertion\",\"type\":\"bool\"}],\"name\":\"assert\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"feeWithdrawal\",\"type\":\"uint256\"}],\"name\":\"adminWithdraw\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastActiveTransaction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"withdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"takerFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"},{\"name\":\"isAdmin\",\"type\":\"bool\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"v\",\"type\":\"uint8[2]\"},{\"name\":\"rs\",\"type\":\"bytes32[4]\"},{\"name\":\"cancelValues\",\"type\":\"uint256[5]\"},{\"name\":\"cancelAddresses\",\"type\":\"address[4]\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"v\",\"type\":\"uint8[2]\"},{\"name\":\"rs\",\"type\":\"bytes32[4]\"},{\"name\":\"tradeValues\",\"type\":\"uint256[7]\"},{\"name\":\"tradeAddresses\",\"type\":\"address[6]\"}],\"name\":\"trade\",\"outputs\":[{\"name\":\"filledTakerTokenAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"invalidOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"v\",\"type\":\"uint8[2][]\"},{\"name\":\"rs\",\"type\":\"bytes32[4][]\"},{\"name\":\"tradeValues\",\"type\":\"uint256[7][]\"},{\"name\":\"tradeAddresses\",\"type\":\"address[6][]\"}],\"name\":\"batchOrderTrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"out\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"referrerAddress\",\"type\":\"address\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeSub\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"invalidateOrdersBefore\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"affiliateFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"takerAffiliateFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"makerFee_\",\"type\":\"uint256\"},{\"name\":\"takerFee_\",\"type\":\"uint256\"},{\"name\":\"affiliateFee_\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeMul\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"traded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"setInactivityReleasePeriod\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"makerAffiliateFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeAdd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"inactivityReleasePeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referrerAddress\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderFills\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenListContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"makerFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAffiliate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"feeAccount_\",\"type\":\"address\"},{\"name\":\"makerFee_\",\"type\":\"uint256\"},{\"name\":\"takerFee_\",\"type\":\"uint256\"},{\"name\":\"affiliateFee_\",\"type\":\"uint256\"},{\"name\":\"affiliateContract_\",\"type\":\"address\"},{\"name\":\"tokenListContract_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"SetOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"takerTokenBuy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"takerAmountBuy\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"takerTokenSell\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"takerAmountSell\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"makerFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"takerFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"makerAmountTaken\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"takerAmountTaken\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"makerOrderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"takerOrderHash\",\"type\":\"bytes32\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"referrerAddress\",\"type\":\"address\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"withdrawFee\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"makerFee\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"takerFee\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"affiliateFee\",\"type\":\"uint256\"}],\"name\":\"FeeChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"errorId\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"makerOrderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"takerOrderHash\",\"type\":\"bytes32\"}],\"name\":\"LogError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"cancelHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenSell\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountSell\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cancelFee\",\"type\":\"uint256\"}],\"name\":\"CancelOrder\",\"type\":\"event\"}]", "ContractName": "Exchange", "CompilerVersion": "v0.4.21+commit.dfe3193c", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000095445852148540acb6fcb9e39856d15f1c4163810000000000000000000000000000000000000000000000000005543df729c0000000000000000000000000000000000000000000000000000008e1bc9bf04000000000000000000000000000000000000000000000000000000aa87bee5380000000000000000000000000007f373b93464d093671469be3e4f06a06c3c3a7ca0000000000000000000000003c277e6750a63470352a50f2daf7ef778c109047", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://3391cf27c6a4de38d0e709f77db0ea20834469e26a9d77428d845b32d7265ab7"}