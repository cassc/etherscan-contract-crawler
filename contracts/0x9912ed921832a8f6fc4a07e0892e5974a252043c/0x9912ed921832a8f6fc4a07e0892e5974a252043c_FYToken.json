{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@yield-protocol/vault-v2/src/FYToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.13;\\n\\nimport \\\"erc3156/contracts/interfaces/IERC3156FlashBorrower.sol\\\";\\nimport \\\"erc3156/contracts/interfaces/IERC3156FlashLender.sol\\\";\\nimport \\\"@yield-protocol/utils-v2/src/token/ERC20Permit.sol\\\";\\nimport \\\"@yield-protocol/utils-v2/src/token/SafeERC20Namer.sol\\\";\\nimport \\\"@yield-protocol/utils-v2/src/access/AccessControl.sol\\\";\\nimport \\\"@yield-protocol/utils-v2/src/utils/Math.sol\\\";\\nimport \\\"@yield-protocol/utils-v2/src/utils/Cast.sol\\\";\\nimport \\\"./interfaces/IFYToken.sol\\\";\\nimport \\\"./interfaces/IJoin.sol\\\";\\nimport \\\"./interfaces/IOracle.sol\\\";\\nimport \\\"./constants/Constants.sol\\\";\\n\\ncontract FYToken is IFYToken, IERC3156FlashLender, AccessControl, ERC20Permit, Constants {\\n    using Math for *;\\n    using Cast for *;\\n\\n    event Point(bytes32 indexed param, address value);\\n    event FlashFeeFactorSet(uint256 indexed fee);\\n    event SeriesMatured(uint256 chiAtMaturity);\\n    event Redeemed(address indexed holder, address indexed receiver, uint256 principalAmount, uint256 underlyingAmount);\\n\\n    uint256 constant CHI_NOT_SET = type(uint256).max;\\n\\n    uint256 internal constant MAX_TIME_TO_MATURITY = 126144000; // seconds in four years\\n    bytes32 internal constant FLASH_LOAN_RETURN = keccak256(\\\"ERC3156FlashBorrower.onFlashLoan\\\");\\n    uint256 constant FLASH_LOANS_DISABLED = type(uint256).max;\\n    uint256 public flashFeeFactor = FLASH_LOANS_DISABLED; // Fee on flash loans, as a percentage in fixed point with 18 decimals. Flash loans disabled by default by overflow from `flashFee`.\\n\\n    IOracle public oracle; // Oracle for the savings rate.\\n    IJoin public override join; // Source of redemption funds.\\n    address public immutable override underlying;\\n    bytes6 public immutable underlyingId; // Needed to access the oracle\\n    uint256 public immutable override maturity;\\n    uint256 public chiAtMaturity = CHI_NOT_SET; // Spot price (exchange rate) between the base and an interest accruing token at maturity\\n\\n    constructor(\\n        bytes6 underlyingId_,\\n        IOracle oracle_, // Underlying vs its interest-bearing version\\n        IJoin join_,\\n        uint256 maturity_,\\n        string memory name,\\n        string memory symbol\\n    ) ERC20Permit(name, symbol, SafeERC20Namer.tokenDecimals(address(IJoin(join_).asset()))) {\\n        // The join asset is this fyToken's underlying, from which we inherit the decimals\\n        uint256 now_ = block.timestamp;\\n        require(\\n            maturity_ > now_ && maturity_ < now_ + MAX_TIME_TO_MATURITY && maturity_ < type(uint32).max,\\n            \\\"Invalid maturity\\\"\\n        );\\n\\n        underlyingId = underlyingId_;\\n        join = join_;\\n        maturity = maturity_;\\n        underlying = address(IJoin(join_).asset());\\n        oracle = oracle_;\\n    }\\n\\n    modifier afterMaturity() {\\n        require(uint32(block.timestamp) >= maturity, \\\"Only after maturity\\\");\\n        _;\\n    }\\n\\n    modifier beforeMaturity() {\\n        require(uint32(block.timestamp) < maturity, \\\"Only before maturity\\\");\\n        _;\\n    }\\n\\n    /// @dev Point to a different Oracle or Join\\n    function point(bytes32 param, address value) external auth {\\n        if (param == \\\"oracle\\\") {\\n            require (chiAtMaturity == CHI_NOT_SET, \\\"Already matured\\\");\\n            oracle = IOracle(value);\\n        } else if (param == \\\"join\\\") {\\n            join = IJoin(value);\\n        } else revert(\\\"Unrecognized parameter\\\");\\n        emit Point(param, value);\\n    }\\n\\n    /// @dev Set the flash loan fee factor\\n    function setFlashFeeFactor(uint256 flashFeeFactor_) external auth {\\n        flashFeeFactor = flashFeeFactor_;\\n        emit FlashFeeFactorSet(flashFeeFactor_);\\n    }\\n\\n    ///@dev Converts the amount of the principal to the underlying\\n    function convertToUnderlying(uint256 principalAmount) external override returns (uint256 underlyingAmount) {\\n        return _convertToUnderlying(principalAmount);\\n    }\\n\\n    ///@dev Converts the amount of the principal to the underlying\\n    ///Before maturity, returns amount as if at maturity.\\n    function _convertToUnderlying(uint256 principalAmount) internal returns (uint256 underlyingAmount) {\\n        if (chiAtMaturity == CHI_NOT_SET) {\\n            return principalAmount;\\n        } else {\\n            return principalAmount.wmul(_accrual());\\n        }\\n    }\\n\\n    ///@dev Converts the amount of the underlying to the principal\\n    function convertToPrincipal(uint256 underlyingAmount) external override returns (uint256 principalAmount) {\\n        return _convertToPrincipal(underlyingAmount);\\n    }\\n\\n    ///@dev Converts the amount of the underlying to the principal\\n    ///Before maturity, returns amount as if at maturity.\\n    function _convertToPrincipal(uint256 underlyingAmount) internal returns (uint256 princpalAmount) {\\n        if (chiAtMaturity == CHI_NOT_SET) {\\n            return underlyingAmount;\\n        } else {\\n            return underlyingAmount.wdivup(_accrual());\\n        }\\n    }\\n\\n    /// @dev Mature the fyToken by recording the chi.\\n    /// If called more than once, it will revert.\\n    function mature() external override afterMaturity {\\n        require(chiAtMaturity == CHI_NOT_SET, \\\"Already matured\\\");\\n        _mature();\\n    }\\n\\n    /// @dev Mature the fyToken by recording the chi.\\n    function _mature() internal returns (uint256 _chiAtMaturity) {\\n        (_chiAtMaturity, ) = oracle.get(underlyingId, CHI, 0); // The value returned is an accumulator, it doesn't need an input amount\\n        require (_chiAtMaturity > 0, \\\"Chi oracle malfunction\\\"); // The chi accumulator needs to have been started\\n        chiAtMaturity = _chiAtMaturity;\\n        emit SeriesMatured(_chiAtMaturity);\\n    }\\n\\n    /// @dev Retrieve the chi accrual since maturity, maturing if necessary.\\n    function accrual() external afterMaturity returns (uint256) {\\n        return _accrual();\\n    }\\n\\n    /// @dev Retrieve the chi accrual since maturity, maturing if necessary.\\n    /// Note: Call only after checking we are past maturity\\n    function _accrual() internal returns (uint256 accrual_) {\\n        if (chiAtMaturity == CHI_NOT_SET) {\\n            // After maturity, but chi not yet recorded. Let's record it, and accrual is then 1.\\n            _mature();\\n        } else {\\n            (uint256 chi, ) = oracle.get(underlyingId, CHI, 0); // The value returned is an accumulator, it doesn't need an input amount\\n            accrual_ = chi.wdiv(chiAtMaturity);\\n        }\\n        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18; // The accrual can't be below 1 (with 18 decimals)\\n    }\\n\\n    ///@dev returns the maximum redeemable amount for the address holder in terms of the principal\\n    function maxRedeem(address holder) external override view returns (uint256 maxPrincipalAmount) {\\n        return _balanceOf[holder];\\n    }\\n\\n    ///@dev returns the amount of underlying redeemable in terms of the principal\\n    function previewRedeem(uint256 principalAmount) external override beforeMaturity returns (uint256 underlyingAmount) {\\n        return _convertToUnderlying(principalAmount);\\n    }\\n\\n    /// @dev Burn fyToken after maturity for an amount of principal that increases according to `chi`\\n    /// If `amount` is 0, the contract will redeem instead the fyToken balance of this contract. Useful for batches.\\n    function redeem(uint256 principalAmount, address receiver, address holder) external override afterMaturity returns (uint256 underlyingAmount) {\\n        principalAmount = (principalAmount == 0) ? _balanceOf[address(this)] : principalAmount;\\n        _burn(holder, principalAmount);\\n        underlyingAmount = _convertToUnderlying(principalAmount);\\n        join.exit(receiver, underlyingAmount.u128());\\n\\n        emit Redeemed(holder, receiver, principalAmount, underlyingAmount);\\n    }\\n\\n    /// @dev Burn fyToken after maturity for an amount of principal that increases according to `chi`\\n    /// If `amount` is 0, the contract will redeem instead the fyToken balance of this contract. Useful for batches.\\n    function redeem(address receiver, uint256 principalAmount) external override afterMaturity returns (uint256 underlyingAmount) {\\n        principalAmount = (principalAmount == 0) ? _balanceOf[address(this)] : principalAmount;\\n        _burn(msg.sender, principalAmount);\\n        underlyingAmount = _convertToUnderlying(principalAmount);\\n        join.exit(receiver, underlyingAmount.u128());\\n\\n        emit Redeemed(msg.sender, receiver, principalAmount, underlyingAmount);\\n    }\\n\\n    ///@dev returns the maximum withdrawable amount for the address holder in terms of the underlying\\n    function maxWithdraw(address holder) external override returns (uint256 maxUnderlyingAmount) {\\n        return _convertToUnderlying(_balanceOf[holder]);\\n    }\\n\\n    ///@dev returns the amount of the principal withdrawable in terms of the underlying\\n    function previewWithdraw(uint256 underlyingAmount) external override beforeMaturity returns (uint256 principalAmount) {\\n        return _convertToPrincipal(underlyingAmount);\\n    }\\n\\n    /// @dev Burn fyToken after maturity for an amount of underlying that increases according to `chi`\\n    /// If `amount` is 0, the contract will redeem instead the fyToken balance of this contract. Useful for batches.\\n    function withdraw(uint256 underlyingAmount, address receiver, address holder) external override afterMaturity returns (uint256 principalAmount) {\\n        principalAmount = (underlyingAmount == 0) ? _balanceOf[address(this)] : _convertToPrincipal(underlyingAmount);\\n        _burn(holder, principalAmount);\\n        underlyingAmount = _convertToUnderlying(principalAmount);\\n        join.exit(receiver, underlyingAmount.u128());\\n\\n        emit Redeemed(holder, receiver, principalAmount, underlyingAmount);\\n    }\\n\\n    /// @dev Mint fyToken providing an equal amount of underlying to the protocol\\n    function mintWithUnderlying(address receiver, uint256 underlyingAmount) external override beforeMaturity {\\n        _mint(receiver, underlyingAmount);\\n        join.join(msg.sender, underlyingAmount.u128());\\n    }\\n\\n    /// @dev Mint fyTokens.\\n    function mint(address receiver, uint256 principalAmount) external override beforeMaturity auth {\\n        _mint(receiver, principalAmount);\\n    }\\n\\n    /// @dev Burn fyTokens. The user needs to have either transferred the tokens to this contract, or have approved this contract to take them.\\n    function burn(address holder, uint256 principalAmount) external override auth {\\n        _burn(holder, principalAmount);\\n    }\\n\\n    /// @dev Burn fyTokens.\\n    /// Any tokens locked in this contract will be burned first and subtracted from the amount to burn from the user's wallet.\\n    /// This feature allows someone to transfer fyToken to this contract to enable a `burn`, potentially saving the cost of `approve` or `permit`.\\n    function _burn(address holder, uint256 principalAmount) internal override returns (bool) {\\n        // First use any tokens locked in this contract\\n        uint256 available = _balanceOf[address(this)];\\n        if (available >= principalAmount) {\\n            return super._burn(address(this), principalAmount);\\n        } else {\\n            if (available > 0) super._burn(address(this), available);\\n            unchecked {\\n                _decreaseAllowance(holder, principalAmount - available);\\n            }\\n            unchecked {\\n                return super._burn(holder, principalAmount - available);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev From ERC-3156. The amount of currency available to be lended.\\n     * @param token The loan currency. It must be a FYDai contract.\\n     * @return The amount of `token` that can be borrowed.\\n     */\\n    function maxFlashLoan(address token) external view override beforeMaturity returns (uint256) {\\n        return token == address(this) ? type(uint256).max - _totalSupply : 0;\\n    }\\n\\n    /**\\n     * @dev From ERC-3156. The fee to be charged for a given loan.\\n     * @param token The loan currency. It must be the asset.\\n     * @param principalAmount The amount of tokens lent.\\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\\n     */\\n    function flashFee(address token, uint256 principalAmount) external view override returns (uint256) {\\n        require(token == address(this), \\\"Unsupported currency\\\");\\n        return _flashFee(principalAmount);\\n    }\\n\\n    /**\\n     * @dev The fee to be charged for a given loan.\\n     * @param principalAmount The amount of tokens lent.\\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\\n     */\\n    function _flashFee(uint256 principalAmount) internal view returns (uint256) {\\n        return principalAmount.wmul(flashFeeFactor);\\n    }\\n\\n    /**\\n     * @dev From ERC-3156. Loan `amount` fyDai to `receiver`, which needs to return them plus fee to this contract within the same transaction.\\n     * Note that if the initiator and the borrower are the same address, no approval is needed for this contract to take the principal + fee from the borrower.\\n     * If the borrower transfers the principal + fee to this contract, they will be burnt here instead of pulled from the borrower.\\n     * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.\\n     * @param token The loan currency. Must be a fyDai contract.\\n     * @param principalAmount The amount of tokens lent.\\n     * @param data A data parameter to be passed on to the `receiver` for any custom use.\\n     */\\n    function flashLoan(\\n        IERC3156FlashBorrower receiver,\\n        address token,\\n        uint256 principalAmount,\\n        bytes memory data\\n    ) external override beforeMaturity returns (bool) {\\n        require(token == address(this), \\\"Unsupported currency\\\");\\n        _mint(address(receiver), principalAmount);\\n        uint128 fee = _flashFee(principalAmount).u128();\\n        require(\\n            receiver.onFlashLoan(msg.sender, token, principalAmount, fee, data) == FLASH_LOAN_RETURN,\\n            \\\"Non-compliant borrower\\\"\\n        );\\n        _burn(address(receiver), principalAmount + fee);\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"erc3156/contracts/interfaces/IERC3156FlashLender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.9.0;\\nimport \\\"./IERC3156FlashBorrower.sol\\\";\\n\\n\\ninterface IERC3156FlashLender {\\n\\n    /**\\n     * @dev The amount of currency available to be lended.\\n     * @param token The loan currency.\\n     * @return The amount of `token` that can be borrowed.\\n     */\\n    function maxFlashLoan(\\n        address token\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev The fee to be charged for a given loan.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\\n     */\\n    function flashFee(\\n        address token,\\n        uint256 amount\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Initiate a flash loan.\\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\n     */\\n    function flashLoan(\\n        IERC3156FlashBorrower receiver,\\n        address token,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool);\\n}\"\r\n    },\r\n    \"erc3156/contracts/interfaces/IERC3156FlashBorrower.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.9.0;\\n\\n\\ninterface IERC3156FlashBorrower {\\n\\n    /**\\n     * @dev Receive a flash loan.\\n     * @param initiator The initiator of the loan.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @param fee The additional amount of tokens to repay.\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\n     * @return The keccak256 hash of \\\"ERC3156FlashBorrower.onFlashLoan\\\"\\n     */\\n    function onFlashLoan(\\n        address initiator,\\n        address token,\\n        uint256 amount,\\n        uint256 fee,\\n        bytes calldata data\\n    ) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@yield-protocol/utils-v2/src/token/SafeERC20Namer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Last audit: https://github.com/yieldprotocol/yield-utils-v2/commit/0d0b08b6b67cef6dfa69e6e6539bee542f49e25b\\n// Report: https://code4rena.com/reports/2021-05-yield\\n\\npragma solidity >=0.5.0;\\n\\nimport \\\"../token/IERC20Metadata.sol\\\";\\nimport \\\"../utils/AddressStringUtil.sol\\\";\\n\\n// produces token descriptors from inconsistent or absent ERC20 symbol implementations that can return string or bytes32\\n// this library will always produce a string symbol to represent the token\\nlibrary SafeERC20Namer {\\n    function bytes32ToString(bytes32 x) private pure returns (string memory) {\\n        bytes memory bytesString = new bytes(32);\\n        uint256 charCount = 0;\\n        for (uint256 j = 0; j < 32; j++) {\\n            bytes1 char = x[j];\\n            if (char != 0) {\\n                bytesString[charCount] = char;\\n                charCount++;\\n            }\\n        }\\n        bytes memory bytesStringTrimmed = new bytes(charCount);\\n        for (uint256 j = 0; j < charCount; j++) {\\n            bytesStringTrimmed[j] = bytesString[j];\\n        }\\n        return string(bytesStringTrimmed);\\n    }\\n\\n    // assumes the data is in position 2\\n    function parseStringData(bytes memory b) private pure returns (string memory) {\\n        uint256 charCount = 0;\\n        // first parse the charCount out of the data\\n        for (uint256 i = 32; i < 64; i++) {\\n            charCount <<= 8;\\n            charCount += uint8(b[i]);\\n        }\\n\\n        bytes memory bytesStringTrimmed = new bytes(charCount);\\n        for (uint256 i = 0; i < charCount; i++) {\\n            bytesStringTrimmed[i] = b[i + 64];\\n        }\\n\\n        return string(bytesStringTrimmed);\\n    }\\n\\n    // uses a heuristic to produce a token name from the address\\n    // the heuristic returns the full hex of the address string in upper case\\n    function addressToName(address token) private pure returns (string memory) {\\n        return AddressStringUtil.toAsciiString(token, 40);\\n    }\\n\\n    // uses a heuristic to produce a token symbol from the address\\n    // the heuristic returns the first 6 hex of the address string in upper case\\n    function addressToSymbol(address token) private pure returns (string memory) {\\n        return AddressStringUtil.toAsciiString(token, 6);\\n    }\\n\\n    // calls an external view token contract method that returns a symbol or name, and parses the output into a string\\n    function callAndParseStringReturn(address token, bytes4 selector) private view returns (string memory) {\\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(selector));\\n        // if not implemented, or returns empty data, return empty string\\n        if (!success || data.length == 0) {\\n            return \\\"\\\";\\n        }\\n        // bytes32 data always has length 32\\n        if (data.length == 32) {\\n            bytes32 decoded = abi.decode(data, (bytes32));\\n            return bytes32ToString(decoded);\\n        } else if (data.length > 64) {\\n            return abi.decode(data, (string));\\n        }\\n        return \\\"\\\";\\n    }\\n\\n    // attempts to extract the token symbol. if it does not implement symbol, returns a symbol derived from the address\\n    function tokenSymbol(address token) public view returns (string memory) {\\n        string memory symbol = callAndParseStringReturn(token, IERC20Metadata.symbol.selector);\\n        if (bytes(symbol).length == 0) {\\n            // fallback to 6 uppercase hex of address\\n            return addressToSymbol(token);\\n        }\\n        return symbol;\\n    }\\n\\n    // attempts to extract the token name. if it does not implement name, returns a name derived from the address\\n    function tokenName(address token) public view returns (string memory) {\\n        string memory name = callAndParseStringReturn(token, IERC20Metadata.name.selector);\\n        if (bytes(name).length == 0) {\\n            // fallback to full hex of address\\n            return addressToName(token);\\n        }\\n        return name;\\n    }\\n\\n    /// @notice Provides a safe ERC20.decimals version which returns '0' as fallback value.\\n    /// @param token The address of the ERC-20 token contract.\\n    /// @return (uint8) Token decimals.\\n    function tokenDecimals(address token) public view returns (uint8) {\\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(IERC20Metadata.decimals.selector));\\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@yield-protocol/utils-v2/src/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms.\\n *\\n * Roles are referred to by their `bytes4` identifier. These are expected to be the \\n * signatures for all the functions in the contract. Special roles should be exposed\\n * in the external API and be unique:\\n *\\n * ```\\n * bytes4 public constant ROOT = 0x00000000;\\n * ```\\n *\\n * Roles represent restricted access to a function call. For that purpose, use {auth}:\\n *\\n * ```\\n * function foo() public auth {\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `ROOT`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {setRoleAdmin}.\\n *\\n * WARNING: The `ROOT` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\ncontract AccessControl {\\n    struct RoleData {\\n        mapping (address => bool) members;\\n        bytes4 adminRole;\\n    }\\n\\n    mapping (bytes4 => RoleData) private _roles;\\n\\n    bytes4 public constant ROOT = 0x00000000;\\n    bytes4 public constant ROOT4146650865 = 0x00000000; // Collision protection for ROOT, test with ROOT12007226833()\\n    bytes4 public constant LOCK = 0xFFFFFFFF;           // Used to disable further permissioning of a function\\n    bytes4 public constant LOCK8605463013 = 0xFFFFFFFF; // Collision protection for LOCK, test with LOCK10462387368()\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role\\n     *\\n     * `ROOT` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes4 indexed role, bytes4 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call.\\n     */\\n    event RoleGranted(bytes4 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes4 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Give msg.sender the ROOT role and create a LOCK role with itself as the admin role and no members. \\n     * Calling setRoleAdmin(msg.sig, LOCK) means no one can grant that msg.sig role anymore.\\n     */\\n    constructor () {\\n        _grantRole(ROOT, msg.sender);   // Grant ROOT to msg.sender\\n        _setRoleAdmin(LOCK, LOCK);      // Create the LOCK role by setting itself as its own admin, creating an independent role tree\\n    }\\n\\n    /**\\n     * @dev Each function in the contract has its own role, identified by their msg.sig signature.\\n     * ROOT can give and remove access to each function, lock any further access being granted to\\n     * a specific action, or even create other roles to delegate admin control over a function.\\n     */\\n    modifier auth() {\\n        require (_hasRole(msg.sig, msg.sender), \\\"Access denied\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allow only if the caller has been granted the admin role of `role`.\\n     */\\n    modifier admin(bytes4 role) {\\n        require (_hasRole(_getRoleAdmin(role), msg.sender), \\\"Only admin\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes4 role, address account) external view returns (bool) {\\n        return _hasRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes4 role) external view returns (bytes4) {\\n        return _getRoleAdmin(role);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n\\n     * If ``role``'s admin role is not `adminRole` emits a {RoleAdminChanged} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function setRoleAdmin(bytes4 role, bytes4 adminRole) external virtual admin(role) {\\n        _setRoleAdmin(role, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes4 role, address account) external virtual admin(role) {\\n        _grantRole(role, account);\\n    }\\n\\n    \\n    /**\\n     * @dev Grants all of `role` in `roles` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - For each `role` in `roles`, the caller must have ``role``'s admin role.\\n     */\\n    function grantRoles(bytes4[] memory roles, address account) external virtual {\\n        for (uint256 i = 0; i < roles.length; i++) {\\n            require (_hasRole(_getRoleAdmin(roles[i]), msg.sender), \\\"Only admin\\\");\\n            _grantRole(roles[i], account);\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets LOCK as ``role``'s admin role. LOCK has no members, so this disables admin management of ``role``.\\n\\n     * Emits a {RoleAdminChanged} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function lockRole(bytes4 role) external virtual admin(role) {\\n        _setRoleAdmin(role, LOCK);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes4 role, address account) external virtual admin(role) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes all of `role` in `roles` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - For each `role` in `roles`, the caller must have ``role``'s admin role.\\n     */\\n    function revokeRoles(bytes4[] memory roles, address account) external virtual {\\n        for (uint256 i = 0; i < roles.length; i++) {\\n            require (_hasRole(_getRoleAdmin(roles[i]), msg.sender), \\\"Only admin\\\");\\n            _revokeRole(roles[i], account);\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes4 role, address account) external virtual {\\n        require(account == msg.sender, \\\"Renounce only for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    function _hasRole(bytes4 role, address account) internal view returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    function _getRoleAdmin(bytes4 role) internal view returns (bytes4) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    function _setRoleAdmin(bytes4 role, bytes4 adminRole) internal virtual {\\n        if (_getRoleAdmin(role) != adminRole) {\\n            _roles[role].adminRole = adminRole;\\n            emit RoleAdminChanged(role, adminRole);\\n        }\\n    }\\n\\n    function _grantRole(bytes4 role, address account) internal {\\n        if (!_hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, msg.sender);\\n        }\\n    }\\n\\n    function _revokeRole(bytes4 role, address account) internal {\\n        if (_hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, msg.sender);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"@yield-protocol/utils-v2/src/utils/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.13;\\n\\nlibrary Math {\\n    // Taken from https://github.com/usmfum/USM/blob/master/src/WadMath.sol\\n    /// @dev Multiply an amount by a fixed point factor with 18 decimals, rounds down.\\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x * y;\\n        unchecked {\\n            z /= 1e18;\\n        }\\n    }\\n\\n    // Taken from https://github.com/usmfum/USM/blob/master/src/WadMath.sol\\n    /// @dev Multiply x and y, with y being fixed point. If both are integers, the result is a fixed point factor. Rounds up.\\n    function wmulup(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x * y + 1e18 - 1; // Rounds up.  So (again imagining 2 decimal places):\\n        unchecked {\\n            z /= 1e18;\\n        } // 383 (3.83) * 235 (2.35) -> 90005 (9.0005), + 99 (0.0099) -> 90104, / 100 -> 901 (9.01).\\n    }\\n\\n    // Taken from https://github.com/usmfum/USM/blob/master/src/WadMath.sol\\n    /// @dev Divide an amount by a fixed point factor with 18 decimals\\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = (x * 1e18) / y;\\n    }\\n\\n    // Taken from https://github.com/usmfum/USM/blob/master/src/WadMath.sol\\n    /// @dev Divide x and y, with y being fixed point. If both are integers, the result is a fixed point factor. Rounds up.\\n    function wdivup(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x * 1e18 + y; // 101 (1.01) / 1000 (10) -> (101 * 100 + 1000 - 1) / 1000 -> 11 (0.11 = 0.101 rounded up).\\n        unchecked {\\n            z -= 1;\\n        } // Can do unchecked subtraction since division in next line will catch y = 0 case anyway\\n        z /= y;\\n    }\\n\\n    // Taken from https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol\\n    /// @dev $x ^ $n; $x is 18-decimals fixed point number\\n    function wpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\\n        uint256 baseUnit = 1e18;\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := baseUnit\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store baseUnit in z for now.\\n                    z := baseUnit\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, baseUnit)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) { revert(0, 0) }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) { revert(0, 0) }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, baseUnit)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) { revert(0, 0) }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) { revert(0, 0) }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, baseUnit)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Divide an amount by a fixed point factor with 27 decimals\\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = (x * 1e27) / y;\\n    }\\n}\\n\"\r\n    },\r\n    \"@yield-protocol/utils-v2/src/token/ERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/src/token/ERC20/ERC20Permit.sol\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./IERC2612.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to use their tokens\\n * without sending any transactions by setting {IERC20-allowance} with a\\n * signature using the {permit} method, and then spend them via\\n * {IERC20-transferFrom}.\\n *\\n * The {permit} signature mechanism conforms to the {IERC2612} interface.\\n */\\nabstract contract ERC20Permit is ERC20, IERC2612 {\\n    mapping (address => uint256) public override nonces;\\n\\n    bytes32 public immutable PERMIT_TYPEHASH = keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 private immutable _DOMAIN_SEPARATOR;\\n    uint256 public immutable deploymentChainId;\\n\\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_, decimals_) {\\n        deploymentChainId = block.chainid;\\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(block.chainid);\\n    }\\n\\n    /// @dev Calculate the DOMAIN_SEPARATOR.\\n    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(bytes(name)),\\n                keccak256(bytes(version())),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /// @dev Return the DOMAIN_SEPARATOR.\\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\\n        return block.chainid == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(block.chainid);\\n    }\\n\\n    /// @dev Setting the version as a function so that it can be overriden\\n    function version() public pure virtual returns(string memory) { return \\\"1\\\"; }\\n\\n    /**\\n     * @dev See {IERC2612-permit}.\\n     *\\n     * In cases where the free option is not a concern, deadline can simply be\\n     * set to uint(-1), so it should be seen as an optional parameter\\n     */\\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external virtual override {\\n        require(deadline >= block.timestamp, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 hashStruct = keccak256(\\n            abi.encode(\\n                PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                amount,\\n                nonces[owner]++,\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                block.chainid == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(block.chainid),\\n                hashStruct\\n            )\\n        );\\n\\n        address signer = ecrecover(hash, v, r, s);\\n        require(\\n            signer != address(0) && signer == owner,\\n            \\\"ERC20Permit: invalid signature\\\"\\n        );\\n\\n        _setAllowance(owner, spender, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@yield-protocol/vault-v2/src/interfaces/IFYToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"./IERC5095.sol\\\";\\nimport \\\"./IJoin.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\n\\ninterface IFYToken is IERC5095 {\\n\\n    /// @dev Oracle for the savings rate.\\n    function oracle() view external returns (IOracle);\\n\\n    /// @dev Source of redemption funds.\\n    function join() view external returns (IJoin); \\n\\n    /// @dev Asset to be paid out on redemption.\\n    function underlying() view external returns (address);\\n\\n    /// @dev Yield id of the asset to be paid out on redemption.\\n    function underlyingId() view external returns (bytes6);\\n\\n    /// @dev Time at which redemptions are enabled.\\n    function maturity() view external returns (uint256);\\n\\n    /// @dev Spot price (exchange rate) between the base and an interest accruing token at maturity, set to 2^256-1 before maturity\\n    function chiAtMaturity() view external returns (uint256);\\n    \\n    /// @dev Record price data at maturity\\n    function mature() external;\\n\\n    /// @dev Mint fyToken providing an equal amount of underlying to the protocol\\n    function mintWithUnderlying(address to, uint256 amount) external;\\n\\n    /// @dev Burn fyToken after maturity for an amount of underlying.\\n    function redeem(address to, uint256 amount) external returns (uint256);\\n\\n    /// @dev Mint fyToken.\\n    /// This function can only be called by other Yield contracts, not users directly.\\n    /// @param to Wallet to mint the fyToken in.\\n    /// @param fyTokenAmount Amount of fyToken to mint.\\n    function mint(address to, uint256 fyTokenAmount) external;\\n\\n    /// @dev Burn fyToken.\\n    /// This function can only be called by other Yield contracts, not users directly.\\n    /// @param from Wallet to burn the fyToken from.\\n    /// @param fyTokenAmount Amount of fyToken to burn.\\n    function burn(address from, uint256 fyTokenAmount) external;\\n}\\n\"\r\n    },\r\n    \"@yield-protocol/utils-v2/src/utils/Cast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.13;\\n\\nlibrary Cast {\\n    ///@dev library for safe casting of value types\\n\\n    function b12(bytes32 x) internal pure returns (bytes12 y) {\\n        require(bytes32(y = bytes12(x)) == x, \\\"Cast overflow\\\");\\n    }\\n\\n    function b6(bytes32 x) internal pure returns (bytes6 y) {\\n        require(bytes32(y = bytes6(x)) == x, \\\"Cast overflow\\\");\\n    }\\n\\n    function u256(int256 x) internal pure returns (uint256 y) {\\n        require(x >= 0, \\\"Cast overflow\\\");\\n        y = uint256(x);\\n    }\\n\\n    function i256(uint256 x) internal pure returns (int256 y) {\\n        require(x <= uint256(type(int256).max), \\\"Cast overflow\\\");\\n        y = int256(x);\\n    }\\n\\n    function u128(uint256 x) internal pure returns (uint128 y) {\\n        require(x <= type(uint128).max, \\\"Cast overflow\\\");\\n        y = uint128(x);\\n    }\\n\\n    function u128(int256 x) internal pure returns (uint128 y) {\\n        require(x >= 0, \\\"Cast overflow\\\");\\n        y = uint128(uint256(x));\\n    }\\n\\n    function i128(uint256 x) internal pure returns (int128) {\\n        require(x <= uint256(int256(type(int128).max)), \\\"Cast overflow\\\");\\n        return int128(int256(x));\\n    }\\n\\n    function i128(int256 x) internal pure returns (int128) {\\n        require(x <= type(int128).max, \\\"Cast overflow\\\");\\n        require(x >= type(int128).min, \\\"Cast overflow\\\");\\n        return int128(x);\\n    }\\n\\n    function u112(uint256 x) internal pure returns (uint112 y) {\\n        require(x <= type(uint112).max, \\\"Cast overflow\\\");\\n        y = uint112(x);\\n    }\\n\\n    function u104(uint256 x) internal pure returns (uint104 y) {\\n        require(x <= type(uint104).max, \\\"Cast overflow\\\");\\n        y = uint104(x);\\n    }\\n\\n    function u96(uint256 x) internal pure returns (uint96 y) {\\n        require(x <= type(uint96).max, \\\"Cast overflow\\\");\\n        y = uint96(x);\\n    }\\n\\n    function u32(uint256 x) internal pure returns (uint32 y) {\\n        require(x <= type(uint32).max, \\\"Cast overflow\\\");\\n        y = uint32(x);\\n    }\\n}\\n\"\r\n    },\r\n    \"@yield-protocol/vault-v2/src/interfaces/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IOracle {\\n    /**\\n     * @notice Doesn't refresh the price, but returns the latest value available without doing any transactional operations\\n     * @param base The asset in which the `amount` to be converted is represented\\n     * @param quote The asset in which the converted `value` will be represented\\n     * @param amount The amount to be converted from `base` to `quote`\\n     * @return value The converted value of `amount` from `base` to `quote`\\n     * @return updateTime The timestamp when the conversion price was taken\\n     */\\n    function peek(\\n        bytes32 base,\\n        bytes32 quote,\\n        uint256 amount\\n    ) external view returns (uint256 value, uint256 updateTime);\\n\\n    /**\\n     * @notice Does whatever work or queries will yield the most up-to-date price, and returns it.\\n     * @param base The asset in which the `amount` to be converted is represented\\n     * @param quote The asset in which the converted `value` will be represented\\n     * @param amount The amount to be converted from `base` to `quote`\\n     * @return value The converted value of `amount` from `base` to `quote`\\n     * @return updateTime The timestamp when the conversion price was taken\\n     */\\n    function get(\\n        bytes32 base,\\n        bytes32 quote,\\n        uint256 amount\\n    ) external returns (uint256 value, uint256 updateTime);\\n}\\n\"\r\n    },\r\n    \"@yield-protocol/vault-v2/src/constants/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.13;\\n\\ncontract Constants {\\n    bytes32 constant CHI = \\\"CHI\\\";\\n    bytes32 constant RATE = \\\"RATE\\\";\\n    bytes6 constant ETH = \\\"00\\\";\\n}\"\r\n    },\r\n    \"@yield-protocol/vault-v2/src/interfaces/IJoin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"@yield-protocol/utils-v2/src/token/IERC20.sol\\\";\\n\\ninterface IJoin {\\n    /// @dev asset managed by this contract\\n    function asset() external view returns (address);\\n\\n    /// @dev amount of assets held by this contract\\n    function storedBalance() external view returns (uint256);\\n\\n    /// @dev Add tokens to this contract.\\n    function join(address user, uint128 wad) external returns (uint128);\\n\\n    /// @dev Remove tokens to this contract.\\n    function exit(address user, uint128 wad) external returns (uint128);\\n\\n    /// @dev Retrieve any tokens other than the `asset`. Useful for airdropped tokens.\\n    function retrieve(IERC20 token, address to) external;\\n}\\n\"\r\n    },\r\n    \"@yield-protocol/utils-v2/src/utils/AddressStringUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\nlibrary AddressStringUtil {\\n    // converts an address to the uppercase hex string, extracting only len bytes (up to 20, multiple of 2)\\n    function toAsciiString(address addr, uint256 len) internal pure returns (string memory) {\\n        require(len % 2 == 0 && len > 0 && len <= 40, \\\"AddressStringUtil: INVALID_LEN\\\");\\n        bytes memory s = new bytes(len);\\n        uint256 addrNum = uint256(uint160(addr));\\n        for (uint256 ii = 0; ii < len ; ii +=2) {\\n            uint8 b = uint8(addrNum >> (4 * (38 - ii)));\\n            s[ii] = char(b >> 4);\\n            s[ii + 1] = char(b & 0x0f);\\n        }\\n        return string(s);\\n    }\\n\\n    // hi and lo are only 4 bits and between 0 and 16\\n    // this method converts those values to the unicode/ascii code point for the hex representation\\n    // uses upper case for the characters\\n    function char(uint8 b) private pure returns (bytes1 c) {\\n        if (b < 10) {\\n            return bytes1(b + 0x30);\\n        } else {\\n            return bytes1(b + 0x37);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@yield-protocol/utils-v2/src/token/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/src/token/ERC20/extensions/IERC20Metadata.sol\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\"\r\n    },\r\n    \"@yield-protocol/utils-v2/src/token/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"@yield-protocol/utils-v2/src/token/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Inspired on token.sol from DappHub. Natspec adpated from OpenZeppelin.\\n\\npragma solidity ^0.8.0;\\nimport \\\"./IERC20Metadata.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n * \\n * Calls to {transferFrom} do not check for allowance if the caller is the owner\\n * of the funds. This allows to reduce the number of approvals that are necessary.\\n *\\n * Finally, {transferFrom} does not decrease the allowance if it is set to\\n * type(uint256).max. This reduces the gas costs without any likely impact.\\n */\\ncontract ERC20 is IERC20Metadata {\\n    uint256                                           internal  _totalSupply;\\n    mapping (address => uint256)                      internal  _balanceOf;\\n    mapping (address => mapping (address => uint256)) internal  _allowance;\\n    string                                            public override name = \\\"???\\\";\\n    string                                            public override symbol = \\\"???\\\";\\n    uint8                                             public override decimals = 18;\\n\\n    /**\\n     *  @dev Sets the values for {name}, {symbol} and {decimals}.\\n     */\\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\\n        name = name_;\\n        symbol = symbol_;\\n        decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() external view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address guy) external view virtual override returns (uint256) {\\n        return _balanceOf[guy];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) external view virtual override returns (uint256) {\\n        return _allowance[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     */\\n    function approve(address spender, uint wad) external virtual override returns (bool) {\\n        return _setAllowance(msg.sender, spender, wad);\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have a balance of at least `wad`.\\n     */\\n    function transfer(address dst, uint wad) external virtual override returns (bool) {\\n        return _transfer(msg.sender, dst, wad);\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `src` must have a balance of at least `wad`.\\n     * - the caller is not `src`, it must have allowance for ``src``'s tokens of at least\\n     * `wad`.\\n     */\\n    /// if_succeeds {:msg \\\"TransferFrom - decrease allowance\\\"} msg.sender != src ==> old(_allowance[src][msg.sender]) >= wad;\\n    function transferFrom(address src, address dst, uint wad) external virtual override returns (bool) {\\n        _decreaseAllowance(src, wad);\\n\\n        return _transfer(src, dst, wad);\\n    }\\n\\n    /**\\n     * @dev Moves tokens `wad` from `src` to `dst`.\\n     * \\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `src` must have a balance of at least `amount`.\\n     */\\n    /// if_succeeds {:msg \\\"Transfer - src decrease\\\"} old(_balanceOf[src]) >= _balanceOf[src];\\n    /// if_succeeds {:msg \\\"Transfer - dst increase\\\"} _balanceOf[dst] >= old(_balanceOf[dst]);\\n    /// if_succeeds {:msg \\\"Transfer - supply\\\"} old(_balanceOf[src]) + old(_balanceOf[dst]) == _balanceOf[src] + _balanceOf[dst];\\n    function _transfer(address src, address dst, uint wad) internal virtual returns (bool) {\\n        require(_balanceOf[src] >= wad, \\\"ERC20: Insufficient balance\\\");\\n        unchecked { _balanceOf[src] = _balanceOf[src] - wad; }\\n        _balanceOf[dst] = _balanceOf[dst] + wad;\\n\\n        emit Transfer(src, dst, wad);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Sets the allowance granted to `spender` by `owner`.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     */\\n    function _setAllowance(address owner, address spender, uint wad) internal virtual returns (bool) {\\n        _allowance[owner][spender] = wad;\\n        emit Approval(owner, spender, wad);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decreases the allowance granted to the caller by `src`, unless src == msg.sender or _allowance[src][msg.sender] == MAX\\n     *\\n     * Emits an {Approval} event indicating the updated allowance, if the allowance is updated.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` must have allowance for the caller of at least\\n     * `wad`, unless src == msg.sender\\n     */\\n    /// if_succeeds {:msg \\\"Decrease allowance - underflow\\\"} old(_allowance[src][msg.sender]) <= _allowance[src][msg.sender];\\n    function _decreaseAllowance(address src, uint wad) internal virtual returns (bool) {\\n        if (src != msg.sender) {\\n            uint256 allowed = _allowance[src][msg.sender];\\n            if (allowed != type(uint).max) {\\n                require(allowed >= wad, \\\"ERC20: Insufficient approval\\\");\\n                unchecked { _setAllowance(src, msg.sender, allowed - wad); }\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /** @dev Creates `wad` tokens and assigns them to `dst`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     */\\n    /// if_succeeds {:msg \\\"Mint - balance overflow\\\"} old(_balanceOf[dst]) >= _balanceOf[dst];\\n    /// if_succeeds {:msg \\\"Mint - supply overflow\\\"} old(_totalSupply) >= _totalSupply;\\n    function _mint(address dst, uint wad) internal virtual returns (bool) {\\n        _balanceOf[dst] = _balanceOf[dst] + wad;\\n        _totalSupply = _totalSupply + wad;\\n        emit Transfer(address(0), dst, wad);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Destroys `wad` tokens from `src`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `src` must have at least `wad` tokens.\\n     */\\n    /// if_succeeds {:msg \\\"Burn - balance underflow\\\"} old(_balanceOf[src]) <= _balanceOf[src];\\n    /// if_succeeds {:msg \\\"Burn - supply underflow\\\"} old(_totalSupply) <= _totalSupply;\\n    function _burn(address src, uint wad) internal virtual returns (bool) {\\n        unchecked {\\n            require(_balanceOf[src] >= wad, \\\"ERC20: Insufficient balance\\\");\\n            _balanceOf[src] = _balanceOf[src] - wad;\\n            _totalSupply = _totalSupply - wad;\\n            emit Transfer(src, address(0), wad);\\n        }\\n\\n        return true;\\n    }\\n}\"\r\n    },\r\n    \"@yield-protocol/utils-v2/src/token/IERC2612.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC2612 standard as defined in the EIP.\\n *\\n * Adds the {permit} method, which can be used to change one's\\n * {IERC20-allowance} without having to send a transaction, by signing a\\n * message. This allows users to spend tokens without having to hold Ether.\\n *\\n * See https://eips.ethereum.org/EIPS/eip-2612.\\n */\\ninterface IERC2612 {\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    /**\\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@yield-protocol/vault-v2/src/interfaces/IERC5095.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport \\\"@yield-protocol/utils-v2/src/token/IERC20.sol\\\";\\n\\ninterface IERC5095 is IERC20 {\\n    /// @dev Asset that is returned on redemption.\\n    function underlying() external view returns (address underlyingAddress);\\n\\n    /// @dev Unix time at which redemption of fyToken for underlying are possible\\n    function maturity() external view returns (uint256 timestamp);\\n\\n    /// @dev Converts a specified amount of principal to underlying\\n    function convertToUnderlying(uint256 principalAmount) external returns (uint256 underlyingAmount);\\n\\n    /// @dev Converts a specified amount of underlying to principal\\n    function convertToPrincipal(uint256 underlyingAmount) external returns (uint256 principalAmount);\\n\\n    /// @dev Gives the maximum amount an address holder can redeem in terms of the principal\\n    function maxRedeem(address holder) external view returns (uint256 maxPrincipalAmount);\\n\\n    /// @dev Gives the amount in terms of underlying that the princiapl amount can be redeemed for plus accrual\\n    function previewRedeem(uint256 principalAmount) external returns (uint256 underlyingAmount);\\n\\n    /// @dev Burn fyToken after maturity for an amount of principal.\\n    function redeem(uint256 principalAmount, address to, address from) external returns (uint256 underlyingAmount);\\n\\n    /// @dev Gives the maximum amount an address holder can withdraw in terms of the underlying\\n    function maxWithdraw(address holder) external returns (uint256 maxUnderlyingAmount);\\n\\n    /// @dev Gives the amount in terms of principal that the underlying amount can be withdrawn for plus accrual\\n    function previewWithdraw(uint256 underlyingAmount) external returns (uint256 principalAmount);\\n\\n    /// @dev Burn fyToken after maturity for an amount of underlying.\\n    function withdraw(uint256 underlyingAmount, address to, address from) external returns (uint256 principalAmount);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"@yield-protocol/utils-v2/src/token/SafeERC20Namer.sol\": {\r\n        \"SafeERC20Namer\": \"0x39bb9cBe0221D769E30bD08d185842065BcE1706\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes6\",\"name\":\"underlyingId_\",\"type\":\"bytes6\"},{\"internalType\":\"contract IOracle\",\"name\":\"oracle_\",\"type\":\"address\"},{\"internalType\":\"contract IJoin\",\"name\":\"join_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maturity_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"FlashFeeFactorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"param\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"Point\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"newAdminRole\",\"type\":\"bytes4\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chiAtMaturity\",\"type\":\"uint256\"}],\"name\":\"SeriesMatured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LOCK\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LOCK8605463013\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROOT\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROOT4146650865\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accrual\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chiAtMaturity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"convertToPrincipal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"}],\"name\":\"convertToUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deploymentChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"}],\"name\":\"flashFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flashFeeFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC3156FlashBorrower\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"flashLoan\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"roles\",\"type\":\"bytes4[]\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRoles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"join\",\"outputs\":[{\"internalType\":\"contract IJoin\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"}],\"name\":\"lockRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maturity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"maxFlashLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"maxRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxPrincipalAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"maxWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxUnderlyingAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"mintWithUnderlying\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"param\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"point\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"}],\"name\":\"previewRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"previewWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"roles\",\"type\":\"bytes4[]\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRoles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"flashFeeFactor_\",\"type\":\"uint256\"}],\"name\":\"setFlashFeeFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"},{\"internalType\":\"bytes4\",\"name\":\"adminRole\",\"type\":\"bytes4\"}],\"name\":\"setRoleAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingId\",\"outputs\":[{\"internalType\":\"bytes6\",\"name\":\"\",\"type\":\"bytes6\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FYToken", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "303000000000000000000000000000000000000000000000000000000000000000000000000000000000000053fba816bd69a7f2a096f58687f87dd3020d0d5c0000000000000000000000003bdb887dc46ec0e964df89ffe2980db0121f0fd000000000000000000000000000000000000000000000000000000000649eedf000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000a4659455448323330364200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a4659455448323330364200000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}