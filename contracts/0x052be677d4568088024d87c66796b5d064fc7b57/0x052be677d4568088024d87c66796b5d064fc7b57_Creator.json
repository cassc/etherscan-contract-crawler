{"SourceCode": "// File: Swivel-v4/src/interfaces/ICreator.sol\r\npragma solidity ^0.8.13;\r\n\r\ninterface ICreator {\r\n    function create(\r\n        uint8,\r\n        address,\r\n        uint256,\r\n        address,\r\n        address,\r\n        address,\r\n        string calldata,\r\n        string calldata,\r\n        uint8\r\n    ) external returns (address, address);\r\n\r\n    function setAdmin(address) external returns (bool);\r\n\r\n    function setMarketPlace(address) external returns (bool);\r\n}\r\n\r\n// File: Swivel-v4/src/interfaces/IRedeemer.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IRedeemer {\r\n    function authRedeem(\r\n        uint8,\r\n        address,\r\n        uint256,\r\n        address,\r\n        address,\r\n        uint256\r\n    ) external returns (uint256);\r\n\r\n    function rates(\r\n        uint8,\r\n        address,\r\n        uint256\r\n    ) external view returns (uint256, uint256);\r\n}\r\n\r\n// File: Swivel-v4/src/interfaces/IERC5095.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC5095 {\r\n    event Redeem(address indexed from, address indexed to, uint256 amount);\r\n\r\n    function maturity() external view returns (uint256);\r\n\r\n    function underlying() external view returns (address);\r\n\r\n    function convertToUnderlying(uint256) external view returns (uint256);\r\n\r\n    function convertToPrincipal(uint256) external view returns (uint256);\r\n\r\n    function maxRedeem(address) external view returns (uint256);\r\n\r\n    function previewRedeem(uint256) external view returns (uint256);\r\n\r\n    function maxWithdraw(address) external view returns (uint256);\r\n\r\n    function previewWithdraw(uint256) external view returns (uint256);\r\n\r\n    function withdraw(uint256, address, address) external returns (uint256);\r\n\r\n    function redeem(uint256, address, address) external returns (uint256);\r\n}\r\n\r\n// File: Swivel-v4/src/tokens/ERC20.sol\r\n\r\n\r\n// Inspired on token.sol from DappHub. Natspec adpated from OpenZeppelin.\r\n\r\npragma solidity 0.8.16;\r\n\r\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\r\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\r\ncontract ERC20 {\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 amount\r\n    );\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            METADATA STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint8 public immutable decimals;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                              ERC20 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            EIP-2612 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 internal immutable INITIAL_CHAIN_ID;\r\n\r\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\r\n\r\n    mapping(address => uint256) public nonces;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            CUSTOM ERRORS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    error Invalid(address signer, address owner);\r\n\r\n    error Deadline(uint256 deadline, uint256 timestamp);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n\r\n        INITIAL_CHAIN_ID = block.chainid;\r\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               ERC20 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function approve(\r\n        address spender,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        balanceOf[msg.sender] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(msg.sender, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\r\n\r\n        if (allowed != type(uint256).max)\r\n            allowance[from][msg.sender] = allowed - amount;\r\n\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             EIP-2612 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        if (deadline < block.timestamp) {\r\n            revert Deadline(deadline, block.timestamp);\r\n        }\r\n        // Unchecked because the only math done is incrementing\r\n        // the owner's nonce which cannot realistically overflow.\r\n        unchecked {\r\n            address recoveredAddress = ecrecover(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        '\\x19\\x01',\r\n                        DOMAIN_SEPARATOR(),\r\n                        keccak256(\r\n                            abi.encode(\r\n                                keccak256(\r\n                                    'Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)'\r\n                                ),\r\n                                owner,\r\n                                spender,\r\n                                value,\r\n                                nonces[owner]++,\r\n                                deadline\r\n                            )\r\n                        )\r\n                    )\r\n                ),\r\n                v,\r\n                r,\r\n                s\r\n            );\r\n\r\n            if (recoveredAddress == address(0) || recoveredAddress != owner) {\r\n                revert Invalid(msg.sender, owner);\r\n            }\r\n\r\n            allowance[recoveredAddress][spender] = value;\r\n        }\r\n\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\r\n        return\r\n            block.chainid == INITIAL_CHAIN_ID\r\n                ? INITIAL_DOMAIN_SEPARATOR\r\n                : computeDomainSeparator();\r\n    }\r\n\r\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    keccak256(\r\n                        'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\r\n                    ),\r\n                    keccak256(bytes(name)),\r\n                    keccak256('1'),\r\n                    block.chainid,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        INTERNAL MINT/BURN LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _mint(address to, uint256 amount) internal virtual {\r\n        totalSupply += amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    function _burn(address from, uint256 amount) internal virtual {\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot underflow because a user's balance\r\n        // will never be larger than the total supply.\r\n        unchecked {\r\n            totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n}\r\n\r\n// File: Swivel-v4/src/tokens/ZcToken.sol\r\n\r\n\r\n\r\npragma solidity 0.8.16;\r\n\r\n\r\n\r\n\r\ncontract ZcToken is ERC20, IERC5095 {\r\n    /// @dev unix timestamp when the ERC5095 token can be redeemed\r\n    uint256 public immutable override maturity;\r\n    /// @dev address of the ERC20 token that is returned on ERC5095 redemption\r\n    address public immutable override underlying;\r\n    /// @dev uint8 associated with a given protocol in Swivel\r\n    uint8 public immutable protocol;\r\n\r\n    /////////////OPTIONAL///////////////// (Allows the calculation and distribution of yield post maturity)\r\n    /// @dev address of a cToken\r\n    address public immutable cToken;\r\n    /// @dev address and interface for an external custody contract (necessary for some project's backwards compatability)\r\n    address public immutable redeemer;\r\n\r\n    error Maturity(uint256 timestamp);\r\n\r\n    error Approvals(uint256 approved, uint256 amount);\r\n\r\n    error Authorized(address owner);\r\n\r\n    constructor(\r\n        uint8 _protocol,\r\n        address _underlying,\r\n        uint256 _maturity,\r\n        address _cToken,\r\n        address _redeemer,\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals\r\n    ) ERC20(_name, _symbol, _decimals) {\r\n        protocol = _protocol;\r\n        underlying = _underlying;\r\n        maturity = _maturity;\r\n        cToken = _cToken;\r\n        redeemer = _redeemer;\r\n    }\r\n\r\n    /// @notice Post maturity converts an amount of principal tokens to an amount of underlying that would be returned. Returns 0 pre-maturity.\r\n    /// @param principalAmount The amount of principal tokens to convert\r\n    /// @return The amount of underlying tokens returned by the conversion\r\n    function convertToUnderlying(\r\n        uint256 principalAmount\r\n    ) external view override returns (uint256) {\r\n        if (block.timestamp < maturity) {\r\n            return 0;\r\n        }\r\n\r\n        // note that maturity rate (mRate) == exchangeRate (xRate) if the mRate would have been 0 (see VaultTracker.rates)\r\n        (uint256 mRate, uint256 xRate) = IRedeemer(redeemer).rates(\r\n            protocol,\r\n            underlying,\r\n            maturity\r\n        );\r\n\r\n        return (principalAmount * xRate) / mRate;\r\n    }\r\n\r\n    /// @notice Post maturity converts a desired amount of underlying tokens returned to principal tokens needed. Returns 0 pre-maturity.\r\n    /// @param underlyingAmount The amount of underlying tokens to convert\r\n    /// @return The amount of principal tokens returned by the conversion\r\n    function convertToPrincipal(\r\n        uint256 underlyingAmount\r\n    ) external view override returns (uint256) {\r\n        if (block.timestamp < maturity) {\r\n            return 0;\r\n        }\r\n\r\n        // note that maturity rate (mRate) == exchangeRate (xRate) if the mRate would have been 0 (see VaultTracker.rates)\r\n        (uint256 mRate, uint256 xRate) = IRedeemer(redeemer).rates(\r\n            protocol,\r\n            underlying,\r\n            maturity\r\n        );\r\n\r\n        return (underlyingAmount * mRate) / xRate;\r\n    }\r\n\r\n    /// @notice Post maturity calculates the amount of principal tokens that `owner` can redeem. Returns 0 pre-maturity.\r\n    /// @param owner The address of the owner for which redemption is calculated\r\n    /// @return The maximum amount of principal tokens that `owner` can redeem.\r\n    function maxRedeem(address owner) external view override returns (uint256) {\r\n        if (block.timestamp < maturity) {\r\n            return 0;\r\n        }\r\n        return balanceOf[owner];\r\n    }\r\n\r\n    /// @notice Post maturity simulates the effects of redeemption at the current block. Returns 0 pre-maturity.\r\n    /// @param principalAmount the amount of principal tokens redeemed in the simulation\r\n    /// @return The maximum amount of underlying returned by `principalAmount` of PT redemption\r\n    function previewRedeem(\r\n        uint256 principalAmount\r\n    ) external view override returns (uint256) {\r\n        if (block.timestamp < maturity) {\r\n            return 0;\r\n        }\r\n\r\n        // note that maturity rate (mRate) == exchangeRate (xRate) if the mRate would have been 0 (see VaultTracker.rates)\r\n        (uint256 mRate, uint256 xRate) = IRedeemer(redeemer).rates(\r\n            protocol,\r\n            underlying,\r\n            maturity\r\n        );\r\n\r\n        return (principalAmount * xRate) / mRate;\r\n    }\r\n\r\n    /// @notice Post maturity calculates the amount of underlying tokens that `owner` can withdraw. Returns 0 pre-maturity.\r\n    /// @param  owner The address of the owner for which withdrawal is calculated\r\n    /// @return The maximum amount of underlying tokens that `owner` can withdraw.\r\n    function maxWithdraw(\r\n        address owner\r\n    ) external view override returns (uint256) {\r\n        if (block.timestamp < maturity) {\r\n            return 0;\r\n        }\r\n\r\n        // note that maturity rate (mRate) == exchangeRate (xRate) if the mRate would have been 0 (see VaultTracker.rates)\r\n        (uint256 mRate, uint256 xRate) = IRedeemer(redeemer).rates(\r\n            protocol,\r\n            underlying,\r\n            maturity\r\n        );\r\n\r\n        return (balanceOf[owner] * xRate) / mRate;\r\n    }\r\n\r\n    /// @notice Post maturity simulates the effects of withdrawal at the current block. Returns 0 pre-maturity.\r\n    /// @param underlyingAmount the amount of underlying tokens withdrawn in the simulation\r\n    /// @return The amount of principal tokens required for the withdrawal of `underlyingAmount`\r\n    function previewWithdraw(\r\n        uint256 underlyingAmount\r\n    ) public view override returns (uint256) {\r\n        if (block.timestamp < maturity) {\r\n            return 0;\r\n        }\r\n\r\n        // note that maturity rate (mRate) == exchangeRate (xRate) if the mRate would have been 0 (see VaultTracker.rates)\r\n        (uint256 mRate, uint256 xRate) = IRedeemer(redeemer).rates(\r\n            protocol,\r\n            underlying,\r\n            maturity\r\n        );\r\n\r\n        return (underlyingAmount * mRate) / xRate;\r\n    }\r\n\r\n    /// @notice At or after maturity, Burns principalAmount from `owner` and sends exactly `underlyingAmount` of underlying tokens to `receiver`.\r\n    /// @param underlyingAmount The amount of underlying tokens withdrawn\r\n    /// @param receiver The receiver of the underlying tokens being withdrawn\r\n    /// @return The amount of principal tokens burnt by the withdrawal\r\n    function withdraw(\r\n        uint256 underlyingAmount,\r\n        address receiver,\r\n        address holder\r\n    ) external override returns (uint256) {\r\n        // If maturity is not yet reached. TODO this is moved from underneath the previewAmount call - should have been here before? Discuss.\r\n        if (block.timestamp < maturity) {\r\n            revert Maturity(maturity);\r\n        }\r\n\r\n        // TODO removing both the `this.foo` and `external` bits of this pattern as it's simply an unnecessary misdirection. Discuss.\r\n        uint256 previewAmount = previewWithdraw(underlyingAmount);\r\n\r\n        // Transfer logic: If holder is msg.sender, skip approval check\r\n        if (holder == msg.sender) {\r\n            IRedeemer(redeemer).authRedeem(\r\n                protocol,\r\n                underlying,\r\n                maturity,\r\n                msg.sender,\r\n                receiver,\r\n                previewAmount\r\n            );\r\n        } else {\r\n            uint256 allowed = allowance[holder][msg.sender];\r\n            if (allowed < previewAmount) {\r\n                revert Approvals(allowed, previewAmount);\r\n            }\r\n            allowance[holder][msg.sender] =\r\n                allowance[holder][msg.sender] -\r\n                previewAmount;\r\n            IRedeemer(redeemer).authRedeem(\r\n                protocol,\r\n                underlying,\r\n                maturity,\r\n                holder,\r\n                receiver,\r\n                previewAmount\r\n            );\r\n        }\r\n\r\n        return previewAmount;\r\n    }\r\n\r\n    /// @notice At or after maturity, burns exactly `principalAmount` of Principal Tokens from `owner` and sends underlyingAmount of underlying tokens to `receiver`.\r\n    /// @param principalAmount The amount of principal tokens being redeemed\r\n    /// @param receiver The receiver of the underlying tokens being withdrawn\r\n    /// @return The amount of underlying tokens distributed by the redemption\r\n    function redeem(\r\n        uint256 principalAmount,\r\n        address receiver,\r\n        address holder\r\n    ) external override returns (uint256) {\r\n        // If maturity is not yet reached\r\n        if (block.timestamp < maturity) {\r\n            revert Maturity(maturity);\r\n        }\r\n\r\n        // some 5095 tokens may have custody of underlying and can can just burn PTs and transfer underlying out, while others rely on external custody\r\n        if (holder == msg.sender) {\r\n            return\r\n                IRedeemer(redeemer).authRedeem(\r\n                    protocol,\r\n                    underlying,\r\n                    maturity,\r\n                    msg.sender,\r\n                    receiver,\r\n                    principalAmount\r\n                );\r\n        } else {\r\n            uint256 allowed = allowance[holder][msg.sender];\r\n\r\n            if (allowed < principalAmount) {\r\n                revert Approvals(allowed, principalAmount);\r\n            }\r\n\r\n            allowance[holder][msg.sender] =\r\n                allowance[holder][msg.sender] -\r\n                principalAmount;\r\n            return\r\n                IRedeemer(redeemer).authRedeem(\r\n                    protocol,\r\n                    underlying,\r\n                    maturity,\r\n                    holder,\r\n                    receiver,\r\n                    principalAmount\r\n                );\r\n        }\r\n    }\r\n\r\n    /// @param f Address to burn from\r\n    /// @param a Amount to burn\r\n    function burn(\r\n        address f,\r\n        uint256 a\r\n    ) external onlyAdmin(address(redeemer)) returns (bool) {\r\n        _burn(f, a);\r\n        return true;\r\n    }\r\n\r\n    /// @param t Address recieving the minted amount\r\n    /// @param a The amount to mint\r\n    function mint(\r\n        address t,\r\n        uint256 a\r\n    ) external onlyAdmin(address(redeemer)) returns (bool) {\r\n        // disallow minting post maturity\r\n        if (block.timestamp > maturity) {\r\n            revert Maturity(maturity);\r\n        }\r\n        _mint(t, a);\r\n        return true;\r\n    }\r\n\r\n    modifier onlyAdmin(address a) {\r\n        if (msg.sender != a) {\r\n            revert Authorized(a);\r\n        }\r\n        _;\r\n    }\r\n}\r\n\r\n// File: Swivel-v4/src/interfaces/IAdapter.sol\r\n\r\n\r\n\r\npragma solidity 0.8.16;\r\n\r\ninterface IAdapter {\r\n    function underlying(address) external view returns (address);\r\n\r\n    function exchangeRate(address) external view returns (uint256);\r\n\r\n    function deposit(address, uint256) external returns (uint256);\r\n\r\n    function withdraw(address, uint256) external returns (uint256);\r\n}\r\n\r\n// File: Swivel-v4/src/interfaces/IVaultTracker.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.13;\r\n\r\ninterface IVaultTracker {\r\n    function addNotional(address, uint256) external returns (bool);\r\n\r\n    function removeNotional(address, uint256) external returns (bool);\r\n\r\n    function redeemInterest(address) external returns (uint256);\r\n\r\n    function matureVault(uint256) external returns (bool);\r\n\r\n    function transferNotionalFrom(\r\n        address,\r\n        address,\r\n        uint256\r\n    ) external returns (bool);\r\n\r\n    function transferNotionalFee(address, uint256) external returns (bool);\r\n\r\n    function rates() external view returns (uint256, uint256);\r\n\r\n    function balancesOf(address) external view returns (uint256, uint256);\r\n\r\n    function setAdapter(address) external;\r\n\r\n    function adapter() external view returns (address);\r\n}\r\n\r\n// File: Swivel-v4/src/VaultTracker.sol\r\n\r\n\r\n\r\npragma solidity 0.8.16;\r\n\r\n\r\n\r\ncontract VaultTracker is IVaultTracker {\r\n    /// @notice A single custom error capable of indicating a wide range of detected errors by providing\r\n    /// an error code value whose string representation is documented <here>, and any possible other values\r\n    /// that are pertinent to the error.\r\n    error Exception(uint8, uint256, uint256, address, address);\r\n\r\n    struct Vault {\r\n        uint256 notional;\r\n        uint256 redeemable;\r\n        uint256 exchangeRate;\r\n        uint256 accrualBlock;\r\n    }\r\n\r\n    mapping(address => Vault) public vaults;\r\n\r\n    address public immutable cTokenAddr;\r\n    address public immutable marketPlace;\r\n    address public immutable swivel;\r\n    uint256 public immutable maturity;\r\n    address public adapter;\r\n    uint256 public maturityRate;\r\n    uint8 public immutable protocol;\r\n\r\n    /// @param p Protocol enum value for this vault\r\n    /// @param m Maturity timestamp associated with this vault\r\n    /// @param a Address of the adapter for this market\r\n    /// @param c Compounding Token address associated with this vault\r\n    /// @param s Address of the deployed swivel contract\r\n    /// @param mp Address of the designated admin, which is the Marketplace addess stored by the Creator contract\r\n    constructor(\r\n        uint8 p,\r\n        uint256 m,\r\n        address a,\r\n        address c,\r\n        address s,\r\n        address mp\r\n    ) {\r\n        protocol = p;\r\n        maturity = m;\r\n        cTokenAddr = c;\r\n        swivel = s;\r\n        marketPlace = mp;\r\n        adapter = a;\r\n\r\n        // instantiate swivel's vault (unblocking transferNotionalFee)\r\n        vaults[s] = Vault({\r\n            notional: 0,\r\n            redeemable: 0,\r\n            exchangeRate: IAdapter(a).exchangeRate(cTokenAddr),\r\n            accrualBlock: block.number\r\n        });\r\n    }\r\n\r\n    /// @notice Adds notional to a given address\r\n    /// @param o Address that owns a vault\r\n    /// @param a Amount of notional added\r\n    function addNotional(\r\n        address o,\r\n        uint256 a\r\n    ) external authorized(marketPlace) returns (bool) {\r\n        Vault memory vlt = vaults[o];\r\n\r\n        if (vlt.notional > 0) {\r\n            // If marginal interest has not been calculated up to the current block, calculate marginal interest and update exchangeRate + accrualBlock\r\n            if (vlt.accrualBlock != block.number) {\r\n                // note that mRate is is maturityRate if > 0, exchangeRate otherwise\r\n                (uint256 mRate, uint256 xRate) = rates();\r\n                // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\r\n                // otherwise, calculate marginal exchange rate between current and previous exchange rate.\r\n                uint256 yield = ((mRate * 1e26) / vlt.exchangeRate) - 1e26;\r\n                uint256 interest = (yield * (vlt.notional + vlt.redeemable)) /\r\n                    1e26;\r\n                // add interest and amount to position, reset cToken exchange rate\r\n                vlt.redeemable = vlt.redeemable + interest;\r\n                // set vault's exchange rate to the lower of (maturityRate, exchangeRate) if vault has matured, otherwise exchangeRate\r\n                vlt.exchangeRate = mRate < xRate ? mRate : xRate;\r\n                // set vault's accrual block to the current block\r\n                vlt.accrualBlock = block.number;\r\n            }\r\n            vlt.notional = vlt.notional + a;\r\n        } else {\r\n            // note that mRate is is maturityRate if > 0, exchangeRate otherwise\r\n            (uint256 mRate, uint256 xRate) = rates();\r\n            // set notional\r\n            vlt.notional = a;\r\n            // set vault's exchange rate to the lower of (maturityRate, exchangeRate) if vault has matured, otherwise exchangeRate\r\n            vlt.exchangeRate = mRate < xRate ? mRate : xRate;\r\n            // set vault's accrual block to the current block\r\n            vlt.accrualBlock = block.number;\r\n        }\r\n\r\n        vaults[o] = vlt;\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Removes notional from a given address\r\n    /// @param o Address that owns a vault\r\n    /// @param a Amount of notional to remove\r\n    function removeNotional(\r\n        address o,\r\n        uint256 a\r\n    ) external authorized(marketPlace) returns (bool) {\r\n        Vault memory vlt = vaults[o];\r\n\r\n        if (a > vlt.notional) {\r\n            revert Exception(31, a, vlt.notional, o, address(0));\r\n        }\r\n\r\n        if (vlt.accrualBlock != block.number) {\r\n            // note that mRate is is maturityRate if > 0, exchangeRate otherwise\r\n            (uint256 mRate, uint256 xRate) = rates();\r\n\r\n            // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\r\n            // otherwise, calculate marginal exchange rate between current and previous exchange rate.\r\n            uint256 yield = ((mRate * 1e26) / vlt.exchangeRate) - 1e26;\r\n            uint256 interest = (yield * (vlt.notional + vlt.redeemable)) / 1e26;\r\n            // remove amount from position, Add interest to position, reset cToken exchange rate\r\n            vlt.redeemable = vlt.redeemable + interest;\r\n            // set vault's exchange rate to the lower of (maturityRate, exchangeRate) if vault has matured, otherwise exchangeRate\r\n            vlt.exchangeRate = maturityRate < xRate ? mRate : xRate;\r\n            // set vault's accrual block to the current block\r\n            vlt.accrualBlock = block.number;\r\n        }\r\n        vlt.notional = vlt.notional - a;\r\n\r\n        vaults[o] = vlt;\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Redeem's interest accrued by a given address\r\n    /// @param o Address that owns a vault\r\n    function redeemInterest(\r\n        address o\r\n    ) external authorized(marketPlace) returns (uint256) {\r\n        Vault memory vlt = vaults[o];\r\n\r\n        uint256 redeemable = vlt.redeemable;\r\n\r\n        if (vlt.accrualBlock != block.number) {\r\n            // note that mRate is is maturityRate if > 0, exchangeRate otherwise\r\n            (uint256 mRate, uint256 xRate) = rates();\r\n\r\n            // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\r\n            // otherwise, calculate marginal exchange rate between current and previous exchange rate.\r\n            uint256 yield = ((mRate * 1e26) / vlt.exchangeRate) - 1e26;\r\n            uint256 interest = (yield * (vlt.notional + vlt.redeemable)) / 1e26;\r\n\r\n            vlt.exchangeRate = mRate < xRate ? mRate : xRate;\r\n            vlt.accrualBlock = block.number;\r\n            // adds marginal interest to previously accrued redeemable interest\r\n            redeemable += interest;\r\n        }\r\n        vlt.redeemable = 0;\r\n\r\n        vaults[o] = vlt;\r\n\r\n        // returns current redeemable if already accrued, redeemable + interest if not\r\n        return redeemable;\r\n    }\r\n\r\n    /// @notice Matures the vault\r\n    /// @param c The current cToken exchange rate\r\n    function matureVault(\r\n        uint256 c\r\n    ) external authorized(marketPlace) returns (bool) {\r\n        maturityRate = c;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Transfers notional from one address to another\r\n    /// @param f Owner of the amount\r\n    /// @param t Recipient of the amount\r\n    /// @param a Amount to transfer\r\n    function transferNotionalFrom(\r\n        address f,\r\n        address t,\r\n        uint256 a\r\n    ) external authorized(marketPlace) returns (bool) {\r\n        if (f == t) {\r\n            revert Exception(32, 0, 0, f, t);\r\n        }\r\n\r\n        Vault memory from = vaults[f];\r\n\r\n        if (a > from.notional) {\r\n            revert Exception(31, a, from.notional, f, t);\r\n        }\r\n\r\n        if (from.accrualBlock != block.number) {\r\n            // note that mRate is is maturityRate if > 0, exchangeRate otherwise\r\n            (uint256 mRate, uint256 xRate) = rates();\r\n            // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\r\n            // otherwise, calculate marginal exchange rate between current and previous exchange rate.\r\n            uint256 yield = ((mRate * 1e26) / from.exchangeRate) - 1e26;\r\n            uint256 interest = (yield * (from.notional + from.redeemable)) /\r\n                1e26;\r\n            // remove amount from position, Add interest to position, reset cToken exchange rate\r\n            from.redeemable = from.redeemable + interest;\r\n            from.exchangeRate = mRate < xRate ? mRate : xRate;\r\n            from.accrualBlock = block.number;\r\n        }\r\n        from.notional = from.notional - a;\r\n        vaults[f] = from;\r\n\r\n        Vault memory to = vaults[t];\r\n\r\n        // transfer notional to address \"t\", calculate interest if necessary\r\n        if (to.notional > 0) {\r\n            // if interest hasnt been calculated within the block, calculate it\r\n            if (from.accrualBlock != block.number) {\r\n                // note that mRate is is maturityRate if > 0, exchangeRate otherwise\r\n                (uint256 mRate, uint256 xRate) = rates();\r\n                uint256 yield = ((mRate * 1e26) / to.exchangeRate) - 1e26;\r\n                uint256 interest = (yield * (to.notional + to.redeemable)) /\r\n                    1e26;\r\n                // add interest and amount to position, reset cToken exchange rate\r\n                to.redeemable = to.redeemable + interest;\r\n                to.exchangeRate = mRate < xRate ? mRate : xRate;\r\n                to.accrualBlock = block.number;\r\n            }\r\n            to.notional = to.notional + a;\r\n        } else {\r\n            // note that mRate is is maturityRate if > 0, exchangeRate otherwise\r\n            (uint256 mRate, uint256 xRate) = rates();\r\n            to.notional = a;\r\n            to.exchangeRate = mRate < xRate ? mRate : xRate;\r\n            to.accrualBlock = block.number;\r\n        }\r\n\r\n        vaults[t] = to;\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Transfers, in notional, a fee payment to the Swivel contract without recalculating marginal interest for the owner\r\n    /// @param f Owner of the amount\r\n    /// @param a Amount to transfer\r\n    function transferNotionalFee(\r\n        address f,\r\n        uint256 a\r\n    ) external authorized(marketPlace) returns (bool) {\r\n        Vault memory oVault = vaults[f];\r\n\r\n        if (a > oVault.notional) {\r\n            revert Exception(31, a, oVault.notional, f, address(0));\r\n        }\r\n        // remove notional from its owner, marginal interest has been calculated already in the tx\r\n        oVault.notional = oVault.notional - a;\r\n\r\n        Vault memory sVault = vaults[swivel];\r\n\r\n        // check if exchangeRate has been stored already this block. If not, calculate marginal interest + store exchangeRate\r\n        if (sVault.accrualBlock != block.number) {\r\n            // note that mRate is is maturityRate if > 0, exchangeRate otherwise\r\n            (uint256 mRate, uint256 xRate) = rates();\r\n            // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\r\n            // otherwise, calculate marginal exchange rate between current and previous exchange rate.\r\n            uint256 yield = ((mRate * 1e26) / sVault.exchangeRate) - 1e26;\r\n            uint256 interest = (yield * (sVault.notional + sVault.redeemable)) /\r\n                1e26;\r\n            // add interest and amount, reset cToken exchange rate\r\n            sVault.redeemable = sVault.redeemable + interest;\r\n            // set to maturityRate only if both > 0 && < exchangeRate\r\n            sVault.exchangeRate = (mRate < xRate) ? mRate : xRate;\r\n            // set current accrual block\r\n            sVault.accrualBlock = block.number;\r\n        }\r\n        // add notional to swivel's vault\r\n        sVault.notional = sVault.notional + a;\r\n        // store the adjusted vaults\r\n        vaults[swivel] = sVault;\r\n        vaults[f] = oVault;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Return both the current maturityRate if it's > 0 (or exchangeRate in its place) and the Compounding exchange rate\r\n    /// @dev While it may seem unnecessarily redundant to return the exchangeRate twice, it prevents many kludges that would otherwise be necessary to guard it\r\n    /// @return maturityRate, exchangeRate if maturityRate > 0, exchangeRate, exchangeRate if not.\r\n    function rates() public view returns (uint256, uint256) {\r\n        uint256 exchangeRate = IAdapter(adapter).exchangeRate(cTokenAddr);\r\n        return ((maturityRate > 0 ? maturityRate : exchangeRate), exchangeRate);\r\n    }\r\n\r\n    /// @notice Returns both relevant balances for a given user's vault\r\n    /// @param o Address that owns a vault\r\n    function balancesOf(address o) external view returns (uint256, uint256) {\r\n        Vault memory vault = vaults[o];\r\n        return (vault.notional, vault.redeemable);\r\n    }\r\n\r\n    /// @notice Allows the marketplace to set a new adapter for the market\r\n    /// @param a Address of a new adapter contract\r\n    function setAdapter(address a) external authorized(marketPlace) {\r\n        adapter = a;\r\n    }\r\n\r\n    modifier authorized(address a) {\r\n        if (msg.sender != a) {\r\n            revert Exception(0, 0, 0, msg.sender, a);\r\n        }\r\n        _;\r\n    }\r\n}\r\n\r\n// File: Swivel-v4/src/Creator.sol\r\n\r\n\r\n\r\npragma solidity 0.8.16;\r\n\r\n\r\n\r\n\r\ncontract Creator is ICreator {\r\n    /// @dev A single custom error capable of indicating a wide range of detected errors by providing\r\n    /// an error code value whose string representation is documented <here>, and any possible other values\r\n    /// that are pertinent to the error.\r\n    error Exception(uint8, uint256, uint256, address, address);\r\n\r\n    address public admin;\r\n    address public marketPlace;\r\n\r\n    event SetAdmin(address indexed admin);\r\n\r\n    constructor() {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    /// @notice Allows the owner to create new markets\r\n    /// @param p Protocol associated with the new market\r\n    /// @param u Underlying token associated with the new market\r\n    /// @param m Maturity timestamp of the new market\r\n    /// @param a Adapter address of the new market\r\n    /// @param c Compounding Token address associated with the new market\r\n    /// @param sw Address of the deployed swivel contract\r\n    /// @param n Name of the new market zcToken\r\n    /// @param s Symbol of the new market zcToken\r\n    /// @param d Decimals of the new market zcToken\r\n    function create(\r\n        uint8 p,\r\n        address u,\r\n        uint256 m,\r\n        address a,\r\n        address c,\r\n        address sw,\r\n        string calldata n,\r\n        string calldata s,\r\n        uint8 d\r\n    ) external authorized(marketPlace) returns (address, address) {\r\n        if (marketPlace == address(0)) {\r\n            revert Exception(34, 0, 0, marketPlace, address(0));\r\n        }\r\n\r\n        address zct = address(new ZcToken(p, u, m, c, marketPlace, n, s, d));\r\n        address tracker = address(\r\n            new VaultTracker(p, m, a, c, sw, marketPlace)\r\n        );\r\n\r\n        return (zct, tracker);\r\n    }\r\n\r\n    /// @param a Address of a new admin\r\n    function setAdmin(address a) external authorized(admin) returns (bool) {\r\n        admin = a;\r\n\r\n        emit SetAdmin(a);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @param m Address of the deployed marketPlace contract\r\n    /// @notice We only allow this to be set once\r\n    /// @dev there is no emit here as it's only done once post deploy by the deploying admin\r\n    function setMarketPlace(\r\n        address m\r\n    ) external authorized(admin) returns (bool) {\r\n        if (marketPlace != address(0)) {\r\n            revert Exception(33, 0, 0, marketPlace, address(0));\r\n        }\r\n\r\n        marketPlace = m;\r\n        return true;\r\n    }\r\n\r\n    modifier authorized(address a) {\r\n        if (msg.sender != a) {\r\n            revert Exception(0, 0, 0, msg.sender, a);\r\n        }\r\n        _;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Exception\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"SetAdmin\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"c\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sw\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"n\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"s\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"d\",\"type\":\"uint8\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketPlace\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"m\",\"type\":\"address\"}],\"name\":\"setMarketPlace\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Creator", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://61745ec04bc24da6ab65fca42c0d971c75f5233686e0ce6aea0d4504987eb419"}