{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/DarkTalanji.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.22;\\n\\nimport \\\".././lib/openzeppelin-contracts/contracts/access/Ownable.sol\\\";\\n\\ninterface IERC721 {\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n    function balanceOf(address owner) external view returns (uint256);\\n}\\n\\ninterface IWrapper {\\n    function transferFromBatch(address from, address to, uint256[] calldata tokenId) external;\\n}\\n\\ninterface ISoulsLocker {\\n    function getSoulsInHero(uint256 heroId) external view returns (uint16[] memory);\\n}\\n\\ninterface IExpManager {\\n    function creditExperience(uint256 heroId, uint64 expToCredit, uint256 minterIdx) external;\\n}\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)\\n        external\\n        returns (bytes4);\\n}\\n\\ninterface IERC1155 {\\n    function mint(address to, uint256 id, uint256 amount, bytes calldata data, uint256 minterIdx) external;\\n}\\n\\n/// @title Dark Talanji\\n/// @author Mauro\\n/// @notice Implementation of Dark Talanji - The Spirit Devourer Contract\\ncontract DarkTalanji is Ownable {\\n    event SpiritsSacrificed(uint256 indexed heroId, uint256[] tokenId, uint256 expCredited);\\n\\n    // Le Anime v2 tokenId offset (tokenId = editionNr + OFFSETAN2)\\n    uint256 private constant OFFSETAN2 = 100000;\\n\\n    // EXP Minter index in the Experience Manager Contract\\n    uint256 public constant EXP_MINTER_IDX = 0;\\n\\n    // Editions Minter index in the ERC1155 Contract\\n    uint256 public constant EDITIONS_MINTER_IDX = 1;\\n\\n    // SuperRare Original Talanji NFT Contract and ID\\n    address public constant SUPERRARE = 0xb932a70A57673d89f4acfFBE830E8ed7f75Fb9e0;\\n\\n    uint256 public constant TALANJI_ID = 17686;\\n\\n    // New Dark Talanji NFT Contract and ID (toomuchlag 1/1s Contract)\\n    address public constant TML = 0x0e847aAd9B5b25CEa58613851199484BE3C4Fa13;\\n\\n    uint256 public constant DARKTALANJI_ID = 4;\\n\\n    // Number of Spirits sacrificed to unlock the original Talanji\\n    uint256 public constant OG_UNLOCK_NUM = 2020;\\n\\n    // Number of Spirits to cap limited edition mint\\n    uint256 public constant PRIME_SACRIFICE = 250;\\n\\n    // Le Anime Contracts (Main ERC721, NFT Locker, and Exp Manager, 1155 Editions)\\n    address public immutable wrapper;\\n    address public immutable locker;\\n    address public immutable expManager;\\n    address public immutable editions;\\n\\n    // Scores of Le Anime characters stored via SSTORE2\\n    address public immutable pointerScores;\\n\\n    // Experience start and end timestamps\\n    uint64 public immutable expStart;\\n    uint64 public immutable expEnd;\\n\\n    bool public sacrificeActive;\\n\\n    constructor() {\\n        // mainnet\\n        wrapper = 0x03BEbcf3D62C1e7465f8a095BFA08a79CA2892A1;\\n        locker = 0x1eb4490091bd0fFF6c3973623C014D082936EA03;\\n        expManager = 0x55124b7C32Ab50932725ec6e34bDB53725e2bbd2;\\n        pointerScores = 0xB6c6De2C865bC497A5CF8A9480Dd2e67504425ae;\\n        editions = 0xfb0EcD5d5cAD8E498f49000A6CE5423763b039EC;\\n\\n        expStart = uint64(1651738261); // 5 May 2022\\n        expEnd = uint64(1735689599); // 31 Dec 2024\\n    }\\n\\n    /////////////\\n    // ADMIN FUNCTIONS\\n    /////////////\\n\\n    /// @notice Activate the Sacrifice - owner only\\n    /// @param activate set true to activate the Sacrifice\\n    function activateSacrifice(bool activate) external onlyOwner {\\n        sacrificeActive = activate;\\n    }\\n\\n    /// @notice Withdraw the original Talanji - contract owner only + owner of dark talanji - to be renounced and deactivated\\n    function ownerWithdrawTalanji() external onlyOwner {\\n        require(IERC721(TML).ownerOf(DARKTALANJI_ID) == msg.sender, \\\"Not the owner of Dark Talanji\\\");\\n\\n        IERC721(SUPERRARE).transferFrom(address(this), msg.sender, TALANJI_ID);\\n    }\\n\\n    /////////////\\n    // REDEEM TALANJI - DARK TALANJI OWNER ONLY\\n    /////////////\\n\\n    /// @notice Redeem the OG SuperRare Talanji. Only if balance of this contract >= threshold (2020 NFTs from the collection)\\n    function redeemOGTalanji() external {\\n        require(IERC721(wrapper).balanceOf(address(this)) >= OG_UNLOCK_NUM, \\\"Not unlocked\\\");\\n\\n        require(IERC721(TML).ownerOf(DARKTALANJI_ID) == msg.sender, \\\"Not the owner of Dark Talanji\\\");\\n\\n        IERC721(SUPERRARE).transferFrom(address(this), msg.sender, TALANJI_ID);\\n    }\\n\\n    /////////////\\n    // SPIRIT TO EXP FUNCTIONS\\n    /////////////\\n\\n    /// @notice Sacrifice Spirits in exchange for EXP in your Hero\\n    /// @param heroId Hero that will receive EXP\\n    /// @param tokenId IDs of Spirits to Sacrifice\\n    function spiritsToExp(uint256 heroId, uint256[] calldata tokenId) external {\\n        require(sacrificeActive, \\\"Not Active\\\");\\n        require(ISoulsLocker(locker).getSoulsInHero(heroId).length > 0, \\\"Not a merged Hero\\\");\\n\\n        // Load on-chain Scores of all 10627 tokenIds\\n        // each byte is the score of a Soul/Spirits\\n        // allData[id - 1] is the score of Soul/Spirit #id\\n        bytes memory allData;\\n\\n        // address of the contract storing Scores data\\n        address pointer = pointerScores;\\n\\n        // efficently load all scores from external storage contract\\n        // assembly adapted from SSTORE2 code (https://github.com/0xsequence/sstore2)\\n        assembly {\\n            // Get the pointer to the free memory and allocate\\n            allData := mload(0x40)\\n\\n            // Update the free memory pointer to prevent overriding our data.\\n            // Allocate enough 32-byte words for the data and the length of the data\\n            // This is the new \\\"memory end\\\" including padding\\n            // mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\\n            mstore(0x40, add(allData, 10688))\\n\\n            // Store the size of the data in the first 32 byte chunk of free memory.\\n            mstore(allData, 10627)\\n\\n            // Copy the code into memory right after the 32 bytes used to store the size.\\n            extcodecopy(pointer, add(allData, 32), 1, 10627)\\n        }\\n\\n        // total Score of the sacrificed Spirits\\n        uint256 totalScore;\\n\\n        // temporary variable to store current token Id\\n        uint16 currTokenId;\\n\\n        // compute totalScore of sacrificed spirits\\n        for (uint256 i = 0; i < tokenId.length; ++i) {\\n            currTokenId = uint16(tokenId[i] - OFFSETAN2);\\n\\n            // needs to be a Spirit NFT (tokenId >= 1574)\\n            require(currTokenId > 1573, \\\"Not a Spirit\\\");\\n\\n            // check that the NFT is not a Hero - it needs to contain 0 NFTs\\n            require(ISoulsLocker(locker).getSoulsInHero(currTokenId).length == 0, \\\"Cannot sacrifice a Hero\\\");\\n\\n            unchecked {\\n                totalScore += uint8(allData[currTokenId - 1]);\\n            }\\n        }\\n\\n        // calculate the redeemable exp from the sacrifice\\n        uint64 expToCredit = uint64(calculateRedeemableExp(totalScore));\\n\\n        // Mint a limited edition for each 10 spirits burned in one go, if balance is < 250\\n        uint256 totalSacrifice = IERC721(wrapper).balanceOf(address(this));\\n\\n        // credit the experience to the Hero, via the ExpManager contract\\n        IExpManager(expManager).creditExperience(heroId, expToCredit, EXP_MINTER_IDX);\\n\\n        // Transfer and lock all the sacrificed spirits into this contract\\n        IWrapper(wrapper).transferFromBatch(msg.sender, address(this), tokenId);\\n\\n        // Mint a limited editions every 10 Spirits if totalSacrifice < 250\\n        if (totalSacrifice < PRIME_SACRIFICE) {\\n            uint256 qtyToMint = tokenId.length / 10;\\n            uint256 remaining = (PRIME_SACRIFICE - totalSacrifice) / 10 + 1;\\n\\n            if (qtyToMint > 0) {\\n                if (remaining < qtyToMint) {\\n                    qtyToMint = remaining;\\n                }\\n                IERC1155(editions).mint(msg.sender, 1, qtyToMint, \\\"\\\", EDITIONS_MINTER_IDX);\\n            }\\n        }\\n\\n        emit SpiritsSacrificed(heroId, tokenId, expToCredit);\\n    }\\n\\n    /////////////\\n    // REEDEMABLE EXP CALCULATIONS\\n    /////////////\\n\\n    /// @notice Calculate the bonus EXP given a Score\\n    /// @param score Score of a charachter\\n    function calculateBonusExp(uint256 score) public pure returns (uint256 bonus) {\\n        if (score >= 100000) bonus = 50;\\n        else if (score >= 50000) bonus = 45;\\n        else if (score >= 25000) bonus = 32;\\n        else if (score >= 10000) bonus = 25;\\n        else if (score >= 5000) bonus = 20;\\n        else if (score >= 2500) bonus = 16;\\n        else if (score >= 1000) bonus = 13;\\n        else if (score >= 500) bonus = 10;\\n        else if (score >= 250) bonus = 8;\\n        else if (score >= 100) bonus = 6;\\n        else if (score >= 50) bonus = 4;\\n        else if (score >= 25) bonus = 2;\\n        else bonus = 0;\\n    }\\n\\n    /// @notice Calculate the EXP currently redeemable by sacrificing Spirits\\n    /// @param score Total Score of the Spirits sacrificed\\n    function calculateRedeemableExp(uint256 score) public view returns (uint256 claimableExp) {\\n        uint256 currentTimestamp = block.timestamp >= expEnd ? expEnd : block.timestamp;\\n\\n        // Exp is proportional to the Total Score + bonus\\n        uint256 expMultiplier = score * (100 + calculateBonusExp(score));\\n\\n        uint256 deltaT = expEnd - currentTimestamp;\\n        uint256 deltaT2 = expEnd - expStart;\\n        uint256 deltaT1 = currentTimestamp - expStart;\\n        uint256 duration = expEnd - expStart;\\n\\n        return expMultiplier * deltaT - (expMultiplier * (deltaT2 * deltaT2 - deltaT1 * deltaT1)) / (duration * 4);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenId\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expCredited\",\"type\":\"uint256\"}],\"name\":\"SpiritsSacrificed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DARKTALANJI_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EDITIONS_MINTER_IDX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EXP_MINTER_IDX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OG_UNLOCK_NUM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRIME_SACRIFICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUPERRARE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TALANJI_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TML\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"activate\",\"type\":\"bool\"}],\"name\":\"activateSacrifice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"score\",\"type\":\"uint256\"}],\"name\":\"calculateBonusExp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"score\",\"type\":\"uint256\"}],\"name\":\"calculateRedeemableExp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimableExp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"editions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"expEnd\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"expManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"expStart\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"locker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerWithdrawTalanji\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pointerScores\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemOGTalanji\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sacrificeActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenId\",\"type\":\"uint256[]\"}],\"name\":\"spiritsToExp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrapper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DarkTalanji", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}