{"SourceCode": "# @version 0.3.10\r\n\"\"\"\r\n@title SemiLog monetary policy\r\n@notice Monetary policy to calculate borrow rates in lending markets depending on utilization.\r\n        Unlike \"core\" policies, it does not depend on crvUSD price.\r\n        Calculated as:\r\n        log(rate) = utilization * (log(rate_max) - log(rate_min)) + log(rate_min)\r\n        e.g.\r\n        rate = rate_min * (rate_max / rate_min)**utilization\r\n@author Curve.fi\r\n@license Copyright (c) Curve.Fi, 2020-2024 - all rights reserved\r\n\"\"\"\r\nfrom vyper.interfaces import ERC20\r\n\r\n\r\ninterface Controller:\r\n    def total_debt() -> uint256: view\r\n\r\ninterface Factory:\r\n    def admin() -> address: view\r\n\r\n\r\nevent SetRates:\r\n    min_rate: uint256\r\n    max_rate: uint256\r\n\r\n\r\nMAX_EXP: constant(uint256) = 1000 * 10**18\r\nMIN_RATE: public(constant(uint256)) = 10**15 / (365 * 86400)  # 0.1%\r\nMAX_RATE: public(constant(uint256)) = 10**19 / (365 * 86400)  # 1000%\r\n\r\nBORROWED_TOKEN: public(immutable(ERC20))\r\nFACTORY: public(immutable(Factory))\r\n\r\nmin_rate: public(uint256)\r\nmax_rate: public(uint256)\r\nlog_min_rate: public(int256)\r\nlog_max_rate: public(int256)\r\n\r\n\r\n@external\r\ndef __init__(borrowed_token: ERC20, min_rate: uint256, max_rate: uint256):\r\n    assert min_rate >= MIN_RATE and max_rate <= MAX_RATE and min_rate <= max_rate, \"Wrong rates\"\r\n\r\n    BORROWED_TOKEN = borrowed_token\r\n    self.min_rate = min_rate\r\n    self.max_rate = max_rate\r\n    self.log_min_rate = self.ln_int(min_rate)\r\n    self.log_max_rate = self.ln_int(max_rate)\r\n\r\n    FACTORY = Factory(msg.sender)\r\n\r\n\r\n### MATH ###\r\n@internal\r\n@pure\r\ndef exp(power: int256) -> uint256:\r\n    if power <= -41446531673892821376:\r\n        return 0\r\n\r\n    if power >= 135305999368893231589:\r\n        # Return MAX_EXP when we are in overflow mode\r\n        return MAX_EXP\r\n\r\n    x: int256 = unsafe_div(unsafe_mul(power, 2**96), 10**18)\r\n\r\n    k: int256 = unsafe_div(\r\n        unsafe_add(\r\n            unsafe_div(unsafe_mul(x, 2**96), 54916777467707473351141471128),\r\n            2**95),\r\n        2**96)\r\n    x = unsafe_sub(x, unsafe_mul(k, 54916777467707473351141471128))\r\n\r\n    y: int256 = unsafe_add(x, 1346386616545796478920950773328)\r\n    y = unsafe_add(unsafe_div(unsafe_mul(y, x), 2**96), 57155421227552351082224309758442)\r\n    p: int256 = unsafe_sub(unsafe_add(y, x), 94201549194550492254356042504812)\r\n    p = unsafe_add(unsafe_div(unsafe_mul(p, y), 2**96), 28719021644029726153956944680412240)\r\n    p = unsafe_add(unsafe_mul(p, x), (4385272521454847904659076985693276 * 2**96))\r\n\r\n    q: int256 = x - 2855989394907223263936484059900\r\n    q = unsafe_add(unsafe_div(unsafe_mul(q, x), 2**96), 50020603652535783019961831881945)\r\n    q = unsafe_sub(unsafe_div(unsafe_mul(q, x), 2**96), 533845033583426703283633433725380)\r\n    q = unsafe_add(unsafe_div(unsafe_mul(q, x), 2**96), 3604857256930695427073651918091429)\r\n    q = unsafe_sub(unsafe_div(unsafe_mul(q, x), 2**96), 14423608567350463180887372962807573)\r\n    q = unsafe_add(unsafe_div(unsafe_mul(q, x), 2**96), 26449188498355588339934803723976023)\r\n\r\n    return shift(\r\n        unsafe_mul(convert(unsafe_div(p, q), uint256), 3822833074963236453042738258902158003155416615667),\r\n        unsafe_sub(k, 195))\r\n\r\n\r\n@internal\r\n@pure\r\ndef ln_int(_x: uint256) -> int256:\r\n    \"\"\"\r\n    @notice Logarithm ln() function based on log2. Not very gas-efficient but brief\r\n    \"\"\"\r\n    # adapted from: https://medium.com/coinmonks/9aef8515136e\r\n    # and vyper log implementation\r\n    # This can be much more optimal but that's not important here\r\n    x: uint256 = _x\r\n    if _x < 10**18:\r\n        x = 10**36 / _x\r\n    res: uint256 = 0\r\n    for i in range(8):\r\n        t: uint256 = 2**(7 - i)\r\n        p: uint256 = 2**t\r\n        if x >= p * 10**18:\r\n            x /= p\r\n            res += t * 10**18\r\n    d: uint256 = 10**18\r\n    for i in range(59):  # 18 decimals: math.log2(10**18) == 59.7\r\n        if (x >= 2 * 10**18):\r\n            res += d\r\n            x /= 2\r\n        x = x * x / 10**18\r\n        d /= 2\r\n    # Now res = log2(x)\r\n    # ln(x) = log2(x) / log2(e)\r\n    result: int256 = convert(res * 10**18 / 1442695040888963328, int256)\r\n    if _x >= 10**18:\r\n        return result\r\n    else:\r\n        return -result\r\n### END MATH ###\r\n\r\n\r\n@internal\r\n@view\r\ndef calculate_rate(_for: address, d_reserves: int256, d_debt: int256) -> uint256:\r\n    total_debt: int256 = convert(Controller(_for).total_debt(), int256)\r\n    total_reserves: int256 = convert(BORROWED_TOKEN.balanceOf(_for), int256) + total_debt + d_reserves\r\n    total_debt += d_debt\r\n    assert total_debt >= 0, \"Negative debt\"\r\n    assert total_reserves >= total_debt, \"Reserves too small\"\r\n    if total_debt == 0:\r\n        return self.min_rate\r\n    else:\r\n        log_min_rate: int256 = self.log_min_rate\r\n        log_max_rate: int256 = self.log_max_rate\r\n        return self.exp(total_debt * (log_max_rate - log_min_rate) / total_reserves + log_min_rate)\r\n\r\n\r\n@view\r\n@external\r\ndef rate(_for: address = msg.sender) -> uint256:\r\n    return self.calculate_rate(_for, 0, 0)\r\n\r\n\r\n@external\r\ndef rate_write(_for: address = msg.sender) -> uint256:\r\n    return self.calculate_rate(_for, 0, 0)\r\n\r\n\r\n@external\r\ndef set_rates(min_rate: uint256, max_rate: uint256):\r\n    assert msg.sender == FACTORY.admin()\r\n\r\n    assert max_rate >= min_rate\r\n    assert min_rate >= MIN_RATE\r\n    assert max_rate <= MAX_RATE\r\n\r\n    if min_rate != self.min_rate:\r\n        self.log_min_rate = self.ln_int(min_rate)\r\n    if max_rate != self.max_rate:\r\n        self.log_max_rate = self.ln_int(max_rate)\r\n    self.min_rate = min_rate\r\n    self.max_rate = max_rate\r\n\r\n    log SetRates(min_rate, max_rate)\r\n\r\n\r\n@view\r\n@external\r\ndef future_rate(_for: address, d_reserves: int256, d_debt: int256) -> uint256:\r\n    return self.calculate_rate(_for, d_reserves, d_debt)", "ABI": "[{\"name\":\"SetRates\",\"inputs\":[{\"name\":\"min_rate\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"max_rate\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"borrowed_token\",\"type\":\"address\"},{\"name\":\"min_rate\",\"type\":\"uint256\"},{\"name\":\"max_rate\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rate\",\"inputs\":[{\"name\":\"_for\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"rate_write\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"rate_write\",\"inputs\":[{\"name\":\"_for\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_rates\",\"inputs\":[{\"name\":\"min_rate\",\"type\":\"uint256\"},{\"name\":\"max_rate\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_rate\",\"inputs\":[{\"name\":\"_for\",\"type\":\"address\"},{\"name\":\"d_reserves\",\"type\":\"int256\"},{\"name\":\"d_debt\",\"type\":\"int256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"MIN_RATE\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"MAX_RATE\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"BORROWED_TOKEN\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"FACTORY\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"min_rate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"max_rate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"log_min_rate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"log_max_rate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}]}]", "ContractName": "SemiLog monetary policy", "CompilerVersion": "vyper:0.3.10", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}