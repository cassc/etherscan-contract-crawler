{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/abstract/FeeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nabstract contract FeeManager {\\n    /// @notice token address\\n    address public token;\\n\\n    constructor(address _token) {\\n        require(_token != address(0), \\\"_token address cannot be 0\\\");\\n        token = _token;\\n        _lock = _NOT_LOCKED;\\n    }\\n\\n    modifier onlyToken() {\\n        require(msg.sender == token, \\\"only token\\\");\\n        _;\\n    }\\n\\n    uint256 private constant _NOT_LOCKED = 1;\\n    uint256 private constant _LOCKED = 2;\\n    uint256 private _lock;\\n\\n    modifier lock() {\\n        if (_lock == _NOT_LOCKED) {\\n            _lock = _LOCKED;\\n            _;\\n            _lock = _NOT_LOCKED;\\n        }\\n    }\\n\\n    function syncFee() external onlyToken lock {\\n        _syncFee();\\n    }\\n\\n    function canSyncFee(address sender, address recipient) external view virtual returns (bool shouldSyncFee);\\n\\n    function _syncFee() internal virtual;\\n}\"\r\n    },\r\n    \"contracts/external/uniswap/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/* solhint-disable func-name-mixedcase */\\npragma solidity 0.8.19;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function price0CumulativeLast() external view returns (uint256);\\n\\n    function price1CumulativeLast() external view returns (uint256);\\n\\n    function kLast() external view returns (uint256);\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\"\r\n    },\r\n    \"contracts/external/uniswap/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/* solhint-disable func-name-mixedcase */\\npragma solidity 0.8.19;\\n\\n/**\\n * @title Uniswap V2 router01 interface\\n */\\ninterface IUniswapV2Router01 {\\n    // external functions\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256, uint256);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256, uint256);\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256, uint256);\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256, uint256);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory);\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory);\\n\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory);\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory);\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory);\\n\\n    // external functions (views)\\n\\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory);\\n\\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory);\\n\\n    // external functions (pure)\\n\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) external pure returns (uint256);\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256);\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256);\\n\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n}\"\r\n    },\r\n    \"contracts/external/uniswap/IUniswapV2Router02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"./IUniswapV2Router01.sol\\\";\\n\\n/**\\n * @title Uniswap V2 router02 interface\\n */\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    // external functions\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256);\\n\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/helpers/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.19;\\r\\n\\r\\ncontract OwnableData {\\r\\n    address public owner;\\r\\n    address public pendingOwner;\\r\\n}\\r\\n\\r\\ncontract Ownable is OwnableData {\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev `owner` defaults to msg.sender on construction.\\r\\n     */\\r\\n    constructor() {\\r\\n        _setOwner(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\\r\\n     *      Can only be invoked by the current `owner`.\\r\\n     * @param _newOwner Address of the new owner.\\r\\n     * @param _direct True if `_newOwner` should be set immediately. False if `_newOwner` needs to use `claimOwnership`.\\r\\n     * @param _renounce Allows the `_newOwner` to be `address(0)` if `_direct` and `_renounce` is True. Has no effect otherwise\\r\\n     */\\r\\n    function transferOwnership(\\r\\n        address _newOwner,\\r\\n        bool _direct,\\r\\n        bool _renounce\\r\\n    ) external onlyOwner {\\r\\n        if (_direct) {\\r\\n            require(_newOwner != address(0) || _renounce, \\\"zero address\\\");\\r\\n\\r\\n            emit OwnershipTransferred(owner, _newOwner);\\r\\n            owner = _newOwner;\\r\\n            pendingOwner = address(0);\\r\\n        } else {\\r\\n            pendingOwner = _newOwner;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Needs to be called by `pendingOwner` to claim ownership.\\r\\n     */\\r\\n    function claimOwnership() external {\\r\\n        address _pendingOwner = pendingOwner;\\r\\n        require(msg.sender == _pendingOwner, \\\"caller != pending owner\\\");\\r\\n\\r\\n        emit OwnershipTransferred(owner, _pendingOwner);\\r\\n        owner = _pendingOwner;\\r\\n        pendingOwner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the Owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, \\\"caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function _setOwner(address newOwner) internal {\\r\\n        address oldOwner = owner;\\r\\n        owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.19;\\r\\n\\r\\ninterface IERC20 {\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function decimals() external view returns (uint8);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\r\\n\\r\\n    function burn(uint256 amount) external returns (bool);\\r\\n    function burnFrom(address account, uint256 amount) external returns (bool);\\r\\n\\r\\n    // EIP 2612\\r\\n    // solhint-disable-next-line func-name-mixedcase\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint256);\\r\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n    function transferWithPermit(address target, address to, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool);\\r\\n}\"\r\n    },\r\n    \"contracts/SpcFeeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/* solhint-disable no-empty-blocks */\\npragma solidity 0.8.19;\\n\\nimport { IUniswapV2Pair } from \\\"./external/uniswap/IUniswapV2Pair.sol\\\";\\nimport { IUniswapV2Router02 } from \\\"./external/uniswap/IUniswapV2Router02.sol\\\";\\n\\nimport { IERC20 } from \\\"./interfaces/IERC20.sol\\\";\\nimport { Ownable } from \\\"./helpers/Ownable.sol\\\";\\nimport { FeeManager } from \\\"./abstract/FeeManager.sol\\\";\\n\\ncontract SpcFeeManager is FeeManager, Ownable {\\n    /// @notice address of wrapped ETH\\n    address public wETH;\\n\\n    /// @notice address of LP mint\\n    address public lpMint;\\n\\n    /// @notice uniswap V2 pair address\\n    IUniswapV2Pair public uniswapPair;\\n    /// @notice uniswap V2 router\\n    IUniswapV2Router02 public uniswapRouter;\\n\\n    /// @notice min amount of tokens to trigger sync\\n    uint256 public minTokens;\\n\\n    /// @notice fee distribution\\n    uint256 public burnFeeAlloc = 0;\\n    uint256 public lpFeeAlloc = 100;\\n    uint256 public totalFeeAlloc = burnFeeAlloc + lpFeeAlloc;\\n\\n    address public taxReceiverAddress;\\n\\n    constructor(address _token, address _wETH, address _taxReceiverAddress) FeeManager(_token) {\\n        require(_wETH != address(0), \\\"_wETH address cannot be 0\\\");\\n        wETH = _wETH;\\n        minTokens = 100 * 10**18;\\n        taxReceiverAddress = _taxReceiverAddress; \\n    }\\n\\n    function setUniswap(address _uniswapPair, address _uniswapRouter) external onlyOwner {\\n        require(_uniswapPair != address(0), \\\"_uniswapPair address cannot be 0\\\");\\n        require(_uniswapRouter != address(0), \\\"_uniswapRouter address cannot be 0\\\");\\n        uniswapPair = IUniswapV2Pair(_uniswapPair);\\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\\n\\n        IERC20(token).approve(address(uniswapRouter), 0);\\n        IERC20(token).approve(address(uniswapRouter), type(uint256).max);\\n        IERC20(wETH).approve(address(uniswapRouter), 0);\\n        IERC20(wETH).approve(address(uniswapRouter), type(uint256).max);\\n    }\\n\\n    function canSyncFee(address, address recipient) external view override returns (bool shouldSyncFee) {\\n            shouldSyncFee = true; // when swap token > ETH\\n    }\\n\\n    function _syncFee() internal override {\\n        uint256 totalAmount = IERC20(token).balanceOf(address(this));\\n        uint256 burnAmount;\\n\\n        if (totalAmount >= minTokens && totalFeeAlloc > 0) {\\n            burnAmount = (totalAmount * burnFeeAlloc) / totalFeeAlloc;\\n\\n            if (burnAmount > 0) {\\n                IERC20(token).burn(burnAmount);\\n            }\\n\\n            uint256 swapAmount = totalAmount - burnAmount;\\n            _swapTokens(swapAmount);\\n\\n        }\\n    }\\n\\n    function _swapTokens(uint256 amount) private {\\n        address[] memory path = new address[](2);\\n\\n        path[0] = token;\\n        path[1] = wETH;\\n\\n        try\\n            uniswapRouter.swapExactTokensForTokens(\\n                amount,\\n                0,\\n                path,\\n                address(taxReceiverAddress),\\n                block.timestamp // solhint-disable-line not-rely-on-time\\n            )\\n        {\\n            //\\n        } catch {\\n            //\\n        }\\n    }\\n\\n    function _addTokensToLiquidity(uint256 tokenAmount, uint256 wETHAmount) private {\\n        if (tokenAmount != 0 && wETHAmount != 0) {\\n            address destination = (lpMint != address(0)) ? lpMint : address(this);\\n\\n            try\\n                uniswapRouter.addLiquidity(\\n                    token,\\n                    wETH,\\n                    tokenAmount,\\n                    wETHAmount,\\n                    0,\\n                    0,\\n                    destination,\\n                    block.timestamp // solhint-disable-line not-rely-on-time\\n                )\\n            {\\n                //\\n            } catch {\\n                //\\n            }\\n        }\\n    }\\n\\n    function setLpMint(address _lpMint) public onlyOwner {\\n        lpMint = _lpMint;\\n    }\\n\\n    function setMinTokens(uint256 _minTokens) public onlyOwner {\\n        require(_minTokens >= 100, \\\"not less then 100\\\");\\n        minTokens = _minTokens;\\n    }\\n\\n    function setFeeAlloc(uint256 _burnFeeAlloc, uint256 _lpFeeAlloc) public onlyOwner {\\n        require(_burnFeeAlloc >= 0 && _burnFeeAlloc <= 100, \\\"_burnFeeAlloc is outside of range 0-100\\\");\\n        require(_lpFeeAlloc >= 0 && _lpFeeAlloc <= 100, \\\"_lpFeeAlloc is outside of range 0-100\\\");\\n        burnFeeAlloc = _burnFeeAlloc;\\n        lpFeeAlloc = _lpFeeAlloc;\\n        totalFeeAlloc = burnFeeAlloc + lpFeeAlloc;\\n    }\\n\\n    function recoverETH() external onlyOwner {\\n        payable(owner).transfer(address(this).balance);\\n    }\\n\\n    function recoverErc20(address _token) external onlyOwner {\\n        uint256 amt = IERC20(_token).balanceOf(address(this));\\n        require(amt > 0, \\\"nothing to recover\\\");\\n        IBadErc20(_token).transfer(owner, amt);\\n    }\\n\\n    function updateTaxAddress(address _address) external onlyOwner {\\n        require(_address != address(0), \\\"zero address\\\");\\n        taxReceiverAddress = _address;\\n    }\\n\\n    receive() external payable {} // not necessary\\n}\\n\\ninterface IBadErc20 {\\n    function transfer(address _recipient, uint256 _amount) external;\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_taxReceiverAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"burnFeeAlloc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"canSyncFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"shouldSyncFee\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpFeeAlloc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpMint\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"recoverErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_burnFeeAlloc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lpFeeAlloc\",\"type\":\"uint256\"}],\"name\":\"setFeeAlloc\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpMint\",\"type\":\"address\"}],\"name\":\"setLpMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minTokens\",\"type\":\"uint256\"}],\"name\":\"setMinTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapPair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapRouter\",\"type\":\"address\"}],\"name\":\"setUniswap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"syncFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxReceiverAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFeeAlloc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_direct\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_renounce\",\"type\":\"bool\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapPair\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"updateTaxAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SpcFeeManager", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000eeb6de393baba42cd96bfea0ca0b1eafe88e9c68000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000e821c366f3091b09d5ab066ceef038df63c4781a", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}