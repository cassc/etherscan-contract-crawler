{"SourceCode": "pragma solidity 0.8.0;\r\n\r\n/**\r\n* @dev Interface of the ERC20 standard as defined in the EIP.\r\n*/\r\ninterface IERC20 {\r\n    /**\r\n    * @dev Returns the amount of tokens in existence.\r\n    */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Returns the name of the token.\r\n    */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n    * @dev Returns the symbol of the token.\r\n    */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n    * @dev Returns the decimals places of the token.\r\n    */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n    * @dev Returns the bep token owner.\r\n    */\r\n    function getOwner() external view returns (address);\r\n\r\n    /**\r\n    * @dev Returns the amount of tokens owned by `account`.\r\n    */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n    *\r\n    * Returns a boolean value indicating whether the operation succeeded.\r\n    *\r\n    * Emits a {Transfer} event.\r\n    */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n    * @dev Returns the remaining number of tokens that `spender` will be\r\n    * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n    * zero by default.\r\n    *\r\n    * This value changes when {approve} or {transferFrom} are called.\r\n    */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n    *\r\n    * Returns a boolean value indicating whether the operation succeeded.\r\n    *\r\n    * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n    * that someone may use both the old and the new allowance by unfortunate\r\n    * transaction ordering. One possible solution to mitigate this race\r\n    * condition is to first reduce the spender's allowance to 0 and set the\r\n    * desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    *\r\n    * Emits an {Approval} event.\r\n    */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n    * allowance mechanism. `amount` is then deducted from the caller's\r\n    * allowance.\r\n    *\r\n    * Returns a boolean value indicating whether the operation succeeded.\r\n    *\r\n    * Emits a {Transfer} event.\r\n    */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n    * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n    * another (`to`).\r\n    *\r\n    * Note that `value` may be zero.\r\n    */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n    * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n    * a call to {approve}. `value` is the new allowance.\r\n    */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n* @dev Provides information about the current execution context, including the\r\n* sender of the transaction and its data. While these are generally available\r\n* via msg.sender and msg.data, they should not be accessed in such a direct\r\n* manner, since when dealing with meta-transactions the account sending and\r\n* paying for execution may not be the actual sender (as far as an application\r\n* is concerned).\r\n*\r\n* This contract is only required for intermediate, library-like contracts.\r\n*/\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n* @dev Contract module which provides a manager access control mechanism, where\r\n* there is owner and manager, that can be granted exclusive access to\r\n* specific functions.\r\n*\r\n* Both owner and manager accounts need to be specified when deploying the contract. This\r\n* can later be changed with {setOwner} and {setManager}.\r\n*\r\n* This module is used through inheritance. Modifiers `onlyOwner` and `ownerOrManager`\r\n* will be available, which can be applied to your functions to restrict their use.\r\n*/\r\nabstract contract Managed is Context\r\n{\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event ManagementTransferred(address indexed previousManager, address indexed newManager);\r\n\r\n    address private _owner;\r\n    address private _manager;\r\n\r\n    /**\r\n    * @dev Initializes the contract, setting owner and manager.\r\n    */\r\n    constructor(address owner_, address manager_)\r\n    {\r\n        require(owner_ != address(0), \"Owner address can't be a zero address\");\r\n        require(manager_ != address(0), \"Manager address can't be a zero address\");\r\n\r\n        _setOwner(owner_);\r\n        _setManager(manager_);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the address of the current owner.\r\n    */\r\n    function owner() public view returns (address)\r\n    { return _owner; }\r\n\r\n    /**\r\n    * @dev Returns the address of the current manager.\r\n    */\r\n    function manager() public view returns (address)\r\n    { return _manager; }\r\n\r\n    /**\r\n    * @dev Transfers owner permissions to a new account (`newOwner`).\r\n    * Can only be called by owner.\r\n    */\r\n    function setOwner(address newOwner) external onlyOwner\r\n    {\r\n        require(newOwner != address(0), \"Managed: new owner can't be zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers manager permissions to a new account (`newManager`).\r\n    * Can only be called by owner.\r\n    */\r\n    function setManager(address newManager) external onlyOwner\r\n    {\r\n        require(newManager != address(0), \"Managed: new manager can't be zero address\");\r\n        _setManager(newManager);\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner()\r\n    {\r\n        require(_msgSender() == _owner, \"Managed: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than owner or manager.\r\n    */\r\n    modifier ownerOrManager()\r\n    {\r\n        require(_msgSender() == _owner || _msgSender() == _manager, \"Managed: caller is not the owner or manager\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers owner permissions to a new account (`newOwner`).\r\n    * Internal function without access restriction.\r\n    */\r\n    function _setOwner(address newOwner) internal\r\n    {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers manager permissions to a new account (`newManager`).\r\n    * Internal function without access restriction.\r\n    */\r\n    function _setManager(address newManager) internal\r\n    {\r\n        address oldManager = _manager;\r\n        _manager = newManager;\r\n        emit ManagementTransferred(oldManager, newManager);\r\n    }\r\n}\r\n\r\n/**\r\n* @dev Contract module which provides a locking mechanism that allows\r\n* a total token lock, or lock of a specific address.\r\n*\r\n* This module is used through inheritance. Modifier `isUnlocked`\r\n* will be available, which can be applied to your functions to restrict their use.\r\n*/\r\nabstract contract Lockable is Managed\r\n{\r\n    event AddressLockChanged(address indexed addr, bool newLock);\r\n    event TokenLockChanged(bool newLock);\r\n\r\n    mapping(address => bool) private _addressLocks;\r\n    bool private _locked;\r\n\r\n    /**\r\n    * @dev Completely locks any transfers of the token.\r\n    * Can only be called by owner.\r\n    */\r\n    function lockToken() external onlyOwner\r\n    {\r\n        _locked = true;\r\n        emit TokenLockChanged(true);\r\n    }\r\n\r\n    /**\r\n    * @dev Completely unlocks any transfers of the token.\r\n    * Can only be called by owner.\r\n    */\r\n    function unlockToken() external onlyOwner\r\n    {\r\n        _locked = false;\r\n        emit TokenLockChanged(false);\r\n    }\r\n\r\n    /**\r\n    * @dev Return whether the token is currently locked.\r\n    */\r\n    function isLocked() public view returns (bool)\r\n    { return _locked; }\r\n\r\n    /**\r\n    * @dev Throws if a function is called while the token is locked.\r\n    */\r\n    modifier isUnlocked()\r\n    {\r\n        require(!_locked, \"All token transfers are currently locked\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Completely locks sending and receiving of token for a specific address.\r\n    * Can only be called by owner or manager\r\n    */\r\n    function lockAddress(address addr) external onlyOwner\r\n    {\r\n        _addressLocks[addr] = true;\r\n        emit AddressLockChanged(addr, true);\r\n    }\r\n\r\n    /**\r\n    * @dev Completely unlocks sending and receiving of token for a specific address.\r\n    * Can only be called by owner or manager\r\n    */\r\n    function unlockAddress(address addr) external onlyOwner\r\n    {\r\n        _addressLocks[addr] = false;\r\n        emit AddressLockChanged(addr, false);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns whether the account (`addr`) is currently locked.\r\n    */\r\n    function isAddressLocked(address addr) public view returns (bool)\r\n    { return _addressLocks[addr]; }\r\n}\r\n\r\n/**\r\n* @dev Implementation of the {IERC20} interface.\r\n*\r\n* This implementation is agnostic to the way tokens are created. This means\r\n* that a supply mechanism has to be added in a derived contract using {_mint}.\r\n* For a generic mechanism see {ERC20PresetMinterPauser}.\r\n*\r\n* TIP: For a detailed writeup see our guide\r\n* https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n* to implement supply mechanisms].\r\n*\r\n* We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n* instead returning `false` on failure. This behavior is nonetheless\r\n* conventional and does not conflict with the expectations of ERC20\r\n* applications.\r\n*\r\n* Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n* This allows applications to reconstruct the allowance for all accounts just\r\n* by listening to said events. Other implementations of the EIP may not emit\r\n* these events, as it isn't required by the specification.\r\n*\r\n* Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n* functions have been added to mitigate the well-known issues around setting\r\n* allowances. See {IERC20-approve}.\r\n*/\r\ncontract ERC20 is Context, IERC20, Managed, Lockable\r\n{\r\n    event Burn(address indexed from, uint256 amount);\r\n    event Release(address indexed to1, address indexed to2, address indexed to3, uint256 amount);\r\n    event Halving(uint256 oldReleaseAmount, uint256 newReleaseAmount);\r\n    event ReleaseAddressChanged(address indexed oldAddress, address indexed newAddress);\r\n    event BurnApproval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    mapping(address => mapping(address => uint256)) private _burnAllowances;\r\n\r\n    uint256 private _totalSupply;\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private immutable _decimals;\r\n\r\n    uint256 private _releaseAmount;\r\n    uint256 private _nextReleaseDate;\r\n    uint256 private _nextReducementDate;\r\n    address private _releaseAddress1;\r\n    address private _releaseAddress2;\r\n    address private _releaseAddress3;\r\n\r\n    uint256 private constant _week = 600000; // 10 000 minutes\r\n    uint256 private constant _4years = 126000000; // 2 100 000 minutes\r\n\r\n    /**\r\n    * @dev Sets the values for {owner}, {manager} and {initialDepositAddress}.\r\n    *\r\n    * Sends first released amount to the {initialDepositAddress1, initialDepositAddress2, initialDepositAddress3}, and locks the remaining supply within contract.\r\n    *\r\n    * The default value of {decimals} is 18. To select a different value for\r\n    * {decimals} you should overload it.\r\n    *\r\n    * All values for token parameters are immutable: they can only be set once during\r\n    * construction.\r\n    */\r\n    constructor(string memory name_, string memory symbol_, uint8 decimals_, address owner_, address manager_, address initialDepositAddress1, address initialDepositAddress2, address initialDepositAddress3) Managed(owner_, manager_)\r\n    {\r\n        require(initialDepositAddress1 != address(0), \"Initial release address can't be a zero address\");\r\n        require(initialDepositAddress2 != address(0), \"Initial release address can't be a zero address\");\r\n        require(initialDepositAddress3 != address(0), \"Initial release address can't be a zero address\");\r\n        require(initialDepositAddress1 != initialDepositAddress2, \"Initial addresses can't be the same\");\r\n        require(initialDepositAddress2 != initialDepositAddress3, \"Initial addresses can't be the same\");\r\n        require(initialDepositAddress3 != initialDepositAddress1, \"Initial addresses can't be the same\");\r\n\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = decimals_;\r\n\r\n        _totalSupply = 21000000 * uint256(10**decimals_);\r\n        _releaseAmount = 50000 * uint256(10**decimals_);\r\n\r\n        _nextReleaseDate = block.timestamp + _week;\r\n        _nextReducementDate = block.timestamp + _4years;\r\n\r\n        _balances[address(this)] = _totalSupply - _releaseAmount;\r\n        emit Transfer(address(0), address(this), _balances[address(this)]);\r\n\r\n        _releaseAddress1 = initialDepositAddress1;\r\n        _releaseAddress2 = initialDepositAddress2;\r\n        _releaseAddress3 = initialDepositAddress3;\r\n\r\n        _balances[initialDepositAddress1] = _releaseAmount*72/100;\r\n        _balances[initialDepositAddress2] = _releaseAmount*8/100;\r\n        _balances[initialDepositAddress3] = _releaseAmount*20/100;\r\n\r\n        emit Transfer(address(0), initialDepositAddress1, _balances[initialDepositAddress1]);\r\n        emit Transfer(address(0), initialDepositAddress2, _balances[initialDepositAddress2]);\r\n        emit Transfer(address(0), initialDepositAddress3, _balances[initialDepositAddress3]);\r\n        emit Release(initialDepositAddress1, initialDepositAddress2, initialDepositAddress3, _releaseAmount);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the name of the token.\r\n    */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the symbol of the token, usually a shorter version of the\r\n    * name.\r\n    */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the number of decimals used to get its user representation.\r\n    * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n    * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n    *\r\n    * Tokens usually opt for a value of 18, imitating the relationship between\r\n    * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n    * overridden;\r\n    *\r\n    * NOTE: This information is only used for _display_ purposes: it in\r\n    * no way affects any of the arithmetic of the contract, including\r\n    * {IERC20-balanceOf} and {IERC20-transfer}.\r\n    */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n    * @dev See {IERC20-getOwner}.\r\n    */\r\n    function getOwner() public view virtual override returns (address)\r\n    { return owner(); }\r\n\r\n    /**\r\n    * @dev See {IERC20-totalSupply}.\r\n    */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns real current supply without the locked tokens\r\n    */\r\n    function currentSupply() view public returns(uint256) {\r\n        return _totalSupply - _balances[address(this)];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev See {IERC20-balanceOf}.\r\n    */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n    * @dev See {IERC20-transfer}.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - the caller must have an available balance of at least `amount`.\r\n    */\r\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev See {IERC20-allowance}.\r\n    */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function burnAllowance(address owner, address spender) public view returns (uint256) {\r\n        return _burnAllowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n    * @dev See {IERC20-approve}.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `spender` cannot be the zero address.\r\n    */\r\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Requirements:\r\n    *\r\n    * - `spender` cannot be the zero address.\r\n    */\r\n    function burnApprove(address spender, uint256 amount) external returns (bool) {\r\n        _burnApprove(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev See {IERC20-transferFrom}.\r\n    *\r\n    * Emits an {Approval} event indicating the updated allowance. This is not\r\n    * required by the EIP. See the note at the beginning of {ERC20}.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `sender` and `recipient` cannot be the zero address.\r\n    * - `sender` must have a balance of at least `amount`.\r\n    * - the caller must have allowance for ``sender``'s tokens of at least\r\n    * `amount`.\r\n    */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        unchecked {\r\n            _approve(sender, _msgSender(), currentAllowance - amount);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Destroys `amount` tokens from the caller.\r\n    *\r\n    * See {ERC20-_burn}.\r\n    */\r\n    function burn(uint256 amount) external virtual\r\n    { _burn(_msgSender(), amount); }\r\n\r\n    /**\r\n    * @dev Destroys `amount` tokens from `account`, deducting from the caller's\r\n    * allowance.\r\n    *\r\n    * See {ERC20-_burn} and {ERC20-allowance}.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - the caller must have burnAllowance for `accounts`'s tokens of at least\r\n    * `amount`.\r\n    */\r\n    function burnFrom(address account, uint256 amount) external virtual\r\n    {\r\n        uint256 currentBurnAllowance = burnAllowance(account, _msgSender());\r\n        require(currentBurnAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\r\n        unchecked {\r\n            _burnApprove(account, _msgSender(), currentBurnAllowance - amount);\r\n        }\r\n        _burn(account, amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n    *\r\n    * This is an alternative to {approve} that can be used as a mitigation for\r\n    * problems described in {IERC20-approve}.\r\n    *\r\n    * Emits an {Approval} event indicating the updated allowance.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `spender` cannot be the zero address.\r\n    */\r\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Atomically increases the burnAllowance granted to `spender` by the caller.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `spender` cannot be the zero address.\r\n    */\r\n    function increaseBurnAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\r\n        _burnApprove(_msgSender(), spender, _burnAllowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n    *\r\n    * This is an alternative to {approve} that can be used as a mitigation for\r\n    * problems described in {IERC20-approve}.\r\n    *\r\n    * Emits an {Approval} event indicating the updated allowance.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `spender` cannot be the zero address.\r\n    * - `spender` must have allowance for the caller of at least\r\n    * `subtractedValue`.\r\n    */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Atomically decreases the burnAllowance granted to `spender` by the caller.\r\n\r\n    *\r\n    * Emits an {BurnApproval} event indicating the updated burnAllowance.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `spender` cannot be the zero address.\r\n    * - `spender` must have allowance for the caller of at least\r\n    * `subtractedValue`.\r\n    */\r\n    function decreaseBurnAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\r\n        uint256 currentBurnAllowance = _burnAllowances[_msgSender()][spender];\r\n        require(currentBurnAllowance >= subtractedValue, \"ERC20: decreased burnAllowance below zero\");\r\n        unchecked {\r\n            _burnApprove(_msgSender(), spender, currentBurnAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n    /**\r\n    * @dev Sets {_releaseAddress1} to {newReleaseAddress}.\r\n    * Emits a {ReleaseAddressChanged} event containing old and a new release addresses.\r\n    */\r\n    function setReleaseAddress1(address newReleaseAddress) external onlyOwner\r\n    {\r\n        require(newReleaseAddress != address(0), \"New release address can't be a zero address\");\r\n        require(newReleaseAddress != _releaseAddress1, \"New release address can't be same as _releaseAddress1\");\r\n        require(newReleaseAddress != _releaseAddress2, \"New release address can't be same as _releaseAddress2\");\r\n        require(newReleaseAddress != _releaseAddress3, \"New release address can't be same as _releaseAddress3\");\r\n\r\n        address oldAddress = _releaseAddress1;\r\n        _releaseAddress1 = newReleaseAddress;\r\n        emit ReleaseAddressChanged(oldAddress, _releaseAddress1);\r\n    }\r\n    /**\r\n    * @dev Sets {_releaseAddress2} to {newReleaseAddress}.\r\n    *\r\n    * Emits a {ReleaseAddressChanged} event containing old and a new release addresses.\r\n    */\r\n    function setReleaseAddress2(address newReleaseAddress) external onlyOwner\r\n    {\r\n        require(newReleaseAddress != address(0), \"New release address can't be a zero address\");\r\n        require(newReleaseAddress != _releaseAddress1, \"New release address can't be same as _releaseAddress1\");\r\n        require(newReleaseAddress != _releaseAddress2, \"New release address can't be same as _releaseAddress2\");\r\n        require(newReleaseAddress != _releaseAddress3, \"New release address can't be same as _releaseAddress3\");\r\n\r\n        address oldAddress = _releaseAddress2;\r\n        _releaseAddress2 = newReleaseAddress;\r\n        emit ReleaseAddressChanged(oldAddress, _releaseAddress2);\r\n    }\r\n\r\n    /**\r\n* @dev Sets {_releaseAddress3} to {newReleaseAddress}.\r\n    *\r\n    * Emits a {ReleaseAddressChanged} event containing old and a new release addresses.\r\n    */\r\n    function setReleaseAddress3(address newReleaseAddress) external onlyOwner\r\n    {\r\n        require(newReleaseAddress != address(0), \"New release address can't be a zero address\");\r\n        require(newReleaseAddress != _releaseAddress1, \"New release address can't be same as _releaseAddress1\");\r\n        require(newReleaseAddress != _releaseAddress2, \"New release address can't be same as _releaseAddress2\");\r\n        require(newReleaseAddress != _releaseAddress3, \"New release address can't be same as _releaseAddress3\");\r\n\r\n        address oldAddress = _releaseAddress3;\r\n        _releaseAddress3 = newReleaseAddress;\r\n        emit ReleaseAddressChanged(oldAddress, _releaseAddress3);\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates and releases new coins into circulation.\r\n    * If multiple weeks have passed, releases all the coins that should be\r\n    * released within those weeks.\r\n    *\r\n    * Emits a {Release} event containing the address {_releaseAddress1, _releaseAddress2, _releaseAddress3} the coins were released to,\r\n    * and the amount {toRelease} of coins the function released.\r\n    */\r\n    function release() external ownerOrManager\r\n    {\r\n        require(block.timestamp > _nextReleaseDate, \"Next coin release is not yet scheduled\");\r\n        require(balanceOf(address(this)) > 0, \"There are no more coins to release\");\r\n\r\n        uint256 toRelease = 0;\r\n        uint256 currentRelease = 0;\r\n\r\n        while((currentRelease = _calculateReleaseAmount()) > 0)\r\n        { toRelease += currentRelease; }\r\n\r\n        _transfer(address(this), _releaseAddress1, toRelease*72/100);\r\n        _transfer(address(this), _releaseAddress2, toRelease*8/100);\r\n        _transfer(address(this), _releaseAddress3, toRelease*20/100);\r\n        emit Release(_releaseAddress1, _releaseAddress2, _releaseAddress3, toRelease);\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates the exact amount of coins that should be released for one release cycle.\r\n    * If the next release will be after the halving date, it also calculates a new {_releaseAmount}\r\n    * for future releases.\r\n    *\r\n    * Emits a {Halving} event if halving happens, containing the old release amount {oldReleaseAmount},\r\n    * and new release amount {_releaseAmount}\r\n    */\r\n    function _calculateReleaseAmount() internal returns (uint256)\r\n    {\r\n        if(block.timestamp < _nextReleaseDate || balanceOf(address(this)) == 0)\r\n            return 0;\r\n\r\n        uint256 amount = _releaseAmount > balanceOf(address(this)) ? balanceOf(address(this)) : _releaseAmount;\r\n\r\n        _nextReleaseDate += _week;\r\n        if(_nextReleaseDate >= _nextReducementDate)\r\n        {\r\n            _nextReducementDate += _4years;\r\n\r\n            uint256 oldReleaseAmount = _releaseAmount;\r\n            _releaseAmount = _releaseAmount / 2;\r\n\r\n            emit Halving(oldReleaseAmount, _releaseAmount);\r\n        }\r\n\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n    * @dev Moves `amount` of tokens from `sender` to `recipient`.\r\n    *\r\n    * This internal function is equivalent to {transfer}, and can be used to\r\n    * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n    *\r\n    * If the `recipient` address is zero address, calls {_burn} instead.\r\n    *\r\n    * Emits a {Transfer} event.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `sender` cannot be the zero address.\r\n    * - `sender` must have an available balance of at least `amount`.\r\n    */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal isUnlocked virtual\r\n    {\r\n        require(recipient != address(0), \"ERC20: transfer to zero address\");\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n\r\n        require(!isAddressLocked(sender), \"Sender address is currently locked and can't send funds\");\r\n        require(!isAddressLocked(recipient), \"Recipient address is currently locked and can't receive funds\");\r\n\r\n        require(_balances[sender] >= amount, \"ERC20: transfer amount exceeds available balance\");\r\n\r\n        _balances[sender] -= amount;\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n    *\r\n    * This internal function is equivalent to `approve`, and can be used to\r\n    * e.g. set automatic allowances for certain subsystems, etc.\r\n    *\r\n    * Emits an {Approval} event.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `owner` cannot be the zero address.\r\n    * - `spender` cannot be the zero address.\r\n    */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n    *\r\n    * Emits an {BurnApproval} event.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `owner` cannot be the zero address.\r\n    * - `spender` cannot be the zero address.\r\n    */\r\n    function _burnApprove(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"burnApprove from the zero address\");\r\n        require(spender != address(0), \"burnApprove to the zero address\");\r\n\r\n        _burnAllowances[owner][spender] = amount;\r\n        emit BurnApproval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Destroys `amount` tokens from `account`, reducing the\r\n    * total supply.\r\n    *\r\n    * Emits a {Transfer} event with `to` set to the zero address.\r\n    * Emits a {Burn} event with `amount` burned.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `account` cannot be the zero address.\r\n    * - `account` must have at least `amount` tokens.\r\n    * - `account` can't be locked.\r\n    */\r\n    function _burn(address account, uint256 amount) internal isUnlocked virtual\r\n    {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        require(!isAddressLocked(account), \"Sender address is currently locked and can't burn funds\");\r\n\r\n        require(_balances[account] >= amount, \"ERC20: burn amount exceeds available balance\");\r\n\r\n        _balances[account] -= amount;\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n        emit Burn(account, amount);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialDepositAddress1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialDepositAddress2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialDepositAddress3\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newLock\",\"type\":\"bool\"}],\"name\":\"AddressLockChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"BurnApproval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldReleaseAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newReleaseAmount\",\"type\":\"uint256\"}],\"name\":\"Halving\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousManager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"ManagementTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to1\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to2\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to3\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Release\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"ReleaseAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newLock\",\"type\":\"bool\"}],\"name\":\"TokenLockChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"burnAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnApprove\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseBurnAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseBurnAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isAddressLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"lockAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newReleaseAddress\",\"type\":\"address\"}],\"name\":\"setReleaseAddress1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newReleaseAddress\",\"type\":\"address\"}],\"name\":\"setReleaseAddress2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newReleaseAddress\",\"type\":\"address\"}],\"name\":\"setReleaseAddress3\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"unlockAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ERC20", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000120000000000000000000000009b0330006bf03c12ad991903cabb17f4a62e71bc0000000000000000000000005a18637da07696b1e1d751fa36a4010fe759a3650000000000000000000000005e7790b25c2b4b048000e3759d4f98da0f614951000000000000000000000000b2d0f19cf2b9d3632619c2029f2cfb04bcd2c86400000000000000000000000016acecfed1dd8461de48aa09522a0e9528b07d350000000000000000000000000000000000000000000000000000000000000016486f757365206f66204d616e64656c6120546f6b656e000000000000000000000000000000000000000000000000000000000000000000000000000000000003484f4d0000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://17377a376aabc6f5d7c7d682331637e6dad1626d80fb6366748fa7b3beb5d01b"}