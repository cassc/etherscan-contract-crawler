{"SourceCode": "# @version 0.3.1\r\n\"\"\"\r\n@title Curve DAO Token\r\n@author Curve Finance\r\n@license MIT\r\n@notice ERC20 with piecewise-linear mining supply.\r\n@dev Based on the ERC-20 token standard as defined at\r\n     https://eips.ethereum.org/EIPS/eip-20\r\n\"\"\"\r\n\r\n# Original idea and credit:\r\n# Curve Finance's ERC20CRV\r\n# https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/ERC20CRV.vy\r\n# This contract is an almost-identical fork of Curve's contract\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\nimplements: ERC20\r\n\r\n\r\nevent Transfer:\r\n    _from: indexed(address)\r\n    _to: indexed(address)\r\n    _value: uint256\r\n\r\nevent Approval:\r\n    _owner: indexed(address)\r\n    _spender: indexed(address)\r\n    _value: uint256\r\n\r\nevent UpdateMiningParameters:\r\n    time: uint256\r\n    rate: uint256\r\n    supply: uint256\r\n\r\nevent SetMinter:\r\n    minter: address\r\n\r\nevent SetAdmin:\r\n    admin: address\r\n\r\n\r\nname: public(String[64])\r\nsymbol: public(String[32])\r\ndecimals: public(uint256)\r\n\r\nbalanceOf: public(HashMap[address, uint256])\r\nallowances: HashMap[address, HashMap[address, uint256]]\r\ntotal_supply: uint256\r\n\r\nminter: public(address)\r\nadmin: public(address)\r\n\r\n# General constants\r\nYEAR: constant(uint256) = 86400 * 365\r\n\r\n# Supply parameters\r\nRATE_REDUCTION_TIME: constant(uint256) = YEAR\r\nRATE_DENOMINATOR: constant(uint256) = 10 ** 18\r\nINFLATION_DELAY: constant(uint256) = 86400\r\n\r\nINITIAL_RATE: public(uint256)\r\nRATE_REDUCTION_COEFFICIENT: public(uint256)\r\n\r\n# Supply variables\r\nmining_epoch: public(int128)\r\nstart_epoch_time: public(uint256)\r\nrate: public(uint256)\r\n\r\nstart_epoch_supply: uint256\r\n\r\n\r\n@external\r\ndef initialize(\r\n    _init_supply: uint256,\r\n    _init_rate: uint256,\r\n    _rate_reduction_coefficient: uint256,\r\n    _admin: address, \r\n    _name: String[64], \r\n    _symbol: String[32]):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param _name Token full name\r\n    @param _symbol Token symbol\r\n    \"\"\"\r\n    assert self.admin == ZERO_ADDRESS, \"already initialized\"\r\n\r\n    self.name = _name\r\n    self.symbol = _symbol\r\n    self.decimals = 18\r\n    self.balanceOf[_admin] = _init_supply\r\n    self.total_supply = _init_supply\r\n    self.admin = _admin\r\n    log Transfer(ZERO_ADDRESS, _admin, _init_supply)\r\n\r\n    self.INITIAL_RATE = _init_rate\r\n    self.RATE_REDUCTION_COEFFICIENT = _rate_reduction_coefficient\r\n\r\n    self.start_epoch_time = block.timestamp + INFLATION_DELAY - RATE_REDUCTION_TIME\r\n    self.mining_epoch = -1\r\n    self.rate = 0\r\n    self.start_epoch_supply = _init_supply\r\n\r\n\r\n@internal\r\ndef _update_mining_parameters():\r\n    \"\"\"\r\n    @dev Update mining rate and supply at the start of the epoch\r\n         Any modifying mining call must also call this\r\n    \"\"\"\r\n    _rate: uint256 = self.rate\r\n    _start_epoch_supply: uint256 = self.start_epoch_supply\r\n\r\n    self.start_epoch_time += RATE_REDUCTION_TIME\r\n    self.mining_epoch += 1\r\n\r\n    if _rate == 0:\r\n        _rate = self.INITIAL_RATE\r\n    else:\r\n        _start_epoch_supply += _rate * RATE_REDUCTION_TIME\r\n        self.start_epoch_supply = _start_epoch_supply\r\n        _rate = _rate * RATE_DENOMINATOR / self.RATE_REDUCTION_COEFFICIENT\r\n\r\n    self.rate = _rate\r\n\r\n    log UpdateMiningParameters(block.timestamp, _rate, _start_epoch_supply)\r\n\r\n\r\n@external\r\ndef update_mining_parameters():\r\n    \"\"\"\r\n    @notice Update mining rate and supply at the start of the epoch\r\n    @dev Callable by any address, but only once per epoch\r\n         Total supply becomes slightly larger if this function is called late\r\n    \"\"\"\r\n    assert block.timestamp >= self.start_epoch_time + RATE_REDUCTION_TIME  # dev: too soon!\r\n    self._update_mining_parameters()\r\n\r\n\r\n@external\r\ndef start_epoch_time_write() -> uint256:\r\n    \"\"\"\r\n    @notice Get timestamp of the current mining epoch start\r\n            while simultaneously updating mining parameters\r\n    @return Timestamp of the epoch\r\n    \"\"\"\r\n    _start_epoch_time: uint256 = self.start_epoch_time\r\n    if block.timestamp >= _start_epoch_time + RATE_REDUCTION_TIME:\r\n        self._update_mining_parameters()\r\n        return self.start_epoch_time\r\n    else:\r\n        return _start_epoch_time\r\n\r\n\r\n@external\r\ndef future_epoch_time_write() -> uint256:\r\n    \"\"\"\r\n    @notice Get timestamp of the next mining epoch start\r\n            while simultaneously updating mining parameters\r\n    @return Timestamp of the next epoch\r\n    \"\"\"\r\n    _start_epoch_time: uint256 = self.start_epoch_time\r\n    if block.timestamp >= _start_epoch_time + RATE_REDUCTION_TIME:\r\n        self._update_mining_parameters()\r\n        return self.start_epoch_time + RATE_REDUCTION_TIME\r\n    else:\r\n        return _start_epoch_time + RATE_REDUCTION_TIME\r\n\r\n\r\n@internal\r\n@view\r\ndef _available_supply() -> uint256:\r\n    return self.start_epoch_supply + (block.timestamp - self.start_epoch_time) * self.rate\r\n\r\n\r\n@external\r\n@view\r\ndef available_supply() -> uint256:\r\n    \"\"\"\r\n    @notice Current number of tokens in existence (claimed or unclaimed)\r\n    \"\"\"\r\n    return self._available_supply()\r\n\r\n\r\n@external\r\n@view\r\ndef mintable_in_timeframe(start: uint256, end: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice How much supply is mintable from start timestamp till end timestamp\r\n    @param start Start of the time interval (timestamp)\r\n    @param end End of the time interval (timestamp)\r\n    @return Tokens mintable from `start` till `end`\r\n    \"\"\"\r\n    assert start <= end  # dev: start > end\r\n    to_mint: uint256 = 0\r\n    current_epoch_time: uint256 = self.start_epoch_time\r\n    current_rate: uint256 = self.rate\r\n\r\n    # Special case if end is in future (not yet minted) epoch\r\n    if end > current_epoch_time + RATE_REDUCTION_TIME:\r\n        current_epoch_time += RATE_REDUCTION_TIME\r\n        current_rate = current_rate * RATE_DENOMINATOR / self.RATE_REDUCTION_COEFFICIENT\r\n\r\n    assert end <= current_epoch_time + RATE_REDUCTION_TIME  # dev: too far in future\r\n\r\n    for i in range(999):  # Curve will not work in 1000 years. Darn!\r\n        if end >= current_epoch_time:\r\n            current_end: uint256 = end\r\n            if current_end > current_epoch_time + RATE_REDUCTION_TIME:\r\n                current_end = current_epoch_time + RATE_REDUCTION_TIME\r\n\r\n            current_start: uint256 = start\r\n            if current_start >= current_epoch_time + RATE_REDUCTION_TIME:\r\n                break  # We should never get here but what if...\r\n            elif current_start < current_epoch_time:\r\n                current_start = current_epoch_time\r\n\r\n            to_mint += current_rate * (current_end - current_start)\r\n\r\n            if start >= current_epoch_time:\r\n                break\r\n\r\n        current_epoch_time -= RATE_REDUCTION_TIME\r\n        current_rate = current_rate * self.RATE_REDUCTION_COEFFICIENT / RATE_DENOMINATOR  # double-division with rounding made rate a bit less => good\r\n        assert current_rate <= self.INITIAL_RATE  # This should never happen\r\n\r\n    return to_mint\r\n\r\n\r\n@external\r\ndef set_minter(_minter: address):\r\n    \"\"\"\r\n    @notice Set the minter address\r\n    @dev Only callable once, when minter has not yet been set\r\n    @param _minter Address of the minter\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n    assert self.minter == ZERO_ADDRESS  # dev: can set the minter only once, at creation\r\n    self.minter = _minter\r\n    log SetMinter(_minter)\r\n\r\n\r\n@external\r\ndef set_admin(_admin: address):\r\n    \"\"\"\r\n    @notice Set the new admin.\r\n    @dev After all is set up, admin only can change the token name\r\n    @param _admin New admin address\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n    self.admin = _admin\r\n    log SetAdmin(_admin)\r\n\r\n\r\n@external\r\n@view\r\ndef totalSupply() -> uint256:\r\n    \"\"\"\r\n    @notice Total number of tokens in existence.\r\n    \"\"\"\r\n    return self.total_supply\r\n\r\n\r\n@external\r\n@view\r\ndef allowance(_owner : address, _spender : address) -> uint256:\r\n    \"\"\"\r\n    @notice Check the amount of tokens that an owner allowed to a spender\r\n    @param _owner The address which owns the funds\r\n    @param _spender The address which will spend the funds\r\n    @return uint256 specifying the amount of tokens still available for the spender\r\n    \"\"\"\r\n    return self.allowances[_owner][_spender]\r\n\r\n\r\n@external\r\ndef transfer(_to : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @notice Transfer `_value` tokens from `msg.sender` to `_to`\r\n    @dev Vyper does not allow underflows, so the subtraction in\r\n         this function will revert on an insufficient balance\r\n    @param _to The address to transfer to\r\n    @param _value The amount to be transferred\r\n    @return bool success\r\n    \"\"\"\r\n    assert _to != ZERO_ADDRESS  # dev: transfers to 0x0 are not allowed\r\n    self.balanceOf[msg.sender] -= _value\r\n    self.balanceOf[_to] += _value\r\n    log Transfer(msg.sender, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef transferFrom(_from : address, _to : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n     @notice Transfer `_value` tokens from `_from` to `_to`\r\n     @param _from address The address which you want to send tokens from\r\n     @param _to address The address which you want to transfer to\r\n     @param _value uint256 the amount of tokens to be transferred\r\n     @return bool success\r\n    \"\"\"\r\n    assert _to != ZERO_ADDRESS  # dev: transfers to 0x0 are not allowed\r\n    # NOTE: vyper does not allow underflows\r\n    #       so the following subtraction would revert on insufficient balance\r\n    self.balanceOf[_from] -= _value\r\n    self.balanceOf[_to] += _value\r\n    self.allowances[_from][msg.sender] -= _value\r\n    log Transfer(_from, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef approve(_spender : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @notice Approve `_spender` to transfer `_value` tokens on behalf of `msg.sender`\r\n    @dev Approval may only be from zero -> nonzero or from nonzero -> zero in order\r\n        to mitigate the potential race condition described here:\r\n        https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    @param _spender The address which will spend the funds\r\n    @param _value The amount of tokens to be spent\r\n    @return bool success\r\n    \"\"\"\r\n    assert _value == 0 or self.allowances[msg.sender][_spender] == 0\r\n    self.allowances[msg.sender][_spender] = _value\r\n    log Approval(msg.sender, _spender, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef mint(_to: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Mint `_value` tokens and assign them to `_to`\r\n    @dev Emits a Transfer event originating from 0x00\r\n    @param _to The account that will receive the created tokens\r\n    @param _value The amount that will be created\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender == self.minter  # dev: minter only\r\n    assert _to != ZERO_ADDRESS  # dev: zero address\r\n\r\n    if block.timestamp >= self.start_epoch_time + RATE_REDUCTION_TIME:\r\n        self._update_mining_parameters()\r\n\r\n    _total_supply: uint256 = self.total_supply + _value\r\n    assert _total_supply <= self._available_supply()  # dev: exceeds allowable mint amount\r\n    self.total_supply = _total_supply\r\n\r\n    self.balanceOf[_to] += _value\r\n    log Transfer(ZERO_ADDRESS, _to, _value)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef burn(_value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Burn `_value` tokens belonging to `msg.sender`\r\n    @dev Emits a Transfer event with a destination of 0x00\r\n    @param _value The amount that will be burned\r\n    @return bool success\r\n    \"\"\"\r\n    self.balanceOf[msg.sender] -= _value\r\n    self.total_supply -= _value\r\n\r\n    log Transfer(msg.sender, ZERO_ADDRESS, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef set_name(_name: String[64], _symbol: String[32]):\r\n    \"\"\"\r\n    @notice Change the token name and symbol to `_name` and `_symbol`\r\n    @dev Only callable by the admin account\r\n    @param _name New token name\r\n    @param _symbol New token symbol\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"Only admin is allowed to change name\"\r\n    self.name = _name\r\n    self.symbol = _symbol", "ABI": "[{\"name\":\"Transfer\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_to\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Approval\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_spender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateMiningParameters\",\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"rate\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetMinter\",\"inputs\":[{\"name\":\"minter\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetAdmin\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"initialize\",\"inputs\":[{\"name\":\"_init_supply\",\"type\":\"uint256\"},{\"name\":\"_init_rate\",\"type\":\"uint256\"},{\"name\":\"_rate_reduction_coefficient\",\"type\":\"uint256\"},{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"outputs\":[],\"gas\":527577},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_mining_parameters\",\"inputs\":[],\"outputs\":[],\"gas\":156788},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"start_epoch_time_write\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":158997},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"future_epoch_time_write\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":159186},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"available_supply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":7647},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"mintable_in_timeframe\",\"inputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":6170727},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_minter\",\"inputs\":[{\"name\":\"_minter\",\"type\":\"address\"}],\"outputs\":[],\"gas\":41816},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_admin\",\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"outputs\":[],\"gas\":39655},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2700},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"allowance\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3262},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transfer\",\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":79032},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transferFrom\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":116720},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"approve\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":41885},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"mint\",\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":244959},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"burn\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":78779},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_name\",\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"outputs\":[],\"gas\":189038},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"gas\":13229},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"gas\":10988},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"decimals\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3000},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3296},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"minter\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3060},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3090},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"INITIAL_RATE\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3120},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"RATE_REDUCTION_COEFFICIENT\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3150},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"mining_epoch\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}],\"gas\":3180},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"start_epoch_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3210},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3240}]", "ContractName": "Curve DAO Token", "CompilerVersion": "vyper:0.3.1", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}