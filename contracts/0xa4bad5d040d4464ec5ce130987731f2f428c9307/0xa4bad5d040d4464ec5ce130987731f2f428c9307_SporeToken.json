{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ApprovedContractList.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/*\\n    Approve Contracts to interact with pools.\\n    (All contracts are barred from interacting with pools by default.)\\n*/\\ncontract ApprovedContractList is Ownable {\\n    mapping (address => bool) approved;\\n    function isApproved(address toCheck) external returns (bool) {\\n        return approved[toCheck];\\n    }\\n    function approveContract(address toApprove) external onlyOwner {\\n        approved[toApprove] = true;\\n    }\\n\\n    function revokeContract(address toRevoke) external onlyOwner {\\n        approved[toRevoke] = false;\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Defensible.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./ApprovedContractList.sol\\\";\\n\\n/*\\n    Prevent smart contracts from calling functions unless approved by the specified whitelist.\\n*/\\ncontract Defensible {\\n // Only smart contracts will be affected by this modifier\\n  modifier defend(ApprovedContractList approvedContractList) {\\n    require(\\n      (msg.sender == tx.origin) || approvedContractList.isApproved(msg.sender),\\n      \\\"This smart contract has not been approved\\\"\\n    );\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/EnokiGeyser.sol\": {\r\n      \"content\": \"/* \\n    - Stake up to X mushrooms per user (dao can change)\\n    - Reward mushroom yield rate for lifespan\\n    - When dead, burn mushroom erc721\\n    - Distribute 5% of ENOKI rewards to Chefs\\n*/\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./TokenPool.sol\\\";\\nimport \\\"./Defensible.sol\\\";\\nimport \\\"./MushroomNFT.sol\\\";\\nimport \\\"./MushroomLib.sol\\\";\\n\\nimport \\\"./metadata/MushroomMetadata.sol\\\";\\n\\n/**\\n * @title Enoki Geyser\\n * @dev A smart-contract based mechanism to distribute tokens over time, inspired loosely by\\n *      Compound and Uniswap.\\n *\\n *      Distribution tokens are added to a locked pool in the contract and become unlocked over time\\n *      according to a once-configurable unlock schedule. Once unlocked, they are available to be\\n *      claimed by users.\\n *\\n *      A user may deposit tokens to accrue ownership share over the unlocked pool. This owner share\\n *      is a function of the number of tokens deposited as well as the length of time deposited.\\n *      Specifically, a user's share of the currently-unlocked pool equals their \\\"deposit-seconds\\\"\\n *      divided by the global \\\"deposit-seconds\\\". This aligns the new token distribution with long\\n *      term supporters of the project, addressing one of the major drawbacks of simple airdrops.\\n *\\n *      More background and motivation available at:\\n *      https://github.com/ampleforth/RFCs/blob/master/RFCs/rfc-1.md\\n */\\ncontract EnokiGeyser is Initializable, OwnableUpgradeSafe, Defensible {\\n    using SafeMath for uint256;\\n    using MushroomLib for MushroomLib.MushroomData;\\n    using MushroomLib for MushroomLib.MushroomType;\\n\\n    event Staked(address indexed user, address nftContract, uint256 nftId, uint256 total, bytes data);\\n    event Unstaked(address indexed user, address nftContract, uint256 nftId, uint256 total, bytes data);\\n    event TokensClaimed(address indexed user, uint256 amount);\\n    event TokensLocked(uint256 amount, uint256 durationSec, uint256 total);\\n    // amount: Unlocked tokens, total: Total locked tokens\\n    event TokensUnlocked(uint256 amount, uint256 total);\\n\\n    TokenPool private _unlockedPool;\\n    TokenPool private _lockedPool;\\n\\n    MushroomMetadata public mushroomMetadata;\\n\\n    //\\n    // Time-bonus params\\n    //\\n    uint256 public constant BONUS_DECIMALS = 2;\\n    uint256 public startBonus = 0;\\n    uint256 public bonusPeriodSec = 0;\\n\\n    uint256 public maxStakesPerAddress = 0;\\n\\n    //\\n    // Global accounting state\\n    //\\n    uint256 public totalLockedShares = 0;\\n    uint256 public totalStakingShares = 0;\\n    uint256 public totalStrengthStaked = 0;\\n    uint256 private _totalStakingShareSeconds = 0;\\n    uint256 private _lastAccountingTimestampSec = now;\\n    uint256 private _maxUnlockSchedules = 0;\\n    uint256 private _initialSharesPerToken = 0;\\n\\n    //\\n    // Dev reward state\\n    //\\n    uint256 public constant MAX_PERCENTAGE = 100;\\n    uint256 public devRewardPercentage = 0; //0% - 100%\\n    address public devRewardAddress;\\n\\n    address public admin;\\n    ApprovedContractList public approvedContractList;\\n\\n    //\\n    // User accounting state\\n    //\\n    // Represents a single stake for a user. A user may have multiple.\\n    struct Stake {\\n        address nftContract;\\n        uint256 nftIndex;\\n        uint256 stakingShares;\\n        uint256 timestampSec;\\n    }\\n\\n    // Caches aggregated values from the User->Stake[] map to save computation.\\n    // If lastAccountingTimestampSec is 0, there's no entry for that user.\\n    struct UserTotals {\\n        uint256 stakingShares;\\n        uint256 stakingShareSeconds;\\n        uint256 lastAccountingTimestampSec;\\n    }\\n\\n    // Aggregated staking values per user\\n    mapping(address => UserTotals) private _userTotals;\\n\\n    // The collection of stakes for each user. Ordered by timestamp, earliest to latest.\\n    mapping(address => Stake[]) private _userStakes;\\n\\n    //\\n    // Locked/Unlocked Accounting state\\n    //\\n    struct UnlockSchedule {\\n        uint256 initialLockedShares;\\n        uint256 unlockedShares;\\n        uint256 lastUnlockTimestampSec;\\n        uint256 endAtSec;\\n        uint256 durationSec;\\n    }\\n\\n    UnlockSchedule[] public unlockSchedules;\\n\\n    /**\\n     * @param distributionToken The token users receive as they unstake.\\n     * @param maxUnlockSchedules Max number of unlock stages, to guard against hitting gas limit.\\n     * @param startBonus_ Starting time bonus, BONUS_DECIMALS fixed point.\\n     *                    e.g. 25% means user gets 25% of max distribution tokens.\\n     * @param bonusPeriodSec_ Length of time for bonus to increase linearly to max.\\n     * @param initialSharesPerToken Number of shares to mint per staking token on first stake.\\n     * @param maxStakesPerAddress_ Maximum number of NFTs stakeable by a given account.\\n     * @param devRewardAddress_ Recipient address of dev rewards.\\n     * @param devRewardPercentage_ Pecentage of rewards claimed to be distributed for dev address.\\n\\n     */\\n    function initialize(\\n        IERC20 distributionToken,\\n        uint256 maxUnlockSchedules,\\n        uint256 startBonus_,\\n        uint256 bonusPeriodSec_,\\n        uint256 initialSharesPerToken,\\n        uint256 maxStakesPerAddress_,\\n        address devRewardAddress_,\\n        uint256 devRewardPercentage_,\\n        address approvedContractList_,\\n        address admin_\\n    ) public initializer {\\n        // The start bonus must be some fraction of the max. (i.e. <= 100%)\\n        require(startBonus_ <= 10**BONUS_DECIMALS, \\\"EnokiGeyser: start bonus too high\\\");\\n        // If no period is desired, instead set startBonus = 100%\\n        // and bonusPeriod to a small value like 1sec.\\n        require(bonusPeriodSec_ != 0, \\\"EnokiGeyser: bonus period is zero\\\");\\n        require(initialSharesPerToken > 0, \\\"EnokiGeyser: initialSharesPerToken is zero\\\");\\n\\n        // The dev reward must be some fraction of the max. (i.e. <= 100%)\\n        require(devRewardPercentage_ <= MAX_PERCENTAGE, \\\"EnokiGeyser: dev reward too high\\\");\\n        \\n        __Ownable_init();\\n\\n        _unlockedPool = new TokenPool(distributionToken);\\n        _lockedPool = new TokenPool(distributionToken);\\n        startBonus = startBonus_;\\n        bonusPeriodSec = bonusPeriodSec_;\\n        _maxUnlockSchedules = maxUnlockSchedules;\\n        _initialSharesPerToken = initialSharesPerToken;\\n        maxStakesPerAddress = maxStakesPerAddress_;\\n\\n        devRewardPercentage = devRewardPercentage_;\\n        devRewardAddress = devRewardAddress_;\\n\\n        admin = admin_;\\n\\n        approvedContractList = ApprovedContractList(approvedContractList_);\\n    }\\n\\n    // TODO: Add a method for per-index staking access\\n    function isNftStakeable(address nftContract) public view returns (bool) {\\n        return mushroomMetadata.hasMetadataResolver(nftContract);\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(admin == msg.sender, \\\"EnokiGeyser: Only Admin\\\");\\n        _;\\n    }\\n\\n    // Only effects future stakes\\n    function setMaxStakesPerAddress(uint256 maxStakes) public onlyAdmin {\\n        maxStakesPerAddress = maxStakes;\\n    }\\n\\n    function setMushroomMetadata(address mushroomMetadata_) public onlyAdmin {\\n        mushroomMetadata = MushroomMetadata(mushroomMetadata_);\\n    }\\n\\n    /**\\n     * @return The token users receive as they unstake.\\n     */\\n    function getDistributionToken() public view returns (IERC20) {\\n        assert(_unlockedPool.token() == _lockedPool.token());\\n        return _unlockedPool.token();\\n    }\\n\\n    /**\\n     * @dev Transfers amount of deposit tokens from the user.\\n     * @param data Not used.\\n     */\\n    function stake(\\n        address nftContract,\\n        uint256 nftIndex,\\n        bytes calldata data\\n    ) external defend(approvedContractList) {\\n        require(isNftStakeable(nftContract), \\\"EnokiGeyser: nft not stakeable\\\");\\n        _stakeFor(msg.sender, msg.sender, nftContract, nftIndex);\\n    }\\n\\n    /**\\n     * @dev Private implementation of staking methods.\\n     * @param staker User address who deposits tokens to stake.\\n     * @param beneficiary User address who gains credit for this stake operation.\\n     */\\n    function _stakeFor(\\n        address staker,\\n        address beneficiary,\\n        address nftContract,\\n        uint256 nftIndex\\n    ) private {\\n        require(beneficiary != address(0), \\\"EnokiGeyser: beneficiary is zero address\\\");\\n        require(totalStakingShares == 0 || totalStaked() > 0, \\\"EnokiGeyser: Invalid state. Staking shares exist, but no staking tokens do\\\");\\n        require(isNftStakeable(nftContract), \\\"EnokiGeyser: Nft contract specified not stakeable\\\");\\n\\n        // Shares is determined by NFT mushroom rate\\n\\n        MushroomLib.MushroomData memory metadata = mushroomMetadata.getMushroomData(nftContract, nftIndex, \\\"\\\");\\n\\n        uint256 mintedStakingShares = (totalStakingShares > 0)\\n            ? totalStakingShares.mul(metadata.strength).div(totalStaked())\\n            : metadata.strength.mul(_initialSharesPerToken);\\n        require(mintedStakingShares > 0, \\\"EnokiGeyser: Stake amount is too small\\\");\\n\\n        updateAccounting();\\n\\n        // 1. User Accounting\\n        UserTotals storage totals = _userTotals[beneficiary];\\n        totals.stakingShares = totals.stakingShares.add(mintedStakingShares);\\n        totals.lastAccountingTimestampSec = now;\\n\\n        Stake memory newStake = Stake(nftContract, nftIndex, mintedStakingShares, now);\\n        _userStakes[beneficiary].push(newStake);\\n\\n        require(_userStakes[beneficiary].length <= maxStakesPerAddress, \\\"EnokiGeyser: Stake would exceed maximum stakes for address\\\");\\n\\n        // 2. Global Accounting\\n        totalStakingShares = totalStakingShares.add(mintedStakingShares);\\n        // Already set in updateAccounting()\\n        // _lastAccountingTimestampSec = now;\\n\\n        // interactions - rather than taking staking tokens, we take the NFT and track the amount staked locally\\n        // require(_stakingPool.token().transferFrom(staker, address(_stakingPool), amount), \\\"EnokiGeyser: transfer into staking pool failed\\\");\\n\\n        totalStrengthStaked = totalStrengthStaked.add(metadata.strength);\\n        IERC721(nftContract).transferFrom(staker, address(this), nftIndex);\\n\\n        emit Staked(beneficiary, nftContract, nftIndex, totalStakedFor(beneficiary), \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Unstakes a certain amount of previously deposited tokens. User also receives their\\n     * alotted number of distribution tokens.\\n     * @param stakes Mushrooms to unstake.\\n     * @param data Not used.\\n     */\\n    function unstake(uint256[] calldata stakes, bytes calldata data) external {\\n        _unstake(stakes);\\n    }\\n\\n    /**\\n     * @param stakes Mushrooms to unstake.\\n     */\\n    function unstakeQuery(uint256[] memory stakes)\\n        public\\n        returns (\\n            uint256 totalReward,\\n            uint256 userReward,\\n            uint256 devReward\\n        )\\n    {\\n        return _unstake(stakes);\\n    }\\n\\n    /**\\n     * @dev Unstakes a certain amount of previously deposited tokens. User also receives their\\n     * alotted number of distribution tokens.\\n     * @param stakes Mushrooms to unstake.\\n     */\\n    function _unstake(uint256[] memory stakes)\\n        private\\n        returns (\\n            uint256 totalReward,\\n            uint256 userReward,\\n            uint256 devReward\\n        )\\n    {\\n        updateAccounting();\\n\\n        // 1. User Accounting\\n        UserTotals storage totals = _userTotals[msg.sender];\\n        Stake[] storage accountStakes = _userStakes[msg.sender];\\n\\n        // Redeem from most recent stake and go backwards in time.\\n        uint256 rewardAmount = 0;\\n\\n        for (uint256 i = 0; i < stakes.length; i++) {\\n            Stake storage lastStake = accountStakes[i];\\n\\n            MushroomLib.MushroomData memory metadata = mushroomMetadata.getMushroomData(lastStake.nftContract, lastStake.nftIndex, \\\"\\\");\\n            uint256 lifespanUsed = now.sub(lastStake.timestampSec);\\n\\n            // fully redeem a past stake\\n            uint256 stakingShareSecondsToBurn = lastStake.stakingShares.mul(lifespanUsed);\\n            rewardAmount = computeNewReward(rewardAmount, stakingShareSecondsToBurn, lifespanUsed);\\n\\n            bool toBurn = false;\\n\\n            if (metadata.lifespan <= lifespanUsed) {\\n                lifespanUsed = metadata.lifespan;\\n                toBurn = true;\\n            }\\n\\n            // Update global aomunt staked\\n            totalStrengthStaked = totalStrengthStaked.sub(metadata.strength);\\n\\n            if (toBurn) {\\n                // Burn dead mushrooms\\n                MushroomNFT(lastStake.nftContract).burn(lastStake.nftIndex);\\n            } else {\\n                // If still alive, reduce lifespan of mushroom and return to user\\n                mushroomMetadata.setMushroomLifespan(lastStake.nftContract, lastStake.nftIndex, metadata.lifespan.sub(lifespanUsed), \\\"\\\");\\n                IERC721(lastStake.nftContract).transferFrom(address(this), msg.sender, lastStake.nftIndex);\\n            }\\n\\n            totals.stakingShareSeconds = totals.stakingShareSeconds.sub(stakingShareSecondsToBurn);\\n            totals.stakingShares = totals.stakingShares.sub(lastStake.stakingShares);\\n\\n            // 2. Global Accounting\\n            _totalStakingShareSeconds = _totalStakingShareSeconds.sub(stakingShareSecondsToBurn);\\n            totalStakingShares = totalStakingShares.sub(lastStake.stakingShares);\\n\\n            accountStakes.pop();\\n            emit Unstaked(msg.sender, lastStake.nftContract, lastStake.nftIndex, totalStakedFor(msg.sender), \\\"\\\");\\n        }\\n\\n        // Already set in updateAccounting\\n        // _lastAccountingTimestampSec = now;\\n\\n        // interactions\\n        totalReward = rewardAmount;\\n        (userReward, devReward) = computeDevReward(totalReward);\\n        if (userReward > 0) {\\n            require(_unlockedPool.transfer(msg.sender, userReward), \\\"EnokiGeyser: transfer to user out of unlocked pool failed\\\");\\n        }\\n\\n        if (devReward > 0) {\\n            require(_unlockedPool.transfer(devRewardAddress, devReward), \\\"EnokiGeyser: transfer to dev out of unlocked pool failed\\\");\\n        }\\n\\n        emit TokensClaimed(msg.sender, rewardAmount);\\n\\n        require(totalStakingShares == 0 || totalStaked() > 0, \\\"EnokiGeyser: Error unstaking. Staking shares exist, but no staking tokens do\\\");\\n    }\\n\\n    /**\\n     * @dev Applies an additional time-bonus to a distribution amount. This is necessary to\\n     *      encourage long-term deposits instead of constant unstake/restakes.\\n     *      The bonus-multiplier is the result of a linear function that starts at startBonus and\\n     *      ends at 100% over bonusPeriodSec, then stays at 100% thereafter.\\n     * @param currentRewardTokens The current number of distribution tokens already alotted for this\\n     *                            unstake op. Any bonuses are already applied.\\n     * @param stakingShareSeconds The stakingShare-seconds that are being burned for new\\n     *                            distribution tokens.\\n     * @param stakeTimeSec Length of time for which the tokens were staked. Needed to calculate\\n     *                     the time-bonus.\\n     * @return Updated amount of distribution tokens to award, with any bonus included on the\\n     *         newly added tokens.\\n     */\\n    function computeNewReward(\\n        uint256 currentRewardTokens,\\n        uint256 stakingShareSeconds,\\n        uint256 stakeTimeSec\\n    ) private view returns (uint256) {\\n        uint256 newRewardTokens = totalUnlocked().mul(stakingShareSeconds).div(_totalStakingShareSeconds);\\n\\n        if (stakeTimeSec >= bonusPeriodSec) {\\n            return currentRewardTokens.add(newRewardTokens);\\n        }\\n\\n        uint256 oneHundredPct = 10**BONUS_DECIMALS;\\n        uint256 bonusedReward = startBonus.add(oneHundredPct.sub(startBonus).mul(stakeTimeSec).div(bonusPeriodSec)).mul(newRewardTokens).div(\\n            oneHundredPct\\n        );\\n        return currentRewardTokens.add(bonusedReward);\\n    }\\n\\n    /**\\n     * @dev Determines split of specified reward amount between user and dev.\\n     * @param totalReward Amount of reward to split.\\n     * @return userReward Reward amounts for user and dev.\\n     * @return devReward Reward amounts for user and dev.\\n     */\\n    function computeDevReward(uint256 totalReward) public view returns (uint256 userReward, uint256 devReward) {\\n        if (devRewardPercentage == 0) {\\n            userReward = totalReward;\\n            devReward = 0;\\n        } else if (devRewardPercentage == MAX_PERCENTAGE) {\\n            userReward = 0;\\n            devReward = totalReward;\\n        } else {\\n            devReward = totalReward.mul(devRewardPercentage).div(MAX_PERCENTAGE);\\n            userReward = totalReward.sub(devReward); // Extra dust due to truncated rounding goes to user\\n        }\\n    }\\n\\n    /**\\n     * @param addr The user to look up staking information for.\\n     * @return The number of staking tokens deposited for addr.\\n     */\\n    function totalStakedFor(address addr) public view returns (uint256) {\\n        return totalStakingShares > 0 ? totalStaked().mul(_userTotals[addr].stakingShares).div(totalStakingShares) : 0;\\n    }\\n\\n    /**\\n     * @return The total number of deposit tokens staked globally, by all users.\\n     */\\n    function totalStaked() public view returns (uint256) {\\n        return totalStrengthStaked;\\n    }\\n\\n    /**\\n     * @dev A globally callable function to update the accounting state of the system.\\n     *      Global state and state for the caller are updated.\\n     * @return [0] balance of the locked pool\\n     * @return [1] balance of the unlocked pool\\n     * @return [2] caller's staking share seconds\\n     * @return [3] global staking share seconds\\n     * @return [4] Rewards caller has accumulated, optimistically assumes max time-bonus.\\n     * @return [5] block timestamp\\n     */\\n    function updateAccounting()\\n        public\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        unlockTokens();\\n\\n        // Global accounting\\n        uint256 newStakingShareSeconds = now.sub(_lastAccountingTimestampSec).mul(totalStakingShares);\\n        _totalStakingShareSeconds = _totalStakingShareSeconds.add(newStakingShareSeconds);\\n        _lastAccountingTimestampSec = now;\\n\\n        // User Accounting\\n        UserTotals storage totals = _userTotals[msg.sender];\\n        uint256 newUserStakingShareSeconds = now.sub(totals.lastAccountingTimestampSec).mul(totals.stakingShares);\\n        totals.stakingShareSeconds = totals.stakingShareSeconds.add(newUserStakingShareSeconds);\\n        totals.lastAccountingTimestampSec = now;\\n\\n        uint256 totalUserRewards = (_totalStakingShareSeconds > 0)\\n            ? totalUnlocked().mul(totals.stakingShareSeconds).div(_totalStakingShareSeconds)\\n            : 0;\\n\\n        return (totalLocked(), totalUnlocked(), totals.stakingShareSeconds, _totalStakingShareSeconds, totalUserRewards, now);\\n    }\\n\\n    /**\\n     * @return Total number of locked distribution tokens.\\n     */\\n    function totalLocked() public view returns (uint256) {\\n        return _lockedPool.balance();\\n    }\\n\\n    /**\\n     * @return Total number of unlocked distribution tokens.\\n     */\\n    function totalUnlocked() public view returns (uint256) {\\n        return _unlockedPool.balance();\\n    }\\n\\n    /**\\n     * @return Number of unlock schedules.\\n     */\\n    function unlockScheduleCount() public view returns (uint256) {\\n        return unlockSchedules.length;\\n    }\\n\\n    /**\\n     * @dev This funcion allows the contract owner to add more locked distribution tokens, along\\n     *      with the associated \\\"unlock schedule\\\". These locked tokens immediately begin unlocking\\n     *      linearly over the duraction of durationSec timeframe.\\n     * @param amount Number of distribution tokens to lock. These are transferred from the caller.\\n     * @param durationSec Length of time to linear unlock the tokens.\\n     */\\n    function lockTokens(uint256 amount, uint256 durationSec) external onlyOwner {\\n        require(unlockSchedules.length < _maxUnlockSchedules, \\\"EnokiGeyser: reached maximum unlock schedules\\\");\\n\\n        // Update lockedTokens amount before using it in computations after.\\n        updateAccounting();\\n\\n        uint256 lockedTokens = totalLocked();\\n        uint256 mintedLockedShares = (lockedTokens > 0) ? totalLockedShares.mul(amount).div(lockedTokens) : amount.mul(_initialSharesPerToken);\\n\\n        UnlockSchedule memory schedule;\\n        schedule.initialLockedShares = mintedLockedShares;\\n        schedule.lastUnlockTimestampSec = now;\\n        schedule.endAtSec = now.add(durationSec);\\n        schedule.durationSec = durationSec;\\n        unlockSchedules.push(schedule);\\n\\n        totalLockedShares = totalLockedShares.add(mintedLockedShares);\\n\\n        require(_lockedPool.token().transferFrom(msg.sender, address(_lockedPool), amount), \\\"EnokiGeyser: transfer into locked pool failed\\\");\\n        emit TokensLocked(amount, durationSec, totalLocked());\\n    }\\n\\n    /**\\n     * @dev Moves distribution tokens from the locked pool to the unlocked pool, according to the\\n     *      previously defined unlock schedules. Publicly callable.\\n     * @return Number of newly unlocked distribution tokens.\\n     */\\n    function unlockTokens() public returns (uint256) {\\n        uint256 unlockedTokens = 0;\\n        uint256 lockedTokens = totalLocked();\\n\\n        if (totalLockedShares == 0) {\\n            unlockedTokens = lockedTokens;\\n        } else {\\n            uint256 unlockedShares = 0;\\n            for (uint256 s = 0; s < unlockSchedules.length; s++) {\\n                unlockedShares = unlockedShares.add(unlockScheduleShares(s));\\n            }\\n            unlockedTokens = unlockedShares.mul(lockedTokens).div(totalLockedShares);\\n            totalLockedShares = totalLockedShares.sub(unlockedShares);\\n        }\\n\\n        if (unlockedTokens > 0) {\\n            require(_lockedPool.transfer(address(_unlockedPool), unlockedTokens), \\\"EnokiGeyser: transfer out of locked pool failed\\\");\\n            emit TokensUnlocked(unlockedTokens, totalLocked());\\n        }\\n\\n        return unlockedTokens;\\n    }\\n\\n    /**\\n     * @dev Returns the number of unlockable shares from a given schedule. The returned value\\n     *      depends on the time since the last unlock. This function updates schedule accounting,\\n     *      but does not actually transfer any tokens.\\n     * @param s Index of the unlock schedule.\\n     * @return The number of unlocked shares.\\n     */\\n    function unlockScheduleShares(uint256 s) private returns (uint256) {\\n        UnlockSchedule storage schedule = unlockSchedules[s];\\n\\n        if (schedule.unlockedShares >= schedule.initialLockedShares) {\\n            return 0;\\n        }\\n\\n        uint256 sharesToUnlock = 0;\\n        // Special case to handle any leftover dust from integer division\\n        if (now >= schedule.endAtSec) {\\n            sharesToUnlock = (schedule.initialLockedShares.sub(schedule.unlockedShares));\\n            schedule.lastUnlockTimestampSec = schedule.endAtSec;\\n        } else {\\n            sharesToUnlock = now.sub(schedule.lastUnlockTimestampSec).mul(schedule.initialLockedShares).div(schedule.durationSec);\\n            schedule.lastUnlockTimestampSec = now;\\n        }\\n\\n        schedule.unlockedShares = schedule.unlockedShares.add(sharesToUnlock);\\n        return sharesToUnlock;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\nimport \\\"../Initializable.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract OwnableUpgradeSafe is Initializable, ContextUpgradeSafe {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n\\n\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n\\n    }\\n\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\nimport \\\"../Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract ContextUpgradeSafe is Initializable {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n\\n\\n    }\\n\\n\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24 <0.7.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"contracts/TokenPool.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title A simple holder of tokens.\\n * This is a simple contract to hold tokens. It's useful in the case where a separate contract\\n * needs to hold multiple distinct pools of the same token.\\n */\\ncontract TokenPool is Ownable {\\n    IERC20 public token;\\n\\n    constructor(IERC20 _token) public {\\n        token = _token;\\n    }\\n\\n    function balance() public view returns (uint256) {\\n        return token.balanceOf(address(this));\\n    }\\n\\n    function transfer(address to, uint256 value) external onlyOwner returns (bool) {\\n        return token.transfer(to, value);\\n    }\\n\\n    function rescueFunds(address tokenToRescue, address to, uint256 amount) external onlyOwner returns (bool) {\\n        require(address(token) != tokenToRescue, 'TokenPool: Cannot claim token held by the contract');\\n\\n        return IERC20(tokenToRescue).transfer(to, amount);\\n    }\\n}\"\r\n    },\r\n    \"contracts/MushroomNFT.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\nimport \\\"./MushroomLib.sol\\\";\\n\\n/*\\n    Minting and burning permissions are managed by the Owner\\n*/\\ncontract MushroomNFT is ERC721(\\\"Mushroom\\\", \\\"Mushroom\\\"), Ownable {\\n    using MushroomLib for MushroomLib.MushroomData;\\n    using MushroomLib for MushroomLib.MushroomType;\\n\\n    mapping (uint256 => MushroomLib.MushroomData) public mushroomData; // NFT Id -> Metadata\\n    mapping (uint256 => MushroomLib.MushroomType) public mushroomTypes; // Species Id -> Metadata\\n    mapping (uint256 => bool) public mushroomTypeExists; // Species Id -> Exists\\n\\n    /* ========== VIEWS ========== */\\n\\n    // Mushrooms inherit their strength from their species\\n    function getMushroomData(uint256 tokenId) public view returns (MushroomLib.MushroomData memory) {\\n        MushroomLib.MushroomData memory data = mushroomData[tokenId];\\n        return data;\\n    }\\n\\n    function getSpecies(uint256 speciesId) public view returns (MushroomLib.MushroomType memory) {\\n        return mushroomTypes[speciesId];\\n    }\\n\\n    function getRemainingMintableForSpecies(uint256 speciesId) public view returns (uint256) {\\n        MushroomLib.MushroomType storage species = mushroomTypes[speciesId];\\n        return species.cap.sub(species.minted);\\n    }\\n    \\n    // TODO: Allowed approved contracts to set lifespan\\n    function setMushroomLifespan(uint256 index, uint256 lifespan) public onlyOwner {\\n        MushroomLib.MushroomData storage data = mushroomData[index];\\n        data.lifespan = lifespan;\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    /**\\n     * @dev Burns `tokenId`. See {ERC721-_burn}. Also clears mushroom data for this token.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own `tokenId` or be an approved operator.\\n     */\\n    function burn(uint256 tokenId) public {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721Burnable: caller is not owner nor approved\\\");\\n        _burn(tokenId);\\n        _clearMushroomData(tokenId);\\n    }\\n\\n    // TODO: Approved Minters only\\n    function mint(address recipient, uint256 tokenId, uint256 speciesId, uint256 lifespan) public {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721Burnable: caller is not owner nor approved\\\");\\n        _mintWithMetadata(recipient, tokenId, speciesId, lifespan);\\n    }\\n\\n    function _mintWithMetadata(address recipient, uint256 tokenId, uint256 speciesId, uint256 lifespan) internal {\\n        require(mushroomTypeExists[speciesId], \\\"MushroomNFT: mushroom species specified does not exist\\\");\\n        MushroomLib.MushroomType storage species = mushroomTypes[speciesId];\\n\\n        require(species.minted < species.cap, \\\"MushroomNFT: minting cap reached for species\\\");\\n\\n        species.minted = species.minted.add(1);\\n        mushroomData[tokenId] = MushroomLib.MushroomData(speciesId, species.strength, lifespan);\\n\\n        _mint(recipient, tokenId);\\n    }\\n\\n    // TODO: We don't really have to do this as a newly minted mushroom will set the data\\n    function _clearMushroomData(uint256 tokenId) internal {\\n        MushroomLib.MushroomData storage data = mushroomData[tokenId];\\n        MushroomLib.MushroomType storage species = mushroomTypes[data.species];     \\n\\n        species.minted = species.minted.sub(1);\\n    }\\n    function setMushroomType(uint256 speciesId, MushroomLib.MushroomType memory mType) public onlyOwner {\\n        if (!mushroomTypeExists[speciesId]) {\\n            mushroomTypeExists[speciesId] = true;\\n        }\\n\\n        mushroomTypes[speciesId] = mType;\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Metadata.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/EnumerableSet.sol\\\";\\nimport \\\"../../utils/EnumerableMap.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\\n    using SafeMath for uint256;\\n    using Address for address;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using Strings for uint256;\\n\\n    // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\n\\n    // Mapping from holder address to their (enumerable) set of owned tokens\\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\\n\\n    // Enumerable mapping from token ids to their owners\\n    EnumerableMap.UintToAddressMap private _tokenOwners;\\n\\n    // Mapping from token ID to approved address\\n    mapping (uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Optional mapping for token URIs\\n    mapping (uint256 => string) private _tokenURIs;\\n\\n    // Base URI\\n    string private _baseURI;\\n\\n    /*\\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\\n     *\\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n\\n    /*\\n     *     bytes4(keccak256('name()')) == 0x06fdde03\\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\\n     *\\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n\\n    /*\\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\\n     *\\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n\\n        // register the supported interfaces to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC721);\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n\\n        return _holderTokens[owner].length();\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        return _tokenOwners.get(tokenId, \\\"ERC721: owner query for nonexistent token\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory _tokenURI = _tokenURIs[tokenId];\\n\\n        // If there is no base URI, return the token URI.\\n        if (bytes(_baseURI).length == 0) {\\n            return _tokenURI;\\n        }\\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\\n        if (bytes(_tokenURI).length > 0) {\\n            return string(abi.encodePacked(_baseURI, _tokenURI));\\n        }\\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\\n        return string(abi.encodePacked(_baseURI, tokenId.toString()));\\n    }\\n\\n    /**\\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\\n    * to the token ID if no specific URI is set for that token ID.\\n    */\\n    function baseURI() public view returns (string memory) {\\n        return _baseURI;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\\n        return _holderTokens[owner].at(index);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\\n        return _tokenOwners.length();\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\\n        (uint256 tokenId, ) = _tokenOwners.at(index);\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        return _tokenOwners.contains(tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     d*\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _mint(to, tokenId);\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _holderTokens[to].add(tokenId);\\n\\n        _tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        // Clear metadata (if any)\\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\\n            delete _tokenURIs[tokenId];\\n        }\\n\\n        _holderTokens[owner].remove(tokenId);\\n\\n        _tokenOwners.remove(tokenId);\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _holderTokens[from].remove(tokenId);\\n        _holderTokens[to].add(tokenId);\\n\\n        _tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI set of nonexistent token\\\");\\n        _tokenURIs[tokenId] = _tokenURI;\\n    }\\n\\n    /**\\n     * @dev Internal function to set the base URI for all token IDs. It is\\n     * automatically added as a prefix to the value returned in {tokenURI},\\n     * or to the token ID if {tokenURI} is empty.\\n     */\\n    function _setBaseURI(string memory baseURI_) internal virtual {\\n        _baseURI = baseURI_;\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n        private returns (bool)\\n    {\\n        if (!to.isContract()) {\\n            return true;\\n        }\\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\\n            IERC721Receiver(to).onERC721Received.selector,\\n            _msgSender(),\\n            from,\\n            tokenId,\\n            _data\\n        ), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n        bytes4 retval = abi.decode(returndata, (bytes4));\\n        return (retval == _ERC721_RECEIVED);\\n    }\\n\\n    function _approve(address to, uint256 tokenId) private {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)\\n    external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\ncontract ERC165 is IERC165 {\\n    /*\\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    /**\\n     * @dev Mapping of interface ids to whether or not it's supported.\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    constructor () internal {\\n        // Derived contracts need only register support for their own interfaces,\\n        // we register support for ERC165 itself here\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     *\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\\n * (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint256(_at(set._inner, index)));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\\n * supported.\\n */\\nlibrary EnumerableMap {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Map type with\\n    // bytes32 keys and values.\\n    // The Map implementation uses private functions, and user-facing\\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\\n    // the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit\\n    // in bytes32.\\n\\n    struct MapEntry {\\n        bytes32 _key;\\n        bytes32 _value;\\n    }\\n\\n    struct Map {\\n        // Storage of map keys and values\\n        MapEntry[] _entries;\\n\\n        // Position of the entry defined by a key in the `entries` array, plus 1\\n        // because index 0 means a key is not in the map.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\\n            map._entries.push(MapEntry({ _key: key, _value: value }));\\n            // The entry is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            map._indexes[key] = map._entries.length;\\n            return true;\\n        } else {\\n            map._entries[keyIndex - 1]._value = value;\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = keyIndex - 1;\\n            uint256 lastIndex = map._entries.length - 1;\\n\\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            MapEntry storage lastEntry = map._entries[lastIndex];\\n\\n            // Move the last entry to the index where the entry to delete is\\n            map._entries[toDeleteIndex] = lastEntry;\\n            // Update the index for the moved entry\\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved entry was stored\\n            map._entries.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete map._indexes[key];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\\n        return map._indexes[key] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function _length(Map storage map) private view returns (uint256) {\\n        return map._entries.length;\\n    }\\n\\n   /**\\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of entries inside the\\n    * array, and it may change when more entries are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\\n        require(map._entries.length > index, \\\"EnumerableMap: index out of bounds\\\");\\n\\n        MapEntry storage entry = map._entries[index];\\n        return (entry._key, entry._value);\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\\n        return _get(map, key, \\\"EnumerableMap: nonexistent key\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\\n     */\\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\\n    }\\n\\n    // UintToAddressMap\\n\\n    struct UintToAddressMap {\\n        Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n        return _set(map._inner, bytes32(key), bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return _remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return _contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return _length(map._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the element stored at position `index` in the set. O(1).\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n        return (uint256(key), address(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint256(_get(map._inner, bytes32(key))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\\n        return address(uint256(_get(map._inner, bytes32(key), errorMessage)));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        uint256 index = digits - 1;\\n        temp = value;\\n        while (temp != 0) {\\n            buffer[index--] = byte(uint8(48 + temp % 10));\\n            temp /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MushroomLib.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nlibrary MushroomLib {\\n    struct MushroomData {\\n        uint256 species;\\n        uint256 strength;\\n        uint256 lifespan;\\n    }\\n\\n    struct MushroomType {\\n        uint256 id;\\n        uint256 strength;\\n        uint256 minLifespan;\\n        uint256 maxLifespan;\\n        uint256 minted;\\n        uint256 cap;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/metadata/MushroomMetadata.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./resolvers/MetadataResolver.sol\\\";\\nimport \\\"../MushroomLib.sol\\\";\\n\\ncontract MushroomMetadata is Ownable {\\n    using MushroomLib for MushroomLib.MushroomData;\\n    using MushroomLib for MushroomLib.MushroomType;\\n\\n    mapping(address => address) public metadataResolvers;\\n\\n    event ResolverSet(address nft, address resolver);\\n\\n    modifier onlyWithMetadataResolver(address nftContract) {\\n        require(metadataResolvers[nftContract] != address(0), \\\"MetadataRegistry: No resolver set for nft\\\");\\n        _;\\n    }\\n\\n    function hasMetadataResolver(address nftContract) external view returns (bool) {\\n        return metadataResolvers[nftContract] != address(0);\\n    }\\n\\n    function getMushroomData(\\n        address nftContract,\\n        uint256 nftIndex,\\n        bytes calldata data\\n    ) external view onlyWithMetadataResolver(nftContract) returns (MushroomLib.MushroomData memory) {\\n        MetadataResolver resolver = MetadataResolver(metadataResolvers[nftContract]);\\n        MushroomLib.MushroomData memory mushroomData = resolver.getMushroomData(nftIndex, data);\\n        return mushroomData;\\n    }\\n\\n    function setMushroomLifespan(\\n        address nftContract,\\n        uint256 nftIndex,\\n        uint256 lifespan,\\n        bytes calldata data\\n    ) external onlyWithMetadataResolver(nftContract) {\\n        MetadataResolver resolver = MetadataResolver(metadataResolvers[nftContract]);\\n        resolver.setMushroomLifespan(nftIndex, lifespan, data);\\n    }\\n\\n    function setResolver(address nftContract, address resolver) public onlyOwner {\\n        metadataResolvers[nftContract] = resolver;\\n\\n        emit ResolverSet(nftContract, resolver);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/metadata/resolvers/MetadataResolver.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../MushroomLib.sol\\\";\\n\\nabstract contract MetadataResolver {\\n    using MushroomLib for MushroomLib.MushroomData;\\n    using MushroomLib for MushroomLib.MushroomType;\\n\\n    function getMushroomData(uint256 index, bytes calldata data) external virtual view returns (MushroomLib.MushroomData memory);\\n    function setMushroomLifespan(uint256 index, uint256 lifespan, bytes calldata data) external virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/EthVesting.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n/**\\n * @title EthVesting\\n * @dev A eth holder contract that can release its eth balance gradually like a\\n * typical vesting scheme, with a cliff and vesting period.\\n */\\ncontract EthVesting {\\n    // The vesting schedule is time-based (i.e. using block timestamps as opposed to e.g. block numbers), and is\\n    // therefore sensitive to timestamp manipulation (which is something miners can do, to a certain degree). Therefore,\\n    // it is recommended to avoid using short time durations (less than a minute). Typical vesting schemes, with a\\n    // cliff period of a year and a duration of four years, are safe to use.\\n    // solhint-disable not-rely-on-time\\n\\n    using SafeMath for uint256;\\n\\n    event EthReleased(uint256 amount);\\n    event EthReleasedBackup(uint256 amount);\\n    event PaymentReceived(address from, uint256 amount);\\n\\n    // beneficiary of tokens after they are released\\n    address payable private _beneficiary;\\n    address payable private _backupBeneficiary;\\n\\n    // Durations and timestamps are expressed in UNIX time, the same units as block.timestamp.\\n    uint256 private _cliff;\\n    uint256 private _start;\\n    uint256 private _duration;\\n    uint256 private _backupReleaseGracePeriod;\\n\\n    uint256 private _released;\\n\\n    /**\\n     * @dev Creates a vesting contract that vests its balance of any ERC20 token to the\\n     * beneficiary, gradually in a linear fashion until start + duration. By then all\\n     * of the balance will have vested.\\n     * @param beneficiary address of the beneficiary to whom vested tokens are transferred\\n     * @param cliffDuration duration in seconds of the cliff in which tokens will begin to vest\\n     * @param start the time (as Unix time) at which point vesting starts\\n     * @param duration duration in seconds of the period in which the tokens will vest\\n     * @param backupReleaseGracePeriod the period after the duration in completed before the backup beneficiary can withdraw\\n     */\\n    constructor (address payable beneficiary, address payable backupBeneficiary, uint256 start, uint256 cliffDuration, uint256 duration, uint256 backupReleaseGracePeriod) public {\\n        require(beneficiary != address(0), \\\"EthVesting: beneficiary is the zero address\\\");\\n        // solhint-disable-next-line max-line-length\\n        require(cliffDuration <= duration, \\\"EthVesting: cliff is longer than duration\\\");\\n        require(duration > 0, \\\"EthVesting: duration is 0\\\");\\n        // solhint-disable-next-line max-line-length\\n        require(start.add(duration) > block.timestamp, \\\"EthVesting: final time is before current time\\\");\\n\\n        _beneficiary = beneficiary;\\n        _backupBeneficiary = backupBeneficiary;\\n        _duration = duration;\\n        _cliff = start.add(cliffDuration);\\n        _start = start;\\n        _backupReleaseGracePeriod = backupReleaseGracePeriod;\\n    }\\n\\n    /**\\n     * @return the beneficiary of the ether.\\n     */\\n    function beneficiary() public view returns (address) {\\n        return _beneficiary;\\n    }\\n\\n    /**\\n     * @return the backup beneficiary of the ether.\\n     */\\n    function backupBeneficiary() public view returns (address) {\\n        return _backupBeneficiary;\\n    }\\n\\n    /**\\n     * @return the period after the duration in completed before the backup beneficiary can withdraw.\\n     */\\n    function backupReleaseGracePeriod() public view returns (uint256) {\\n        return _backupReleaseGracePeriod;\\n    }\\n\\n    /**\\n     * @return the cliff time of the eth vesting.\\n     */\\n    function cliff() public view returns (uint256) {\\n        return _cliff;\\n    }\\n\\n    /**\\n     * @return the start time of the eth vesting.\\n     */\\n    function start() public view returns (uint256) {\\n        return _start;\\n    }\\n\\n    /**\\n     * @return the duration of the eth vesting.\\n     */\\n    function duration() public view returns (uint256) {\\n        return _duration;\\n    }\\n\\n    /**\\n     * @return the amount of the token released.\\n     */\\n    function released() public view returns (uint256) {\\n        return _released;\\n    }\\n\\n    /**\\n     * @notice Transfers vested tokens to beneficiary.\\n     */\\n    function release() public {\\n        uint256 unreleased = _releasableAmount();\\n\\n        require(unreleased > 0, \\\"EthVesting: no eth is due\\\");\\n\\n        _released = _released.add(unreleased);\\n\\n        _beneficiary.transfer(unreleased);\\n\\n        emit EthReleased(unreleased);\\n    }\\n\\n    /**\\n     * @dev Calculates the amount that has already vested but hasn't been released yet.\\n     */\\n    function _releasableAmount() private view returns (uint256) {\\n        return _vestedAmount().sub(_released);\\n    }\\n\\n    /**\\n     * @dev Calculates the amount that has already vested.\\n     */\\n    function _vestedAmount() private view returns (uint256) {\\n        uint256 currentBalance = address(this).balance;\\n        uint256 totalBalance = currentBalance.add(_released);\\n\\n        if (block.timestamp < _cliff) {\\n            return 0;\\n        } else if (block.timestamp >= _start.add(_duration)) {\\n            return totalBalance;\\n        } else {\\n            return totalBalance.mul(block.timestamp.sub(_start)).div(_duration);\\n        }\\n    }\\n\\n    /**\\n     * @dev After the vesting period is complete, allows for withdrawal by backup beneficiary if funds are unclaimed after the post-duration grace period\\n     */\\n    function backupRelease() public {\\n        require(block.timestamp >= _start.add(_duration).add(_backupReleaseGracePeriod));\\n        _backupBeneficiary.transfer(address(this).balance);\\n\\n        emit EthReleasedBackup(address(this).balance);\\n    }\\n\\n    // Allow Recieve Ether\\n    receive () external payable virtual {\\n        emit PaymentReceived(msg.sender, msg.value);\\n    }\\n}\"\r\n    },\r\n    \"contracts/GeyserEscrow.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./EnokiGeyser.sol\\\";\\n\\ncontract GeyserEscrow is Ownable{\\n    EnokiGeyser public geyser;\\n\\n    constructor(EnokiGeyser geyser_) public {\\n        geyser = geyser_;\\n    }\\n\\n    function lockTokens(\\n        uint256 amount,\\n        uint256 durationSec\\n    ) external onlyOwner {\\n        IERC20 distributionToken = geyser.getDistributionToken();\\n        distributionToken.approve(address(geyser), amount);\\n\\n        geyser.lockTokens(amount, durationSec);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMission.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ninterface IMission  {\\n    function sendSpores(address recipient, uint256 amount) external;\\n    function approvePool(address pool) external;\\n    function revokePool(address pool) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IMushroomFactory.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\ninterface IMushroomFactory  {\\n    function costPerMushroom() external returns (uint256);\\n    function growMushrooms(address recipient, uint256 numMushrooms) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IMushroomMetadata.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../MushroomLib.sol\\\";\\n\\nabstract contract IMushroomMetadata {\\n    using MushroomLib for MushroomLib.MushroomData;\\n    using MushroomLib for MushroomLib.MushroomType;\\n\\n    function hasMetadataResolver(address nftContract) external virtual view returns (bool);\\n\\n    function getMushroomData(\\n        address nftContract,\\n        uint256 nftIndex,\\n        bytes calldata data\\n    ) external virtual view returns (MushroomLib.MushroomData memory);\\n\\n    function setMushroomLifespan(\\n        address nftContract,\\n        uint256 nftIndex,\\n        uint256 lifespan,\\n        bytes calldata data\\n    ) external virtual;\\n\\n    function setResolver(address nftContract, address resolver) public virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/metadata/resolvers/MushroomResolver.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"../../MushroomNFT.sol\\\";\\nimport \\\"../../MushroomLib.sol\\\";\\nimport \\\"./MetadataResolver.sol\\\";\\n\\n\\n/*\\n    Reads mushroom NFT metadata directly from the Mushroom NFT contract\\n*/ \\ncontract MushroomResolver is Initializable, OwnableUpgradeSafe, MetadataResolver {\\n    using MushroomLib for MushroomLib.MushroomData;\\n    using MushroomLib for MushroomLib.MushroomType;\\n\\n    MushroomNFT public mushroomNft;\\n\\n    function initialize(address mushroomNft_) public initializer {\\n        __Ownable_init();\\n        mushroomNft = MushroomNFT(mushroomNft_);\\n    }\\n\\n    function getMushroomData(uint256 index, bytes calldata data) external view override returns (MushroomLib.MushroomData memory) {\\n        MushroomLib.MushroomData memory mData = mushroomNft.getMushroomData(index);\\n        return mData;\\n    }\\n    function setMushroomLifespan(uint256 index, uint256 lifespan, bytes calldata data) external override {\\n        mushroomNft.setMushroomLifespan(index, lifespan);\\n    }\\n}\"\r\n    },\r\n    \"contracts/Mission.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/*\\n    A pool of spores that can be takens by Spore pools according to their spore rate\\n*/\\ncontract Mission is Initializable, OwnableUpgradeSafe {\\n\\n    IERC20 public sporeToken;\\n    mapping (address => bool) public approved;\\n\\n    event SporesHarvested(address pool, uint256 amount);\\n\\n    modifier onlyApprovedPool() {\\n        require(approved[msg.sender], \\\"Mission: Only approved pools\\\");\\n        _;\\n    }\\n    function initialize(IERC20 sporeToken_) public initializer {\\n        __Ownable_init();\\n        sporeToken = sporeToken_;\\n    }\\n\\n    function sendSpores(address recipient, uint256 amount) public onlyApprovedPool {\\n        sporeToken.transfer(recipient, amount);\\n        emit SporesHarvested(msg.sender, amount);\\n    }\\n\\n    function approvePool(address pool) public onlyOwner {\\n        approved[pool] = true;\\n    }\\n\\n    function revokePool(address pool) public onlyOwner {\\n        approved[pool] = false;\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../utils/EnumerableSet.sol\\\";\\nimport \\\"../utils/Address.sol\\\";\\nimport \\\"../GSN/Context.sol\\\";\\nimport \\\"../Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, _msgSender()));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n */\\nabstract contract AccessControlUpgradeSafe is Initializable, ContextUpgradeSafe {\\n    function __AccessControl_init() internal initializer {\\n        __Context_init_unchained();\\n        __AccessControl_init_unchained();\\n    }\\n\\n    function __AccessControl_init_unchained() internal initializer {\\n\\n\\n    }\\n\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using Address for address;\\n\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping (bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view returns (bool) {\\n        return _roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n        return _roles[role].members.length();\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\\n        return _roles[role].members.at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to grant\\\");\\n\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to revoke\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (_roles[role].members.add(account)) {\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (_roles[role].members.remove(account)) {\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\\n * (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint256(_at(set._inner, index)));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MushroomFactory.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./MushroomNFT.sol\\\";\\nimport \\\"./MushroomLib.sol\\\";\\nimport \\\"./metadata/MushroomMetadata.sol\\\";\\n\\ncontract MushroomFactory is Initializable, OwnableUpgradeSafe {\\n    using MushroomLib for MushroomLib.MushroomData;\\n    using MushroomLib for MushroomLib.MushroomType;\\n    using SafeMath for uint256;\\n\\n    IERC20 public sporeToken;\\n    MushroomNFT public mushroomNft;\\n    MushroomMetadata public mushroomMetadata;\\n\\n    uint256 public costPerMushroom;\\n    uint256 public mySpecies;\\n\\n    function initialize(IERC20 sporeToken_, MushroomNFT mushroomNft_, uint256 costPerMushroom_) public initializer {\\n        __Ownable_init();\\n        sporeToken=sporeToken_;\\n        mushroomNft=mushroomNft_;\\n        costPerMushroom=costPerMushroom_;\\n    }\\n\\n    function _generateMushroomLifespan(uint256 minLifespan, uint256 maxLifespan) internal returns (uint256) {\\n        uint256 range = maxLifespan.sub(minLifespan);\\n        uint256 fromMin = uint256(keccak256(abi.encodePacked(block.timestamp))) % range;\\n        return minLifespan.add(fromMin);\\n    }\\n\\n    // Each mushroom costs 1/10th of the spore rate in spores.\\n    function growMushrooms(address recipient, uint256 numMushrooms) public onlyOwner {\\n        MushroomLib.MushroomType memory species = mushroomNft.getSpecies(mySpecies);\\n        for (uint256 i = 0; i < numMushrooms; i++) {\\n            uint256 nextId = mushroomNft.totalSupply().add(1);\\n            mushroomNft.mint(recipient, nextId, mySpecies, _generateMushroomLifespan(species.minLifespan, species.maxLifespan));\\n        }\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PaymentSplitter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n/**\\n * @title PaymentSplitter\\n * @dev This contract allows to split Ether payments among a group of accounts. The sender does not need to be aware\\n * that the Ether will be split in this way, since it is handled transparently by the contract.\\n *\\n * The split can be in equal parts or in any other arbitrary proportion. The way this is specified is by assigning each\\n * account to a number of shares. Of all the Ether that this contract receives, each account will then be able to claim\\n * an amount proportional to the percentage of total shares they were assigned.\\n *\\n * `PaymentSplitter` follows a _pull payment_ model. This means that payments are not automatically forwarded to the\\n * accounts but kept in this contract, and the actual transfer is triggered as a separate step by calling the {release}\\n * function.\\n */\\ncontract PaymentSplitter is Context {\\n    using SafeMath for uint256;\\n\\n    event PayeeAdded(address account, uint256 shares);\\n    event PaymentReleased(address to, uint256 amount);\\n    event PaymentReceived(address from, uint256 amount);\\n\\n    uint256 private _totalShares;\\n    uint256 private _totalReleased;\\n\\n    mapping(address => uint256) private _shares;\\n    mapping(address => uint256) private _released;\\n    address[] private _payees;\\n\\n    /**\\n     * @dev Creates an instance of `PaymentSplitter` where each account in `payees` is assigned the number of shares at\\n     * the matching position in the `shares` array.\\n     *\\n     * All addresses in `payees` must be non-zero. Both arrays must have the same non-zero length, and there must be no\\n     * duplicates in `payees`.\\n     */\\n    constructor (address[] memory payees, uint256[] memory shares) public payable {\\n        // solhint-disable-next-line max-line-length\\n        require(payees.length == shares.length, \\\"PaymentSplitter: payees and shares length mismatch\\\");\\n        require(payees.length > 0, \\\"PaymentSplitter: no payees\\\");\\n\\n        for (uint256 i = 0; i < payees.length; i++) {\\n            _addPayee(payees[i], shares[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev The Ether received will be logged with {PaymentReceived} events. Note that these events are not fully\\n     * reliable: it's possible for a contract to receive Ether without triggering this function. This only affects the\\n     * reliability of the events, and not the actual splitting of Ether.\\n     *\\n     * To learn more about this see the Solidity documentation for\\n     * https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function[fallback\\n     * functions].\\n     */\\n    receive () external payable virtual {\\n        emit PaymentReceived(_msgSender(), msg.value);\\n    }\\n\\n    /**\\n     * @dev Getter for the total shares held by payees.\\n     */\\n    function totalShares() public view returns (uint256) {\\n        return _totalShares;\\n    }\\n\\n    /**\\n     * @dev Getter for the total amount of Ether already released.\\n     */\\n    function totalReleased() public view returns (uint256) {\\n        return _totalReleased;\\n    }\\n\\n    /**\\n     * @dev Getter for the amount of shares held by an account.\\n     */\\n    function shares(address account) public view returns (uint256) {\\n        return _shares[account];\\n    }\\n\\n    /**\\n     * @dev Getter for the amount of Ether already released to a payee.\\n     */\\n    function released(address account) public view returns (uint256) {\\n        return _released[account];\\n    }\\n\\n    /**\\n     * @dev Getter for the address of the payee number `index`.\\n     */\\n    function payee(uint256 index) public view returns (address) {\\n        return _payees[index];\\n    }\\n\\n    /**\\n     * @dev Triggers a transfer to `account` of the amount of Ether they are owed, according to their percentage of the\\n     * total shares and their previous withdrawals.\\n     */\\n    function release(address payable account) public virtual {\\n        require(_shares[account] > 0, \\\"PaymentSplitter: account has no shares\\\");\\n\\n        uint256 totalReceived = address(this).balance.add(_totalReleased);\\n        uint256 payment = totalReceived.mul(_shares[account]).div(_totalShares).sub(_released[account]);\\n\\n        require(payment != 0, \\\"PaymentSplitter: account is not due payment\\\");\\n\\n        _released[account] = _released[account].add(payment);\\n        _totalReleased = _totalReleased.add(payment);\\n\\n        account.transfer(payment);\\n        emit PaymentReleased(account, payment);\\n    }\\n\\n    /**\\n     * @dev Add a new payee to the contract.\\n     * @param account The address of the payee to add.\\n     * @param shares_ The number of shares owned by the payee.\\n     */\\n    function _addPayee(address account, uint256 shares_) private {\\n        require(account != address(0), \\\"PaymentSplitter: account is the zero address\\\");\\n        require(shares_ > 0, \\\"PaymentSplitter: shares are 0\\\");\\n        require(_shares[account] == 0, \\\"PaymentSplitter: account already has shares\\\");\\n\\n        _payees.push(account);\\n        _shares[account] = shares_;\\n        _totalShares = _totalShares.add(shares_);\\n        emit PayeeAdded(account, shares_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SporePool.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\n/* \\n    Releases spores at the given rate until exhausted\\n    is doubled or halved every 3,240 blocks (7 days at 20s a block) based on staked $ENOKI\\n*/\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./Defensible.sol\\\";\\nimport \\\"./interfaces/IMushroomFactory.sol\\\";\\nimport \\\"./interfaces/IMission.sol\\\";\\nimport \\\"./SporeToken.sol\\\";\\nimport \\\"./ApprovedContractList.sol\\\";\\n\\ncontract SporePool is Ownable, ReentrancyGuard, Pausable, Defensible {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    SporeToken public rewardsToken;\\n    IERC20 public stakingToken;\\n    uint256 public periodFinish = 0;\\n    uint256 public rewardRate = 0;\\n    uint256 public rewardsDuration = 7 days;\\n    uint256 public lastUpdateTime;\\n    uint256 public rewardPerTokenStored;\\n\\n    uint256 public constant MAX_PERCENTAGE = 100;\\n    uint256 public devRewardPercentage;\\n    address public devRewardAddress;\\n\\n    mapping(address => uint256) public userRewardPerTokenPaid;\\n    mapping(address => uint256) public rewards;\\n\\n    uint256 private _totalSupply;\\n    mapping(address => uint256) private _balances;\\n\\n    IMushroomFactory public mushroomFactory;\\n    IMission public mission;\\n    ApprovedContractList public approvedContractList;\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(\\n        address _owner,\\n        address _rewardsToken,\\n        address _stakingToken,\\n        address _mushroomFactory,\\n        address _mission,\\n        address _approvedContractList,\\n        uint256 _devRewardPercentage,\\n        address _devRewardAddress\\n    ) public {\\n        rewardsToken = SporeToken(_rewardsToken);\\n        stakingToken = IERC20(_stakingToken);\\n        mushroomFactory = IMushroomFactory(_mushroomFactory);\\n        mission = IMission(_mission);\\n        approvedContractList = ApprovedContractList(_approvedContractList);\\n\\n        devRewardPercentage = _devRewardPercentage;\\n        devRewardAddress = _devRewardAddress;\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function totalSupply() external view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) external view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function lastTimeRewardApplicable() public view returns (uint256) {\\n        return Math.min(block.timestamp, periodFinish);\\n    }\\n\\n    function rewardPerToken() public view returns (uint256) {\\n        if (_totalSupply == 0) {\\n            return rewardPerTokenStored;\\n        }\\n        return rewardPerTokenStored.add(lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply));\\n    }\\n\\n    function earned(address account) public view returns (uint256) {\\n        return _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);\\n    }\\n\\n    function getRewardForDuration() external view returns (uint256) {\\n        return rewardRate.mul(rewardsDuration);\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function stake(uint256 amount) external nonReentrant defend(approvedContractList) whenNotPaused updateReward(msg.sender) {\\n        require(amount > 0, \\\"Cannot stake 0\\\");\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\\n        emit Staked(msg.sender, amount);\\n    }\\n\\n    function withdraw(uint256 amount) public nonReentrant updateReward(msg.sender) {\\n        require(amount > 0, \\\"Cannot withdraw 0\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\\n        stakingToken.safeTransfer(msg.sender, amount);\\n        emit Withdrawn(msg.sender, amount);\\n    }\\n\\n    function harvest(uint256 mushroomsToGrow) public nonReentrant updateReward(msg.sender) {\\n        uint256 reward = rewards[msg.sender];\\n\\n        if (reward > 0) {\\n            uint256 remainingReward = reward;\\n            rewards[msg.sender] = 0;\\n\\n            // Burn some rewards for mushrooms if desired\\n            if (mushroomsToGrow > 0) {\\n                uint256 totalCost = mushroomFactory.costPerMushroom().mul(mushroomsToGrow);\\n                require(reward >= totalCost, \\\"Not enough rewards to grow the number of mushrooms specified\\\");\\n\\n                uint256 toDev = totalCost.mul(devRewardPercentage).div(MAX_PERCENTAGE);\\n                rewardsToken.burn(totalCost.sub(toDev));\\n\\n                if (toDev > 0) {\\n                    mission.sendSpores(devRewardAddress, toDev);\\n                }\\n\\n                remainingReward = reward.sub(totalCost);\\n                mushroomFactory.growMushrooms(msg.sender, mushroomsToGrow);\\n            }\\n\\n            if (remainingReward > 0) {\\n                // TODO: Add safe ERC20 features to spore token\\n                // rewardsToken.safeTransfer(msg.sender, remainingReward);\\n\\n                mission.sendSpores(msg.sender, remainingReward);\\n                emit RewardPaid(msg.sender, remainingReward);\\n            }\\n        }\\n    }\\n\\n    function exit() external {\\n        withdraw(_balances[msg.sender]);\\n        harvest(0);\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function notifyRewardAmount(uint256 reward) external onlyOwner updateReward(address(0)) {\\n        if (block.timestamp >= periodFinish) {\\n            rewardRate = reward.div(rewardsDuration);\\n        } else {\\n            uint256 remaining = periodFinish.sub(block.timestamp);\\n            uint256 leftover = remaining.mul(rewardRate);\\n            rewardRate = reward.add(leftover).div(rewardsDuration);\\n        }\\n\\n        // Ensure the provided reward amount is not more than the balance in the contract.\\n        // This keeps the reward rate in the right range, preventing overflows due to\\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\\n        uint256 balance = rewardsToken.balanceOf(address(this));\\n        require(rewardRate <= balance.div(rewardsDuration), \\\"Provided reward too high\\\");\\n\\n        lastUpdateTime = block.timestamp;\\n        periodFinish = block.timestamp.add(rewardsDuration);\\n        emit RewardAdded(reward);\\n    }\\n\\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\\n        // Cannot recover the staking token or the rewards token\\n        require(tokenAddress != address(stakingToken) && tokenAddress != address(rewardsToken), \\\"Cannot withdraw the staking or rewards tokens\\\");\\n\\n        //TODO: Add safeTransfer\\n        IERC20(tokenAddress).transfer(owner(), tokenAmount);\\n        emit Recovered(tokenAddress, tokenAmount);\\n    }\\n\\n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\\n        require(block.timestamp > periodFinish, \\\"Previous rewards period must be complete before changing the duration for the new period\\\");\\n        rewardsDuration = _rewardsDuration;\\n        emit RewardsDurationUpdated(rewardsDuration);\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier updateReward(address account) {\\n        rewardPerTokenStored = rewardPerToken();\\n        lastUpdateTime = lastTimeRewardApplicable();\\n        if (account != address(0)) {\\n            rewards[account] = earned(account);\\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\\n        }\\n        _;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event RewardAdded(uint256 reward);\\n    event Staked(address indexed user, uint256 amount);\\n    event Withdrawn(address indexed user, uint256 amount);\\n    event RewardPaid(address indexed user, uint256 reward);\\n    event RewardsDurationUpdated(uint256 newDuration);\\n    event Recovered(address token, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\ncontract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\ncontract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor () internal {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!_paused, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(_paused, \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SporeToken.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract SporeToken is ERC20(\\\"SporeFinance\\\", \\\"SPORE\\\"), Ownable {\\n    using SafeMath for uint256;\\n\\n    /* ========== STATE VARIABLES ========== */\\n    mapping(address => bool) public minters;\\n    address public initialLiquidityManager;\\n\\n    bool internal _transfersEnabled;\\n    mapping(address => bool) internal _canTransferInitialLiquidity;\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(address initialLiquidityManager_) public {\\n        _transfersEnabled = false;\\n        minters[msg.sender] = true;\\n        initialLiquidityManager = initialLiquidityManager_;\\n        _canTransferInitialLiquidity[msg.sender] = true;\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /// @notice Transfer is enabled as normal except during an initial phase\\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\\n        require(_transfersEnabled || _canTransferInitialLiquidity[msg.sender], \\\"SporeToken: transfers not enabled\\\");\\n\\n        return super.transfer(recipient, amount);\\n    }\\n\\n    /// @notice TransferFrom is enabled as normal except during an initial phase\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        require(_transfersEnabled || _canTransferInitialLiquidity[msg.sender], \\\"SporeToken: transfers not enabled\\\");\\n\\n        return super.transferFrom(sender, recipient, amount);\\n    }\\n\\n    /// @notice Any account is entitled to burn their own tokens\\n    function burn(uint256 amount) public {\\n        require(amount > 0);\\n        require(balanceOf(msg.sender) >= amount);\\n        _burn(msg.sender, amount);\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function mint(address to, uint256 amount) public onlyMinter {\\n        _mint(to, amount);\\n    }\\n\\n    function addInitialLiquidityTransferRights(address account) public onlyInitialLiquidityManager {\\n        require(!_transfersEnabled, \\\"SporeToken: cannot add initial liquidity transfer rights after global transfers enabled\\\");\\n        _canTransferInitialLiquidity[account] = true;\\n    }\\n\\n    /// @notice One time acion to enable global transfers after the initial liquidity is supplied.\\n    function enableTransfers() public onlyInitialLiquidityManager {\\n        _transfersEnabled = true;\\n    }\\n\\n    function addMinter(address account) public onlyOwner {\\n        minters[account] = true;\\n    }\\n\\n    function removeMinter(address account) public onlyOwner {\\n        minters[account] = false;\\n    }\\n\\n    modifier onlyMinter() {\\n        require(minters[msg.sender], \\\"Restricted to minters.\\\");\\n        _;\\n    }\\n\\n    modifier onlyInitialLiquidityManager() {\\n        require(initialLiquidityManager == msg.sender, \\\"Restricted to initial liquidity manager.\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"contracts/SporePresale.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"./SporeToken.sol\\\";\\n\\ncontract SporePresale is Ownable {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    mapping(address => bool) public whitelist;\\n    mapping(address => uint256) public ethSupply;\\n    uint256 public whitelistCount;\\n    address payable devAddress;\\n    uint256 public sporePrice = 25;\\n    uint256 public buyLimit = 3 * 1e18;\\n    bool public presaleStart = false;\\n    bool public onlyWhitelist = true;\\n    uint256 public presaleLastSupply = 15000 * 1e18;\\n\\n    SporeToken public spore;\\n\\n    event BuySporeSuccess(address account, uint256 ethAmount, uint256 sporeAmount);\\n\\n    constructor(address payable devAddress_, SporeToken sporeToken_) public {\\n        devAddress = devAddress_;\\n        spore = sporeToken_;\\n    }\\n\\n    function addToWhitelist(address[] memory accounts) public onlyOwner {\\n        for (uint256 i = 0; i < accounts.length; i++) {\\n            address account = accounts[i];\\n\\n            require(whitelist[account] == false, \\\"This account is already in whitelist.\\\");\\n            whitelist[account] = true;\\n            whitelistCount = whitelistCount + 1;\\n        }\\n    }\\n\\n    function removeFromWhitelist(address[] memory accounts) public onlyOwner {\\n        for (uint256 i = 0; i < accounts.length; i++) {\\n            address account = accounts[i];\\n\\n            require(whitelist[account], \\\"This account is not in whitelist.\\\");\\n            whitelist[account] = false;\\n            whitelistCount = whitelistCount - 1;\\n        }\\n    }\\n\\n    function getDevAddress() public view returns (address) {\\n        return address(devAddress);\\n    }\\n    function setDevAddress(address payable account) public onlyOwner {\\n        devAddress = account;\\n    }\\n\\n    function startPresale() public onlyOwner {\\n        presaleStart = true;\\n    }\\n\\n    function stopPresale() public onlyOwner {\\n        presaleStart = false;\\n    }\\n\\n    function setSporePrice(uint256 newPrice) public onlyOwner {\\n        sporePrice = newPrice;\\n    }\\n\\n    function setBuyLimit(uint256 newLimit) public onlyOwner {\\n        buyLimit = newLimit;\\n    }\\n\\n    function changeToNotOnlyWhitelist() public onlyOwner {\\n        onlyWhitelist = false;\\n    }\\n\\n    modifier needHaveLastSupply() {\\n        require(presaleLastSupply >= 0, \\\"Oh you are so late.\\\");\\n        _;\\n    }\\n\\n    modifier presaleHasStarted() {\\n        require(presaleStart, \\\"Presale has not been started.\\\");\\n        _;\\n    }\\n\\n    receive() external payable presaleHasStarted needHaveLastSupply {\\n        if (onlyWhitelist) {\\n            require(whitelist[msg.sender], \\\"This time is only for people who are in whitelist.\\\");\\n        }\\n        uint256 ethTotalAmount = ethSupply[msg.sender].add(msg.value);\\n        require(ethTotalAmount <= buyLimit, \\\"Everyone should buy less than 3 eth.\\\");\\n        uint256 sporeAmount = msg.value.mul(sporePrice);\\n        require(sporeAmount <= presaleLastSupply, \\\"insufficient presale supply\\\");\\n        presaleLastSupply = presaleLastSupply.sub(sporeAmount);\\n        spore.mint(msg.sender, sporeAmount);\\n        ethSupply[msg.sender] = ethTotalAmount;\\n        devAddress.transfer(msg.value);\\n        emit BuySporeSuccess(msg.sender, msg.value, sporeAmount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TokenVesting.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n/**\\n * @title TokenVesting\\n * @dev A token holder contract that can release its token balance gradually like a\\n * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the\\n * owner.\\n */\\ncontract TokenVesting is Ownable {\\n    // The vesting schedule is time-based (i.e. using block timestamps as opposed to e.g. block numbers), and is\\n    // therefore sensitive to timestamp manipulation (which is something miners can do, to a certain degree). Therefore,\\n    // it is recommended to avoid using short time durations (less than a minute). Typical vesting schemes, with a\\n    // cliff period of a year and a duration of four years, are safe to use.\\n    // solhint-disable not-rely-on-time\\n\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    event TokensReleased(address token, uint256 amount);\\n    event TokenVestingRevoked(address token);\\n\\n    // beneficiary of tokens after they are released\\n    address private _beneficiary;\\n\\n    // Durations and timestamps are expressed in UNIX time, the same units as block.timestamp.\\n    uint256 private _cliff;\\n    uint256 private _start;\\n    uint256 private _duration;\\n\\n    bool private _revocable;\\n\\n    mapping (address => uint256) private _released;\\n    mapping (address => bool) private _revoked;\\n\\n    /**\\n     * @dev Creates a vesting contract that vests its balance of any ERC20 token to the\\n     * beneficiary, gradually in a linear fashion until start + duration. By then all\\n     * of the balance will have vested.\\n     * @param beneficiary address of the beneficiary to whom vested tokens are transferred\\n     * @param cliffDuration duration in seconds of the cliff in which tokens will begin to vest\\n     * @param start the time (as Unix time) at which point vesting starts\\n     * @param duration duration in seconds of the period in which the tokens will vest\\n     * @param revocable whether the vesting is revocable or not\\n     */\\n    constructor (address beneficiary, uint256 start, uint256 cliffDuration, uint256 duration, bool revocable) public {\\n        require(beneficiary != address(0), \\\"TokenVesting: beneficiary is the zero address\\\");\\n        // solhint-disable-next-line max-line-length\\n        require(cliffDuration <= duration, \\\"TokenVesting: cliff is longer than duration\\\");\\n        require(duration > 0, \\\"TokenVesting: duration is 0\\\");\\n        // solhint-disable-next-line max-line-length\\n        require(start.add(duration) > block.timestamp, \\\"TokenVesting: final time is before current time\\\");\\n\\n        _beneficiary = beneficiary;\\n        _revocable = revocable;\\n        _duration = duration;\\n        _cliff = start.add(cliffDuration);\\n        _start = start;\\n    }\\n\\n    /**\\n     * @return the beneficiary of the tokens.\\n     */\\n    function beneficiary() public view returns (address) {\\n        return _beneficiary;\\n    }\\n\\n    /**\\n     * @return the cliff time of the token vesting.\\n     */\\n    function cliff() public view returns (uint256) {\\n        return _cliff;\\n    }\\n\\n    /**\\n     * @return the start time of the token vesting.\\n     */\\n    function start() public view returns (uint256) {\\n        return _start;\\n    }\\n\\n    /**\\n     * @return the duration of the token vesting.\\n     */\\n    function duration() public view returns (uint256) {\\n        return _duration;\\n    }\\n\\n    /**\\n     * @return true if the vesting is revocable.\\n     */\\n    function revocable() public view returns (bool) {\\n        return _revocable;\\n    }\\n\\n    /**\\n     * @return the amount of the token released.\\n     */\\n    function released(address token) public view returns (uint256) {\\n        return _released[token];\\n    }\\n\\n    /**\\n     * @return true if the token is revoked.\\n     */\\n    function revoked(address token) public view returns (bool) {\\n        return _revoked[token];\\n    }\\n\\n    /**\\n     * @notice Transfers vested tokens to beneficiary.\\n     * @param token ERC20 token which is being vested\\n     */\\n    function release(IERC20 token) public {\\n        uint256 unreleased = _releasableAmount(token);\\n\\n        require(unreleased > 0, \\\"TokenVesting: no tokens are due\\\");\\n\\n        _released[address(token)] = _released[address(token)].add(unreleased);\\n\\n        token.safeTransfer(_beneficiary, unreleased);\\n\\n        emit TokensReleased(address(token), unreleased);\\n    }\\n\\n    /**\\n     * @notice Allows the owner to revoke the vesting. Tokens already vested\\n     * remain in the contract, the rest are returned to the owner.\\n     * @param token ERC20 token which is being vested\\n     */\\n    function revoke(IERC20 token) public onlyOwner {\\n        require(_revocable, \\\"TokenVesting: cannot revoke\\\");\\n        require(!_revoked[address(token)], \\\"TokenVesting: token already revoked\\\");\\n\\n        uint256 balance = token.balanceOf(address(this));\\n\\n        uint256 unreleased = _releasableAmount(token);\\n        uint256 refund = balance.sub(unreleased);\\n\\n        _revoked[address(token)] = true;\\n\\n        token.safeTransfer(owner(), refund);\\n\\n        emit TokenVestingRevoked(address(token));\\n    }\\n\\n    /**\\n     * @dev Calculates the amount that has already vested but hasn't been released yet.\\n     * @param token ERC20 token which is being vested\\n     */\\n    function _releasableAmount(IERC20 token) private view returns (uint256) {\\n        return _vestedAmount(token).sub(_released[address(token)]);\\n    }\\n\\n    /**\\n     * @dev Calculates the amount that has already vested.\\n     * @param token ERC20 token which is being vested\\n     */\\n    function _vestedAmount(IERC20 token) private view returns (uint256) {\\n        uint256 currentBalance = token.balanceOf(address(this));\\n        uint256 totalBalance = currentBalance.add(_released[address(token)]);\\n\\n        if (block.timestamp < _cliff) {\\n            return 0;\\n        } else if (block.timestamp >= _start.add(_duration) || _revoked[address(token)]) {\\n            return totalBalance;\\n        } else {\\n            return totalBalance.mul(block.timestamp.sub(_start)).div(_duration);\\n        }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialLiquidityManager_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addInitialLiquidityTransferRights\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTransfers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialLiquidityManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minters\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SporeToken", "CompilerVersion": "v0.6.11+commit.5ef660b1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000004f8fdc5d03b21ae85c5e451efe454d6e550ff761", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}