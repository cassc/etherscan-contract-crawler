{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IHoneycombs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IHoneycombs {\\n    /// @dev The minimal honeycomb data stored on-chain, the rest is generated.\\n    struct StoredHoneycomb {\\n        uint32 epoch; // Each honeycomb is revealed in an epoch\\n        uint24 day; // The days since token was created\\n        uint16 seed; // A unique identifier (this is the token ID since it is pre-reveal)\\n    }\\n\\n    struct Honeycomb {\\n        StoredHoneycomb stored; // We carry over the honeycomb from storage\\n        bool isRevealed; // Whether the honeycomb is revealed\\n        uint256 seed; // The instantiated seed for pseudo-randomisation (post-reveal)\\n        bytes svg; // final svg for the honeycomb\\n        Canvas canvas; // all data relevant to the canvas\\n        BaseHexagon baseHexagon; // all data relevant to the base hexagon\\n        Grid grid; // all data relevant to the grid\\n        Gradients gradients; // all data relevant to the gradients\\n    }\\n\\n    struct Honeycombs {\\n        mapping(uint256 => StoredHoneycomb) all; // All honeycombs\\n        uint32 maxSupply; // The maximum number of honeycombs that can be minted\\n        uint32 minted; // The number of honeycombs that have been minted\\n        uint32 burned; // The number of honeycombs that have been burned\\n        uint32 day0; // Marks the start of this journey\\n        mapping(uint256 => Epoch) epochs; // All epochs\\n        uint256 epoch; // The current epoch index\\n    }\\n\\n    struct Canvas {\\n        string color; // background color of canvas\\n        uint16 size; // size or length of canvas in user units (pixels)\\n        uint16 hexagonSize; // size or length of hexagon in user units (pixels)\\n        uint16 maxHexagonsPerLine; // max number of hexagons per line\\n    }\\n\\n    struct BaseHexagon {\\n        string path; // path of base hexagon\\n        string fillColor; // fill color of base hexagon\\n        uint8 strokeWidth; // stroke width size in user units (pixels)\\n        uint8 hexagonType; // type of base hexagon, i.e. flat or pointy\\n    }\\n\\n    struct Grid {\\n        bytes hexagonsSvg; // final svg for all hexagons\\n        bytes svg; // final svg for the grid\\n        uint16 gridX; // x coordinate of the grid\\n        uint16 gridY; // y coordinate of the grid\\n        uint16 rowDistance; // distance between rows in user units (pixels)\\n        uint16 columnDistance; // distance between columns in user units (pixels)\\n        uint16 rotation; // rotation of entire shape in degrees\\n        uint8 shape; // shape of the grid, i.e. triangle, diamond, hexagon, random\\n        uint8 totalGradients; // number of gradients required based on the grid size and shape\\n        uint8 rows; // number of rows in the grid\\n        uint8 longestRowCount; // largest row size in the grid for centering purposes\\n    }\\n\\n    struct Gradients {\\n        bytes svg; // final svg for the gradients\\n        uint16 duration; // duration of animation in seconds\\n        uint8 direction; // direction of animation, i.e. forward or backward\\n        uint8 chrome; // max number of colors in all the gradients, aka chrome\\n    }\\n\\n    struct Epoch {\\n        uint128 randomness; // The source of randomness for tokens from this epoch\\n        uint64 revealBlock; // The block at which this epoch was / is revealed\\n        bool committed; // Whether the epoch has been instantiated\\n        bool revealed; // Whether the epoch has been revealed\\n    }\\n\\n    event NewEpoch(uint256 indexed epoch, uint64 indexed revealBlock);\\n\\n    error NotAllowed();\\n    error MaxSupplyReached();\\n    error NotExactEth();\\n    error MaxMintPerAddressReached();\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/GridArt.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"../interfaces/IHoneycombs.sol\\\";\\nimport \\\"./Utilities.sol\\\";\\n\\n/**\\n@title  GridArt\\n@notice Generates the grid for a given Honeycomb.\\n*/\\nlibrary GridArt {\\n    enum HEXAGON_TYPE { FLAT, POINTY } // prettier-ignore\\n    enum SHAPE { TRIANGLE, DIAMOND, HEXAGON, RANDOM } // prettier-ignore\\n\\n    /// @dev The paths for a 72x72 px hexagon.\\n    function getHexagonPath(uint8 pathType) public pure returns (string memory path) {\\n        if (pathType == uint8(HEXAGON_TYPE.FLAT)) {\\n            return \\\"M22.2472 7.32309L4.82457 37.5C3.93141 39.047 3.93141 40.953 4.82457 42.5L22.2472 72.6769C23.1404 74.2239 24.791 75.1769 26.5774 75.1769H61.4226C63.209 75.1769 64.8596 74.2239 65.7528 72.6769L83.1754 42.5C84.0686 40.953 84.0686 39.047 83.1754 37.5L65.7528 7.32309C64.8596 5.77608 63.209 4.82309 61.4226 4.82309H26.5774C24.791 4.82309 23.1404 5.77608 22.2472 7.32309Z\\\"; // prettier-ignore\\n        } else if (pathType == uint8(HEXAGON_TYPE.POINTY)) {\\n            return \\\"M72.6769 22.2472L42.5 4.82457C40.953 3.93141 39.047 3.93141 37.5 4.82457L7.32309 22.2472C5.77608 23.1404 4.82309 24.791 4.82309 26.5774V61.4226C4.82309 63.209 5.77608 64.8596 7.32309 65.7528L37.5 83.1754C39.047 84.0686 40.953 84.0686 42.5 83.1754L72.6769 65.7528C74.2239 64.8596 75.1769 63.209 75.1769 61.4226V26.5774C75.1769 24.791 74.2239 23.1404 72.6769 22.2472Z\\\"; // prettier-ignore\\n        }\\n    }\\n\\n        /// @dev Get hexagon from given grid and hexagon properties.\\n    /// @param grid The grid metadata.\\n    /// @param xIndex The x index in the grid.\\n    /// @param yIndex The y index in the grid.\\n    /// @param gradientId The gradient id for the hexagon.\\n    function getUpdatedHexagonsSvg(\\n        IHoneycombs.Grid memory grid,\\n        uint16 xIndex,\\n        uint16 yIndex,\\n        uint16 gradientId\\n    ) public pure returns (bytes memory) {\\n        uint16 x = grid.gridX + xIndex * grid.columnDistance;\\n        uint16 y = grid.gridY + yIndex * grid.rowDistance;\\n\\n        // prettier-ignore\\n        return abi.encodePacked(grid.hexagonsSvg, abi.encodePacked(\\n            '<use href=\\\"#hexagon\\\" stroke=\\\"url(#gradient', Utilities.uint2str(gradientId), ')\\\" ',\\n                'x=\\\"', Utilities.uint2str(x), '\\\" y=\\\"', Utilities.uint2str(y), '\\\"',\\n            '/>'\\n        ));\\n    }\\n\\n    /// @dev Add positioning to the grid (for centering on canvas).\\n    /// @dev Note this function appends attributes to grid object, so returned object has original grid + positioning.\\n    /// @param honeycomb The honeycomb data used for rendering.\\n    /// @param grid The grid metadata.\\n    function addGridPositioning(\\n        IHoneycombs.Honeycomb memory honeycomb,\\n        IHoneycombs.Grid memory grid\\n    ) public pure returns (IHoneycombs.Grid memory) {\\n        // Compute grid properties.\\n        grid.rowDistance = ((3 * honeycomb.canvas.hexagonSize) / 4) + 7; // 7 is a relatively arbitrary buffer\\n        grid.columnDistance = honeycomb.canvas.hexagonSize / 2 - 1;\\n        uint16 gridHeight = honeycomb.canvas.hexagonSize + 7 + ((grid.rows - 1) * grid.rowDistance);\\n        uint16 gridWidth = grid.longestRowCount * (honeycomb.canvas.hexagonSize - 2);\\n\\n        /**\\n         * Swap variables if it is a flat top hexagon (this math assumes pointy top as default). Rotating a flat top\\n         * hexagon 90 degrees clockwise results in a pointy top hexagon. This effectively swaps the x and y axis.\\n         */\\n        if (honeycomb.baseHexagon.hexagonType == uint8(HEXAGON_TYPE.FLAT)) {\\n            (grid.rowDistance, grid.columnDistance) = Utilities.swap(grid.rowDistance, grid.columnDistance);\\n            (gridWidth, gridHeight) = Utilities.swap(gridWidth, gridHeight);\\n        }\\n\\n        // Compute grid positioning.\\n        grid.gridX = (honeycomb.canvas.size - gridWidth) / 2;\\n        grid.gridY = (honeycomb.canvas.size - gridHeight) / 2;\\n\\n        return grid;\\n    }\\n\\n    /// @dev Get the honeycomb grid for a random shape.\\n    /// @dev Note: can only be called for pointy tops (flat tops are not supported as they would be redundant).\\n    /// @param honeycomb The honeycomb data used for rendering.\\n    function getRandomGrid(IHoneycombs.Honeycomb memory honeycomb) public pure returns (IHoneycombs.Grid memory) {\\n        IHoneycombs.Grid memory grid;\\n\\n        // Get random rows from 1 to honeycomb.canvas.maxHexagonsPerline.\\n        grid.rows = uint8(Utilities.random(honeycomb.seed, \\\"rows\\\", honeycomb.canvas.maxHexagonsPerLine) + 1);\\n\\n        // Get random hexagons in each row from 1 to honeycomb.canvas.maxHexagonsPerLine - 1.\\n        uint8[] memory hexagonsInRow = new uint8[](grid.rows);\\n        for (uint8 i; i < grid.rows; ) {\\n            hexagonsInRow[i] =\\n                uint8(Utilities.random(\\n                    honeycomb.seed,\\n                    abi.encodePacked(\\\"hexagonsInRow\\\", Utilities.uint2str(i)),\\n                    honeycomb.canvas.maxHexagonsPerLine - 1\\n                ) + 1); // prettier-ignore\\n            grid.longestRowCount = Utilities.max(hexagonsInRow[i], grid.longestRowCount);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Determine positioning of entire grid, which is based on the longest row.\\n        grid = addGridPositioning(honeycomb, grid); // appends to grid object\\n\\n        int8 lastRowEvenOdd = -1; // Helps avoid overlapping hexagons: -1 = unset, 0 = even, 1 = odd\\n        // Create random grid. Only working with pointy tops for simplicity.\\n        for (uint8 i; i < grid.rows; ) {\\n            uint8 firstX = grid.longestRowCount - hexagonsInRow[i];\\n\\n            // Increment firstX if last row's evenness/oddness is same as this rows and update with current.\\n            if (lastRowEvenOdd == int8(firstX % 2)) ++firstX;\\n            lastRowEvenOdd = int8(firstX % 2);\\n\\n            // Assign indexes for each hexagon.\\n            for (uint8 j; j < hexagonsInRow[i]; ) {\\n                uint8 xIndex = firstX + (j * 2);\\n                grid.hexagonsSvg = getUpdatedHexagonsSvg(grid, xIndex, i, i + 1);\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        grid.totalGradients = grid.rows;\\n        return grid;\\n    }\\n\\n    /// @dev Get the honeycomb grid for a hexagon shape.\\n    /// @param honeycomb The honeycomb data used for rendering.\\n    function getHexagonGrid(IHoneycombs.Honeycomb memory honeycomb) public pure returns (IHoneycombs.Grid memory) {\\n        IHoneycombs.Grid memory grid;\\n\\n        // Get random rows from 3 to honeycomb.canvas.maxHexagonsPerLine, only odd.\\n        grid.rows = uint8(\\n            Utilities.random(honeycomb.seed, \\\"rows\\\", (honeycomb.canvas.maxHexagonsPerLine / 2) - 1) * 2 + 3\\n        );\\n\\n        // Determine positioning of entire grid, which is based on the longest row.\\n        grid.longestRowCount = grid.rows;\\n        grid = addGridPositioning(honeycomb, grid); // appends to grid object\\n\\n        // Create grid based on hexagon base type.\\n        if (honeycomb.baseHexagon.hexagonType == uint8(HEXAGON_TYPE.POINTY)) {\\n            grid.totalGradients = grid.rows;\\n\\n            for (uint8 i; i < grid.rows; ) {\\n                // Compute hexagons in row.\\n                uint8 hexagonsInRow = grid.rows - Utilities.absDiff(grid.rows / 2, i);\\n\\n                // Assign indexes for each hexagon.\\n                for (uint8 j; j < hexagonsInRow; ) {\\n                    uint8 xIndex = (grid.rows - hexagonsInRow) + (j * 2);\\n                    grid.hexagonsSvg = getUpdatedHexagonsSvg(grid, xIndex, i, i + 1);\\n                    unchecked {\\n                        ++j;\\n                    }\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        } else if (honeycomb.baseHexagon.hexagonType == uint8(HEXAGON_TYPE.FLAT)) {\\n            uint8 flatTopRows = grid.rows * 2 - 1;\\n            grid.totalGradients = flatTopRows;\\n            uint8 halfRows = grid.rows / 2;\\n\\n            for (uint8 i; i < flatTopRows; ) {\\n                // Determine hexagons in row.\\n                uint8 hexagonsInRow;\\n                if (i <= grid.rows / 2) {\\n                    // ascending, i.e. rows = 1 2 3 4 5 when rows = 5\\n                    hexagonsInRow = i + 1;\\n                } else if (i < flatTopRows - halfRows - 1) {\\n                    // alternate between rows / 2 + 1 and rows / 2 every other row\\n                    hexagonsInRow = (halfRows + i) % 2 == 0 ? halfRows + 1 : halfRows;\\n                } else {\\n                    // descending, i.e. rows = 5, 4, 3, 2, 1 when rows = 5\\n                    hexagonsInRow = flatTopRows - i;\\n                }\\n\\n                // Assign indexes for each hexagon.\\n                for (uint8 j; j < hexagonsInRow; ) {\\n                    uint8 xIndex = (grid.rows - hexagonsInRow) - halfRows + (j * 2);\\n                    grid.hexagonsSvg = getUpdatedHexagonsSvg(grid, xIndex, i, i + 1);\\n                    unchecked {\\n                        ++j;\\n                    }\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n\\n        return grid;\\n    }\\n\\n    /// @dev Get the honeycomb grid for a diamond shape.\\n    /// @param honeycomb The honeycomb data used for rendering.\\n    function getDiamondGrid(IHoneycombs.Honeycomb memory honeycomb) public pure returns (IHoneycombs.Grid memory) {\\n        IHoneycombs.Grid memory grid;\\n\\n        // Get random rows from 3 to honeycomb.canvas.maxHexagonsPerLine, only odd.\\n        grid.rows = uint8(\\n            Utilities.random(honeycomb.seed, \\\"rows\\\", (honeycomb.canvas.maxHexagonsPerLine / 2) - 1) * 2 + 3\\n        );\\n\\n        // Determine positioning of entire grid, which is based on the longest row.\\n        grid.longestRowCount = grid.rows / 2 + 1;\\n        grid = addGridPositioning(honeycomb, grid); // appends to grid object\\n\\n        // Create diamond grid. Both flat top and pointy top result in the same grid, so no need to check hexagon type.\\n        for (uint8 i; i < grid.rows; ) {\\n            // Determine hexagons in row. Pattern is ascending/descending sequence, i.e 1 2 3 2 1 when rows = 5.\\n            uint8 hexagonsInRow = i < grid.rows / 2 ? i + 1 : grid.rows - i;\\n            uint8 firstXInRow = i < grid.rows / 2 ? grid.rows / 2 - i : i - grid.rows / 2;\\n\\n            // Assign indexes for each hexagon.\\n            for (uint8 j; j < hexagonsInRow; ) {\\n                uint8 xIndex = firstXInRow + (j * 2);\\n                grid.hexagonsSvg = getUpdatedHexagonsSvg(grid, xIndex, i, i + 1);\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        grid.totalGradients = grid.rows;\\n        return grid;\\n    }\\n\\n    /// @dev Get the honeycomb grid for a triangle shape.\\n    /// @param honeycomb The honeycomb data used for rendering.\\n    function getTriangleGrid(IHoneycombs.Honeycomb memory honeycomb) public pure returns (IHoneycombs.Grid memory) {\\n        IHoneycombs.Grid memory grid;\\n\\n        // Get random rows from 2 to honeycomb.canvas.maxHexagonsPerLine.\\n        grid.rows = uint8(Utilities.random(honeycomb.seed, \\\"rows\\\", honeycomb.canvas.maxHexagonsPerLine - 1) + 2);\\n\\n        // Determine positioning of entire grid, which is based on the longest row.\\n        grid.longestRowCount = grid.rows;\\n        grid = addGridPositioning(honeycomb, grid); // appends to grid object\\n\\n        // Create grid based on hexagon base type.\\n        if (honeycomb.baseHexagon.hexagonType == uint8(HEXAGON_TYPE.POINTY)) {\\n            grid.totalGradients = grid.rows;\\n\\n            // Iterate through rows - will only be north/south facing (design).\\n            for (uint8 i; i < grid.rows; ) {\\n                // Assign indexes for each hexagon. Each row has i + 1 hexagons.\\n                for (uint8 j; j < i + 1; ) {\\n                    uint8 xIndex = grid.rows - 1 - i + (j * 2);\\n                    grid.hexagonsSvg = getUpdatedHexagonsSvg(grid, xIndex, i, i + 1);\\n                    unchecked {\\n                        ++j;\\n                    }\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        } else if (honeycomb.baseHexagon.hexagonType == uint8(HEXAGON_TYPE.FLAT)) {\\n            uint8 flatTopRows = grid.rows * 2 - 1;\\n            grid.totalGradients = flatTopRows;\\n\\n            // Iterate through rows - will only be west/east facing (design).\\n            for (uint8 i; i < flatTopRows; ) {\\n                // Determine hexagons in row. First half is ascending. Second half is descending.\\n                uint8 hexagonsInRow;\\n                if (i <= flatTopRows / 2) {\\n                    // ascending with peak, i.e. rows = 1 1 2 2 3 when rows = 5\\n                    hexagonsInRow = i / 2 + 1;\\n                } else {\\n                    // descending with peak, i.e. rows = 2 2 1 1 when rows = 5\\n                    hexagonsInRow = ((flatTopRows - i - 1) / 2) + 1;\\n                }\\n\\n                // Assign indexes for each hexagon. Each row has i + 1 hexagons.\\n                for (uint8 j; j < hexagonsInRow; ) {\\n                    uint8 xIndex = (i % 2) + (j * 2);\\n                    grid.hexagonsSvg = getUpdatedHexagonsSvg(grid, xIndex, i, i + 1);\\n                    unchecked {\\n                        ++j;\\n                    }\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n\\n        return grid;\\n    }\\n\\n    /// @dev Generate the overall honeycomb grid, including the final svg.\\n    /// @dev Using double coordinates: https://www.redblobgames.com/grids/hexagons/#coordinates-doubled\\n    /// @param honeycomb The honeycomb data used for rendering.\\n    /// @return (bytes, uint8, uint8) The svg, totalGradients, and rows.\\n    function generateGrid(IHoneycombs.Honeycomb memory honeycomb) public pure returns (bytes memory, uint8, uint8) {\\n        // Partial grid object used to store supportive variables\\n        IHoneycombs.Grid memory gridData;\\n\\n        // Get grid data based on shape.\\n        if (honeycomb.grid.shape == uint8(SHAPE.TRIANGLE)) {\\n            gridData = getTriangleGrid(honeycomb);\\n        } else if (honeycomb.grid.shape == uint8(SHAPE.DIAMOND)) {\\n            gridData = getDiamondGrid(honeycomb);\\n        } else if (honeycomb.grid.shape == uint8(SHAPE.HEXAGON)) {\\n            gridData = getHexagonGrid(honeycomb);\\n        } else if (honeycomb.grid.shape == uint8(SHAPE.RANDOM)) {\\n            gridData = getRandomGrid(honeycomb);\\n        }\\n\\n        // Generate grid svg.\\n        // prettier-ignore\\n        bytes memory svg = abi.encodePacked(\\n            '<g transform=\\\"scale(1) rotate(', \\n                    Utilities.uint2str(honeycomb.grid.rotation) ,',', \\n                    Utilities.uint2str(honeycomb.canvas.size / 2) ,',', \\n                    Utilities.uint2str(honeycomb.canvas.size / 2), ')\\\">',\\n                gridData.hexagonsSvg,\\n            '</g>'\\n        );\\n\\n        return (svg, gridData.totalGradients, gridData.rows);\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/Utilities.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nlibrary Utilities {\\n    /// @dev Zero-index based pseudorandom number based on one input and max bound\\n    function random(uint256 input, uint256 _max) internal pure returns (uint256) {\\n        return (uint256(keccak256(abi.encodePacked(input))) % _max);\\n    }\\n\\n    /// @dev Zero-index based salted pseudorandom number based on two inputs and max bound\\n    function random(uint256 input, bytes memory salt, uint256 _max) internal pure returns (uint256) {\\n        return (uint256(keccak256(abi.encodePacked(input, salt))) % _max);\\n    }\\n\\n    /// @dev Convert an integer to a string\\n    function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 j = _i;\\n        uint256 len;\\n        while (j != 0) {\\n            ++len;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint256 k = len;\\n        while (_i != 0) {\\n            k = k - 1;\\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\\n            bytes1 b1 = bytes1(temp);\\n            bstr[k] = b1;\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n\\n    /// @dev Get the larger number\\n    function max(uint8 one, uint8 two) internal pure returns (uint8) {\\n        return one > two ? one : two;\\n    }\\n\\n    /// @dev Get the absolute difference between two numbers\\n    function absDiff(uint8 one, uint8 two) internal pure returns (uint8) {\\n        return one > two ? one - two : two - one;\\n    }\\n\\n    /// @dev Swap two numbers\\n    function swap(uint16 one, uint16 two) internal pure returns (uint16, uint16) {\\n        return (two, one);\\n    }\\n\\n    /// @dev Get the days since another date (input is seconds)\\n    function day(uint256 from, uint256 to) internal pure returns (uint24) {\\n        return uint24((to - from) / 24 hours + 1);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"day\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"}],\"internalType\":\"struct IHoneycombs.StoredHoneycomb\",\"name\":\"stored\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"isRevealed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"color\",\"type\":\"string\"},{\"internalType\":\"uint16\",\"name\":\"size\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"hexagonSize\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxHexagonsPerLine\",\"type\":\"uint16\"}],\"internalType\":\"struct IHoneycombs.Canvas\",\"name\":\"canvas\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"path\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"fillColor\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"strokeWidth\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"hexagonType\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.BaseHexagon\",\"name\":\"baseHexagon\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"hexagonsSvg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"gridX\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"gridY\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rowDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"columnDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rotation\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"shape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"totalGradients\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rows\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"longestRowCount\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Grid\",\"name\":\"grid\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"duration\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"direction\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"chrome\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Gradients\",\"name\":\"gradients\",\"type\":\"tuple\"}],\"internalType\":\"struct IHoneycombs.Honeycomb\",\"name\":\"honeycomb\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"hexagonsSvg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"gridX\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"gridY\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rowDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"columnDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rotation\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"shape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"totalGradients\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rows\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"longestRowCount\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Grid\",\"name\":\"grid\",\"type\":\"tuple\"}],\"name\":\"addGridPositioning\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"hexagonsSvg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"gridX\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"gridY\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rowDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"columnDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rotation\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"shape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"totalGradients\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rows\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"longestRowCount\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Grid\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"day\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"}],\"internalType\":\"struct IHoneycombs.StoredHoneycomb\",\"name\":\"stored\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"isRevealed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"color\",\"type\":\"string\"},{\"internalType\":\"uint16\",\"name\":\"size\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"hexagonSize\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxHexagonsPerLine\",\"type\":\"uint16\"}],\"internalType\":\"struct IHoneycombs.Canvas\",\"name\":\"canvas\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"path\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"fillColor\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"strokeWidth\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"hexagonType\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.BaseHexagon\",\"name\":\"baseHexagon\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"hexagonsSvg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"gridX\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"gridY\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rowDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"columnDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rotation\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"shape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"totalGradients\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rows\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"longestRowCount\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Grid\",\"name\":\"grid\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"duration\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"direction\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"chrome\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Gradients\",\"name\":\"gradients\",\"type\":\"tuple\"}],\"internalType\":\"struct IHoneycombs.Honeycomb\",\"name\":\"honeycomb\",\"type\":\"tuple\"}],\"name\":\"generateGrid\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"day\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"}],\"internalType\":\"struct IHoneycombs.StoredHoneycomb\",\"name\":\"stored\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"isRevealed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"color\",\"type\":\"string\"},{\"internalType\":\"uint16\",\"name\":\"size\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"hexagonSize\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxHexagonsPerLine\",\"type\":\"uint16\"}],\"internalType\":\"struct IHoneycombs.Canvas\",\"name\":\"canvas\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"path\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"fillColor\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"strokeWidth\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"hexagonType\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.BaseHexagon\",\"name\":\"baseHexagon\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"hexagonsSvg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"gridX\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"gridY\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rowDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"columnDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rotation\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"shape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"totalGradients\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rows\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"longestRowCount\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Grid\",\"name\":\"grid\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"duration\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"direction\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"chrome\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Gradients\",\"name\":\"gradients\",\"type\":\"tuple\"}],\"internalType\":\"struct IHoneycombs.Honeycomb\",\"name\":\"honeycomb\",\"type\":\"tuple\"}],\"name\":\"getDiamondGrid\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"hexagonsSvg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"gridX\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"gridY\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rowDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"columnDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rotation\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"shape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"totalGradients\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rows\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"longestRowCount\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Grid\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"day\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"}],\"internalType\":\"struct IHoneycombs.StoredHoneycomb\",\"name\":\"stored\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"isRevealed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"color\",\"type\":\"string\"},{\"internalType\":\"uint16\",\"name\":\"size\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"hexagonSize\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxHexagonsPerLine\",\"type\":\"uint16\"}],\"internalType\":\"struct IHoneycombs.Canvas\",\"name\":\"canvas\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"path\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"fillColor\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"strokeWidth\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"hexagonType\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.BaseHexagon\",\"name\":\"baseHexagon\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"hexagonsSvg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"gridX\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"gridY\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rowDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"columnDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rotation\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"shape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"totalGradients\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rows\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"longestRowCount\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Grid\",\"name\":\"grid\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"duration\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"direction\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"chrome\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Gradients\",\"name\":\"gradients\",\"type\":\"tuple\"}],\"internalType\":\"struct IHoneycombs.Honeycomb\",\"name\":\"honeycomb\",\"type\":\"tuple\"}],\"name\":\"getHexagonGrid\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"hexagonsSvg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"gridX\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"gridY\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rowDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"columnDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rotation\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"shape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"totalGradients\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rows\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"longestRowCount\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Grid\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"pathType\",\"type\":\"uint8\"}],\"name\":\"getHexagonPath\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"path\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"day\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"}],\"internalType\":\"struct IHoneycombs.StoredHoneycomb\",\"name\":\"stored\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"isRevealed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"color\",\"type\":\"string\"},{\"internalType\":\"uint16\",\"name\":\"size\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"hexagonSize\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxHexagonsPerLine\",\"type\":\"uint16\"}],\"internalType\":\"struct IHoneycombs.Canvas\",\"name\":\"canvas\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"path\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"fillColor\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"strokeWidth\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"hexagonType\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.BaseHexagon\",\"name\":\"baseHexagon\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"hexagonsSvg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"gridX\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"gridY\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rowDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"columnDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rotation\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"shape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"totalGradients\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rows\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"longestRowCount\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Grid\",\"name\":\"grid\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"duration\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"direction\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"chrome\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Gradients\",\"name\":\"gradients\",\"type\":\"tuple\"}],\"internalType\":\"struct IHoneycombs.Honeycomb\",\"name\":\"honeycomb\",\"type\":\"tuple\"}],\"name\":\"getRandomGrid\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"hexagonsSvg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"gridX\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"gridY\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rowDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"columnDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rotation\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"shape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"totalGradients\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rows\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"longestRowCount\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Grid\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"day\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"}],\"internalType\":\"struct IHoneycombs.StoredHoneycomb\",\"name\":\"stored\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"isRevealed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"color\",\"type\":\"string\"},{\"internalType\":\"uint16\",\"name\":\"size\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"hexagonSize\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxHexagonsPerLine\",\"type\":\"uint16\"}],\"internalType\":\"struct IHoneycombs.Canvas\",\"name\":\"canvas\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"path\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"fillColor\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"strokeWidth\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"hexagonType\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.BaseHexagon\",\"name\":\"baseHexagon\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"hexagonsSvg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"gridX\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"gridY\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rowDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"columnDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rotation\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"shape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"totalGradients\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rows\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"longestRowCount\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Grid\",\"name\":\"grid\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"duration\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"direction\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"chrome\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Gradients\",\"name\":\"gradients\",\"type\":\"tuple\"}],\"internalType\":\"struct IHoneycombs.Honeycomb\",\"name\":\"honeycomb\",\"type\":\"tuple\"}],\"name\":\"getTriangleGrid\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"hexagonsSvg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"gridX\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"gridY\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rowDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"columnDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rotation\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"shape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"totalGradients\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rows\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"longestRowCount\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Grid\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"hexagonsSvg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"gridX\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"gridY\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rowDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"columnDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rotation\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"shape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"totalGradients\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rows\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"longestRowCount\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Grid\",\"name\":\"grid\",\"type\":\"tuple\"},{\"internalType\":\"uint16\",\"name\":\"xIndex\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"yIndex\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"gradientId\",\"type\":\"uint16\"}],\"name\":\"getUpdatedHexagonsSvg\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "GridArt", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}