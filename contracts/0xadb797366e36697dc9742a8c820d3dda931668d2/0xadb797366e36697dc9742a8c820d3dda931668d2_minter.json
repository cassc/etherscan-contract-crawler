{"SourceCode": "pragma solidity ^0.4.16;\r\n\r\n/** @title owned. */\r\ncontract owned  {\r\n  address owner;\r\n  function owned() {\r\n    owner = msg.sender;\r\n  }\r\n  function changeOwner(address newOwner) onlyOwner {\r\n    owner = newOwner;\r\n  }\r\n  modifier onlyOwner() {\r\n    require(msg.sender==owner); \r\n    _;\r\n  }\r\n}\r\n\r\n/** @title mortal. */\r\ncontract mortal is owned() {\r\n  function kill() onlyOwner {\r\n    if (msg.sender == owner) selfdestruct(owner);\r\n  }\r\n}\r\n\r\n/** @title DSMath. */\r\ncontract DSMath {\r\n\r\n\t// Copyright (C) 2015, 2016, 2017  DappHub, LLC\r\n\r\n\t// Licensed under the Apache License, Version 2.0 (the \"License\").\r\n\t// You may not use this file except in compliance with the License.\r\n\r\n\t// Unless required by applicable law or agreed to in writing, software\r\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\r\n    \r\n\t// /*\r\n    // uint128 functions (h is for half)\r\n    //  */\r\n\r\n    function hmore(uint128 x, uint128 y) constant internal returns (bool) {\r\n        return x>y;\r\n    }\r\n\r\n    function hless(uint128 x, uint128 y) constant internal returns (bool) {\r\n        return x<y;\r\n    }\r\n\r\n    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n\r\n    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n\r\n    function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        require(y == 0 ||(z = x * y)/ y == x);\r\n    }\r\n\r\n    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = x / y;\r\n    }\r\n\r\n    function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    // /*\r\n    // int256 functions\r\n    //  */\r\n\r\n    /*\r\n    WAD math\r\n     */\r\n    uint64 constant WAD_Dec=18;\r\n    uint128 constant WAD = 10 ** 18;\r\n\r\n    function wmore(uint128 x, uint128 y) constant internal returns (bool) {\r\n        return hmore(x, y);\r\n    }\r\n\r\n    function wless(uint128 x, uint128 y) constant internal returns (bool) {\r\n        return hless(x, y);\r\n    }\r\n\r\n    function wadd(uint128 x, uint128 y) constant  returns (uint128) {\r\n        return hadd(x, y);\r\n    }\r\n\r\n    function wsub(uint128 x, uint128 y) constant   returns (uint128) {\r\n        return hsub(x, y);\r\n    }\r\n\r\n    function wmul(uint128 x, uint128 y) constant returns (uint128 z) {\r\n        z = cast((uint256(x) * y + WAD / 2) / WAD);\r\n    }\r\n\r\n    function wdiv(uint128 x, uint128 y) constant internal  returns (uint128 z) {\r\n        z = cast((uint256(x) * WAD + y / 2) / y);\r\n    }\r\n\r\n    function wmin(uint128 x, uint128 y) constant internal  returns (uint128) {\r\n        return hmin(x, y);\r\n    }\r\n\r\n    function wmax(uint128 x, uint128 y) constant internal  returns (uint128) {\r\n        return hmax(x, y);\r\n    }\r\n\r\n    function cast(uint256 x) constant internal returns (uint128 z) {\r\n        assert((z = uint128(x)) == x);\r\n    }\r\n\t\r\n}\r\n \r\n/** @title I_minter. */\r\ncontract I_minter { \r\n    event EventCreateStatic(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \r\n    event EventRedeemStatic(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \r\n    event EventCreateRisk(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \r\n    event EventRedeemRisk(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \r\n    event EventBankrupt();\r\n\r\n    function Leverage() constant returns (uint128)  {}\r\n    function RiskPrice(uint128 _currentPrice,uint128 _StaticTotal,uint128 _RiskTotal, uint128 _ETHTotal) constant returns (uint128 price)  {}\r\n    function RiskPrice(uint128 _currentPrice) constant returns (uint128 price)  {}     \r\n    function PriceReturn(uint _TransID,uint128 _Price) {}\r\n    function NewStatic() external payable returns (uint _TransID)  {}\r\n    function NewStaticAdr(address _Risk) external payable returns (uint _TransID)  {}\r\n    function NewRisk() external payable returns (uint _TransID)  {}\r\n    function NewRiskAdr(address _Risk) external payable returns (uint _TransID)  {}\r\n    function RetRisk(uint128 _Quantity) external payable returns (uint _TransID)  {}\r\n    function RetStatic(uint128 _Quantity) external payable returns (uint _TransID)  {}\r\n    function Strike() constant returns (uint128)  {}\r\n}\r\n\r\n/** @title I_Pricer. */\r\ncontract I_Pricer {\r\n    uint128 public lastPrice;\r\n    I_minter public mint;\r\n    string public sURL;\r\n    mapping (bytes32 => uint) RevTransaction;\r\n    function __callback(bytes32 myid, string result) {}\r\n    function queryCost() constant returns (uint128 _value) {}\r\n    function QuickPrice() payable {}\r\n    function requestPrice(uint _actionID) payable returns (uint _TrasID) {}\r\n    function collectFee() returns(bool) {}\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        revert();\r\n    }\r\n}\r\n\r\n/** @title I_coin. */\r\ncontract I_coin is mortal {\r\n\r\n    event EventClear();\r\n\r\n\tI_minter public mint;\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals=18;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = '';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\t\r\n    function mintCoin(address target, uint256 mintedAmount) returns (bool success) {}\r\n    function meltCoin(address target, uint256 meltedAmount) returns (bool success) {}\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData){}\r\n\r\n    function setMinter(address _minter) {}   \r\n\tfunction increaseApproval (address _spender, uint256 _addedValue) returns (bool success) {}    \r\n\tfunction decreaseApproval (address _spender, uint256 _subtractedValue) \treturns (bool success) {} \r\n\r\n    // @param _owner The address from which the balance will be retrieved\r\n    // @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}    \r\n\r\n\r\n    // @notice send `_value` token to `_to` from `msg.sender`\r\n    // @param _to The address of the recipient\r\n    // @param _value The amount of token to be transferred\r\n    // @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n\r\n    // @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    // @param _from The address of the sender\r\n    // @param _to The address of the recipient\r\n    // @param _value The amount of token to be transferred\r\n    // @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    // @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    // @param _spender The address of the account able to transfer the tokens\r\n    // @param _value The amount of wei to be approved for transfer\r\n    // @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\t\r\n\t// @param _owner The address of the account owning tokens\r\n    // @param _spender The address of the account able to transfer the tokens\r\n    // @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\t\r\n\tmapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\t// @return total amount of tokens\r\n    uint256 public totalSupply;\r\n}\r\n\r\n/** @title DSBaseActor. */\r\ncontract DSBaseActor {\r\n   /*\r\n   Copyright 2016 Nexus Development, LLC\r\n\r\n   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n   Unless required by applicable law or agreed to in writing, software\r\n   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   See the License for the specific language governing permissions and\r\n   limitations under the License.\r\n   */\r\n\r\n    bool _ds_mutex;\r\n    modifier mutex() {\r\n        assert(!_ds_mutex);\r\n        _ds_mutex = true;\r\n        _;\r\n        _ds_mutex = false;\r\n    }\r\n\t\r\n    function tryExec( address target, bytes calldata, uint256 value)\r\n\t\t\tmutex()\r\n            internal\r\n            returns (bool call_ret)\r\n    {\r\n\t\t/** @dev Requests new StatiCoins be made for a given address\r\n          * @param target where the ETH is sent to.\r\n          * @param calldata\r\n          * @param value\r\n          * @return True if ETH is transfered\r\n        */\r\n        return target.call.value(value)(calldata);\r\n    }\r\n\t\r\n    function exec( address target, bytes calldata, uint256 value)\r\n             internal\r\n    {\r\n        assert(tryExec(target, calldata, value));\r\n    }\r\n}\r\n\r\n/** @title canFreeze. */\r\ncontract canFreeze is owned { \r\n\t//Copyright (c) 2017 GenkiFS\r\n\t//Basically a \"break glass in case of emergency\"\r\n    bool public frozen=false;\r\n    modifier LockIfFrozen() {\r\n        if (!frozen){\r\n            _;\r\n        }\r\n    }\r\n    function Freeze() onlyOwner {\r\n        // fixes the price and allows everyone to redeem their coins at the current value\r\n\t\t// only becomes false when all ETH has been claimed or the pricer contract is changed\r\n        frozen=true;\r\n    }\r\n}\r\n\r\n/** @title oneWrite. */\r\ncontract oneWrite {  \r\n\t//  Adds modifies that allow one function to be called only once\r\n\t//Copyright (c) 2017 GenkiFS\r\n  bool written = false;\r\n  function oneWrite() {\r\n\t/** @dev Constuctor, make sure written=false initally\r\n\t*/\r\n    written = false;\r\n  }\r\n  modifier LockIfUnwritten() {\r\n    if (written){\r\n        _;\r\n    }\r\n  }\r\n  modifier writeOnce() {\r\n    if (!written){\r\n        written=true;\r\n        _;\r\n    }\r\n  }\r\n}\r\n\r\n/** @title pricerControl. */\r\ncontract pricerControl is canFreeze {\r\n\t//  Copyright (c) 2017 GenkiFS\r\n\t//  Controls the Pricer contract for minter.  Allows updates to be made in the future by swapping the pricer contract\r\n\t//  Although this is not expected, web addresses, API's, new oracles could require adjusments to the pricer contract\r\n\t//  A delay of 2 days is implemented to allow coinholders to redeem their coins if they do not agree with the new contract\r\n\t//  A new pricer contract unfreezes the minter (allowing a live price to be used)\r\n    I_Pricer public pricer;\r\n    address public future;\r\n    uint256 public releaseTime;\r\n    uint public PRICER_DELAY = 2; // days updated when coins are set\r\n    event EventAddressChange(address indexed _from, address indexed _to, uint _timeChange);\r\n\r\n    function setPricer(address newAddress) onlyOwner {\r\n\t\t/** @dev Changes the Pricer contract, after a certain delay\r\n          * @param newAddress Allows coins to be created and sent to other people\r\n          * @return transaction ID which can be viewed in the pending mapping\r\n        */\r\n        releaseTime = now + PRICER_DELAY;\r\n        future = newAddress;\r\n        EventAddressChange(pricer, future, releaseTime);\r\n    }  \r\n\r\n    modifier updates() {\r\n        if (now > releaseTime  && pricer != future){\r\n            update();\r\n            //log0('Updating');\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyPricer() {\r\n      require(msg.sender==address(pricer));\r\n      _;\r\n    }\r\n\r\n    function update() internal {\r\n        pricer =  I_Pricer(future);\r\n\t\tfrozen = false;\r\n    }\r\n}\r\n\r\n/** @title minter. */\t\r\ncontract minter is I_minter, DSBaseActor, oneWrite, pricerControl, DSMath{ //\r\n\t// Copyright (c) 2017 GenkiFS\r\n\t// This contract is the controller for the StatiCoin contracts.  \r\n\t// Users have 4(+2) functions they can call to mint/melt Static/Risk coins which then calls the Pricer contract\r\n\t// after a delay the Pricer contract will call back to the PriceReturn() function\r\n\t// this will then call one of the functions ActionNewStatic, ActionNewRisk, ActionRetStatic, ActionRetRisk\r\n\t// which will then call the Static or Risk ERC20 contracts to mint/melt new tokens\r\n\t// Transfer of tokens is handled by the ERC20 contracts, ETH is stored here.  \r\n    enum Action {NewStatic, RetStatic, NewRisk, RetRisk} // Enum of what users can do\r\n    struct Trans { // Struct\r\n        uint128 amount; // Amount sent by the user (Can be either ETH or number of returned coins)\r\n        address holder; // Address of the user\r\n        Action action;  // Type of action requested (mint/melt a Risk/StatiCoin)\r\n\t\tbytes32 pricerID;  // ID for the pricer function\r\n    }\r\n    uint128 public lastPrice; //Storage of the last price returned by the Pricer contract\r\n\tuint128 public PendingETH; //Amount of eth to be added to the contract\r\n    uint public TransID=0; // An increasing counter to keep track of transactions requested\r\n\tuint public TransCompleted; // Last transaction removed\r\n    string public Currency; // Name of underlying base currency\r\n    I_coin public Static;  // ERC20 token interface for the StatiCoin\r\n    I_coin public Risk;  // ERC20 token interface for the Risk coin\r\n    uint128 public Multiplier;//=15*10**(17); // default ratio for Risk price\r\n    uint128 public levToll=5*10**(18-1);//0.5  // this plus the multiplier defines the maximum leverage\r\n    uint128 public mintFee = 2*10**(18-3); //0.002 Used to pay oricalize and for marketing contract which is in both parties interest.\r\n    mapping (uint => Trans[]) public pending; // A mapping of pending transactions\r\n\r\n    event EventCreateStatic(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \r\n    event EventRedeemStatic(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \r\n    event EventCreateRisk(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \r\n    event EventRedeemRisk(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \r\n    event EventBankrupt();\t//Called when no more ETH is in the contract and everything needs to be manually reset.  \r\n\t\r\n\tfunction minter(string _currency, uint128 _Multiplier) { //,uint8 _DecimalPlaces\r\n        // CONSTRUCTOR  \r\n        Currency=_currency;\r\n        Multiplier = _Multiplier;\r\n        // can't add new contracts here as it gives out of gas messages.  Too much code.\r\n    }\t\r\n\r\n\tfunction () {\r\n        //if ETH is just sent to this address then we cannot determine if it's for StatiCoins or RiskCoins, so send it back.\r\n        revert();\r\n    }\r\n\r\n\tfunction Bailout() \r\n\t\t\texternal \r\n\t\t\tpayable \r\n\t\t\t{\r\n        /** @dev Allows extra ETH to be added to the benefit of both types of coin holders\r\n          * @return nothing\r\n        */\r\n    }\r\n\t\t\r\n    function NewStatic() \r\n\t\t\texternal \r\n\t\t\tpayable \r\n\t\t\treturns (uint _TransID) {\r\n        /** @dev Requests new StatiCoins be made for the sender.  \r\n\t\t  * This cannot be called by a contract.  Only a simple wallet (with 0 codesize).\r\n\t\t  * Contracts must use the Approve, transferFrom pattern and move coins from wallets\r\n          * @return transaction ID which can be viewed in the pending mapping\r\n        */\r\n\t\t_TransID=NewCoinInternal(msg.sender,cast(msg.value),Action.NewStatic);\r\n\t\t//log0('NewStatic');\r\n    }\r\n\t\r\n    function NewStaticAdr(address _user) \r\n\t\t\texternal \r\n\t\t\tpayable \r\n\t\t\treturns (uint _TransID)  {  \r\n        /** @dev Requests new StatiCoins be made for a given address.  \r\n\t\t  * The address cannot be a contract, only a simple wallet (with 0 codesize).\r\n\t\t  * Contracts must use the Approve, transferFrom pattern and move coins from wallets\r\n          * @param _user Allows coins to be created and sent to other people\r\n          * @return transaction ID which can be viewed in the pending mapping\r\n        */\r\n\t\t_TransID=NewCoinInternal(_user,cast(msg.value),Action.NewStatic);\r\n\t\t//log0('NewStatic');\r\n    }\r\n\t\r\n    function NewRisk() \r\n\t\t\texternal \r\n\t\t\tpayable \r\n\t\t\treturns (uint _TransID)  {\r\n        /** @dev Requests new Riskcoins be made for the sender.  \r\n\t\t  * This cannot be called by a contract, only a simple wallet (with 0 codesize).\r\n\t\t  * Contracts must use the Approve, transferFrom pattern and move coins from wallets\r\n          * @return transaction ID which can be viewed in the pending mapping\r\n          */\r\n\t\t_TransID=NewCoinInternal(msg.sender,cast(msg.value),Action.NewRisk);\r\n        //log0('NewRisk');\r\n    }\r\n\r\n    function NewRiskAdr(address _user) \r\n\t\t\texternal \r\n\t\t\tpayable \r\n\t\t\treturns (uint _TransID)  {\r\n        /** @dev Requests new Riskcoins be made for a given address.  \r\n\t\t  * The address cannot be a contract, only a simple wallet (with 0 codesize).\r\n\t\t  * Contracts must use the Approve, transferFrom pattern and move coins from wallets\r\n          * @param _user Allows coins to be created and sent to other people\r\n          * @return transaction ID which can be viewed in the pending mapping\r\n          */\r\n\t\t_TransID=NewCoinInternal(_user,cast(msg.value),Action.NewRisk);\r\n        //log0('NewRisk');\r\n    }\r\n\r\n    function RetRisk(uint128 _Quantity) \r\n\t\t\texternal \r\n\t\t\tpayable \r\n\t\t\tLockIfUnwritten  \r\n\t\t\treturns (uint _TransID)  {\r\n        /** @dev Returns Riskcoins.  Needs a bit of eth sent to pay the pricer contract and the excess is returned.  \r\n\t\t  * The address cannot be a contract, only a simple wallet (with 0 codesize).\r\n          * @param _Quantity Amount of coins being returned\r\n\t\t  * @return transaction ID which can be viewed in the pending mapping\r\n        */\r\n        if(frozen){\r\n            //Skip the pricer contract\r\n            TransID++;\r\n\t\t\tActionRetRisk(Trans(_Quantity,msg.sender,Action.RetRisk,0),TransID,lastPrice);\r\n\t\t\t_TransID=TransID;\r\n        } else {\r\n            //Only returned when Risk price is positive\r\n\t\t\t_TransID=RetCoinInternal(_Quantity,cast(msg.value),msg.sender,Action.RetRisk);\r\n        }\r\n\t\t//log0('RetRisk');\r\n    }\r\n\r\n    function RetStatic(uint128 _Quantity) \r\n\t\t\texternal \r\n\t\t\tpayable \r\n\t\t\tLockIfUnwritten  \r\n\t\t\treturns (uint _TransID)  {\r\n        /** @dev Returns StatiCoins,  Needs a bit of eth sent to pay the pricer contract\r\n          * @param _Quantity Amount of coins being returned\r\n\t\t  * @return transaction ID which can be viewed in the pending mapping\r\n        */\r\n        if(frozen){\r\n            //Skip the pricer contract\r\n\t\t\tTransID++;\r\n            ActionRetStatic(Trans(_Quantity,msg.sender,Action.RetStatic,0),TransID,lastPrice);\r\n\t\t\t_TransID=TransID;\r\n        } else {\r\n            //Static can be returned at any time\r\n\t\t\t_TransID=RetCoinInternal(_Quantity,cast(msg.value),msg.sender,Action.RetStatic);\r\n        }\r\n\t\t//log0('RetStatic');\r\n    }\r\n\t\r\n\t//****************************//\r\n\t// Constant functions (Ones that don't write to the blockchain)\r\n\r\n    function StaticEthAvailable() \r\n\t\t\tconstant \r\n\t\t\treturns (uint128)  {\r\n\t\t/** @dev Returns the total amount of eth that can be sent to buy StatiCoins\r\n\t\t  * @return amount of Eth\r\n        */\r\n\t\treturn StaticEthAvailable(cast(Risk.totalSupply()), cast(this.balance));\r\n    }\r\n\r\n\tfunction StaticEthAvailable(uint128 _RiskTotal, uint128 _TotalETH) \r\n\t\t\tconstant \r\n\t\t\treturns (uint128)  {\r\n\t\t/** @dev Returns the total amount of eth that can be sent to buy StatiCoins allows users to test arbitrary amounts of RiskTotal and ETH contained in the contract\r\n\t\t  * @param _RiskTotal Quantity of riskcoins\r\n          * @param  _TotalETH Total value of ETH in the contract\r\n\t\t  * @return amount of Eth\r\n        */\r\n\t\t// (Multiplier+levToll)*_RiskTotal - _TotalETH\r\n\t\tuint128 temp = wmul(wadd(Multiplier,levToll),_RiskTotal);\r\n\t\tif(wless(_TotalETH,temp)){\r\n\t\t\treturn wsub(temp ,_TotalETH);\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}\r\n    }\r\n\r\n\tfunction RiskPrice(uint128 _currentPrice,uint128 _StaticTotal,uint128 _RiskTotal, uint128 _ETHTotal) \r\n\t\t\tconstant \r\n\t\t\treturns (uint128 price)  {\r\n\t    /** @dev Allows users to query various hypothetical prices of RiskCoins in terms of base currency\r\n          * @param _currentPrice Current price of ETH in Base currency.\r\n          * @param _StaticTotal Total quantity of StatiCoins issued.\r\n          * @param _RiskTotal Total quantity of invetor coins issued.\r\n          * @param _ETHTotal Total quantity of ETH in the contract.\r\n          * @return price of RiskCoins \r\n        */\r\n        if(_ETHTotal == 0 || _RiskTotal==0){\r\n\t\t\t//Return the default price of _currentPrice * Multiplier\r\n            return wmul( _currentPrice , Multiplier); \r\n        } else {\r\n            if(hmore( wmul(_ETHTotal , _currentPrice),_StaticTotal)){ //_ETHTotal*_currentPrice>_StaticTotal\r\n\t\t\t\t//Risk price is positive\r\n                return wdiv(wsub(wmul(_ETHTotal , _currentPrice) , _StaticTotal) , _RiskTotal); // (_ETHTotal * _currentPrice) - _StaticTotal) / _RiskTotal\r\n            } else  {\r\n\t\t\t\t//RiskPrice is negative\r\n                return 0;\r\n            }\r\n        }       \r\n    }\r\n\t\r\n    function RiskPrice(uint128 _currentPrice) \r\n\t\t\tconstant \r\n\t\t\treturns (uint128 price)  {\r\n\t    /** @dev Allows users to query price of RiskCoins in terms of base currency, using current quantities of coins\r\n          * @param _currentPrice Current price of ETH in Base currency.\r\n\t      * @return price of RiskCoins \r\n        */\r\n        return RiskPrice(_currentPrice,cast(Static.totalSupply()),cast(Risk.totalSupply()),wsub(cast(this.balance),PendingETH));\r\n    }     \r\n\r\n    function LastRiskPrice() \r\n\t\t\tconstant \r\n\t\t\treturns (uint128 price)  {\r\n\t    /** @dev Allows users to query the last price of RiskCoins in terms of base currency\r\n        *   @return price of RiskCoins \r\n        */\r\n        return RiskPrice(lastPrice);\r\n    }     \t\t\r\n\t\r\n\tfunction Leverage() public \r\n\t\t\tconstant \r\n\t\t\treturns (uint128)  {\r\n\t\t/** @dev Returns the ratio at which Riskcoin grows in value for the equivalent growth in ETH price\r\n\t\t* @return ratio\r\n        */\r\n        if(Risk.totalSupply()>0){\r\n            return wdiv(cast(this.balance) , cast(Risk.totalSupply())); //  this.balance/Risk.totalSupply\r\n        }else{\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function Strike() public \r\n\t\t\tconstant \r\n\t\t\treturns (uint128)  {\r\n\t\t/** @dev Returns the current price at which the Risk price goes negative\r\n\t\t* @return Risk price in underlying per ETH\r\n        */ \r\n        if(this.balance>0){\r\n            return wdiv(cast(Static.totalSupply()) , cast(this.balance)); //Static.totalSupply / this.balance\r\n        }else{\r\n            return 0;            \r\n        }\r\n    }\r\n\r\n\t//****************************//\r\n\t// Only owner can access the following functions\r\n    function setFee(uint128 _newFee) \r\n\t\t\tonlyOwner {\r\n        /** @dev Allows the minting fee to be changed, only owner can modify\r\n          * @param _newFee Size of new fee\r\n          * return nothing \r\n        */\r\n        mintFee=_newFee;\r\n    }\r\n\r\n    function setCoins(address newRisk,address newStatic) \r\n\t\t\tupdates \r\n\t\t\tonlyOwner \r\n\t\t\twriteOnce {\r\n        /** @dev Allows the minting fee to be reduced, only owner can modify once, Triggers the pricer to be updated \r\n          * @param newRisk Address of Riskcoin contract\r\n          * @param newStatic Address of StatiCoin contract\r\n          * return nothing \r\n        */\r\n        Risk=I_coin(newRisk);\r\n        Static=I_coin(newStatic);\r\n\t\tPRICER_DELAY = 2 days;\r\n    }\r\n\t\r\n\t//****************************//\t\r\n\t// Only Pricer can access the following function\r\n    function PriceReturn(uint _TransID,uint128 _Price) \r\n\t\t\tonlyPricer {\r\n\t    /** @dev Return function for the Pricer contract only.  Controls melting and minting of new coins.\r\n          * @param _TransID Tranasction ID issued by the minter.\r\n          * @param _Price Quantity of Base currency per ETH delivered by the Pricer contract\r\n          * Nothing returned.  One of 4 functions is implemented\r\n        */\r\n\t    Trans memory details=pending[_TransID][0];//Get the details for this transaction. \r\n        if(0==_Price||frozen){ //If there is an error in pricing or contract is frozen, use the old price\r\n            _Price=lastPrice;\r\n        } else {\r\n\t\t\tif(Static.totalSupply()>0 && Risk.totalSupply()>0) {// dont update if there are coins missing\r\n\t\t\t\tlastPrice=_Price; // otherwise update the last price\r\n\t\t\t}\r\n        }\r\n\t\t//Mint some new StatiCoins\r\n        if(Action.NewStatic==details.action){\r\n            ActionNewStatic(details,_TransID, _Price);\r\n        }\r\n\t\t//Melt some old StatiCoins\r\n        if(Action.RetStatic==details.action){\r\n            ActionRetStatic(details,_TransID, _Price);\r\n        }\r\n\t\t//Mint some new Risk coins\r\n        if(Action.NewRisk==details.action){\r\n            ActionNewRisk(details,_TransID, _Price);\r\n        }\r\n\t\t//Melt some old Risk coin\r\n        if(Action.RetRisk==details.action){\r\n            ActionRetRisk(details,_TransID, _Price);\r\n        }\r\n\t\t//Remove the transaction from the blockchain (saving some gas)\r\n\t\tTransCompleted=_TransID;\r\n\t\tdelete pending[_TransID];\r\n    }\r\n\t\r\n\t//****************************//\r\n    // Only internal functions now\r\n    function ActionNewStatic(Trans _details, uint _TransID, uint128 _Price) \r\n\t\t\tinternal {\r\n\t\t/** @dev Internal function to create new StatiCoins based on transaction data in the Pending queue.  If not enough spare StatiCoins are available then ETH is refunded.\r\n          * @param _details Structure holding the amount sent (in ETH), the address of the person to sent to, and the type of request.\r\n          * @param _TransID ID of the transaction (as stored in this contract).\r\n          * @param _Price Current 24 hour average price as returned by the oracle in the pricer contract.\r\n          * @return function returns nothing, but adds StatiCoins to the users address and events are created\r\n        */\r\n\t\t//log0('NewStatic');\r\n            \r\n            //if(Action.NewStatic<>_details.action){revert();}  //already checked\r\n\t\t\t\r\n\t\t\tuint128 CurRiskPrice=RiskPrice(_Price);\r\n\t\t\tuint128 AmountReturn;\r\n\t\t\tuint128 AmountMint;\r\n\t\t\t\r\n\t\t\t//Calculates the amount of ETH that can be added to create StatiCoins (excluding the amount already sent and stored in the contract)\r\n\t\t\tuint128 StaticAvail = StaticEthAvailable(cast(Risk.totalSupply()), wsub(cast(this.balance),PendingETH)); \r\n\t\t\t\t\t\t\r\n\t\t\t// If the amount sent is less than the Static amount available, everything is fine.  Nothing needs to be returned.  \r\n\t\t\tif (wless(_details.amount,StaticAvail)) {\r\n\t\t\t\t// restrictions do not hamper the creation of a StatiCoin\r\n\t\t\t\tAmountMint = _details.amount;\r\n\t\t\t\tAmountReturn = 0;\r\n\t\t\t} else {\r\n\t\t\t\t// Amount of Static is less than amount requested.  \r\n\t\t\t\t// Take all the StatiCoins available.\r\n\t\t\t\t// Maybe there is zero Static available, so all will be returned.\r\n\t\t\t\tAmountMint = StaticAvail;\r\n\t\t\t\tAmountReturn = wsub(_details.amount , StaticAvail) ;\r\n\t\t\t}\t\r\n\t\t\t\r\n\t\t\tif(0 == CurRiskPrice){\r\n\t\t\t\t// return all the ETH\r\n\t\t\t\tAmountReturn = _details.amount;\r\n\t\t\t\t//AmountMint = 0; //not required as Risk price = 0\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t//Static can be added when Risk price is positive and leverage is below the limit\r\n            if(CurRiskPrice > 0  && StaticAvail>0 ){\r\n                // Dont create if CurRiskPrice is 0 or there is no Static available (leverage is too high)\r\n\t\t\t\t//log0('leverageOK');\r\n                Static.mintCoin(_details.holder, uint256(wmul(AmountMint , _Price))); //request coins from the Static creator contract\r\n                EventCreateStatic(_details.holder, wmul(AmountMint , _Price), _TransID, _Price); // Event giving the holder address, coins created, transaction id, and price \r\n\t\t\t\tPendingETH=wsub(PendingETH,AmountMint);\r\n            } \r\n\r\n\t\t\tif (AmountReturn>0) {\r\n                // return some money because not enough StatiCoins are available\r\n\t\t\t\tbytes memory calldata; // define a blank `bytes`\r\n                exec(_details.holder,calldata, AmountReturn);  //Refund ETH from this contract\r\n\t\t\t\tPendingETH=wsub(PendingETH,AmountReturn);\r\n\t\t\t}\t\r\n    }\r\n\r\n    function ActionNewRisk(Trans _details, uint _TransID,uint128 _Price) \r\n\t\t\tinternal {\r\n\t\t/** @dev Internal function to create new Risk coins based on transaction data in the Pending queue.  Risk coins can only be created if the price is above zero\r\n          * @param _details Structure holding the amount sent (in ETH), the address of the person to sent to, and the type of request.\r\n          * @param _TransID ID of the transaction (as stored in this contract).\r\n          * @param _Price Current 24 hour average price as returned by the oracle in the pricer contract.\r\n          * @return function returns nothing, but adds Riskcoins to the users address and events are created\r\n        */\r\n        //log0('NewRisk');\r\n        //if(Action.NewRisk<>_details.action){revert();}  //already checked\r\n\t\t// Get the Risk price using the amount of ETH in the contract before this transaction existed\r\n\t\tuint128 CurRiskPrice;\r\n\t\tif(wless(cast(this.balance),PendingETH)){\r\n\t\t\tCurRiskPrice=0;\r\n\t\t} else {\r\n\t\t\tCurRiskPrice=RiskPrice(_Price,cast(Static.totalSupply()),cast(Risk.totalSupply()),wsub(cast(this.balance),PendingETH));\r\n\t\t}\r\n        if(CurRiskPrice>0){\r\n            uint128 quantity=wdiv(wmul(_details.amount , _Price),CurRiskPrice);  // No of Riskcoins =  _details.amount * _Price / CurRiskPrice\r\n            Risk.mintCoin(_details.holder, uint256(quantity) );  //request coins from the Riskcoin creator contract\r\n            EventCreateRisk(_details.holder, quantity, _TransID, _Price); // Event giving the holder address, coins created, transaction id, and price \r\n        } else {\r\n            // Don't create if CurRiskPrice is 0, Return all the ETH originally sent\r\n            bytes memory calldata; // define a blank `bytes`\r\n            exec(_details.holder,calldata, _details.amount);\r\n        }\r\n\t\tPendingETH=wsub(PendingETH,_details.amount);\r\n    }\r\n\r\n    function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) \r\n\t\t\tinternal {\r\n\t\t/** @dev Internal function to Return StatiCoins based on transaction data in the Pending queue.  Static can be returned at any time.\r\n          * @param _details Structure holding the amount sent (in ETH), the address of the person to sent to, and the type of request.\r\n          * @param _TransID ID of the transaction (as stored in this contract).\r\n          * @param _Price Current 24 hour average price as returned by the oracle in the pricer contract.\r\n          * @return function returns nothing, but removes StatiCoins from the user's address, sends ETH and events are created\r\n        */\r\n\t\t//if(Action.RetStatic<>_details.action){revert();}  //already checked\r\n\t\t//log0('RetStatic');\r\n\t\tuint128 _ETHReturned;\r\n\t\tif(0==Risk.totalSupply()){_Price=lastPrice;} //No Risk coins for balance so use fixed price\r\n        _ETHReturned = wdiv(_details.amount , _Price); //_details.amount / _Price\r\n        if (Static.meltCoin(_details.holder,_details.amount)){\r\n            // deducted first, will add back if Returning ETH goes wrong.\r\n            EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);\r\n            if (wless(cast(this.balance),_ETHReturned)) {\r\n                 _ETHReturned=cast(this.balance);//Not enough ETH available.  Return all Eth in the contract\r\n            }\r\n\t\t\tbytes memory calldata; // define a blank `bytes`\r\n            if (tryExec(_details.holder, calldata, _ETHReturned)) { \r\n\t\t\t\t//ETH returned successfully\r\n\t\t\t} else {\r\n\t\t\t\t// there was an error, so add back the amount previously deducted\r\n\t\t\t\tStatic.mintCoin(_details.holder,_details.amount); //Add back the amount requested\r\n\t\t\t\tEventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);  //redo the creation event\r\n\t\t\t}\r\n\t\t\tif ( 0==this.balance) {\r\n\t\t\t\tBankrupt();\r\n\t\t\t}\r\n        }        \r\n    }\r\n\r\n    function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) \r\n\t\t\tinternal {\r\n\t\t/** @dev Internal function to Return Riskcoins based on transaction data in the Pending queue.  Riskcoins can be returned so long as the Risk price is greater than 0.\r\n          * @param _details Structure holding the amount sent (in ETH), the address of the person to sent to, and the type of request.\r\n          * @param _TransID ID of the transaction (as stored in this contract).\r\n          * @param _Price Current 24 hour average price as returned by the oracle in the Pricer contract.\r\n          * @return function returns nothing, but removes StatiCoins from the users address, sends ETH and events are created\r\n        */        \r\n\t\t//if(Action.RetRisk<>_details.action){revert();}  //already checked\r\n\t\t//log0('RetRisk');\r\n        uint128 _ETHReturned;\r\n\t\tuint128 CurRiskPrice;\r\n\t\t//if(0==Static.totalSupply()){_Price=lastPrice};// no StatiCoins, so all Risk coins are worth the same.  // _ETHReturned = _details.amount / _RiskTotal * _ETHTotal\r\n\t\tCurRiskPrice=RiskPrice(_Price);\r\n        if(CurRiskPrice>0){\r\n            _ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price); // _details.amount * CurRiskPrice / _Price\r\n            if (Risk.meltCoin(_details.holder,_details.amount )){\r\n                // Coins are deducted first, will add back if returning ETH goes wrong.\r\n                EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);\r\n                if ( wless(cast(this.balance),_ETHReturned)) { // should never happen, but just in case\r\n                     _ETHReturned=cast(this.balance);\r\n                }\r\n\t\t\t\tbytes memory calldata; // define a blank `bytes`\r\n                if (tryExec(_details.holder, calldata, _ETHReturned)) { \r\n\t\t\t\t\t//Returning ETH went ok.  \r\n                } else {\r\n                    // there was an error, so add back the amount previously deducted from the Riskcoin contract\r\n                    Risk.mintCoin(_details.holder,_details.amount);\r\n                    EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);\r\n                }\r\n            } \r\n        }  else {\r\n            // Risk price is zero so can't do anything.  Call back and delete the transaction from the contract\r\n        }\r\n    }\r\n\r\n\tfunction IsWallet(address _address) \r\n\t\t\tinternal \r\n\t\t\treturns(bool){\r\n\t\t/**\r\n\t\t* @dev checks that _address is not a contract.  \r\n\t\t* @param _address to check \r\n\t\t* @return True if not a contract, \r\n\t\t*/\t\t\r\n\t\tuint codeLength;\r\n\t\tassembly {\r\n            // Retrieve the size of the code on target address, this needs assembly .\r\n            codeLength := extcodesize(_address)\r\n        }\r\n\t\treturn(0==codeLength);\t\t\r\n    } \r\n\r\n\tfunction RetCoinInternal(uint128 _Quantity, uint128 _AmountETH, address _user, Action _action) \r\n\t\t\tinternal \r\n\t\t\tupdates \r\n\t\t\treturns (uint _TransID)  {\r\n        /** @dev Requests coins be melted and ETH returned\r\n\t\t  * @param _Quantity of Static or Risk coins to be melted0\r\n\t\t  * @param _AmountETH Amount of eth sent to this contract to cover oracle fee.  Excess is returned.\r\n          * @param _user Address to whom the returned ETH will be sent.\r\n\t\t  * @param _action Allows Static or Risk coins to be returned\r\n\t\t  * @return transaction ID which can be viewed in the Pending mapping\r\n        */\r\n\t\trequire(IsWallet(_user));\r\n\t\tuint128 refund;\r\n        uint128 Fee=pricer.queryCost();  //Get the cost of querying the pricer contract\r\n\t\tif(wless(_AmountETH,Fee)){\r\n\t\t\trevert();  //log0('Not enough ETH to mint');\r\n\t\t\t} else {\r\n\t\t\trefund=wsub(_AmountETH,Fee);//Returning coins has had too much ETH sent, so return it.\r\n\t\t}\r\n\t\tif(0==_Quantity){revert();}// quantity has to be non zero\r\n\t\tTransID++;\r\n        \r\n        uint PricerID = pricer.requestPrice.value(uint256(Fee))(TransID);  //Ask the pricer to get the price.  The Fee also cover calling the function PriceReturn at a later time.\r\n\t\tpending[TransID].push(Trans(_Quantity,_user,_action,bytes32(PricerID)));  //Add a transaction to the Pending queue.\r\n        _TransID=TransID;  //return the transaction ID to the user \r\n        _user.transfer(uint256(refund)); //Return ETH if too much has been sent to cover the pricer\r\n    }\r\n\t\t\r\n\tfunction NewCoinInternal(address _user, uint128 _amount, Action _action) \r\n\t\t\tinternal \r\n\t\t\tupdates \r\n\t\t\tLockIfUnwritten \r\n\t\t\tLockIfFrozen  \r\n\t\t\treturns (uint _TransID)  {\r\n\t\t/** @dev Requests new coins be made\r\n          * @param _user Address for whom the coins are to be created\r\n          * @param _amount Amount of eth sent to this contract\r\n\t\t  * @param _action Allows Static or Risk coins to be minted\r\n\t\t  * @return transaction ID which can be viewed in the pending mapping\r\n        */\r\n\t\trequire(IsWallet(_user));\r\n\t\tuint128 toCredit;\r\n        uint128 Fee=wmax(wmul(_amount,mintFee),pricer.queryCost()); // fee is the maxium of the pricer query cost and a mintFee% of value sent\r\n        if(wless(_amount,Fee)) revert(); //log0('Not enough ETH to mint');\r\n\t\tTransID++;\r\n        uint PricerID = pricer.requestPrice.value(uint256(Fee))(TransID); //Ask the pricer to return the price\r\n\t\ttoCredit=wsub(_amount,Fee);\r\n\t\tpending[TransID].push(Trans(toCredit,_user,_action,bytes32(PricerID))); //Store the transaction ID and data ready for later recall\r\n\t\tPendingETH=wadd(PendingETH,toCredit);\r\n        _TransID=TransID;//return the transaction ID for this contract to the user \t\t\r\n\t} \r\n\r\n    function Bankrupt() \r\n\t\t\tinternal {\r\n\t\t\tEventBankrupt();\r\n\t\t\t// Reset the contract\r\n\t\t\tStatic.kill();  //delete all current Static tokens\r\n\t\t\tRisk.kill();  //delete all current Risk tokens\r\n\t\t\t//need to create new coins externally, too much gas is used if done here.  \r\n\t\t\tfrozen=false;\r\n\t\t\twritten=false;  // Reset the writeOnce and LockIfUnwritten modifiers\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"_currentPrice\",\"type\":\"uint128\"},{\"name\":\"_StaticTotal\",\"type\":\"uint128\"},{\"name\":\"_RiskTotal\",\"type\":\"uint128\"},{\"name\":\"_ETHTotal\",\"type\":\"uint128\"}],\"name\":\"RiskPrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"frozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"NewRisk\",\"outputs\":[{\"name\":\"_TransID\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TransCompleted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setPricer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Static\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newFee\",\"type\":\"uint128\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_Quantity\",\"type\":\"uint128\"}],\"name\":\"RetStatic\",\"outputs\":[{\"name\":\"_TransID\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Bailout\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Leverage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_Quantity\",\"type\":\"uint128\"}],\"name\":\"RetRisk\",\"outputs\":[{\"name\":\"_TransID\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newRisk\",\"type\":\"address\"},{\"name\":\"newStatic\",\"type\":\"address\"}],\"name\":\"setCoins\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_currentPrice\",\"type\":\"uint128\"}],\"name\":\"RiskPrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint128\"},{\"name\":\"y\",\"type\":\"uint128\"}],\"name\":\"wsub\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Risk\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Currency\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint128\"},{\"name\":\"y\",\"type\":\"uint128\"}],\"name\":\"wadd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"NewStatic\",\"outputs\":[{\"name\":\"_TransID\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"NewRiskAdr\",\"outputs\":[{\"name\":\"_TransID\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Strike\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint128\"},{\"name\":\"y\",\"type\":\"uint128\"}],\"name\":\"wmul\",\"outputs\":[{\"name\":\"z\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TransID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"NewStaticAdr\",\"outputs\":[{\"name\":\"_TransID\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"future\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pending\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint128\"},{\"name\":\"holder\",\"type\":\"address\"},{\"name\":\"action\",\"type\":\"uint8\"},{\"name\":\"pricerID\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pricer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LastRiskPrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"levToll\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"releaseTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_TransID\",\"type\":\"uint256\"},{\"name\":\"_Price\",\"type\":\"uint128\"}],\"name\":\"PriceReturn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"StaticEthAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRICER_DELAY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_RiskTotal\",\"type\":\"uint128\"},{\"name\":\"_TotalETH\",\"type\":\"uint128\"}],\"name\":\"StaticEthAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PendingETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Multiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_currency\",\"type\":\"string\"},{\"name\":\"_Multiplier\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"_transactionID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_Price\",\"type\":\"uint256\"}],\"name\":\"EventCreateStatic\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"_transactionID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_Price\",\"type\":\"uint256\"}],\"name\":\"EventRedeemStatic\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"_transactionID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_Price\",\"type\":\"uint256\"}],\"name\":\"EventCreateRisk\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"_transactionID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_Price\",\"type\":\"uint256\"}],\"name\":\"EventRedeemRisk\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EventBankrupt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_timeChange\",\"type\":\"uint256\"}],\"name\":\"EventAddressChange\",\"type\":\"event\"}]", "ContractName": "minter", "CompilerVersion": "v0.4.16+commit.d7661dd9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000014d1120d7b160000000000000000000000000000000000000000000000000000000000000000000d455448555344204d696e74657200000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://a52654792a417bc00b891c054b85980aae6520c677cb8c0bcdab9de49f4ace74"}