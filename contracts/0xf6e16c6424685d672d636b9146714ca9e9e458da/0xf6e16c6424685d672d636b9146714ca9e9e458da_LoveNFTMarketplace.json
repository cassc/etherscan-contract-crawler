{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(\\n        uint256 tokenId,\\n        uint256 salePrice\\n    ) external view returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC1155Receiver.sol\\\";\\n\\n/**\\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\\n *\\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\\n * stuck.\\n *\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155Holder is ERC1155Receiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Receiver.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILoveNFTMarketplace.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.18;\\n\\nimport {ILoveRoles} from './ILoveRoles.sol';\\nimport {ILoveNFTShared} from './ILoveNFTShared.sol';\\n\\ninterface ILoveNFTMarketplace is ILoveRoles {\\n  enum TokenType {\\n    ERC721,\\n    ERC1155\\n  }\\n\\n  struct NFT {\\n    address addr;\\n    uint256 tokenId;\\n  }\\n\\n  struct ListingParams {\\n    NFT nft;\\n    uint256 price;\\n    uint256 startTime;\\n    uint256 endTime;\\n  }\\n\\n  struct ListNFT {\\n    NFT nft;\\n    TokenType tokenType;\\n    address seller;\\n    uint256 price;\\n    uint256 startTime;\\n    uint256 endTime;\\n  }\\n\\n  struct LazyListingParams {\\n    NFT nft;\\n    uint256 price;\\n    uint256 startTime;\\n    uint256 endTime;\\n    bytes32 uid;\\n  }\\n\\n  struct OfferNFT {\\n    NFT nft;\\n    address offerer;\\n    uint256 offerPrice;\\n    TokenType tokenType;\\n    TokenRoyaltyInfo royaltyInfo;\\n    bool accepted;\\n  }\\n\\n  struct OfferNFTParams {\\n    NFT nft;\\n    address offerer;\\n    uint256 price;\\n  }\\n\\n  struct AuctionParams {\\n    NFT nft;\\n    uint256 initialPrice;\\n    uint256 minBidStep;\\n    uint256 startTime;\\n    uint256 endTime;\\n  }\\n\\n  struct AuctionNFT {\\n    NFT nft;\\n    TokenType tokenType;\\n    address creator;\\n    uint256 initialPrice;\\n    uint256 minBidStep;\\n    uint256 startTime;\\n    uint256 endTime;\\n    address lastBidder;\\n    uint256 highestBid;\\n    TokenRoyaltyInfo royaltyInfo;\\n    address winner;\\n    bool success;\\n  }\\n\\n  struct TokenRoyaltyInfo {\\n    address royaltyReceiver;\\n    uint256 royaltyAmount;\\n  }\\n\\n  // events\\n  event ChangedPlatformFee(uint256 newValue);\\n  event ChangedFeeReceiver(address newFeeReceiver);\\n\\n  event ListedNFT(\\n    address indexed nftAddress,\\n    uint256 indexed tokenId,\\n    uint256 price,\\n    address indexed seller,\\n    uint256 startTime,\\n    uint256 endTime\\n  );\\n\\n  event CanceledListedNFT(\\n    address indexed nftAddress,\\n    uint256 indexed tokenId,\\n    uint256 price,\\n    address indexed seller,\\n    uint256 startTime,\\n    uint256 endTime\\n  );\\n\\n  event BoughtNFT(\\n    address indexed nftAddress,\\n    uint256 indexed tokenId,\\n    uint256 price,\\n    address seller,\\n    address indexed buyer\\n  );\\n  event OfferedNFT(address indexed nftAddress, uint256 indexed tokenId, uint256 offerPrice, address indexed offerer);\\n  event CanceledOfferedNFT(\\n    address indexed nftAddress,\\n    uint256 indexed tokenId,\\n    uint256 offerPrice,\\n    address indexed offerer\\n  );\\n  event AcceptedNFT(\\n    address indexed nftAddress,\\n    uint256 indexed tokenId,\\n    uint256 offerPrice,\\n    address offerer,\\n    address indexed nftOwner\\n  );\\n  event CreatedAuction(\\n    address indexed nftAddress,\\n    uint256 indexed tokenId,\\n    uint256 price,\\n    uint256 minBidStep,\\n    uint256 startTime,\\n    uint256 endTime,\\n    address indexed creator\\n  );\\n  event PlacedBid(address indexed nftAddress, uint256 indexed tokenId, uint256 bidPrice, address indexed bidder);\\n  event CanceledAuction(address indexed nftAddress, uint256 indexed tokenId);\\n\\n  event ResultedAuction(\\n    address indexed nftAddress,\\n    uint256 indexed tokenId,\\n    address creator,\\n    address indexed winner,\\n    uint256 price,\\n    address caller\\n  );\\n\\n  function listNft(ListingParams calldata params) external returns (uint256);\\n\\n  function getListedNFT(NFT calldata nft) external view returns (ListNFT memory);\\n\\n  function cancelListedNFT(NFT calldata nft) external;\\n\\n  function buyNFT(NFT calldata nft, uint256 price) external returns (uint256 priceWithRoyalty);\\n\\n  function buyLazyListedNFT(\\n    ILoveNFTShared.MintRequest calldata params,\\n    bytes calldata signature\\n  ) external returns (uint256 priceWithRoyalty);\\n\\n  function offerNFT(OfferNFTParams calldata params) external returns (uint256);\\n\\n  function cancelOfferNFT(OfferNFTParams calldata params) external returns (uint256);\\n\\n  function acceptOfferNFT(OfferNFTParams calldata params) external returns (uint256);\\n\\n  function createAuction(AuctionParams calldata params) external;\\n\\n  function cancelAuction(NFT calldata nft) external;\\n\\n  function bidPlace(NFT calldata nft, uint256 bidPrice) external returns (uint256);\\n\\n  function resultAuction(NFT calldata nft) external returns (uint256);\\n\\n  function resultAuctions(NFT[] calldata nfts) external returns (uint256);\\n\\n  function getAuction(NFT calldata nft) external view returns (AuctionNFT memory);\\n\\n  function transferFee(uint256 amount) external;\\n\\n  function setPlatformFee(uint256 newPlatformFee) external;\\n\\n  function updateFeeReceiver(address newFeeReceiver) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILoveNFTShared.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.18;\\n\\nimport {IERC1155} from '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\\nimport {IERC2981} from '@openzeppelin/contracts/interfaces/IERC2981.sol';\\nimport {IERC1155MetadataURI} from '@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol';\\n\\ninterface ILoveNFTShared is IERC1155, IERC1155MetadataURI, IERC2981 {\\n  struct MintRequest {\\n    uint256 tokenId;\\n    uint256 price;\\n    uint128 startTimestamp;\\n    uint128 endTimestamp;\\n    string uri;\\n    address royaltyRecipient;\\n    uint96 royaltyFraction;\\n    bytes32 uid;\\n  }\\n\\n  function redeem(address account, MintRequest calldata _req, bytes calldata signature) external;\\n\\n  function exists(uint256 tokenId) external view returns (bool);\\n\\n  function feeDenominator() external pure returns (uint96);\\n\\n  function decodeTokenId(uint256 tokenId) external pure returns (address, uint256, uint256);\\n\\n  function encodeTokenId(address creator, uint256 index, uint256 collection) external pure returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILoveRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.18;\\n\\ninterface ILoveRoles {\\n  function grantRole(address account, string calldata role) external;\\n\\n  function revokeRole(address account, string calldata role) external;\\n\\n  function checkRole(address accountToCheck, string calldata role) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/LoveRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.18;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\nimport {ILoveRoles} from '../interfaces/ILoveRoles.sol';\\n\\nabstract contract LoveRoles is ILoveRoles, Ownable {\\n  mapping(address user => mapping(string role => bool hasRole)) private users;\\n\\n  event RoleGranted(address indexed account, string role);\\n  event RoleRevoked(address indexed account, string role);\\n\\n  modifier hasRole(string memory role) {\\n    require(users[msg.sender][role] || msg.sender == owner(), 'account doesnt have this role');\\n    _;\\n  }\\n\\n  function grantRole(address account, string calldata role) external onlyOwner {\\n    require(!users[account][role], 'role already granted');\\n    users[account][role] = true;\\n\\n    emit RoleGranted(account, role);\\n  }\\n\\n  function revokeRole(address account, string calldata role) external onlyOwner {\\n    require(users[account][role], 'role already revoked');\\n    users[account][role] = false;\\n\\n    emit RoleRevoked(account, role);\\n  }\\n\\n  function checkRole(address accountToCheck, string calldata role) external view returns (bool) {\\n    return users[accountToCheck][role];\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/TokenIdentifiers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\\n\\n/*\\n    DESIGN NOTES:\\n    Token ids are a concatenation of:\\n   * creator: hex address of the creator of the token. 160 bits\\n   * index: Index for this token (the regular ID), up to 2^56 - 1. 56 bits\\n   * collection: Virtual collection id for this token, up to 2^40 - 1 (1 trillion).  40 bits\\n\\n  */\\n/**\\n * @title TokenIdentifiers\\n * support for authentication and metadata for token ids\\n */\\n\\nlibrary TokenIdentifiers {\\n  uint56 private constant MAX_INDEX = 0xFFFFFFFFFFFFFF;\\n  uint40 private constant MAX_COLLECTION = 0xFFFFFFFFFF;\\n\\n  // Function to create a token ID based on creator, index, and supply\\n  function createTokenId(address creator, uint256 index, uint256 collection) internal pure returns (uint256) {\\n    // Concatenate the values into a single uint256 token ID\\n    uint256 tokenID = (uint256(uint160(creator)) << 96) | (uint256(index) << 40) | uint256(collection);\\n    return tokenID;\\n  }\\n\\n  function tokenCreator(uint256 _id) internal pure returns (address) {\\n    return address(uint160(_id >> 96));\\n  }\\n\\n  function tokenIndex(uint256 _id) internal pure returns (uint56) {\\n    return uint56((_id >> 40) & MAX_INDEX);\\n  }\\n\\n  function tokenCollection(uint256 _id) internal pure returns (uint40) {\\n    return uint40(_id & MAX_COLLECTION);\\n  }\\n\\n  // Function to extract creator, index, and supply from a token ID\\n  function decodeTokenId(uint256 _id) internal pure returns (address creator, uint56 index, uint40 collection) {\\n    creator = tokenCreator(_id);\\n    index = tokenIndex(_id);\\n    collection = tokenCollection(_id);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/LoveMarketplace.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.18;\\n\\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\nimport {ReentrancyGuard} from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {IERC1155} from '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\nimport {ERC1155Holder} from '@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol';\\nimport {IERC2981} from '@openzeppelin/contracts/interfaces/IERC2981.sol';\\nimport {IERC165} from '@openzeppelin/contracts/utils/introspection/IERC165.sol';\\nimport {ILoveNFTMarketplace} from './interfaces/ILoveNFTMarketplace.sol';\\nimport {ILoveNFTShared} from './interfaces/ILoveNFTShared.sol';\\nimport {LoveRoles} from './lib/LoveRoles.sol';\\nimport {TokenIdentifiers} from './lib/TokenIdentifiers.sol';\\n\\n/* Love NFT Marketplace\\n    List NFT,\\n    Buy NFT,\\n    Offer NFT,\\n    Accept offer,\\n    Create auction,\\n    Bid place,\\n    & support Royalty\\n*/\\ncontract LoveNFTMarketplace is ILoveNFTMarketplace, LoveRoles, ERC1155Holder, ReentrancyGuard {\\n  using TokenIdentifiers for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  uint256 public platformFee = 50;\\n  uint256 public constant LISTING_FEE = 1 ether;\\n  uint256 public constant MINIMUM_BUYING_FEE = 5 ether;\\n  uint256 public reservedBalance;\\n  address public feeReceiver;\\n  ILoveNFTShared private immutable loveNFTShared;\\n  IERC20 private immutable loveToken;\\n\\n  constructor(address _loveToken, address _loveNFTShared, address tokenOwner) {\\n    transferOwnership(tokenOwner);\\n    loveToken = IERC20(_loveToken);\\n    loveNFTShared = ILoveNFTShared(_loveNFTShared);\\n  }\\n\\n  // NFT => list struct\\n  mapping(bytes32 encodedNft => ListNFT listingStruct) private listNfts;\\n\\n  // NFT => offerer address => offer price => offer struct\\n  mapping(bytes32 encodedNft => mapping(address offerer => mapping(uint256 price => OfferNFT offerStruct)))\\n    private offerNfts;\\n\\n  // NFT => action struct\\n  mapping(bytes32 encodedNft => AuctionNFT auctionStruct) private auctionNfts;\\n\\n  modifier onlyListedNFT(NFT calldata nft) {\\n    ListNFT memory listedNFT = listNfts[encodeNft(nft)];\\n    require(\\n      listedNFT.seller != address(0) && listedNFT.price > 0 && block.timestamp <= listedNFT.endTime,\\n      'not listed'\\n    );\\n    _;\\n  }\\n\\n  modifier onAuction(NFT calldata nft) {\\n    NFT memory auctionNft = auctionNfts[encodeNft(nft)].nft;\\n    require(auctionNft.addr == nft.addr && auctionNft.tokenId == nft.tokenId, 'auction is not created');\\n    _;\\n  }\\n\\n  modifier notOnAuction(NFT calldata nft) {\\n    AuctionNFT memory auction = auctionNfts[encodeNft(nft)];\\n    require(auction.nft.addr == address(0) || auction.success, 'auction already created');\\n    _;\\n  }\\n\\n  modifier onlyOfferedNFT(OfferNFTParams calldata params) {\\n    OfferNFT memory offer = offerNfts[encodeNft(params.nft)][params.offerer][params.price];\\n    require(offer.offerer == params.offerer && offer.offerPrice == params.price, 'not offered');\\n    require(!offer.accepted, 'already accepted');\\n    _;\\n  }\\n\\n  modifier minimumPrice(uint256 price) {\\n    require(price > MINIMUM_BUYING_FEE, 'price is less than the minimum commission');\\n    _;\\n  }\\n\\n  /**\\n   * @notice List NFT on Marketplace\\n   * @param params The listing parameters (nft, tokenId, price, startTime, endTime)\\n   */\\n  function listNft(ListingParams calldata params) external minimumPrice(params.price) returns (uint256) {\\n    require(block.timestamp <= params.startTime && params.endTime > params.startTime, 'invalid time range');\\n\\n    bytes32 encodedNft = encodeNft(params.nft);\\n    ListNFT memory listedNFT = listNfts[encodedNft];\\n    TokenType tokenType = _getTokenType(params.nft.addr);\\n    // If the NFT is already listed, the seller must be the same as the caller.\\n    if (listedNFT.seller != address(0)) {\\n      require(listedNFT.seller == msg.sender, 'not seller');\\n    } else {\\n      // Otherwise, the caller must be the owner of the NFT.\\n      _verifyOwnershipAndApproval(msg.sender, params.nft, tokenType);\\n      // The caller must have enough tokens for the platform fee.\\n      require(loveToken.balanceOf(msg.sender) >= LISTING_FEE, 'no tokens for platform fee');\\n      // The caller must transfer the NFT to the marketplace contract.\\n      _transferNFT(msg.sender, address(this), params.nft, tokenType);\\n      // The caller must transfer the platform fee to the marketplace contract.\\n      loveToken.safeTransferFrom(msg.sender, address(this), LISTING_FEE);\\n    }\\n\\n    // Update the listing.\\n    listNfts[encodedNft] = ListNFT({\\n      nft: params.nft,\\n      tokenType: tokenType,\\n      price: params.price,\\n      seller: msg.sender,\\n      startTime: params.startTime,\\n      endTime: params.endTime\\n    });\\n    emit ListedNFT(params.nft.addr, params.nft.tokenId, params.price, msg.sender, params.startTime, params.endTime);\\n    return LISTING_FEE;\\n  }\\n\\n  function getListedNFT(NFT calldata nft) external view returns (ListNFT memory) {\\n    return listNfts[encodeNft(nft)];\\n  }\\n\\n  /**\\n   * @notice Cancel listed NFT\\n   * @param nft NFT address\\n   */\\n  function cancelListedNFT(NFT calldata nft) external onlyListedNFT(nft) {\\n    bytes32 encodedNft = encodeNft(nft);\\n    ListNFT memory listedNFT = listNfts[encodedNft];\\n    // Ensure the sender is the seller\\n    require(listedNFT.seller == msg.sender, 'not seller');\\n\\n    delete listNfts[encodedNft];\\n    // Transfer the NFT back to the seller\\n    _transferNFT(address(this), msg.sender, nft, listedNFT.tokenType);\\n\\n    emit CanceledListedNFT(\\n      listedNFT.nft.addr,\\n      listedNFT.nft.tokenId,\\n      listedNFT.price,\\n      listedNFT.seller,\\n      listedNFT.startTime,\\n      listedNFT.endTime\\n    );\\n  }\\n\\n  function buyLazyListedNFT(\\n    ILoveNFTShared.MintRequest calldata params,\\n    bytes calldata signature\\n  ) external returns (uint256 priceWithRoyalty) {\\n    address creator = params.tokenId.tokenCreator();\\n\\n    // calculate platform fee\\n    (uint256 amount, ) = calculateFeeAndAmount(params.price);\\n    // calculate royalty fee\\n\\n    uint256 royaltyAmount = (params.price * params.royaltyFraction) / loveNFTShared.feeDenominator();\\n\\n    TokenRoyaltyInfo memory royaltyInfo = TokenRoyaltyInfo(params.royaltyRecipient, royaltyAmount);\\n\\n    loveToken.safeTransferFrom(msg.sender, address(this), params.price + royaltyInfo.royaltyAmount);\\n\\n    if (royaltyInfo.royaltyReceiver == creator) {\\n      uint256 amountWithRoyalty = amount + royaltyInfo.royaltyAmount;\\n      loveToken.safeTransfer(creator, amountWithRoyalty);\\n    } else {\\n      _transferRoyalty(royaltyInfo, address(this));\\n      loveToken.safeTransfer(creator, amount);\\n    }\\n\\n    // mint nft\\n    loveNFTShared.redeem(msg.sender, params, signature);\\n\\n    emit BoughtNFT(address(loveNFTShared), params.tokenId, params.price, creator, msg.sender);\\n\\n    return royaltyInfo.royaltyAmount + params.price;\\n  }\\n\\n  /**\\n   * @notice Buy NFT on Marketplace\\n   * @param nft NFT address\\n   * @param price listed price\\n   * @return priceWithRoyalty price with fees\\n   */\\n  function buyNFT(NFT calldata nft, uint256 price) external onlyListedNFT(nft) returns (uint256 priceWithRoyalty) {\\n    bytes32 encodedNft = encodeNft(nft);\\n    ListNFT memory listedNft = listNfts[encodedNft];\\n    require(price >= listedNft.price, 'less than listed price');\\n\\n    delete listNfts[encodedNft];\\n    TokenRoyaltyInfo memory royaltyInfo = _tryGetRoyaltyInfo(nft, price);\\n    _transferRoyalty(royaltyInfo, msg.sender);\\n    // remove nft from listing\\n    (uint256 amount, uint256 buyingFee) = calculateFeeAndAmount(price);\\n    // transfer platform fee to marketplace contract\\n    loveToken.safeTransferFrom(msg.sender, address(this), buyingFee);\\n\\n    // Transfer payment to nft owner\\n    loveToken.safeTransferFrom(msg.sender, listedNft.seller, amount);\\n\\n    // Transfer NFT to buyer\\n    _transferNFT(address(this), msg.sender, nft, listedNft.tokenType);\\n\\n    emit BoughtNFT(nft.addr, nft.tokenId, price, listedNft.seller, msg.sender);\\n    return price + royaltyInfo.royaltyAmount;\\n  }\\n\\n  /**\\n   * @notice Offer NFT on Marketplace\\n   * @param params OfferNFTParams\\n   * @return offerPriceWithRoyalty offer price with royalty\\n   */\\n  function offerNFT(\\n    OfferNFTParams calldata params\\n  ) external notOnAuction(params.nft) minimumPrice(params.price) returns (uint256) {\\n    // nft should be minted\\n    TokenType tokenType = _getTokenType(params.nft.addr);\\n    if (tokenType == TokenType.ERC721) {\\n      require(IERC721(params.nft.addr).ownerOf(params.nft.tokenId) != address(0), 'not exist');\\n    } else if (params.nft.addr == address(loveNFTShared)) {\\n      require(loveNFTShared.exists(params.nft.tokenId), 'not exist');\\n    }\\n\\n    TokenRoyaltyInfo memory royaltyInfo = _tryGetRoyaltyInfo(params.nft, params.price);\\n    uint256 offerPriceWithRoyalty = params.price + royaltyInfo.royaltyAmount;\\n\\n    reservedBalance += offerPriceWithRoyalty;\\n\\n    loveToken.safeTransferFrom(msg.sender, address(this), offerPriceWithRoyalty);\\n\\n    offerNfts[encodeNft(params.nft)][msg.sender][params.price] = OfferNFT({\\n      nft: params.nft,\\n      tokenType: tokenType,\\n      offerer: msg.sender,\\n      offerPrice: params.price,\\n      accepted: false,\\n      royaltyInfo: royaltyInfo\\n    });\\n\\n    emit OfferedNFT(params.nft.addr, params.nft.tokenId, params.price, msg.sender);\\n    return offerPriceWithRoyalty;\\n  }\\n\\n  /**\\n   * @notice Cancel offer\\n   * @param params The offer parameters (nft, tokenId, offerer, price)\\n   * @return offerPriceWithRoyalty offer price with royalty\\n   */\\n  function cancelOfferNFT(OfferNFTParams calldata params) external onlyOfferedNFT(params) returns (uint256) {\\n    require(params.offerer == msg.sender, 'not offerer');\\n\\n    bytes32 encodedNft = encodeNft(params.nft);\\n    OfferNFT memory offer = offerNfts[encodedNft][params.offerer][params.price];\\n    delete offerNfts[encodedNft][params.offerer][params.price];\\n\\n    uint256 offerPriceWithRoyalty = offer.offerPrice + offer.royaltyInfo.royaltyAmount;\\n    reservedBalance -= offerPriceWithRoyalty;\\n\\n    loveToken.safeTransfer(offer.offerer, offerPriceWithRoyalty);\\n\\n    emit CanceledOfferedNFT(offer.nft.addr, offer.nft.tokenId, offer.offerPrice, params.offerer);\\n    return offerPriceWithRoyalty;\\n  }\\n\\n  /**\\n   * @notice Accept offer\\n   * @param params The offer parameters (nft, tokenId, offerer, price)\\n   * @return amount amount transfer to seller\\n   */\\n  function acceptOfferNFT(\\n    OfferNFTParams calldata params\\n  ) external onlyOfferedNFT(params) nonReentrant returns (uint256) {\\n    bytes32 encodedNft = encodeNft(params.nft);\\n    OfferNFT storage offer = offerNfts[encodedNft][params.offerer][params.price];\\n    ListNFT memory list = listNfts[encodedNft];\\n    address from = address(this);\\n    // If the NFT is listed, the seller is the owner of the NFT\\n    if (list.seller != address(0)) {\\n      require(msg.sender == list.seller, 'not listed owner');\\n      delete listNfts[encodedNft];\\n    } else {\\n      // If not, the seller is the owner of the NFT\\n      _verifyOwnershipAndApproval(msg.sender, params.nft, offer.tokenType);\\n      from = msg.sender;\\n    }\\n\\n    TokenRoyaltyInfo memory royaltyInfo = offer.royaltyInfo;\\n    uint256 offerPriceWithRoyalty = params.price + royaltyInfo.royaltyAmount;\\n\\n    // Release reserved balance\\n    reservedBalance -= offerPriceWithRoyalty;\\n    offer.accepted = true;\\n\\n    // Calculate & Transfer platform fee\\n    (uint256 amount, ) = calculateFeeAndAmount(params.price);\\n\\n    if (royaltyInfo.royaltyReceiver == msg.sender) {\\n      uint256 amountWithRoyalty = amount + royaltyInfo.royaltyAmount;\\n      loveToken.safeTransfer(msg.sender, amountWithRoyalty);\\n    } else {\\n      _transferRoyalty(royaltyInfo, address(this));\\n      loveToken.safeTransfer(msg.sender, amount);\\n    }\\n\\n    // Transfer NFT to offerer\\n    _transferNFT(from, params.offerer, params.nft, offer.tokenType);\\n\\n    emit AcceptedNFT(params.nft.addr, params.nft.tokenId, params.price, params.offerer, msg.sender);\\n    return amount;\\n  }\\n\\n  /**\\n   * @notice Create auction for NFT\\n   * @dev This function allows users to create an auction for an NFT\\n   * @param params The auction parameters (nft, tokenId, initialPrice, minBidStep, startTime, endTime)\\n   */\\n  function createAuction(\\n    AuctionParams calldata params\\n  ) external notOnAuction(params.nft) minimumPrice(params.initialPrice) {\\n    TokenType tokenType = _getTokenType(params.nft.addr);\\n    // Verify if the caller is the owner of the NFT\\n    _verifyOwnershipAndApproval(msg.sender, params.nft, tokenType);\\n\\n    require(loveToken.balanceOf(msg.sender) >= LISTING_FEE, 'no tokens for platform fee');\\n    // The caller must transfer the platform fee to the marketplace contract.\\n    loveToken.safeTransferFrom(msg.sender, address(this), LISTING_FEE);\\n    // Transfer the NFT from the caller to the contract\\n    _transferNFT(msg.sender, address(this), params.nft, tokenType);\\n\\n    // Store the auction details in the auctionNfts mapping\\n    auctionNfts[encodeNft(params.nft)] = AuctionNFT({\\n      nft: params.nft,\\n      tokenType: tokenType,\\n      creator: msg.sender,\\n      initialPrice: params.initialPrice,\\n      minBidStep: params.minBidStep,\\n      startTime: params.startTime,\\n      endTime: params.endTime,\\n      lastBidder: address(0),\\n      highestBid: params.initialPrice,\\n      royaltyInfo: TokenRoyaltyInfo(address(0), 0),\\n      winner: address(0),\\n      success: false\\n    });\\n\\n    emit CreatedAuction(\\n      params.nft.addr,\\n      params.nft.tokenId,\\n      params.initialPrice,\\n      params.minBidStep,\\n      params.startTime,\\n      params.endTime,\\n      msg.sender\\n    );\\n  }\\n\\n  /**\\n   * @notice Cancel auction\\n   * @param nft NFT address\\n   */\\n  function cancelAuction(NFT calldata nft) external onAuction(nft) {\\n    bytes32 encodedNft = encodeNft(nft);\\n    AuctionNFT memory auction = auctionNfts[encodedNft];\\n    require(auction.creator == msg.sender, 'not auction creator');\\n    require(!auction.success, 'auction already success');\\n    require(auction.lastBidder == address(0), 'already have bidder');\\n\\n    delete auctionNfts[encodedNft];\\n\\n    _transferNFT(address(this), msg.sender, nft, auction.tokenType);\\n\\n    emit CanceledAuction(nft.addr, nft.tokenId);\\n  }\\n\\n  /**\\n   * @notice Place bid on auction\\n   * @param nft NFT address\\n   * @param bidPrice bid price (must be greater than highest bid + min bid step)\\n   * @return bidPriceWithRoyalty bid price with royalty\\n   */\\n  function bidPlace(NFT calldata nft, uint256 bidPrice) external onAuction(nft) nonReentrant returns (uint256) {\\n    AuctionNFT storage auction = auctionNfts[encodeNft(nft)];\\n    require(block.timestamp >= auction.startTime, 'auction not started');\\n    require(block.timestamp <= auction.endTime, 'auction ended');\\n    require(bidPrice >= auction.highestBid + auction.minBidStep, 'less than min bid price');\\n\\n    TokenRoyaltyInfo memory royaltyInfo = _tryGetRoyaltyInfo(nft, bidPrice);\\n    uint256 lastBidPriceWithRoyalty = 0;\\n    uint256 bidPriceWithRoyalty = bidPrice + royaltyInfo.royaltyAmount;\\n\\n    if (auction.lastBidder != address(0)) {\\n      address lastBidder = auction.lastBidder;\\n      uint256 lastBidPrice = auction.highestBid;\\n      // Transfer back to last bidder\\n      lastBidPriceWithRoyalty = lastBidPrice + auction.royaltyInfo.royaltyAmount;\\n      loveToken.safeTransfer(lastBidder, lastBidPriceWithRoyalty);\\n    }\\n\\n    reservedBalance += bidPriceWithRoyalty - lastBidPriceWithRoyalty;\\n    // Set new highest bid price & bidder\\n    auction.lastBidder = msg.sender;\\n    auction.highestBid = bidPrice;\\n    auction.royaltyInfo = royaltyInfo;\\n\\n    loveToken.safeTransferFrom(msg.sender, address(this), bidPriceWithRoyalty);\\n\\n    emit PlacedBid(nft.addr, nft.tokenId, bidPrice, msg.sender);\\n    return bidPriceWithRoyalty;\\n  }\\n\\n  /**\\n   * @notice Result auctions\\n   * @param nft NFT\\n   */\\n  function resultAuction(NFT calldata nft) external returns (uint256) {\\n    uint256 amount = _resultAuction(nft);\\n    reservedBalance -= amount;\\n    return amount;\\n  }\\n\\n  /**\\n   * @notice Result multiple auctions\\n   * @param nfts NFT (nftAddres, tokenId)\\n   */\\n  function resultAuctions(NFT[] calldata nfts) external returns (uint256) {\\n    uint256 totalAmount = 0;\\n\\n    for (uint256 i = 0; i < nfts.length; ++i) {\\n      // Result each auction and accumulate the amount transferred to the auction creator\\n      uint256 amount = _resultAuction(nfts[i]);\\n      totalAmount += amount;\\n    }\\n    reservedBalance -= totalAmount;\\n    return totalAmount;\\n  }\\n\\n  /**\\n   * @notice Get auction info by NFT address and token id\\n   * @param nft NFT address\\n   * @return AuctionNFT struct\\n   */\\n  function getAuction(NFT calldata nft) external view returns (AuctionNFT memory) {\\n    return auctionNfts[encodeNft(nft)];\\n  }\\n\\n  /**\\n   * @notice Transfer fee to fee receiver contract\\n   * @dev should set feeReceiver (updateFeeReceiver()) address before call this function\\n   * @param amount Fee amount\\n   */\\n  function transferFee(uint256 amount) external hasRole('admin') {\\n    require(feeReceiver != address(0), 'invalid feeReceiver address');\\n    require(getAvailableBalance() >= amount, 'insufficient balance (reserved)');\\n    loveToken.safeTransfer(feeReceiver, amount);\\n  }\\n\\n  /**\\n   * @notice Set platform fee\\n   * @param newPlatformFee new platform fee\\n   */\\n  function setPlatformFee(uint256 newPlatformFee) external onlyOwner {\\n    platformFee = newPlatformFee;\\n    emit ChangedPlatformFee(newPlatformFee);\\n  }\\n\\n  /**\\n   * @notice Set platform fee contract (LoveDrop)\\n   * @param newFeeReceiver new fee receiver address\\n   */\\n  function updateFeeReceiver(address newFeeReceiver) external onlyOwner {\\n    require(newFeeReceiver != address(0), 'invalid address');\\n    feeReceiver = newFeeReceiver;\\n\\n    emit ChangedFeeReceiver(newFeeReceiver);\\n  }\\n\\n  /**\\n   * @notice Calculate fee and amount\\n   * @param price price\\n   * @return amount amount transfer to seller\\n   * @return fee fee transfer to marketplace contract\\n   */\\n  function calculateFeeAndAmount(uint256 price) public view returns (uint256 amount, uint256 fee) {\\n    uint256 fee1e27 = (price * platformFee * 1e27) / 100;\\n    fee = fee1e27 / 1e27;\\n    if (fee < MINIMUM_BUYING_FEE) {\\n      fee = MINIMUM_BUYING_FEE;\\n    }\\n    return (price - fee, fee);\\n  }\\n\\n  /**\\n   * @notice Get available balance\\n   * @return availableBalance available balance (not reserved)\\n   */\\n  function getAvailableBalance() public view returns (uint256 availableBalance) {\\n    return loveToken.balanceOf(address(this)) - reservedBalance;\\n  }\\n\\n  function _resultAuction(NFT calldata nft) internal onAuction(nft) returns (uint256) {\\n    AuctionNFT storage auction = auctionNfts[encodeNft(nft)];\\n    require(!auction.success, 'already resulted');\\n    require(block.timestamp > auction.endTime, 'auction not ended');\\n    address creator = auction.creator;\\n    address winner = auction.lastBidder;\\n    uint256 highestBid = auction.highestBid;\\n    TokenType tokenType = auction.tokenType;\\n    if (winner == address(0)) {\\n      // If no one bid, transfer NFT back to creator\\n      delete auctionNfts[encodeNft(nft)];\\n      _transferNFT(address(this), creator, nft, tokenType);\\n      emit CanceledAuction(nft.addr, nft.tokenId);\\n      return 0;\\n    }\\n\\n    auction.success = true;\\n    auction.winner = winner;\\n    TokenRoyaltyInfo memory royaltyInfo = auction.royaltyInfo;\\n    // Calculate royalty fee and transfer to recipient\\n    _transferRoyalty(royaltyInfo, address(this));\\n\\n    // Calculate platform fee\\n    (uint256 amount, ) = calculateFeeAndAmount(highestBid);\\n\\n    // Transfer to auction creator\\n    loveToken.safeTransfer(creator, amount);\\n    // Transfer NFT to the winner\\n    _transferNFT(address(this), winner, nft, auction.tokenType);\\n\\n    emit ResultedAuction(nft.addr, nft.tokenId, creator, winner, highestBid, msg.sender);\\n    return highestBid + royaltyInfo.royaltyAmount;\\n  }\\n\\n  function rescueTokens(NFT calldata nft, address receiver) external onlyOwner {\\n    bool isAuction = auctionNfts[encodeNft(nft)].creator != address(0);\\n    bool isListed = listNfts[encodeNft(nft)].seller != address(0);\\n    require(!isListed, 'nft is on sale');\\n    require(!isAuction, 'nft is on auction');\\n    TokenType tokenType = _getTokenType(nft.addr);\\n    _transferNFT(address(this), receiver, nft, tokenType);\\n  }\\n\\n  function _tryGetRoyaltyInfo(\\n    NFT memory nft,\\n    uint256 price\\n  ) internal view returns (TokenRoyaltyInfo memory royaltyInfo) {\\n    if (IERC2981(nft.addr).supportsInterface(type(IERC2981).interfaceId)) {\\n      (address royaltyRecipient, uint256 amount) = IERC2981(nft.addr).royaltyInfo(nft.tokenId, price);\\n      if (amount > price / 5) amount = price / 5;\\n      royaltyInfo = TokenRoyaltyInfo(royaltyRecipient, amount);\\n    }\\n    return royaltyInfo;\\n  }\\n\\n  function _transferRoyalty(TokenRoyaltyInfo memory royaltyInfo, address from) internal {\\n    if (royaltyInfo.royaltyReceiver != address(0) && royaltyInfo.royaltyAmount > 0) {\\n      if (from == address(this)) {\\n        loveToken.safeTransfer(royaltyInfo.royaltyReceiver, royaltyInfo.royaltyAmount);\\n      } else {\\n        loveToken.safeTransferFrom(from, royaltyInfo.royaltyReceiver, royaltyInfo.royaltyAmount);\\n      }\\n    }\\n  }\\n\\n  function _getTokenType(address nftAddress) internal view returns (TokenType tokenType) {\\n    if (IERC165(nftAddress).supportsInterface(type(IERC1155).interfaceId)) {\\n      return TokenType.ERC1155;\\n    } else if (IERC165(nftAddress).supportsInterface(type(IERC721).interfaceId)) {\\n      return TokenType.ERC721;\\n    } else {\\n      revert('Invalid NFT type');\\n    }\\n  }\\n\\n  function _verifyOwnershipAndApproval(address claimant, NFT memory nft, TokenType tokenType) internal view {\\n    bool isValid = false;\\n    if (tokenType == TokenType.ERC1155) {\\n      isValid =\\n        IERC1155(nft.addr).balanceOf(claimant, nft.tokenId) >= 1 &&\\n        IERC1155(nft.addr).isApprovedForAll(claimant, address(this));\\n    } else if (tokenType == TokenType.ERC721) {\\n      isValid =\\n        IERC721(nft.addr).ownerOf(nft.tokenId) == claimant &&\\n        (IERC721(nft.addr).getApproved(nft.tokenId) == address(this) ||\\n          IERC721(nft.addr).isApprovedForAll(claimant, address(this)));\\n    }\\n    require(isValid, 'not owner or approved tokens');\\n  }\\n\\n  function _transferNFT(address from, address to, NFT calldata nft, TokenType tokenType) internal {\\n    if (tokenType == TokenType.ERC1155) {\\n      IERC1155(nft.addr).safeTransferFrom(from, to, nft.tokenId, 1, '');\\n    } else if (tokenType == TokenType.ERC721) {\\n      IERC721(nft.addr).transferFrom(from, to, nft.tokenId);\\n    }\\n  }\\n\\n  function encodeNft(NFT calldata nft) internal pure returns (bytes32 encodedNft) {\\n    return keccak256(abi.encodePacked(nft.addr, nft.tokenId));\\n  }\\n\\n  function onERC1155Received(\\n    address,\\n    address,\\n    uint256,\\n    uint256,\\n    bytes memory\\n  ) public virtual override returns (bytes4) {\\n    return this.onERC1155Received.selector;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loveToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_loveNFTShared\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offerPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftOwner\",\"type\":\"address\"}],\"name\":\"AcceptedNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"BoughtNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"CanceledAuction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"CanceledListedNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offerPrice\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"}],\"name\":\"CanceledOfferedNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFeeReceiver\",\"type\":\"address\"}],\"name\":\"ChangedFeeReceiver\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"ChangedPlatformFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minBidStep\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"CreatedAuction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"ListedNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offerPrice\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"}],\"name\":\"OfferedNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bidPrice\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"}],\"name\":\"PlacedBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"ResultedAuction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LISTING_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINIMUM_BUYING_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct ILoveNFTMarketplace.NFT\",\"name\":\"nft\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct ILoveNFTMarketplace.OfferNFTParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"acceptOfferNFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct ILoveNFTMarketplace.NFT\",\"name\":\"nft\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"bidPrice\",\"type\":\"uint256\"}],\"name\":\"bidPlace\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"startTimestamp\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"endTimestamp\",\"type\":\"uint128\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"royaltyRecipient\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"royaltyFraction\",\"type\":\"uint96\"},{\"internalType\":\"bytes32\",\"name\":\"uid\",\"type\":\"bytes32\"}],\"internalType\":\"struct ILoveNFTShared.MintRequest\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"buyLazyListedNFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"priceWithRoyalty\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct ILoveNFTMarketplace.NFT\",\"name\":\"nft\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"buyNFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"priceWithRoyalty\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"calculateFeeAndAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct ILoveNFTMarketplace.NFT\",\"name\":\"nft\",\"type\":\"tuple\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct ILoveNFTMarketplace.NFT\",\"name\":\"nft\",\"type\":\"tuple\"}],\"name\":\"cancelListedNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct ILoveNFTMarketplace.NFT\",\"name\":\"nft\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct ILoveNFTMarketplace.OfferNFTParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"cancelOfferNFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountToCheck\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"role\",\"type\":\"string\"}],\"name\":\"checkRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct ILoveNFTMarketplace.NFT\",\"name\":\"nft\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"initialPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBidStep\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"internalType\":\"struct ILoveNFTMarketplace.AuctionParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"createAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct ILoveNFTMarketplace.NFT\",\"name\":\"nft\",\"type\":\"tuple\"}],\"name\":\"getAuction\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct ILoveNFTMarketplace.NFT\",\"name\":\"nft\",\"type\":\"tuple\"},{\"internalType\":\"enum ILoveNFTMarketplace.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBidStep\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lastBidder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"highestBid\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"royaltyReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct ILoveNFTMarketplace.TokenRoyaltyInfo\",\"name\":\"royaltyInfo\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"internalType\":\"struct ILoveNFTMarketplace.AuctionNFT\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAvailableBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"availableBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct ILoveNFTMarketplace.NFT\",\"name\":\"nft\",\"type\":\"tuple\"}],\"name\":\"getListedNFT\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct ILoveNFTMarketplace.NFT\",\"name\":\"nft\",\"type\":\"tuple\"},{\"internalType\":\"enum ILoveNFTMarketplace.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"internalType\":\"struct ILoveNFTMarketplace.ListNFT\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"role\",\"type\":\"string\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct ILoveNFTMarketplace.NFT\",\"name\":\"nft\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"internalType\":\"struct ILoveNFTMarketplace.ListingParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"listNft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct ILoveNFTMarketplace.NFT\",\"name\":\"nft\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct ILoveNFTMarketplace.OfferNFTParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"offerNFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platformFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct ILoveNFTMarketplace.NFT\",\"name\":\"nft\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"rescueTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reservedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct ILoveNFTMarketplace.NFT\",\"name\":\"nft\",\"type\":\"tuple\"}],\"name\":\"resultAuction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct ILoveNFTMarketplace.NFT[]\",\"name\":\"nfts\",\"type\":\"tuple[]\"}],\"name\":\"resultAuctions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"role\",\"type\":\"string\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPlatformFee\",\"type\":\"uint256\"}],\"name\":\"setPlatformFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFeeReceiver\",\"type\":\"address\"}],\"name\":\"updateFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LoveNFTMarketplace", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000504624040e0642921c2c266a9ac37cafbd8cda4e000000000000000000000000b0a5818c8c2011cce667e56f9d1e512d6ad83d820000000000000000000000000d6f043296c9e950ae5aaf8add002358cd24bd46", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}