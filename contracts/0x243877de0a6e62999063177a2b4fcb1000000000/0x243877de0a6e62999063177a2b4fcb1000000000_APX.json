{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/APX.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/**\\n    Twitter: https://twitter.com/ThisAPXisNOTforyoubotsniper_itisforDEGEN\\n    Telegram: https://t.me/SorryIfAreTrickedBot\\n    Website: https://ThisAPX.isNOTForSniper.ItisforDEGEN.vip\\n\\n    Read carefully my degen friends. DO NOT buy before I drop the tax to 0%\\n    In the first several blocks (~2min) we have a tax on all the bots\\n\\n    Ape in as fast as you can LATER.\\n**/\\n\\npragma solidity ^0.8.15;\\npragma experimental ABIEncoderV2;\\n\\nabstract contract Ownable {\\n    address private _owner;\\n\\n    constructor() {\\n        _owner = msg.sender;\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner() == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        _owner = address(0);\\n    }\\n}\\n\\nlibrary SafeERC20 {\\n    function safeTransfer(address token, address to, uint256 value) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: INTERNAL TRANSFER_FAILED');\\n    }\\n}\\n\\ninterface IERC20 {\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external;\\n}\\n\\ninterface IUniswapV2Factory {\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n}\\n\\ninterface IUniswapV2Router02 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external;\\n\\n    function addLiquidityETH(address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n}\\n\\ncontract APX is Ownable {\\n    string private constant _name = unicode\\\"\ud83c\udd30\ud83c\udd3f\ud83c\udd47\\\";\\n    string private constant _symbol = unicode\\\"\ud83c\udd30\ud83c\udd3f\ud83c\udd47\\\";\\n    uint256 private constant _totalSupply = 65_000_000_000 * 1e18;\\n    uint256 private constant _treasuryLock = 0;\\n\\n    uint256 public maxTransactionAmount = 1_000_000_000 * 1e18;\\n    uint256 public maxWallet = 2_000_000_000 * 1e18;\\n    uint256 public swapTokensAtAmount = (_totalSupply * 5) / 1000;\\n\\n    address private treasuryWallet;\\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; \\n    \\n    uint16 public buyTotalFees = 30;\\n    uint16 public sellTotalFees = 30;\\n\\n    bool private swapping;\\n    bool public limitsInEffect = true;\\n    bool private launched;\\n\\n    mapping(address => uint256) private _balances;\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n    mapping(address => bool) private _isExcludedFromFees;\\n    mapping(address => bool) private _isExcludedMaxTransactionAmount;\\n    mapping(address => bool) private automatedMarketMakerPairs;\\n\\n    event SwapAndLiquify(uint256 TreasuryETH);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    IUniswapV2Router02 public constant uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n    address public immutable uniswapV2Pair;\\n\\n    constructor() {\\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), WETH);\\n        automatedMarketMakerPairs[uniswapV2Pair] = true;\\n\\n        treasuryWallet = msg.sender;\\n\\n        setExcludedFromFees(owner(), true);\\n        setExcludedFromFees(address(this), true);\\n\\n\\n        setExcludedFromFees(treasuryWallet, true);\\n\\n        setExcludedFromMaxTransaction(owner(), true);\\n        setExcludedFromMaxTransaction(address(uniswapV2Router), true);\\n        setExcludedFromMaxTransaction(address(this), true);\\n\\n\\n        setExcludedFromMaxTransaction(address(uniswapV2Pair), true);\\n        setExcludedFromMaxTransaction(treasuryWallet, true);\\n   \\n        _balances[address(this)] = _totalSupply / 10;\\n        emit Transfer(address(0), address(this), _balances[address(this)]);\\n\\n        _approve(address(this), address(uniswapV2Router), type(uint256).max);\\n    }\\n\\n    receive() external payable {}\\n\\n    function name() public pure returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public pure returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public pure returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() public pure returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) external returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) private {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\\n        uint256 currentAllowance = _allowances[sender][msg.sender];\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n            unchecked {\\n                _approve(sender, msg.sender, currentAllowance - amount);\\n            }\\n        }\\n\\n        _transfer(sender, recipient, amount);\\n\\n        return true;\\n    }\\n\\n    function _transfer(address from, address to, uint256 amount) private {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(amount > 0, \\\"Transfer amount must be greater than zero\\\");\\n\\n        if (!launched && (from != owner() && from != address(this) && to != owner())) {\\n            revert(\\\"Trading not enabled\\\");\\n        }\\n\\n        if (limitsInEffect) {\\n            if (from != owner() && to != owner() && to != address(0) && to != address(0xdead) && !swapping) {\\n                if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\\n                    require(amount <= maxTransactionAmount, \\\"Buy transfer amount exceeds the maxTx\\\");\\n                    require(amount + balanceOf(to) <= maxWallet, \\\"Max wallet exceeded\\\");\\n                } else if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\\n                    require(amount <= maxTransactionAmount,\\\"Sell transfer amount exceeds the maxTx\\\");\\n                } else if (!_isExcludedMaxTransactionAmount[to]) {\\n                    require(amount + balanceOf(to) <= maxWallet, \\\"Max wallet exceeded\\\");\\n                }\\n            }\\n        }\\n\\n        bool takeFee = !swapping;\\n\\n        if (_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\\n            takeFee = false;\\n        }\\n\\n        uint256 senderBalance = _balances[from];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n\\n        uint256 fees = 0;\\n        if (takeFee) {\\n            if (automatedMarketMakerPairs[to] && sellTotalFees > 0) {\\n                fees = (amount * sellTotalFees) / 100;\\n            } else if (automatedMarketMakerPairs[from] && buyTotalFees > 0) {\\n                fees = (amount * buyTotalFees) / 100;\\n            }\\n\\n            if (fees > 0) {\\n                unchecked {\\n                    amount = amount - fees;\\n                    _balances[from] -= fees;\\n                    _balances[address(this)] += fees;\\n                }\\n                emit Transfer(from, address(this), fees);\\n            }\\n        }\\n\\n        bool canSwap = balanceOf(address(this)) >= swapTokensAtAmount;\\n\\n        if (canSwap && !swapping && !automatedMarketMakerPairs[from] && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {\\n            swapping = true;\\n            swapBack(amount);\\n            swapping = false;\\n        }\\n\\n        unchecked {\\n            _balances[from] -= amount;\\n            _balances[to] += amount;\\n        }\\n        emit Transfer(from, to, amount);\\n    }\\n\\n    function removeLimits() external onlyOwner {\\n        limitsInEffect = false;\\n    }\\n\\n    function setFees(uint16 _buyTotalFees, uint16 _sellTotalFees) external onlyOwner {\\n        require(_buyTotalFees <= 5, \\\"Buy fees must be less than or equal to 5%\\\");\\n        require(_sellTotalFees <= 5, \\\"Sell fees must be less than or equal to 5%\\\");\\n        buyTotalFees = _buyTotalFees;\\n        sellTotalFees = _sellTotalFees;\\n    }\\n\\n    function setExcludedFromFees(address account, bool excluded) public onlyOwner {\\n        _isExcludedFromFees[account] = excluded;\\n    }\\n\\n    function setExcludedFromMaxTransaction(address account, bool excluded) public onlyOwner {\\n        _isExcludedMaxTransactionAmount[account] = excluded;\\n    }\\n\\n    function AstroPepeMoon() external onlyOwner {\\n        require(!launched, \\\"Pepe Rocket Already launched\\\");\\n        launched = true;\\n    }\\n\\n    function AddLiq() external payable onlyOwner {\\n        require(!launched, \\\"Already launched\\\");\\n        uniswapV2Router.addLiquidityETH{value: msg.value}(\\n            address(this),\\n            _balances[address(this)],\\n            0,\\n            0,\\n            owner(),\\n            block.timestamp\\n        );\\n    }\\n\\n    function setAutomatedMarketMakerPair(address pair, bool value) external onlyOwner {\\n        require(pair != uniswapV2Pair, \\\"The pair cannot be removed\\\");\\n        automatedMarketMakerPairs[pair] = value;\\n    }\\n\\n    function setSwapAtAmount(uint256 newSwapAmount) external onlyOwner {\\n        require(newSwapAmount >= (totalSupply() * 1) / 100000, \\\"Swap amount cannot be lower than 0.001% of the supply\\\");\\n        require(newSwapAmount <= (totalSupply() * 5) / 1000, \\\"Swap amount cannot be higher than 0.5% of the supply\\\");\\n        swapTokensAtAmount = newSwapAmount;\\n    }\\n\\n    function setMaxTxnAmount(uint256 newMaxTx) external onlyOwner {\\n        require(newMaxTx >= ((totalSupply() * 1) / 50) / 1e18, \\\"Cannot set max transaction lower than 2%\\\");\\n        maxTransactionAmount = newMaxTx * (10**18);\\n    }\\n\\n    function setMaxWalletAmount(uint256 newMaxWallet) external onlyOwner {\\n        require(newMaxWallet >= ((totalSupply() * 1) / 50) / 1e18, \\\"Cannot set max wallet lower than 2%\\\");\\n        maxWallet = newMaxWallet * (10**18);\\n    }\\n\\n    function updateTreasuryWallet(address newAddress) external onlyOwner {\\n        require(newAddress != address(0), \\\"Address cannot be zero\\\");\\n        treasuryWallet = newAddress;\\n        setExcludedFromFees(treasuryWallet, true);\\n        setExcludedFromMaxTransaction(treasuryWallet, true);\\n    }\\n\\n    function excludedFromFee(address account) public view returns (bool) {\\n        return _isExcludedFromFees[account];\\n    }\\n\\n    function withdrawStuckToken(address token, address to) external onlyOwner {\\n        uint256 _contractBalance = IERC20(token).balanceOf(address(this));\\n        SafeERC20.safeTransfer(token, to, _contractBalance); // Use safeTransfer\\n    }\\n\\n    function withdrawStuckETH(address addr) external onlyOwner {\\n        require(addr != address(0), \\\"Invalid address\\\");\\n\\n        (bool success, ) = addr.call{value: address(this).balance}(\\\"\\\");\\n        require(success, \\\"Withdrawal failed\\\");\\n    }\\n\\n    function min(uint256 a, uint256 b) private pure returns (uint256){\\n      return (a > b) ? b : a;\\n    }\\n\\n    function swapBack(uint256 amount) private {\\n        uint256 swapThreshold = min(swapTokensAtAmount, 2 * amount);\\n        // uint256 swapThreshold = swapTokensAtAmount;\\n\\n        bool success;\\n    \\n        if (balanceOf(address(this)) > swapTokensAtAmount * 10) {\\n            swapThreshold = swapTokensAtAmount * 5;\\n        }\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = WETH;\\n\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(swapThreshold, 0, path, address(this), block.timestamp);\\n\\n        uint256 ethBalance = address(this).balance;\\n        if (ethBalance > 0) {\\n            (success, ) = address(treasuryWallet).call{value: ethBalance}(\\\"\\\");\\n        }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"TreasuryETH\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AddLiq\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AstroPepeMoon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTotalFees\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitsInEffect\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransactionAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTotalFees\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"setExcludedFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"setExcludedFromMaxTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_buyTotalFees\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_sellTotalFees\",\"type\":\"uint16\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxTx\",\"type\":\"uint256\"}],\"name\":\"setMaxTxnAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxWallet\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newSwapAmount\",\"type\":\"uint256\"}],\"name\":\"setSwapAtAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateTreasuryWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"withdrawStuckETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawStuckToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "APX", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}