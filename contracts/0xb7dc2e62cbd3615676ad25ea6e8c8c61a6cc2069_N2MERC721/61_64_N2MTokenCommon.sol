/** ---------------------------------------------------------------------------- //
 *                                                                               //
 *                                       .:::.                                   //
 *                                    .:::::::.                                  //
 *                                    ::::::::.                                  //
 *                                 .:::::::::.                                   //
 *                             ..:::.              ..                            //
 *                          .::::.                 ::::..                        //
 *                      ..:::..                    ::::::::.                     //
 *                   .::::.                        :::.  ..:::.                  //
 *               ..:::..                           :::.      .:::.               //
 *            .::::.                               :::.         .:::..           //
 *         .:::..               ..                 :::.            .::::.        //
 *     .::::.               ..:::=-                ::::               ..:::.     //
 *    :::.               .:::::::===:              ::::::.               .::::   //
 *   .::.            .:::::::::::=====.            ::::::::::.             .::.  //
 *   .::         .:::::::::::::::=======.          :::::::::::::..          ::.  //
 *   .::        .::::::::::::::::========-         :::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::==========:       :::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::============:     :::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::==============.   :::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::===============-. :::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::=================::::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::==================-::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::==================-::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::==================-::::::::::::::::        ::.  //
 *   .::        .:::::::::::::::::=================-::::::::::::::::        ::.  //
 *   .::        .:::::::::::::::: .-===============-::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::   .==============-::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::     :============-::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::       :==========-::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::        .-========-::::::::::::::::        ::.  //
 *   .::          .::::::::::::::          .=======-::::::::::::::.         ::.  //
 *   .::.             .::::::::::            .=====-::::::::::..            ::.  //
 *    :::..              ..::::::              :===-::::::..              .:::.  //
 *      .:::..               .:::                -=-:::.               .::::.    //
 *         .::::.            .:::                 ..                .::::.       //
 *            .::::.         .:::                               ..:::.           //
 *                .:::.      .:::                            .::::.              //
 *                   .:::..  .:::                        ..:::..                 //
 *                      .::::.:::                     .::::.                     //
 *                         ..::::                 ..:::..                        //
 *                             .:              .::::.                            //
 *                                     :::::.::::.                               //
 *                                    ::::::::.                                  //
 *                                    :::::::.                                   //
 *                                     .::::.                                    //
 *                                                                               //
 *                                                                               //
 *   Smart contract generated by https://nfts2me.com                             //
 *                                                                               //
 *   NFTs2Me. Make an NFT Collection.                                            //
 *   With ZERO Coding Skills.                                                    //
 *                                                                               //
 *   NFTs2Me is not associated or affiliated with this project.                  //
 *   NFTs2Me is not liable for any bugs or issues associated with this contract. //
 *   NFTs2Me Terms of Service: https://nfts2me.com/terms-of-service/             //
 * ----------------------------------------------------------------------------- */

/// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721VotesUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/interfaces/IERC2981Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol";

/// Utils
import "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@nfts2me/contracts/interfaces/IN2MCrossFactory.sol";
import "@nfts2me/contracts/interfaces/IN2M_ERCBase.sol";
import "./N2MCommonStorage.sol";

interface IN2MLibrary {
    function tokenURIImpl(uint256 tokenId) external view returns (string memory);
}

/// @title NFTs2Me.com Smart Contracts
/// @author The NFTs2Me Team
/// @notice Read our terms of service
/// @custom:security-contact [emailÂ protected]
/// @custom:terms-of-service https://nfts2me.com/terms-of-service/
/// @custom:website https://nfts2me.com/
abstract contract N2MTokenCommon is N2MCommonStorage, IN2M_ERCBase {
    /// IMMUTABLE
    address internal immutable LIBRARY_ADDRESS;

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor(address libraryAddress, address payable factoryAddress) N2MCommonStorage(factoryAddress) {
        LIBRARY_ADDRESS = libraryAddress;
    }

    function _mint(address to, uint256 tokenId) internal virtual;

    function _exists(uint256 tokenId) internal view virtual returns (bool);

    function name() external view virtual override returns (string memory);

    function tokenURI(uint256 tokenId) external view virtual override returns (string memory);

    function balanceOf(address owner) public view virtual returns (uint256 balance);    

    /// @notice Mints one NFT to the caller (msg.sender). Requires `minting type` to be `sequential` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    function mint() external payable override {
        _requirePayment(_mintPrice, 1);
        _checkPhase();
        if (_mintingType != MintingType.SEQUENTIAL) revert InvalidMintingType();
        unchecked {
            if ((++_soldTokens) > _collectionSize) revert CollectionSoldOut();
        }
        _mint(msg.sender, _soldTokens);
    }

    /// @notice Mints `amount` NFTs to the caller (msg.sender). Requires `minting type` to be `sequential` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    /// @param amount The number of NFTs to mint
    function mint(uint256 amount) external payable override {
        _requirePayment(_mintPrice, amount);
        _mintSequentialWithChecks(msg.sender, amount);
    }

    /// @notice Mints `amount` NFTs to the caller (msg.sender) with a given `affiliate`. Requires `minting type` to be `sequential` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    /// @param amount The number of NFTs to mint
    /// @param affiliate The affiliate address
    function mint(uint256 amount, address affiliate) external payable override {
        _requirePaymentWithAffiliates(amount, affiliate);
        _mintSequentialWithChecks(msg.sender, amount);
    }

    /// @notice Mints `amount` NFTs to `to` address. Requires `minting type` to be `sequential` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    /// @param to The address of the NFTs receiver
    /// @param amount The number of NFTs to mint    
    function mintTo(address to, uint256 amount) external payable override {
        _requirePayment(_mintPrice, amount);
        _mintSequentialWithChecks(to, amount);
    }

    /// @notice Mints `amount` NFTs to `to` address with a given `affiliate`. Requires `minting type` to be `sequential` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    /// @param to The address of the NFTs receiver
    /// @param amount The number of NFTs to mint    
    /// @param affiliate The affiliate address
    function mintTo(address to, uint256 amount, address affiliate) external payable override {
        _requirePaymentWithAffiliates(amount, affiliate);
        _mintSequentialWithChecks(to, amount);
    }

    function _mintSequentialWithChecks(address to, uint256 amount) private {
        _checkPhase();
        if (_mintingType != MintingType.SEQUENTIAL) revert InvalidMintingType();
        if ((_soldTokens + amount) > _collectionSize) revert CollectionSoldOut();

        _mintSequential(to, amount);
    }

    function _mintSequential(address to, uint256 amount, bool soulbound) private {
        for (uint256 i; i < amount; ) {
            unchecked {
                _mint(to, ++_soldTokens);
            }
            if (soulbound) _soulbound[_soldTokens] = true;
            unchecked {
                ++i;
            }
        }
    }

    function _mintSequential(address to, uint256 amount) internal virtual {
        for (uint256 i; i < amount; ) {
            unchecked {
                _mint(to, ++_soldTokens);
                ++i;
            }
        }
    }

    /// @notice Two phases on-chain random minting. Mints `amount` NFTs tickets to `to` address. Requires `minting type` to be `random` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment). Once minted, those tickets must be redeemed for an actual token calling `redeemRandom()`.
    /// @param to The address of the NFTs receiver
    /// @param amount The number of NFTs to mint    
    function mintRandomTo(address to, uint256 amount) external payable override {
        _requirePayment(_mintPrice, amount);
        _mintRandomWithChecks(to, amount);
    }

    /// @notice Two phases on-chain random minting. Mints `amount` NFTs tickets to `to` address with a given `affiliate`. Requires `minting type` to be `random` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment). Once minted, those tickets must be redeemed for an actual token calling `redeemRandom()`.
    /// @param to The address of the NFTs receiver
    /// @param amount The number of NFTs to mint    
    /// @param affiliate The affiliate address
    function mintRandomTo(address to, uint256 amount, address affiliate) external payable override {
        _requirePaymentWithAffiliates(amount, affiliate);
        _mintRandomWithChecks(to, amount);
    }

    function _mintRandomWithChecks(address to, uint256 amount) private {
        _checkPhase();
        if (_mintingType != MintingType.RANDOM) revert InvalidMintingType();
        if (_soldTokens + (amount) > _collectionSize) revert CollectionSoldOut();

        unchecked {
            _randomTickets[to].blockNumberToReveal = block.number + 2;
            _randomTickets[to].amount += amount;
            _soldTokens += uint32(amount);
        }

        if (_maxPerAddress != 0) {

            if (balanceOf(to) > _maxPerAddress) revert MaxPerAddressExceeded();
        }        
    }

    /// @notice Redeems remaining random tickets generated from `msg.sender` by calling `mintRandomTo` for actual NFTs.
    function redeemRandom() external payable override {
        uint256 blockNumberToReveal = _randomTickets[msg.sender].blockNumberToReveal;
        uint256 amountToRedeem = _randomTickets[msg.sender].amount;

        if (amountToRedeem == 0) revert NothingToRedeem();
        if (block.number <= _randomTickets[msg.sender].blockNumberToReveal) revert CantRevealYetWaitABitToBeAbleToRedeem();

        bytes32 seedFromBlockNumber = blockhash(blockNumberToReveal);

        if (seedFromBlockNumber == 0) {

            uint256 newBlockNumber = ((block.number & uint256(int256(-0x100))) + (blockNumberToReveal & 0xff));

            if ((newBlockNumber >= block.number)) {
                newBlockNumber -= 256;

            }
            seedFromBlockNumber = blockhash(newBlockNumber);

        }

        delete(_randomTickets[msg.sender].blockNumberToReveal);
        delete(_randomTickets[msg.sender].amount);

        uint16 maxPerAddressTemp = _maxPerAddress;
        delete(_maxPerAddress);
        _mintRandom(msg.sender, amountToRedeem, seedFromBlockNumber, false);
        _maxPerAddress = maxPerAddressTemp;
    }

    function _mintRandom(address to, uint256 amount, bytes32 seed, bool soulbound) private {
        for (; amount > 0; ) {
            uint256 tokenId = _randomTokenId(seed, amount);
            _mint(to, tokenId);
            if (soulbound) _soulbound[tokenId] = true;
            unchecked {
                --amount;
            }
        }
    }

    function _randomTokenId(bytes32 seed, uint256 extraModifier) private view returns (uint256 tokenId) {

        tokenId = (uint256(keccak256(abi.encodePacked(seed, extraModifier))) % _collectionSize) + 1;

        while (_exists(tokenId)) {
            unchecked {
                tokenId = (tokenId % _collectionSize) + 1;
            }
        }
    }

    /// @notice Mints `amount` NFTs to `to` address. Requires `minting type` to be `specify` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    /// @param to The address of the NFTs receiver
    /// @param tokenIds An array of the specified tokens. They must not be minted, otherwise, it will revert.
    function mintSpecifyTo(address to, uint256[] memory tokenIds)
        external
        payable
        override
    {
        _requirePayment(_mintPrice, tokenIds.length);
        _mintSpecifyWithChecks(to, tokenIds);
    }

    /// @notice Mints `amount` NFTs to `to` address with a given `affiliate`. Requires `minting type` to be `specify` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    /// @param to The address of the NFTs receiver
    /// @param tokenIds An array of the specified tokens. They must not be minted, otherwise, it will revert.
    /// @param affiliate The affiliate address
    function mintSpecifyTo(address to, uint256[] memory tokenIds, address affiliate) 
        external
        payable
        override
    {
        _requirePaymentWithAffiliates(tokenIds.length, affiliate);
        _mintSpecifyWithChecks(to, tokenIds);
    }

    function _mintSpecifyWithChecks(address to, uint256[] memory tokenIds)
        private
    {
        _checkPhase();
        if (_mintingType != MintingType.SPECIFY) revert InvalidMintingType();

        if (_soldTokens + (tokenIds.length) > _collectionSize) revert CollectionSoldOut();

        _mintSpecify(to, tokenIds);
    }

    function _mintSpecify(
        address to,
        uint256[] memory tokenIds,
        bool soulbound
    ) private {
        _mintSpecify(to, tokenIds);
        uint256 inputLength = tokenIds.length;        
        if (soulbound) {
            for (uint256 i; i < inputLength; ) {
                _soulbound[tokenIds[i]] = true;
                unchecked {
                    ++i;
                }
            }
        }
    }

    function _mintSpecify(address to, uint256[] memory tokenIds)
        internal
        virtual
    {

        uint256 inputLength = tokenIds.length;
        unchecked {
            _soldTokens += uint32(inputLength);
        }
        for (uint256 i; i < inputLength; ) {
            uint256 tokenId = tokenIds[i];

            if (tokenId == 0 || tokenId > _collectionSize) revert InvalidTokenId();
            _mint(to, tokenId);
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Mints one NFT to `to` address. Requires `minting type` to be `customURI`.
    /// @param to The address of the NFTs receiver
    /// @param customURICIDHash The CID of the given token.
    /// @param soulbound True if the NFT is a Soulbound Token (SBT). If set, it can't be transferred.
    function mintCustomURITo(address to, bytes32 customURICIDHash, bool soulbound)
        external
        payable
        override
    {
        _requirePayment(_mintPrice, 1);
        _checkPhase();
        if (_mintingType != MintingType.CUSTOM_URI) revert InvalidMintingType();
        unchecked {
            if ((++_soldTokens) > _collectionSize) revert CollectionSoldOut();
        }
        _mint(to, _soldTokens);

        unchecked {
            if (soulbound) _soulbound[_soldTokens] = true;
        }
        _customURICIDHashes[_soldTokens] = customURICIDHash;
    }

    /// @notice Only owner can call this function. Free of charge. Mints sizeof(`to`) to `to` addresses. Requires `minting type` to be `sequential`.
    /// @param to The addresses of the NFTs receivers
    /// @param soulbound True if the NFT is a Soulbound Token (SBT). If set, it can't be transferred.
    function airdropSequential(address[] memory to, bool soulbound)
        external
        payable
        override
        onlyStrictOwner
    {
        if (_mintingType != MintingType.SEQUENTIAL) revert InvalidMintingType();
        if (_soldTokens + (to.length) > _collectionSize) revert CollectionSoldOut();

        uint256 toLength = to.length;
        for (uint256 i; i < toLength; ) {

            unchecked {
                _mint(to[i], ++_soldTokens);                
                if (soulbound) _soulbound[_soldTokens] = true;
                ++i;
            }
        }
    }

    /// @notice Only owner can call this function. Free of charge. Mints sizeof(`to`) to `to` addresses with random tokenIds. Requires `minting type` to be `random`.
    /// @param to The addresses of the NFTs receivers
    /// @param soulbound True if the NFT is a Soulbound Token (SBT). If set, it can't be transferred.
    function airdropRandom(address[] memory to, bool soulbound)
        external
        payable
        override
        onlyOwner
    {
        uint256 toLength = to.length;
        if (_mintingType != MintingType.RANDOM) revert InvalidMintingType();

        if ((_soldTokens + toLength) > _collectionSize) revert CollectionSoldOut();

        unchecked {
            _soldTokens += uint32(toLength);
        }

        bytes32 randomSeed = blockhash(block.number - 1);

        for (uint256 i; i < toLength; ) {
            uint256 newTokenId = _randomTokenId(randomSeed, i);
            _mint(to[i], newTokenId);
            if (soulbound) _soulbound[newTokenId] = true;
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Only owner can call this function. Free of charge. Mints sizeof(`to`) to `to` addresses with specified tokenIds. Requires `minting type` to be `specify`.
    /// @param to The addresses of the NFTs receivers
    /// @param tokenIds An array of the specified tokens. They must not be minted, otherwise, it will revert.
    /// @param soulbound True if the NFT is a Soulbound Token (SBT). If set, it can't be transferred.
    function airdropSpecify(
        address[] memory to,
        uint256[] memory tokenIds,
        bool soulbound
    ) external payable override onlyOwner {
        uint256 toLength = to.length;
        if (_mintingType != MintingType.SPECIFY) revert InvalidMintingType();

        if (_soldTokens + (tokenIds.length) > _collectionSize) revert CollectionSoldOut();
        if (toLength != tokenIds.length) revert InvalidInputSizesDontMatch();

        unchecked {
            _soldTokens += uint32(toLength);
        }

        for (uint256 i; i < toLength; ) {

            if (tokenIds[i] == 0 || tokenIds[i] > _collectionSize) revert InvalidTokenId();
            _mint(to[i], tokenIds[i]);
            if (soulbound) _soulbound[tokenIds[i]] = true;
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Mints `amount` of NFTs to `to` address with optional specified tokenIds. This function must be called only if a valid `signature` is given during a whitelisting/presale.
    /// @param to The addresses of the NFTs receivers
    /// @param tokenIds An optional array of the specified tokens. They must not be minted, otherwise, it will revert. Only used if minting type is `specify`.
    /// @param freeMinting True is minting is free
    /// @param customFee Zero is fee is different from `mintingPrice`.
    /// @param maxAmount Max Amount to be minted with the given `signature`.
    /// @param amount Amount to mint.
    /// @param soulbound True if the NFT is a Soulbound Token (SBT). If set, it can't be transferred.
    /// @param signature Valid `signature` for the presale/whitelist.
    function mintPresale(
        address to,
        uint256[] memory tokenIds,
        bool freeMinting,
        uint256 customFee,
        uint256 maxAmount,
        uint256 amount,
        bool soulbound,
        bytes calldata signature
    ) external payable override {
        if (amount == 0) revert InvalidAmount();

        _usedAmountSignature[signature] += amount;
        if (_usedAmountSignature[signature] > maxAmount) revert NotEnoughAmountToMint();

        if (_soldTokens + amount > _collectionSize) revert CollectionSoldOut();

        if (_currentPhase == SalePhase.CLOSED) revert PresaleNotOpen();

        address signer = ECDSAUpgradeable.recover(
            ECDSAUpgradeable.toEthSignedMessageHash(
                keccak256(
                    abi.encodePacked(
                        this.mintPresale.selector,                             
                        address(this),                                         
                        block.chainid,                                         
                        to,
                        freeMinting,
                        customFee,
                        maxAmount,
                        soulbound
                    )
                )
            ),
            signature
        );

        if (signer != N2M_PRESALE_SIGNER && signer != owner()) revert SignatureMismatch();

        if (freeMinting) {

            if (msg.value != 0) revert InvalidMintFeeForFreeMinting();
        } else {

            if (customFee == 0) customFee = _mintPrice;
            _requirePayment(customFee, amount);
        }

        if (_mintingType == MintingType.SPECIFY) {

            if (tokenIds.length != amount) revert InvalidInputSizesDontMatch();
            _mintSpecify(to, tokenIds, soulbound);
        } else if (_mintingType == MintingType.RANDOM) {
            bytes32 seed = keccak256(abi.encodePacked(signature));
            _soldTokens += uint32(amount);
            _mintRandom(to, amount, seed, soulbound);
        } else if (_mintingType == MintingType.SEQUENTIAL) {
            _mintSequential(to, amount, soulbound);
        } else {

            revert PresaleInvalidMintingType();
        }
    }

    /// @notice Returns the minting price of one NFT.
    /// @return Mint price for one NFT in native coin or ERC-20.
    function mintPrice() external view returns (uint256) {
        return _mintPrice;
    }

    /// @notice Returns the current total supply.
    /// @return Current total supply.
    function totalSupply() external view returns (uint256) {
        return _soldTokens;
    }

    /// @notice Max amount of NFTs to be hold per address.
    /// @return Max per address allowed.
    function maxPerAddress() external view override returns (uint16) {
        return _maxPerAddress;
    }

    /// @notice Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of exchange. The royalty amount is denominated and should be paid in that same unit of exchange.
    /// @param salePrice The sale price
    /// @return receiver the receiver of the royalties.
    /// @return royaltyAmount the amount of the royalties for the given input.
    function royaltyInfo(
        uint256, 
        uint256 salePrice
    ) external view virtual returns (address receiver, uint256 royaltyAmount) {

        return (address(this), uint256((salePrice * _royaltyFee) / 100_00));
    }

    function _requirePaymentWithAffiliates(uint256 amount, address affiliate)
        internal
    {
        uint16 currentUserDiscount;
        uint16 currentAffiliatePercentage;
        if (_affiliatesInfo[affiliate].enabled) {
            currentUserDiscount = _affiliatesInfo[affiliate].userDiscount;
            currentAffiliatePercentage = _affiliatesInfo[affiliate].affiliatePercentage;
        } else {
            currentUserDiscount = _affiliatesInfo[address(0)].userDiscount;
            currentAffiliatePercentage = _affiliatesInfo[address(0)].affiliatePercentage;
        }

        uint256 discountMintPrice = ((100_00 - currentUserDiscount) * _mintPrice) / 100_00;
        _requirePayment(discountMintPrice, amount);
        if (affiliate != address(0)) {
            uint256 affiliateAmount = (currentAffiliatePercentage * discountMintPrice * amount) / 100_00;
            _pendingTotalAffiliatesBalance += affiliateAmount;
            _pendingAffiliateBalance[affiliate] += affiliateAmount;
            emit AffiliateSell(affiliate);
        }
    }

    function _checkPhase() private {

        if (_currentPhase != SalePhase.PUBLIC) {
            if (_currentPhase == SalePhase.DROP_DATE) {
                if (block.timestamp >= _dropDateTimestamp) {
                    _currentPhase = SalePhase.PUBLIC;
                    delete(_dropDateTimestamp);
                } else {
                    revert WaitUntilDropDate();
                }
            } else if (_currentPhase == SalePhase.DROP_AND_END_DATE) {
                if (block.timestamp < _dropDateTimestamp) {
                    revert WaitUntilDropDate();
                }
                if (block.timestamp >= _endDateTimestamp) {
                    revert SaleFinished();
                }
            } else {

                revert PublicSaleNotOpen();
            }
        }
    }

    function _requirePayment(uint256 p_mintPrice, uint256 amount) internal {
        if (_isERC20Payment == false) {

            if (msg.value != (p_mintPrice * amount)) revert InvalidMintFee();
        } else {

            if (p_mintPrice == 0) return;
            uint256 totalAmount = p_mintPrice * amount;

            SafeERC20Upgradeable.safeTransferFrom(
                IERC20Upgradeable(_erc20PaymentAddress),
                msg.sender,
                address(this),
                totalAmount
            );
        }
    }

    modifier onlyAllowedOperator() {

        _isOperatorAllowed(msg.sender);
        _;
    }

    modifier onlyAllowedOperatorApproval(address operator) {
        _isOperatorAllowed(operator);
        _;
    }    

    function _isOperatorAllowed(address operator) private {
        if (_operatorFilterStatus == OperatorFilterStatus.ENABLED_EXISTS) {

            operatorFilterRegistry.isOperatorAllowed(address(this), operator);

        } else if (_operatorFilterStatus == OperatorFilterStatus.ENABLED_NOT_INITIALIZED) {

            if (address(operatorFilterRegistry).code.length > 0) {
                try operatorFilterRegistry.registerAndSubscribe(address(this), DEFAULT_SUBSCRIPTION) {

                    _operatorFilterStatus = OperatorFilterStatus.ENABLED_EXISTS;
                    operatorFilterRegistry.isOperatorAllowed(address(this), operator);
                } catch {
                }
            }
        } 

    }

    fallback() external payable
    {
        address libraryAddress = LIBRARY_ADDRESS;

        assembly {

            calldatacopy(0, 0, calldatasize())

            let result := delegatecall(
                gas(),
                libraryAddress,
                0,
                calldatasize(),
                0,
                0
            )

            returndatacopy(0, 0, returndatasize())

            switch result

            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }

    receive() external payable {}    
}