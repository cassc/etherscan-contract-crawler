{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.16;\r\n\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n}\r\n\r\n// safe transfer.\r\n// if is contract maybe is error. if account must success.\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        // (bool success,) = to.call.value(value)(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n\r\n// owner\r\nabstract contract Ownable {\r\n    address public owner;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, 'owner error');\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        owner = address(0);\r\n    }\r\n}\r\n\r\n// ReentrancyGuard.\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\n// Mining GODZ.\r\ncontract MiningGODZ is Ownable, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n\r\n    address public immutable gainToken;                             // gain token is GODZ.\r\n    uint256 public constant DAY_SECOND_NUMBER = 86400;                 // mainnet=86400, testnet=60.\r\n    uint256 public constant TAKE_END_TIME = DAY_SECOND_NUMBER * 3;  // 3 day can take.\r\n    uint256 private constant SCALING_FACTOR = 1e18;                 // Scaling this up increases support for high supply tokens.\r\n    uint256 public constant TOTAL_EARN = 600000000*(1e18);          // total earn.\r\n    uint256[6] public EARN_RATIO = [30,20,10,20,15,5];              // earn ratio.\r\n    uint256[6] public KEEP_TIME = [30*DAY_SECOND_NUMBER,20*DAY_SECOND_NUMBER,10*DAY_SECOND_NUMBER,30*DAY_SECOND_NUMBER,20*DAY_SECOND_NUMBER,10*DAY_SECOND_NUMBER];\r\n\r\n    // pool info.\r\n    struct PoolInfo {\r\n        address token;              // token(only GODZ or GODZ-ETH-LP).\r\n        uint256 startTime;          // start time.\r\n        uint256 keepTime;           // mining time(10day/20day/30day).\r\n        uint256 endTime;            // mining time(20day/40day/60day).\r\n        uint256 amountPerTime;      // amount per time(keep time is 2mul time).\r\n        uint256 totalEarn;          // total earn.\r\n        uint256 totalDeposit;       // total deposit.\r\n        uint256 accTokenPerShare;   // Accumulated Token per share, times SCALING_FACTOR. Check code.\r\n        uint256 lastRewardTime;     // last reward time.\r\n    }\r\n    PoolInfo[] public poolInfo;        // pool info.\r\n\r\n    // user info.\r\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\r\n    struct UserInfo {\r\n        uint256 startTime;          // start time.\r\n        uint256 amount;             // depoist amount.\r\n        uint256 rewardDebt;         // reward debt. Accumulated Token per share, times SCALING_FACTOR. Check code.\r\n    }\r\n\r\n    mapping(uint256 => mapping(address => address)) public inviter;    // pool id => account => super.\r\n    mapping(address => bool) public whiteList;                         // white list.\r\n    uint256 public inviterRatio = 10;                                  // 10%.\r\n    uint256 public immutable whiteListPriorityTime;                    // white list priority 7 day.\r\n\r\n    // user ids\r\n    mapping(address => uint256[]) public userIDs;\r\n    mapping(uint256 => IDInfoMsg) public IDInfo;      // ID => ID info.\r\n    struct IDInfoMsg {\r\n        uint256 pid;         // pid.\r\n        uint256 ID;          // ID.\r\n        uint256 depositTime; // deposit time.\r\n        uint256 amount;      // amount.\r\n        bool isTaked;        // is taked.\r\n        address account;     // amount\r\n    }\r\n    uint256 public nextID = 0;  // next ID.\r\n\r\n\r\n    constructor(address gainToken_, address lpToken_) {\r\n        gainToken = gainToken_;\r\n        _addAllPools(gainToken_, lpToken_);\r\n        whiteListPriorityTime = DAY_SECOND_NUMBER.mul(7).add(block.timestamp);\r\n\r\n        whiteList[msg.sender] = true;\r\n    }\r\n\r\n    event Deposit(uint256 pid, address account, uint256 amount, uint256 earn);\r\n    event Withdraw(uint256 pid, uint256 ID, address account, uint256 amount);\r\n\r\n\r\n    // add pools.\r\n    function _addAllPools(address token_, address lp_) private {\r\n        uint256 _count = EARN_RATIO.length;\r\n        uint256 _startTime = block.timestamp;\r\n\r\n        for(uint256 i = 0; i < _count; i++) {\r\n            address _token = i < 3 ? lp_ : token_;\r\n            poolInfo.push(PoolInfo({\r\n            token: _token,\r\n            startTime: _startTime,\r\n            keepTime: KEEP_TIME[i],\r\n            endTime: KEEP_TIME[i].mul(2).add(_startTime),\r\n            amountPerTime: TOTAL_EARN.mul(EARN_RATIO[i]).div(100).div(KEEP_TIME[i]).div(2),\r\n            totalEarn: TOTAL_EARN.mul(EARN_RATIO[i]).div(100),\r\n            totalDeposit: 0,\r\n            accTokenPerShare: 0,\r\n            lastRewardTime: block.timestamp\r\n            }));\r\n\r\n            inviter[i][msg.sender] = msg.sender;\r\n        }\r\n    }\r\n\r\n    // get all pool.\r\n    function getAllPool() external view returns(PoolInfo[] memory) {\r\n        return poolInfo;\r\n    }\r\n\r\n    // get user IDs.\r\n    function getUserIDs(address account) external view returns(uint256[] memory) {\r\n        return userIDs[account];\r\n    }\r\n\r\n    // get user IDs msg.\r\n    function getUserIDsMsg(address account) external view returns(IDInfoMsg[] memory) {\r\n        uint256 _length = userIDs[account].length;\r\n        uint256[] memory _IDs = userIDs[account];\r\n        IDInfoMsg[] memory _IDInfoMsgs = new IDInfoMsg[](_length);\r\n\r\n        for(uint256 i = 0; i < _length; i++) {\r\n            uint256 _ID = _IDs[i];\r\n            _IDInfoMsgs[i] = IDInfo[_ID];\r\n        }\r\n        return _IDInfoMsgs;\r\n    }\r\n    \r\n    receive() external payable {}\r\n\r\n    function takeETH(address to, uint256 amount) external onlyOwner {\r\n        require(amount > 0, \"amount can not be 0\");\r\n        require(to != address(0), \"invalid to address\");\r\n        TransferHelper.safeTransferETH(to, amount);\r\n    }\r\n\r\n    function takeToken(address token, address to, uint256 amount) external onlyOwner {\r\n        require(to != address(0), \"invalid to address\");\r\n        require(isContract(token), \"token not contract\");\r\n        TransferHelper.safeTransfer(token, to, amount);\r\n    }\r\n\r\n    // set white list.\r\n    function setWhiteList(address account, bool status) external onlyOwner {\r\n        whiteList[account] = status;\r\n    }\r\n\r\n    // set white lists.\r\n    function setWhiteLists(address[] memory accounts) external onlyOwner {\r\n        uint256 _count = accounts.length;\r\n        for(uint256 i = 0; i < _count; i++) {\r\n            whiteList[accounts[i]] = true;\r\n        }\r\n    }\r\n\r\n    // set inviter ratio.\r\n    function setInviterRatio(uint256 newInviterRatio) external onlyOwner {\r\n        require(newInviterRatio < 100, \"number error\");\r\n        inviterRatio = newInviterRatio;\r\n    }\r\n\r\n    // _binding inviter.\r\n    function _bindingInviter(uint256 pid, address account, address superAddress) private {\r\n        require(!isContract(account), \"is contract\");\r\n        require(superAddress != address(0), \"zero address\");\r\n        require(superAddress != account, \"not myself\");\r\n        require(inviter[pid][account] == address(0), \"already binding\");\r\n        require(inviter[pid][superAddress] != address(0), \"super not super\");\r\n\r\n        inviter[pid][account] = superAddress;\r\n    }\r\n\r\n    // update pool.\r\n    function updatePool(uint256 pid) external {\r\n        _updatePool(pid, 0);\r\n    }\r\n\r\n    function _updatePool(uint256 pid, uint256 amount) private {\r\n        PoolInfo storage _PoolInfo = poolInfo[pid];\r\n\r\n        if(block.timestamp <= _PoolInfo.lastRewardTime || _PoolInfo.totalDeposit == 0) {\r\n            _PoolInfo.totalDeposit += amount;\r\n            _PoolInfo.lastRewardTime = block.timestamp > _PoolInfo.endTime ? _PoolInfo.endTime : block.timestamp;\r\n            return;\r\n        }\r\n\r\n        uint256 _timestamp = block.timestamp > _PoolInfo.endTime ? _PoolInfo.endTime : block.timestamp;\r\n        uint256 _addPerShare = _timestamp.sub(_PoolInfo.lastRewardTime).mul(_PoolInfo.amountPerTime).mul(SCALING_FACTOR).div(_PoolInfo.totalDeposit);\r\n        _PoolInfo.accTokenPerShare += _addPerShare;\r\n        _PoolInfo.totalDeposit += amount;\r\n\r\n        _PoolInfo.lastRewardTime = _timestamp;\r\n    }\r\n\r\n    // pending token.\r\n    function pendingToken(uint256 pid, address account) public view returns(uint256) {\r\n        PoolInfo memory _PoolInfo = poolInfo[pid];\r\n        UserInfo memory _UserInfo = userInfo[pid][account];\r\n\r\n        uint256 newAccTokenPerShare = _PoolInfo.accTokenPerShare;\r\n        if(block.timestamp > _PoolInfo.lastRewardTime && _PoolInfo.totalDeposit != 0) {\r\n            uint256 _timestamp = block.timestamp > _PoolInfo.endTime ? _PoolInfo.endTime : block.timestamp;\r\n            uint256 addPerShare = _timestamp.sub(_PoolInfo.lastRewardTime).mul(_PoolInfo.amountPerTime).mul(SCALING_FACTOR).div(_PoolInfo.totalDeposit);\r\n            newAccTokenPerShare += addPerShare;\r\n        }\r\n        uint256 pendingAmount = _UserInfo.amount.mul(newAccTokenPerShare).div(SCALING_FACTOR).sub(_UserInfo.rewardDebt);\r\n        return pendingAmount;\r\n    }\r\n\r\n    // deposit.\r\n    function deposit(uint256 pid, uint256 amount, address superAddress) external nonReentrant {\r\n        PoolInfo storage _PoolInfo = poolInfo[pid];\r\n        address account = msg.sender;\r\n        // _binding inviter.\r\n        if(inviter[pid][account] == address(0)) {\r\n            _bindingInviter(pid, account, superAddress);\r\n        }\r\n\r\n        UserInfo storage _UserInfo = userInfo[pid][account];\r\n        require(_PoolInfo.token != address(0), \"zero address error\");\r\n        _updatePool(pid, amount);\r\n        require(inviter[pid][account] != address(0), \"not have super\");\r\n        require(whiteList[account] || block.timestamp > whiteListPriorityTime, \"you are not white list\");\r\n\r\n        uint256 pendingAmount = 0;\r\n        if(_UserInfo.amount > 0) {\r\n            pendingAmount = _UserInfo.amount.mul(_PoolInfo.accTokenPerShare).div(SCALING_FACTOR).sub(_UserInfo.rewardDebt);\r\n            if(pendingAmount > 0) {\r\n                uint256 pendingAmountSuper = pendingAmount.mul(inviterRatio).div(100);\r\n                uint256 pendingAmountMy = pendingAmount.sub(pendingAmountSuper);\r\n                address _super = inviter[pid][account];\r\n                if(userInfo[pid][_super].startTime > 0) {\r\n                    if(pendingAmountSuper > 0) TransferHelper.safeTransfer(gainToken, _super, pendingAmountSuper);\r\n                }\r\n                if(pendingAmountMy > 0) TransferHelper.safeTransfer(gainToken, account, pendingAmountMy);\r\n            }\r\n        }\r\n        if(amount > 0) {\r\n            TransferHelper.safeTransferFrom(_PoolInfo.token, account, address(this), amount);\r\n            _UserInfo.amount += amount;\r\n            _UserInfo.startTime = block.timestamp;\r\n            // add ID.\r\n            nextID++;\r\n            uint256 _ID = nextID;\r\n            userIDs[account].push(_ID);\r\n            IDInfo[_ID] = IDInfoMsg({\r\n                pid: pid,\r\n                ID: _ID,\r\n                depositTime: block.timestamp,\r\n                amount: amount,\r\n                isTaked: false,\r\n                account: account\r\n            });\r\n        }\r\n        _UserInfo.rewardDebt = _UserInfo.amount.mul(_PoolInfo.accTokenPerShare).div(SCALING_FACTOR);\r\n        emit Deposit(pid, account, amount, pendingAmount);\r\n    }\r\n\r\n    // withdraw.\r\n    function withdraw(uint256 pid, uint256[] memory IDs) external nonReentrant {\r\n        PoolInfo storage _PoolInfo = poolInfo[pid];\r\n        address account = msg.sender;\r\n        UserInfo storage _UserInfo = userInfo[pid][account];\r\n        _updatePool(pid, 0);\r\n        require(inviter[pid][account] != address(0), \"not have super\");\r\n        require(whiteList[account] || block.timestamp > whiteListPriorityTime, \"you are not white list\");\r\n\r\n        // earn.\r\n        uint256 pendingAmount = _UserInfo.amount.mul(_PoolInfo.accTokenPerShare).div(SCALING_FACTOR).sub(_UserInfo.rewardDebt);\r\n        if(pendingAmount > 0) {\r\n            uint256 pendingAmountSuper = pendingAmount.mul(inviterRatio).div(100);\r\n            uint256 pendingAmountMy = pendingAmount.sub(pendingAmountSuper);\r\n            address _super = inviter[pid][account];\r\n            if(userInfo[pid][_super].startTime > 0) { \r\n                if(pendingAmountSuper > 0) TransferHelper.safeTransfer(gainToken, _super, pendingAmountSuper);\r\n            }\r\n            if(pendingAmountMy > 0) TransferHelper.safeTransfer(gainToken, account, pendingAmountMy);\r\n        }\r\n        emit Deposit(pid, account, 0, pendingAmount);\r\n\r\n        // take.\r\n        uint256 _nowTime = block.timestamp;\r\n        for(uint256 i = 0; i < IDs.length; i++) {\r\n            uint256 _ID = IDs[i];\r\n            IDInfoMsg storage _IDInfoMsg = IDInfo[_ID];\r\n            require(!_IDInfoMsg.isTaked, \"already taked\");\r\n            require(_IDInfoMsg.account == account, \"ID not your\");\r\n            require(_IDInfoMsg.ID == _ID, \"ID error\");\r\n            require(_IDInfoMsg.pid == pid, \"pid error\");\r\n\r\n            uint256 _canTakeStartTime = _IDInfoMsg.depositTime.add(_PoolInfo.keepTime);\r\n            uint256 _canTakeEndTime = _canTakeStartTime.add(TAKE_END_TIME);\r\n            if((_nowTime >= _canTakeStartTime && _nowTime <= _canTakeEndTime) || _nowTime > _PoolInfo.endTime) {\r\n                uint256 takedAmount = _IDInfoMsg.amount;\r\n                if(takedAmount > 0) TransferHelper.safeTransfer(_PoolInfo.token, account, takedAmount);\r\n                _UserInfo.amount -= takedAmount;\r\n                _PoolInfo.totalDeposit -= takedAmount;\r\n\r\n                _IDInfoMsg.isTaked = true;\r\n                emit Withdraw(pid, _ID, account, takedAmount);\r\n            }\r\n        }\r\n\r\n        _UserInfo.rewardDebt = _UserInfo.amount.mul(_PoolInfo.accTokenPerShare).div(SCALING_FACTOR);        \r\n    }\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length > 0;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gainToken_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lpToken_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earn\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DAY_SECOND_NUMBER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"EARN_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"IDInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isTaked\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"KEEP_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TAKE_END_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_EARN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"superAddress\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gainToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllPool\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"keepTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPerTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEarn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accTokenPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardTime\",\"type\":\"uint256\"}],\"internalType\":\"struct MiningGODZ.PoolInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserIDs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserIDsMsg\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isTaked\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"internalType\":\"struct MiningGODZ.IDInfoMsg[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"inviter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inviterRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"pendingToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"keepTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPerTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEarn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accTokenPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newInviterRatio\",\"type\":\"uint256\"}],\"name\":\"setInviterRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"setWhiteLists\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"takeETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"takeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userIDs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whiteListPriorityTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"IDs\",\"type\":\"uint256[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MiningGODZ", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000001068a889fd7151fb2ca9d98d268b0d0cd623fc2f000000000000000000000000ec4a060f134ce3d857510083acfa158fdbf2433d", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://470d69c306a0656916c327c7306ead178d8a90c70745a7b49da89d6c765e8f9a"}