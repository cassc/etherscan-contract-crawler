/**
 *Submitted for verification at Etherscan.io on 2022-08-13
*/

/**

The Mirror of Matsuyama


        ---------------------------------------------------------------------
        𝐼𝑛 𝑎𝑛𝑐𝑖𝑒𝑛𝑡 𝑑𝑎𝑦𝑠 𝑡ℎ𝑒𝑟𝑒 𝑙𝑖𝑣𝑒𝑑 𝑖𝑛 𝑎 𝑟𝑒𝑚𝑜𝑡𝑒 𝑝𝑎𝑟𝑡 𝑜𝑓 𝐽𝑎𝑝𝑎𝑛 𝑎 𝑚𝑎𝑛 𝑎𝑛𝑑 ℎ𝑖𝑠 𝑤𝑖𝑓𝑒, 
       𝑡ℎ𝑒𝑦 𝑤𝑒𝑟𝑒 𝑏𝑙𝑒𝑠𝑠𝑒𝑑 𝑤𝑖𝑡ℎ 𝑎 𝑙𝑖𝑡𝑡𝑙𝑒 𝑔𝑖𝑟𝑙, 𝑤ℎ𝑜 𝑤𝑎𝑠 𝑡ℎ𝑒 𝑝𝑒𝑡 𝑎𝑛𝑑 𝑖𝑑𝑜𝑙 𝑜𝑓 ℎ𝑒𝑟 𝑝𝑎𝑟𝑒𝑛𝑡𝑠. 
          𝑂𝑛 𝑜𝑛𝑒 𝑜𝑐𝑐𝑎𝑠𝑖𝑜𝑛 𝑡ℎ𝑒 𝑚𝑎𝑛 𝑤𝑎𝑠 𝑐𝑎𝑙𝑙𝑒𝑑 𝑎𝑤𝑎𝑦 𝑜𝑛 𝑏𝑢𝑠𝑖𝑛𝑒𝑠𝑠 𝑖𝑛 𝑑𝑖𝑠𝑡𝑎𝑛𝑡 𝐾𝑦𝑜𝑡𝑜. 
    𝐵𝑒𝑓𝑜𝑟𝑒 ℎ𝑒 𝑤𝑒𝑛𝑡 ℎ𝑒 𝑡𝑜𝑙𝑑 ℎ𝑖𝑠 𝑑𝑎𝑢𝑔ℎ𝑡𝑒𝑟 𝑡ℎ𝑎𝑡 𝑖𝑓 𝑠ℎ𝑒 𝑤𝑒𝑟𝑒 𝑔𝑜𝑜𝑑 𝑎𝑛𝑑 𝑑𝑢𝑡𝑖𝑓𝑢𝑙 𝑡𝑜 ℎ𝑒𝑟 𝑚𝑜𝑡ℎ𝑒𝑟
               ℎ𝑒 𝑤𝑜𝑢𝑙𝑑 𝑏𝑟𝑖𝑛𝑔 ℎ𝑒𝑟 𝑏𝑎𝑐𝑘 𝑎 𝑝𝑟𝑒𝑠𝑒𝑛𝑡 𝑠ℎ𝑒 𝑤𝑜𝑢𝑙𝑑 𝑝𝑟𝑖𝑧𝑒 𝑣𝑒𝑟𝑦 ℎ𝑖𝑔ℎ𝑙𝑦. 
        𝑇ℎ𝑒𝑛 𝑡ℎ𝑒 𝑔𝑜𝑜𝑑 𝑚𝑎𝑛 𝑡𝑜𝑜𝑘 ℎ𝑖𝑠 𝑑𝑒𝑝𝑎𝑟𝑡𝑢𝑟𝑒, 𝑚𝑜𝑡ℎ𝑒𝑟 𝑎𝑛𝑑 𝑑𝑎𝑢𝑔ℎ𝑡𝑒𝑟 𝑤𝑎𝑡𝑐ℎ𝑖𝑛𝑔 ℎ𝑖𝑚 𝑔𝑜.

                       𝐴𝑡 𝑙𝑎𝑠𝑡 ℎ𝑒 𝑟𝑒𝑡𝑢𝑟𝑛𝑒𝑑 𝑡𝑜 ℎ𝑖𝑠 ℎ𝑜𝑚𝑒, 
        𝑎𝑛𝑑 𝑎𝑓𝑡𝑒𝑟 ℎ𝑖𝑠 𝑤𝑖𝑓𝑒 𝑎𝑛𝑑 𝑐ℎ𝑖𝑙𝑑 ℎ𝑎𝑑 𝑡𝑎𝑘𝑒𝑛 𝑜𝑓𝑓 ℎ𝑖𝑠 𝑙𝑎𝑟𝑔𝑒 ℎ𝑎𝑡 𝑎𝑛𝑑 𝑠𝑎𝑛𝑑𝑎𝑙𝑠 ℎ𝑒 𝑠𝑎𝑡 𝑑𝑜𝑤𝑛
                 𝑢𝑝𝑜𝑛 𝑡ℎ𝑒 𝑤ℎ𝑖𝑡𝑒 𝑚𝑎𝑡𝑠 𝑎𝑛𝑑 𝑜𝑝𝑒𝑛𝑒𝑑 𝑎 𝑏𝑎𝑚𝑏𝑜𝑜 𝑏𝑎𝑠𝑘𝑒𝑡, 
                  𝑤𝑎𝑡𝑐ℎ𝑖𝑛𝑔 𝑡ℎ𝑒 𝑒𝑎𝑔𝑒𝑟 𝑔𝑎𝑧𝑒 𝑜𝑓 ℎ𝑖𝑠 𝑙𝑖𝑡𝑡𝑙𝑒 𝑐ℎ𝑖𝑙𝑑. 
𝐻𝑒 𝑡𝑜𝑜𝑘 𝑜𝑢𝑡 𝑎 𝑤𝑜𝑛𝑑𝑒𝑟𝑓𝑢𝑙 𝑑𝑜𝑙𝑙 𝑎𝑛𝑑 𝑎 𝑙𝑎𝑐𝑞𝑢𝑒𝑟 𝑏𝑜𝑥 𝑜𝑓 𝑐𝑎𝑘𝑒𝑠 𝑎𝑛𝑑 𝑝𝑢𝑡 𝑡ℎ𝑒𝑚 𝑖𝑛𝑡𝑜 ℎ𝑒𝑟 𝑜𝑢𝑡𝑠𝑡𝑟𝑒𝑡𝑐ℎ𝑒𝑑 ℎ𝑎𝑛𝑑𝑠. 
                     𝑂𝑛𝑐𝑒 𝑚𝑜𝑟𝑒 ℎ𝑒 𝑑𝑖𝑣𝑒𝑑 𝑖𝑛𝑡𝑜 ℎ𝑖𝑠 𝑏𝑎𝑠𝑘𝑒𝑡 
         𝑎𝑛𝑑 𝑝𝑟𝑒𝑠𝑒𝑛𝑡𝑒𝑑 ℎ𝑖𝑠 𝑤𝑖𝑓𝑒 𝑤𝑖𝑡ℎ 𝑎 𝑚𝑒𝑡𝑎𝑙 𝑚𝑖𝑟𝑟𝑜𝑟. 𝐼𝑡𝑠 𝑐𝑜𝑛𝑣𝑒𝑥 𝑠𝑢𝑟𝑓𝑎𝑐𝑒 𝑠ℎ𝑜𝑛𝑒 𝑏𝑟𝑖𝑔ℎ𝑡𝑙𝑦, 
         𝑤ℎ𝑖𝑙𝑒 𝑢𝑝𝑜𝑛 𝑖𝑡𝑠 𝑏𝑎𝑐𝑘 𝑡ℎ𝑒𝑟𝑒 𝑤𝑎𝑠 𝑎 𝑑𝑒𝑠𝑖𝑔𝑛 𝑜𝑓 𝑝𝑖𝑛𝑒 𝑡𝑟𝑒𝑒𝑠 𝑎𝑛𝑑 𝑠𝑡𝑜𝑟𝑘𝑠.
        ---------------------------------------------------------------------


*/


pragma solidity 0.8.7;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        return c;
    }

}

contract Ownable is Context {
    address private _owner;
    address private _previousOwner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

}

interface IUniswapV2Factory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
}

interface IUniswapV2Router02 {
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function factory() external pure returns (address);
    function WETH() external pure returns (address);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
}

contract MATSUYAMA  is Context, IERC20, Ownable {
    using SafeMath for uint256;
    mapping (address => uint256) private _rOwned;
    mapping (address => uint256) private _tOwned;
    mapping (address => mapping (address => uint256)) private _allowances;
    mapping (address => bool) private _isExcludedFromFee;
    mapping (address => bool) private bots;
    mapping (address => uint) private cooldown;
    uint256 private constant MAX = ~uint256(0);
    uint256 private constant _tTotal = 1000 * 10**8;
    uint256 private _rTotal = (MAX - (MAX % _tTotal));
    uint256 private _tFeeTotal;

    uint256 private _feeAddr1;
    uint256 private _feeAddr2;
    uint256 private _initialTax;
    uint256 private _finalTax;
    uint256 private _reduceTaxCountdown;
    address payable private _feeAddrWallet;

    string private constant _name = unicode"The Mirror of Matsuyama";
    string private constant _symbol = "MATSUYAMA";
    uint8 private constant _decimals = 8;

    IUniswapV2Router02 private uniswapV2Router;
    address private uniswapV2Pair;
    bool private tradingOpen;
    bool private inSwap = false;
    bool private swapEnabled = false;
    bool private cooldownEnabled = false;
    uint256 private _maxTxAmount = 20 * 10**8;
    uint256 private _maxWalletSize = 40 * 10**8;
    event MaxTxAmountUpdated(uint _maxTxAmount);
    modifier lockTheSwap {
        inSwap = true;
        _;
        inSwap = false;
    }

    constructor () {
        _feeAddrWallet = payable(_msgSender());
        _rOwned[_msgSender()] = _rTotal;
        _isExcludedFromFee[owner()] = true;
        _isExcludedFromFee[address(this)] = true;
        _isExcludedFromFee[_feeAddrWallet] = true;
        _initialTax=10;
        _finalTax=5;
        _reduceTaxCountdown=60;

        emit Transfer(address(0), _msgSender(), _tTotal);
    }

    function name() public pure returns (string memory) {
        return _name;
    }

    function symbol() public pure returns (string memory) {
        return _symbol;
    }

    function decimals() public pure returns (uint8) {
        return _decimals;
    }

    function totalSupply() public pure override returns (uint256) {
        return _tTotal;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return tokenFromReflection(_rOwned[account]);
    }
    function addBots(address[] memory bots_) public onlyOwner {
        for (uint i = 0; i < bots_.length; i++) {
            bots[bots_[i]] = true;
        }
    }

    function delBot(address notbot) public onlyOwner {
        bots[notbot] = false;
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    function setCooldownEnabled(bool onoff) external onlyOwner() {
        cooldownEnabled = onoff;
    }

    function tokenFromReflection(uint256 rAmount) private view returns(uint256) {
        require(rAmount <= _rTotal, "Amount must be less than total reflections");
        uint256 currentRate =  _getRate();
        return rAmount.div(currentRate);
    }

    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");


        if (from != owner() && to != owner()) {
            require(!bots[from] && !bots[to]);
            _feeAddr1 = 0;
            _feeAddr2 = (_reduceTaxCountdown==0)?_finalTax:_initialTax;
            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {
                // Cooldown
                require(amount <= _maxTxAmount, "Exceeds the _maxTxAmount.");
                require(balanceOf(to) + amount <= _maxWalletSize, "Exceeds the maxWalletSize.");
                if(_reduceTaxCountdown>0){_reduceTaxCountdown--;}
            }


            uint256 contractTokenBalance = balanceOf(address(this));
            if (!inSwap && from != uniswapV2Pair && swapEnabled && contractTokenBalance>0 && _reduceTaxCountdown<30) {
                swapTokensForEth(contractTokenBalance);
                uint256 contractETHBalance = address(this).balance;
                if(contractETHBalance > 0) {
                    sendETHToFee(address(this).balance);
                }
            }
        }else{
          _feeAddr1 = 0;
          _feeAddr2 = 0;
        }

        _tokenTransfer(from,to,amount);
    }

    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapV2Router.WETH();
        _approve(address(this), address(uniswapV2Router), tokenAmount);
        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }


    function removeLimits() external onlyOwner{
        _maxTxAmount = _tTotal;
        _maxWalletSize = _tTotal;
    }

    function sendETHToFee(uint256 amount) private {
        _feeAddrWallet.transfer(amount);
    }

    function openTrading() external onlyOwner() {
        require(!tradingOpen,"trading is already open");
        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
        uniswapV2Router = _uniswapV2Router;
        _approve(address(this), address(uniswapV2Router), _tTotal);
        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());
        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);
        swapEnabled = true;
        cooldownEnabled = true;

        tradingOpen = true;
        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);
    }

    function _tokenTransfer(address sender, address recipient, uint256 amount) private {
        _transferStandard(sender, recipient, amount);
    }

    function _transferStandard(address sender, address recipient, uint256 tAmount) private {
        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);
        _rOwned[sender] = _rOwned[sender].sub(rAmount);
        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
        _takeTeam(tTeam);
        _reflectFee(rFee, tFee);
        emit Transfer(sender, recipient, tTransferAmount);
    }

    function _takeTeam(uint256 tTeam) private {
        uint256 currentRate =  _getRate();
        uint256 rTeam = tTeam.mul(currentRate);
        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);
    }

    function _reflectFee(uint256 rFee, uint256 tFee) private {
        _rTotal = _rTotal.sub(rFee);
        _tFeeTotal = _tFeeTotal.add(tFee);
    }

    receive() external payable {}

    function manualswap() external {
        require(_msgSender() == _feeAddrWallet);
        uint256 contractBalance = balanceOf(address(this));
        swapTokensForEth(contractBalance);
    }

    function manualsend() external {
        require(_msgSender() == _feeAddrWallet);
        uint256 contractETHBalance = address(this).balance;
        sendETHToFee(contractETHBalance);
    }


    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {
        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _feeAddr1, _feeAddr2);
        uint256 currentRate =  _getRate();
        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);
        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);
    }

    function _getTValues(uint256 tAmount, uint256 taxFee, uint256 TeamFee) private pure returns (uint256, uint256, uint256) {
        uint256 tFee = tAmount.mul(taxFee).div(100);
        uint256 tTeam = tAmount.mul(TeamFee).div(100);
        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);
        return (tTransferAmount, tFee, tTeam);
    }

    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {
        uint256 rAmount = tAmount.mul(currentRate);
        uint256 rFee = tFee.mul(currentRate);
        uint256 rTeam = tTeam.mul(currentRate);
        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);
        return (rAmount, rTransferAmount, rFee);
    }

	function _getRate() private view returns(uint256) {
        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();
        return rSupply.div(tSupply);
    }

    function _getCurrentSupply() private view returns(uint256, uint256) {
        uint256 rSupply = _rTotal;
        uint256 tSupply = _tTotal;
        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);
        return (rSupply, tSupply);
    }
}