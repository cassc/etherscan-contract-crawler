{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/incentives/BendKeeper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {KeeperCompatibleInterface} from \\\"@chainlink/contracts/src/v0.8/KeeperCompatible.sol\\\";\\nimport {IFeeDistributor} from \\\"./interfaces/IFeeDistributor.sol\\\";\\nimport {IFeeCollector} from \\\"./interfaces/IFeeCollector.sol\\\";\\n\\ncontract BendKeeper is KeeperCompatibleInterface {\\n    uint256 public constant DAY = 86400;\\n    IFeeDistributor public feeDistributor;\\n    IFeeCollector public feeCollector;\\n    uint256 public nextDistributeTime;\\n\\n    constructor(address _feeDistributorAddr, address _feeCollector) {\\n        feeDistributor = IFeeDistributor(_feeDistributorAddr);\\n        feeCollector = IFeeCollector(_feeCollector);\\n        nextDistributeTime = (block.timestamp / DAY) * DAY + DAY;\\n    }\\n\\n    function checkUpkeep(bytes calldata)\\n        external\\n        view\\n        override\\n        returns (bool upkeepNeeded, bytes memory)\\n    {\\n        upkeepNeeded = block.timestamp >= nextDistributeTime;\\n    }\\n\\n    function performUpkeep(bytes calldata) external override {\\n        if (block.timestamp >= nextDistributeTime) {\\n            feeCollector.collect();\\n            feeDistributor.distribute();\\n            nextDistributeTime += DAY;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/KeeperCompatible.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./KeeperBase.sol\\\";\\nimport \\\"./interfaces/KeeperCompatibleInterface.sol\\\";\\n\\nabstract contract KeeperCompatible is KeeperBase, KeeperCompatibleInterface {}\\n\"\r\n    },\r\n    \"contracts/incentives/interfaces/IFeeDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\nimport {ILendPoolAddressesProvider} from \\\"../interfaces/ILendPoolAddressesProvider.sol\\\";\\n\\ninterface IFeeDistributor {\\n    event Distributed(uint256 time, uint256 tokenAmount);\\n\\n    event Claimed(\\n        address indexed recipient,\\n        uint256 amount,\\n        uint256 claimEpoch,\\n        uint256 maxEpoch\\n    );\\n\\n    function lastDistributeTime() external view returns (uint256);\\n\\n    function distribute() external;\\n\\n    function claim(bool weth) external returns (uint256);\\n\\n    function claimable(address _addr) external view returns (uint256);\\n\\n    function addressesProvider()\\n        external\\n        view\\n        returns (ILendPoolAddressesProvider);\\n\\n    function bendCollector() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/incentives/interfaces/IFeeCollector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\ninterface IFeeCollector {\\n    function collect() external;\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/KeeperBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract KeeperBase {\\n  error OnlySimulatedBackend();\\n\\n  /**\\n   * @notice method that allows it to be simulated via eth_call by checking that\\n   * the sender is the zero address.\\n   */\\n  function preventExecution() internal view {\\n    if (tx.origin != address(0)) {\\n      revert OnlySimulatedBackend();\\n    }\\n  }\\n\\n  /**\\n   * @notice modifier that allows it to be simulated via eth_call by checking\\n   * that the sender is the zero address.\\n   */\\n  modifier cannotExecute() {\\n    preventExecution();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface KeeperCompatibleInterface {\\n  /**\\n   * @notice method that is simulated by the keepers to see if any work actually\\n   * needs to be performed. This method does does not actually need to be\\n   * executable, and since it is only ever simulated it can consume lots of gas.\\n   * @dev To ensure that it is never called, you may want to add the\\n   * cannotExecute modifier from KeeperBase to your implementation of this\\n   * method.\\n   * @param checkData specified in the upkeep registration so it is always the\\n   * same for a registered upkeep. This can easily be broken down into specific\\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\\n   * same contract and easily differentiated by the contract.\\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\\n   * performUpkeep or not.\\n   * @return performData bytes that the keeper should call performUpkeep with, if\\n   * upkeep is needed. If you would like to encode data to decode later, try\\n   * `abi.encode`.\\n   */\\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\\n\\n  /**\\n   * @notice method that is actually executed by the keepers, via the registry.\\n   * The data returned by the checkUpkeep simulation will be passed into\\n   * this method to actually be executed.\\n   * @dev The input to this method should not be trusted, and the caller of the\\n   * method should not even be restricted to any single registry. Anyone should\\n   * be able call it, and the input should be validated, there is no guarantee\\n   * that the data passed in is the performData returned from checkUpkeep. This\\n   * could happen due to malicious keepers, racing keepers, or simply a state\\n   * change while the performUpkeep transaction is waiting for confirmation.\\n   * Always validate the data passed in.\\n   * @param performData is the data which was passed back from the checkData\\n   * simulation. If it is encoded, it can easily be decoded into other types by\\n   * calling `abi.decode`. This data should not be trusted, and should be\\n   * validated against the contract's current state.\\n   */\\n  function performUpkeep(bytes calldata performData) external;\\n}\\n\"\r\n    },\r\n    \"contracts/incentives/interfaces/ILendPoolAddressesProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\ninterface ILendPoolAddressesProvider {\\n    function getLendPool() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeDistributorAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeCollector\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"upkeepNeeded\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"internalType\":\"contract IFeeCollector\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDistributor\",\"outputs\":[{\"internalType\":\"contract IFeeDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextDistributeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"performUpkeep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BendKeeper", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000002338d34337dd0811b684640de74717b73f7b80590000000000000000000000001d53bb3dabf03c60b6f17d8316c3ffd505c7eff1", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}