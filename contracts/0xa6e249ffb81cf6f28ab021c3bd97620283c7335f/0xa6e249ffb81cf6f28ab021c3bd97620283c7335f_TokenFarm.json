{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/OTC_app/TokenFarm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"../library/BoringERC20.sol\\\";\\r\\n\\r\\ncontract TokenFarm is Ownable, ReentrancyGuard {\\r\\n    using BoringERC20 for IBoringERC20;\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    // Info of each user for each farm.\\r\\n    struct UserInfo {\\r\\n        uint256 amount; // How many Staking tokens the user has provided.\\r\\n        uint256 rewardDebt; // Reward debt. See explanation below.\\r\\n    }\\r\\n\\r\\n    // Info of each reward distribution pool.\\r\\n    struct PoolInfo {\\r\\n        IBoringERC20 stakingToken; // Address of Staking token contract.\\r\\n        IBoringERC20 rewardToken; // Address of Reward token contract\\r\\n        uint256 precision; //reward token precision\\r\\n        uint256 startTimestamp; // start timestamp of the pool\\r\\n        uint256 lastRewardTimestamp; // Last timestamp that Reward Token distribution occurs.\\r\\n        uint256 accRewardPerShare; // Accumulated Reward Token per share. See below.\\r\\n        uint256 totalStaked; // total staked amount each pool's stake token, typically, each pool has the same stake token, so need to track it separatedly\\r\\n        uint256 totalRewards;\\r\\n    }\\r\\n\\r\\n    // Reward info\\r\\n    struct RewardInfo {\\r\\n        uint256 startTimestamp;\\r\\n        uint256 endTimestamp;\\r\\n        uint256 rewardPerSec;\\r\\n    }\\r\\n\\r\\n    /// @notice Info of each pool.\\r\\n    PoolInfo[] public poolInfo;\\r\\n\\r\\n    // @dev this is mostly used for extending reward period\\r\\n    // @notice Reward info is a set of {endTimestamp, rewardPerTimestamp}\\r\\n    // indexed by pool ID\\r\\n    mapping(uint256 => RewardInfo[]) public poolRewardInfo;\\r\\n\\r\\n    // Info of each user that stakes Staking tokens.\\r\\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\\r\\n\\r\\n    // @notice limit length of reward info\\r\\n    // how many phases are allowed\\r\\n    uint256 public rewardInfoLimit;\\r\\n\\r\\n    event Deposit(address indexed user, uint256 amount, uint256 pool, uint256 accRewardPerShare, uint256 rewardDebit);\\r\\n    event Withdraw(address indexed user, uint256 amount, uint256 pool, uint256 accRewardPerShare, uint256 rewardDebit);\\r\\n    event EmergencyWithdraw(\\r\\n        address indexed user,\\r\\n        uint256 amount,\\r\\n        uint256 pool\\r\\n    );\\r\\n    event AddPoolInfo(\\r\\n        uint256 indexed poolID,\\r\\n        IBoringERC20 stakingToken,\\r\\n        IBoringERC20 rewardToken,\\r\\n        uint256 startTimestamp,\\r\\n        uint256 precision\\r\\n    );\\r\\n\\r\\n    event AddRewardInfo(\\r\\n        uint256 indexed poolID,\\r\\n        uint256 indexed phase,\\r\\n        uint256 endTimestamp,\\r\\n        uint256 rewardPerTimestamp\\r\\n    );\\r\\n    event UpdatePoolInfo(uint256 indexed poolID, uint256 indexed lastRewardTimestamp);\\r\\n    event SetRewardInfoLimit(uint256 rewardInfoLimit);\\r\\n\\r\\n    // constructor\\r\\n    constructor() {\\r\\n        rewardInfoLimit = 53;\\r\\n    }\\r\\n\\r\\n    // @notice set new reward info limit\\r\\n    function setRewardInfoLimit(uint256 _updatedRewardInfoLimit)\\r\\n    external\\r\\n    onlyOwner\\r\\n    {\\r\\n        rewardInfoLimit = _updatedRewardInfoLimit;\\r\\n        emit SetRewardInfoLimit(rewardInfoLimit);\\r\\n    }\\r\\n\\r\\n    // @notice reward pool, one pool represents a pair of staking and reward token, last reward Timestamp and acc reward Per Share\\r\\n    function addPoolInfo(\\r\\n        IBoringERC20 _stakingToken,\\r\\n        IBoringERC20 _rewardToken\\r\\n    ) external onlyOwner {\\r\\n        uint256 decimalsRewardToken = uint256(_rewardToken.safeDecimals());\\r\\n\\r\\n        require(\\r\\n            decimalsRewardToken < 30,\\r\\n            \\\"constructor: reward token decimals must be inferior to 30\\\"\\r\\n        );\\r\\n\\r\\n        uint256 precision = uint256(10**(uint256(30) - (decimalsRewardToken)));\\r\\n\\r\\n        poolInfo.push(\\r\\n            PoolInfo({\\r\\n                stakingToken: _stakingToken,\\r\\n                rewardToken: _rewardToken,\\r\\n                precision: precision,\\r\\n                startTimestamp: block.timestamp,\\r\\n                lastRewardTimestamp: block.timestamp,\\r\\n                accRewardPerShare: 0,\\r\\n                totalStaked: 0,\\r\\n                totalRewards: 0\\r\\n            })\\r\\n        );\\r\\n        emit AddPoolInfo(\\r\\n            poolInfo.length - 1,\\r\\n            _stakingToken,\\r\\n            _rewardToken,\\r\\n            block.timestamp,\\r\\n            precision\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // @notice if the new reward info is added, the reward & its end timestamp will be extended by the newly pushed reward info.\\r\\n    function addRewardInfo(\\r\\n        uint256 _pid,\\r\\n        uint256 _endTimestamp,\\r\\n        uint256 _rewardPerSec\\r\\n    ) external onlyOwner {\\r\\n        RewardInfo[] storage rewardInfo = poolRewardInfo[_pid];\\r\\n        PoolInfo storage pool = poolInfo[_pid];\\r\\n        require(\\r\\n            rewardInfo.length < rewardInfoLimit,\\r\\n            \\\"addRewardInfo::reward info length exceeds the limit\\\"\\r\\n        );\\r\\n        require(\\r\\n            rewardInfo.length == 0 ||\\r\\n            rewardInfo[rewardInfo.length - 1].endTimestamp >=\\r\\n            block.timestamp,\\r\\n            \\\"addRewardInfo::reward period ended\\\"\\r\\n        );\\r\\n        require(\\r\\n            rewardInfo.length == 0 ||\\r\\n            rewardInfo[rewardInfo.length - 1].endTimestamp < _endTimestamp,\\r\\n            \\\"addRewardInfo::bad new endTimestamp\\\"\\r\\n        );\\r\\n        uint256 startTimestamp = rewardInfo.length == 0\\r\\n        ? pool.startTimestamp\\r\\n        : rewardInfo[rewardInfo.length - 1].endTimestamp;\\r\\n\\r\\n        uint256 timeRange = _endTimestamp.sub(startTimestamp);\\r\\n\\r\\n        uint256 totalRewards = timeRange.mul(_rewardPerSec);\\r\\n        pool.rewardToken.safeTransferFrom(\\r\\n            msg.sender,\\r\\n            address(this),\\r\\n            totalRewards\\r\\n        );\\r\\n        pool.totalRewards = pool.totalRewards.add(totalRewards);\\r\\n\\r\\n        rewardInfo.push(\\r\\n            RewardInfo({\\r\\n                startTimestamp: startTimestamp,\\r\\n                endTimestamp: _endTimestamp,\\r\\n                rewardPerSec: _rewardPerSec\\r\\n            })\\r\\n        );\\r\\n\\r\\n        emit AddRewardInfo(\\r\\n            _pid,\\r\\n            rewardInfo.length - 1,\\r\\n            _endTimestamp,\\r\\n            _rewardPerSec\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function rewardInfoLen(uint256 _pid)\\r\\n    external\\r\\n    view\\r\\n    returns (uint256)\\r\\n    {\\r\\n        return poolRewardInfo[_pid].length;\\r\\n    }\\r\\n\\r\\n    function poolInfoLen() external view returns (uint256) {\\r\\n        return poolInfo.length;\\r\\n    }\\r\\n\\r\\n    // @notice this will return  end block based on the current block timestamp.\\r\\n    function currentEndTimestamp(uint256 _pid)\\r\\n    external\\r\\n    view\\r\\n    returns (uint256)\\r\\n    {\\r\\n        return _endTimestampOf(_pid, block.timestamp);\\r\\n    }\\r\\n\\r\\n    function _endTimestampOf(uint256 _pid, uint256 _timestamp)\\r\\n    internal\\r\\n    view\\r\\n    returns (uint256)\\r\\n    {\\r\\n        RewardInfo[] memory rewardInfo = poolRewardInfo[_pid];\\r\\n        uint256 len = rewardInfo.length;\\r\\n        if (len == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        for (uint256 i = 0; i < len; ++i) {\\r\\n            if (_timestamp <= rewardInfo[i].endTimestamp)\\r\\n                return rewardInfo[i].endTimestamp;\\r\\n        }\\r\\n\\r\\n        // @dev when couldn't find any reward info, it means that _blockTimestamp exceed endTimestamp\\r\\n        // so return the latest reward info.\\r\\n        return rewardInfo[len - 1].endTimestamp;\\r\\n    }\\r\\n\\r\\n    // @notice this will return reward per block based on the current block timestamp.\\r\\n    function currentRewardPerSec(uint256 _pid)\\r\\n    external\\r\\n    view\\r\\n    returns (uint256)\\r\\n    {\\r\\n        return _rewardPerSecOf(_pid, block.timestamp);\\r\\n    }\\r\\n\\r\\n    function _rewardPerSecOf(uint256 _pid, uint256 _blockTimestamp)\\r\\n    internal\\r\\n    view\\r\\n    returns (uint256)\\r\\n    {\\r\\n        RewardInfo[] memory rewardInfo = poolRewardInfo[_pid];\\r\\n        uint256 len = rewardInfo.length;\\r\\n        if (len == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        for (uint256 i = 0; i < len; ++i) {\\r\\n            if (_blockTimestamp <= rewardInfo[i].endTimestamp)\\r\\n                return rewardInfo[i].rewardPerSec;\\r\\n        }\\r\\n        // @dev when couldn't find any reward info, it means that timestamp exceed endtimestamp\\r\\n        // so return 0\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    // @notice Return reward multiplier over the given _from to _to timestamp.\\r\\n    function getMultiplier(\\r\\n        uint256 _from,\\r\\n        uint256 _to,\\r\\n        uint256 _endTimestamp\\r\\n    ) public pure returns (uint256) {\\r\\n        if ((_from >= _endTimestamp) || (_from > _to)) {\\r\\n            return 0;\\r\\n        }\\r\\n        if (_to <= _endTimestamp) {\\r\\n            return _to - _from;\\r\\n        }\\r\\n        return _endTimestamp - _from;\\r\\n    }\\r\\n\\r\\n    // @notice View function to see pending Reward on frontend.\\r\\n    function pendingReward(uint256 _pid, address _user)\\r\\n    external\\r\\n    view\\r\\n    returns (uint256)\\r\\n    {\\r\\n        return\\r\\n        _pendingReward(\\r\\n            _pid,\\r\\n            userInfo[_pid][_user].amount,\\r\\n            userInfo[_pid][_user].rewardDebt\\r\\n        );\\r\\n    }\\r\\n\\r\\n\\r\\n    function _pendingReward(\\r\\n        uint256 _pid,\\r\\n        uint256 _amount,\\r\\n        uint256 _rewardDebt\\r\\n    ) internal view returns (uint256) {\\r\\n        PoolInfo memory pool = poolInfo[_pid];\\r\\n        RewardInfo[] memory rewardInfo = poolRewardInfo[_pid];\\r\\n        uint256 accRewardPerShare = pool.accRewardPerShare;\\r\\n        if (\\r\\n            block.timestamp > pool.lastRewardTimestamp &&\\r\\n            pool.totalStaked != 0\\r\\n        ) {\\r\\n            uint256 cursor = pool.lastRewardTimestamp;\\r\\n            for (uint256 i = 0; i < rewardInfo.length; ++i) {\\r\\n                uint256 multiplier = getMultiplier(\\r\\n                    cursor,\\r\\n                    block.timestamp,\\r\\n                    rewardInfo[i].endTimestamp\\r\\n                );\\r\\n                if (multiplier == 0) continue;\\r\\n                cursor = rewardInfo[i].endTimestamp;\\r\\n                uint256 tokenReward = multiplier.mul(rewardInfo[i].rewardPerSec);\\r\\n                accRewardPerShare = accRewardPerShare.add(tokenReward.mul(pool.precision).div(pool.totalStaked));\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return uint256(_amount.mul(accRewardPerShare).div(pool.precision)).sub(_rewardDebt);\\r\\n    }\\r\\n\\r\\n    function updatePool(uint256 _pid) external nonReentrant {\\r\\n        _updatePool(_pid);\\r\\n    }\\r\\n\\r\\n    // @notice Update reward variables of the given pool to be up-to-date.\\r\\n    function _updatePool(uint256 _pid) internal {\\r\\n        PoolInfo storage pool = poolInfo[_pid];\\r\\n        RewardInfo[] memory rewardInfo = poolRewardInfo[_pid];\\r\\n        if (block.timestamp <= pool.lastRewardTimestamp) {\\r\\n            return;\\r\\n        }\\r\\n        if (pool.totalStaked == 0) {\\r\\n            // if there is no total supply, return and use the pool's start block timestamp as the last reward block timestamp\\r\\n            // so that ALL reward will be distributed.\\r\\n            // however, if the first deposit is out of reward period, last reward block will be its block timestamp\\r\\n            // in order to keep the multiplier = 0\\r\\n            if (\\r\\n                block.timestamp > _endTimestampOf(_pid, block.timestamp)\\r\\n            ) {\\r\\n                pool.lastRewardTimestamp = block.timestamp;\\r\\n            }\\r\\n            return;\\r\\n        }\\r\\n        // @dev for each reward info\\r\\n        for (uint256 i = 0; i < rewardInfo.length; ++i) {\\r\\n            // @dev get multiplier based on current Block and rewardInfo's end block\\r\\n            // multiplier will be a range of either (current block - pool.lastRewardBlock)\\r\\n            // or (reward info's endblock - pool.lastRewardTimestamp) or 0\\r\\n            uint256 multiplier = getMultiplier(\\r\\n                pool.lastRewardTimestamp,\\r\\n                block.timestamp,\\r\\n                rewardInfo[i].endTimestamp\\r\\n            );\\r\\n            if (multiplier == 0) continue;\\r\\n            // @dev if currentTimestamp exceed end block, use end block as the last reward block\\r\\n            // so that for the next iteration, previous endTimestamp will be used as the last reward block\\r\\n            if (block.timestamp > rewardInfo[i].endTimestamp) {\\r\\n                pool.lastRewardTimestamp = rewardInfo[i].endTimestamp;\\r\\n            } else {\\r\\n                pool.lastRewardTimestamp = block.timestamp;\\r\\n            }\\r\\n            uint256 tokenReward = multiplier.mul(rewardInfo[i].rewardPerSec);\\r\\n            pool.accRewardPerShare = pool.accRewardPerShare.add(tokenReward.mul(pool.precision).div(pool.totalStaked));\\r\\n        }\\r\\n        emit UpdatePoolInfo(_pid, pool.lastRewardTimestamp);\\r\\n    }\\r\\n\\r\\n    // @notice Update reward variables for all pools. gas spending is HIGH in this method call, BE CAREFUL\\r\\n    function massUpdateCampaigns() external nonReentrant {\\r\\n        uint256 length = poolInfo.length;\\r\\n        for (uint256 pid = 0; pid < length; ++pid) {\\r\\n            _updatePool(pid);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // @notice Stake Staking tokens to TokenFarm\\r\\n    function deposit(uint256 _pid, uint256 _amount)\\r\\n    external\\r\\n    nonReentrant\\r\\n    {\\r\\n        _deposit(_pid, _amount);\\r\\n    }\\r\\n\\r\\n    // @notice Stake Staking tokens to TokenFarm\\r\\n    function _deposit(uint256 _pid, uint256 _amount) internal {\\r\\n        PoolInfo storage pool = poolInfo[_pid];\\r\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\r\\n\\r\\n        _updatePool(_pid);\\r\\n\\r\\n        if (user.amount > 0) {\\r\\n            uint256 pending = uint256(user.amount.mul(pool.accRewardPerShare).div(pool.precision)).sub(user.rewardDebt);\\r\\n            if (pending > 0) {\\r\\n                pool.rewardToken.safeTransfer(address(msg.sender), pending);\\r\\n            }\\r\\n        }\\r\\n        if (_amount > 0) {\\r\\n            pool.stakingToken.safeTransferFrom(\\r\\n                address(msg.sender),\\r\\n                address(this),\\r\\n                _amount\\r\\n            );\\r\\n            user.amount = user.amount.add(_amount);\\r\\n            pool.totalStaked = pool.totalStaked.add(_amount);\\r\\n        }\\r\\n        user.rewardDebt = user.amount.mul(pool.accRewardPerShare).div(pool.precision);\\r\\n        emit Deposit(msg.sender, _amount, _pid, pool.accRewardPerShare, user.rewardDebt);\\r\\n    }\\r\\n\\r\\n    // @notice Withdraw Staking tokens from STAKING.\\r\\n    function withdraw(uint256 _pid, uint256 _amount)\\r\\n    external\\r\\n    nonReentrant\\r\\n    {\\r\\n        _withdraw(_pid, _amount);\\r\\n    }\\r\\n\\r\\n    // @notice internal method for withdraw (withdraw and harvest method depend on this method)\\r\\n    function _withdraw(uint256 _pid, uint256 _amount) internal {\\r\\n        PoolInfo storage pool = poolInfo[_pid];\\r\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\r\\n        require(user.amount >= _amount, \\\"withdraw::bad withdraw amount\\\");\\r\\n        _updatePool(_pid);\\r\\n        uint256 pending = uint256(user.amount.mul(pool.accRewardPerShare).div(pool.precision)).sub(user.rewardDebt);\\r\\n        if (pending > 0) {\\r\\n            pool.rewardToken.safeTransfer(address(msg.sender), pending);\\r\\n        }\\r\\n        if (_amount > 0) {\\r\\n            user.amount = user.amount.sub(_amount);\\r\\n            pool.stakingToken.safeTransfer(address(msg.sender), _amount);\\r\\n            pool.totalStaked = pool.totalStaked.sub(_amount);\\r\\n        }\\r\\n        user.rewardDebt = user.amount.mul(pool.accRewardPerShare).div(pool.precision);\\r\\n\\r\\n        emit Withdraw(msg.sender, _amount, _pid, pool.accRewardPerShare, user.rewardDebt);\\r\\n    }\\r\\n\\r\\n    // @notice method for harvest pools (used when the user want to claim their reward token based on specified pools)\\r\\n    function harvest(uint256 _pid) external nonReentrant {\\r\\n        _withdraw(_pid, 0);\\r\\n    }\\r\\n\\r\\n    // @notice Withdraw without caring about rewards. EMERGENCY ONLY.\\r\\n    function emergencyWithdraw(uint256 _pid) external nonReentrant {\\r\\n        PoolInfo storage pool = poolInfo[_pid];\\r\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\r\\n        uint256 _amount = user.amount;\\r\\n        pool.totalStaked = pool.totalStaked.sub(_amount);\\r\\n        user.amount = 0;\\r\\n        user.rewardDebt = 0;\\r\\n        pool.stakingToken.safeTransfer(address(msg.sender), _amount);\\r\\n        emit EmergencyWithdraw(msg.sender, _amount, _pid);\\r\\n    }\\r\\n\\r\\n    function rescueFunds(uint256 _pid, address _beneficiary) external onlyOwner {\\r\\n        PoolInfo storage pool = poolInfo[_pid];\\r\\n        uint256 amount = pool.rewardToken.balanceOf(address(this));\\r\\n        pool.rewardToken.safeTransfer(_beneficiary, amount);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/library/BoringERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../interfaces/IBoringERC20.sol\\\";\\r\\n\\r\\nlibrary BoringERC20 {\\r\\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\\r\\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\\r\\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\\r\\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\\r\\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\\r\\n\\r\\n    function returnDataToString(bytes memory data)\\r\\n    internal\\r\\n    pure\\r\\n    returns (string memory)\\r\\n    {\\r\\n        if (data.length >= 64) {\\r\\n            return abi.decode(data, (string));\\r\\n        } else if (data.length == 32) {\\r\\n            uint8 i = 0;\\r\\n            while (i < 32 && data[i] != 0) {\\r\\n                i++;\\r\\n            }\\r\\n            bytes memory bytesArray = new bytes(i);\\r\\n            for (i = 0; i < 32 && data[i] != 0; i++) {\\r\\n                bytesArray[i] = data[i];\\r\\n            }\\r\\n            return string(bytesArray);\\r\\n        } else {\\r\\n            return \\\"???\\\";\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\\r\\n    /// @param token The address of the ERC-20 token contract.\\r\\n    /// @return (string) Token symbol.\\r\\n    function safeSymbol(IBoringERC20 token)\\r\\n    internal\\r\\n    view\\r\\n    returns (string memory)\\r\\n    {\\r\\n        (bool success, bytes memory data) = address(token).staticcall(\\r\\n            abi.encodeWithSelector(SIG_SYMBOL)\\r\\n        );\\r\\n        return success ? returnDataToString(data) : \\\"???\\\";\\r\\n    }\\r\\n\\r\\n    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\\r\\n    /// @param token The address of the ERC-20 token contract.\\r\\n    /// @return (string) Token name.\\r\\n    function safeName(IBoringERC20 token)\\r\\n    internal\\r\\n    view\\r\\n    returns (string memory)\\r\\n    {\\r\\n        (bool success, bytes memory data) = address(token).staticcall(\\r\\n            abi.encodeWithSelector(SIG_NAME)\\r\\n        );\\r\\n        return success ? returnDataToString(data) : \\\"???\\\";\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\\r\\n    /// @param token The address of the ERC-20 token contract.\\r\\n    /// @return (uint8) Token decimals.\\r\\n    function safeDecimals(IBoringERC20 token) internal view returns (uint8) {\\r\\n        (bool success, bytes memory data) = address(token).staticcall(\\r\\n            abi.encodeWithSelector(SIG_DECIMALS)\\r\\n        );\\r\\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\\r\\n    }\\r\\n\\r\\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\\r\\n    /// Reverts on a failed transfer.\\r\\n    /// @param token The address of the ERC-20 token.\\r\\n    /// @param to Transfer tokens to.\\r\\n    /// @param amount The token amount.\\r\\n    function safeTransfer(\\r\\n        IBoringERC20 token,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        (bool success, bytes memory data) = address(token).call(\\r\\n            abi.encodeWithSelector(SIG_TRANSFER, to, amount)\\r\\n        );\\r\\n        require(\\r\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\r\\n            \\\"BoringERC20: Transfer failed\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\\r\\n    /// Reverts on a failed transfer.\\r\\n    /// @param token The address of the ERC-20 token.\\r\\n    /// @param from Transfer tokens from.\\r\\n    /// @param to Transfer tokens to.\\r\\n    /// @param amount The token amount.\\r\\n    function safeTransferFrom(\\r\\n        IBoringERC20 token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        (bool success, bytes memory data) = address(token).call(\\r\\n            abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount)\\r\\n        );\\r\\n        require(\\r\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\r\\n            \\\"BoringERC20: TransferFrom failed\\\"\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBoringERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IBoringERC20 {\\r\\n    function mint(address to, uint256 amount) external;\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function allowance(address owner, address spender)\\r\\n    external\\r\\n    view\\r\\n    returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n\\r\\n    /// @notice EIP 2612\\r\\n    function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"contract IBoringERC20\",\"name\":\"stakingToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IBoringERC20\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"precision\",\"type\":\"uint256\"}],\"name\":\"AddPoolInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"phase\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPerTimestamp\",\"type\":\"uint256\"}],\"name\":\"AddRewardInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pool\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accRewardPerShare\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardDebit\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pool\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardInfoLimit\",\"type\":\"uint256\"}],\"name\":\"SetRewardInfoLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lastRewardTimestamp\",\"type\":\"uint256\"}],\"name\":\"UpdatePoolInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pool\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accRewardPerShare\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardDebit\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IBoringERC20\",\"name\":\"_stakingToken\",\"type\":\"address\"},{\"internalType\":\"contract IBoringERC20\",\"name\":\"_rewardToken\",\"type\":\"address\"}],\"name\":\"addPoolInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardPerSec\",\"type\":\"uint256\"}],\"name\":\"addRewardInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"currentEndTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"currentRewardPerSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTimestamp\",\"type\":\"uint256\"}],\"name\":\"getMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massUpdateCampaigns\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"contract IBoringERC20\",\"name\":\"stakingToken\",\"type\":\"address\"},{\"internalType\":\"contract IBoringERC20\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"precision\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accRewardPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolInfoLen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolRewardInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerSec\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"rescueFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"rewardInfoLen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardInfoLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_updatedRewardInfoLimit\",\"type\":\"uint256\"}],\"name\":\"setRewardInfoLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TokenFarm", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}