{"SourceCode": "pragma solidity ^0.4.13;\r\ncontract owned {\r\n    address public owner;\r\n    mapping (address =>  bool) public admins;\r\n\r\n    function owned() {\r\n        owner = msg.sender;\r\n        admins[msg.sender]=true;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin   {\r\n        require(admins[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n    function makeAdmin(address newAdmin, bool isAdmin) onlyOwner {\r\n        admins[newAdmin] = isAdmin;\r\n    }\r\n}\r\n\r\ninterface tokenRecipient {\r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\r\n}\r\n\r\ncontract GRX is owned {\r\n    // Public variables of the token\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n    uint256 minBalanceForAccounts;\r\n    bool public usersCanTrade;\r\n    bool public usersCanUnfreeze;\r\n\r\n    bool public ico = true; //turn ico on and of\r\n    mapping (address => bool) public admin;\r\n\r\n\r\n    modifier notICO {\r\n        require(admin[msg.sender] || !ico);\r\n        _;\r\n    }\r\n\r\n\r\n    // This creates an array with all balances\r\n    mapping (address => uint256) public balanceOf;\r\n\r\n\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    mapping (address =>  bool) public frozen;\r\n\r\n    mapping (address =>  bool) public canTrade; //user allowed to buy or sell\r\n\r\n    // This generates a public event on the blockchain that will notify clients\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    //This generates a public even on the blockhcain when an address is reward\r\n    event Reward(address from, address to, uint256 value, string data, uint256 time);\r\n\r\n    // This notifies clients about the amount burnt\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    // This generates a public event on the blockchain that will notify clients\r\n    event Frozen(address indexed addr, bool frozen);\r\n\r\n    // This generates a public event on the blockchain that will notify clients\r\n    event Unlock(address indexed addr, address from, uint256 val);\r\n\r\n    // This generates a public event on the blockchain that will notify clients\r\n\r\n\r\n    // This generates a public event on the blockchain that will notify clients\r\n    // event Unfreeze(address indexed addr);\r\n\r\n    /**\r\n     * Constrctor function\r\n     *\r\n     * Initializes contract with initial supply tokens to the creator of the contract\r\n     */\r\n    function GRX() {\r\n        uint256 initialSupply = 20000000000000000000000000;\r\n        balanceOf[msg.sender] = initialSupply ;              // Give the creator all initial tokens\r\n        totalSupply = initialSupply;                        // Update total supply\r\n        name = \"Gold Reward Token\";                                   // Set the name for display purposes\r\n        symbol = \"GRX\";                               // Set the symbol for display purposes\r\n        decimals = 18;                            // Amount of decimals for display purposes\r\n        minBalanceForAccounts = 1000000000000000;\r\n        usersCanTrade=false;\r\n        usersCanUnfreeze=false;\r\n        admin[msg.sender]=true;\r\n        canTrade[msg.sender]=true;\r\n\r\n    }\r\n\r\n    /**\r\n     * Increace Total Supply\r\n     *\r\n     * Increases the total coin supply\r\n     */\r\n    function increaseTotalSupply (address target,  uint256 increaseBy )  onlyOwner {\r\n        balanceOf[target] += increaseBy;\r\n        totalSupply += increaseBy;\r\n        Transfer(0, owner, increaseBy);\r\n        Transfer(owner, target, increaseBy);\r\n    }\r\n\r\n    function  usersCanUnFreeze(bool can) {\r\n        usersCanUnfreeze=can;\r\n    }\r\n\r\n    function setMinBalance(uint minimumBalanceInWei) onlyOwner {\r\n        minBalanceForAccounts = minimumBalanceInWei;\r\n    }\r\n\r\n    /**\r\n     * transferAndFreeze\r\n     *\r\n     * Function to transfer to and freeze and account at the same time\r\n     */\r\n    function transferAndFreeze (address target,  uint256 amount )  onlyAdmin {\r\n        _transfer(msg.sender, target, amount);\r\n        freeze(target, true);\r\n    }\r\n\r\n    /**\r\n     * _freeze internal\r\n     *\r\n     * function to freeze an account\r\n     */\r\n    function _freeze (address target, bool froze )  internal  {\r\n\r\n        frozen[target]=froze;\r\n        Frozen(target, froze);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * freeze\r\n     *\r\n     * function to freeze an account\r\n     */\r\n    function freeze (address target, bool froze )   {\r\n        if(froze || (!froze && !usersCanUnfreeze)) {\r\n            require(admin[msg.sender]);\r\n        }\r\n\r\n        _freeze(target, froze);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Internal transfer, only can be called by this contract\r\n     */\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        require(_to != 0x0);                                   // Prevent transfer to 0x0 address. Use burn() instead\r\n\r\n        require(!frozen[_from]);                       //prevent transfer from frozen address\r\n        require(balanceOf[_from] >= _value);                // Check if the sender has enough\r\n        require(balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows\r\n        balanceOf[_from] -= _value;                         // Subtract from the sender\r\n        balanceOf[_to] += _value;                           // Add the same to the recipient\r\n        Transfer(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens\r\n     *\r\n     * Send `_value` tokens to `_to` from your account\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transfer(address _to, uint256 _value) notICO {\r\n        require(!frozen[msg.sender]);                       //prevent transfer from frozen address\r\n        if (msg.sender.balance  < minBalanceForAccounts) {\r\n            sell((minBalanceForAccounts - msg.sender.balance) * sellPrice);\r\n        }\r\n        _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n\r\n\r\n    mapping (address => uint256) public totalLockedRewardsOf;\r\n    mapping (address => mapping (address => uint256)) public lockedRewardsOf; //balance of a locked reward\r\n    mapping (address => mapping (uint32  => address)) public userRewarders; //indexed list of rewardees rewarder\r\n    mapping (address => mapping (address => uint32)) public userRewardCount; //a list of number of times a customer has received reward from a given merchant\r\n    mapping (address => uint32) public userRewarderCount; //number of rewarders per customer\r\n\r\n    //merchant\r\n    mapping (address =>  uint256  ) public totalRewardIssuedOut;\r\n\r\n    /**\r\n     * Reward tokens - tokens go to\r\n     *\r\n     * Send `_value` tokens to `_to` from your account\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function reward(address _to, uint256 _value, bool locked, string data) {\r\n        require(_to != 0x0);\r\n        require(!frozen[msg.sender]);                       //prevent transfer from frozen address\r\n        if (msg.sender.balance  < minBalanceForAccounts) {\r\n            sell((minBalanceForAccounts - msg.sender.balance) * sellPrice);\r\n        }\r\n        if(!locked) {\r\n            _transfer(msg.sender, _to, _value);\r\n        }else{\r\n            //prevent transfer from frozen address\r\n            require(balanceOf[msg.sender] >= _value);                // Check if the sender has enough\r\n            require(totalLockedRewardsOf[_to] + _value > totalLockedRewardsOf[_to]); // Check for overflows\r\n            balanceOf[msg.sender] -= _value;                         // Subtract from the sender\r\n            totalLockedRewardsOf[_to] += _value;                           // Add the same to the recipient\r\n            lockedRewardsOf[_to][msg.sender] += _value;\r\n            if(userRewardCount[_to][msg.sender]==0) {\r\n                userRewarderCount[_to] += 1;\r\n                userRewarders[_to][userRewarderCount[_to]]=msg.sender;\r\n            }\r\n            userRewardCount[_to][msg.sender]+=1;\r\n            totalRewardIssuedOut[msg.sender]+= _value;\r\n            Transfer(msg.sender, _to, _value);\r\n        }\r\n\r\n        Reward(msg.sender, _to, _value, data, now);\r\n    }\r\n\r\n    /**\r\n     * Transfer locked rewards\r\n     *\r\n     * Send `_value` tokens to `_to` merchant\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transferReward(address _to, uint256 _value) {\r\n        require(!frozen[msg.sender]);                       //prevent transfer from frozen address\r\n        require(lockedRewardsOf[msg.sender][_to] >= _value );\r\n        require(totalLockedRewardsOf[msg.sender] >= _value);\r\n\r\n        if (msg.sender.balance  < minBalanceForAccounts) {\r\n            sell((minBalanceForAccounts - msg.sender.balance) * sellPrice);\r\n        }\r\n        totalLockedRewardsOf[msg.sender] -= _value;                           // Add the same to the recipient\r\n        lockedRewardsOf[msg.sender][_to] -= _value;\r\n        balanceOf[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * Unlocked locked rewards by merchant\r\n     *\r\n     * Unlock `_value` tokens of `add`\r\n     *\r\n     * @param addr The address of the recipient\r\n     * @param _value the amount to unlock\r\n     */\r\n    function unlockReward(address addr, uint256 _value) {\r\n        require(totalLockedRewardsOf[addr] > _value);                       //prevent transfer from frozen address\r\n        require(lockedRewardsOf[addr][msg.sender] >= _value );\r\n        if(_value==0) _value=lockedRewardsOf[addr][msg.sender];\r\n        if (msg.sender.balance  < minBalanceForAccounts) {\r\n            sell((minBalanceForAccounts - msg.sender.balance) * sellPrice);\r\n        }\r\n        totalLockedRewardsOf[addr] -= _value;                           // Add the same to the recipient\r\n        lockedRewardsOf[addr][msg.sender] -= _value;\r\n        balanceOf[addr] += _value;\r\n        Unlock(addr, msg.sender, _value);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Transfer tokens from other address\r\n     *\r\n     * Send `_value` tokens to `_to` in behalf of `_from`\r\n     *\r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        require(!frozen[_from]);                       //prevent transfer from frozen address\r\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     */\r\n    function approve(address _spender, uint256 _value)\r\n    returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address and notify\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     * @param _extraData some extra information to send to the approved contract\r\n     */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) onlyOwner\r\n    returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly\r\n     *\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burn(uint256 _value) onlyOwner returns (bool success) {\r\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\r\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\r\n        totalSupply -= _value;                      // Updates totalSupply\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens from other ccount\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n     *\r\n     * @param _from the address of the sender\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burnFrom(address _from, uint256 _value)  returns (bool success) {\r\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\r\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n        totalSupply -= _value;                              // Update totalSupply\r\n        Burn(_from, _value);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     function increaseSupply(address _from, uint256 _value) onlyOwner  returns (bool success)  {\r\n     balanceOf[_from] += _value;                         // Subtract from the targeted balance\r\n     totalSupply += _value;                              // Update totalSupply\r\n     // Burn(_from, _value);\r\n     return true;\r\n     }\r\n     */\r\n\r\n\r\n\r\n\r\n    uint256 public sellPrice = 608;\r\n    uint256 public buyPrice = 760;\r\n\r\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {\r\n        sellPrice = newSellPrice;\r\n        buyPrice = newBuyPrice;\r\n    }\r\n    function setUsersCanTrade(bool trade) onlyOwner {\r\n        usersCanTrade=trade;\r\n    }\r\n    function setCanTrade(address addr, bool trade) onlyOwner {\r\n        canTrade[addr]=trade;\r\n    }\r\n\r\n    //user is buying grx\r\n    function buy() payable returns (uint256 amount){\r\n        if(!usersCanTrade && !canTrade[msg.sender]) revert();\r\n        amount = msg.value * buyPrice;                    // calculates the amount\r\n\r\n        require(balanceOf[this] >= amount);               // checks if it has enough to sell\r\n        balanceOf[msg.sender] += amount;                  // adds the amount to buyer's balance\r\n        balanceOf[this] -= amount;                        // subtracts amount from seller's balance\r\n        Transfer(this, msg.sender, amount);               // execute an event reflecting the change\r\n        return amount;                                    // ends function and returns\r\n    }\r\n\r\n    //user is selling us grx, we are selling eth to the user\r\n    function sell(uint256 amount) returns (uint revenue){\r\n        require(!frozen[msg.sender]);\r\n        if(!usersCanTrade && !canTrade[msg.sender]) {\r\n            require(minBalanceForAccounts > amount/sellPrice);\r\n        }\r\n        require(balanceOf[msg.sender] >= amount);         // checks if the sender has enough to sell\r\n        balanceOf[this] += amount;                        // adds the amount to owner's balance\r\n        balanceOf[msg.sender] -= amount;                  // subtracts the amount from seller's balance\r\n        revenue = amount / sellPrice;\r\n        require(msg.sender.send(revenue));                // sends ether to the seller: it's important to do this last to prevent recursion attacks\r\n        Transfer(msg.sender, this, amount);               // executes an event reflecting on the change\r\n        return revenue;                                   // ends function and returns\r\n    }\r\n\r\n    function() payable {\r\n    }\r\n    event Withdrawn(address indexed to, uint256 value);\r\n    function withdraw(address target, uint256 amount) onlyOwner {\r\n        target.transfer(amount);\r\n        Withdrawn(target, amount);\r\n    }\r\n\r\n    function setAdmin(address addr, bool enabled) onlyOwner {\r\n        admin[addr]=enabled;\r\n    }\r\n\r\n    function setICO(bool enabled) onlyOwner {\r\n        ico=enabled;\r\n    }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"newSellPrice\",\"type\":\"uint256\"},{\"name\":\"newBuyPrice\",\"type\":\"uint256\"}],\"name\":\"setPrices\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"trade\",\"type\":\"bool\"}],\"name\":\"setCanTrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"unlockReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"},{\"name\":\"isAdmin\",\"type\":\"bool\"}],\"name\":\"makeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usersCanUnfreeze\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"canTrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ico\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usersCanTrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalRewardIssuedOut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"locked\",\"type\":\"bool\"},{\"name\":\"data\",\"type\":\"string\"}],\"name\":\"reward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferAndFreeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRewarderCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalLockedRewardsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"increaseBy\",\"type\":\"uint256\"}],\"name\":\"increaseTotalSupply\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedRewardsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"froze\",\"type\":\"bool\"}],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minimumBalanceInWei\",\"type\":\"uint256\"}],\"name\":\"setMinBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"userRewarders\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"trade\",\"type\":\"bool\"}],\"name\":\"setUsersCanTrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRewardCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[{\"name\":\"revenue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"can\",\"type\":\"bool\"}],\"name\":\"usersCanUnFreeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Reward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"Frozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"Unlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"}]", "ContractName": "GRX", "CompilerVersion": "v0.4.16+commit.d7661dd9", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://521d3ab728928c5b9db45213934998adc769b6dfdc98471ce1caa759a7008089"}