{"SourceCode": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.10;\r\n\r\nlibrary ConfiguratorInputTypes {\r\n  struct InitReserveInput {\r\n    address aTokenImpl;\r\n    address stableDebtTokenImpl;\r\n    address variableDebtTokenImpl;\r\n    uint8 underlyingAssetDecimals;\r\n    address interestRateStrategyAddress;\r\n    address underlyingAsset;\r\n    address treasury;\r\n    address incentivesController;\r\n    string aTokenName;\r\n    string aTokenSymbol;\r\n    string variableDebtTokenName;\r\n    string variableDebtTokenSymbol;\r\n    string stableDebtTokenName;\r\n    string stableDebtTokenSymbol;\r\n    bytes params;\r\n  }\r\n\r\n  struct UpdateATokenInput {\r\n    address asset;\r\n    address treasury;\r\n    address incentivesController;\r\n    string name;\r\n    string symbol;\r\n    address implementation;\r\n    bytes params;\r\n  }\r\n\r\n  struct UpdateDebtTokenInput {\r\n    address asset;\r\n    address incentivesController;\r\n    string name;\r\n    string symbol;\r\n    address implementation;\r\n    bytes params;\r\n  }\r\n}\r\n\r\n/**\r\n * @title IPoolConfigurator\r\n * @author Aave\r\n * @notice Defines the basic interface for a Pool configurator.\r\n */\r\ninterface IPoolConfigurator {\r\n  /**\r\n   * @dev Emitted when a reserve is initialized.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param aToken The address of the associated aToken contract\r\n   * @param stableDebtToken The address of the associated stable rate debt token\r\n   * @param variableDebtToken The address of the associated variable rate debt token\r\n   * @param interestRateStrategyAddress The address of the interest rate strategy for the reserve\r\n   */\r\n  event ReserveInitialized(\r\n    address indexed asset,\r\n    address indexed aToken,\r\n    address stableDebtToken,\r\n    address variableDebtToken,\r\n    address interestRateStrategyAddress\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when borrowing is enabled or disabled on a reserve.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param enabled True if borrowing is enabled, false otherwise\r\n   */\r\n  event ReserveBorrowing(address indexed asset, bool enabled);\r\n\r\n  /**\r\n   * @dev Emitted when flashloans are enabled or disabled on a reserve.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param enabled True if flashloans are enabled, false otherwise\r\n   */\r\n  event ReserveFlashLoaning(address indexed asset, bool enabled);\r\n\r\n  /**\r\n   * @dev Emitted when the collateralization risk parameters for the specified asset are updated.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param ltv The loan to value of the asset when used as collateral\r\n   * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized\r\n   * @param liquidationBonus The bonus liquidators receive to liquidate this asset\r\n   */\r\n  event CollateralConfigurationChanged(\r\n    address indexed asset,\r\n    uint256 ltv,\r\n    uint256 liquidationThreshold,\r\n    uint256 liquidationBonus\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when stable rate borrowing is enabled or disabled on a reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param enabled True if stable rate borrowing is enabled, false otherwise\r\n   */\r\n  event ReserveStableRateBorrowing(address indexed asset, bool enabled);\r\n\r\n  /**\r\n   * @dev Emitted when a reserve is activated or deactivated\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param active True if reserve is active, false otherwise\r\n   */\r\n  event ReserveActive(address indexed asset, bool active);\r\n\r\n  /**\r\n   * @dev Emitted when a reserve is frozen or unfrozen\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param frozen True if reserve is frozen, false otherwise\r\n   */\r\n  event ReserveFrozen(address indexed asset, bool frozen);\r\n\r\n  /**\r\n   * @dev Emitted when a reserve is paused or unpaused\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param paused True if reserve is paused, false otherwise\r\n   */\r\n  event ReservePaused(address indexed asset, bool paused);\r\n\r\n  /**\r\n   * @dev Emitted when a reserve is dropped.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   */\r\n  event ReserveDropped(address indexed asset);\r\n\r\n  /**\r\n   * @dev Emitted when a reserve factor is updated.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param oldReserveFactor The old reserve factor, expressed in bps\r\n   * @param newReserveFactor The new reserve factor, expressed in bps\r\n   */\r\n  event ReserveFactorChanged(\r\n    address indexed asset,\r\n    uint256 oldReserveFactor,\r\n    uint256 newReserveFactor\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when the borrow cap of a reserve is updated.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param oldBorrowCap The old borrow cap\r\n   * @param newBorrowCap The new borrow cap\r\n   */\r\n  event BorrowCapChanged(address indexed asset, uint256 oldBorrowCap, uint256 newBorrowCap);\r\n\r\n  /**\r\n   * @dev Emitted when the supply cap of a reserve is updated.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param oldSupplyCap The old supply cap\r\n   * @param newSupplyCap The new supply cap\r\n   */\r\n  event SupplyCapChanged(address indexed asset, uint256 oldSupplyCap, uint256 newSupplyCap);\r\n\r\n  /**\r\n   * @dev Emitted when the liquidation protocol fee of a reserve is updated.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param oldFee The old liquidation protocol fee, expressed in bps\r\n   * @param newFee The new liquidation protocol fee, expressed in bps\r\n   */\r\n  event LiquidationProtocolFeeChanged(address indexed asset, uint256 oldFee, uint256 newFee);\r\n\r\n  /**\r\n   * @dev Emitted when the unbacked mint cap of a reserve is updated.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param oldUnbackedMintCap The old unbacked mint cap\r\n   * @param newUnbackedMintCap The new unbacked mint cap\r\n   */\r\n  event UnbackedMintCapChanged(\r\n    address indexed asset,\r\n    uint256 oldUnbackedMintCap,\r\n    uint256 newUnbackedMintCap\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when the category of an asset in eMode is changed.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param oldCategoryId The old eMode asset category\r\n   * @param newCategoryId The new eMode asset category\r\n   */\r\n  event EModeAssetCategoryChanged(address indexed asset, uint8 oldCategoryId, uint8 newCategoryId);\r\n\r\n  /**\r\n   * @dev Emitted when a new eMode category is added.\r\n   * @param categoryId The new eMode category id\r\n   * @param ltv The ltv for the asset category in eMode\r\n   * @param liquidationThreshold The liquidationThreshold for the asset category in eMode\r\n   * @param liquidationBonus The liquidationBonus for the asset category in eMode\r\n   * @param oracle The optional address of the price oracle specific for this category\r\n   * @param label A human readable identifier for the category\r\n   */\r\n  event EModeCategoryAdded(\r\n    uint8 indexed categoryId,\r\n    uint256 ltv,\r\n    uint256 liquidationThreshold,\r\n    uint256 liquidationBonus,\r\n    address oracle,\r\n    string label\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when a reserve interest strategy contract is updated.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param oldStrategy The address of the old interest strategy contract\r\n   * @param newStrategy The address of the new interest strategy contract\r\n   */\r\n  event ReserveInterestRateStrategyChanged(\r\n    address indexed asset,\r\n    address oldStrategy,\r\n    address newStrategy\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when an aToken implementation is upgraded.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param proxy The aToken proxy address\r\n   * @param implementation The new aToken implementation\r\n   */\r\n  event ATokenUpgraded(\r\n    address indexed asset,\r\n    address indexed proxy,\r\n    address indexed implementation\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when the implementation of a stable debt token is upgraded.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param proxy The stable debt token proxy address\r\n   * @param implementation The new aToken implementation\r\n   */\r\n  event StableDebtTokenUpgraded(\r\n    address indexed asset,\r\n    address indexed proxy,\r\n    address indexed implementation\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when the implementation of a variable debt token is upgraded.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param proxy The variable debt token proxy address\r\n   * @param implementation The new aToken implementation\r\n   */\r\n  event VariableDebtTokenUpgraded(\r\n    address indexed asset,\r\n    address indexed proxy,\r\n    address indexed implementation\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when the debt ceiling of an asset is set.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param oldDebtCeiling The old debt ceiling\r\n   * @param newDebtCeiling The new debt ceiling\r\n   */\r\n  event DebtCeilingChanged(address indexed asset, uint256 oldDebtCeiling, uint256 newDebtCeiling);\r\n\r\n  /**\r\n   * @dev Emitted when the the siloed borrowing state for an asset is changed.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param oldState The old siloed borrowing state\r\n   * @param newState The new siloed borrowing state\r\n   */\r\n  event SiloedBorrowingChanged(address indexed asset, bool oldState, bool newState);\r\n\r\n  /**\r\n   * @dev Emitted when the bridge protocol fee is updated.\r\n   * @param oldBridgeProtocolFee The old protocol fee, expressed in bps\r\n   * @param newBridgeProtocolFee The new protocol fee, expressed in bps\r\n   */\r\n  event BridgeProtocolFeeUpdated(uint256 oldBridgeProtocolFee, uint256 newBridgeProtocolFee);\r\n\r\n  /**\r\n   * @dev Emitted when the total premium on flashloans is updated.\r\n   * @param oldFlashloanPremiumTotal The old premium, expressed in bps\r\n   * @param newFlashloanPremiumTotal The new premium, expressed in bps\r\n   */\r\n  event FlashloanPremiumTotalUpdated(\r\n    uint128 oldFlashloanPremiumTotal,\r\n    uint128 newFlashloanPremiumTotal\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when the part of the premium that goes to protocol is updated.\r\n   * @param oldFlashloanPremiumToProtocol The old premium, expressed in bps\r\n   * @param newFlashloanPremiumToProtocol The new premium, expressed in bps\r\n   */\r\n  event FlashloanPremiumToProtocolUpdated(\r\n    uint128 oldFlashloanPremiumToProtocol,\r\n    uint128 newFlashloanPremiumToProtocol\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when the reserve is set as borrowable/non borrowable in isolation mode.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param borrowable True if the reserve is borrowable in isolation, false otherwise\r\n   */\r\n  event BorrowableInIsolationChanged(address asset, bool borrowable);\r\n  /**\r\n   * @dev Emitted when the reserve black list bitmap is updated\r\n   * @param asset The reserve\r\n   * @param bitmapBlacklist 0 represents that the reserve is borrowable for this reserve asset\r\n   */\r\n  event ReserveBlacklistBitmapChanged(address asset, uint128 bitmapBlacklist);\r\n  /**\r\n   * @notice Initializes multiple reserves.\r\n   * @param input The array of initialization parameters\r\n   */\r\n  function initReserves(ConfiguratorInputTypes.InitReserveInput[] calldata input) external;\r\n\r\n  /**\r\n   * @dev Updates the aToken implementation for the reserve.\r\n   * @param input The aToken update parameters\r\n   */\r\n  function updateAToken(ConfiguratorInputTypes.UpdateATokenInput calldata input) external;\r\n\r\n  /**\r\n   * @notice Updates the stable debt token implementation for the reserve.\r\n   * @param input The stableDebtToken update parameters\r\n   */\r\n  function updateStableDebtToken(\r\n    ConfiguratorInputTypes.UpdateDebtTokenInput calldata input\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Updates the variable debt token implementation for the asset.\r\n   * @param input The variableDebtToken update parameters\r\n   */\r\n  function updateVariableDebtToken(\r\n    ConfiguratorInputTypes.UpdateDebtTokenInput calldata input\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Configures borrowing on a reserve.\r\n   * @dev Can only be disabled (set to false) if stable borrowing is disabled\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param enabled True if borrowing needs to be enabled, false otherwise\r\n   */\r\n  function setReserveBorrowing(address asset, bool enabled) external;\r\n\r\n  /**\r\n   * @notice Configures the reserve collateralization parameters.\r\n   * @dev All the values are expressed in bps. A value of 10000, results in 100.00%\r\n   * @dev The `liquidationBonus` is always above 100%. A value of 105% means the liquidator will receive a 5% bonus\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param ltv The loan to value of the asset when used as collateral\r\n   * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized\r\n   * @param liquidationBonus The bonus liquidators receive to liquidate this asset\r\n   */\r\n  function configureReserveAsCollateral(\r\n    address asset,\r\n    uint256 ltv,\r\n    uint256 liquidationThreshold,\r\n    uint256 liquidationBonus\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Enable or disable stable rate borrowing on a reserve.\r\n   * @dev Can only be enabled (set to true) if borrowing is enabled\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param enabled True if stable rate borrowing needs to be enabled, false otherwise\r\n   */\r\n  function setReserveStableRateBorrowing(address asset, bool enabled) external;\r\n\r\n  /**\r\n   * @notice Enable or disable flashloans on a reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param enabled True if flashloans need to be enabled, false otherwise\r\n   */\r\n  function setReserveFlashLoaning(address asset, bool enabled) external;\r\n\r\n  /**\r\n   * @notice Activate or deactivate a reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param active True if the reserve needs to be active, false otherwise\r\n   */\r\n  function setReserveActive(address asset, bool active) external;\r\n\r\n  /**\r\n   * @notice Freeze or unfreeze a reserve. A frozen reserve doesn't allow any new supply, borrow\r\n   * or rate swap but allows repayments, liquidations, rate rebalances and withdrawals.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param freeze True if the reserve needs to be frozen, false otherwise\r\n   */\r\n  function setReserveFreeze(address asset, bool freeze) external;\r\n\r\n  /**\r\n   * @notice Sets the borrowable in isolation flag for the reserve.\r\n   * @dev When this flag is set to true, the asset will be borrowable against isolated collaterals and the\r\n   * borrowed amount will be accumulated in the isolated collateral's total debt exposure\r\n   * @dev Only assets of the same family (e.g. USD stablecoins) should be borrowable in isolation mode to keep\r\n   * consistency in the debt ceiling calculations\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param borrowable True if the asset should be borrowable in isolation, false otherwise\r\n   */\r\n  function setBorrowableInIsolation(address asset, bool borrowable) external;\r\n\r\n  /**\r\n   * @notice Pauses a reserve. A paused reserve does not allow any interaction (supply, borrow, repay,\r\n   * swap interest rate, liquidate, atoken transfers).\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param paused True if pausing the reserve, false if unpausing\r\n   */\r\n  function setReservePause(address asset, bool paused) external;\r\n\r\n  /**\r\n   * @notice Updates the reserve factor of a reserve.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param newReserveFactor The new reserve factor of the reserve\r\n   */\r\n  function setReserveFactor(address asset, uint256 newReserveFactor) external;\r\n\r\n  /**\r\n   * @notice Sets the interest rate strategy of a reserve.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param newRateStrategyAddress The address of the new interest strategy contract\r\n   */\r\n  function setReserveInterestRateStrategyAddress(\r\n    address asset,\r\n    address newRateStrategyAddress\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Pauses or unpauses all the protocol reserves. In the paused state all the protocol interactions\r\n   * are suspended.\r\n   * @param paused True if protocol needs to be paused, false otherwise\r\n   */\r\n  function setPoolPause(bool paused) external;\r\n\r\n  /**\r\n   * @notice Updates the borrow cap of a reserve.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param newBorrowCap The new borrow cap of the reserve\r\n   */\r\n  function setBorrowCap(address asset, uint256 newBorrowCap) external;\r\n\r\n  /**\r\n   * @notice Updates the supply cap of a reserve.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param newSupplyCap The new supply cap of the reserve\r\n   */\r\n  function setSupplyCap(address asset, uint256 newSupplyCap) external;\r\n\r\n  /**\r\n   * @notice Updates the liquidation protocol fee of reserve.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param newFee The new liquidation protocol fee of the reserve, expressed in bps\r\n   */\r\n  function setLiquidationProtocolFee(address asset, uint256 newFee) external;\r\n\r\n  /**\r\n   * @notice Updates the unbacked mint cap of reserve.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param newUnbackedMintCap The new unbacked mint cap of the reserve\r\n   */\r\n  function setUnbackedMintCap(address asset, uint256 newUnbackedMintCap) external;\r\n\r\n  /**\r\n   * @notice Assign an efficiency mode (eMode) category to asset.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param newCategoryId The new category id of the asset\r\n   */\r\n  function setAssetEModeCategory(address asset, uint8 newCategoryId) external;\r\n\r\n  /**\r\n   * @notice Adds a new efficiency mode (eMode) category.\r\n   * @dev If zero is provided as oracle address, the default asset oracles will be used to compute the overall debt and\r\n   * overcollateralization of the users using this category.\r\n   * @dev The new ltv and liquidation threshold must be greater than the base\r\n   * ltvs and liquidation thresholds of all assets within the eMode category\r\n   * @param categoryId The id of the category to be configured\r\n   * @param ltv The ltv associated with the category\r\n   * @param liquidationThreshold The liquidation threshold associated with the category\r\n   * @param liquidationBonus The liquidation bonus associated with the category\r\n   * @param oracle The oracle associated with the category\r\n   * @param label A label identifying the category\r\n   */\r\n  function setEModeCategory(\r\n    uint8 categoryId,\r\n    uint16 ltv,\r\n    uint16 liquidationThreshold,\r\n    uint16 liquidationBonus,\r\n    address oracle,\r\n    string calldata label\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Drops a reserve entirely.\r\n   * @param asset The address of the reserve to drop\r\n   */\r\n  function dropReserve(address asset) external;\r\n\r\n  /**\r\n   * @notice Updates the bridge fee collected by the protocol reserves.\r\n   * @param newBridgeProtocolFee The part of the fee sent to the protocol treasury, expressed in bps\r\n   */\r\n  function updateBridgeProtocolFee(uint256 newBridgeProtocolFee) external;\r\n\r\n  /**\r\n   * @notice Updates the total flash loan premium.\r\n   * Total flash loan premium consists of two parts:\r\n   * - A part is sent to aToken holders as extra balance\r\n   * - A part is collected by the protocol reserves\r\n   * @dev Expressed in bps\r\n   * @dev The premium is calculated on the total amount borrowed\r\n   * @param newFlashloanPremiumTotal The total flashloan premium\r\n   */\r\n  function updateFlashloanPremiumTotal(uint128 newFlashloanPremiumTotal) external;\r\n\r\n  /**\r\n   * @notice Updates the flash loan premium collected by protocol reserves\r\n   * @dev Expressed in bps\r\n   * @dev The premium to protocol is calculated on the total flashloan premium\r\n   * @param newFlashloanPremiumToProtocol The part of the flashloan premium sent to the protocol treasury\r\n   */\r\n  function updateFlashloanPremiumToProtocol(uint128 newFlashloanPremiumToProtocol) external;\r\n\r\n  /**\r\n   * @notice Sets the debt ceiling for an asset.\r\n   * @param newDebtCeiling The new debt ceiling\r\n   */\r\n  function setDebtCeiling(address asset, uint256 newDebtCeiling) external;\r\n\r\n  /**\r\n   * @notice Sets siloed borrowing for an asset\r\n   * @param siloed The new siloed borrowing state\r\n   */\r\n  function setSiloedBorrowing(address asset, bool siloed) external;\r\n\r\n  /**\r\n   * @notice Sets the bitmapBlacklist for an asset\r\n   * @param bitMapBlacklist The new bitmap\r\n   */\r\n  function setReserveBlacklistBitmap(address reserve, uint128 bitMapBlacklist) external;\r\n}\r\n\r\n/**\r\n * @title IPoolAddressesProvider\r\n * @author Aave\r\n * @notice Defines the basic interface for a Pool Addresses Provider.\r\n */\r\ninterface IPoolAddressesProvider {\r\n  /**\r\n   * @dev Emitted when the market identifier is updated.\r\n   * @param oldMarketId The old id of the market\r\n   * @param newMarketId The new id of the market\r\n   */\r\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\r\n\r\n  /**\r\n   * @dev Emitted when the pool is updated.\r\n   * @param oldAddress The old address of the Pool\r\n   * @param newAddress The new address of the Pool\r\n   */\r\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\r\n\r\n  /**\r\n   * @dev Emitted when the pool configurator is updated.\r\n   * @param oldAddress The old address of the PoolConfigurator\r\n   * @param newAddress The new address of the PoolConfigurator\r\n   */\r\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\r\n\r\n  /**\r\n   * @dev Emitted when the price oracle is updated.\r\n   * @param oldAddress The old address of the PriceOracle\r\n   * @param newAddress The new address of the PriceOracle\r\n   */\r\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\r\n\r\n  /**\r\n   * @dev Emitted when the ACL manager is updated.\r\n   * @param oldAddress The old address of the ACLManager\r\n   * @param newAddress The new address of the ACLManager\r\n   */\r\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\r\n\r\n  /**\r\n   * @dev Emitted when the ACL admin is updated.\r\n   * @param oldAddress The old address of the ACLAdmin\r\n   * @param newAddress The new address of the ACLAdmin\r\n   */\r\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\r\n\r\n  /**\r\n   * @dev Emitted when the price oracle sentinel is updated.\r\n   * @param oldAddress The old address of the PriceOracleSentinel\r\n   * @param newAddress The new address of the PriceOracleSentinel\r\n   */\r\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\r\n\r\n  /**\r\n   * @dev Emitted when the pool data provider is updated.\r\n   * @param oldAddress The old address of the PoolDataProvider\r\n   * @param newAddress The new address of the PoolDataProvider\r\n   */\r\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\r\n\r\n  /**\r\n   * @dev Emitted when a new proxy is created.\r\n   * @param id The identifier of the proxy\r\n   * @param proxyAddress The address of the created proxy contract\r\n   * @param implementationAddress The address of the implementation contract\r\n   */\r\n  event ProxyCreated(\r\n    bytes32 indexed id,\r\n    address indexed proxyAddress,\r\n    address indexed implementationAddress\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when a new non-proxied contract address is registered.\r\n   * @param id The identifier of the contract\r\n   * @param oldAddress The address of the old contract\r\n   * @param newAddress The address of the new contract\r\n   */\r\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\r\n\r\n  /**\r\n   * @dev Emitted when the implementation of the proxy registered with id is updated\r\n   * @param id The identifier of the contract\r\n   * @param proxyAddress The address of the proxy contract\r\n   * @param oldImplementationAddress The address of the old implementation contract\r\n   * @param newImplementationAddress The address of the new implementation contract\r\n   */\r\n  event AddressSetAsProxy(\r\n    bytes32 indexed id,\r\n    address indexed proxyAddress,\r\n    address oldImplementationAddress,\r\n    address indexed newImplementationAddress\r\n  );\r\n\r\n  /**\r\n   * @notice Returns the id of the Aave market to which this contract points to.\r\n   * @return The market id\r\n   */\r\n  function getMarketId() external view returns (string memory);\r\n\r\n  /**\r\n   * @notice Associates an id with a specific PoolAddressesProvider.\r\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\r\n   * identify and validate multiple Aave markets.\r\n   * @param newMarketId The market id\r\n   */\r\n  function setMarketId(string calldata newMarketId) external;\r\n\r\n  /**\r\n   * @notice Returns an address by its identifier.\r\n   * @dev The returned address might be an EOA or a contract, potentially proxied\r\n   * @dev It returns ZERO if there is no registered address with the given id\r\n   * @param id The id\r\n   * @return The address of the registered for the specified id\r\n   */\r\n  function getAddress(bytes32 id) external view returns (address);\r\n\r\n  /**\r\n   * @notice General function to update the implementation of a proxy registered with\r\n   * certain `id`. If there is no proxy registered, it will instantiate one and\r\n   * set as implementation the `newImplementationAddress`.\r\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\r\n   * setter function, in order to avoid unexpected consequences\r\n   * @param id The id\r\n   * @param newImplementationAddress The address of the new implementation\r\n   */\r\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\r\n\r\n  /**\r\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\r\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\r\n   * @param id The id\r\n   * @param newAddress The address to set\r\n   */\r\n  function setAddress(bytes32 id, address newAddress) external;\r\n\r\n  /**\r\n   * @notice Returns the address of the Pool proxy.\r\n   * @return The Pool proxy address\r\n   */\r\n  function getPool() external view returns (address);\r\n\r\n  /**\r\n   * @notice Updates the implementation of the Pool, or creates a proxy\r\n   * setting the new `pool` implementation when the function is called for the first time.\r\n   * @param newPoolImpl The new Pool implementation\r\n   */\r\n  function setPoolImpl(address newPoolImpl) external;\r\n\r\n  /**\r\n   * @notice Returns the address of the PoolConfigurator proxy.\r\n   * @return The PoolConfigurator proxy address\r\n   */\r\n  function getPoolConfigurator() external view returns (address);\r\n\r\n  /**\r\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\r\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\r\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\r\n   */\r\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\r\n\r\n  /**\r\n   * @notice Returns the address of the price oracle.\r\n   * @return The address of the PriceOracle\r\n   */\r\n  function getPriceOracle() external view returns (address);\r\n\r\n  /**\r\n   * @notice Updates the address of the price oracle.\r\n   * @param newPriceOracle The address of the new PriceOracle\r\n   */\r\n  function setPriceOracle(address newPriceOracle) external;\r\n\r\n  /**\r\n   * @notice Returns the address of the ACL manager.\r\n   * @return The address of the ACLManager\r\n   */\r\n  function getACLManager() external view returns (address);\r\n\r\n  /**\r\n   * @notice Updates the address of the ACL manager.\r\n   * @param newAclManager The address of the new ACLManager\r\n   */\r\n  function setACLManager(address newAclManager) external;\r\n\r\n  /**\r\n   * @notice Returns the address of the ACL admin.\r\n   * @return The address of the ACL admin\r\n   */\r\n  function getACLAdmin() external view returns (address);\r\n\r\n  /**\r\n   * @notice Updates the address of the ACL admin.\r\n   * @param newAclAdmin The address of the new ACL admin\r\n   */\r\n  function setACLAdmin(address newAclAdmin) external;\r\n\r\n  /**\r\n   * @notice Returns the address of the price oracle sentinel.\r\n   * @return The address of the PriceOracleSentinel\r\n   */\r\n  function getPriceOracleSentinel() external view returns (address);\r\n\r\n  /**\r\n   * @notice Updates the address of the price oracle sentinel.\r\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\r\n   */\r\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\r\n\r\n  /**\r\n   * @notice Returns the address of the data provider.\r\n   * @return The address of the DataProvider\r\n   */\r\n  function getPoolDataProvider() external view returns (address);\r\n\r\n  /**\r\n   * @notice Updates the address of the data provider.\r\n   * @param newDataProvider The address of the new DataProvider\r\n   */\r\n  function setPoolDataProvider(address newDataProvider) external;\r\n}\r\n\r\nlibrary DataTypes {\r\n  struct ReserveData {\r\n    //stores the reserve configuration\r\n    ReserveConfigurationMap configuration;\r\n    //the liquidity index. Expressed in ray\r\n    uint128 liquidityIndex;\r\n    //the current supply rate. Expressed in ray\r\n    uint128 currentLiquidityRate;\r\n    //variable borrow index. Expressed in ray\r\n    uint128 variableBorrowIndex;\r\n    //the current variable borrow rate. Expressed in ray\r\n    uint128 currentVariableBorrowRate;\r\n    //the current stable borrow rate. Expressed in ray\r\n    uint128 currentStableBorrowRate;\r\n    //timestamp of last update\r\n    uint40 lastUpdateTimestamp;\r\n    //the id of the reserve. Represents the position in the list of the active reserves\r\n    uint16 id;\r\n    //aToken address\r\n    address aTokenAddress;\r\n    //stableDebtToken address\r\n    address stableDebtTokenAddress;\r\n    //variableDebtToken address\r\n    address variableDebtTokenAddress;\r\n    //address of the interest rate strategy\r\n    address interestRateStrategyAddress;\r\n    //the current treasury balance, scaled\r\n    uint128 accruedToTreasury;\r\n    //the outstanding unbacked aTokens minted through the bridging feature\r\n    uint128 unbacked;\r\n    //the outstanding debt borrowed against this asset in isolation mode\r\n    uint128 isolationModeTotalDebt;\r\n    // the blacklist bitmap\r\n    uint128 blacklistBitmap;\r\n  }\r\n\r\n  struct ReserveConfigurationMap {\r\n    //bit 0-15: LTV\r\n    //bit 16-31: Liq. threshold\r\n    //bit 32-47: Liq. bonus\r\n    //bit 48-55: Decimals\r\n    //bit 56: reserve is active\r\n    //bit 57: reserve is frozen\r\n    //bit 58: borrowing is enabled\r\n    //bit 59: stable rate borrowing enabled\r\n    //bit 60: asset is paused\r\n    //bit 61: borrowing in isolation mode is enabled\r\n    //bit 62-63: reserved\r\n    //bit 64-79: reserve factor\r\n    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\r\n    //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\r\n    //bit 152-167 liquidation protocol fee\r\n    //bit 168-175 eMode category\r\n    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\r\n    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\r\n    //bit 252-255 unused\r\n\r\n    uint256 data;\r\n  }\r\n\r\n  struct UserConfigurationMap {\r\n    /**\r\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\r\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\r\n     * asset is borrowed by the user.\r\n     */\r\n    uint256 data;\r\n  }\r\n\r\n  struct EModeCategory {\r\n    // each eMode category has a custom ltv and liquidation threshold\r\n    uint16 ltv;\r\n    uint16 liquidationThreshold;\r\n    uint16 liquidationBonus;\r\n    // each eMode category may or may not have a custom oracle to override the individual assets price oracles\r\n    address priceSource;\r\n    string label;\r\n  }\r\n\r\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\r\n\r\n  struct ReserveCache {\r\n    uint256 currScaledVariableDebt;\r\n    uint256 nextScaledVariableDebt;\r\n    uint256 currPrincipalStableDebt;\r\n    uint256 currAvgStableBorrowRate;\r\n    uint256 currTotalStableDebt;\r\n    uint256 nextAvgStableBorrowRate;\r\n    uint256 nextTotalStableDebt;\r\n    uint256 currLiquidityIndex;\r\n    uint256 nextLiquidityIndex;\r\n    uint256 currVariableBorrowIndex;\r\n    uint256 nextVariableBorrowIndex;\r\n    uint256 currLiquidityRate;\r\n    uint256 currVariableBorrowRate;\r\n    uint256 reserveFactor;\r\n    ReserveConfigurationMap reserveConfiguration;\r\n    address aTokenAddress;\r\n    address stableDebtTokenAddress;\r\n    address variableDebtTokenAddress;\r\n    uint40 reserveLastUpdateTimestamp;\r\n    uint40 stableDebtLastUpdateTimestamp;\r\n  }\r\n\r\n  struct ExecuteLiquidationCallParams {\r\n    uint256 reservesCount;\r\n    uint256 debtToCover;\r\n    address collateralAsset;\r\n    address debtAsset;\r\n    address user;\r\n    bool receiveAToken;\r\n    address priceOracle;\r\n    uint8 userEModeCategory;\r\n    address priceOracleSentinel;\r\n  }\r\n\r\n  struct ExecuteSupplyParams {\r\n    address asset;\r\n    uint256 amount;\r\n    address onBehalfOf;\r\n    uint16 referralCode;\r\n  }\r\n\r\n  struct ExecuteBorrowParams {\r\n    address asset;\r\n    address user;\r\n    address onBehalfOf;\r\n    uint256 amount;\r\n    InterestRateMode interestRateMode;\r\n    uint16 referralCode;\r\n    bool releaseUnderlying;\r\n    uint256 maxStableRateBorrowSizePercent;\r\n    uint256 reservesCount;\r\n    address oracle;\r\n    uint8 userEModeCategory;\r\n    address priceOracleSentinel;\r\n  }\r\n\r\n  struct ExecuteRepayParams {\r\n    address asset;\r\n    uint256 amount;\r\n    InterestRateMode interestRateMode;\r\n    address onBehalfOf;\r\n    bool useATokens;\r\n  }\r\n\r\n  struct ExecuteWithdrawParams {\r\n    address asset;\r\n    uint256 amount;\r\n    address to;\r\n    uint256 reservesCount;\r\n    address oracle;\r\n    uint8 userEModeCategory;\r\n  }\r\n\r\n  struct ExecuteSetUserEModeParams {\r\n    uint256 reservesCount;\r\n    address oracle;\r\n    uint8 categoryId;\r\n  }\r\n\r\n  struct FinalizeTransferParams {\r\n    address asset;\r\n    address from;\r\n    address to;\r\n    uint256 amount;\r\n    uint256 balanceFromBefore;\r\n    uint256 balanceToBefore;\r\n    uint256 reservesCount;\r\n    address oracle;\r\n    uint8 fromEModeCategory;\r\n  }\r\n\r\n  struct FlashloanParams {\r\n    address receiverAddress;\r\n    address[] assets;\r\n    uint256[] amounts;\r\n    uint256[] interestRateModes;\r\n    address onBehalfOf;\r\n    bytes params;\r\n    uint16 referralCode;\r\n    uint256 flashLoanPremiumToProtocol;\r\n    uint256 flashLoanPremiumTotal;\r\n    uint256 maxStableRateBorrowSizePercent;\r\n    uint256 reservesCount;\r\n    address addressesProvider;\r\n    uint8 userEModeCategory;\r\n    bool isAuthorizedFlashBorrower;\r\n  }\r\n\r\n  struct FlashloanSimpleParams {\r\n    address receiverAddress;\r\n    address asset;\r\n    uint256 amount;\r\n    bytes params;\r\n    uint16 referralCode;\r\n    uint256 flashLoanPremiumToProtocol;\r\n    uint256 flashLoanPremiumTotal;\r\n  }\r\n\r\n  struct FlashLoanRepaymentParams {\r\n    uint256 amount;\r\n    uint256 totalPremium;\r\n    uint256 flashLoanPremiumToProtocol;\r\n    address asset;\r\n    address receiverAddress;\r\n    uint16 referralCode;\r\n  }\r\n\r\n  struct CalculateUserAccountDataParams {\r\n    UserConfigurationMap userConfig;\r\n    uint256 reservesCount;\r\n    address user;\r\n    address oracle;\r\n    uint8 userEModeCategory;\r\n  }\r\n\r\n  struct ValidateBorrowParams {\r\n    ReserveCache reserveCache;\r\n    UserConfigurationMap userConfig;\r\n    address asset;\r\n    address userAddress;\r\n    uint256 amount;\r\n    InterestRateMode interestRateMode;\r\n    uint256 maxStableLoanPercent;\r\n    uint256 reservesCount;\r\n    address oracle;\r\n    uint8 userEModeCategory;\r\n    address priceOracleSentinel;\r\n    bool isolationModeActive;\r\n    address isolationModeCollateralAddress;\r\n    uint256 isolationModeDebtCeiling;\r\n  }\r\n\r\n  struct ValidateLiquidationCallParams {\r\n    ReserveCache debtReserveCache;\r\n    uint256 totalDebt;\r\n    uint256 healthFactor;\r\n    address priceOracleSentinel;\r\n  }\r\n\r\n  struct CalculateInterestRatesParams {\r\n    uint256 unbacked;\r\n    uint256 liquidityAdded;\r\n    uint256 liquidityTaken;\r\n    uint256 totalStableDebt;\r\n    uint256 totalVariableDebt;\r\n    uint256 averageStableBorrowRate;\r\n    uint256 reserveFactor;\r\n    address reserve;\r\n    address aToken;\r\n  }\r\n\r\n  struct InitReserveParams {\r\n    address asset;\r\n    address aTokenAddress;\r\n    address stableDebtAddress;\r\n    address variableDebtAddress;\r\n    address interestRateStrategyAddress;\r\n    uint16 reservesCount;\r\n    uint16 maxNumberReserves;\r\n  }\r\n}\r\n\r\n/**\r\n * @title IPool\r\n * @author Aave\r\n * @notice Defines the basic interface for an Aave Pool.\r\n */\r\ninterface IPool {\r\n  /**\r\n   * @dev Emitted on mintUnbacked()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address initiating the supply\r\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\r\n   * @param amount The amount of supplied assets\r\n   * @param referralCode The referral code used\r\n   */\r\n  event MintUnbacked(\r\n    address indexed reserve,\r\n    address user,\r\n    address indexed onBehalfOf,\r\n    uint256 amount,\r\n    uint16 indexed referralCode\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted on backUnbacked()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param backer The address paying for the backing\r\n   * @param amount The amount added as backing\r\n   * @param fee The amount paid in fees\r\n   */\r\n  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\r\n\r\n  /**\r\n   * @dev Emitted on supply()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address initiating the supply\r\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\r\n   * @param amount The amount supplied\r\n   * @param referralCode The referral code used\r\n   */\r\n  event Supply(\r\n    address indexed reserve,\r\n    address user,\r\n    address indexed onBehalfOf,\r\n    uint256 amount,\r\n    uint16 indexed referralCode\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted on withdraw()\r\n   * @param reserve The address of the underlying asset being withdrawn\r\n   * @param user The address initiating the withdrawal, owner of aTokens\r\n   * @param to The address that will receive the underlying\r\n   * @param amount The amount to be withdrawn\r\n   */\r\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\r\n\r\n  /**\r\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\r\n   * @param reserve The address of the underlying asset being borrowed\r\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\r\n   * initiator of the transaction on flashLoan()\r\n   * @param onBehalfOf The address that will be getting the debt\r\n   * @param amount The amount borrowed out\r\n   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\r\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\r\n   * @param referralCode The referral code used\r\n   */\r\n  event Borrow(\r\n    address indexed reserve,\r\n    address user,\r\n    address indexed onBehalfOf,\r\n    uint256 amount,\r\n    DataTypes.InterestRateMode interestRateMode,\r\n    uint256 borrowRate,\r\n    uint16 indexed referralCode\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted on repay()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The beneficiary of the repayment, getting his debt reduced\r\n   * @param repayer The address of the user initiating the repay(), providing the funds\r\n   * @param amount The amount repaid\r\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\r\n   */\r\n  event Repay(\r\n    address indexed reserve,\r\n    address indexed user,\r\n    address indexed repayer,\r\n    uint256 amount,\r\n    bool useATokens\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted on swapBorrowRateMode()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address of the user swapping his rate mode\r\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\r\n   */\r\n  event SwapBorrowRateMode(\r\n    address indexed reserve,\r\n    address indexed user,\r\n    DataTypes.InterestRateMode interestRateMode\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param totalDebt The total isolation mode debt for the reserve\r\n   */\r\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\r\n\r\n  /**\r\n   * @dev Emitted when the user selects a certain asset category for eMode\r\n   * @param user The address of the user\r\n   * @param categoryId The category id\r\n   */\r\n  event UserEModeSet(address indexed user, uint8 categoryId);\r\n\r\n  /**\r\n   * @dev Emitted on setUserUseReserveAsCollateral()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address of the user enabling the usage as collateral\r\n   */\r\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\r\n\r\n  /**\r\n   * @dev Emitted on setUserUseReserveAsCollateral()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address of the user enabling the usage as collateral\r\n   */\r\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\r\n\r\n  /**\r\n   * @dev Emitted on rebalanceStableBorrowRate()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address of the user for which the rebalance has been executed\r\n   */\r\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\r\n\r\n  /**\r\n   * @dev Emitted on flashLoan()\r\n   * @param target The address of the flash loan receiver contract\r\n   * @param initiator The address initiating the flash loan\r\n   * @param asset The address of the asset being flash borrowed\r\n   * @param amount The amount flash borrowed\r\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\r\n   * @param premium The fee flash borrowed\r\n   * @param referralCode The referral code used\r\n   */\r\n  event FlashLoan(\r\n    address indexed target,\r\n    address initiator,\r\n    address indexed asset,\r\n    uint256 amount,\r\n    DataTypes.InterestRateMode interestRateMode,\r\n    uint256 premium,\r\n    uint16 indexed referralCode\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when a borrower is liquidated.\r\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n   * @param user The address of the borrower getting liquidated\r\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\r\n   * @param liquidator The address of the liquidator\r\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n   * to receive the underlying collateral asset directly\r\n   */\r\n  event LiquidationCall(\r\n    address indexed collateralAsset,\r\n    address indexed debtAsset,\r\n    address indexed user,\r\n    uint256 debtToCover,\r\n    uint256 liquidatedCollateralAmount,\r\n    address liquidator,\r\n    bool receiveAToken\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when the state of a reserve is updated.\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param liquidityRate The next liquidity rate\r\n   * @param stableBorrowRate The next stable borrow rate\r\n   * @param variableBorrowRate The next variable borrow rate\r\n   * @param liquidityIndex The next liquidity index\r\n   * @param variableBorrowIndex The next variable borrow index\r\n   */\r\n  event ReserveDataUpdated(\r\n    address indexed reserve,\r\n    uint256 liquidityRate,\r\n    uint256 stableBorrowRate,\r\n    uint256 variableBorrowRate,\r\n    uint256 liquidityIndex,\r\n    uint256 variableBorrowIndex\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\r\n   * @param reserve The address of the reserve\r\n   * @param amountMinted The amount minted to the treasury\r\n   */\r\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\r\n\r\n  /**\r\n   * @notice Mints an `amount` of aTokens to the `onBehalfOf`\r\n   * @param asset The address of the underlying asset to mint\r\n   * @param amount The amount to mint\r\n   * @param onBehalfOf The address that will receive the aTokens\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   */\r\n  function mintUnbacked(\r\n    address asset,\r\n    uint256 amount,\r\n    address onBehalfOf,\r\n    uint16 referralCode\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Back the current unbacked underlying with `amount` and pay `fee`.\r\n   * @param asset The address of the underlying asset to back\r\n   * @param amount The amount to back\r\n   * @param fee The amount paid in fees\r\n   * @return The backed amount\r\n   */\r\n  function backUnbacked(address asset, uint256 amount, uint256 fee) external returns (uint256);\r\n\r\n  /**\r\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\r\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\r\n   * @param asset The address of the underlying asset to supply\r\n   * @param amount The amount to be supplied\r\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n   *   is a different wallet\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   */\r\n  function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\r\n\r\n  /**\r\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\r\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\r\n   * @param asset The address of the underlying asset to supply\r\n   * @param amount The amount to be supplied\r\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n   *   is a different wallet\r\n   * @param deadline The deadline timestamp that the permit is valid\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   * @param permitV The V parameter of ERC712 permit sig\r\n   * @param permitR The R parameter of ERC712 permit sig\r\n   * @param permitS The S parameter of ERC712 permit sig\r\n   */\r\n  function supplyWithPermit(\r\n    address asset,\r\n    uint256 amount,\r\n    address onBehalfOf,\r\n    uint16 referralCode,\r\n    uint256 deadline,\r\n    uint8 permitV,\r\n    bytes32 permitR,\r\n    bytes32 permitS\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\r\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\r\n   * @param asset The address of the underlying asset to withdraw\r\n   * @param amount The underlying amount to be withdrawn\r\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\r\n   * @param to The address that will receive the underlying, same as msg.sender if the user\r\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\r\n   *   different wallet\r\n   * @return The final amount withdrawn\r\n   */\r\n  function withdraw(address asset, uint256 amount, address to) external returns (uint256);\r\n\r\n  /**\r\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\r\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\r\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\r\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\r\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\r\n   * @param asset The address of the underlying asset to borrow\r\n   * @param amount The amount to be borrowed\r\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\r\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\r\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\r\n   * if he has been given credit delegation allowance\r\n   */\r\n  function borrow(\r\n    address asset,\r\n    uint256 amount,\r\n    uint256 interestRateMode,\r\n    uint16 referralCode,\r\n    address onBehalfOf\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\r\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\r\n   * @param asset The address of the borrowed underlying asset previously borrowed\r\n   * @param amount The amount to repay\r\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\r\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\r\n   * other borrower whose debt should be removed\r\n   * @return The final amount repaid\r\n   */\r\n  function repay(\r\n    address asset,\r\n    uint256 amount,\r\n    uint256 interestRateMode,\r\n    address onBehalfOf\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\r\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\r\n   * @param asset The address of the borrowed underlying asset previously borrowed\r\n   * @param amount The amount to repay\r\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\r\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\r\n   * other borrower whose debt should be removed\r\n   * @param deadline The deadline timestamp that the permit is valid\r\n   * @param permitV The V parameter of ERC712 permit sig\r\n   * @param permitR The R parameter of ERC712 permit sig\r\n   * @param permitS The S parameter of ERC712 permit sig\r\n   * @return The final amount repaid\r\n   */\r\n  function repayWithPermit(\r\n    address asset,\r\n    uint256 amount,\r\n    uint256 interestRateMode,\r\n    address onBehalfOf,\r\n    uint256 deadline,\r\n    uint8 permitV,\r\n    bytes32 permitR,\r\n    bytes32 permitS\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\r\n   * equivalent debt tokens\r\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\r\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\r\n   * balance is not enough to cover the whole debt\r\n   * @param asset The address of the borrowed underlying asset previously borrowed\r\n   * @param amount The amount to repay\r\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n   * @return The final amount repaid\r\n   */\r\n  function repayWithATokens(\r\n    address asset,\r\n    uint256 amount,\r\n    uint256 interestRateMode\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\r\n   * @param asset The address of the underlying asset borrowed\r\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\r\n   */\r\n  function swapBorrowRateMode(address asset, uint256 interestRateMode) external;\r\n\r\n  /**\r\n   * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\r\n   * - Users can be rebalanced if the following conditions are satisfied:\r\n   *     1. Usage ratio is above 95%\r\n   *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\r\n   *        much has been borrowed at a stable rate and suppliers are not earning enough\r\n   * @param asset The address of the underlying asset borrowed\r\n   * @param user The address of the user to be rebalanced\r\n   */\r\n  function rebalanceStableBorrowRate(address asset, address user) external;\r\n\r\n  /**\r\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\r\n   * @param asset The address of the underlying asset supplied\r\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\r\n   */\r\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\r\n\r\n  /**\r\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\r\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\r\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\r\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n   * @param user The address of the borrower getting liquidated\r\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n   * to receive the underlying collateral asset directly\r\n   */\r\n  function liquidationCall(\r\n    address collateralAsset,\r\n    address debtAsset,\r\n    address user,\r\n    uint256 debtToCover,\r\n    bool receiveAToken\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\r\n   * as long as the amount taken plus a fee is returned.\r\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\r\n   * into consideration. For further details please visit https://docs.aave.com/developers/\r\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\r\n   * @param assets The addresses of the assets being flash-borrowed\r\n   * @param amounts The amounts of the assets being flash-borrowed\r\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\r\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\r\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\r\n   * @param params Variadic packed params to pass to the receiver as extra information\r\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   */\r\n  function flashLoan(\r\n    address receiverAddress,\r\n    address[] calldata assets,\r\n    uint256[] calldata amounts,\r\n    uint256[] calldata interestRateModes,\r\n    address onBehalfOf,\r\n    bytes calldata params,\r\n    uint16 referralCode\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\r\n   * as long as the amount taken plus a fee is returned.\r\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\r\n   * into consideration. For further details please visit https://docs.aave.com/developers/\r\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\r\n   * @param asset The address of the asset being flash-borrowed\r\n   * @param amount The amount of the asset being flash-borrowed\r\n   * @param params Variadic packed params to pass to the receiver as extra information\r\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   */\r\n  function flashLoanSimple(\r\n    address receiverAddress,\r\n    address asset,\r\n    uint256 amount,\r\n    bytes calldata params,\r\n    uint16 referralCode\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Returns the user account data across all the reserves\r\n   * @param user The address of the user\r\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\r\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\r\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\r\n   * @return currentLiquidationThreshold The liquidation threshold of the user\r\n   * @return ltv The loan to value of The user\r\n   * @return healthFactor The current health factor of the user\r\n   */\r\n  function getUserAccountData(\r\n    address user\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint256 totalCollateralBase,\r\n      uint256 totalDebtBase,\r\n      uint256 availableBorrowsBase,\r\n      uint256 currentLiquidationThreshold,\r\n      uint256 ltv,\r\n      uint256 healthFactor\r\n    );\r\n\r\n  /**\r\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\r\n   * interest rate strategy\r\n   * @dev Only callable by the PoolConfigurator contract\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\r\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\r\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\r\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\r\n   */\r\n  function initReserve(\r\n    address asset,\r\n    address aTokenAddress,\r\n    address stableDebtAddress,\r\n    address variableDebtAddress,\r\n    address interestRateStrategyAddress\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Drop a reserve\r\n   * @dev Only callable by the PoolConfigurator contract\r\n   * @param asset The address of the underlying asset of the reserve\r\n   */\r\n  function dropReserve(address asset) external;\r\n\r\n  /**\r\n   * @notice Updates the address of the interest rate strategy contract\r\n   * @dev Only callable by the PoolConfigurator contract\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param rateStrategyAddress The address of the interest rate strategy contract\r\n   */\r\n  function setReserveInterestRateStrategyAddress(\r\n    address asset,\r\n    address rateStrategyAddress\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Sets the configuration bitmap of the reserve as a whole\r\n   * @dev Only callable by the PoolConfigurator contract\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param configuration The new configuration bitmap\r\n   */\r\n  function setConfiguration(\r\n    address asset,\r\n    DataTypes.ReserveConfigurationMap calldata configuration\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Returns the configuration of the reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The configuration of the reserve\r\n   */\r\n  function getConfiguration(\r\n    address asset\r\n  ) external view returns (DataTypes.ReserveConfigurationMap memory);\r\n\r\n  /**\r\n   * @notice Returns the configuration of the user across all the reserves\r\n   * @param user The user address\r\n   * @return The configuration of the user\r\n   */\r\n  function getUserConfiguration(\r\n    address user\r\n  ) external view returns (DataTypes.UserConfigurationMap memory);\r\n\r\n  /**\r\n   * @notice Returns the normalized income of the reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The reserve's normalized income\r\n   */\r\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the normalized variable debt per unit of asset\r\n   * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\r\n   * \"dynamic\" variable index based on time, current stored index and virtual rate at the current\r\n   * moment (approx. a borrower would get if opening a position). This means that is always used in\r\n   * combination with variable debt supply/balances.\r\n   * If using this function externally, consider that is possible to have an increasing normalized\r\n   * variable debt that is not equivalent to how the variable debt index would be updated in storage\r\n   * (e.g. only updates with non-zero variable debt supply)\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The reserve normalized variable debt\r\n   */\r\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the state and configuration of the reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The state and configuration data of the reserve\r\n   */\r\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\r\n\r\n  /**\r\n   * @notice Validates and finalizes an aToken transfer\r\n   * @dev Only callable by the overlying aToken of the `asset`\r\n   * @param asset The address of the underlying asset of the aToken\r\n   * @param from The user from which the aTokens are transferred\r\n   * @param to The user receiving the aTokens\r\n   * @param amount The amount being transferred/withdrawn\r\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\r\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\r\n   */\r\n  function finalizeTransfer(\r\n    address asset,\r\n    address from,\r\n    address to,\r\n    uint256 amount,\r\n    uint256 balanceFromBefore,\r\n    uint256 balanceToBefore\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Returns the list of the underlying assets of all the initialized reserves\r\n   * @dev It does not include dropped reserves\r\n   * @return The addresses of the underlying assets of the initialized reserves\r\n   */\r\n  function getReservesList() external view returns (address[] memory);\r\n\r\n  /**\r\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\r\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\r\n   * @return The address of the reserve associated with id\r\n   */\r\n  function getReserveAddressById(uint16 id) external view returns (address);\r\n\r\n  /**\r\n   * @notice Returns the PoolAddressesProvider connected to this contract\r\n   * @return The address of the PoolAddressesProvider\r\n   */\r\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\r\n\r\n  /**\r\n   * @notice Updates the protocol fee on the bridging\r\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\r\n   */\r\n  function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\r\n\r\n  /**\r\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\r\n   * - A part is sent to aToken holders as extra, one time accumulated interest\r\n   * - A part is collected by the protocol treasury\r\n   * @dev The total premium is calculated on the total borrowed amount\r\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\r\n   * @dev Only callable by the PoolConfigurator contract\r\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\r\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\r\n   */\r\n  function updateFlashloanPremiums(\r\n    uint128 flashLoanPremiumTotal,\r\n    uint128 flashLoanPremiumToProtocol\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Configures a new category for the eMode.\r\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\r\n   * The category 0 is reserved as it's the default for volatile assets\r\n   * @param id The id of the category\r\n   * @param config The configuration of the category\r\n   */\r\n  function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;\r\n\r\n  /**\r\n   * @notice Returns the data of an eMode category\r\n   * @param id The id of the category\r\n   * @return The configuration data of the category\r\n   */\r\n  function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);\r\n\r\n  /**\r\n   * @notice Allows a user to use the protocol in eMode\r\n   * @param categoryId The id of the category\r\n   */\r\n  function setUserEMode(uint8 categoryId) external;\r\n\r\n  /**\r\n   * @notice Returns the eMode the user is using\r\n   * @param user The address of the user\r\n   * @return The eMode id\r\n   */\r\n  function getUserEMode(address user) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Resets the isolation mode total debt of the given asset to zero\r\n   * @dev It requires the given asset has zero debt ceiling\r\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\r\n   */\r\n  function resetIsolationModeTotalDebt(address asset) external;\r\n\r\n  /**\r\n   * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\r\n   * @return The percentage of available liquidity to borrow, expressed in bps\r\n   */\r\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the total fee on flash loans\r\n   * @return The total fee on flashloans\r\n   */\r\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\r\n\r\n  /**\r\n   * @notice Returns the part of the bridge fees sent to protocol\r\n   * @return The bridge fee sent to the protocol treasury\r\n   */\r\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the part of the flashloan fees sent to protocol\r\n   * @return The flashloan fee sent to the protocol treasury\r\n   */\r\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\r\n\r\n  /**\r\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\r\n   * @return The maximum number of reserves supported\r\n   */\r\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\r\n\r\n  /**\r\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\r\n   * @param assets The list of reserves for which the minting needs to be executed\r\n   */\r\n  function mintToTreasury(address[] calldata assets) external;\r\n\r\n  /**\r\n   * @notice Rescue and transfer tokens locked in this contract\r\n   * @param token The address of the token\r\n   * @param to The address of the recipient\r\n   * @param amount The amount of token to transfer\r\n   */\r\n  function rescueTokens(address token, address to, uint256 amount) external;\r\n\r\n  /**\r\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\r\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\r\n   * @dev Deprecated: Use the `supply` function instead\r\n   * @param asset The address of the underlying asset to supply\r\n   * @param amount The amount to be supplied\r\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n   *   is a different wallet\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   */\r\n  function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\r\n\r\n  function configureReserveBlacklistBitmap(address asset, uint128 reserveBlacklistBitmap) external;\r\n\r\n  function getReserveBorrowable(\r\n    address asset,\r\n    address assetToBorrow\r\n  ) external view returns(bool);\r\n\r\n  function getReserveBitmap(\r\n    address asset\r\n  ) external view returns(uint128);\r\n}\r\n\r\n/**\r\n * @title IPriceOracleGetter\r\n * @author Aave\r\n * @notice Interface for the Aave price oracle.\r\n */\r\ninterface IPriceOracleGetter {\r\n  /**\r\n   * @notice Returns the base currency address\r\n   * @dev Address 0x0 is reserved for USD as base currency.\r\n   * @return Returns the base currency address.\r\n   */\r\n  function BASE_CURRENCY() external view returns (address);\r\n\r\n  /**\r\n   * @notice Returns the base currency unit\r\n   * @dev 1 ether for ETH, 1e8 for USD.\r\n   * @return Returns the base currency unit.\r\n   */\r\n  function BASE_CURRENCY_UNIT() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the asset price in the base currency\r\n   * @param asset The address of the asset\r\n   * @return The price of the asset\r\n   */\r\n  function getAssetPrice(address asset) external view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title IAaveOracle\r\n * @author Aave\r\n * @notice Defines the basic interface for the Aave Oracle\r\n */\r\ninterface IAaveOracle is IPriceOracleGetter {\r\n  /**\r\n   * @dev Emitted after the base currency is set\r\n   * @param baseCurrency The base currency of used for price quotes\r\n   * @param baseCurrencyUnit The unit of the base currency\r\n   */\r\n  event BaseCurrencySet(address indexed baseCurrency, uint256 baseCurrencyUnit);\r\n\r\n  /**\r\n   * @dev Emitted after the price source of an asset is updated\r\n   * @param asset The address of the asset\r\n   * @param source The price source of the asset\r\n   */\r\n  event AssetSourceUpdated(address indexed asset, address indexed source);\r\n\r\n  /**\r\n   * @dev Emitted after the address of fallback oracle is updated\r\n   * @param fallbackOracle The address of the fallback oracle\r\n   */\r\n  event FallbackOracleUpdated(address indexed fallbackOracle);\r\n\r\n  /**\r\n   * @notice Returns the PoolAddressesProvider\r\n   * @return The address of the PoolAddressesProvider contract\r\n   */\r\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\r\n\r\n  /**\r\n   * @notice Sets or replaces price sources of assets\r\n   * @param assets The addresses of the assets\r\n   * @param sources The addresses of the price sources\r\n   */\r\n  function setAssetSources(address[] calldata assets, address[] calldata sources) external;\r\n\r\n  /**\r\n   * @notice Sets the fallback oracle\r\n   * @param fallbackOracle The address of the fallback oracle\r\n   */\r\n  function setFallbackOracle(address fallbackOracle) external;\r\n\r\n  /**\r\n   * @notice Returns a list of prices from a list of assets addresses\r\n   * @param assets The list of assets addresses\r\n   * @return The prices of the given assets\r\n   */\r\n  function getAssetsPrices(address[] calldata assets) external view returns (uint256[] memory);\r\n\r\n  /**\r\n   * @notice Returns the address of the source for an asset address\r\n   * @param asset The address of the asset\r\n   * @return The address of the source\r\n   */\r\n  function getSourceOfAsset(address asset) external view returns (address);\r\n\r\n  /**\r\n   * @notice Returns the address of the fallback oracle\r\n   * @return The address of the fallback oracle\r\n   */\r\n  function getFallbackOracle() external view returns (address);\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns (address payable) {\r\n    return payable(msg.sender);\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes memory) {\r\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n    return msg.data;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev Initializes the contract setting the deployer as the initial owner.\r\n   */\r\n  constructor() {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Leaves the contract without owner. It will not be possible to call\r\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n   *\r\n   * NOTE: Renouncing ownership will leave the contract without an owner,\r\n   * thereby removing any functionality that is only available to the owner.\r\n   */\r\n  function renounceOwnership() public virtual onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IERC20Detailed is IERC20 {\r\n  function name() external view returns (string memory);\r\n\r\n  function symbol() external view returns (string memory);\r\n\r\n  function decimals() external view returns (uint8);\r\n}\r\n\r\n/**\r\n * @title WadRayMath library\r\n * @author Aave\r\n * @notice Provides functions to perform calculations with Wad and Ray units\r\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers\r\n * with 27 digits of precision)\r\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\r\n */\r\nlibrary WadRayMath {\r\n  // HALF_WAD and HALF_RAY expressed with extended notation as constant with operations are not supported in Yul assembly\r\n  uint256 internal constant WAD = 1e18;\r\n  uint256 internal constant HALF_WAD = 0.5e18;\r\n\r\n  uint256 internal constant RAY = 1e27;\r\n  uint256 internal constant HALF_RAY = 0.5e27;\r\n\r\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\r\n\r\n  /**\r\n   * @dev Multiplies two wad, rounding half up to the nearest wad\r\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\r\n   * @param a Wad\r\n   * @param b Wad\r\n   * @return c = a*b, in wad\r\n   */\r\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b\r\n    assembly {\r\n      if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))) {\r\n        revert(0, 0)\r\n      }\r\n\r\n      c := div(add(mul(a, b), HALF_WAD), WAD)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Divides two wad, rounding half up to the nearest wad\r\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\r\n   * @param a Wad\r\n   * @param b Wad\r\n   * @return c = a/b, in wad\r\n   */\r\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // to avoid overflow, a <= (type(uint256).max - halfB) / WAD\r\n    assembly {\r\n      if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))) {\r\n        revert(0, 0)\r\n      }\r\n\r\n      c := div(add(mul(a, WAD), div(b, 2)), b)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Multiplies two ray, rounding half up to the nearest ray\r\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\r\n   * @param a Ray\r\n   * @param b Ray\r\n   * @return c = a raymul b\r\n   */\r\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b\r\n    assembly {\r\n      if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))) {\r\n        revert(0, 0)\r\n      }\r\n\r\n      c := div(add(mul(a, b), HALF_RAY), RAY)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Divides two ray, rounding half up to the nearest ray\r\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\r\n   * @param a Ray\r\n   * @param b Ray\r\n   * @return c = a raydiv b\r\n   */\r\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\r\n    assembly {\r\n      if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))) {\r\n        revert(0, 0)\r\n      }\r\n\r\n      c := div(add(mul(a, RAY), div(b, 2)), b)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Casts ray down to wad\r\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\r\n   * @param a Ray\r\n   * @return b = a converted to wad, rounded half up to the nearest wad\r\n   */\r\n  function rayToWad(uint256 a) internal pure returns (uint256 b) {\r\n    assembly {\r\n      b := div(a, WAD_RAY_RATIO)\r\n      let remainder := mod(a, WAD_RAY_RATIO)\r\n      if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) {\r\n        b := add(b, 1)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Converts wad up to ray\r\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\r\n   * @param a Wad\r\n   * @return b = a converted in ray\r\n   */\r\n  function wadToRay(uint256 a) internal pure returns (uint256 b) {\r\n    // to avoid overflow, b/WAD_RAY_RATIO == a\r\n    assembly {\r\n      b := mul(a, WAD_RAY_RATIO)\r\n\r\n      if iszero(eq(div(b, WAD_RAY_RATIO), a)) {\r\n        revert(0, 0)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @title PercentageMath library\r\n * @author Aave\r\n * @notice Provides functions to perform percentage calculations\r\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\r\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\r\n */\r\nlibrary PercentageMath {\r\n  // Maximum percentage factor (100.00%)\r\n  uint256 internal constant PERCENTAGE_FACTOR = 1e4;\r\n\r\n  // Half percentage factor (50.00%)\r\n  uint256 internal constant HALF_PERCENTAGE_FACTOR = 0.5e4;\r\n\r\n  /**\r\n   * @notice Executes a percentage multiplication\r\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\r\n   * @param value The value of which the percentage needs to be calculated\r\n   * @param percentage The percentage of the value to be calculated\r\n   * @return result value percentmul percentage\r\n   */\r\n  function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256 result) {\r\n    // to avoid overflow, value <= (type(uint256).max - HALF_PERCENTAGE_FACTOR) / percentage\r\n    assembly {\r\n      if iszero(\r\n        or(\r\n          iszero(percentage),\r\n          iszero(gt(value, div(sub(not(0), HALF_PERCENTAGE_FACTOR), percentage)))\r\n        )\r\n      ) {\r\n        revert(0, 0)\r\n      }\r\n\r\n      result := div(add(mul(value, percentage), HALF_PERCENTAGE_FACTOR), PERCENTAGE_FACTOR)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Executes a percentage division\r\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\r\n   * @param value The value of which the percentage needs to be calculated\r\n   * @param percentage The percentage of the value to be calculated\r\n   * @return result value percentdiv percentage\r\n   */\r\n  function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256 result) {\r\n    // to avoid overflow, value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR\r\n    assembly {\r\n      if or(\r\n        iszero(percentage),\r\n        iszero(iszero(gt(value, div(sub(not(0), div(percentage, 2)), PERCENTAGE_FACTOR))))\r\n      ) {\r\n        revert(0, 0)\r\n      }\r\n\r\n      result := div(add(mul(value, PERCENTAGE_FACTOR), div(percentage, 2)), percentage)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @title Errors library\r\n * @author Aave\r\n * @notice Defines the error messages emitted by the different contracts of the Aave protocol\r\n */\r\nlibrary Errors {\r\n  string public constant CALLER_NOT_POOL_ADMIN = '1'; // 'The caller of the function is not a pool admin'\r\n  string public constant CALLER_NOT_EMERGENCY_ADMIN = '2'; // 'The caller of the function is not an emergency admin'\r\n  string public constant CALLER_NOT_POOL_OR_EMERGENCY_ADMIN = '3'; // 'The caller of the function is not a pool or emergency admin'\r\n  string public constant CALLER_NOT_RISK_OR_POOL_ADMIN = '4'; // 'The caller of the function is not a risk or pool admin'\r\n  string public constant CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN = '5'; // 'The caller of the function is not an asset listing or pool admin'\r\n  string public constant CALLER_NOT_BRIDGE = '6'; // 'The caller of the function is not a bridge'\r\n  string public constant ADDRESSES_PROVIDER_NOT_REGISTERED = '7'; // 'Pool addresses provider is not registered'\r\n  string public constant INVALID_ADDRESSES_PROVIDER_ID = '8'; // 'Invalid id for the pool addresses provider'\r\n  string public constant NOT_CONTRACT = '9'; // 'Address is not a contract'\r\n  string public constant CALLER_NOT_POOL_CONFIGURATOR = '10'; // 'The caller of the function is not the pool configurator'\r\n  string public constant CALLER_NOT_ATOKEN = '11'; // 'The caller of the function is not an AToken'\r\n  string public constant INVALID_ADDRESSES_PROVIDER = '12'; // 'The address of the pool addresses provider is invalid'\r\n  string public constant INVALID_FLASHLOAN_EXECUTOR_RETURN = '13'; // 'Invalid return value of the flashloan executor function'\r\n  string public constant RESERVE_ALREADY_ADDED = '14'; // 'Reserve has already been added to reserve list'\r\n  string public constant NO_MORE_RESERVES_ALLOWED = '15'; // 'Maximum amount of reserves in the pool reached'\r\n  string public constant EMODE_CATEGORY_RESERVED = '16'; // 'Zero eMode category is reserved for volatile heterogeneous assets'\r\n  string public constant INVALID_EMODE_CATEGORY_ASSIGNMENT = '17'; // 'Invalid eMode category assignment to asset'\r\n  string public constant RESERVE_LIQUIDITY_NOT_ZERO = '18'; // 'The liquidity of the reserve needs to be 0'\r\n  string public constant FLASHLOAN_PREMIUM_INVALID = '19'; // 'Invalid flashloan premium'\r\n  string public constant INVALID_RESERVE_PARAMS = '20'; // 'Invalid risk parameters for the reserve'\r\n  string public constant INVALID_EMODE_CATEGORY_PARAMS = '21'; // 'Invalid risk parameters for the eMode category'\r\n  string public constant BRIDGE_PROTOCOL_FEE_INVALID = '22'; // 'Invalid bridge protocol fee'\r\n  string public constant CALLER_MUST_BE_POOL = '23'; // 'The caller of this function must be a pool'\r\n  string public constant INVALID_MINT_AMOUNT = '24'; // 'Invalid amount to mint'\r\n  string public constant INVALID_BURN_AMOUNT = '25'; // 'Invalid amount to burn'\r\n  string public constant INVALID_AMOUNT = '26'; // 'Amount must be greater than 0'\r\n  string public constant RESERVE_INACTIVE = '27'; // 'Action requires an active reserve'\r\n  string public constant RESERVE_FROZEN = '28'; // 'Action cannot be performed because the reserve is frozen'\r\n  string public constant RESERVE_PAUSED = '29'; // 'Action cannot be performed because the reserve is paused'\r\n  string public constant BORROWING_NOT_ENABLED = '30'; // 'Borrowing is not enabled'\r\n  string public constant STABLE_BORROWING_NOT_ENABLED = '31'; // 'Stable borrowing is not enabled'\r\n  string public constant NOT_ENOUGH_AVAILABLE_USER_BALANCE = '32'; // 'User cannot withdraw more than the available balance'\r\n  string public constant INVALID_INTEREST_RATE_MODE_SELECTED = '33'; // 'Invalid interest rate mode selected'\r\n  string public constant COLLATERAL_BALANCE_IS_ZERO = '34'; // 'The collateral balance is 0'\r\n  string public constant HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = '35'; // 'Health factor is lesser than the liquidation threshold'\r\n  string public constant COLLATERAL_CANNOT_COVER_NEW_BORROW = '36'; // 'There is not enough collateral to cover a new borrow'\r\n  string public constant COLLATERAL_SAME_AS_BORROWING_CURRENCY = '37'; // 'Collateral is (mostly) the same currency that is being borrowed'\r\n  string public constant AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = '38'; // 'The requested amount is greater than the max loan size in stable rate mode'\r\n  string public constant NO_DEBT_OF_SELECTED_TYPE = '39'; // 'For repayment of a specific type of debt, the user needs to have debt that type'\r\n  string public constant NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = '40'; // 'To repay on behalf of a user an explicit amount to repay is needed'\r\n  string public constant NO_OUTSTANDING_STABLE_DEBT = '41'; // 'User does not have outstanding stable rate debt on this reserve'\r\n  string public constant NO_OUTSTANDING_VARIABLE_DEBT = '42'; // 'User does not have outstanding variable rate debt on this reserve'\r\n  string public constant UNDERLYING_BALANCE_ZERO = '43'; // 'The underlying balance needs to be greater than 0'\r\n  string public constant INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = '44'; // 'Interest rate rebalance conditions were not met'\r\n  string public constant HEALTH_FACTOR_NOT_BELOW_THRESHOLD = '45'; // 'Health factor is not below the threshold'\r\n  string public constant COLLATERAL_CANNOT_BE_LIQUIDATED = '46'; // 'The collateral chosen cannot be liquidated'\r\n  string public constant SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = '47'; // 'User did not borrow the specified currency'\r\n  string public constant INCONSISTENT_FLASHLOAN_PARAMS = '49'; // 'Inconsistent flashloan parameters'\r\n  string public constant BORROW_CAP_EXCEEDED = '50'; // 'Borrow cap is exceeded'\r\n  string public constant SUPPLY_CAP_EXCEEDED = '51'; // 'Supply cap is exceeded'\r\n  string public constant UNBACKED_MINT_CAP_EXCEEDED = '52'; // 'Unbacked mint cap is exceeded'\r\n  string public constant DEBT_CEILING_EXCEEDED = '53'; // 'Debt ceiling is exceeded'\r\n  string public constant UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO = '54'; // 'Claimable rights over underlying not zero (aToken supply or accruedToTreasury)'\r\n  string public constant STABLE_DEBT_NOT_ZERO = '55'; // 'Stable debt supply is not zero'\r\n  string public constant VARIABLE_DEBT_SUPPLY_NOT_ZERO = '56'; // 'Variable debt supply is not zero'\r\n  string public constant LTV_VALIDATION_FAILED = '57'; // 'Ltv validation failed'\r\n  string public constant INCONSISTENT_EMODE_CATEGORY = '58'; // 'Inconsistent eMode category'\r\n  string public constant PRICE_ORACLE_SENTINEL_CHECK_FAILED = '59'; // 'Price oracle sentinel validation failed'\r\n  string public constant ASSET_NOT_BORROWABLE_IN_ISOLATION = '60'; // 'Asset is not borrowable in isolation mode'\r\n  string public constant RESERVE_ALREADY_INITIALIZED = '61'; // 'Reserve has already been initialized'\r\n  string public constant USER_IN_ISOLATION_MODE_OR_LTV_ZERO_OR_BORROWED_BLACKLISTED_ASSET = '62'; // 'User is in isolation mode or ltv is zero'\r\n  string public constant INVALID_LTV = '63'; // 'Invalid ltv parameter for the reserve'\r\n  string public constant INVALID_LIQ_THRESHOLD = '64'; // 'Invalid liquidity threshold parameter for the reserve'\r\n  string public constant INVALID_LIQ_BONUS = '65'; // 'Invalid liquidity bonus parameter for the reserve'\r\n  string public constant INVALID_DECIMALS = '66'; // 'Invalid decimals parameter of the underlying asset of the reserve'\r\n  string public constant INVALID_RESERVE_FACTOR = '67'; // 'Invalid reserve factor parameter for the reserve'\r\n  string public constant INVALID_BORROW_CAP = '68'; // 'Invalid borrow cap for the reserve'\r\n  string public constant INVALID_SUPPLY_CAP = '69'; // 'Invalid supply cap for the reserve'\r\n  string public constant INVALID_LIQUIDATION_PROTOCOL_FEE = '70'; // 'Invalid liquidation protocol fee for the reserve'\r\n  string public constant INVALID_EMODE_CATEGORY = '71'; // 'Invalid eMode category for the reserve'\r\n  string public constant INVALID_UNBACKED_MINT_CAP = '72'; // 'Invalid unbacked mint cap for the reserve'\r\n  string public constant INVALID_DEBT_CEILING = '73'; // 'Invalid debt ceiling for the reserve\r\n  string public constant INVALID_RESERVE_INDEX = '74'; // 'Invalid reserve index'\r\n  string public constant ACL_ADMIN_CANNOT_BE_ZERO = '75'; // 'ACL admin cannot be set to the zero address'\r\n  string public constant INCONSISTENT_PARAMS_LENGTH = '76'; // 'Array parameters that should be equal length are not'\r\n  string public constant ZERO_ADDRESS_NOT_VALID = '77'; // 'Zero address not valid'\r\n  string public constant INVALID_EXPIRATION = '78'; // 'Invalid expiration'\r\n  string public constant INVALID_SIGNATURE = '79'; // 'Invalid signature'\r\n  string public constant OPERATION_NOT_SUPPORTED = '80'; // 'Operation not supported'\r\n  string public constant DEBT_CEILING_NOT_ZERO = '81'; // 'Debt ceiling is not zero'\r\n  string public constant ASSET_NOT_LISTED = '82'; // 'Asset is not listed'\r\n  string public constant INVALID_OPTIMAL_USAGE_RATIO = '83'; // 'Invalid optimal usage ratio'\r\n  string public constant INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = '84'; // 'Invalid optimal stable to total debt ratio'\r\n  string public constant UNDERLYING_CANNOT_BE_RESCUED = '85'; // 'The underlying asset cannot be rescued'\r\n  string public constant ADDRESSES_PROVIDER_ALREADY_ADDED = '86'; // 'Reserve has already been added to reserve list'\r\n  string public constant POOL_ADDRESSES_DO_NOT_MATCH = '87'; // 'The token implementation pool address and the pool address provided by the initializing pool do not match'\r\n  string public constant STABLE_BORROWING_ENABLED = '88'; // 'Stable borrowing is enabled'\r\n  string public constant SILOED_BORROWING_VIOLATION = '89'; // 'User is trying to borrow multiple assets including a siloed one'\r\n  string public constant RESERVE_DEBT_NOT_ZERO = '90'; // the total debt of the reserve needs to be 0\r\n  string public constant FLASHLOAN_DISABLED = '91'; // FlashLoaning for this asset is disabled\r\n  string public constant COLLATERAL_BLACKLIST_VIOLATION = '92'; // user is trying to borrow an asset that is blacklisted given one of his collaterals\r\n  string public constant INVALID_RESERVE_BITMAP = '93';\r\n}\r\n\r\n/**\r\n * @title IReserveInterestRateStrategy\r\n * @author Aave\r\n * @notice Interface for the calculation of the interest rates\r\n */\r\ninterface IReserveInterestRateStrategy {\r\n  /**\r\n   * @notice Calculates the interest rates depending on the reserve's state and configurations\r\n   * @param params The parameters needed to calculate interest rates\r\n   * @return liquidityRate The liquidity rate expressed in rays\r\n   * @return stableBorrowRate The stable borrow rate expressed in rays\r\n   * @return variableBorrowRate The variable borrow rate expressed in rays\r\n   */\r\n  function calculateInterestRates(\r\n    DataTypes.CalculateInterestRatesParams memory params\r\n  ) external view returns (uint256, uint256, uint256);\r\n}\r\n\r\n/**\r\n * @title IDefaultInterestRateStrategy\r\n * @author Aave\r\n * @notice Defines the basic interface of the DefaultReserveInterestRateStrategy\r\n */\r\ninterface IDefaultInterestRateStrategy is IReserveInterestRateStrategy {\r\n  /**\r\n   * @notice Returns the usage ratio at which the pool aims to obtain most competitive borrow rates.\r\n   * @return The optimal usage ratio, expressed in ray.\r\n   */\r\n  function OPTIMAL_USAGE_RATIO() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the optimal stable to total debt ratio of the reserve.\r\n   * @return The optimal stable to total debt ratio, expressed in ray.\r\n   */\r\n  function OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the excess usage ratio above the optimal.\r\n   * @dev It's always equal to 1-optimal usage ratio (added as constant for gas optimizations)\r\n   * @return The max excess usage ratio, expressed in ray.\r\n   */\r\n  function MAX_EXCESS_USAGE_RATIO() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the excess stable debt ratio above the optimal.\r\n   * @dev It's always equal to 1-optimal stable to total debt ratio (added as constant for gas optimizations)\r\n   * @return The max excess stable to total debt ratio, expressed in ray.\r\n   */\r\n  function MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the address of the PoolAddressesProvider\r\n   * @return The address of the PoolAddressesProvider contract\r\n   */\r\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\r\n\r\n  /**\r\n   * @notice Returns the variable rate slope below optimal usage ratio\r\n   * @dev It's the variable rate when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO\r\n   * @return The variable rate slope, expressed in ray\r\n   */\r\n  function getVariableRateSlope1() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the variable rate slope above optimal usage ratio\r\n   * @dev It's the variable rate when usage ratio > OPTIMAL_USAGE_RATIO\r\n   * @return The variable rate slope, expressed in ray\r\n   */\r\n  function getVariableRateSlope2() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the stable rate slope below optimal usage ratio\r\n   * @dev It's the stable rate when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO\r\n   * @return The stable rate slope, expressed in ray\r\n   */\r\n  function getStableRateSlope1() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the stable rate slope above optimal usage ratio\r\n   * @dev It's the variable rate when usage ratio > OPTIMAL_USAGE_RATIO\r\n   * @return The stable rate slope, expressed in ray\r\n   */\r\n  function getStableRateSlope2() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the stable rate excess offset\r\n   * @dev It's an additional premium applied to the stable when stable debt > OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO\r\n   * @return The stable rate excess offset, expressed in ray\r\n   */\r\n  function getStableRateExcessOffset() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the base stable borrow rate\r\n   * @return The base stable borrow rate, expressed in ray\r\n   */\r\n  function getBaseStableBorrowRate() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the base variable borrow rate\r\n   * @return The base variable borrow rate, expressed in ray\r\n   */\r\n  function getBaseVariableBorrowRate() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the maximum variable borrow rate\r\n   * @return The maximum variable borrow rate, expressed in ray\r\n   */\r\n  function getMaxVariableBorrowRate() external view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title DefaultReserveInterestRateStrategy contract\r\n * @author Aave\r\n * @notice Implements the calculation of the interest rates depending on the reserve state\r\n * @dev The model of interest rate is based on 2 slopes, one before the `OPTIMAL_USAGE_RATIO`\r\n * point of usage and another from that one to 100%.\r\n * - An instance of this same contract, can't be used across different Aave markets, due to the caching\r\n *   of the PoolAddressesProvider\r\n */\r\ncontract DefaultReserveInterestRateStrategy is IDefaultInterestRateStrategy {\r\n  using WadRayMath for uint256;\r\n  using PercentageMath for uint256;\r\n\r\n  /// @inheritdoc IDefaultInterestRateStrategy\r\n  uint256 public immutable OPTIMAL_USAGE_RATIO;\r\n\r\n  /// @inheritdoc IDefaultInterestRateStrategy\r\n  uint256 public immutable OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO;\r\n\r\n  /// @inheritdoc IDefaultInterestRateStrategy\r\n  uint256 public immutable MAX_EXCESS_USAGE_RATIO;\r\n\r\n  /// @inheritdoc IDefaultInterestRateStrategy\r\n  uint256 public immutable MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO;\r\n\r\n  IPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\r\n\r\n  // Base variable borrow rate when usage rate = 0. Expressed in ray\r\n  uint256 internal immutable _baseVariableBorrowRate;\r\n\r\n  // Slope of the variable interest curve when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO. Expressed in ray\r\n  uint256 internal immutable _variableRateSlope1;\r\n\r\n  // Slope of the variable interest curve when usage ratio > OPTIMAL_USAGE_RATIO. Expressed in ray\r\n  uint256 internal immutable _variableRateSlope2;\r\n\r\n  // Slope of the stable interest curve when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO. Expressed in ray\r\n  uint256 internal immutable _stableRateSlope1;\r\n\r\n  // Slope of the stable interest curve when usage ratio > OPTIMAL_USAGE_RATIO. Expressed in ray\r\n  uint256 internal immutable _stableRateSlope2;\r\n\r\n  // Premium on top of `_variableRateSlope1` for base stable borrowing rate\r\n  uint256 internal immutable _baseStableRateOffset;\r\n\r\n  // Additional premium applied to stable rate when stable debt surpass `OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO`\r\n  uint256 internal immutable _stableRateExcessOffset;\r\n\r\n  /**\r\n   * @dev Constructor.\r\n   * @param provider The address of the PoolAddressesProvider contract\r\n   * @param optimalUsageRatio The optimal usage ratio\r\n   * @param baseVariableBorrowRate The base variable borrow rate\r\n   * @param variableRateSlope1 The variable rate slope below optimal usage ratio\r\n   * @param variableRateSlope2 The variable rate slope above optimal usage ratio\r\n   * @param stableRateSlope1 The stable rate slope below optimal usage ratio\r\n   * @param stableRateSlope2 The stable rate slope above optimal usage ratio\r\n   * @param baseStableRateOffset The premium on top of variable rate for base stable borrowing rate\r\n   * @param stableRateExcessOffset The premium on top of stable rate when there stable debt surpass the threshold\r\n   * @param optimalStableToTotalDebtRatio The optimal stable debt to total debt ratio of the reserve\r\n   */\r\n  constructor(\r\n    IPoolAddressesProvider provider,\r\n    uint256 optimalUsageRatio,\r\n    uint256 baseVariableBorrowRate,\r\n    uint256 variableRateSlope1,\r\n    uint256 variableRateSlope2,\r\n    uint256 stableRateSlope1,\r\n    uint256 stableRateSlope2,\r\n    uint256 baseStableRateOffset,\r\n    uint256 stableRateExcessOffset,\r\n    uint256 optimalStableToTotalDebtRatio\r\n  ) {\r\n    require(WadRayMath.RAY >= optimalUsageRatio, Errors.INVALID_OPTIMAL_USAGE_RATIO);\r\n    require(\r\n      WadRayMath.RAY >= optimalStableToTotalDebtRatio,\r\n      Errors.INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO\r\n    );\r\n    OPTIMAL_USAGE_RATIO = optimalUsageRatio;\r\n    MAX_EXCESS_USAGE_RATIO = WadRayMath.RAY - optimalUsageRatio;\r\n    OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = optimalStableToTotalDebtRatio;\r\n    MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO = WadRayMath.RAY - optimalStableToTotalDebtRatio;\r\n    ADDRESSES_PROVIDER = provider;\r\n    _baseVariableBorrowRate = baseVariableBorrowRate;\r\n    _variableRateSlope1 = variableRateSlope1;\r\n    _variableRateSlope2 = variableRateSlope2;\r\n    _stableRateSlope1 = stableRateSlope1;\r\n    _stableRateSlope2 = stableRateSlope2;\r\n    _baseStableRateOffset = baseStableRateOffset;\r\n    _stableRateExcessOffset = stableRateExcessOffset;\r\n  }\r\n\r\n  /// @inheritdoc IDefaultInterestRateStrategy\r\n  function getVariableRateSlope1() external view returns (uint256) {\r\n    return _variableRateSlope1;\r\n  }\r\n\r\n  /// @inheritdoc IDefaultInterestRateStrategy\r\n  function getVariableRateSlope2() external view returns (uint256) {\r\n    return _variableRateSlope2;\r\n  }\r\n\r\n  /// @inheritdoc IDefaultInterestRateStrategy\r\n  function getStableRateSlope1() external view returns (uint256) {\r\n    return _stableRateSlope1;\r\n  }\r\n\r\n  /// @inheritdoc IDefaultInterestRateStrategy\r\n  function getStableRateSlope2() external view returns (uint256) {\r\n    return _stableRateSlope2;\r\n  }\r\n\r\n  /// @inheritdoc IDefaultInterestRateStrategy\r\n  function getStableRateExcessOffset() external view returns (uint256) {\r\n    return _stableRateExcessOffset;\r\n  }\r\n\r\n  /// @inheritdoc IDefaultInterestRateStrategy\r\n  function getBaseStableBorrowRate() public view returns (uint256) {\r\n    return _variableRateSlope1 + _baseStableRateOffset;\r\n  }\r\n\r\n  /// @inheritdoc IDefaultInterestRateStrategy\r\n  function getBaseVariableBorrowRate() external view override returns (uint256) {\r\n    return _baseVariableBorrowRate;\r\n  }\r\n\r\n  /// @inheritdoc IDefaultInterestRateStrategy\r\n  function getMaxVariableBorrowRate() external view override returns (uint256) {\r\n    return _baseVariableBorrowRate + _variableRateSlope1 + _variableRateSlope2;\r\n  }\r\n\r\n  struct CalcInterestRatesLocalVars {\r\n    uint256 availableLiquidity;\r\n    uint256 totalDebt;\r\n    uint256 currentVariableBorrowRate;\r\n    uint256 currentStableBorrowRate;\r\n    uint256 currentLiquidityRate;\r\n    uint256 borrowUsageRatio;\r\n    uint256 supplyUsageRatio;\r\n    uint256 stableToTotalDebtRatio;\r\n    uint256 availableLiquidityPlusDebt;\r\n  }\r\n\r\n  /// @inheritdoc IReserveInterestRateStrategy\r\n  function calculateInterestRates(\r\n    DataTypes.CalculateInterestRatesParams memory params\r\n  ) public view override returns (uint256, uint256, uint256) {\r\n    CalcInterestRatesLocalVars memory vars;\r\n\r\n    vars.totalDebt = params.totalStableDebt + params.totalVariableDebt;\r\n\r\n    vars.currentLiquidityRate = 0;\r\n    vars.currentVariableBorrowRate = _baseVariableBorrowRate;\r\n    vars.currentStableBorrowRate = getBaseStableBorrowRate();\r\n\r\n    if (vars.totalDebt != 0) {\r\n      vars.stableToTotalDebtRatio = params.totalStableDebt.rayDiv(vars.totalDebt);\r\n      vars.availableLiquidity =\r\n        IERC20(params.reserve).balanceOf(params.aToken) +\r\n        params.liquidityAdded -\r\n        params.liquidityTaken;\r\n\r\n      vars.availableLiquidityPlusDebt = vars.availableLiquidity + vars.totalDebt;\r\n      vars.borrowUsageRatio = vars.totalDebt.rayDiv(vars.availableLiquidityPlusDebt);\r\n      vars.supplyUsageRatio = vars.totalDebt.rayDiv(\r\n        vars.availableLiquidityPlusDebt + params.unbacked\r\n      );\r\n    }\r\n\r\n    if (vars.borrowUsageRatio > OPTIMAL_USAGE_RATIO) {\r\n      uint256 excessBorrowUsageRatio = (vars.borrowUsageRatio - OPTIMAL_USAGE_RATIO).rayDiv(\r\n        MAX_EXCESS_USAGE_RATIO\r\n      );\r\n\r\n      vars.currentStableBorrowRate +=\r\n        _stableRateSlope1 +\r\n        _stableRateSlope2.rayMul(excessBorrowUsageRatio);\r\n\r\n      vars.currentVariableBorrowRate +=\r\n        _variableRateSlope1 +\r\n        _variableRateSlope2.rayMul(excessBorrowUsageRatio);\r\n    } else {\r\n      vars.currentStableBorrowRate += _stableRateSlope1.rayMul(vars.borrowUsageRatio).rayDiv(\r\n        OPTIMAL_USAGE_RATIO\r\n      );\r\n\r\n      vars.currentVariableBorrowRate += _variableRateSlope1.rayMul(vars.borrowUsageRatio).rayDiv(\r\n        OPTIMAL_USAGE_RATIO\r\n      );\r\n    }\r\n\r\n    if (vars.stableToTotalDebtRatio > OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO) {\r\n      uint256 excessStableDebtRatio = (vars.stableToTotalDebtRatio -\r\n        OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO).rayDiv(MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO);\r\n      vars.currentStableBorrowRate += _stableRateExcessOffset.rayMul(excessStableDebtRatio);\r\n    }\r\n\r\n    vars.currentLiquidityRate = _getOverallBorrowRate(\r\n      params.totalStableDebt,\r\n      params.totalVariableDebt,\r\n      vars.currentVariableBorrowRate,\r\n      params.averageStableBorrowRate\r\n    ).rayMul(vars.supplyUsageRatio).percentMul(\r\n        PercentageMath.PERCENTAGE_FACTOR - params.reserveFactor\r\n      );\r\n\r\n    return (\r\n      vars.currentLiquidityRate,\r\n      vars.currentStableBorrowRate,\r\n      vars.currentVariableBorrowRate\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the overall borrow rate as the weighted average between the total variable debt and total stable\r\n   * debt\r\n   * @param totalStableDebt The total borrowed from the reserve at a stable rate\r\n   * @param totalVariableDebt The total borrowed from the reserve at a variable rate\r\n   * @param currentVariableBorrowRate The current variable borrow rate of the reserve\r\n   * @param currentAverageStableBorrowRate The current weighted average of all the stable rate loans\r\n   * @return The weighted averaged borrow rate\r\n   */\r\n  function _getOverallBorrowRate(\r\n    uint256 totalStableDebt,\r\n    uint256 totalVariableDebt,\r\n    uint256 currentVariableBorrowRate,\r\n    uint256 currentAverageStableBorrowRate\r\n  ) internal pure returns (uint256) {\r\n    uint256 totalDebt = totalStableDebt + totalVariableDebt;\r\n\r\n    if (totalDebt == 0) return 0;\r\n\r\n    uint256 weightedVariableRate = totalVariableDebt.wadToRay().rayMul(currentVariableBorrowRate);\r\n\r\n    uint256 weightedStableRate = totalStableDebt.wadToRay().rayMul(currentAverageStableBorrowRate);\r\n\r\n    uint256 overallBorrowRate = (weightedVariableRate + weightedStableRate).rayDiv(\r\n      totalDebt.wadToRay()\r\n    );\r\n\r\n    return overallBorrowRate;\r\n  }\r\n}\r\n\r\n/**\r\n * @notice Deployment helper to onbaord reserve, set risk parameters as well as conduct an initial deposit \r\n * @dev The AtomicReservesSetupHelper is an Ownable contract, so only the deployer or future owners can call this contract.\r\n */\r\ncontract EthAtomicReservesSetupHelper is Ownable {\r\n\r\n      struct RateStrategyInput {\r\n          uint256 optimalUsageRatio;\r\n          uint256 baseVariableBorrowRate;\r\n          uint256 variableRateSlope1;\r\n          uint256 variableRateSlope2;\r\n          uint256 stableRateSlope1;\r\n          uint256 stableRateSlope2;\r\n          uint256 baseStableRateOffset;\r\n          uint256 stableRateExcessOffset;\r\n          uint256 optimalStableToTotalDebtRatio;\r\n      }\r\n        \r\n        struct ConfigureReserveInput {\r\n            uint256 reserveFactor;\r\n            uint256 borrowCap;\r\n            uint256 supplyCap;\r\n            bool stableBorrowingEnabled;\r\n            bool borrowingEnabled;\r\n            bool flashLoanEnabled;\r\n        }\r\n        address internal constant aTokenImpl = 0xCdeaad1BC5bA9000059fd2E76B28101FEa2F2ce0;\r\n        address internal constant sdTokenImpl = 0xF8a60AD22873C6019B9F964505778bcf32Db53fD;\r\n        address internal constant vdTokenImpl = 0xd320771C447855bb9B3EF0A4793C9264f893C36F;\r\n        address internal constant treasury = 0xa3eC77D52696D249440c2d2466B917C5E3Edfd16;\r\n        address internal constant incentivesController = 0x77b93217d12EE30Cc42Fc9a3A882E1dD77058657;\r\n        IPool internal constant pool = IPool(0xeA14474946C59Dee1F103aD517132B3F19Cef1bE);\r\n        IAaveOracle internal constant oracle = IAaveOracle(0x39AbEDA13579fbb4eFFb31B5f38BdC91AE754a39);\r\n        IPoolConfigurator internal constant configurator = IPoolConfigurator(0x877A6ca3B694881Bd29c6ea1C8a9a15bae449122);\r\n        IPoolAddressesProvider internal constant poolAddressProvider = IPoolAddressesProvider(0x0218890dd636c3a1cf0f98557eE2d3612c6bD953);\r\n\r\n        function newListing(address asset, \r\n                            address feed, \r\n                            uint256 seedValue, \r\n                            uint128 blacklistBitmap, \r\n                            RateStrategyInput memory rateInput, \r\n                            ConfigureReserveInput memory configureInput) \r\n        external onlyOwner {\r\n\r\n              // actual workflow\r\n              _setPriceFeed(asset, feed);\r\n        \r\n              address strategy = _deployRateStrategy(rateInput);\r\n\r\n              _initializeReserve(asset, strategy);\r\n\r\n              _configureReserve(asset, configureInput);\r\n\r\n              _supplySeedValue(asset, seedValue);\r\n              // set blacklist such that borrowable reserve(s) is controled\r\n              if (blacklistBitmap > 0) {\r\n                _setReserveBlacklistBitmap(asset, blacklistBitmap);\r\n              }\r\n              \r\n        }\r\n\r\n        function _setPriceFeed(address asset, address feed) internal {\r\n          address[] memory assets = new address[](1);\r\n          address[] memory sources = new address[](1);\r\n          assets[0] = asset;\r\n          sources[0] = feed;\r\n          oracle.setAssetSources(assets, sources);\r\n        }\r\n        \r\n        function _deployRateStrategy(RateStrategyInput memory rateInput) internal returns(address) {\r\n          DefaultReserveInterestRateStrategy interestRateStrategy = new DefaultReserveInterestRateStrategy(\r\n            poolAddressProvider,\r\n            rateInput.optimalUsageRatio,\r\n            rateInput.baseVariableBorrowRate,\r\n            rateInput.variableRateSlope1,\r\n            rateInput.variableRateSlope2,\r\n            rateInput.stableRateSlope1,\r\n            rateInput.stableRateSlope2,\r\n            rateInput.baseStableRateOffset,\r\n            rateInput.stableRateExcessOffset,\r\n            rateInput.optimalStableToTotalDebtRatio\r\n          );\r\n          return address(interestRateStrategy);\r\n        }\r\n\r\n        function _initializeReserve(address asset, address interestRateStrategyAddress) internal {\r\n            uint8 decimal = IERC20Detailed(asset).decimals();\r\n            string memory symbol = IERC20Detailed(asset).symbol();\r\n    \r\n            ConfiguratorInputTypes.InitReserveInput[] memory inputs = new ConfiguratorInputTypes.InitReserveInput[](1);\r\n            inputs[0] = ConfiguratorInputTypes.InitReserveInput(\r\n                aTokenImpl,\r\n                sdTokenImpl,\r\n                vdTokenImpl,\r\n                decimal,\r\n                interestRateStrategyAddress,\r\n                asset,\r\n                treasury,\r\n                incentivesController,\r\n                string(abi.encodePacked(\"Kinza \", symbol)),\r\n                string(abi.encodePacked(\"k\", symbol)),\r\n                string(abi.encodePacked(\"Kinza Variable Debt \", symbol)),\r\n                string(abi.encodePacked(\"vDebt\", symbol)),\r\n                string(abi.encodePacked(\"Kinza Stable Debt \", symbol)),\r\n                string(abi.encodePacked(\"sDebt\", symbol)),\r\n                abi.encodePacked(\"0x10\")\r\n                );\r\n            configurator.initReserves(inputs);\r\n        }\r\n\r\n        function _configureReserve(address asset, ConfigureReserveInput memory inputParams) internal {\r\n            // init with zero LTV in the beginning to prevent hundred finance type of frontrunning\r\n            configurator.configureReserveAsCollateral(\r\n              asset,\r\n              0, // LTV\r\n              0, // liqT\r\n              0 // bonus\r\n            );\r\n\r\n            if (inputParams.borrowingEnabled) {\r\n              configurator.setReserveBorrowing(asset, true);\r\n\r\n              configurator.setBorrowCap(asset, inputParams.borrowCap);\r\n              configurator.setReserveStableRateBorrowing(\r\n                asset,\r\n                inputParams.stableBorrowingEnabled\r\n              );\r\n            }\r\n            configurator.setReserveFlashLoaning(asset, inputParams.flashLoanEnabled);\r\n            configurator.setSupplyCap(asset, inputParams.supplyCap);\r\n            configurator.setReserveFactor(asset, inputParams.reserveFactor);\r\n        }\r\n\r\n        function _supplySeedValue(address asset, uint256 seedValue) internal {\r\n                // expect fund available\r\n            IERC20(asset).approve(address(pool), seedValue);\r\n            pool.supply(asset, seedValue, owner(), 0);\r\n        }\r\n\r\n        function _setReserveBlacklistBitmap(address asset, uint128 blacklistBitmap) internal {\r\n          configurator.setReserveBlacklistBitmap(asset, blacklistBitmap);\r\n        }\r\n\r\n        /** @dev Converts basis points to RAY units\r\n        * e.g. 10_00 (10.00%) will return 100000000000000000000000000\r\n        */\r\n        function _bpsToRay(uint256 amount) internal pure returns (uint256) {\r\n          return (amount * 1e27) / 10_000;\r\n        }\r\n\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feed\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"seedValue\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"blacklistBitmap\",\"type\":\"uint128\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"optimalUsageRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseVariableBorrowRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"variableRateSlope1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"variableRateSlope2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stableRateSlope1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stableRateSlope2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseStableRateOffset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stableRateExcessOffset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimalStableToTotalDebtRatio\",\"type\":\"uint256\"}],\"internalType\":\"struct EthAtomicReservesSetupHelper.RateStrategyInput\",\"name\":\"rateInput\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"reserveFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyCap\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"stableBorrowingEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"borrowingEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"flashLoanEnabled\",\"type\":\"bool\"}],\"internalType\":\"struct EthAtomicReservesSetupHelper.ConfigureReserveInput\",\"name\":\"configureInput\",\"type\":\"tuple\"}],\"name\":\"newListing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "EthAtomicReservesSetupHelper", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://42e6701210e7225d37ce29271e8b2b6b4a3fdedf816eee26017dac879d0b9867"}