{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/actions/common/Executable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.15;\\n\\n/**\\n * @title Shared Action Executable interface\\n * @notice Provides a dma-common interface for an execute method to all Action\\n */\\ninterface Executable {\\n  function execute(bytes calldata data, uint8[] memory paramsMap) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/actions/morpho-blue/MorphoBlueClaimRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.15;\\n\\nimport { Executable } from \\\"../common/Executable.sol\\\";\\nimport { ClaimMultipleRewardsData } from \\\"../../core/types/MorphoBlue.sol\\\";\\nimport {\\n  IUniversalRewardsDistributorBase\\n} from \\\"../../interfaces/morpho-blue/IUniversalRewardsDistributorBase.sol\\\";\\n\\n/**\\n * @title ClaimMultipleTokens Action contract\\n * @notice Claims multiple rewards from MorphoBlue and sends them to the owner's EOA\\n */\\ncontract MorphoBlueClaimRewards is Executable {\\n  /**\\n   * @param data Encoded calldata that conforms to the ClaimMultipleRewardsData struct\\n   */\\n  function execute(bytes calldata data, uint8[] memory) external payable override {\\n    ClaimMultipleRewardsData memory claimData = abi.decode(data, (ClaimMultipleRewardsData));\\n    require(\\n      claimData.claimable.length == claimData.rewards.length &&\\n        claimData.rewards.length == claimData.urd.length &&\\n        claimData.urd.length == claimData.proofs.length,\\n      \\\"MorphoBlueClaimRewards - Array lengths must be equal\\\"\\n    );\\n    for (uint256 i = 0; i < claimData.rewards.length; i++) {\\n      /**\\n       * @dev Calls the `claim` function of the `IUniversalRewardsDistributorBase` contract to claim rewards.\\n       * @param claimData.urd[i] The address of the rewards distributor to claim from.\\n       * @param claimData.rewards[i] The address of the rewards token to claim.\\n       * @param claimData.claimable[i] The amount of rewards to claim.\\n       * @param claimData.proofs[i] The Merkle proof to claim the rewards.\\n       * @param address(this) The address of the contract claiming the rewards - DPM proxy.\\n       */\\n      IUniversalRewardsDistributorBase(claimData.urd[i]).claim(\\n        address(this),\\n        claimData.rewards[i],\\n        claimData.claimable[i],\\n        claimData.proofs[i]\\n      );\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/types/MorphoBlue.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.15;\\n\\nimport { MarketParams } from \\\"../../interfaces/morpho-blue/IMorpho.sol\\\";\\n\\nstruct DepositData {\\n  MarketParams marketParams;\\n  uint256 amount;\\n  bool sumAmounts;\\n}\\n\\nstruct BorrowData {\\n  MarketParams marketParams;\\n  uint256 amount;\\n}\\n\\nstruct WithdrawData {\\n  MarketParams marketParams;\\n  uint256 amount;\\n  address to;\\n}\\n\\nstruct PaybackData {\\n  MarketParams marketParams;\\n  uint256 amount;\\n  address onBehalf;\\n  bool paybackAll;\\n}\\n\\nstruct ClaimMultipleRewardsData {\\n  address[] urd;\\n  address[] rewards;\\n  uint256[] claimable;\\n  bytes32[][] proofs;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/morpho-blue/IMorpho.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\ntype Id is bytes32;\\n\\nstruct MarketParams {\\n  address loanToken;\\n  address collateralToken;\\n  address oracle;\\n  address irm;\\n  uint256 lltv;\\n}\\n\\n/// @dev Warning: For `feeRecipient`, `supplyShares` does not contain the accrued shares since the last interest\\n/// accrual.\\nstruct Position {\\n  uint256 supplyShares;\\n  uint128 borrowShares;\\n  uint128 collateral;\\n}\\n\\n/// @dev Warning: `totalSupplyAssets` does not contain the accrued interest since the last interest accrual.\\n/// @dev Warning: `totalBorrowAssets` does not contain the accrued interest since the last interest accrual.\\n/// @dev Warning: `totalSupplyShares` does not contain the additional shares accrued by `feeRecipient` since the last\\n/// interest accrual.\\nstruct Market {\\n  uint128 totalSupplyAssets;\\n  uint128 totalSupplyShares;\\n  uint128 totalBorrowAssets;\\n  uint128 totalBorrowShares;\\n  uint128 lastUpdate;\\n  uint128 fee;\\n}\\n\\nstruct Authorization {\\n  address authorizer;\\n  address authorized;\\n  bool isAuthorized;\\n  uint256 nonce;\\n  uint256 deadline;\\n}\\n\\nstruct Signature {\\n  uint8 v;\\n  bytes32 r;\\n  bytes32 s;\\n}\\n\\n/// @dev This interface is used for factorizing IMorphoStaticTyping and IMorpho.\\n/// @dev Consider using the IMorpho interface instead of this one.\\ninterface IMorphoBase {\\n  /// @notice The EIP-712 domain separator.\\n  /// @dev Warning: Every EIP-712 signed message based on this domain separator can be reused on another chain sharing\\n  /// the same chain id because the domain separator would be the same.\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n  /// @notice The owner of the contract.\\n  /// @dev It has the power to change the owner.\\n  /// @dev It has the power to set fees on markets and set the fee recipient.\\n  /// @dev It has the power to enable but not disable IRMs and LLTVs.\\n  function owner() external view returns (address);\\n\\n  /// @notice The fee recipient of all markets.\\n  /// @dev The recipient receives the fees of a given market through a supply position on that market.\\n  function feeRecipient() external view returns (address);\\n\\n  /// @notice Whether the `irm` is enabled.\\n  function isIrmEnabled(address irm) external view returns (bool);\\n\\n  /// @notice Whether the `lltv` is enabled.\\n  function isLltvEnabled(uint256 lltv) external view returns (bool);\\n\\n  /// @notice Whether `authorized` is authorized to modify `authorizer`'s position on all markets.\\n  /// @dev Anyone is authorized to modify their own positions, regardless of this variable.\\n  function isAuthorized(address authorizer, address authorized) external view returns (bool);\\n\\n  /// @notice The `authorizer`'s current nonce. Used to prevent replay attacks with EIP-712 signatures.\\n  function nonce(address authorizer) external view returns (uint256);\\n\\n  /// @notice Sets `newOwner` as `owner` of the contract.\\n  /// @dev Warning: No two-step transfer ownership.\\n  /// @dev Warning: The owner can be set to the zero address.\\n  function setOwner(address newOwner) external;\\n\\n  /// @notice Enables `irm` as a possible IRM for market creation.\\n  /// @dev Warning: It is not possible to disable an IRM.\\n  function enableIrm(address irm) external;\\n\\n  /// @notice Enables `lltv` as a possible LLTV for market creation.\\n  /// @dev Warning: It is not possible to disable a LLTV.\\n  function enableLltv(uint256 lltv) external;\\n\\n  /// @notice Sets the `newFee` for the given market `marketParams`.\\n  /// @param newFee The new fee, scaled by WAD.\\n  /// @dev Warning: The recipient can be the zero address.\\n  function setFee(MarketParams memory marketParams, uint256 newFee) external;\\n\\n  /// @notice Sets `newFeeRecipient` as `feeRecipient` of the fee.\\n  /// @dev Warning: If the fee recipient is set to the zero address, fees will accrue there and will be lost.\\n  /// @dev Modifying the fee recipient will allow the new recipient to claim any pending fees not yet accrued. To\\n  /// ensure that the current recipient receives all due fees, accrue interest manually prior to making any changes.\\n  function setFeeRecipient(address newFeeRecipient) external;\\n\\n  /// @notice Creates the market `marketParams`.\\n  /// @dev Here is the list of assumptions on the market's dependencies (tokens, IRM and oracle) that guarantees\\n  /// Morpho behaves as expected:\\n  /// - The token should be ERC-20 compliant, except that it can omit return values on `transfer` and `transferFrom`.\\n  /// - The token balance of Morpho should only decrease on `transfer` and `transferFrom`. In particular, tokens with\\n  /// burn functions are not supported.\\n  /// - The token should not re-enter Morpho on `transfer` nor `transferFrom`.\\n  /// - The token balance of the sender (resp. receiver) should decrease (resp. increase) by exactly the given amount\\n  /// on `transfer` and `transferFrom`. In particular, tokens with fees on transfer are not supported.\\n  /// - The IRM should not re-enter Morpho.\\n  /// - The oracle should return a price with the correct scaling.\\n  /// @dev Here is a list of properties on the market's dependencies that could break Morpho's liveness properties\\n  /// (funds could get stuck):\\n  /// - The token can revert on `transfer` and `transferFrom` for a reason other than an approval or balance issue.\\n  /// - A very high amount of assets (~1e35) supplied or borrowed can make the computation of `toSharesUp` and\\n  /// `toSharesDown` overflow.\\n  /// - The IRM can revert on `borrowRate`.\\n  /// - A very high borrow rate returned by the IRM can make the computation of `interest` in `_accrueInterest`\\n  /// overflow.\\n  /// - The oracle can revert on `price`. Note that this can be used to prevent `borrow`, `withdrawCollateral` and\\n  /// `liquidate` from being used under certain market conditions.\\n  /// - A very high price returned by the oracle can make the computation of `maxBorrow` in `_isHealthy` overflow, or\\n  /// the computation of `assetsRepaid` in `liquidate` overflow.\\n  /// @dev The borrow share price of a market with less than 1e4 assets borrowed can be decreased by manipulations, to\\n  /// the point where `totalBorrowShares` is very large and borrowing overflows.\\n  function createMarket(MarketParams memory marketParams) external;\\n\\n  /// @notice Supplies `assets` or `shares` on behalf of `onBehalf`, optionally calling back the caller's\\n  /// `onMorphoSupply` function with the given `data`.\\n  /// @dev Either `assets` or `shares` should be zero. Most use cases should rely on `assets` as an input so the\\n  /// caller is guaranteed to have `assets` tokens pulled from their balance, but the possibility to mint a specific\\n  /// amount of shares is given for full compatibility and precision.\\n  /// @dev Supplying a large amount can revert for overflow.\\n  /// @dev Supplying an amount of shares may lead to supply more or fewer assets than expected due to slippage.\\n  /// Consider using the `assets` parameter to avoid this.\\n  /// @param marketParams The market to supply assets to.\\n  /// @param assets The amount of assets to supply.\\n  /// @param shares The amount of shares to mint.\\n  /// @param onBehalf The address that will own the increased supply position.\\n  /// @param data Arbitrary data to pass to the `onMorphoSupply` callback. Pass empty data if not needed.\\n  /// @return assetsSupplied The amount of assets supplied.\\n  /// @return sharesSupplied The amount of shares minted.\\n  function supply(\\n    MarketParams memory marketParams,\\n    uint256 assets,\\n    uint256 shares,\\n    address onBehalf,\\n    bytes memory data\\n  ) external returns (uint256 assetsSupplied, uint256 sharesSupplied);\\n\\n  /// @notice Withdraws `assets` or `shares` on behalf of `onBehalf` and sends the assets to `receiver`.\\n  /// @dev Either `assets` or `shares` should be zero. To withdraw max, pass the `shares`'s balance of `onBehalf`.\\n  /// @dev `msg.sender` must be authorized to manage `onBehalf`'s positions.\\n  /// @dev Withdrawing an amount corresponding to more shares than supplied will revert for underflow.\\n  /// @dev It is advised to use the `shares` input when withdrawing the full position to avoid reverts due to\\n  /// conversion roundings between shares and assets.\\n  /// @param marketParams The market to withdraw assets from.\\n  /// @param assets The amount of assets to withdraw.\\n  /// @param shares The amount of shares to burn.\\n  /// @param onBehalf The address of the owner of the supply position.\\n  /// @param receiver The address that will receive the withdrawn assets.\\n  /// @return assetsWithdrawn The amount of assets withdrawn.\\n  /// @return sharesWithdrawn The amount of shares burned.\\n  function withdraw(\\n    MarketParams memory marketParams,\\n    uint256 assets,\\n    uint256 shares,\\n    address onBehalf,\\n    address receiver\\n  ) external returns (uint256 assetsWithdrawn, uint256 sharesWithdrawn);\\n\\n  /// @notice Borrows `assets` or `shares` on behalf of `onBehalf` and sends the assets to `receiver`.\\n  /// @dev Either `assets` or `shares` should be zero. Most use cases should rely on `assets` as an input so the\\n  /// caller is guaranteed to borrow `assets` of tokens, but the possibility to mint a specific amount of shares is\\n  /// given for full compatibility and precision.\\n  /// @dev `msg.sender` must be authorized to manage `onBehalf`'s positions.\\n  /// @dev Borrowing a large amount can revert for overflow.\\n  /// @dev Borrowing an amount of shares may lead to borrow fewer assets than expected due to slippage.\\n  /// Consider using the `assets` parameter to avoid this.\\n  /// @param marketParams The market to borrow assets from.\\n  /// @param assets The amount of assets to borrow.\\n  /// @param shares The amount of shares to mint.\\n  /// @param onBehalf The address that will own the increased borrow position.\\n  /// @param receiver The address that will receive the borrowed assets.\\n  /// @return assetsBorrowed The amount of assets borrowed.\\n  /// @return sharesBorrowed The amount of shares minted.\\n  function borrow(\\n    MarketParams memory marketParams,\\n    uint256 assets,\\n    uint256 shares,\\n    address onBehalf,\\n    address receiver\\n  ) external returns (uint256 assetsBorrowed, uint256 sharesBorrowed);\\n\\n  /// @notice Repays `assets` or `shares` on behalf of `onBehalf`, optionally calling back the caller's\\n  /// `onMorphoReplay` function with the given `data`.\\n  /// @dev Either `assets` or `shares` should be zero. To repay max, pass the `shares`'s balance of `onBehalf`.\\n  /// @dev Repaying an amount corresponding to more shares than borrowed will revert for underflow.\\n  /// @dev It is advised to use the `shares` input when repaying the full position to avoid reverts due to conversion\\n  /// roundings between shares and assets.\\n  /// @dev An attacker can front-run a repay with a small repay making the transaction revert for underflow.\\n  /// @param marketParams The market to repay assets to.\\n  /// @param assets The amount of assets to repay.\\n  /// @param shares The amount of shares to burn.\\n  /// @param onBehalf The address of the owner of the debt position.\\n  /// @param data Arbitrary data to pass to the `onMorphoRepay` callback. Pass empty data if not needed.\\n  /// @return assetsRepaid The amount of assets repaid.\\n  /// @return sharesRepaid The amount of shares burned.\\n  function repay(\\n    MarketParams memory marketParams,\\n    uint256 assets,\\n    uint256 shares,\\n    address onBehalf,\\n    bytes memory data\\n  ) external returns (uint256 assetsRepaid, uint256 sharesRepaid);\\n\\n  /// @notice Supplies `assets` of collateral on behalf of `onBehalf`, optionally calling back the caller's\\n  /// `onMorphoSupplyCollateral` function with the given `data`.\\n  /// @dev Interest are not accrued since it's not required and it saves gas.\\n  /// @dev Supplying a large amount can revert for overflow.\\n  /// @param marketParams The market to supply collateral to.\\n  /// @param assets The amount of collateral to supply.\\n  /// @param onBehalf The address that will own the increased collateral position.\\n  /// @param data Arbitrary data to pass to the `onMorphoSupplyCollateral` callback. Pass empty data if not needed.\\n  function supplyCollateral(\\n    MarketParams memory marketParams,\\n    uint256 assets,\\n    address onBehalf,\\n    bytes memory data\\n  ) external;\\n\\n  /// @notice Withdraws `assets` of collateral on behalf of `onBehalf` and sends the assets to `receiver`.\\n  /// @dev `msg.sender` must be authorized to manage `onBehalf`'s positions.\\n  /// @dev Withdrawing an amount corresponding to more collateral than supplied will revert for underflow.\\n  /// @param marketParams The market to withdraw collateral from.\\n  /// @param assets The amount of collateral to withdraw.\\n  /// @param onBehalf The address of the owner of the collateral position.\\n  /// @param receiver The address that will receive the collateral assets.\\n  function withdrawCollateral(\\n    MarketParams memory marketParams,\\n    uint256 assets,\\n    address onBehalf,\\n    address receiver\\n  ) external;\\n\\n  /// @notice Liquidates the given `repaidShares` of debt asset or seize the given `seizedAssets` of collateral on the\\n  /// given market `marketParams` of the given `borrower`'s position, optionally calling back the caller's\\n  /// `onMorphoLiquidate` function with the given `data`.\\n  /// @dev Either `seizedAssets` or `repaidShares` should be zero.\\n  /// @dev Seizing more than the collateral balance will underflow and revert without any error message.\\n  /// @dev Repaying more than the borrow balance will underflow and revert without any error message.\\n  /// @dev An attacker can front-run a liquidation with a small repay making the transaction revert for underflow.\\n  /// @param marketParams The market of the position.\\n  /// @param borrower The owner of the position.\\n  /// @param seizedAssets The amount of collateral to seize.\\n  /// @param repaidShares The amount of shares to repay.\\n  /// @param data Arbitrary data to pass to the `onMorphoLiquidate` callback. Pass empty data if not needed.\\n  /// @return The amount of assets seized.\\n  /// @return The amount of assets repaid.\\n  function liquidate(\\n    MarketParams memory marketParams,\\n    address borrower,\\n    uint256 seizedAssets,\\n    uint256 repaidShares,\\n    bytes memory data\\n  ) external returns (uint256, uint256);\\n\\n  /// @notice Executes a flash loan.\\n  /// @dev Flash loans have access to the whole balance of the contract (the liquidity and deposited collateral of all\\n  /// markets combined, plus donations).\\n  /// @dev Warning: Not ERC-3156 compliant but compatibility is easily reached:\\n  /// - `flashFee` is zero.\\n  /// - `maxFlashLoan` is the token's balance of this contract.\\n  /// - The receiver of `assets` is the caller.\\n  /// @param token The token to flash loan.\\n  /// @param assets The amount of assets to flash loan.\\n  /// @param data Arbitrary data to pass to the `onMorphoFlashLoan` callback.\\n  function flashLoan(address token, uint256 assets, bytes calldata data) external;\\n\\n  /// @notice Sets the authorization for `authorized` to manage `msg.sender`'s positions.\\n  /// @param authorized The authorized address.\\n  /// @param newIsAuthorized The new authorization status.\\n  function setAuthorization(address authorized, bool newIsAuthorized) external;\\n\\n  /// @notice Sets the authorization for `authorization.authorized` to manage `authorization.authorizer`'s positions.\\n  /// @dev Warning: Reverts if the signature has already been submitted.\\n  /// @dev The signature is malleable, but it has no impact on the security here.\\n  /// @dev The nonce is passed as argument to be able to revert with a different error message.\\n  /// @param authorization The `Authorization` struct.\\n  /// @param signature The signature.\\n  function setAuthorizationWithSig(\\n    Authorization calldata authorization,\\n    Signature calldata signature\\n  ) external;\\n\\n  /// @notice Accrues interest for the given market `marketParams`.\\n  function accrueInterest(MarketParams memory marketParams) external;\\n\\n  /// @notice Returns the data stored on the different `slots`.\\n  function extSloads(bytes32[] memory slots) external view returns (bytes32[] memory);\\n}\\n\\n/// @dev This interface is inherited by Morpho so that function signatures are checked by the compiler.\\n/// @dev Consider using the IMorpho interface instead of this one.\\ninterface IMorphoStaticTyping is IMorphoBase {\\n  /// @notice The state of the position of `user` on the market corresponding to `id`.\\n  /// @dev Warning: For `feeRecipient`, `supplyShares` does not contain the accrued shares since the last interest\\n  /// accrual.\\n  function position(\\n    Id id,\\n    address user\\n  ) external view returns (uint256 supplyShares, uint128 borrowShares, uint128 collateral);\\n\\n  /// @notice The state of the market corresponding to `id`.\\n  /// @dev Warning: `totalSupplyAssets` does not contain the accrued interest since the last interest accrual.\\n  /// @dev Warning: `totalBorrowAssets` does not contain the accrued interest since the last interest accrual.\\n  /// @dev Warning: `totalSupplyShares` does not contain the accrued shares by `feeRecipient` since the last interest\\n  /// accrual.\\n  function market(\\n    Id id\\n  )\\n    external\\n    view\\n    returns (\\n      uint128 totalSupplyAssets,\\n      uint128 totalSupplyShares,\\n      uint128 totalBorrowAssets,\\n      uint128 totalBorrowShares,\\n      uint128 lastUpdate,\\n      uint128 fee\\n    );\\n\\n  /// @notice The market params corresponding to `id`.\\n  /// @dev This mapping is not used in Morpho. It is there to enable reducing the cost associated to calldata on layer\\n  /// 2s by creating a wrapper contract with functions that take `id` as input instead of `marketParams`.\\n  function idToMarketParams(\\n    Id id\\n  )\\n    external\\n    view\\n    returns (address loanToken, address collateralToken, address oracle, address irm, uint256 lltv);\\n}\\n\\n/// @title IMorpho\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @dev Use this interface for Morpho to have access to all the functions with the appropriate function signatures.\\ninterface IMorpho is IMorphoBase {\\n  /// @notice The state of the position of `user` on the market corresponding to `id`.\\n  /// @dev Warning: For `feeRecipient`, `p.supplyShares` does not contain the accrued shares since the last interest\\n  /// accrual.\\n  function position(Id id, address user) external view returns (Position memory p);\\n\\n  /// @notice The state of the market corresponding to `id`.\\n  /// @dev Warning: `m.totalSupplyAssets` does not contain the accrued interest since the last interest accrual.\\n  /// @dev Warning: `m.totalBorrowAssets` does not contain the accrued interest since the last interest accrual.\\n  /// @dev Warning: `m.totalSupplyShares` does not contain the accrued shares by `feeRecipient` since the last\\n  /// interest accrual.\\n  function market(Id id) external view returns (Market memory m);\\n\\n  /// @notice The market params corresponding to `id`.\\n  /// @dev This mapping is not used in Morpho. It is there to enable reducing the cost associated to calldata on layer\\n  /// 2s by creating a wrapper contract with functions that take `id` as input instead of `marketParams`.\\n  function idToMarketParams(Id id) external view returns (MarketParams memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/morpho-blue/IUniversalRewardsDistributorBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @notice The pending root struct for a merkle tree distribution during the timelock.\\nstruct PendingRoot {\\n  /// @dev The submitted pending root.\\n  bytes32 root;\\n  /// @dev The optional ipfs hash containing metadata about the root (e.g. the merkle tree itself).\\n  bytes32 ipfsHash;\\n  /// @dev The timestamp at which the pending root can be accepted.\\n  uint256 validAt;\\n}\\n\\n/// @dev This interface is used for factorizing IUniversalRewardsDistributorStaticTyping and\\n/// IUniversalRewardsDistributor.\\n/// @dev Consider using the IUniversalRewardsDistributor interface instead of this one.\\ninterface IUniversalRewardsDistributorBase {\\n  function root() external view returns (bytes32);\\n\\n  function owner() external view returns (address);\\n\\n  function timelock() external view returns (uint256);\\n\\n  function ipfsHash() external view returns (bytes32);\\n\\n  function isUpdater(address) external view returns (bool);\\n\\n  function claimed(address, address) external view returns (uint256);\\n\\n  function acceptRoot() external;\\n\\n  function setRoot(bytes32 newRoot, bytes32 newIpfsHash) external;\\n\\n  function setTimelock(uint256 newTimelock) external;\\n\\n  function setRootUpdater(address updater, bool active) external;\\n\\n  function revokePendingRoot() external;\\n\\n  function setOwner(address newOwner) external;\\n\\n  function submitRoot(bytes32 newRoot, bytes32 ipfsHash) external;\\n\\n  function claim(\\n    address account,\\n    address reward,\\n    uint256 claimable,\\n    bytes32[] memory proof\\n  ) external returns (uint256 amount);\\n}\\n\\n/// @dev This interface is inherited by the UniversalRewardsDistributor so that function signatures are checked by the\\n/// compiler.\\n/// @dev Consider using the IUniversalRewardsDistributor interface instead of this one.\\ninterface IUniversalRewardsDistributorStaticTyping is IUniversalRewardsDistributorBase {\\n  function pendingRoot() external view returns (bytes32 root, bytes32 ipfsHash, uint256 validAt);\\n}\\n\\n/// @title IUniversalRewardsDistributor\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @dev Use this interface for UniversalRewardsDistributor to have access to all the functions with the appropriate\\n/// function signatures.\\ninterface IUniversalRewardsDistributor is IUniversalRewardsDistributorBase {\\n  function pendingRoot() external view returns (PendingRoot memory);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 0\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "MorphoBlueClaimRewards", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "0", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}