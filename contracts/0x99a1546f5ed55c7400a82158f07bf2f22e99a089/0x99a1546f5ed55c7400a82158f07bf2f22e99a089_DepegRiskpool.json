{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"DepegRiskpool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\n\\nimport \\\"IERC20Metadata.sol\\\";\\n\\nimport \\\"BasicRiskpool.sol\\\";\\nimport \\\"IBundle.sol\\\";\\nimport \\\"IPolicy.sol\\\";\\nimport \\\"IBundleToken.sol\\\";\\n\\nimport \\\"BasicRiskpool2.sol\\\";\\nimport \\\"IChainRegistryFacade.sol\\\";\\nimport \\\"IStakingFacade.sol\\\";\\n\\n\\ncontract DepegRiskpool is \\n    BasicRiskpool2\\n{\\n    struct BundleInfo {\\n        uint256 bundleId;\\n        string name;\\n        IBundle.BundleState state;\\n        uint256 tokenId;\\n        address owner;\\n        uint256 lifetime;\\n        uint256 minSumInsured;\\n        uint256 maxSumInsured;\\n        uint256 minDuration;\\n        uint256 maxDuration;\\n        uint256 annualPercentageReturn;\\n        uint256 capitalSupportedByStaking;\\n        uint256 capital;\\n        uint256 lockedCapital;\\n        uint256 balance;\\n        uint256 createdAt;\\n    }\\n\\n    event LogRiskpoolCapitalSet(uint256 poolCapitalNew, uint256 poolCapitalOld);\\n    event LogBundleCapitalSet(uint256 bundleCapitalNew, uint256 bundleCapitalOld);\\n\\n    event LogAllowAllAccountsSet(bool allowAllAccounts);\\n    event LogAllowAccountSet(address account, bool allowAccount);\\n\\n    event LogBundleExtended(uint256 bundleId, uint256 createdAt, uint256 lifetime, uint256 lifetimeExtended);\\n    event LogBundleExpired(uint256 bundleId, uint256 createdAt, uint256 lifetime);\\n    event LogBundleMismatch(uint256 bundleId, uint256 bundleIdRequested);\\n    event LogBundleMatchesApplication(uint256 bundleId, bool sumInsuredOk, bool durationOk, bool premiumOk);\\n\\n    // values according to \\n    // https://github.com/etherisc/depeg-ui/issues/328\\n\\n    bytes32 public constant EMPTY_STRING_HASH = keccak256(abi.encodePacked(\\\"\\\"));\\n\\n    uint256 public constant MIN_BUNDLE_LIFETIME = 14 * 24 * 3600;\\n    uint256 public constant MAX_BUNDLE_LIFETIME = 180 * 24 * 3600;\\n    uint256 public constant MIN_POLICY_DURATION = 14 * 24 * 3600;\\n    uint256 public constant MAX_POLICY_DURATION = 120 * 24 * 3600;\\n    uint256 public constant MIN_POLICY_COVERAGE = 2000 * 10 ** 6; // as usdt amount\\n    uint256 public constant MAX_POLICY_COVERAGE = 10 ** 6 * 10 ** 6; // as usdt amount\\n    uint256 public constant ONE_YEAR_DURATION = 365 * 24 * 3600; \\n\\n    uint256 public constant APR_100_PERCENTAGE = 10**6;\\n    uint256 public constant MAX_APR = APR_100_PERCENTAGE / 5;\\n\\n    uint256 public constant EXTENSION_INTERVAL = 31 * 24 * 3600; // allowed interval to extend at end of lifetime\\n\\n    mapping(uint256 /* bundle id */ => uint96 /* nft id for bundle */) private _bundleNftId;\\n    mapping(uint256 /* bundle id */ => uint256 /* lifetime extension */) private _bundleLifetimeExtension;\\n    mapping(string /* bundle name */ => uint256 /* bundle id */) private _bundleIdForBundleName;\\n\\n    IChainRegistryFacade private _chainRegistry;\\n    IStakingFacade private _staking;\\n\\n    // managed token\\n    IERC20Metadata private _token;\\n    uint256 private _tokenDecimals;\\n\\n    // sum insured % of protected amount\\n    // 100 corresponds to a depeg price value down to 0.0 is covered by the policy\\n    // 20 corresponds to only depeg values down to 0.8 are covered \\n    // ie even if the chainlink price feed would report 0.65 at depeg time\\n    // the policy holder payout is capped at 0.80\\n    uint256 private _sumInsuredPercentage;\\n    \\n    // capital caps\\n    uint256 private _riskpoolCapitalCap;\\n    uint256 private _bundleCapitalCap;\\n\\n    // bundle creation whitelisting\\n    mapping(address /* potential bundle owner */ => bool /* is allowed to create bundle*/) _allowedAccount;\\n    bool private _allowAllAccounts;\\n\\n\\n    modifier onlyAllowedAccount {\\n        require(isAllowed(_msgSender()), \\\"ERROR:DRP-001:ACCOUNT_NOT_ALLOWED_FOR_BUNDLE_CREATION\\\");\\n        _;\\n    }\\n\\n\\n    constructor(\\n        bytes32 name,\\n        uint256 sumOfSumInsuredCap,\\n        uint256 sumInsuredPercentage,\\n        address erc20Token,\\n        address wallet,\\n        address registry\\n    )\\n        BasicRiskpool2(name, getFullCollateralizationLevel(), sumOfSumInsuredCap, erc20Token, wallet, registry)\\n    {\\n        require(\\n            sumInsuredPercentage > 0 && sumInsuredPercentage <= 100,\\n            \\\"ERROR:DRP-005:SUM_INSURED_PERCENTAGE_INVALID\\\");\\n\\n        _sumInsuredPercentage = sumInsuredPercentage;\\n\\n        _token = IERC20Metadata(erc20Token);\\n        _tokenDecimals = _token.decimals();\\n\\n        _riskpoolCapitalCap = sumOfSumInsuredCap;\\n        _bundleCapitalCap = _riskpoolCapitalCap / 10;\\n        _allowAllAccounts = true;\\n\\n        _staking = IStakingFacade(address(0));\\n        _chainRegistry = IChainRegistryFacade(address(0));\\n    }\\n\\n\\n    function setCapitalCaps(\\n        uint256 poolCapitalCap,\\n        uint256 bundleCapitalCap\\n    )\\n        public\\n        onlyOwner\\n    {\\n        require(poolCapitalCap <= getSumOfSumInsuredCap(), \\\"ERROR:DRP-011:POOL_CAPITAL_CAP_TOO_LARGE\\\");\\n        require(bundleCapitalCap < poolCapitalCap, \\\"ERROR:DRP-012:BUNDLE_CAPITAL_CAP_TOO_LARGE\\\");\\n        require(bundleCapitalCap > 0, \\\"ERROR:DRP-013:BUNDLE_CAPITAL_CAP_ZERO\\\");\\n\\n        uint256 poolCapOld = _riskpoolCapitalCap;\\n        uint256 bundleCapOld = _bundleCapitalCap;\\n\\n        _riskpoolCapitalCap = poolCapitalCap;\\n        _bundleCapitalCap = bundleCapitalCap;\\n\\n        emit LogRiskpoolCapitalSet(_riskpoolCapitalCap, poolCapOld);\\n        emit LogBundleCapitalSet(_bundleCapitalCap, bundleCapOld);\\n    }\\n\\n\\n    function setAllowAllAccounts(bool allowAllAccounts)\\n        external\\n        onlyOwner\\n    {\\n        _allowAllAccounts = allowAllAccounts;\\n        emit LogAllowAllAccountsSet(_allowAllAccounts);\\n    }\\n\\n\\n    function isAllowAllAccountsEnabled()\\n        external\\n        view\\n        returns(bool allowAllAccounts)\\n    {\\n        return _allowAllAccounts;\\n    }\\n\\n\\n    function setAllowAccount(address account, bool allowAccount)\\n        external\\n        onlyOwner\\n    {\\n        _allowedAccount[account] = allowAccount;\\n        emit LogAllowAccountSet(account, _allowedAccount[account]);\\n    }\\n\\n\\n    function isAllowed(address account)\\n        public\\n        view\\n        returns(bool allowed)\\n    {\\n        return _allowAllAccounts || _allowedAccount[account];\\n    }\\n\\n\\n    function setStakingAddress(address stakingAddress)\\n        external\\n        onlyOwner\\n    {\\n        _staking = IStakingFacade(stakingAddress);\\n        require(_staking.implementsIStaking(), \\\"ERROR:DRP-016:STAKING_NOT_ISTAKING\\\");\\n\\n        _chainRegistry = IChainRegistryFacade(_staking.getRegistry());\\n    }\\n\\n\\n    function getStaking()\\n        external\\n        view\\n        returns(IStakingFacade)\\n    {\\n        return _staking;\\n    }\\n\\n\\n    function getChainRegistry()\\n        external\\n        view\\n        returns(IChainRegistryFacade)\\n    {\\n        return _chainRegistry;\\n    }\\n\\n    function createBundle(\\n        string memory name,\\n        uint256 lifetime,\\n        uint256 policyMinProtectedBalance,\\n        uint256 policyMaxProtectedBalance,\\n        uint256 policyMinDuration,\\n        uint256 policyMaxDuration,\\n        uint256 annualPercentageReturn,\\n        uint256 initialAmount\\n    ) \\n        public\\n        onlyAllowedAccount\\n        returns(uint256 bundleId)\\n    {\\n        require(\\n            _bundleIdForBundleName[name] == 0,\\n            \\\"ERROR:DRP-020:NAME_NOT_UNIQUE\\\");\\n        require(\\n            lifetime >= MIN_BUNDLE_LIFETIME\\n            && lifetime <= MAX_BUNDLE_LIFETIME, \\n            \\\"ERROR:DRP-021:LIFETIME_INVALID\\\");\\n\\n        // get sum insured bounds from protected balance bounds\\n        uint256 policyMinSumInsured = calculateSumInsured(policyMinProtectedBalance);\\n        uint256 policyMaxSumInsured = calculateSumInsured(policyMaxProtectedBalance);\\n        \\n        require(\\n            policyMaxProtectedBalance >= policyMinProtectedBalance\\n            && policyMaxProtectedBalance <= MAX_POLICY_COVERAGE\\n            && policyMaxSumInsured <= _bundleCapitalCap,\\n            \\\"ERROR:DRP-022:MAX_PROTECTED_BALANCE_INVALID\\\");\\n        require(\\n            policyMinProtectedBalance >= MIN_POLICY_COVERAGE\\n            && policyMinProtectedBalance <= policyMaxProtectedBalance, \\n            \\\"ERROR:DRP-023:MIN_PROTECTED_BALANCE_INVALID\\\");\\n        require(\\n            policyMaxDuration > 0\\n            && policyMaxDuration <= MAX_POLICY_DURATION, \\n            \\\"ERROR:DRP-024:MAX_DURATION_INVALID\\\");\\n        require(\\n            policyMinDuration >= MIN_POLICY_DURATION\\n            && policyMinDuration <= policyMaxDuration, \\n            \\\"ERROR:DRP-025:MIN_DURATION_INVALID\\\");\\n        require(\\n            annualPercentageReturn > 0\\n            && annualPercentageReturn <= MAX_APR, \\n            \\\"ERROR:DRP-026:APR_INVALID\\\");\\n        require(\\n            initialAmount > 0\\n            && initialAmount <= _bundleCapitalCap, \\n            \\\"ERROR:DRP-027:RISK_CAPITAL_INVALID\\\");\\n        require(\\n            getCapital() + initialAmount <= _riskpoolCapitalCap,\\n            \\\"ERROR:DRP-028:POOL_CAPITAL_CAP_EXCEEDED\\\");\\n\\n        bytes memory filter = encodeBundleParamsAsFilter(\\n            name,\\n            lifetime,\\n            policyMinSumInsured,\\n            policyMaxSumInsured,\\n            policyMinDuration,\\n            policyMaxDuration,\\n            annualPercentageReturn\\n        );\\n\\n        bundleId = super.createBundle(filter, initialAmount);\\n\\n        if(keccak256(abi.encodePacked(name)) != EMPTY_STRING_HASH) {\\n            _bundleIdForBundleName[name] = bundleId;\\n        }\\n\\n        // Register the new bundle with the staking/bundle registry contract. \\n        // Staking and registry are set in tandem (the address of the registry is retrieved from staking),\\n        // so if one is present, its safe to assume the other is too.\\n        IBundle.Bundle memory bundle = _instanceService.getBundle(bundleId);\\n\\n        if (address(_chainRegistry) != address(0) && isComponentRegistered(bundle.riskpoolId)) { \\n            registerBundleInRegistry(bundle, name, lifetime);\\n        }\\n    }\\n\\n\\n    function extendBundleLifetime(\\n        uint256 bundleId,\\n        uint256 lifetimeExtension\\n    )\\n        external\\n        onlyBundleOwner(bundleId)\\n    {\\n        require(\\n            lifetimeExtension >= MIN_BUNDLE_LIFETIME\\n            && lifetimeExtension <= MAX_BUNDLE_LIFETIME, \\n            \\\"ERROR:DRP-030:LIFETIME_EXTENSION_INVALID\\\");\\n\\n        (\\n            IBundle.BundleState state,\\n            uint256 createdAt,\\n            uint256 lifetime,\\n            uint256 extendedLifetime,\\n            bool isExpired\\n        ) = getBundleLifetimeData(bundleId);\\n\\n        require(state == IBundle.BundleState.Active, \\\"ERROR:DRP-031:BUNDLE_NOT_ACTIVE\\\");\\n        require(!isExpired, \\\"ERROR:DRP-032:BUNDLE_EXPIRED\\\");\\n        require(block.timestamp > createdAt + extendedLifetime - EXTENSION_INTERVAL, \\\"ERROR:DRP-033:TOO_EARLY\\\");\\n\\n        _bundleLifetimeExtension[bundleId] += lifetimeExtension;\\n        uint256 lifetimeExtended = lifetime + _bundleLifetimeExtension[bundleId];\\n\\n        // update lifetime in registry (if registry is available and bundle is registered)\\n        if (address(_chainRegistry) != address(0) && _bundleNftId[bundleId] > 0) { \\n            uint96 nftId = getNftId(bundleId);\\n            _chainRegistry.extendBundleLifetime(nftId, lifetimeExtension);\\n        }\\n\\n        // write log entry\\n        emit LogBundleExtended(bundleId, createdAt, lifetime, lifetimeExtended);\\n    }\\n\\n\\n    function getNftId(uint256 bundleId)\\n        public\\n        view \\n        returns(uint96 nftId)\\n    {\\n        nftId = _bundleNftId[bundleId];\\n        return nftId > 0 ? nftId : _chainRegistry.getBundleNftId(_instanceService.getInstanceId(), bundleId);\\n    }\\n\\n\\n    function getBundleLifetimeData(uint256 bundleId)\\n        public\\n        view\\n        returns(\\n            IBundle.BundleState state,\\n            uint256 createdAt,\\n            uint256 lifetime,\\n            uint256 extendedLifetime,\\n            bool isExpired\\n        )\\n    {\\n        IBundle.Bundle memory bundle = _instanceService.getBundle(bundleId);\\n        (, lifetime,,,,,) = decodeBundleParamsFromFilter(bundle.filter);\\n        uint256 lifetimeExtension = _bundleLifetimeExtension[bundleId];\\n\\n        state = bundle.state;\\n        createdAt = bundle.createdAt;\\n        extendedLifetime = lifetime + lifetimeExtension;\\n        isExpired = block.timestamp > bundle.createdAt + lifetime + lifetimeExtension;\\n    }\\n\\n\\n    function getSumInsuredPercentage()\\n        external\\n        view\\n        returns(uint256 sumInsuredPercentage)\\n    {\\n        return _sumInsuredPercentage;\\n    }\\n\\n\\n    function calculateSumInsured(uint256 protectedBalance)\\n        public\\n        view\\n        returns(uint256 sumInsured)\\n    {\\n        return (protectedBalance * _sumInsuredPercentage) / 100;\\n    }\\n\\n\\n    function depegPriceIsBelowProtectedDepegPrice(uint256 depegPrice, uint256 targetPrice)\\n        public\\n        view\\n        returns(bool isBelowProtectedPrice)\\n    {\\n        return 100 * depegPrice < targetPrice * (100 - _sumInsuredPercentage);\\n    }\\n\\n\\n    function getProtectedMinDepegPrice(uint256 targetPrice)\\n        public\\n        view\\n        returns(uint256 protectedDepegPrice)\\n    {\\n        return (targetPrice * (100 - _sumInsuredPercentage)) / 100;\\n    }\\n\\n\\n    function isComponentRegistered(uint256 componentId)\\n        private\\n        view\\n        returns(bool)\\n    {\\n        bytes32 instanceId = _instanceService.getInstanceId();\\n        uint96 componentNftId = _chainRegistry.getComponentNftId(instanceId, componentId);\\n        return _chainRegistry.exists(componentNftId);\\n    }\\n\\n    /**\\n     * @dev Register the bundle with given id in the bundle registry.\\n     */    \\n    function registerBundleInRegistry(\\n        IBundle.Bundle memory bundle,\\n        string memory name,\\n        uint256 lifetime\\n    )\\n        private\\n    {\\n        bytes32 instanceId = _instanceService.getInstanceId();\\n        uint256 expiration = bundle.createdAt + lifetime;\\n\\n        // register bundle and keep track of nft id\\n        _bundleNftId[bundle.id] = _chainRegistry.registerBundle(\\n            instanceId,\\n            bundle.riskpoolId,\\n            bundle.id,\\n            name,\\n            expiration\\n        );\\n    }\\n\\n    function getBundleInfo(uint256 bundleId)\\n        external\\n        view\\n        returns(BundleInfo memory info)\\n    {\\n        IBundle.Bundle memory bundle = _instanceService.getBundle(bundleId);\\n        IBundleToken token = _instanceService.getBundleToken();\\n\\n        (\\n            string memory name,\\n            uint256 lifetime,\\n            uint256 minSumInsured,\\n            uint256 maxSumInsured,\\n            uint256 minDuration,\\n            uint256 maxDuration,\\n            uint256 annualPercentageReturn\\n        ) = decodeBundleParamsFromFilter(bundle.filter);\\n\\n        address tokenOwner = token.burned(bundle.tokenId) ? address(0) : token.ownerOf(bundle.tokenId);\\n        uint256 capitalSupportedByStaking = getSupportedCapitalAmount(bundleId);\\n        uint256 extendedLifetime = lifetime + _bundleLifetimeExtension[bundleId];\\n\\n        info = BundleInfo(\\n            bundleId,\\n            name,\\n            bundle.state,\\n            bundle.tokenId,\\n            tokenOwner,\\n            extendedLifetime,\\n            minSumInsured,\\n            maxSumInsured,\\n            minDuration,\\n            maxDuration,\\n            annualPercentageReturn,\\n            capitalSupportedByStaking,\\n            bundle.capital,\\n            bundle.lockedCapital,\\n            bundle.balance,\\n            bundle.createdAt\\n        );\\n    }\\n\\n\\n    function getFilterDataStructure() external override pure returns(string memory) {\\n        return \\\"(uint256 minSumInsured,uint256 maxSumInsured,uint256 minDuration,uint256 maxDuration,uint256 annualPercentageReturn)\\\";\\n    }\\n\\n    function encodeBundleParamsAsFilter(\\n        string memory name,\\n        uint256 lifetime,\\n        uint256 minSumInsured,\\n        uint256 maxSumInsured,\\n        uint256 minDuration,\\n        uint256 maxDuration,\\n        uint256 annualPercentageReturn\\n    )\\n        public pure\\n        returns (bytes memory filter)\\n    {\\n        filter = abi.encode(\\n            name,\\n            lifetime,\\n            minSumInsured,\\n            maxSumInsured,\\n            minDuration,\\n            maxDuration,\\n            annualPercentageReturn\\n        );\\n    }\\n\\n    function decodeBundleParamsFromFilter(\\n        bytes memory filter\\n    )\\n        public pure\\n        returns (\\n            string memory name,\\n            uint256 lifetime,\\n            uint256 minSumInsured,\\n            uint256 maxSumInsured,\\n            uint256 minDuration,\\n            uint256 maxDuration,\\n            uint256 annualPercentageReturn\\n        )\\n    {\\n        (\\n            name,\\n            lifetime,\\n            minSumInsured,\\n            maxSumInsured,\\n            minDuration,\\n            maxDuration,\\n            annualPercentageReturn\\n        ) = abi.decode(filter, (string, uint256, uint256, uint256, uint256, uint256, uint256));\\n    }\\n\\n\\n    function encodeApplicationParameterAsData(\\n        address wallet,\\n        uint256 protectedBalance,\\n        uint256 duration,\\n        uint256 bundleId,\\n        uint256 maxPremium\\n    )\\n        public pure\\n        returns (bytes memory data)\\n    {\\n        data = abi.encode(\\n            wallet,\\n            protectedBalance,\\n            duration,\\n            bundleId,\\n            maxPremium\\n        );\\n    }\\n\\n\\n    function decodeApplicationParameterFromData(\\n        bytes memory data\\n    )\\n        public pure\\n        returns (\\n            address wallet,\\n            uint256 protectedBalance,\\n            uint256 duration,\\n            uint256 bundleId,\\n            uint256 maxPremium\\n        )\\n    {\\n        (\\n            wallet,\\n            protectedBalance,\\n            duration,\\n            bundleId,\\n            maxPremium\\n        ) = abi.decode(data, (address, uint256, uint256, uint256, uint256));\\n    }\\n\\n    function getBundleFilter(uint256 bundleId) public view returns (bytes memory filter) {\\n        IBundle.Bundle memory bundle = _instanceService.getBundle(bundleId);\\n        filter = bundle.filter;\\n    }\\n\\n    // sorts bundles on increasing annual percentage return\\n    function isHigherPriorityBundle(uint256 firstBundleId, uint256 secondBundleId) \\n        public override \\n        view \\n        returns (bool firstBundleIsHigherPriority) \\n    {\\n        uint256 firstApr = _getBundleApr(firstBundleId);\\n        uint256 secondApr = _getBundleApr(secondBundleId);\\n        firstBundleIsHigherPriority = (firstApr < secondApr);\\n    }\\n\\n\\n    function bundleMatchesApplication(\\n        IBundle.Bundle memory bundle, \\n        IPolicy.Application memory application\\n    ) \\n        public view override\\n        returns(bool isMatching) \\n    {}\\n\\n\\n    function bundleMatchesApplication2(\\n        IBundle.Bundle memory bundle, \\n        IPolicy.Application memory application\\n    ) \\n        public override\\n        returns(bool isMatching) \\n    {\\n        (\\n            , // name not needed\\n            uint256 lifetime,\\n            uint256 minSumInsured,\\n            uint256 maxSumInsured,\\n            uint256 minDuration,\\n            uint256 maxDuration,\\n            uint256 annualPercentageReturn\\n        ) = decodeBundleParamsFromFilter(bundle.filter);\\n\\n        // enforce max bundle lifetime\\n        uint256 extendedLifetime = lifetime + _bundleLifetimeExtension[bundle.id];\\n        if(block.timestamp > bundle.createdAt + extendedLifetime) {\\n            // TODO this expired bundle bundle should be removed from active bundles\\n            // ideally this is done in the core, at least should be done\\n            // in basicriskpool template\\n            // may not be done here:\\n            // - lockBundle does not work as riskpool is not owner of bundle\\n            // - remove from active list would modify list that is iterateed over right now...\\n\\n            emit LogBundleExpired(bundle.id, bundle.createdAt, extendedLifetime);\\n            return false;\\n        }\\n\\n        // detailed match check\\n        return detailedBundleApplicationMatch(\\n            bundle.id,\\n            minSumInsured,\\n            maxSumInsured,\\n            minDuration,\\n            maxDuration,\\n            annualPercentageReturn,\\n            application\\n        );\\n    }\\n\\n    function detailedBundleApplicationMatch(\\n        uint256 bundleId,\\n        uint256 minSumInsured,\\n        uint256 maxSumInsured,\\n        uint256 minDuration,\\n        uint256 maxDuration,\\n        uint256 annualPercentageReturn,\\n        IPolicy.Application memory application\\n    )\\n        public\\n        returns(bool isMatching)\\n    {\\n        (\\n            , // we don't care about the wallet address here\\n            , // we don't care about the protected balance here\\n            uint256 duration,\\n            uint256 applicationBundleId,\\n            uint256 maxPremium\\n        ) = decodeApplicationParameterFromData(application.data);\\n\\n        // if bundle id specified a match is required\\n        if(applicationBundleId > 0 && bundleId != applicationBundleId) {\\n            emit LogBundleMismatch(bundleId, applicationBundleId);\\n            return false;\\n        }\\n\\n        bool sumInsuredOk = true;\\n        bool durationOk = true;\\n        bool premiumOk = true;\\n\\n        if(application.sumInsuredAmount < minSumInsured) { sumInsuredOk = false; }\\n        if(application.sumInsuredAmount > maxSumInsured) { sumInsuredOk = false; }\\n\\n        // commented code below to indicate how to enforce hard link to stking in this contract\\n        // if(getSupportedCapitalAmount(bundle.id) < bundle.lockedCapital + application.sumInsuredAmount) {\\n        //     sumInsuredOk = false;\\n        // }\\n\\n        if(duration < minDuration) { durationOk = false; }\\n        if(duration > maxDuration) { durationOk = false; }\\n        \\n        uint256 premium = calculatePremium(application.sumInsuredAmount, duration, annualPercentageReturn);\\n        if(premium > maxPremium) { premiumOk = false; }\\n\\n        emit LogBundleMatchesApplication(bundleId, sumInsuredOk, durationOk, premiumOk);\\n        return (sumInsuredOk && durationOk && premiumOk);\\n    }\\n\\n\\n    function getSupportedCapitalAmount(uint256 bundleId)\\n        public view\\n        returns(uint256 capitalCap)\\n    {\\n        // if no staking data provider is available anything goes\\n        if(address(_staking) == address(0)) {\\n            return _bundleCapitalCap;\\n        }\\n\\n        // otherwise: get amount supported by staking\\n        uint96 bundleNftId = _bundleNftId[bundleId];\\n        return _staking.capitalSupport(bundleNftId);\\n    }\\n\\n\\n    function calculatePremium(\\n        uint256 sumInsured,\\n        uint256 duration,\\n        uint256 annualPercentageReturn\\n    ) \\n        public pure\\n        returns(uint256 premiumAmount) \\n    {\\n        uint256 policyDurationReturn = annualPercentageReturn * duration / ONE_YEAR_DURATION;\\n        premiumAmount = sumInsured * policyDurationReturn / APR_100_PERCENTAGE;\\n    }\\n\\n    function getRiskpoolCapitalCap() public view returns (uint256 poolCapitalCap) {\\n        return _riskpoolCapitalCap;\\n    }\\n\\n    function getBundleCapitalCap() public view returns (uint256 bundleCapitalCap) {\\n        return _bundleCapitalCap;\\n    }\\n\\n    function getMaxBundleLifetime() public pure returns(uint256 maxBundleLifetime) {\\n        return MAX_BUNDLE_LIFETIME;\\n    }\\n\\n\\n    function getOneYearDuration() public pure returns(uint256 yearDuration) { \\n        return ONE_YEAR_DURATION;\\n    }\\n\\n\\n    function getApr100PercentLevel() public pure returns(uint256 apr100PercentLevel) { \\n        return APR_100_PERCENTAGE;\\n    }\\n\\n\\n    function _afterFundBundle(uint256 bundleId, uint256 amount)\\n        internal\\n        override\\n        view\\n    {\\n        require(\\n            _instanceService.getBundle(bundleId).capital <= _bundleCapitalCap, \\n            \\\"ERROR:DRP-100:FUNDING_EXCEEDS_BUNDLE_CAPITAL_CAP\\\");\\n\\n        require(\\n            getCapital() <= _riskpoolCapitalCap, \\n            \\\"ERROR:DRP-101:FUNDING_EXCEEDS_RISKPOOL_CAPITAL_CAP\\\");\\n    }\\n\\n\\n    function _getBundleApr(uint256 bundleId) internal view returns (uint256 annualPercentageReturn) {\\n        bytes memory filter = getBundleFilter(bundleId);\\n        (,,,,,, annualPercentageReturn) = decodeBundleParamsFromFilter(filter);\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"BasicRiskpool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\n\\nimport \\\"Riskpool.sol\\\";\\nimport \\\"IBundle.sol\\\";\\nimport \\\"IPolicy.sol\\\";\\n\\n// basic riskpool always collateralizes one application using exactly one bundle\\nabstract contract BasicRiskpool is Riskpool {\\n\\n    event LogBasicRiskpoolBundlesAndPolicies(uint256 activeBundles, uint256 bundleId);\\n    event LogBasicRiskpoolCandidateBundleAmountCheck(uint256 index, uint256 bundleId, uint256 maxAmount, uint256 collateralAmount);\\n\\n    // remember bundleId for each processId\\n    // approach only works for basic risk pool where a\\n    // policy is collateralized by exactly one bundle\\n    mapping(bytes32 /* processId */ => uint256 /** bundleId */) internal _collateralizedBy;\\n    uint32 private _policiesCounter = 0;\\n\\n    constructor(\\n        bytes32 name,\\n        uint256 collateralization,\\n        uint256 sumOfSumInsuredCap,\\n        address erc20Token,\\n        address wallet,\\n        address registry\\n    )\\n        Riskpool(name, collateralization, sumOfSumInsuredCap, erc20Token, wallet, registry)\\n    { }\\n\\n    \\n\\n    // needs to remember which bundles helped to cover ther risk\\n    // simple (retail) approach: single policy covered by single bundle\\n    // first bundle with a match and sufficient capacity wins\\n    // Component <- Riskpool <- BasicRiskpool <- TestRiskpool\\n    // complex (wholesale) approach: single policy covered by many bundles\\n    // Component <- Riskpool <- AdvancedRiskpool <- TestRiskpool\\n    function _lockCollateral(bytes32 processId, uint256 collateralAmount) \\n        internal override\\n        returns(bool success) \\n    {\\n        uint256 activeBundles = activeBundles();\\n        uint256 capital = getCapital();\\n        uint256 lockedCapital = getTotalValueLocked();\\n\\n        emit LogBasicRiskpoolBundlesAndPolicies(activeBundles, _policiesCounter);\\n        require(activeBundles > 0, \\\"ERROR:BRP-001:NO_ACTIVE_BUNDLES\\\");\\n        require(capital > lockedCapital, \\\"ERROR:BRP-002:NO_FREE_CAPITAL\\\");\\n\\n        // ensure there is a chance to find the collateral\\n        if(capital >= lockedCapital + collateralAmount) {\\n            IPolicy.Application memory application = _instanceService.getApplication(processId);\\n\\n            // initialize bundle idx with round robin based on active bundles\\n            uint idx = _policiesCounter % activeBundles;\\n            \\n            // basic riskpool implementation: policy coverage by single bundle only/\\n            // the initial bundle is selected via round robin based on the policies counter.\\n            // If a bundle does not match (application not matching or insufficient funds for collateral) the next one is tried. \\n            // This is continued until all bundles have been tried once. If no bundle matches the policy is rejected.\\n            for (uint256 i = 0; i < activeBundles && !success; i++) {\\n                uint256 bundleId = getActiveBundleId(idx);\\n                IBundle.Bundle memory bundle = _instanceService.getBundle(bundleId);\\n                bool isMatching = bundleMatchesApplication(bundle, application);\\n                emit LogRiskpoolBundleMatchesPolicy(bundleId, isMatching);\\n\\n                if (isMatching) {\\n                    uint256 maxAmount = bundle.capital - bundle.lockedCapital;\\n                    emit LogBasicRiskpoolCandidateBundleAmountCheck(idx, bundleId, maxAmount, collateralAmount);\\n\\n                    if (maxAmount >= collateralAmount) {\\n                        _riskpoolService.collateralizePolicy(bundleId, processId, collateralAmount);\\n                        _collateralizedBy[processId] = bundleId;\\n                        success = true;\\n                        _policiesCounter++;\\n                    } else {\\n                        idx = (idx + 1) % activeBundles;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    function _processPayout(bytes32 processId, uint256 amount)\\n        internal override\\n    {\\n        uint256 bundleId = _collateralizedBy[processId];\\n        _riskpoolService.processPayout(bundleId, processId, amount);\\n    }\\n\\n    function _processPremium(bytes32 processId, uint256 amount)\\n        internal override\\n    {\\n        uint256 bundleId = _collateralizedBy[processId];\\n        _riskpoolService.processPremium(bundleId, processId, amount);\\n    }\\n\\n    function _releaseCollateral(bytes32 processId) \\n        internal override\\n        returns(uint256 collateralAmount) \\n    {        \\n        uint256 bundleId = _collateralizedBy[processId];\\n        collateralAmount = _riskpoolService.releasePolicy(bundleId, processId);\\n    }\\n}\"\r\n    },\r\n    \"Riskpool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\n\\nimport \\\"IRiskpool.sol\\\";\\nimport \\\"Component.sol\\\";\\n\\nimport \\\"IBundle.sol\\\";\\nimport \\\"IPolicy.sol\\\";\\nimport \\\"IInstanceService.sol\\\";\\nimport \\\"IRiskpoolService.sol\\\";\\n\\nimport \\\"IERC721.sol\\\";\\n\\nabstract contract Riskpool is \\n    IRiskpool, \\n    Component \\n{    \\n    // used for representation of collateralization\\n    // collateralization between 0 and 1 (1=100%) \\n    // value might be larger when overcollateralization\\n    uint256 public constant FULL_COLLATERALIZATION_LEVEL = 10**18;\\n    string public constant DEFAULT_FILTER_DATA_STRUCTURE = \\\"\\\";\\n\\n    IInstanceService internal _instanceService; \\n    IRiskpoolService internal _riskpoolService;\\n    IERC721 internal _bundleToken;\\n    \\n    // keep track of bundles associated with this riskpool\\n    uint256 [] internal _bundleIds;\\n\\n    address private _wallet;\\n    address private _erc20Token;\\n    uint256 private _collateralization;\\n    uint256 private _sumOfSumInsuredCap;\\n    uint256 private _maxNumberOfActiveBundles;\\n\\n    modifier onlyPool {\\n        require(\\n            _msgSender() == _getContractAddress(\\\"Pool\\\"),\\n            \\\"ERROR:RPL-001:ACCESS_DENIED\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyBundleOwner(uint256 bundleId) {\\n        IBundle.Bundle memory bundle = _instanceService.getBundle(bundleId);\\n        address bundleOwner = _bundleToken.ownerOf(bundle.tokenId);\\n\\n        require(\\n            _msgSender() == bundleOwner,\\n            \\\"ERROR:BUC-001:NOT_BUNDLE_OWNER\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(\\n        bytes32 name,\\n        uint256 collateralization,\\n        uint256 sumOfSumInsuredCap,\\n        address erc20Token,\\n        address wallet,\\n        address registry\\n    )\\n        Component(name, ComponentType.Riskpool, registry)\\n    { \\n        _collateralization = collateralization;\\n\\n        require(sumOfSumInsuredCap != 0, \\\"ERROR:RPL-002:SUM_OF_SUM_INSURED_CAP_ZERO\\\");\\n        _sumOfSumInsuredCap = sumOfSumInsuredCap;\\n\\n        require(erc20Token != address(0), \\\"ERROR:RPL-003:ERC20_ADDRESS_ZERO\\\");\\n        _erc20Token = erc20Token;\\n\\n        require(wallet != address(0), \\\"ERROR:RPL-004:WALLET_ADDRESS_ZERO\\\");\\n        _wallet = wallet;\\n\\n        _instanceService = IInstanceService(_getContractAddress(\\\"InstanceService\\\")); \\n        _riskpoolService = IRiskpoolService(_getContractAddress(\\\"RiskpoolService\\\"));\\n        _bundleToken = _instanceService.getBundleToken();\\n    }\\n\\n    function _afterPropose() internal override virtual {\\n        _riskpoolService.registerRiskpool(\\n            _wallet,\\n            _erc20Token, \\n            _collateralization,\\n            _sumOfSumInsuredCap\\n        );\\n    }\\n\\n    function createBundle(bytes memory filter, uint256 initialAmount) \\n        public virtual override\\n        returns(uint256 bundleId)\\n    {\\n        address bundleOwner = _msgSender();\\n        bundleId = _riskpoolService.createBundle(bundleOwner, filter, initialAmount);\\n        _bundleIds.push(bundleId);\\n\\n        emit LogRiskpoolBundleCreated(bundleId, initialAmount);\\n    }\\n\\n    function fundBundle(uint256 bundleId, uint256 amount) \\n        external override\\n        onlyBundleOwner(bundleId)\\n        returns(uint256 netAmount)\\n    {\\n        netAmount = _riskpoolService.fundBundle(bundleId, amount);\\n    }\\n\\n    function defundBundle(uint256 bundleId, uint256 amount)\\n        external override\\n        onlyBundleOwner(bundleId)\\n        returns(uint256 netAmount)\\n    {\\n        netAmount = _riskpoolService.defundBundle(bundleId, amount);\\n    }\\n\\n    function lockBundle(uint256 bundleId)\\n        external override\\n        onlyBundleOwner(bundleId)\\n    {\\n        _riskpoolService.lockBundle(bundleId);\\n    }\\n\\n    function unlockBundle(uint256 bundleId)\\n        external override\\n        onlyBundleOwner(bundleId)\\n    {\\n        _riskpoolService.unlockBundle(bundleId);\\n    }\\n\\n    function closeBundle(uint256 bundleId)\\n        external override\\n        onlyBundleOwner(bundleId)\\n    {\\n        _riskpoolService.closeBundle(bundleId);\\n    }\\n\\n    function burnBundle(uint256 bundleId)\\n        external override\\n        onlyBundleOwner(bundleId)\\n    {\\n        _riskpoolService.burnBundle(bundleId);\\n    }\\n\\n    function collateralizePolicy(bytes32 processId, uint256 collateralAmount) \\n        external override\\n        onlyPool\\n        returns(bool success) \\n    {\\n        success = _lockCollateral(processId, collateralAmount);\\n        emit LogRiskpoolCollateralLocked(processId, collateralAmount, success);\\n    }\\n\\n    function processPolicyPayout(bytes32 processId, uint256 amount)\\n        external override\\n        onlyPool\\n    {\\n        _processPayout(processId, amount);\\n        emit LogRiskpoolPayoutProcessed(processId, amount);\\n    }\\n\\n    function processPolicyPremium(bytes32 processId, uint256 amount)\\n        external override\\n        onlyPool\\n    {\\n        _processPremium(processId, amount);\\n        emit LogRiskpoolPremiumProcessed(processId, amount);\\n    }\\n\\n    function releasePolicy(bytes32 processId) \\n        external override\\n        onlyPool\\n    {\\n        uint256 collateralAmount = _releaseCollateral(processId);\\n        emit LogRiskpoolCollateralReleased(processId, collateralAmount);\\n    }\\n\\n    function setMaximumNumberOfActiveBundles(uint256 maximumNumberOfActiveBundles)\\n        external override\\n        onlyOwner\\n    {\\n        uint256 riskpoolId = getId();\\n        _riskpoolService.setMaximumNumberOfActiveBundles(riskpoolId, maximumNumberOfActiveBundles);\\n    }\\n\\n    function getMaximumNumberOfActiveBundles()\\n        public view override\\n        returns(uint256 maximumNumberOfActiveBundles)\\n    {\\n        uint256 riskpoolId = getId();\\n        return _instanceService.getMaximumNumberOfActiveBundles(riskpoolId);\\n    }\\n\\n    function getWallet() public view override returns(address) {\\n        return _wallet;\\n    }\\n\\n    function getErc20Token() public view override returns(address) {\\n        return _erc20Token;\\n    }\\n\\n    function getSumOfSumInsuredCap() public view override returns (uint256) {\\n        return _sumOfSumInsuredCap;\\n    }\\n\\n    function getFullCollateralizationLevel() public pure override returns (uint256) {\\n        return FULL_COLLATERALIZATION_LEVEL;\\n    }\\n\\n    function getCollateralizationLevel() public view override returns (uint256) {\\n        return _collateralization;\\n    }\\n\\n    function bundles() public override view returns(uint256) {\\n        return _bundleIds.length;\\n    }\\n\\n    function getBundle(uint256 idx) public override view returns(IBundle.Bundle memory) {\\n        require(idx < _bundleIds.length, \\\"ERROR:RPL-006:BUNDLE_INDEX_TOO_LARGE\\\");\\n\\n        uint256 bundleIdx = _bundleIds[idx];\\n        return _instanceService.getBundle(bundleIdx);\\n    }\\n\\n    function activeBundles() public override view returns(uint256) {\\n        uint256 riskpoolId = getId();\\n        return _instanceService.activeBundles(riskpoolId);\\n    }\\n\\n    function getActiveBundleId(uint256 idx) public override view returns(uint256 bundleId) {\\n        uint256 riskpoolId = getId();\\n        require(idx < _instanceService.activeBundles(riskpoolId), \\\"ERROR:RPL-007:ACTIVE_BUNDLE_INDEX_TOO_LARGE\\\");\\n\\n        return _instanceService.getActiveBundleId(riskpoolId, idx);\\n    }\\n\\n    function getFilterDataStructure() external override pure returns(string memory) {\\n        return DEFAULT_FILTER_DATA_STRUCTURE;\\n    }\\n\\n    function getCapital() public override view returns(uint256) {\\n        uint256 riskpoolId = getId();\\n        return _instanceService.getCapital(riskpoolId);\\n    }\\n\\n    function getTotalValueLocked() public override view returns(uint256) {\\n        uint256 riskpoolId = getId();\\n        return _instanceService.getTotalValueLocked(riskpoolId);\\n    }\\n\\n    function getCapacity() public override view returns(uint256) {\\n        uint256 riskpoolId = getId();\\n        return _instanceService.getCapacity(riskpoolId);\\n    }\\n\\n    function getBalance() public override view returns(uint256) {\\n        uint256 riskpoolId = getId();\\n        return _instanceService.getBalance(riskpoolId);\\n    }\\n\\n    function bundleMatchesApplication(\\n        IBundle.Bundle memory bundle, \\n        IPolicy.Application memory application\\n    ) public override view virtual returns(bool isMatching);\\n\\n    function _afterArchive() internal view override { \\n        uint256 riskpoolId = getId();\\n        require(\\n            _instanceService.unburntBundles(riskpoolId) == 0, \\n            \\\"ERROR:RPL-010:RISKPOOL_HAS_UNBURNT_BUNDLES\\\"\\n            );\\n    }\\n\\n    function _lockCollateral(bytes32 processId, uint256 collateralAmount) internal virtual returns(bool success);\\n    function _processPremium(bytes32 processId, uint256 amount) internal virtual;\\n    function _processPayout(bytes32 processId, uint256 amount) internal virtual;\\n    function _releaseCollateral(bytes32 processId) internal virtual returns(uint256 collateralAmount);\\n\\n}\"\r\n    },\r\n    \"IRiskpool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\n\\nimport \\\"IComponent.sol\\\";\\nimport \\\"IBundle.sol\\\";\\nimport \\\"IPolicy.sol\\\";\\n\\ninterface IRiskpool is IComponent {\\n\\n    event LogRiskpoolCreated (address riskpoolAddress);\\n    event LogRiskpoolProposed (uint256 id);\\n    event LogRiskpoolApproved (uint256 id);\\n    event LogRiskpoolDeclined (uint256 id);\\n\\n    event LogRiskpoolBundleCreated(uint256 bundleId, uint256 amount);\\n    event LogRiskpoolBundleMatchesPolicy(uint256 bundleId, bool isMatching);\\n    event LogRiskpoolCollateralLocked(bytes32 processId, uint256 collateralAmount, bool isSecured);\\n\\n    event LogRiskpoolPremiumProcessed(bytes32 processId, uint256 amount);\\n    event LogRiskpoolPayoutProcessed(bytes32 processId, uint256 amount);\\n    event LogRiskpoolCollateralReleased(bytes32 processId, uint256 collateralAmount);\\n\\n\\n    function createBundle(bytes memory filter, uint256 initialAmount) external returns(uint256 bundleId);\\n    function fundBundle(uint256 bundleId, uint256 amount) external returns(uint256 netAmount);\\n    function defundBundle(uint256 bundleId, uint256 amount) external returns(uint256 netAmount);\\n\\n    function lockBundle(uint256 bundleId) external;\\n    function unlockBundle(uint256 bundleId) external;\\n    function closeBundle(uint256 bundleId) external;\\n    function burnBundle(uint256 bundleId) external;\\n\\n    function collateralizePolicy(bytes32 processId, uint256 collateralAmount) external returns(bool isSecured);\\n    function processPolicyPremium(bytes32 processId, uint256 amount) external;\\n    function processPolicyPayout(bytes32 processId, uint256 amount) external;\\n    function releasePolicy(bytes32 processId) external;\\n\\n    function getCollateralizationLevel() external view returns (uint256);\\n    function getFullCollateralizationLevel() external view returns (uint256);\\n\\n    function bundleMatchesApplication(\\n        IBundle.Bundle memory bundle, \\n        IPolicy.Application memory application\\n    ) \\n        external view returns(bool isMatching);   \\n    \\n    function getFilterDataStructure() external view returns(string memory);\\n\\n    function bundles() external view returns(uint256);\\n    function getBundle(uint256 idx) external view returns(IBundle.Bundle memory);\\n\\n    function activeBundles() external view returns(uint256);\\n    function getActiveBundleId(uint256 idx) external view returns(uint256 bundleId);\\n\\n    function getWallet() external view returns(address);\\n    function getErc20Token() external view returns(address);\\n\\n    function getSumOfSumInsuredCap() external view returns (uint256);\\n    function getCapital() external view returns(uint256);\\n    function getTotalValueLocked() external view returns(uint256); \\n    function getCapacity() external view returns(uint256); \\n    function getBalance() external view returns(uint256); \\n\\n    function setMaximumNumberOfActiveBundles(uint256 maximumNumberOfActiveBundles) external; \\n    function getMaximumNumberOfActiveBundles() external view returns(uint256 maximumNumberOfActiveBundles);\\n}\\n\"\r\n    },\r\n    \"IComponent.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\n\\nimport \\\"IRegistry.sol\\\";\\n\\ninterface IComponent {\\n\\n    enum ComponentType {\\n        Oracle,\\n        Product,\\n        Riskpool\\n    }\\n\\n    enum ComponentState {\\n        Created,\\n        Proposed,\\n        Declined,\\n        Active,\\n        Paused,\\n        Suspended,\\n        Archived\\n    }\\n\\n    event LogComponentCreated (\\n        bytes32 componentName,\\n        IComponent.ComponentType componentType,\\n        address componentAddress,\\n        address registryAddress);\\n\\n    function setId(uint256 id) external;\\n\\n    function getName() external view returns(bytes32);\\n    function getId() external view returns(uint256);\\n    function getType() external view returns(ComponentType);\\n    function getState() external view returns(ComponentState);\\n    function getOwner() external view returns(address);\\n\\n    function isProduct() external view returns(bool);\\n    function isOracle() external view returns(bool);\\n    function isRiskpool() external view returns(bool);\\n\\n    function getRegistry() external view returns(IRegistry);\\n\\n    function proposalCallback() external;\\n    function approvalCallback() external; \\n    function declineCallback() external;\\n    function suspendCallback() external;\\n    function resumeCallback() external;\\n    function pauseCallback() external;\\n    function unpauseCallback() external;\\n    function archiveCallback() external;\\n}\"\r\n    },\r\n    \"IRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\n\\ninterface IRegistry {\\n\\n    event LogContractRegistered(\\n        bytes32 release,\\n        bytes32 contractName,\\n        address contractAddress,\\n        bool isNew\\n    );\\n\\n    event LogContractDeregistered(bytes32 release, bytes32 contractName);\\n\\n    event LogReleasePrepared(bytes32 release);\\n\\n    function registerInRelease(\\n        bytes32 _release,\\n        bytes32 _contractName,\\n        address _contractAddress\\n    ) external;\\n\\n    function register(bytes32 _contractName, address _contractAddress) external;\\n\\n    function deregisterInRelease(bytes32 _release, bytes32 _contractName)\\n        external;\\n\\n    function deregister(bytes32 _contractName) external;\\n\\n    function prepareRelease(bytes32 _newRelease) external;\\n\\n    function getContractInRelease(bytes32 _release, bytes32 _contractName)\\n        external\\n        view\\n        returns (address _contractAddress);\\n\\n    function getContract(bytes32 _contractName)\\n        external\\n        view\\n        returns (address _contractAddress);\\n\\n    function getRelease() external view returns (bytes32 _release);\\n\\n    function ensureSender(address sender, bytes32 _contractName) external view returns(bool _senderMatches);\\n\\n    function contracts() external view returns (uint256 _numberOfContracts);\\n\\n    function contractName(uint256 idx) external view returns (bytes32 _contractName);\\n\\n}\\n\"\r\n    },\r\n    \"IBundle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\n\\ninterface IBundle {\\n\\n    event LogBundleCreated(\\n        uint256 bundleId, \\n        uint256 riskpoolId, \\n        address owner,\\n        BundleState state,\\n        uint256 amount\\n    );\\n\\n    event LogBundleStateChanged(uint256 bundleId, BundleState oldState, BundleState newState);\\n\\n    event LogBundleCapitalProvided(uint256 bundleId, address sender, uint256 amount, uint256 capacity);\\n    event LogBundleCapitalWithdrawn(uint256 bundleId, address recipient, uint256 amount, uint256 capacity);\\n\\n    event LogBundlePolicyCollateralized(uint256 bundleId, bytes32 processId, uint256 amount, uint256 capacity);\\n    event LogBundlePayoutProcessed(uint256 bundleId, bytes32 processId, uint256 amount);\\n    event LogBundlePolicyReleased(uint256 bundleId, bytes32 processId, uint256 amount, uint256 capacity);\\n\\n    enum BundleState {\\n        Active,\\n        Locked,\\n        Closed,\\n        Burned\\n    }\\n\\n    struct Bundle {\\n        uint256 id;\\n        uint256 riskpoolId;\\n        uint256 tokenId;\\n        BundleState state;\\n        bytes filter; // required conditions for applications to be considered for collateralization by this bundle\\n        uint256 capital; // net investment capital amount (<= balance)\\n        uint256 lockedCapital; // capital amount linked to collateralizaion of non-closed policies (<= capital)\\n        uint256 balance; // total amount of funds: net investment capital + net premiums - payouts\\n        uint256 createdAt;\\n        uint256 updatedAt;\\n    }\\n\\n    function create(address owner_, uint256 riskpoolId_, bytes calldata filter_, uint256 amount_) external returns(uint256 bundleId);\\n    function fund(uint256 bundleId, uint256 amount) external;\\n    function defund(uint256 bundleId, uint256 amount) external;\\n\\n    function lock(uint256 bundleId) external;\\n    function unlock(uint256 bundleId) external;\\n    function close(uint256 bundleId) external;\\n    function burn(uint256 bundleId) external;\\n\\n    function collateralizePolicy(uint256 bundleId, bytes32 processId, uint256 collateralAmount) external;\\n    function processPremium(uint256 bundleId, bytes32 processId, uint256 amount) external;\\n    function processPayout(uint256 bundleId, bytes32 processId, uint256 amount) external;\\n    function releasePolicy(uint256 bundleId, bytes32 processId) external returns(uint256 collateralAmount);\\n}\\n\"\r\n    },\r\n    \"IPolicy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\n\\ninterface IPolicy {\\n\\n    // Events\\n    event LogMetadataCreated(\\n        address owner,\\n        bytes32 processId,\\n        uint256 productId, \\n        PolicyFlowState state\\n    );\\n\\n    event LogMetadataStateChanged(\\n        bytes32 processId, \\n        PolicyFlowState state\\n    );\\n\\n    event LogApplicationCreated(\\n        bytes32 processId, \\n        uint256 premiumAmount, \\n        uint256 sumInsuredAmount\\n    );\\n\\n    event LogApplicationRevoked(bytes32 processId);\\n    event LogApplicationUnderwritten(bytes32 processId);\\n    event LogApplicationDeclined(bytes32 processId);\\n\\n    event LogPolicyCreated(bytes32 processId);\\n    event LogPolicyExpired(bytes32 processId);\\n    event LogPolicyClosed(bytes32 processId);\\n\\n    event LogPremiumCollected(bytes32 processId, uint256 amount);\\n    \\n    event LogApplicationSumInsuredAdjusted(bytes32 processId, uint256 sumInsuredAmountOld, uint256 sumInsuredAmount);\\n    event LogApplicationPremiumAdjusted(bytes32 processId, uint256 premiumAmountOld, uint256 premiumAmount);\\n    event LogPolicyPremiumAdjusted(bytes32 processId, uint256 premiumExpectedAmountOld, uint256 premiumExpectedAmount);\\n\\n    event LogClaimCreated(bytes32 processId, uint256 claimId, uint256 claimAmount);\\n    event LogClaimConfirmed(bytes32 processId, uint256 claimId, uint256 confirmedAmount);\\n    event LogClaimDeclined(bytes32 processId, uint256 claimId);\\n    event LogClaimClosed(bytes32 processId, uint256 claimId);\\n\\n    event LogPayoutCreated(\\n        bytes32 processId,\\n        uint256 claimId,\\n        uint256 payoutId,\\n        uint256 amount\\n    );\\n\\n    event LogPayoutProcessed(\\n        bytes32 processId, \\n        uint256 payoutId\\n    );\\n\\n    // States\\n    enum PolicyFlowState {Started, Active, Finished}\\n    enum ApplicationState {Applied, Revoked, Underwritten, Declined}\\n    enum PolicyState {Active, Expired, Closed}\\n    enum ClaimState {Applied, Confirmed, Declined, Closed}\\n    enum PayoutState {Expected, PaidOut}\\n\\n    // Objects\\n    struct Metadata {\\n        address owner;\\n        uint256 productId;\\n        PolicyFlowState state;\\n        bytes data;\\n        uint256 createdAt;\\n        uint256 updatedAt;\\n    }\\n\\n    struct Application {\\n        ApplicationState state;\\n        uint256 premiumAmount;\\n        uint256 sumInsuredAmount;\\n        bytes data; \\n        uint256 createdAt;\\n        uint256 updatedAt;\\n    }\\n\\n    struct Policy {\\n        PolicyState state;\\n        uint256 premiumExpectedAmount;\\n        uint256 premiumPaidAmount;\\n        uint256 claimsCount;\\n        uint256 openClaimsCount;\\n        uint256 payoutMaxAmount;\\n        uint256 payoutAmount;\\n        uint256 createdAt;\\n        uint256 updatedAt;\\n    }\\n\\n    struct Claim {\\n        ClaimState state;\\n        uint256 claimAmount;\\n        uint256 paidAmount;\\n        bytes data;\\n        uint256 createdAt;\\n        uint256 updatedAt;\\n    }\\n\\n    struct Payout {\\n        uint256 claimId;\\n        PayoutState state;\\n        uint256 amount;\\n        bytes data;\\n        uint256 createdAt;\\n        uint256 updatedAt;\\n    }\\n\\n    function createPolicyFlow(\\n        address owner,\\n        uint256 productId, \\n        bytes calldata data\\n    ) external returns(bytes32 processId);\\n\\n    function createApplication(\\n        bytes32 processId, \\n        uint256 premiumAmount,\\n        uint256 sumInsuredAmount,\\n        bytes calldata data\\n    ) external;\\n\\n    function revokeApplication(bytes32 processId) external;\\n    function underwriteApplication(bytes32 processId) external;\\n    function declineApplication(bytes32 processId) external;\\n\\n    function collectPremium(bytes32 processId, uint256 amount) external;\\n\\n    function adjustPremiumSumInsured(\\n        bytes32 processId, \\n        uint256 expectedPremiumAmount,\\n        uint256 sumInsuredAmount\\n    ) external;\\n\\n    function createPolicy(bytes32 processId) external;\\n    function expirePolicy(bytes32 processId) external;\\n    function closePolicy(bytes32 processId) external;\\n\\n    function createClaim(\\n        bytes32 processId, \\n        uint256 claimAmount, \\n        bytes calldata data\\n    ) external returns (uint256 claimId);\\n\\n    function confirmClaim(\\n        bytes32 processId, \\n        uint256 claimId, \\n        uint256 confirmedAmount\\n    ) external;\\n\\n    function declineClaim(bytes32 processId, uint256 claimId) external;\\n    function closeClaim(bytes32 processId, uint256 claimId) external;\\n\\n    function createPayout(\\n        bytes32 processId,\\n        uint256 claimId,\\n        uint256 payoutAmount,\\n        bytes calldata data\\n    ) external returns (uint256 payoutId);\\n\\n    function processPayout(\\n        bytes32 processId,\\n        uint256 payoutId\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"Component.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\n\\nimport \\\"IComponent.sol\\\";\\nimport \\\"IAccess.sol\\\";\\nimport \\\"IComponentEvents.sol\\\";\\nimport \\\"IRegistry.sol\\\";\\nimport \\\"IComponentOwnerService.sol\\\";\\nimport \\\"IInstanceService.sol\\\";\\nimport \\\"Ownable.sol\\\";\\n\\n\\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/GUIDELINES.md#style-guidelines\\nabstract contract Component is \\n    IComponent,\\n    IComponentEvents,\\n    Ownable \\n{\\n    bytes32 private _componentName;\\n    uint256 private _componentId;\\n    IComponent.ComponentType private _componentType;\\n\\n    IRegistry private _registry;\\n    IAccess private _access;\\n    IComponentOwnerService private _componentOwnerService;\\n    IInstanceService private _instanceService;\\n\\n    modifier onlyInstanceOperatorService() {\\n        require(\\n             _msgSender() == _getContractAddress(\\\"InstanceOperatorService\\\"),\\n            \\\"ERROR:CMP-001:NOT_INSTANCE_OPERATOR_SERVICE\\\");\\n        _;\\n    }\\n\\n    modifier onlyComponent() {\\n        require(\\n             _msgSender() == _getContractAddress(\\\"Component\\\"),\\n            \\\"ERROR:CMP-002:NOT_COMPONENT\\\");\\n        _;\\n    }\\n\\n    modifier onlyComponentOwnerService() {\\n        require(\\n             _msgSender() == address(_componentOwnerService),\\n            \\\"ERROR:CMP-003:NOT_COMPONENT_OWNER_SERVICE\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        bytes32 name,\\n        IComponent.ComponentType componentType,\\n        address registry\\n    )\\n        Ownable()\\n    {\\n        require(registry != address(0), \\\"ERROR:CMP-004:REGISTRY_ADDRESS_ZERO\\\");\\n\\n        _registry = IRegistry(registry);\\n        _access = _getAccess();\\n        _componentOwnerService = _getComponentOwnerService();\\n        _instanceService = _getInstanceService();\\n\\n        _componentName = name;\\n        _componentType = componentType;\\n\\n        emit LogComponentCreated(\\n            _componentName, \\n            _componentType, \\n            address(this), \\n            address(_registry));\\n    }\\n\\n    function setId(uint256 id) external override onlyComponent { _componentId = id; }\\n\\n    function getName() public override view returns(bytes32) { return _componentName; }\\n    function getId() public override view returns(uint256) { return _componentId; }\\n    function getType() public override view returns(IComponent.ComponentType) { return _componentType; }\\n    function getState() public override view returns(IComponent.ComponentState) { return _instanceService.getComponentState(_componentId); }\\n    function getOwner() public override view returns(address) { return owner(); }\\n\\n    function isProduct() public override view returns(bool) { return _componentType == IComponent.ComponentType.Product; }\\n    function isOracle() public override view returns(bool) { return _componentType == IComponent.ComponentType.Oracle; }\\n    function isRiskpool() public override view returns(bool) { return _componentType == IComponent.ComponentType.Riskpool; }\\n\\n    function getRegistry() external override view returns(IRegistry) { return _registry; }\\n\\n    function proposalCallback() public override onlyComponent { _afterPropose(); }\\n    function approvalCallback() public override onlyComponent { _afterApprove(); }\\n    function declineCallback() public override onlyComponent { _afterDecline(); }\\n    function suspendCallback() public override onlyComponent { _afterSuspend(); }\\n    function resumeCallback() public override onlyComponent { _afterResume(); }\\n    function pauseCallback() public override onlyComponent { _afterPause(); }\\n    function unpauseCallback() public override onlyComponent { _afterUnpause(); }\\n    function archiveCallback() public override onlyComponent { _afterArchive(); }\\n    \\n    // these functions are intended to be overwritten to implement\\n    // component specific notification handling\\n    function _afterPropose() internal virtual {}\\n    function _afterApprove() internal virtual {}\\n    function _afterDecline() internal virtual {}\\n    function _afterSuspend() internal virtual {}\\n    function _afterResume() internal virtual {}\\n    function _afterPause() internal virtual {}\\n    function _afterUnpause() internal virtual {}\\n    function _afterArchive() internal virtual {}\\n\\n    function _getAccess() internal view returns (IAccess) {\\n        return IAccess(_getContractAddress(\\\"Access\\\"));        \\n    }\\n\\n    function _getInstanceService() internal view returns (IInstanceService) {\\n        return IInstanceService(_getContractAddress(\\\"InstanceService\\\"));        \\n    }\\n\\n    function _getComponentOwnerService() internal view returns (IComponentOwnerService) {\\n        return IComponentOwnerService(_getContractAddress(\\\"ComponentOwnerService\\\"));        \\n    }\\n\\n    function _getContractAddress(bytes32 contractName) internal view returns (address) { \\n        return _registry.getContract(contractName);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"IAccess.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\n\\ninterface IAccess {\\n    function getDefaultAdminRole() external view returns(bytes32 role);\\n    function getProductOwnerRole() external view returns(bytes32 role);\\n    function getOracleProviderRole() external view returns(bytes32 role);\\n    function getRiskpoolKeeperRole() external view returns(bytes32 role);\\n    function hasRole(bytes32 role, address principal) external view returns(bool);\\n\\n    function grantRole(bytes32 role, address principal) external;\\n    function revokeRole(bytes32 role, address principal) external;\\n    function renounceRole(bytes32 role, address principal) external;\\n    \\n    function addRole(bytes32 role) external;\\n    function invalidateRole(bytes32 role) external;\\n}\\n\"\r\n    },\r\n    \"IComponentEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\n\\nimport \\\"IComponent.sol\\\";\\n\\ninterface IComponentEvents {\\n\\n    event LogComponentProposed (\\n        bytes32 componentName,\\n        IComponent.ComponentType componentType,\\n        address componentAddress,\\n        uint256 id);\\n    \\n    event LogComponentApproved (uint256 id);\\n    event LogComponentDeclined (uint256 id);\\n\\n    event LogComponentSuspended (uint256 id);\\n    event LogComponentResumed (uint256 id);\\n\\n    event LogComponentPaused (uint256 id);\\n    event LogComponentUnpaused (uint256 id);\\n\\n    event LogComponentArchived (uint256 id);\\n\\n    event LogComponentStateChanged (\\n        uint256 id, \\n        IComponent.ComponentState stateOld, \\n        IComponent.ComponentState stateNew);\\n}\\n\"\r\n    },\r\n    \"IComponentOwnerService.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\n\\nimport \\\"IComponent.sol\\\";\\n\\ninterface IComponentOwnerService {\\n\\n    function propose(IComponent component) external;\\n\\n    function stake(uint256 id) external;\\n    function withdraw(uint256 id) external;\\n\\n    function pause(uint256 id) external; \\n    function unpause(uint256 id) external;\\n\\n    function archive(uint256 id) external;\\n}\"\r\n    },\r\n    \"IInstanceService.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\n\\nimport \\\"IComponent.sol\\\";\\nimport \\\"IBundle.sol\\\";\\nimport \\\"IPolicy.sol\\\";\\nimport \\\"IPool.sol\\\";\\nimport \\\"IBundleToken.sol\\\";\\nimport \\\"IComponentOwnerService.sol\\\";\\nimport \\\"IInstanceOperatorService.sol\\\";\\nimport \\\"IOracleService.sol\\\";\\nimport \\\"IProductService.sol\\\";\\nimport \\\"IRiskpoolService.sol\\\";\\n\\nimport \\\"IERC20.sol\\\";\\nimport \\\"IERC721.sol\\\";\\n\\ninterface IInstanceService {\\n\\n    // instance\\n    function getChainId() external view returns(uint256 chainId);\\n    function getChainName() external view returns(string memory chainName);\\n    function getInstanceId() external view returns(bytes32 instanceId);\\n    function getInstanceOperator() external view returns(address instanceOperator);\\n\\n    // registry\\n    function getComponentOwnerService() external view returns(IComponentOwnerService service);\\n    function getInstanceOperatorService() external view returns(IInstanceOperatorService service);\\n    function getOracleService() external view returns(IOracleService service);\\n    function getProductService() external view returns(IProductService service);\\n    function getRiskpoolService() external view returns(IRiskpoolService service);\\n    function contracts() external view returns (uint256 numberOfContracts);\\n    function contractName(uint256 idx) external view returns (bytes32 name);\\n\\n    // access\\n    function getDefaultAdminRole() external view returns(bytes32 role);\\n    function getProductOwnerRole() external view returns(bytes32 role);\\n    function getOracleProviderRole() external view returns(bytes32 role);\\n    function getRiskpoolKeeperRole() external view returns(bytes32 role);\\n    function hasRole(bytes32 role, address principal) external view returns (bool roleIsAssigned);    \\n\\n    // component\\n    function products() external view returns(uint256 numberOfProducts);\\n    function oracles() external view returns(uint256 numberOfOracles);\\n    function riskpools() external view returns(uint256 numberOfRiskpools);\\n\\n    function getComponentId(address componentAddress) external view returns(uint256 componentId);\\n    function getComponent(uint256 componentId) external view returns(IComponent component);\\n    function getComponentType(uint256 componentId) external view returns(IComponent.ComponentType componentType);\\n    function getComponentState(uint256 componentId) external view returns(IComponent.ComponentState componentState);\\n\\n    // service staking\\n    function getStakingRequirements(uint256 componentId) external view returns(bytes memory data);\\n    function getStakedAssets(uint256 componentId) external view returns(bytes memory data);\\n\\n    // riskpool\\n    function getRiskpool(uint256 riskpoolId) external view returns(IPool.Pool memory riskPool);\\n    function getFullCollateralizationLevel() external view returns (uint256);\\n    function getCapital(uint256 riskpoolId) external view returns(uint256 capitalAmount);\\n    function getTotalValueLocked(uint256 riskpoolId) external view returns(uint256 totalValueLockedAmount);\\n    function getCapacity(uint256 riskpoolId) external view returns(uint256 capacityAmount);\\n    function getBalance(uint256 riskpoolId) external view returns(uint256 balanceAmount);\\n\\n    function activeBundles(uint256 riskpoolId) external view returns(uint256 numberOfActiveBundles);\\n    function getActiveBundleId(uint256 riskpoolId, uint256 bundleIdx) external view returns(uint256 bundleId);\\n    function getMaximumNumberOfActiveBundles(uint256 riskpoolId) external view returns(uint256 maximumNumberOfActiveBundles);\\n\\n    // bundles\\n    function getBundleToken() external view returns(IBundleToken token);\\n    function bundles() external view returns(uint256 numberOfBundles);\\n    function getBundle(uint256 bundleId) external view returns(IBundle.Bundle memory bundle);\\n    function unburntBundles(uint256 riskpoolId) external view returns(uint256 numberOfUnburntBundles);\\n\\n    // policy\\n    function processIds() external view returns(uint256 numberOfProcessIds);\\n    function getMetadata(bytes32 processId) external view returns(IPolicy.Metadata memory metadata);\\n    function getApplication(bytes32 processId) external view returns(IPolicy.Application memory application);\\n    function getPolicy(bytes32 processId) external view returns(IPolicy.Policy memory policy);\\n    function claims(bytes32 processId) external view returns(uint256 numberOfClaims);\\n    function payouts(bytes32 processId) external view returns(uint256 numberOfPayouts);\\n\\n    function getClaim(bytes32 processId, uint256 claimId) external view returns (IPolicy.Claim memory claim);\\n    function getPayout(bytes32 processId, uint256 payoutId) external view returns (IPolicy.Payout memory payout);\\n\\n    // treasury\\n    function getTreasuryAddress() external view returns(address treasuryAddress);\\n \\n    function getInstanceWallet() external view returns(address walletAddress);\\n    function getRiskpoolWallet(uint256 riskpoolId) external view returns(address walletAddress);\\n \\n    function getComponentToken(uint256 componentId) external view returns(IERC20 token);\\n    function getFeeFractionFullUnit() external view returns(uint256 fullUnit);\\n\\n}\\n\"\r\n    },\r\n    \"IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\n\\ninterface IPool {\\n\\n    event LogRiskpoolRegistered(\\n        uint256 riskpoolId, \\n        address wallet,\\n        address erc20Token, \\n        uint256 collateralizationLevel, \\n        uint256 sumOfSumInsuredCap\\n    );\\n    \\n    event LogRiskpoolRequiredCollateral(bytes32 processId, uint256 sumInsured, uint256 collateral);\\n    event LogRiskpoolCollateralizationFailed(uint256 riskpoolId, bytes32 processId, uint256 amount);\\n    event LogRiskpoolCollateralizationSucceeded(uint256 riskpoolId, bytes32 processId, uint256 amount);\\n    event LogRiskpoolCollateralReleased(uint256 riskpoolId, bytes32 processId, uint256 amount);\\n\\n    struct Pool {\\n        uint256 id; // matches component id of riskpool\\n        address wallet; // riskpool wallet\\n        address erc20Token; // the value token of the riskpool\\n        uint256 collateralizationLevel; // required collateralization level to cover new policies \\n        uint256 sumOfSumInsuredCap; // max sum of sum insured the pool is allowed to secure\\n        uint256 sumOfSumInsuredAtRisk; // current sum of sum insured at risk in this pool\\n        uint256 capital; // net investment capital amount (<= balance)\\n        uint256 lockedCapital; // capital amount linked to collateralizaion of non-closed policies (<= capital)\\n        uint256 balance; // total amount of funds: net investment capital + net premiums - payouts\\n        uint256 createdAt;\\n        uint256 updatedAt;\\n    }\\n\\n    function registerRiskpool(\\n        uint256 riskpoolId, \\n        address wallet,\\n        address erc20Token,\\n        uint256 collateralizationLevel, \\n        uint256 sumOfSumInsuredCap\\n    ) external;\\n\\n    function setRiskpoolForProduct(uint256 productId, uint256 riskpoolId) external;\\n\\n    function underwrite(bytes32 processId) external returns(bool success);\\n    function processPremium(bytes32 processId, uint256 amount) external;\\n    function processPayout(bytes32 processId, uint256 amount) external;\\n    function release(bytes32 processId) external; \\n}\\n\"\r\n    },\r\n    \"IBundleToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\n\\nimport \\\"IERC721.sol\\\";\\n\\ninterface IBundleToken is\\n    IERC721\\n{\\n    event LogBundleTokenMinted(uint256 bundleId, uint256 tokenId, address tokenOwner);\\n    event LogBundleTokenBurned(uint256 bundleId, uint256 tokenId);   \\n\\n    function burned(uint tokenId) external view returns(bool isBurned);\\n    function exists(uint256 tokenId) external view returns(bool doesExist);\\n    function getBundleId(uint256 tokenId) external view returns(uint256 bundleId);\\n    function totalSupply() external view returns(uint256 tokenCount);\\n}\\n\"\r\n    },\r\n    \"IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"IInstanceOperatorService.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\n\\nimport \\\"ITreasury.sol\\\";\\n\\ninterface IInstanceOperatorService {\\n\\n    // registry\\n    function prepareRelease(bytes32 newRelease) external;\\n    function register(bytes32 contractName, address contractAddress) external;\\n    function deregister(bytes32 contractName) external;\\n    function registerInRelease(bytes32 release, bytes32 contractName, address contractAddress) external;\\n    function deregisterInRelease(bytes32 release, bytes32 contractName) external;\\n\\n    // access\\n    function createRole(bytes32 role) external;\\n    function invalidateRole(bytes32 role) external;\\n    function grantRole(bytes32 role, address principal) external;\\n    function revokeRole(bytes32 role, address principal) external;\\n\\n    // component\\n    function approve(uint256 id) external;\\n    function decline(uint256 id) external;\\n    function suspend(uint256 id) external;\\n    function resume(uint256 id) external;\\n    function archive(uint256 id) external;\\n    \\n    // service staking\\n    function setDefaultStaking(uint16 componentType, bytes calldata data) external;\\n    function adjustStakingRequirements(uint256 id, bytes calldata data) external;\\n\\n    // treasury\\n    function suspendTreasury() external;\\n    function resumeTreasury() external;\\n    \\n    function setInstanceWallet(address walletAddress) external;\\n    function setRiskpoolWallet(uint256 riskpoolId, address walletAddress) external;  \\n    function setProductToken(uint256 productId, address erc20Address) external; \\n\\n    function setPremiumFees(ITreasury.FeeSpecification calldata feeSpec) external;\\n    function setCapitalFees(ITreasury.FeeSpecification calldata feeSpec) external;\\n    \\n    function createFeeSpecification(\\n        uint256 componentId,\\n        uint256 fixedFee,\\n        uint256 fractionalFee,\\n        bytes calldata feeCalculationData\\n    ) external view returns(ITreasury.FeeSpecification memory);\\n\\n\\n}\\n\"\r\n    },\r\n    \"ITreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\nimport \\\"IERC20.sol\\\";\\n\\ninterface ITreasury {\\n\\n    event LogTreasurySuspended();\\n    event LogTreasuryResumed();\\n\\n    event LogTreasuryProductTokenSet(uint256 productId, uint256 riskpoolId, address erc20Address);\\n    event LogTreasuryInstanceWalletSet(address walletAddress);\\n    event LogTreasuryRiskpoolWalletSet(uint256 riskpoolId, address walletAddress);\\n\\n    event LogTreasuryPremiumFeesSet(uint256 productId, uint256 fixedFee, uint256 fractionalFee);\\n    event LogTreasuryCapitalFeesSet(uint256 riskpoolId, uint256 fixedFee, uint256 fractionalFee);\\n\\n    event LogTreasuryPremiumTransferred(address from, address riskpoolWalletAddress, uint256 amount);\\n    event LogTreasuryPayoutTransferred(address riskpoolWalletAddress, address to, uint256 amount);\\n    event LogTreasuryCapitalTransferred(address from, address riskpoolWalletAddress, uint256 amount);\\n    event LogTreasuryFeesTransferred(address from, address instanceWalletAddress, uint256 amount);\\n    event LogTreasuryWithdrawalTransferred(address riskpoolWalletAddress, address to, uint256 amount);\\n\\n    event LogTreasuryPremiumProcessed(bytes32 processId, uint256 amount);\\n    event LogTreasuryPayoutProcessed(uint256 riskpoolId, address to, uint256 amount);\\n    event LogTreasuryCapitalProcessed(uint256 riskpoolId, uint256 bundleId, uint256 amount);\\n    event LogTreasuryWithdrawalProcessed(uint256 riskpoolId, uint256 bundleId, uint256 amount);\\n\\n    struct FeeSpecification {\\n        uint256 componentId;\\n        uint256 fixedFee;\\n        uint256 fractionalFee;\\n        bytes feeCalculationData;\\n        uint256 createdAt;\\n        uint256 updatedAt;\\n    }\\n\\n    function setProductToken(uint256 productId, address erc20Address) external;\\n\\n    function setInstanceWallet(address instanceWalletAddress) external;\\n    function setRiskpoolWallet(uint256 riskpoolId, address riskpoolWalletAddress) external;\\n\\n    function createFeeSpecification(\\n        uint256 componentId,\\n        uint256 fixedFee,\\n        uint256 fractionalFee,\\n        bytes calldata feeCalculationData\\n    )\\n        external view returns(FeeSpecification memory feeSpec);\\n    \\n    function setPremiumFees(FeeSpecification calldata feeSpec) external;\\n    function setCapitalFees(FeeSpecification calldata feeSpec) external;\\n    \\n    function processPremium(bytes32 processId) external \\n        returns(\\n            bool success,\\n            uint256 feeAmount,\\n            uint256 netPremiumAmount\\n        );\\n    \\n    function processPremium(bytes32 processId, uint256 amount) external \\n        returns(\\n            bool success,\\n            uint256 feeAmount,\\n            uint256 netPremiumAmount\\n        );\\n    \\n    function processPayout(bytes32 processId, uint256 payoutId) external \\n        returns(\\n            uint256 feeAmount,\\n            uint256 netPayoutAmount\\n        );\\n    \\n    function processCapital(uint256 bundleId, uint256 capitalAmount) external \\n        returns(\\n            uint256 feeAmount,\\n            uint256 netCapitalAmount\\n        );\\n\\n    function processWithdrawal(uint256 bundleId, uint256 amount) external\\n        returns(\\n            uint256 feeAmount,\\n            uint256 netAmount\\n        );\\n\\n    function getComponentToken(uint256 componentId) external view returns(IERC20 token);\\n    function getFeeSpecification(uint256 componentId) external view returns(FeeSpecification memory feeSpecification);\\n\\n    function getFractionFullUnit() external view returns(uint256);\\n    function getInstanceWallet() external view returns(address instanceWalletAddress);\\n    function getRiskpoolWallet(uint256 riskpoolId) external view returns(address riskpoolWalletAddress);\\n\\n}\\n\"\r\n    },\r\n    \"IOracleService.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\n\\ninterface IOracleService {\\n\\n    function respond(uint256 requestId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"IProductService.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\n\\ninterface IProductService {\\n\\n    function newApplication(\\n        address owner,\\n        uint256 premiumAmount,\\n        uint256 sumInsuredAmount,\\n        bytes calldata metaData, \\n        bytes calldata applicationData \\n    ) external returns(bytes32 processId);\\n\\n    function collectPremium(bytes32 processId, uint256 amount) external\\n        returns(\\n            bool success,\\n            uint256 feeAmount,\\n            uint256 netPremiumAmount\\n        );\\n    \\n    function adjustPremiumSumInsured(\\n        bytes32 processId, \\n        uint256 expectedPremiumAmount,\\n        uint256 sumInsuredAmount\\n    ) external;\\n\\n    function revoke(bytes32 processId) external;\\n    function underwrite(bytes32 processId) external returns(bool success);\\n    function decline(bytes32 processId) external;\\n    function expire(bytes32 processId) external;\\n    function close(bytes32 processId) external;\\n\\n    function newClaim(\\n        bytes32 processId, \\n        uint256 claimAmount,\\n        bytes calldata data\\n    ) external returns(uint256 claimId);\\n\\n    function confirmClaim(\\n        bytes32 processId, \\n        uint256 claimId, \\n        uint256 confirmedAmount\\n    ) external;\\n\\n    function declineClaim(bytes32 processId, uint256 claimId) external;\\n    function closeClaim(bytes32 processId, uint256 claimId) external;\\n\\n    function newPayout(\\n        bytes32 processId, \\n        uint256 claimId, \\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns(uint256 payoutId);\\n\\n    function processPayout(bytes32 processId, uint256 payoutId) external\\n        returns(\\n            uint256 feeAmount,\\n            uint256 netPayoutAmount\\n        );\\n\\n    function request(\\n        bytes32 processId,\\n        bytes calldata data,\\n        string calldata callbackMethodName,\\n        address callbackContractAddress,\\n        uint256 responsibleOracleId\\n    ) external returns(uint256 requestId);\\n\\n    function cancelRequest(uint256 requestId) external;\\n}\\n\"\r\n    },\r\n    \"IRiskpoolService.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\n\\ninterface IRiskpoolService {\\n\\n    function registerRiskpool(\\n        address wallet,\\n        address erc20Token,\\n        uint256 collateralization, \\n        uint256 sumOfSumInsuredCap\\n    ) external;\\n\\n    function createBundle(address owner_, bytes calldata filter_, uint256 amount_) external returns(uint256 bundleId);\\n    function fundBundle(uint256 bundleId, uint256 amount) external returns(uint256 netAmount);\\n    function defundBundle(uint256 bundleId, uint256 amount) external returns(uint256 netAmount);\\n\\n    function lockBundle(uint256 bundleId) external;\\n    function unlockBundle(uint256 bundleId) external;\\n    function closeBundle(uint256 bundleId) external;\\n    function burnBundle(uint256 bundleId) external;\\n\\n    function collateralizePolicy(uint256 bundleId, bytes32 processId, uint256 collateralAmount) external;\\n    function processPremium(uint256 bundleId, bytes32 processId, uint256 amount) external;\\n    function processPayout(uint256 bundleId, bytes32 processId, uint256 amount) external;\\n    function releasePolicy(uint256 bundleId, bytes32 processId) external returns(uint256 collateralAmount);\\n\\n    function setMaximumNumberOfActiveBundles(uint256 riskpoolId, uint256 maxNumberOfActiveBundles) external;\\n}\\n\\n\"\r\n    },\r\n    \"Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"BasicRiskpool2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\n\\nimport \\\"Riskpool2.sol\\\";\\nimport \\\"IBundle.sol\\\";\\nimport \\\"IPolicy.sol\\\";\\n\\n// basic riskpool always collateralizes one application using exactly one bundle\\nabstract contract BasicRiskpool2 is Riskpool2 {\\n\\n    event LogBasicRiskpoolCapitalCheck(uint256 activeBundles, uint256 policies);\\n    event LogBasicRiskpoolCapitalization(uint256 activeBundles, uint256 capital, uint256 lockedCapital, uint256 collateralAmount, bool capacityIsAvailable);\\n    event LogBasicRiskpoolCandidateBundleAmountCheck(uint256 index, uint256 bundleId, uint256 maxAmount, uint256 collateralAmount);\\n\\n    // remember bundleId for each processId\\n    // approach only works for basic risk pool where a\\n    // policy is collateralized by exactly one bundle\\n    mapping(bytes32 /* processId */ => uint256 /** bundleId */) internal _collateralizedBy;\\n    uint32 private _policiesCounter = 0;\\n\\n    // will hold a sorted active bundle id array\\n    uint256[] private _activeBundleIds;\\n\\n    // informational counter of active policies per bundle\\n    mapping(uint256 /* bundleId */ => uint256 /* activePolicyCount */) private _activePoliciesForBundle;\\n\\n    constructor(\\n        bytes32 name,\\n        uint256 collateralization,\\n        uint256 sumOfSumInsuredCap,\\n        address erc20Token,\\n        address wallet,\\n        address registry\\n    )\\n        Riskpool2(name, collateralization, sumOfSumInsuredCap, erc20Token, wallet, registry)\\n    { }\\n\\n    \\n\\n    // needs to remember which bundles helped to cover ther risk\\n    // simple (retail) approach: single policy covered by single bundle\\n    // first bundle with a match and sufficient capacity wins\\n    // Component <- Riskpool <- BasicRiskpool <- TestRiskpool\\n    // complex (wholesale) approach: single policy covered by many bundles\\n    // Component <- Riskpool <- AdvancedRiskpool <- TestRiskpool\\n    function _lockCollateral(bytes32 processId, uint256 collateralAmount) \\n        internal override\\n        returns(bool success) \\n    {\\n        require(_activeBundleIds.length > 0, \\\"ERROR:BRP-001:NO_ACTIVE_BUNDLES\\\");\\n\\n        uint256 capital = getCapital();\\n        uint256 lockedCapital = getTotalValueLocked();\\n        bool capacityIsAvailable = capital > lockedCapital + collateralAmount;\\n\\n        emit LogBasicRiskpoolCapitalization(\\n            _activeBundleIds.length,\\n            capital,\\n            lockedCapital, \\n            collateralAmount,\\n            capacityIsAvailable);\\n\\n        // ensure there is a chance to find the collateral\\n        if(!capacityIsAvailable) {\\n            return false;\\n        }\\n\\n        // set default outcome\\n        success = false;\\n\\n        IPolicy.Application memory application = _instanceService.getApplication(processId);\\n        \\n        // basic riskpool implementation: policy coverage by single bundle only/\\n        // active bundle arrays with the most attractive bundle at the first place\\n        for (uint256 i = 0; i < _activeBundleIds.length && !success; i++) {\\n            uint256 bundleId = _activeBundleIds[i];\\n            // uint256 bundleId = getActiveBundleId(bundleIdx);\\n            IBundle.Bundle memory bundle = _instanceService.getBundle(bundleId);\\n            bool isMatching = bundleMatchesApplication2(bundle, application);\\n            emit LogRiskpoolBundleMatchesPolicy(bundleId, isMatching);\\n\\n            if (isMatching) {\\n                uint256 maxAmount = bundle.capital - bundle.lockedCapital;\\n                emit LogBasicRiskpoolCandidateBundleAmountCheck(i, bundleId, maxAmount, collateralAmount);\\n\\n                if (maxAmount >= collateralAmount) {\\n                    _riskpoolService.collateralizePolicy(bundleId, processId, collateralAmount);\\n                    _collateralizedBy[processId] = bundleId;\\n                    success = true;\\n                    _policiesCounter++;\\n\\n                    // update active policies counter\\n                    _activePoliciesForBundle[bundleId]++;\\n                }\\n            }\\n        }\\n    }\\n\\n    // hack\\n    function bundleMatchesApplication2(\\n        IBundle.Bundle memory bundle, \\n        IPolicy.Application memory application\\n    ) \\n        public virtual returns(bool isMatching);\\n\\n    // manage sorted list of active bundle ids\\n    function _afterCreateBundle(uint256 bundleId, bytes memory filter, uint256 initialAmount) internal override virtual {\\n        _addBundleToActiveList(bundleId);\\n    }\\n\\n    function _afterLockBundle(uint256 bundleId) internal override virtual {\\n        _removeBundleFromActiveList(bundleId);\\n    }\\n    function _afterUnlockBundle(uint256 bundleId) internal override virtual {\\n        _addBundleToActiveList(bundleId);\\n    }\\n    function _afterCloseBundle(uint256 bundleId) internal override virtual {\\n        _removeBundleFromActiveList(bundleId);\\n    }\\n\\n    function _addBundleToActiveList(uint256 bundleId) internal {\\n        bool found = false;\\n        bool inserted = false;\\n\\n        for (uint256 i = 0; !inserted && !found && i < _activeBundleIds.length; i++) {\\n            if (bundleId == _activeBundleIds[i]) {\\n                found = true;\\n            } \\n            else if (isHigherPriorityBundle(bundleId, _activeBundleIds[i])) {\\n                inserted = true;\\n                _activeBundleIds.push(10**6);\\n\\n                for (uint256 j = _activeBundleIds.length - 1; j > i; j--) {\\n                    _activeBundleIds[j] = _activeBundleIds[j-1];\\n                }\\n\\n                // does not work for inserting at end of list ...\\n                _activeBundleIds[i] = bundleId;\\n            }\\n        }\\n\\n        if (!found && !inserted) {\\n            _activeBundleIds.push(bundleId);\\n        }\\n    }\\n\\n    // default implementation adds new bundle at the end of the active list\\n    function isHigherPriorityBundle(uint256 firstBundleId, uint256 secondBundleId) \\n        public virtual \\n        view \\n        returns (bool firstBundleIsHigherPriority) \\n    {\\n        firstBundleIsHigherPriority = false;\\n    }\\n\\n\\n    function _removeBundleFromActiveList(uint256 bundleId) internal {\\n        bool inList = false;\\n        for (uint256 i = 0; !inList && i < _activeBundleIds.length; i++) {\\n            inList = (bundleId == _activeBundleIds[i]);\\n            if (inList) {\\n                for (; i < _activeBundleIds.length - 1; i++) {\\n                    _activeBundleIds[i] = _activeBundleIds[i+1];\\n                }\\n                _activeBundleIds.pop();\\n            }\\n        }\\n    }\\n\\n    function getActiveBundleIds() public view returns (uint256[] memory activeBundleIds) {\\n        return _activeBundleIds;\\n    }\\n\\n    function getActivePolicies(uint256 bundleId) public view returns (uint256 activePolicies) {\\n        return _activePoliciesForBundle[bundleId];\\n    }\\n\\n    function _processPayout(bytes32 processId, uint256 amount)\\n        internal override\\n    {\\n        uint256 bundleId = _collateralizedBy[processId];\\n        _riskpoolService.processPayout(bundleId, processId, amount);\\n    }\\n\\n    function _processPremium(bytes32 processId, uint256 amount)\\n        internal override\\n    {\\n        uint256 bundleId = _collateralizedBy[processId];\\n        _riskpoolService.processPremium(bundleId, processId, amount);\\n    }\\n\\n    function _releaseCollateral(bytes32 processId) \\n        internal override\\n        returns(uint256 collateralAmount) \\n    {        \\n        uint256 bundleId = _collateralizedBy[processId];\\n        collateralAmount = _riskpoolService.releasePolicy(bundleId, processId);\\n\\n        // update active policies counter\\n        _activePoliciesForBundle[bundleId]--;\\n    }\\n}\\n\"\r\n    },\r\n    \"Riskpool2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\n\\nimport \\\"IERC20Metadata.sol\\\";\\nimport \\\"IERC721.sol\\\";\\n\\nimport \\\"IRiskpool.sol\\\";\\nimport \\\"Component.sol\\\";\\n\\nimport \\\"IBundle.sol\\\";\\nimport \\\"IPolicy.sol\\\";\\nimport \\\"IInstanceService.sol\\\";\\nimport \\\"IRiskpoolService.sol\\\";\\n\\n\\nabstract contract Riskpool2 is \\n    IRiskpool, \\n    Component \\n{    \\n\\n    // TODO move to IRiskpool\\n    event LogMaximumNumberOfActiveBundlesSet(uint256 numberOfBundles);\\n    event LogRiskpoolBundleFunded(uint256 bundleId, uint256 amount);\\n    event LogRiskpoolBundleDefunded(uint256 bundleId, uint256 amount);\\n\\n    event LogRiskpoolBundleLocked(uint256 bundleId);\\n    event LogRiskpoolBundleUnlocked(uint256 bundleId);\\n    event LogRiskpoolBundleClosed(uint256 bundleId);\\n    event LogRiskpoolBundleBurned(uint256 bundleId);\\n\\n    // used for representation of collateralization\\n    // collateralization between 0 and 1 (1=100%) \\n    // value might be larger when overcollateralization\\n    uint256 public constant FULL_COLLATERALIZATION_LEVEL = 10**18;\\n    string public constant DEFAULT_FILTER_DATA_STRUCTURE = \\\"\\\";\\n\\n    IInstanceService internal _instanceService; \\n    IRiskpoolService internal _riskpoolService;\\n    IERC721 internal _bundleToken;\\n    \\n    // keep track of bundles associated with this riskpool\\n    uint256 [] internal _bundleIds;\\n\\n    address private _wallet;\\n    address private _erc20Token;\\n    uint256 private _collateralization;\\n    uint256 private _sumOfSumInsuredCap;\\n    uint256 private _maxNumberOfActiveBundles;\\n\\n    modifier onlyPool {\\n        require(\\n            _msgSender() == _getContractAddress(\\\"Pool\\\"),\\n            \\\"ERROR:RPL-001:ACCESS_DENIED\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyBundleOwner(uint256 bundleId) {\\n        IBundle.Bundle memory bundle = _instanceService.getBundle(bundleId);\\n        address bundleOwner = _bundleToken.ownerOf(bundle.tokenId);\\n\\n        require(\\n            _msgSender() == bundleOwner,\\n            \\\"ERROR:RPL-002:NOT_BUNDLE_OWNER\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(\\n        bytes32 name,\\n        uint256 collateralization,\\n        uint256 sumOfSumInsuredCap, // in full token units, eg 1 for 1 usdc\\n        address erc20Token,\\n        address wallet,\\n        address registry\\n    )\\n        Component(name, ComponentType.Riskpool, registry)\\n    { \\n        _collateralization = collateralization;\\n\\n        require(sumOfSumInsuredCap != 0, \\\"ERROR:RPL-003:SUM_OF_SUM_INSURED_CAP_ZERO\\\");\\n        _sumOfSumInsuredCap = sumOfSumInsuredCap;\\n\\n        require(erc20Token != address(0), \\\"ERROR:RPL-005:ERC20_ADDRESS_ZERO\\\");\\n        _erc20Token = erc20Token;\\n\\n        require(wallet != address(0), \\\"ERROR:RPL-006:WALLET_ADDRESS_ZERO\\\");\\n        _wallet = wallet;\\n\\n        _instanceService = IInstanceService(_getContractAddress(\\\"InstanceService\\\")); \\n        _riskpoolService = IRiskpoolService(_getContractAddress(\\\"RiskpoolService\\\"));\\n        _bundleToken = _instanceService.getBundleToken();\\n    }\\n\\n    function _afterPropose() internal override virtual {\\n        _riskpoolService.registerRiskpool(\\n            _wallet,\\n            _erc20Token, \\n            _collateralization,\\n            _sumOfSumInsuredCap\\n        );\\n    }\\n\\n    function createBundle(bytes memory filter, uint256 initialAmount) \\n        public virtual override\\n        returns(uint256 bundleId)\\n    {\\n        address bundleOwner = _msgSender();\\n        bundleId = _riskpoolService.createBundle(bundleOwner, filter, initialAmount);\\n        _bundleIds.push(bundleId);\\n\\n        // after action hook for child contracts\\n        _afterCreateBundle(bundleId, filter, initialAmount);\\n\\n        emit LogRiskpoolBundleCreated(bundleId, initialAmount);\\n    }\\n\\n    function fundBundle(uint256 bundleId, uint256 amount) \\n        external override\\n        onlyBundleOwner(bundleId)\\n        returns(uint256 netAmount)\\n    {\\n        netAmount = _riskpoolService.fundBundle(bundleId, amount);\\n\\n        // after action hook for child contracts\\n        _afterFundBundle(bundleId, amount);\\n\\n        emit LogRiskpoolBundleFunded(bundleId, amount);\\n    }\\n\\n    function defundBundle(uint256 bundleId, uint256 amount)\\n        external override\\n        onlyBundleOwner(bundleId)\\n        returns(uint256 netAmount)\\n    {\\n        netAmount = _riskpoolService.defundBundle(bundleId, amount);\\n\\n        // after action hook for child contracts\\n        _afterDefundBundle(bundleId, amount);\\n\\n        emit LogRiskpoolBundleDefunded(bundleId, amount);\\n    }\\n\\n    function lockBundle(uint256 bundleId)\\n        external override\\n        onlyBundleOwner(bundleId)\\n    {\\n        _riskpoolService.lockBundle(bundleId);\\n\\n        // after action hook for child contracts\\n        _afterLockBundle(bundleId);\\n\\n        emit LogRiskpoolBundleLocked(bundleId);\\n    }\\n\\n    function unlockBundle(uint256 bundleId)\\n        external override\\n        onlyBundleOwner(bundleId)\\n    {\\n        _riskpoolService.unlockBundle(bundleId);\\n\\n        // after action hook for child contracts\\n        _afterUnlockBundle(bundleId);\\n\\n        emit LogRiskpoolBundleUnlocked(bundleId);\\n    }\\n\\n    function closeBundle(uint256 bundleId)\\n        external override\\n        onlyBundleOwner(bundleId)\\n    {\\n        _riskpoolService.closeBundle(bundleId);\\n\\n        // after action hook for child contracts\\n        _afterCloseBundle(bundleId);\\n\\n        emit LogRiskpoolBundleClosed(bundleId);\\n    }\\n\\n    function burnBundle(uint256 bundleId)\\n        external override\\n        onlyBundleOwner(bundleId)\\n    {\\n        _riskpoolService.burnBundle(bundleId);\\n\\n        // after action hook for child contracts\\n        _afterBurnBundle(bundleId);\\n\\n        emit LogRiskpoolBundleBurned(bundleId);\\n    }\\n\\n    function collateralizePolicy(bytes32 processId, uint256 collateralAmount) \\n        external override\\n        onlyPool\\n        returns(bool success) \\n    {\\n        success = _lockCollateral(processId, collateralAmount);\\n\\n        emit LogRiskpoolCollateralLocked(processId, collateralAmount, success);\\n    }\\n\\n    function processPolicyPayout(bytes32 processId, uint256 amount)\\n        external override\\n        onlyPool\\n    {\\n        _processPayout(processId, amount);\\n        emit LogRiskpoolPayoutProcessed(processId, amount);\\n    }\\n\\n    function processPolicyPremium(bytes32 processId, uint256 amount)\\n        external override\\n        onlyPool\\n    {\\n        _processPremium(processId, amount);\\n        emit LogRiskpoolPremiumProcessed(processId, amount);\\n    }\\n\\n    function releasePolicy(bytes32 processId) \\n        external override\\n        onlyPool\\n    {\\n        uint256 collateralAmount = _releaseCollateral(processId);\\n        emit LogRiskpoolCollateralReleased(processId, collateralAmount);\\n    }\\n\\n    function setMaximumNumberOfActiveBundles(uint256 maximumNumberOfActiveBundles)\\n        public override\\n        onlyOwner\\n    {\\n        // TODO remove riskpoolId parameter in service method (and infer it from sender address)\\n        uint256 riskpoolId = getId();\\n        _riskpoolService.setMaximumNumberOfActiveBundles(riskpoolId, maximumNumberOfActiveBundles);\\n        // after action hook for child contracts\\n        _afterSetMaximumActiveBundles(maximumNumberOfActiveBundles);\\n\\n        emit LogMaximumNumberOfActiveBundlesSet(maximumNumberOfActiveBundles);\\n    }\\n\\n    function getMaximumNumberOfActiveBundles()\\n        public view override\\n        returns(uint256 maximumNumberOfActiveBundles)\\n    {\\n        uint256 riskpoolId = getId();\\n        return _instanceService.getMaximumNumberOfActiveBundles(riskpoolId);\\n    }\\n\\n    function getWallet() public view override returns(address) {\\n        return _wallet;\\n    }\\n\\n    function getErc20Token() public view override returns(address) {\\n        return _erc20Token;\\n    }\\n\\n    function getSumOfSumInsuredCap() public view override returns (uint256) {\\n        return _sumOfSumInsuredCap;\\n    }\\n\\n    function getFullCollateralizationLevel() public pure override returns (uint256) {\\n        return FULL_COLLATERALIZATION_LEVEL;\\n    }\\n\\n    function getCollateralizationLevel() public view override returns (uint256) {\\n        return _collateralization;\\n    }\\n\\n    function bundles() public override view returns(uint256) {\\n        return _bundleIds.length;\\n    }\\n\\n    function getBundleId(uint256 idx) external view returns(uint256 bundleId) {\\n        require(idx < _bundleIds.length, \\\"ERROR:RPL-007:BUNDLE_INDEX_TOO_LARGE\\\");\\n        return _bundleIds[idx];\\n    }\\n\\n    // empty implementation to satisfy IRiskpool\\n    function getBundle(uint256 idx) external override view returns(IBundle.Bundle memory) {}\\n\\n    function activeBundles() public override view returns(uint256) {\\n        uint256 riskpoolId = getId();\\n        return _instanceService.activeBundles(riskpoolId);\\n    }\\n\\n    function getActiveBundleId(uint256 idx) public override view returns(uint256 bundleId) {\\n        uint256 riskpoolId = getId();\\n        require(idx < _instanceService.activeBundles(riskpoolId), \\\"ERROR:RPL-008:ACTIVE_BUNDLE_INDEX_TOO_LARGE\\\");\\n\\n        return _instanceService.getActiveBundleId(riskpoolId, idx);\\n    }\\n\\n    function getFilterDataStructure() external override virtual pure returns(string memory) {\\n        return DEFAULT_FILTER_DATA_STRUCTURE;\\n    }\\n\\n    function getCapital() public override view returns(uint256) {\\n        uint256 riskpoolId = getId();\\n        return _instanceService.getCapital(riskpoolId);\\n    }\\n\\n    function getTotalValueLocked() public override view returns(uint256) {\\n        uint256 riskpoolId = getId();\\n        return _instanceService.getTotalValueLocked(riskpoolId);\\n    }\\n\\n    function getCapacity() public override view returns(uint256) {\\n        uint256 riskpoolId = getId();\\n        return _instanceService.getCapacity(riskpoolId);\\n    }\\n\\n    function getBalance() public override view returns(uint256) {\\n        uint256 riskpoolId = getId();\\n        return _instanceService.getBalance(riskpoolId);\\n    }\\n\\n    // change: no longer view to allow for log entries in derived contracts\\n    function bundleMatchesApplication(\\n        IBundle.Bundle memory bundle, \\n        IPolicy.Application memory application\\n    ) public override virtual view returns(bool isMatching);\\n\\n    function _afterArchive() internal view override { \\n        uint256 riskpoolId = getId();\\n        require(\\n            _instanceService.unburntBundles(riskpoolId) == 0, \\n            \\\"ERROR:RPL-010:RISKPOOL_HAS_UNBURNT_BUNDLES\\\"\\n            );\\n    }\\n\\n    // after action hooks for child contracts\\n    function _afterSetMaximumActiveBundles(uint256 numberOfBundles) internal virtual {}\\n    function _afterCreateBundle(uint256 bundleId, bytes memory filter, uint256 initialAmount) internal virtual {}\\n    function _afterFundBundle(uint256 bundleId, uint256 amount) internal virtual {}\\n    function _afterDefundBundle(uint256 bundleId, uint256 amount) internal virtual {}\\n\\n    function _afterLockBundle(uint256 bundleId) internal virtual {}\\n    function _afterUnlockBundle(uint256 bundleId) internal virtual {}\\n    function _afterCloseBundle(uint256 bundleId) internal virtual {}\\n    function _afterBurnBundle(uint256 bundleId) internal virtual {}\\n\\n    // abstract functions to implement by concrete child contracts\\n    function _lockCollateral(bytes32 processId, uint256 collateralAmount) internal virtual returns(bool success);\\n    function _processPremium(bytes32 processId, uint256 amount) internal virtual;\\n    function _processPayout(bytes32 processId, uint256 amount) internal virtual;\\n    function _releaseCollateral(bytes32 processId) internal virtual returns(uint256 collateralAmount);\\n}\\n\"\r\n    },\r\n    \"IChainRegistryFacade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\n\\n/**\\n * @dev this facade is intended for user contracts with limited \\n * interactions with the actual contract and that need to work \\n * with older solidity versions that do not support user defined \\n * types.\\n * \\n * usage: \\n * (1) copy this interface into your repository\\n * (2) adapt the pragma to your needsd\\n * (3) use it in your contracts, ie. cast actual contract \\n * address to this interface, then  usd the resulting facade \\n * to interact with the actual contract\\n */\\n\\nimport {IChainNftFacade} from \\\"IChainNftFacade.sol\\\";\\n\\ninterface IChainRegistryFacade {\\n\\n    function registerBundle(\\n        bytes32 instanceId,\\n        uint256 riskpoolId,\\n        uint256 bundleId,\\n        string memory displayName,\\n        uint256 expiryAt\\n    )\\n        external\\n        returns(uint96 nftId);\\n\\n    function extendBundleLifetime(uint96 id, uint256 lifetimeExtension) external;\\n\\n    function owner() external view returns(address);\\n    function getNft() external view returns(IChainNftFacade);\\n    function toChain(uint256 chainId) external pure returns(bytes5 chain);\\n\\n    function objects(bytes5 chain, uint8 objectType) external view returns(uint256 numberOfObjects);\\n    function getNftId(bytes5 chain, uint8 objectType, uint256 idx) external view returns(uint96 nftId);\\n    function exists(uint96 id) external view returns(bool);\\n    function ownerOf(uint96 id) external view returns(address nftOwner);\\n\\n    function getInstanceNftId(bytes32 instanceId) external view returns(uint96 nftId);\\n    function getComponentNftId(bytes32 instanceId, uint256 componentId) external view returns(uint96 nftId);\\n    function getBundleNftId(bytes32 instanceId, uint256 bundleId) external view returns(uint96 nftId);\\n\\n    function version() external pure returns(uint48);\\n    function versionParts()\\n        external\\n        view\\n        returns(\\n            uint16 major,\\n            uint16 minor,\\n            uint16 patch\\n        );\\n\\n\\n    function decodeComponentData(uint96 id)\\n        external\\n        view\\n        returns(\\n            bytes32 instanceId,\\n            uint256 componentId,\\n            address token);\\n\\n\\n    function decodeBundleData(uint96 id)\\n        external\\n        view\\n        returns(\\n            bytes32 instanceId,\\n            uint256 riskpoolId,\\n            uint256 bundleId,\\n            address token,\\n            string memory displayName,\\n            uint256 expiryAt);\\n\\n\\n    function decodeStakeData(uint96 id)\\n        external\\n        view\\n        returns(\\n            uint96 target,\\n            uint8 targetType);\\n\\n}\"\r\n    },\r\n    \"IChainNftFacade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\n\\n/**\\n * @dev this facade is intended for user contracts with limited \\n * interactions with the actual contract and that need to work \\n * with older solidity versions that do not support user defined \\n * types.\\n * \\n * usage: \\n * (1) copy this interface into your repository\\n * (2) adapt the pragma to your needsd\\n * (3) use it in your contracts, ie. cast actual contract \\n * address to this interface, then  usd the resulting facade \\n * to interact with the actual contract\\n */\\n\\nimport {IChainRegistryFacade} from \\\"IChainRegistryFacade.sol\\\";\\n\\ninterface IChainNftFacade {\\n\\n    function mint(address to, string memory uri) external returns(uint256 tokenId);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function getRegistry() external view returns (IChainRegistryFacade);\\n\\n    function exists(uint256 tokenId) external view returns(bool);\\n    function totalMinted() external view returns(uint256);\\n}\"\r\n    },\r\n    \"IStakingFacade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.2;\\n\\n/**\\n * @dev this facade is intended for user contracts with limited \\n * interactions with the actual contract and that need to work \\n * with older solidity versions that do not support user defined \\n * types.\\n * \\n * usage: \\n * (1) copy this interface into your repository\\n * (2) adapt the pragma to your needsd\\n * (3) use it in your contracts, ie. cast actual contract \\n * address to this interface, then  usd the resulting facade \\n * to interact with the actual contract\\n */\\n\\nimport {IERC20Metadata} from \\\"IERC20Metadata.sol\\\";\\n\\nimport {IChainRegistryFacade} from \\\"IChainRegistryFacade.sol\\\";\\n\\ninterface IStakingFacade {\\n\\n    function owner() external view returns(address);\\n    function getRegistry() external view returns(IChainRegistryFacade);\\n\\n    function getStakingWallet() external view returns(address stakingWallet);\\n    function getDip() external view returns(IERC20Metadata);\\n\\n    function maxRewardRate() external view returns(uint256 rate);\\n    function rewardRate() external view returns(uint256 rate);\\n    function rewardBalance() external view returns(uint256 dipAmount);\\n    function rewardReserves() external view returns(uint256 dipAmount);\\n\\n    function stakeBalance() external view returns(uint256 dipAmount);\\n    function stakingRate(bytes5 chain, address token) external view returns(uint256 rate);\\n\\n    function capitalSupport(uint96 targetNftId) external view returns(uint256 capitalAmount);\\n    function implementsIStaking() external pure returns(bool);\\n\\n    function toChain(uint256 chainId) external pure returns(bytes5);\\n\\n    function toRate(uint256 value, int8 exp) external pure returns(uint256 rate);\\n    function rateDecimals() external pure returns(uint256 decimals);\\n\\n    function version() external pure returns(uint48);\\n    function versionParts()\\n        external\\n        view\\n        returns(\\n            uint16 major,\\n            uint16 minor,\\n            uint16 patch\\n        );\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"DepegRiskpool.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"sumOfSumInsuredCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sumInsuredPercentage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"erc20Token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowAccount\",\"type\":\"bool\"}],\"name\":\"LogAllowAccountSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowAllAccounts\",\"type\":\"bool\"}],\"name\":\"LogAllowAllAccountsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"LogBasicRiskpoolCandidateBundleAmountCheck\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"activeBundles\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"policies\",\"type\":\"uint256\"}],\"name\":\"LogBasicRiskpoolCapitalCheck\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"activeBundles\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"capital\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedCapital\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"capacityIsAvailable\",\"type\":\"bool\"}],\"name\":\"LogBasicRiskpoolCapitalization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bundleCapitalNew\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bundleCapitalOld\",\"type\":\"uint256\"}],\"name\":\"LogBundleCapitalSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lifetime\",\"type\":\"uint256\"}],\"name\":\"LogBundleExpired\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lifetime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lifetimeExtended\",\"type\":\"uint256\"}],\"name\":\"LogBundleExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"sumInsuredOk\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"durationOk\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"premiumOk\",\"type\":\"bool\"}],\"name\":\"LogBundleMatchesApplication\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bundleIdRequested\",\"type\":\"uint256\"}],\"name\":\"LogBundleMismatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogComponentApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogComponentArchived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"componentName\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"enum IComponent.ComponentType\",\"name\":\"componentType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"componentAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"registryAddress\",\"type\":\"address\"}],\"name\":\"LogComponentCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogComponentDeclined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogComponentPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"componentName\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"enum IComponent.ComponentType\",\"name\":\"componentType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"componentAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogComponentProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogComponentResumed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum IComponent.ComponentState\",\"name\":\"stateOld\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"enum IComponent.ComponentState\",\"name\":\"stateNew\",\"type\":\"uint8\"}],\"name\":\"LogComponentStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogComponentSuspended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogComponentUnpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numberOfBundles\",\"type\":\"uint256\"}],\"name\":\"LogMaximumNumberOfActiveBundlesSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogRiskpoolApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"}],\"name\":\"LogRiskpoolBundleBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"}],\"name\":\"LogRiskpoolBundleClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogRiskpoolBundleCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogRiskpoolBundleDefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogRiskpoolBundleFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"}],\"name\":\"LogRiskpoolBundleLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isMatching\",\"type\":\"bool\"}],\"name\":\"LogRiskpoolBundleMatchesPolicy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"}],\"name\":\"LogRiskpoolBundleUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolCapitalNew\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolCapitalOld\",\"type\":\"uint256\"}],\"name\":\"LogRiskpoolCapitalSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"processId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isSecured\",\"type\":\"bool\"}],\"name\":\"LogRiskpoolCollateralLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"processId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"LogRiskpoolCollateralReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"riskpoolAddress\",\"type\":\"address\"}],\"name\":\"LogRiskpoolCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogRiskpoolDeclined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"processId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogRiskpoolPayoutProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"processId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogRiskpoolPremiumProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogRiskpoolProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"APR_100_PERCENTAGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_FILTER_DATA_STRUCTURE\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EMPTY_STRING_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EXTENSION_INTERVAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FULL_COLLATERALIZATION_LEVEL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_APR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BUNDLE_LIFETIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_POLICY_COVERAGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_POLICY_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BUNDLE_LIFETIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_POLICY_COVERAGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_POLICY_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE_YEAR_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeBundles\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approvalCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"archiveCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"riskpoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum IBundle.BundleState\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"filter\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"capital\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedCapital\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"internalType\":\"struct IBundle.Bundle\",\"name\":\"bundle\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"enum IPolicy.ApplicationState\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"premiumAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sumInsuredAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"internalType\":\"struct IPolicy.Application\",\"name\":\"application\",\"type\":\"tuple\"}],\"name\":\"bundleMatchesApplication\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isMatching\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"riskpoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum IBundle.BundleState\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"filter\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"capital\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedCapital\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"internalType\":\"struct IBundle.Bundle\",\"name\":\"bundle\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"enum IPolicy.ApplicationState\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"premiumAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sumInsuredAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"internalType\":\"struct IPolicy.Application\",\"name\":\"application\",\"type\":\"tuple\"}],\"name\":\"bundleMatchesApplication2\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isMatching\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bundles\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"}],\"name\":\"burnBundle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sumInsured\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"annualPercentageReturn\",\"type\":\"uint256\"}],\"name\":\"calculatePremium\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"premiumAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"protectedBalance\",\"type\":\"uint256\"}],\"name\":\"calculateSumInsured\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sumInsured\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"}],\"name\":\"closeBundle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"processId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"collateralizePolicy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"lifetime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"policyMinProtectedBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"policyMaxProtectedBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"policyMinDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"policyMaxDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"annualPercentageReturn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialAmount\",\"type\":\"uint256\"}],\"name\":\"createBundle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"filter\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"initialAmount\",\"type\":\"uint256\"}],\"name\":\"createBundle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"declineCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"decodeApplicationParameterFromData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"protectedBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPremium\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"filter\",\"type\":\"bytes\"}],\"name\":\"decodeBundleParamsFromFilter\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"lifetime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSumInsured\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSumInsured\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"annualPercentageReturn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"defundBundle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"netAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depegPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetPrice\",\"type\":\"uint256\"}],\"name\":\"depegPriceIsBelowProtectedDepegPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isBelowProtectedPrice\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSumInsured\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSumInsured\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"annualPercentageReturn\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"enum IPolicy.ApplicationState\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"premiumAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sumInsuredAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"internalType\":\"struct IPolicy.Application\",\"name\":\"application\",\"type\":\"tuple\"}],\"name\":\"detailedBundleApplicationMatch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isMatching\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"protectedBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPremium\",\"type\":\"uint256\"}],\"name\":\"encodeApplicationParameterAsData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"lifetime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSumInsured\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSumInsured\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"annualPercentageReturn\",\"type\":\"uint256\"}],\"name\":\"encodeBundleParamsAsFilter\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"filter\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lifetimeExtension\",\"type\":\"uint256\"}],\"name\":\"extendBundleLifetime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"fundBundle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"netAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"getActiveBundleId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActiveBundleIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"activeBundleIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"}],\"name\":\"getActivePolicies\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"activePolicies\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getApr100PercentLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"apr100PercentLevel\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"getBundle\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"riskpoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum IBundle.BundleState\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"filter\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"capital\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedCapital\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"internalType\":\"struct IBundle.Bundle\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBundleCapitalCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bundleCapitalCap\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"}],\"name\":\"getBundleFilter\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"filter\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"getBundleId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"}],\"name\":\"getBundleInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"enum IBundle.BundleState\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lifetime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSumInsured\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSumInsured\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"annualPercentageReturn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"capitalSupportedByStaking\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"capital\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedCapital\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"}],\"internalType\":\"struct DepegRiskpool.BundleInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"}],\"name\":\"getBundleLifetimeData\",\"outputs\":[{\"internalType\":\"enum IBundle.BundleState\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lifetime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extendedLifetime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isExpired\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCapacity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCapital\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainRegistry\",\"outputs\":[{\"internalType\":\"contract IChainRegistryFacade\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCollateralizationLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getErc20Token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFilterDataStructure\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFullCollateralizationLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxBundleLifetime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxBundleLifetime\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaximumNumberOfActiveBundles\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maximumNumberOfActiveBundles\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getName\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"}],\"name\":\"getNftId\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"nftId\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOneYearDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"yearDuration\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetPrice\",\"type\":\"uint256\"}],\"name\":\"getProtectedMinDepegPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"protectedDepegPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegistry\",\"outputs\":[{\"internalType\":\"contract IRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRiskpoolCapitalCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolCapitalCap\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStaking\",\"outputs\":[{\"internalType\":\"contract IStakingFacade\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"internalType\":\"enum IComponent.ComponentState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSumInsuredPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sumInsuredPercentage\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSumOfSumInsuredCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"}],\"name\":\"getSupportedCapitalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"capitalCap\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalValueLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getType\",\"outputs\":[{\"internalType\":\"enum IComponent.ComponentType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAllowAllAccountsEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"allowAllAccounts\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"firstBundleId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondBundleId\",\"type\":\"uint256\"}],\"name\":\"isHigherPriorityBundle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"firstBundleIsHigherPriority\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOracle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isProduct\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRiskpool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"}],\"name\":\"lockBundle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"processId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"processPolicyPayout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"processId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"processPolicyPremium\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"processId\",\"type\":\"bytes32\"}],\"name\":\"releasePolicy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resumeCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowAccount\",\"type\":\"bool\"}],\"name\":\"setAllowAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"allowAllAccounts\",\"type\":\"bool\"}],\"name\":\"setAllowAllAccounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolCapitalCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bundleCapitalCap\",\"type\":\"uint256\"}],\"name\":\"setCapitalCaps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"setId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maximumNumberOfActiveBundles\",\"type\":\"uint256\"}],\"name\":\"setMaximumNumberOfActiveBundles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakingAddress\",\"type\":\"address\"}],\"name\":\"setStakingAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"suspendCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"}],\"name\":\"unlockBundle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DepegRiskpool", "CompilerVersion": "v0.8.2+commit.661d1103", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "44657065675f313639333932333734385f5269736b706f6f6c00000000000000000000000000000000000000000000000000000000000000000001d1a94a20000000000000000000000000000000000000000000000000000000000000000014000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000e14da747413a5beff56b9424895eeb6d00fc710b000000000000000000000000d250b7ec0dcae1c988a69120f7bb2213d4e7c660", "EVMVersion": "istanbul", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": ""}