{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/callhub.sol\": {\r\n      \"content\": \"pragma solidity 0.8.20;\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\n/** CallHub.tech is the ultimate cryptocurrency sharing platform that allows users to share tokens and track their progress. Callhub's mission is to empower everyone with an edge to both showcase it and monetize it.\\r\\n\\r\\n\ud83c\udf10 Website / App: https://CallHub.tech\\r\\n\ud83d\udcd6 Whitepaper: https://callhub.gitbook.io/wp/\\r\\n\ud83d\udc26 Twitter(X): https://x.com/CallHubTech\\r\\n\ud83d\ude80 TG: https://t.me/CallHubTech\\r\\n\ud83e\udd16 TG bot: https://t.me/CallHubBot\\r\\n\\r\\n*/\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ninterface IERC20Metadata is IERC20{\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the decimals places of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\\r\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\r\\n    mapping(address => uint256) private _balances;\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the values for {name} and {symbol}.\\r\\n     *\\r\\n     * All two of these values are immutable: they can only be set once during\\r\\n     * construction.\\r\\n     */\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of decimals used to get its user representation.\\r\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\r\\n     *\\r\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n     * Ether and Wei. This is the default value returned by this function, unless\\r\\n     * it's overridden.\\r\\n     *\\r\\n     * NOTE: This information is only used for _display_ purposes: it in\\r\\n     * no way affects any of the arithmetic of the contract, including\\r\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n     */\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _transfer(owner, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\r\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\r\\n     *\\r\\n     * NOTE: Does not update the allowance if the current allowance\\r\\n     * is the maximum `uint256`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` and `to` cannot be the zero address.\\r\\n     * - `from` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for ``from``'s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\r\\n        address spender = _msgSender();\\r\\n        _spendAllowance(from, spender, amount);\\r\\n        _transfer(from, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\r\\n        unchecked {\\r\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\r\\n     *\\r\\n     * This internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `from` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        uint256 fromBalance = _balances[from];\\r\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            _balances[from] = fromBalance - amount;\\r\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\r\\n            // decrementing then incrementing.\\r\\n            _balances[to] += amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _totalSupply += amount;\\r\\n        unchecked {\\r\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\r\\n            _balances[account] += amount;\\r\\n        }\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\r\\n     *\\r\\n     * This internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\r\\n     *\\r\\n     * Does not update the allowance amount in case of infinite allowance.\\r\\n     * Revert if not enough allowance is available.\\r\\n     *\\r\\n     * Might emit an {Approval} event.\\r\\n     */\\r\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        if (currentAllowance != type(uint256).max) {\\r\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\r\\n            unchecked {\\r\\n                _approve(owner, spender, currentAllowance - amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n    \\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() external virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary Address {\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        return account.code.length > 0;\\r\\n    }\\r\\n\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\r\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\r\\n     *\\r\\n     * _Available since v4.8._\\r\\n     */\\r\\n    function verifyCallResultFromTarget(\\r\\n        address target,\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        if (success) {\\r\\n            if (returndata.length == 0) {\\r\\n                // only check isContract if the call was successful and the return data is empty\\r\\n                // otherwise we already know that it was a contract\\r\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n            }\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\r\\n     * revert reason or using the provided one.\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\r\\n        // Look for revert reason and bubble it up if present\\r\\n        if (returndata.length > 0) {\\r\\n            // The easiest way to bubble the revert reason is using memory via assembly\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                let returndata_size := mload(returndata)\\r\\n                revert(add(32, returndata), returndata_size)\\r\\n            }\\r\\n        } else {\\r\\n            revert(errorMessage);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary SafeERC20 {\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n        if (returndata.length > 0) {\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\r\\n        require(\\r\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface ILpPair {\\r\\n    function sync() external;\\r\\n}\\r\\n\\r\\ninterface IDexRouter {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\\r\\n}\\r\\n\\r\\ninterface IDexFactory {\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n}\\r\\n\\r\\ncontract CallHub is ERC20, Ownable {\\r\\n\\r\\n    mapping (address => bool) public exemptFromFees;\\r\\n    mapping (address => bool) public exemptFromLimits;\\r\\n\\r\\n    bool public tradingAllowed;\\r\\n\\r\\n    mapping (address => bool) public isAMMPair;\\r\\n\\r\\n    address public marketingAddress;\\r\\n    address public devAddress;\\r\\n\\r\\n    Taxes public buyTax;\\r\\n    Taxes public sellTax;\\r\\n\\r\\n    TokensForTax public tokensForTax;\\r\\n\\r\\n    mapping(address => uint256) private _holderLastTransferBlock; // MEV protection\\r\\n    bool public antiMevEnabled = true;\\r\\n\\r\\n    bool public limited = true;\\r\\n\\r\\n    uint256 public swapTokensAtAmt;\\r\\n\\r\\n    address public immutable lpPair;\\r\\n    IDexRouter public immutable dexRouter;\\r\\n    address public immutable WETH;\\r\\n\\r\\n    TxLimits public txLimits;\\r\\n\\r\\n    uint64 public constant FEE_DIVISOR = 10000;\\r\\n\\r\\n    uint256 public launchBlock;\\r\\n    bool public dynamicTaxOn;\\r\\n    bool public dynamicLiquidityTax;\\r\\n\\r\\n    // structs\\r\\n\\r\\n    struct TxLimits {\\r\\n        uint128 transactionLimit;\\r\\n        uint128 walletLimit;\\r\\n    }\\r\\n\\r\\n    struct Taxes {\\r\\n        uint64 marketingTax;\\r\\n        uint64 devTax;\\r\\n        uint64 liquidityTax;\\r\\n        uint64 totalTax;\\r\\n    }\\r\\n\\r\\n    struct TokensForTax {\\r\\n        uint80 tokensForMarketing;\\r\\n        uint80 tokensForLiquidity;\\r\\n        uint80 tokensForDev;\\r\\n        bool gasSaver;\\r\\n    }\\r\\n\\r\\n    // events\\r\\n\\r\\n    event UpdatedTransactionLimit(uint newMax);\\r\\n    event UpdatedWalletLimit(uint newMax);\\r\\n    event SetExemptFromFees(address _address, bool _isExempt);\\r\\n    event SetExemptFromLimits(address _address, bool _isExempt);\\r\\n    event RemovedLimits();\\r\\n    event UpdatedBuyTax(uint newAmt);\\r\\n    event UpdatedSellTax(uint newAmt);\\r\\n\\r\\n    // constructor\\r\\n\\r\\n    constructor()\\r\\n        ERC20(\\\"CallHub\\\", \\\"CHUB\\\")\\r\\n    {   \\r\\n        _mint(msg.sender, 10_000_000 * 1e18);\\r\\n\\r\\n        address _v2Router;\\r\\n\\r\\n        dynamicTaxOn = true;\\r\\n        dynamicLiquidityTax = false;\\r\\n\\r\\n        // @dev assumes WETH pair\\r\\n        if(block.chainid == 1){\\r\\n            _v2Router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\r\\n        } else if(block.chainid == 5){\\r\\n            _v2Router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\r\\n        } else if(block.chainid == 97){\\r\\n            _v2Router = 0xD99D1c33F9fC3444f8101754aBC46c52416550D1;\\r\\n        } else if(block.chainid == 42161){\\r\\n            _v2Router = 0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506;\\r\\n        } else {\\r\\n            revert(\\\"Chain not configured\\\");\\r\\n        }\\r\\n\\r\\n        dexRouter = IDexRouter(_v2Router);\\r\\n\\r\\n        txLimits.transactionLimit = uint128(totalSupply() * 10 / 10000);\\r\\n        txLimits.walletLimit = uint128(totalSupply() * 10 / 10000);\\r\\n        swapTokensAtAmt = totalSupply() * 25 / 100000;\\r\\n\\r\\n        marketingAddress = 0xb9b379c641ce30cf1Ec44728650De5Bb4FCf78B0; // update\\r\\n        devAddress = 0x76cD3b3E69cC333B143dDD2055a432c7A84CAcB4; // update\\r\\n\\r\\n        buyTax.marketingTax = 1600; // 1% = 100\\r\\n        buyTax.liquidityTax = 0;\\r\\n        buyTax.devTax = 400;\\r\\n        buyTax.totalTax = buyTax.marketingTax + buyTax.liquidityTax + buyTax.devTax;\\r\\n\\r\\n        sellTax.marketingTax = 1600;\\r\\n        sellTax.liquidityTax = 0;\\r\\n        sellTax.devTax = 400;\\r\\n        sellTax.totalTax = sellTax.marketingTax + sellTax.liquidityTax + sellTax.devTax;\\r\\n\\r\\n        tokensForTax.gasSaver = true;\\r\\n\\r\\n        WETH = dexRouter.WETH();\\r\\n        lpPair = IDexFactory(dexRouter.factory()).createPair(address(this), WETH);\\r\\n\\r\\n        isAMMPair[lpPair] = true;\\r\\n\\r\\n        exemptFromLimits[lpPair] = true;\\r\\n        exemptFromLimits[msg.sender] = true;\\r\\n        exemptFromLimits[address(this)] = true;\\r\\n\\r\\n        exemptFromFees[msg.sender] = true;\\r\\n        exemptFromFees[address(this)] = true;\\r\\n        exemptFromFees[address(dexRouter)] = true;\\r\\n \\r\\n        _approve(address(this), address(dexRouter), type(uint256).max);\\r\\n        _approve(address(msg.sender), address(dexRouter), totalSupply());\\r\\n    }\\r\\n\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual override {\\r\\n        \\r\\n        if(!exemptFromFees[from] && !exemptFromFees[to]){\\r\\n            require(tradingAllowed, \\\"Trading not active\\\");\\r\\n            amount -= handleTax(from, to, amount);\\r\\n            checkLimits(from, to, amount);\\r\\n        }\\r\\n\\r\\n        super._transfer(from,to,amount);\\r\\n    }\\r\\n\\r\\n    function checkLimits(address from, address to, uint256 amount) internal {\\r\\n        if(limited){\\r\\n            bool exFromLimitsTo = exemptFromLimits[to];\\r\\n            uint256 balanceOfTo = balanceOf(to);\\r\\n            TxLimits memory _txLimits = txLimits;\\r\\n            // buy\\r\\n            if (isAMMPair[from] && !exFromLimitsTo) {\\r\\n                require(amount <= _txLimits.transactionLimit, \\\"Max Txn\\\");\\r\\n                require(amount + balanceOfTo <= _txLimits.walletLimit, \\\"Max Wallet\\\");\\r\\n            } \\r\\n            // sell\\r\\n            else if (isAMMPair[to] && !exemptFromLimits[from]) {\\r\\n                require(amount <= _txLimits.transactionLimit, \\\"Max Txn\\\");\\r\\n            }\\r\\n            else if(!exFromLimitsTo) {\\r\\n                require(amount + balanceOfTo <= _txLimits.walletLimit, \\\"Max Wallet\\\");\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (antiMevEnabled){\\r\\n            if(isAMMPair[to]){\\r\\n                require(_holderLastTransferBlock[from] < block.number, \\\"Anti MEV\\\");\\r\\n            } else {\\r\\n                _holderLastTransferBlock[to] = block.number;\\r\\n                _holderLastTransferBlock[tx.origin] = block.number;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function handleTax(address from, address to, uint256 amount) internal returns (uint256){\\r\\n\\r\\n        if(balanceOf(address(this)) >= swapTokensAtAmt && !isAMMPair[from]) {\\r\\n            convertTaxes();\\r\\n        }\\r\\n\\r\\n        if(dynamicTaxOn){\\r\\n            setInternalTaxes();\\r\\n        }\\r\\n        \\r\\n        uint128 tax = 0;\\r\\n\\r\\n        Taxes memory taxes;\\r\\n\\r\\n        if (isAMMPair[to]){\\r\\n            taxes = sellTax;\\r\\n        } else if(isAMMPair[from]){\\r\\n            taxes = buyTax;\\r\\n        }\\r\\n\\r\\n        if(taxes.totalTax > 0){\\r\\n            TokensForTax memory tokensForTaxUpdate = tokensForTax;\\r\\n            tax = uint128(amount * taxes.totalTax / FEE_DIVISOR);\\r\\n            tokensForTaxUpdate.tokensForLiquidity += uint80(tax * taxes.liquidityTax / taxes.totalTax / 1e9);\\r\\n            tokensForTaxUpdate.tokensForMarketing += uint80(tax * taxes.marketingTax / taxes.totalTax / 1e9);\\r\\n            tokensForTaxUpdate.tokensForDev += uint80(tax * taxes.devTax / taxes.totalTax / 1e9);\\r\\n            tokensForTax = tokensForTaxUpdate;\\r\\n            super._transfer(from, address(this), tax);\\r\\n        }\\r\\n        \\r\\n        return tax;\\r\\n    }\\r\\n\\r\\n    function swapTokensForETH(uint256 tokenAmt) private {\\r\\n\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = WETH;\\r\\n\\r\\n        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokenAmt,\\r\\n            0,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function convertTaxes() private {\\r\\n\\r\\n        uint256 contractBalance = balanceOf(address(this));\\r\\n        TokensForTax memory tokensForTaxMem = tokensForTax;\\r\\n        uint256 totalTokensToSwap = tokensForTaxMem.tokensForLiquidity + tokensForTaxMem.tokensForMarketing + tokensForTaxMem.tokensForDev;\\r\\n        \\r\\n        if(contractBalance == 0 || totalTokensToSwap == 0) {return;}\\r\\n\\r\\n        if(contractBalance > swapTokensAtAmt * 20){\\r\\n            contractBalance = swapTokensAtAmt * 20;\\r\\n        }\\r\\n\\r\\n        if(tokensForTaxMem.tokensForLiquidity > 0){\\r\\n            uint256 liquidityTokens = contractBalance * tokensForTaxMem.tokensForLiquidity / totalTokensToSwap;\\r\\n            super._transfer(address(this), lpPair, liquidityTokens);\\r\\n            try ILpPair(lpPair).sync(){} catch {}\\r\\n            contractBalance -= liquidityTokens;\\r\\n            totalTokensToSwap -= tokensForTaxMem.tokensForLiquidity;\\r\\n        }\\r\\n\\r\\n        if(contractBalance > 0){\\r\\n\\r\\n            swapTokensForETH(contractBalance);\\r\\n            \\r\\n            uint256 ethBalance = address(this).balance;\\r\\n\\r\\n            bool success;\\r\\n\\r\\n            if(tokensForTaxMem.tokensForDev > 0){\\r\\n                (success,) = devAddress.call{value: ethBalance * tokensForTaxMem.tokensForDev / totalTokensToSwap}(\\\"\\\");  \\r\\n            }\\r\\n\\r\\n            ethBalance = address(this).balance;\\r\\n\\r\\n            if(ethBalance > 0){\\r\\n                (success,) = marketingAddress.call{value: ethBalance}(\\\"\\\");  \\r\\n            }\\r\\n        }\\r\\n\\r\\n        tokensForTaxMem.tokensForLiquidity = 0;\\r\\n        tokensForTaxMem.tokensForMarketing = 0;\\r\\n        tokensForTaxMem.tokensForDev = 0;\\r\\n\\r\\n        tokensForTax = tokensForTaxMem;\\r\\n    }\\r\\n\\r\\n    // owner functions\\r\\n    function setExemptFromFee(address _address, bool _isExempt) external onlyOwner {\\r\\n        require(_address != address(0), \\\"Zero Address\\\");\\r\\n        require(_address != address(this), \\\"Cannot unexempt contract\\\");\\r\\n        exemptFromFees[_address] = _isExempt;\\r\\n        emit SetExemptFromFees(_address, _isExempt);\\r\\n    }\\r\\n\\r\\n    function setExemptFromLimit(address _address, bool _isExempt) external onlyOwner {\\r\\n        require(_address != address(0), \\\"Zero Address\\\");\\r\\n        if(!_isExempt){\\r\\n            require(_address != lpPair, \\\"Cannot remove pair\\\");\\r\\n        }\\r\\n        exemptFromLimits[_address] = _isExempt;\\r\\n        emit SetExemptFromLimits(_address, _isExempt);\\r\\n    }\\r\\n\\r\\n    function updateTransactionLimit(uint128 newNumInTokens) external onlyOwner {\\r\\n        require(newNumInTokens >= (totalSupply() * 1 / 1000)/(10**decimals()), \\\"Too low\\\");\\r\\n        txLimits.transactionLimit = uint128(newNumInTokens * (10**decimals()));\\r\\n        emit UpdatedTransactionLimit(txLimits.transactionLimit);\\r\\n    }\\r\\n\\r\\n    function updateWalletLimit(uint128 newNumInTokens) external onlyOwner {\\r\\n        require(newNumInTokens >= (totalSupply() * 1 / 1000)/(10**decimals()), \\\"Too low\\\");\\r\\n        txLimits.walletLimit = uint128(newNumInTokens * (10**decimals()));\\r\\n        emit UpdatedWalletLimit(txLimits.walletLimit);\\r\\n    }\\r\\n\\r\\n    function updateSwapTokensAmt(uint256 newAmount) external onlyOwner {\\r\\n        require(newAmount >= (totalSupply() * 1) / 100000, \\\"Swap amount cannot be lower than 0.001% total supply.\\\");\\r\\n        require(newAmount <= (totalSupply() * 5) / 1000, \\\"Swap amount cannot be higher than 0.5% total supply.\\\");\\r\\n        swapTokensAtAmt = newAmount;\\r\\n    }\\r\\n\\r\\n    function updateBuyTax(uint64 _marketingTax, uint64 _liquidityTax, uint64 _devTax) external onlyOwner {\\r\\n        Taxes memory taxes;\\r\\n        taxes.marketingTax = _marketingTax;\\r\\n        taxes.liquidityTax = _liquidityTax;\\r\\n        taxes.devTax = _devTax;\\r\\n        taxes.totalTax = _marketingTax + _liquidityTax + _devTax;\\r\\n        require(taxes.totalTax  <= 1000, \\\"Keep tax below 10%\\\");\\r\\n        emit UpdatedBuyTax(taxes.totalTax);\\r\\n        buyTax = taxes;\\r\\n    }\\r\\n\\r\\n    function updateSellTax(uint64 _marketingTax, uint64 _liquidityTax, uint64 _devTax) external onlyOwner {\\r\\n        Taxes memory taxes;\\r\\n        taxes.marketingTax = _marketingTax;\\r\\n        taxes.liquidityTax = _liquidityTax;\\r\\n        taxes.devTax = _devTax;\\r\\n        taxes.totalTax = _marketingTax + _liquidityTax + _devTax;\\r\\n        require(taxes.totalTax  <= 1000, \\\"Keep tax below 10%\\\");\\r\\n        emit UpdatedSellTax(taxes.totalTax);\\r\\n        sellTax = taxes;\\r\\n    }\\r\\n\\r\\n    function renounceDevTax() external {\\r\\n        require(msg.sender == devAddress, \\\"Not dev\\\");\\r\\n        \\r\\n        Taxes memory buyTaxes = buyTax;\\r\\n        buyTaxes.marketingTax += buyTaxes.devTax;\\r\\n        buyTaxes.devTax = 0;\\r\\n        buyTax = buyTaxes;\\r\\n\\r\\n        Taxes memory sellTaxes = sellTax;\\r\\n        sellTaxes.marketingTax += sellTaxes.devTax;\\r\\n        sellTaxes.devTax = 0;\\r\\n        sellTax = sellTaxes;\\r\\n    }\\r\\n\\r\\n    function enableTrading() external onlyOwner {\\r\\n        require(!tradingAllowed, \\\"Trading already enabled\\\");\\r\\n        tradingAllowed = true;\\r\\n        launchBlock = block.number;\\r\\n    }\\r\\n\\r\\n    function removeLimits() external onlyOwner {\\r\\n        limited = false;\\r\\n        TxLimits memory _txLimits;\\r\\n        uint256 supply = totalSupply();\\r\\n        _txLimits.transactionLimit = uint128(supply);\\r\\n        _txLimits.walletLimit = uint128(supply);\\r\\n        txLimits = _txLimits;\\r\\n        emit RemovedLimits();\\r\\n    }\\r\\n\\r\\n    function updateMevBlockerEnabled(bool _enabled) external onlyOwner {\\r\\n        antiMevEnabled = _enabled;\\r\\n    }\\r\\n\\r\\n    function airdropToWallets(address[] calldata wallets, uint256[] calldata amountsInWei) external onlyOwner {\\r\\n        require(wallets.length == amountsInWei.length, \\\"arrays length mismatch\\\");\\r\\n        for(uint256 i = 0; i < wallets.length; i++){\\r\\n            super._transfer(msg.sender, wallets[i], amountsInWei[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function rescueTokens(address _token, address _to) external onlyOwner {\\r\\n        require(_token != address(0), \\\"_token address cannot be 0\\\");\\r\\n        uint256 _contractBalance = IERC20(_token).balanceOf(address(this));\\r\\n        SafeERC20.safeTransfer(IERC20(_token),_to, _contractBalance);\\r\\n    }\\r\\n\\r\\n    function updateMarketingAddress(address _address) external onlyOwner {\\r\\n        require(_address != address(0), \\\"zero address\\\");\\r\\n        marketingAddress = _address;\\r\\n    }\\r\\n\\r\\n    function updateDevAddress(address _address) external onlyOwner {\\r\\n        require(_address != address(0), \\\"zero address\\\");\\r\\n        devAddress = _address;\\r\\n    }\\r\\n\\r\\n    function removeDynamicTax() external onlyOwner {\\r\\n        require(dynamicTaxOn, \\\"Already off\\\");\\r\\n        dynamicTaxOn = false;\\r\\n    }\\r\\n\\r\\n    receive() payable external {}\\r\\n\\r\\n    function setInternalTaxes() internal {\\r\\n        Taxes memory newBuyTax = buyTax;\\r\\n        Taxes memory newSellTax = sellTax;\\r\\n        TxLimits memory _txLimits = txLimits;\\r\\n\\r\\n        uint256 currentBlock = block.number;\\r\\n        uint256 blocksSinceLaunch = currentBlock - launchBlock;\\r\\n        uint256 decay = blocksSinceLaunch / 10;\\r\\n\\r\\n        if(decay >= 11){\\r\\n            dynamicTaxOn = false;\\r\\n            newBuyTax.totalTax = 500;\\r\\n            newSellTax.totalTax = 500;\\r\\n            limited = false;\\r\\n            uint256 supply = totalSupply();\\r\\n            _txLimits.transactionLimit = uint128(supply);\\r\\n            _txLimits.walletLimit = uint128(supply);\\r\\n            txLimits = _txLimits;\\r\\n            emit RemovedLimits();\\r\\n        } else if (decay > 0) {\\r\\n            newBuyTax.totalTax = uint64(2000 - (decay * 100));\\r\\n            newSellTax.totalTax = uint64(2000 - (decay * 100));\\r\\n            _txLimits.transactionLimit = uint128(totalSupply() * decay / 1000);\\r\\n            _txLimits.walletLimit = uint128(totalSupply() * decay / 1000);\\r\\n        } \\r\\n\\r\\n        if(buyTax.totalTax != newBuyTax.totalTax){\\r\\n            if(dynamicLiquidityTax){\\r\\n                newBuyTax.marketingTax = newBuyTax.totalTax * 6 / 10;\\r\\n                newBuyTax.liquidityTax = newBuyTax.totalTax * 2 / 10;\\r\\n            } else {\\r\\n                newBuyTax.marketingTax = newBuyTax.totalTax * 8 / 10;\\r\\n                newBuyTax.liquidityTax = 0;\\r\\n            }\\r\\n            newBuyTax.devTax = newBuyTax.totalTax - newBuyTax.marketingTax - newBuyTax.liquidityTax;\\r\\n            buyTax = newBuyTax;\\r\\n        }\\r\\n        if(sellTax.totalTax != newSellTax.totalTax){\\r\\n            if(dynamicLiquidityTax){\\r\\n                newSellTax.marketingTax = newSellTax.totalTax * 6 / 10;\\r\\n                newSellTax.liquidityTax = newSellTax.totalTax * 2 / 10;\\r\\n            } else {\\r\\n                newSellTax.marketingTax = newSellTax.totalTax * 8 / 10;\\r\\n                newSellTax.liquidityTax = 0;\\r\\n            }\\r\\n            newSellTax.devTax = newSellTax.totalTax - newSellTax.marketingTax - newSellTax.liquidityTax;\\r\\n            sellTax = newSellTax;\\r\\n        }\\r\\n\\r\\n        if(_txLimits.transactionLimit != txLimits.transactionLimit){\\r\\n            txLimits = _txLimits;\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RemovedLimits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_isExempt\",\"type\":\"bool\"}],\"name\":\"SetExemptFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_isExempt\",\"type\":\"bool\"}],\"name\":\"SetExemptFromLimits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmt\",\"type\":\"uint256\"}],\"name\":\"UpdatedBuyTax\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmt\",\"type\":\"uint256\"}],\"name\":\"UpdatedSellTax\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMax\",\"type\":\"uint256\"}],\"name\":\"UpdatedTransactionLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMax\",\"type\":\"uint256\"}],\"name\":\"UpdatedWalletLimit\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEE_DIVISOR\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsInWei\",\"type\":\"uint256[]\"}],\"name\":\"airdropToWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"antiMevEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTax\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"marketingTax\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"devTax\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"liquidityTax\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"totalTax\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dexRouter\",\"outputs\":[{\"internalType\":\"contract IDexRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dynamicLiquidityTax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dynamicTaxOn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"exemptFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"exemptFromLimits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAMMPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limited\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeDynamicTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceDevTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"rescueTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTax\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"marketingTax\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"devTax\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"liquidityTax\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"totalTax\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isExempt\",\"type\":\"bool\"}],\"name\":\"setExemptFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isExempt\",\"type\":\"bool\"}],\"name\":\"setExemptFromLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensForTax\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"tokensForMarketing\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"tokensForLiquidity\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"tokensForDev\",\"type\":\"uint80\"},{\"internalType\":\"bool\",\"name\":\"gasSaver\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"txLimits\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"transactionLimit\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"walletLimit\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_marketingTax\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_liquidityTax\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_devTax\",\"type\":\"uint64\"}],\"name\":\"updateBuyTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"updateDevAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"updateMarketingAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"updateMevBlockerEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_marketingTax\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_liquidityTax\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_devTax\",\"type\":\"uint64\"}],\"name\":\"updateSellTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"updateSwapTokensAmt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"newNumInTokens\",\"type\":\"uint128\"}],\"name\":\"updateTransactionLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"newNumInTokens\",\"type\":\"uint128\"}],\"name\":\"updateWalletLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CallHub", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}