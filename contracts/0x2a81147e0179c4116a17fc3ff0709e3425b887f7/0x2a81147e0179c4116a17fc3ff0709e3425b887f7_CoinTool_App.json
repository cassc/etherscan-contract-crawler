{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\n/*\r\n//https://cointool.app web3 basic tools!\r\n//\r\n//\r\n//  _____      _    _______          _                        \r\n// / ____|    (_)  |__   __|        | |     /\\                \r\n//| |     ___  _ _ __ | | ___   ___ | |    /  \\   _ __  _ __  \r\n//| |    / _ \\| | '_ \\| |/ _ \\ / _ \\| |   / /\\ \\ | '_ \\| '_ \\ \r\n//| |___| (_) | | | | | | (_) | (_) | |_ / ____ \\| |_) | |_) |\r\n// \\_____\\___/|_|_| |_|_|\\___/ \\___/|_(_)_/    \\_\\ .__/| .__/ \r\n//                                               | |   | |    \r\n//                                               |_|   |_|    \r\n//\r\n*/\r\n\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract CoinTool_App{\r\n    address owner;\r\n    address private immutable original;\r\n    mapping(address => mapping(bytes =>uint256)) public map;\r\n\r\n    constructor() payable {\r\n        original = address(this);\r\n        owner = tx.origin;\r\n    }\r\n    receive() external payable {}\r\n    fallback() external payable{}\r\n\r\n    function t(uint256 total,bytes memory data,bytes calldata _salt) external payable {\r\n        require(msg.sender == tx.origin);\r\n        bytes memory bytecode = bytes.concat(bytes20(0x3D602d80600A3D3981F3363d3d373d3D3D363d73), bytes20(address(this)), bytes15(0x5af43d82803e903d91602b57fd5bf3));\r\n        uint256 i = map[msg.sender][_salt]+1;\r\n        uint256 end = total+i;\r\n        for (i; i < end;++i) {\r\n\t        bytes32 salt = keccak256(abi.encodePacked(_salt,i,msg.sender));\r\n\t\t\tassembly {\r\n\t            let proxy := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n                    let succeeded := call(\r\n                        gas(),\r\n                        proxy,\r\n                        0,\r\n                        add(data, 0x20),\r\n                        mload(data),\r\n                        0,\r\n                        0\r\n                    )\r\n\t\t\t}\r\n        }\r\n        map[msg.sender][_salt] += total;\r\n    }\r\n\r\n\r\n    function t_(uint256[] calldata a,bytes memory data,bytes calldata _salt) external payable {\r\n        require(msg.sender == tx.origin);\r\n        bytes memory bytecode = bytes.concat(bytes20(0x3D602d80600A3D3981F3363d3d373d3D3D363d73), bytes20(address(this)), bytes15(0x5af43d82803e903d91602b57fd5bf3));\r\n        uint256 i = 0;\r\n        for (i; i < a.length; ++i) {\r\n\t        bytes32 salt = keccak256(abi.encodePacked(_salt,a[i],msg.sender));\r\n\t\t\tassembly {\r\n\t            let proxy := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n                    let succeeded := call(\r\n                        gas(),\r\n                        proxy,\r\n                        0,\r\n                        add(data, 0x20),\r\n                        mload(data),\r\n                        0,\r\n                        0\r\n                    )\r\n\t\t\t}\r\n        }\r\n        uint256 e = a[a.length-1];\r\n        if(e>map[msg.sender][_salt]){\r\n           map[msg.sender][_salt] = e;\r\n        }\r\n    }\r\n\r\n    function f(uint256[] calldata a,bytes memory data,bytes memory _salt) external payable {\r\n        require(msg.sender == tx.origin);\r\n        bytes32 bytecode = keccak256(abi.encodePacked(bytes.concat(bytes20(0x3D602d80600A3D3981F3363d3d373d3D3D363d73), bytes20(address(this)), bytes15(0x5af43d82803e903d91602b57fd5bf3))));\r\n        uint256 i = 0;\r\n        for (i; i < a.length; ++i) {\r\n\t        bytes32 salt = keccak256(abi.encodePacked(_salt,a[i],msg.sender));\r\n            address proxy = address(uint160(uint(keccak256(abi.encodePacked(\r\n                    hex'ff',\r\n                    address(this),\r\n                    salt,\r\n                    bytecode\r\n                )))));\r\n\t\t\tassembly {\r\n                let succeeded := call(\r\n                    gas(),\r\n                    proxy,\r\n                    0,\r\n                    add(data, 0x20),\r\n                    mload(data),\r\n                    0,\r\n                    0\r\n                )\r\n\t\t\t}\r\n        }\r\n    }\r\n\r\n\r\n\r\n    function d(address a,bytes memory data) external payable{\r\n        require(msg.sender == original);\r\n        a.delegatecall(data);\r\n    }\r\n    function c(address a,bytes calldata data) external payable {\r\n       require(msg.sender == original);\r\n       external_call(a,data);\r\n    }\r\n\r\n    function dKill(address a,bytes memory data) external payable{\r\n        require(msg.sender == original);\r\n        a.delegatecall(data);\r\n        selfdestruct(payable(msg.sender));\r\n    }\r\n    function cKill(address a,bytes calldata data) external payable {\r\n       require(msg.sender == original);\r\n       external_call(a,data);\r\n       selfdestruct(payable(msg.sender));\r\n    }\r\n\r\n    function k() external {\r\n        require(msg.sender == original);\r\n        selfdestruct(payable(msg.sender));\r\n    }\r\n   \r\n    function external_call(address destination,bytes memory data) internal{\r\n        assembly {\r\n            let succeeded := call(\r\n                gas(),\r\n                destination,\r\n                0,\r\n                add(data, 0x20),\r\n                mload(data),\r\n                0,\r\n                0\r\n            )\r\n        }\r\n    }\r\n\r\n\r\n    function claimTokens(address _token) external  {\r\n        require(owner == msg.sender);\r\n        if (_token == address(0x0)) {\r\n           payable (owner).transfer(address(this).balance);\r\n            return;\r\n        }\r\n        IERC20 erc20token = IERC20(_token);\r\n        uint256 balance = erc20token.balanceOf(address(this));\r\n        erc20token.transfer(owner, balance);\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"c\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"cKill\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"d\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"dKill\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"a\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_salt\",\"type\":\"bytes\"}],\"name\":\"f\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"k\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"map\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_salt\",\"type\":\"bytes\"}],\"name\":\"t\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"a\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_salt\",\"type\":\"bytes\"}],\"name\":\"t_\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CoinTool_App", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5f297dfed403682a4960b7769600b70af12a513c6536b40fdf7f27534d2504ee"}