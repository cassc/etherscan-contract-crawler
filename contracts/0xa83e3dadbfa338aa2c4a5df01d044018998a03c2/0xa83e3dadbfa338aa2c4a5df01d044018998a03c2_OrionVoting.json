{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/base/Staking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n//import \\\"hardhat/console.sol\\\";\\n\\nabstract contract Staking {\\n    uint256 internal constant RATE_PRECISION = 1e40;\\n\\n    uint256 public rewardRate; //\u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c \u043d\u0430\u0433\u0440\u0430\u0434, \u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440 1 ORN \u0432 \u0441\u0435\u043a\u0443\u043d\u0434\u0443 \u043d\u0430 \u0432\u0441\u0435\u0445 (\u0442\u043e\u0447\u043d\u043e\u0441\u0442\u044c 10**48)\\n\\n    struct UserState {\\n        uint256 stake;\\n        uint256 rateCumulative;\\n        uint256 reward;\\n        uint256 rewardWithdraw;\\n    }\\n\\n    uint256 public allStake; //\u0441\u0443\u043c\u043c\u0430 \u0432\u0441\u0435\u0445 \u0441\u0442\u0435\u0439\u043a\u043e\u0432\\n    mapping(address => UserState) public poolStake; //\u0441\u0442\u0435\u0439\u043a\u0438 \u043f\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\u043c\\n\\n    uint256 public rateCumulative;\\n    uint256 public rateTime;\\n    uint256 private rewardCumulativeTotal; //\u0441\u0443\u043c\u043c\u0430 \u0432\u0441\u0435\u0445 \u043d\u0430\u0433\u0440\u0430\u0434\\n\\n    event SetRewards(\\n        uint64 rewards,\\n        uint64 duration,\\n        uint256 rewardCumulativeTotal,\\n        uint256 rateCumulative,\\n        uint256 timestamp\\n    );\\n    event Stake(\\n        address indexed account,\\n        uint256 amount,\\n        uint256 rewardCumulativeTotal,\\n        uint256 rateCumulative,\\n        uint256 reward,\\n        uint256 timestamp\\n    );\\n    event Unstake(\\n        address indexed account,\\n        uint256 amount,\\n        uint256 rewardCumulativeTotal,\\n        uint256 rateCumulative,\\n        uint256 reward,\\n        uint256 timestamp\\n    );\\n    event ClaimReward(\\n        address indexed account,\\n        uint256 amount,\\n        uint256 rewardCumulativeTotal,\\n        uint256 rateCumulative,\\n        uint256 reward,\\n        uint256 timestamp\\n    );\\n\\n    //  Set the overall reward\\n    function _setRewards(uint64 rewards, uint64 duration) internal {\\n        require(duration > 0, \\\"_setRewards: zero duration\\\");\\n\\n        _writeCumulative();\\n\\n        //  ORN / sec\\n        rewardRate = (RATE_PRECISION * rewards) / duration;\\n\\n        emit SetRewards(\\n            rewards,\\n            duration,\\n            rewardCumulativeTotal,\\n            rateCumulative,\\n            block.timestamp\\n        );\\n    }\\n\\n    //\u0420\u0430\u0441\u0447\u0435\u0442 \u043d\u043e\u0432\u043e\u0433\u043e \u043a\u0443\u0440\u0441\u0430 \u043d\u0430\u0433\u0440\u0430\u0434\u044b\\n    function calcNewRate() public view virtual returns (uint256) {\\n        uint256 Rate = 0;\\n        if (allStake > 0) {\\n            Rate = rewardRate / allStake;\\n        }\\n\\n        return Rate * (block.timestamp - rateTime);\\n    }\\n\\n    function _writeCumulative() internal virtual {\\n        uint256 newRate = calcNewRate();\\n\\n        rewardCumulativeTotal += (newRate * allStake) / RATE_PRECISION;\\n        rateCumulative += newRate;\\n        rateTime = block.timestamp;\\n    }\\n\\n    function _stake(address account, uint256 amount) internal {\\n        require(amount > 0, \\\"_stake: zero stake amount\\\");\\n\\n        _writeCumulative();\\n\\n        UserState memory item = poolStake[account];\\n        item.reward = _calcReward(item, rateCumulative);\\n        item.stake += amount;\\n        item.rateCumulative = rateCumulative;\\n        poolStake[account] = item;\\n\\n        allStake += amount;\\n\\n        emit Stake(\\n            account,\\n            amount,\\n            rewardCumulativeTotal,\\n            rateCumulative,\\n            item.reward,\\n            block.timestamp\\n        );\\n    }\\n\\n    function _claimReward(address account, uint256 amount) internal {\\n        _writeCumulative();\\n\\n        UserState memory item = poolStake[account];\\n\\n        item.reward = _calcReward(item, rateCumulative);\\n        require(\\n            item.reward - item.rewardWithdraw >= amount,\\n            \\\"Error claim amount\\\"\\n        );\\n        item.rewardWithdraw += amount;\\n        item.rateCumulative = rateCumulative;\\n        poolStake[account] = item;\\n\\n        emit ClaimReward(\\n            account,\\n            amount,\\n            rewardCumulativeTotal,\\n            rateCumulative,\\n            item.reward,\\n            block.timestamp\\n        );\\n    }\\n\\n    function _unstake(address account, uint256 amount) internal {\\n        _writeCumulative();\\n\\n        UserState memory item = poolStake[account];\\n        require(item.stake >= amount, \\\"Error unstake amount\\\");\\n\\n        item.reward = _calcReward(item, rateCumulative);\\n        item.stake -= amount;\\n        item.rateCumulative = rateCumulative;\\n        poolStake[account] = item;\\n\\n        allStake -= amount;\\n\\n        emit Unstake(\\n            account,\\n            amount,\\n            rewardCumulativeTotal,\\n            rateCumulative,\\n            item.reward,\\n            block.timestamp\\n        );\\n    }\\n\\n    function _calcReward(\\n        UserState memory item,\\n        uint256 _rateCumulative\\n    ) internal pure returns (uint256) {\\n        return\\n            item.reward +\\n            ((_rateCumulative - item.rateCumulative) * item.stake) /\\n            RATE_PRECISION;\\n    }\\n\\n    function getReward(address account) public view virtual returns (uint256) {\\n        UserState memory item = poolStake[account];\\n        uint256 _rateCumulative = rateCumulative + calcNewRate();\\n        return _calcReward(item, _rateCumulative) - item.rewardWithdraw;\\n    }\\n\\n    function getStake(address account) public view returns (uint256) {\\n        return poolStake[account].stake;\\n    }\\n\\n    function getRewardWithdraw(\\n        address account\\n    ) external view returns (uint256) {\\n        return poolStake[account].rewardWithdraw;\\n    }\\n\\n    function getRewardCumulative(\\n        address account\\n    ) external view returns (uint256) {\\n        return getReward(account) + poolStake[account].rewardWithdraw;\\n    }\\n\\n    function getRewardCumulativeAll() public view returns (uint256) {\\n        uint256 newRate = calcNewRate();\\n        return rewardCumulativeTotal + (newRate * allStake) / RATE_PRECISION;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/interfaces/IOrionFarmV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n\\ninterface IOrionFarmV2\\n{\\n    //Action\\n    function create_lock_period(address pool, uint256 amount, uint256 lock_period) external;\\n    function increase_amount(address pool, uint256 amount) external;\\n    function increase_lock_period(address pool, uint256 new_lock_period) external;\\n    function withdraw(address pool) external;\\n    function claimReward(address pool) external;\\n\\n    function createSmartReward(address pool) external;\\n\\n    //View\\n    function getReward(address pool, address account) external view returns (uint256);\\n    function getBoost(address pool, address account) external view returns (uint256);\\n    function getStake(address pool, address account) external view returns (uint256);\\n    function allStake(address pool) external view returns (uint256);\\n    function lockTimeStart(address pool, address account) external view returns (uint48);\\n    function lockTimePeriod(address pool, address account) external view returns (uint48);\\n\\n    function libStakingReward() external view returns(address);\\n}\\n\\n\"\r\n    },\r\n    \"contracts/governance/interfaces/IOrionVoting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./IStaking.sol\\\";\\n\\ninterface IOrionVoting is IStaking\\n{\\n\\n    //admin\\n    function setSmart(address addr, bool bUse) external;\\n    function setRewards(uint64 rewards, uint64 duration) external;\\n    function addPool(address pool) external;\\n    function deletePool(address pool) external;\\n\\n\\n    //user\\n    function vote(address pool, uint256 amount) external;\\n    function voteArr(address[] calldata pools, uint256[] calldata amounts) external;\\n    function unvote(address pool, uint256 amount) external;\\n    function unvoteAll(address account) external;\\n\\n    //smart\\n    function claimReward(address pool, address to, uint256 amount) external;\\n\\n    //vew\\n    function countPool() external view returns (uint256);//number of pools\\n    function poolList(uint256) external view returns (address);//list of pools\\n    function poolIndex(address pool) external view returns (uint256);//whether there is a pool in the list (index numbers starting from 1)\\n    function users(address user) external view returns (uint256);//user votes across all pools\\n    function usersPool(address user,address pool) external view returns (uint256);//user votes by pool\\n    function smarts(address smart) external view returns (bool);//white list of trusted farm contracts\\n\\n    function veORN() external view returns (address);\\n    function ORN() external view returns (address);\\n\\n    function havePool(address account) external view returns (bool);\\n\\n\\n\\n}\\n\"\r\n    },\r\n    \"contracts/governance/interfaces/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n\\ninterface IStaking\\n{\\n    //staking\\n    function getReward(address account) external view returns (uint256);\\n    function getStake(address account) external view returns (uint256);\\n    function allStake() external view returns (uint256);\\n    function rewardRate() external view returns (uint256);\\n    function rateCumulative() external view returns (uint256);\\n    function rateTime() external view returns (uint256);\\n\\n\\n    function getRewardWithdraw(address account) external view returns (uint256);\\n    function getRewardCumulative(address account) external view returns (uint256);\\n    function getRewardCumulativeAll() external view returns (uint256);\\n\\n}\"\r\n    },\r\n    \"contracts/governance/interfaces/ITWBalance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\ninterface ITWBalance\\n{\\n    struct TWItem\\n    {\\n        // the block timestamp\\n        uint48  timestamp;        \\n        // the amount accumulator, i.e. amount * time elapsed\\n        uint208 amountTW;\\n    }\\n\\n    /// @notice Returns the time weight (TW) amount of tokens in existence.\\n    function totalSupplyTW() external view returns (TWItem memory);\\n\\n    /// @notice Calculates the average aamount of tokens in existence from the specified TW period\\n    function totalSupplyAvg(TWItem memory itemStart) view external returns (uint256);\\n\\n    /// @notice Returns the time weight (TW) balance of a token\\n    /// @param user The account for which to look up the number of tokens it has, i.e. its balance\\n    /// @return The number of tokens held by the account\\n    function balanceOfTW(address user) external view returns (TWItem memory);\\n    \\n    /// @notice Calculates the average address balance from the specified TW period\\n    function balanceOfAvg(address user, TWItem memory itemStart) view external returns (uint256);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/governance/interfaces/IveORN.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./ITWBalance.sol\\\";\\nimport \\\"./IStaking.sol\\\";\\n\\ninterface IveORN is ITWBalance,IStaking\\n{\\n    struct UserInfo {\\n        uint48 time_lock;\\n        uint128 balance;\\n        uint128 amount_token;\\n    }\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n    function totalSupply(uint256 ts) external view returns (uint256);\\n    function totalSupply0() external view returns (uint256);//balance on start timestamp\\n\\n    /// @notice Returns the balance of a token\\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\\n    /// @return The number of tokens held by the account\\n    function balanceOf(address account) external view returns (uint256);\\n    function balanceOf(address account, uint256 ts) external view returns (uint256);\\n    function balanceOf0(address account) external view returns (uint256);//balance on start timestamp\\n\\n    function balanceTokenOf(address account) external view  returns (uint256);\\n\\n    /// @notice Returns the number of decimals used to get its user representation.\\n    function decimals() external view returns (uint8);\\n    \\n    function name() pure external returns(string memory);\\n    function symbol() pure external returns(string memory);\\n \\n\\n    function ORN() external view returns (address);\\n\\n    function lockTime(address account) external view returns (uint48);\\n\\n    \\n    //staking ORN\\n    function create_lock(uint256 _value, uint256 _unlock_time) external;\\n    //function deposit_for(address _addr, uint256 _value) external;\\n    function increase_amount(uint256 _value) external;\\n    function increase_unlock_time(uint256 _unlock_time) external;\\n    function increase_unlock_period(uint256 unlock_period) external;\\n    function create_lock_period(uint256 _value, uint256 unlock_period) external;\\n\\n    function withdraw() external;\\n    function claimReward() external;\\n\\n    function tokenMap(address user) external returns(UserInfo memory);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/governance/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.7;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nlibrary TransferHelper {\\n    /// @notice Transfers tokens from the targeted address to the given destination\\n    /// @notice Errors with 'STF' if transfer fails\\n    /// @param token The contract address of the token to be transferred\\n    /// @param from The originating address from which the tokens will be transferred\\n    /// @param to The destination address of the transfer\\n    /// @param value The amount to be transferred\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\\n    }\\n\\n    /// @notice Transfers tokens from msg.sender to a recipient\\n    /// @dev Errors with ST if transfer fails\\n    /// @param token The contract address of the token which will be transferred\\n    /// @param to The recipient of the transfer\\n    /// @param value The value of the transfer\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\\n    }\\n\\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\\n    /// @dev Errors with 'SA' if transfer fails\\n    /// @param token The contract address of the token to be approved\\n    /// @param to The target of the approval\\n    /// @param value The amount of the given token the target will be allowed to spend\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\\n    }\\n\\n    /// @notice Transfers ETH to the recipient address\\n    /// @dev Fails with `STE`\\n    /// @param to The destination of the transfer\\n    /// @param value The value to be transferred\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'STE');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/OrionVoting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./base/Staking.sol\\\";\\nimport \\\"./libraries/TransferHelper.sol\\\";\\nimport \\\"./interfaces/IveORN.sol\\\";\\nimport \\\"./interfaces/IOrionVoting.sol\\\";\\nimport \\\"./interfaces/IOrionFarmV2.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nuint256 constant MAX_PERCENT = 10000;\\n\\n\\ncontract OrionVoting is Staking {\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n    struct Proposal {\\n        bytes32 name;\\n        EnumerableSet.Bytes32Set choices;\\n        uint256 timestampFinish;\\n    }\\n\\n    uint256 public countPool; //number of pools\\n    mapping(uint256 => address) public poolList; //list of pools\\n    mapping(address => uint256) public poolIndex; //whether there is a pool in the list (index numbers starting from 1)\\n\\n    mapping(address => uint256) public users; //user votes across all pools\\n    mapping(address => mapping(address => uint256)) public usersPool; //user votes by pool\\n\\n    mapping(address => bool) public smarts; //white list of trusted farm contracts\\n\\n    address public immutable veORN;\\n    address public immutable ORN;\\n    address public immutable smartOwner;\\n\\n    mapping(bytes32 => Proposal) private proposals;\\n    mapping(bytes32 => uint256) public proposalVotes;\\n    mapping(bytes32 => mapping(address => uint256)) public voted;\\n    mapping(address => mapping(bytes32 => bytes32)) public userVotedChoice;\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == smartOwner, \\\"Caller is not the owner\\\");\\n        _;\\n    }\\n\\n    event UsePool(address indexed pool, bool bUse);\\n    event Vote(address indexed pool, address indexed account, uint256 amount);\\n    event Unvote(address indexed pool, address indexed account, uint256 amount);\\n    event UnvoteAll(address indexed account);\\n    event ProposalCreated(\\n        bytes32 name,\\n        uint256 timestampFinish,\\n        bytes32[] choices\\n    );\\n    event ProposalVoted(\\n        address user,\\n        bytes32 name,\\n        bytes32 choice,\\n        uint256 votePower\\n    );\\n    event ProposalUnvoted(\\n        address user,\\n        bytes32 name,\\n        bytes32 choice,\\n        uint256 votePower\\n    );\\n\\n    error MAX_PROPOSALS_EXCEED();\\n    error PROPOSAL_NOT_EXIST();\\n    error ALREADY_VOTED();\\n    error EMPTY_NAME();\\n    error EMPTY_CHOICES();\\n    error PROPOSAL_FINISHED();\\n    error CHOICE_NOT_EXIST();\\n    error DUPLICATED_CHOICES();\\n    error PROPOSAL_ALREADY_EXIST();\\n    error LOCK_WILL_EXPIRE();\\n    error ZERO_PREVIOUS_VOTE();\\n    error CANT_CHANGE_CHOICE();\\n\\n    constructor(address veORN_, address owner) {\\n        veORN = veORN_;\\n        ORN = IveORN(veORN).ORN();\\n        smartOwner = owner;\\n    }\\n\\n    //admin caller\\n\\n    function setSmart(address addr, bool bUse) external onlyOwner {\\n        smarts[addr] = bUse;\\n    }\\n\\n    function setRewards(uint64 rewards, uint64 duration) external onlyOwner {\\n        _setRewards(rewards, duration);\\n    }\\n\\n    function addPool(address pool) public onlyOwner {\\n        countPool++;\\n        poolIndex[pool] = countPool;\\n        poolList[countPool] = pool;\\n\\n        emit UsePool(pool, true);\\n    }\\n\\n    function deletePool(address pool) external onlyOwner {\\n        uint256 index = poolIndex[pool];\\n        require(index > 0, \\\"Pool not found\\\");\\n        delete poolIndex[pool];\\n\\n        //we move the last element to the place of the deleted one and delete the last element\\n        poolList[index] = poolList[countPool];\\n        poolIndex[poolList[countPool]] = index;\\n        delete poolList[countPool];\\n        countPool--;\\n\\n        emit UsePool(pool, false);\\n    }\\n\\n    //smart caller\\n\\n    function claimReward(address pool, address to, uint256 amount) external {\\n        require(\\n            smarts[msg.sender],\\n            \\\"claimReward: caller not found in white list\\\"\\n        );\\n\\n        _claimReward(pool, amount);\\n\\n        TransferHelper.safeTransfer(ORN, to, amount);\\n    }\\n\\n    //user caller\\n    function votePercent(address pool, uint256 percent) external {\\n        require(percent <= MAX_PERCENT, \\\"Error percent\\\");\\n        uint256 balanceVeORN = IveORN(veORN).balanceOf0(msg.sender);\\n        vote(pool, (balanceVeORN * percent) / MAX_PERCENT);\\n    }\\n\\n    function vote(address pool, uint256 amount) public {\\n        require(poolIndex[pool] > 0, \\\"Pool not found\\\");\\n\\n        //check balance\\n        uint256 balanceVeORN = IveORN(veORN).balanceOf0(msg.sender);\\n        uint256 balanceVotes = users[msg.sender];\\n        //require(balanceVeORN >= balanceVotes+amount,\\\"Error user veORN balance\\\");// and revert if overflow\\n        uint256 balanceRemained;\\n        if (balanceVeORN > balanceVotes)\\n            balanceRemained = balanceVeORN - balanceVotes;\\n        if (amount > balanceRemained) amount = balanceRemained;\\n\\n        users[msg.sender] += amount;\\n        usersPool[msg.sender][pool] += amount;\\n\\n        _stake(pool, amount);\\n\\n        emit Vote(pool, msg.sender, amount);\\n    }\\n\\n    function unvotePercent(address pool, uint256 percent) external {\\n        require(percent <= MAX_PERCENT, \\\"Error percent\\\");\\n        uint256 balanceVeORN = IveORN(veORN).balanceOf0(msg.sender);\\n        unvote(pool, (balanceVeORN * percent) / MAX_PERCENT);\\n    }\\n\\n    function unvote(address pool, uint256 amount) public {\\n        if (usersPool[msg.sender][pool] > amount) {\\n            usersPool[msg.sender][pool] -= amount;\\n        } else {\\n            amount = usersPool[msg.sender][pool];\\n            delete usersPool[msg.sender][pool];\\n        }\\n        if (users[msg.sender] > amount) {\\n            users[msg.sender] -= amount;\\n        } else {\\n            amount = users[msg.sender];\\n            delete users[msg.sender];\\n        }\\n\\n        _unstake(pool, amount);\\n\\n        emit Unvote(pool, msg.sender, amount);\\n    }\\n\\n    //array call support\\n    function voteArr(\\n        address[] calldata pools,\\n        uint256[] calldata amounts\\n    ) external {\\n        require(pools.length == amounts.length, \\\"Pool not found\\\");\\n\\n        for (uint256 i = 0; i < pools.length; i++) vote(pools[i], amounts[i]);\\n    }\\n\\n    //user or smart caller\\n\\n    function unvoteAll(address account) external {\\n        require(\\n            msg.sender == veORN || msg.sender == account,\\n            \\\"unvoteAll: caller is not the veORN contract\\\"\\n        );\\n\\n        uint256 balanceVotes = users[account];\\n        if (balanceVotes > 0) {\\n            uint256 _countPool = countPool;\\n            for (uint256 i = 1; i <= _countPool; i++) {\\n                address pool = poolList[i];\\n                uint256 amount = usersPool[account][pool];\\n\\n                if (amount > 0) {\\n                    usersPool[account][pool] = 0;\\n                    _unstake(pool, amount);\\n\\n                    balanceVotes -= amount;\\n                    if (balanceVotes == 0) break;\\n                }\\n            }\\n            users[account] = 0;\\n\\n            emit UnvoteAll(account);\\n        }\\n    }\\n\\n    function addPool2(address pool, address farmv2) external {\\n        //\u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u043f\u0443\u043b\u0430 \u0438 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0441\u043c\u0430\u0440\u0442-\u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430 \u043d\u0430\u0433\u0440\u0430\u0434 \u0434\u043b\u044f \u043f\u0443\u043b\u043e\u0432 v2\\n        addPool(pool); //check owner\\n        IOrionFarmV2(farmv2).createSmartReward(pool);\\n    }\\n\\n    function createProposal(\\n        bytes32 name,\\n        bytes32[] memory choices,\\n        uint256 timestampFinish\\n    ) external onlyOwner {\\n        if (name == 0x0) revert EMPTY_NAME();\\n        if (choices.length > 10) revert MAX_PROPOSALS_EXCEED();\\n        if (choices.length == 0) revert EMPTY_CHOICES();\\n        if (timestampFinish <= block.timestamp) revert PROPOSAL_FINISHED();\\n\\n        Proposal storage proposal = proposals[name];\\n        if (proposal.name != 0x0) revert PROPOSAL_ALREADY_EXIST();\\n\\n        proposal.name = name;\\n        proposal.timestampFinish = timestampFinish;\\n\\n        for (uint i = 0; i < choices.length; ++i) {\\n            bytes32 choice = choices[i];\\n            if (choice == 0x0) revert EMPTY_NAME();\\n            if (!proposal.choices.add(choice)) revert DUPLICATED_CHOICES();\\n        }\\n\\n        emit ProposalCreated(name, timestampFinish, choices);\\n    }\\n\\n    function voteProposal(bytes32 name, bytes32 choice) external {\\n        Proposal storage proposal = proposals[name];\\n\\n        if (proposal.name == 0x0) revert PROPOSAL_NOT_EXIST();\\n\\n        if (proposal.timestampFinish <= block.timestamp)\\n            revert PROPOSAL_FINISHED();\\n\\n        if (!proposal.choices.contains(choice)) revert CHOICE_NOT_EXIST();\\n\\n        uint256 lockFinish = IveORN(veORN).lockTime(msg.sender);\\n        if (lockFinish < proposal.timestampFinish)\\n            revert LOCK_WILL_EXPIRE();\\n\\n        bytes32 currentChoice = userVotedChoice[msg.sender][name];\\n        if (currentChoice != bytes32(0) && currentChoice != choice) revert CANT_CHANGE_CHOICE();\\n\\n        uint256 votePower = IveORN(veORN).balanceOf0(msg.sender); // votePower != 0 due to userInfo.time_lock != 0\\n        uint256 votedAmount = voted[name][msg.sender];\\n\\n        if (votePower <= votedAmount) revert ALREADY_VOTED();\\n\\n        bytes32 id = keccak256(abi.encode(name, choice));\\n        proposalVotes[id] += votePower - votedAmount;\\n        voted[name][msg.sender] = votePower;\\n        userVotedChoice[msg.sender][name] = choice;\\n\\n        emit ProposalVoted(msg.sender, name, choice, votePower);\\n    }\\n\\n    function changeVoteProposal(\\n        bytes32 name,\\n        bytes32 previousChoice,\\n        bytes32 newChoice\\n    ) external {\\n        Proposal storage proposal = proposals[name];\\n\\n        if (proposal.name == 0x0) revert PROPOSAL_NOT_EXIST();\\n\\n        if (proposal.timestampFinish <= block.timestamp)\\n            revert PROPOSAL_FINISHED();\\n\\n        if (!proposal.choices.contains(previousChoice)) revert CHOICE_NOT_EXIST();\\n        if (!proposal.choices.contains(newChoice)) revert CHOICE_NOT_EXIST();\\n\\n        uint256 votedAmount = voted[name][msg.sender];\\n        if (votedAmount == 0) revert ZERO_PREVIOUS_VOTE();\\n\\n        uint256 votePower = IveORN(veORN).balanceOf0(msg.sender); // votePower >= votedAmount\\n\\n        bytes32 previousId = keccak256(abi.encode(name, previousChoice));\\n        proposalVotes[previousId] -= votedAmount;\\n\\n        bytes32 newId = keccak256(abi.encode(name, newChoice));\\n        proposalVotes[newId] += votePower;\\n\\n        voted[name][msg.sender] = votePower;\\n        userVotedChoice[msg.sender][name] = newChoice;\\n\\n        emit ProposalUnvoted(msg.sender, name, previousChoice, votedAmount);\\n        emit ProposalVoted(msg.sender, name, newChoice, votePower);\\n    }\\n\\n    function proposalInfo(\\n        bytes32 name\\n    )\\n        external\\n        view\\n        returns (bytes32, uint256, bytes32[] memory, uint256[] memory)\\n    {\\n        Proposal storage proposal = proposals[name];\\n        uint256 choicesLength = proposal.choices.length();\\n        uint256[] memory votes = new uint256[](choicesLength);\\n\\n        for (uint i = 0; i < choicesLength; ++i) {\\n            bytes32 id = keccak256(abi.encode(name, proposal.choices.at(i)));\\n            votes[i] = proposalVotes[id];\\n        }\\n\\n        return (\\n            name,\\n            proposal.timestampFinish,\\n            proposal.choices.values(),\\n            votes\\n        );\\n    }\\n\\n    //view\\n    function havePool(address account) external view returns (bool) {\\n        return poolIndex[account] > 0;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"veORN_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ALREADY_VOTED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CANT_CHANGE_CHOICE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CHOICE_NOT_EXIST\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DUPLICATED_CHOICES\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EMPTY_CHOICES\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EMPTY_NAME\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LOCK_WILL_EXPIRE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MAX_PROPOSALS_EXCEED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PROPOSAL_ALREADY_EXIST\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PROPOSAL_FINISHED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PROPOSAL_NOT_EXIST\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_PREVIOUS_VOTE\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardCumulativeTotal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rateCumulative\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"ClaimReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestampFinish\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"choices\",\"type\":\"bytes32[]\"}],\"name\":\"ProposalCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"choice\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votePower\",\"type\":\"uint256\"}],\"name\":\"ProposalUnvoted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"choice\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votePower\",\"type\":\"uint256\"}],\"name\":\"ProposalVoted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"rewards\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"duration\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardCumulativeTotal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rateCumulative\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"SetRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardCumulativeTotal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rateCumulative\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardCumulativeTotal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rateCumulative\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unvote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"UnvoteAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"bUse\",\"type\":\"bool\"}],\"name\":\"UsePool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Vote\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ORN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"farmv2\",\"type\":\"address\"}],\"name\":\"addPool2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calcNewRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"previousChoice\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"newChoice\",\"type\":\"bytes32\"}],\"name\":\"changeVoteProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"countPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"choices\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"timestampFinish\",\"type\":\"uint256\"}],\"name\":\"createProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"deletePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getRewardCumulative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardCumulativeAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getRewardWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"havePool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateCumulative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardWithdraw\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"proposalInfo\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"proposalVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateCumulative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"rewards\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"duration\",\"type\":\"uint64\"}],\"name\":\"setRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"bUse\",\"type\":\"bool\"}],\"name\":\"setSmart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smartOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"smarts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unvote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unvoteAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"unvotePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"userVotedChoice\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"usersPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"veORN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"voteArr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"votePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"choice\",\"type\":\"bytes32\"}],\"name\":\"voteProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"voted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "OrionVoting", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "000000000000000000000000f05f7a9f018b572aaf55e49d6cea49c3ac4bb51d000000000000000000000000857851ee6e398651cb7c72462cc7ce2a94d8f1c6", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}