{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/IPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\n/**\\n * @dev Interface for price feeds used by Comet\\n * Note This is Chainlink's AggregatorV3Interface, but without the `getRoundData` function.\\n */\\ninterface IPriceFeed {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\"\r\n    },\r\n    \"contracts/pricefeeds/ScalingPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\nimport \\\"../vendor/@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"../IPriceFeed.sol\\\";\\n\\n/**\\n * @title Scaling price feed\\n * @notice A custom price feed that scales up or down the price received from an underlying Chainlink price feed and returns the result\\n * @author Compound\\n */\\ncontract ScalingPriceFeed is IPriceFeed {\\n    /** Custom errors **/\\n    error InvalidInt256();\\n\\n    /// @notice Version of the price feed\\n    uint public constant override version = 1;\\n\\n    /// @notice Description of the price feed\\n    string public description;\\n\\n    /// @notice Number of decimals for returned prices\\n    uint8 public immutable override decimals;\\n\\n    /// @notice Underlying Chainlink price feed where prices are fetched from\\n    address public immutable underlyingPriceFeed;\\n\\n    /// @notice Whether or not the price should be upscaled\\n    bool internal immutable shouldUpscale;\\n\\n    /// @notice The amount to upscale or downscale the price by\\n    int256 internal immutable rescaleFactor;\\n\\n    /**\\n     * @notice Construct a new scaling price feed\\n     * @param underlyingPriceFeed_ The address of the underlying price feed to fetch prices from\\n     * @param decimals_ The number of decimals for the returned prices\\n     **/\\n    constructor(address underlyingPriceFeed_, uint8 decimals_) {\\n        underlyingPriceFeed = underlyingPriceFeed_;\\n        decimals = decimals_;\\n        description = AggregatorV3Interface(underlyingPriceFeed_).description();\\n\\n        uint8 chainlinkPriceFeedDecimals = AggregatorV3Interface(underlyingPriceFeed_).decimals();\\n        // Note: Solidity does not allow setting immutables in if/else statements\\n        shouldUpscale = chainlinkPriceFeedDecimals < decimals_ ? true : false;\\n        rescaleFactor = (shouldUpscale\\n            ? signed256(10 ** (decimals_ - chainlinkPriceFeedDecimals))\\n            : signed256(10 ** (chainlinkPriceFeedDecimals - decimals_))\\n        );\\n    }\\n\\n    /**\\n     * @notice Price for the latest round\\n     * @return roundId Round id from the underlying price feed\\n     * @return answer Latest price for the asset in terms of ETH\\n     * @return startedAt Timestamp when the round was started; passed on from underlying price feed\\n     * @return updatedAt Timestamp when the round was last updated; passed on from underlying price feed\\n     * @return answeredInRound Round id in which the answer was computed; passed on from underlying price feed\\n     **/\\n    function latestRoundData() override external view returns (\\n        uint80 roundId,\\n        int256 answer,\\n        uint256 startedAt,\\n        uint256 updatedAt,\\n        uint80 answeredInRound\\n    ) {\\n        (uint80 roundId_, int256 price, uint256 startedAt_, uint256 updatedAt_, uint80 answeredInRound_) = AggregatorV3Interface(underlyingPriceFeed).latestRoundData();\\n        return (roundId_, scalePrice(price), startedAt_, updatedAt_, answeredInRound_);\\n    }\\n\\n    function signed256(uint256 n) internal pure returns (int256) {\\n        if (n > uint256(type(int256).max)) revert InvalidInt256();\\n        return int256(n);\\n    }\\n\\n    function scalePrice(int256 price) internal view returns (int256) {\\n        int256 scaledPrice;\\n        if (shouldUpscale) {\\n            scaledPrice = price * rescaleFactor;\\n        } else {\\n            scaledPrice = price / rescaleFactor;\\n        }\\n        return scaledPrice;\\n    }\\n}\"\r\n    },\r\n    \"contracts/vendor/@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1,\r\n      \"details\": {\r\n        \"yulDetails\": {\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf [xa[r]scLM cCTUtTOntnfDIul Lcul Vcul [j] Tpeul xa[rul] xa[r]cL gvif CTUca[r]LsTOtfDnca[r]Iulc] jmul[jul] VcTOcul jmul\"\r\n        }\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlyingPriceFeed_\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidInt256\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingPriceFeed\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ScalingPriceFeed", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "000000000000000000000000536218f9e9eb48863970252233c8f271f554c2d00000000000000000000000000000000000000000000000000000000000000008", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}