{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface.\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(\\n        address account,\\n        bytes4[] memory interfaceIds\\n    ) internal view returns (bool[] memory) {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     *\\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\\n     * should be exercised when using this function.\\n     *\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success && returnSize >= 0x20 && returnValue > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary Errors {\\r\\n    /// Common error\\r\\n    string constant CM_CONTRACT_HAS_BEEN_INITIALIZED = \\\"CM-01\\\"; \\r\\n    string constant CM_FACTORY_ADDRESS_IS_NOT_CONFIGURED = \\\"CM-02\\\";\\r\\n    string constant CM_VICS_ADDRESS_IS_NOT_CONFIGURED = \\\"CM-03\\\";\\r\\n    string constant CM_VICS_EXCHANGE_IS_NOT_CONFIGURED = \\\"CM-04\\\";\\r\\n    string constant CM_CEX_FUND_MANAGER_IS_NOT_CONFIGURED = \\\"CM-05\\\";\\r\\n    string constant CM_TREASURY_MANAGER_IS_NOT_CONFIGURED = \\\"CM-06\\\";\\r\\n    string constant CM_CEX_DEFAULT_MASTER_ACCOUNT_IS_NOT_CONFIGURED = \\\"CM-07\\\";\\r\\n    string constant CM_ADDRESS_IS_NOT_ICEXDABOTCERTTOKEN = \\\"CM-08\\\";\\r\\n    string constant CM_INDEX_OUT_OF_RANGE = \\\"CM-09\\\";\\r\\n    string constant CM_UNAUTHORIZED_CALLER = \\\"CM-10\\\";\\r\\n    string constant CM_PROXY_ADMIN_IS_NOT_CONFIGURED = \\\"CM-11\\\";\\r\\n    \\r\\n\\r\\n    /// IBCertToken error  (Bot Certificate Token)\\r\\n    string constant BCT_CALLER_IS_NOT_OWNER = \\\"BCT-01\\\"; \\r\\n    string constant BCT_REQUIRE_ALL_TOKENS_BURNT = \\\"BCT-02\\\";\\r\\n    string constant BCT_UNLOCK_AMOUNT_EXCEEDS_TOTAL_LOCKED = \\\"BCT-03\\\";\\r\\n    string constant BCT_INSUFFICIENT_LIQUID_FOR_UNLOCKING = \\\"BCT-04a\\\";\\r\\n    string constant BCT_INSUFFICIENT_LIQUID_FOR_LOCKING = \\\"BCT-04b\\\";\\r\\n    string constant BCT_AMOUNT_EXCEEDS_TOTAL_STAKE = \\\"BCT-05\\\";\\r\\n    string constant BCT_CANNOT_MINT_TO_ZERO_ADDRESS = \\\"BCT-06\\\";\\r\\n    string constant BCT_INSUFFICIENT_LIQUID_FOR_BURN = \\\"BCT-07\\\";\\r\\n    string constant BCT_INSUFFICIENT_ACCOUNT_FUND = \\\"BCT-08\\\";\\r\\n    string constant BCT_CALLER_IS_NEITHER_BOT_NOR_CERTLOCKER = \\\"BCT-09\\\";\\r\\n    string constant BCT_VALUE_MISMATCH_ASSET_AMOUNT = \\\"BCT-10\\\";\\r\\n\\r\\n    /// IBCEXCertToken error (Cex Bot Certificate Token)\\r\\n    string constant CBCT_CALLER_IS_NOT_FUND_MANAGER = \\\"CBCT-01\\\";\\r\\n\\r\\n    /// GovernToken error (Bot Governance Token)\\r\\n    string constant BGT_CALLER_IS_NOT_OWNED_BOT = \\\"BGT-01\\\";\\r\\n    string constant BGT_CANNOT_MINT_TO_ZERO_ADDRESS = \\\"BGT-02\\\";\\r\\n    string constant BGT_CALLER_IS_NOT_GOVERNANCE = \\\"BGT-03\\\";\\r\\n\\r\\n    // VaultBase error (VB)\\r\\n    string constant VB_CALLER_IS_NOT_DABOT = \\\"VB-01a\\\";\\r\\n    string constant VB_CALLER_IS_NOT_OWNER_BOT = \\\"VB-01b\\\";\\r\\n    string constant VB_INVALID_VAULT_ID = \\\"VB-02\\\";\\r\\n    string constant VB_INVALID_VAULT_TYPE = \\\"VB-03\\\";\\r\\n    string constant VB_INVALID_SNAPSHOT_ID = \\\"VB-04\\\";\\r\\n\\r\\n    // RegularVault Error (RV)\\r\\n    string constant RV_VAULT_IS_RESTRICTED = \\\"RV-01\\\";\\r\\n    string constant RV_DEPOSIT_LOCKED = \\\"RV-02\\\";\\r\\n    string constant RV_WITHDRAWL_AMOUNT_EXCEED_DEPOSIT = \\\"RV-03\\\";\\r\\n\\r\\n    // BotVaultManager (VM)\\r\\n    string constant VM_VAULT_EXISTS = \\\"VM-01\\\";\\r\\n\\r\\n    // BotManager (BM)\\r\\n    string constant BM_DOES_NOT_SUPPORT_IDABOT = \\\"BM-01\\\";\\r\\n    string constant BM_DUPLICATED_BOT_QUALIFIED_NAME = \\\"BM-02\\\";\\r\\n    string constant BM_TEMPLATE_IS_NOT_REGISTERED = \\\"BM-03\\\";\\r\\n    string constant BM_GOVERNANCE_TOKEN_IS_NOT_DEPLOYED = \\\"BM-04\\\";\\r\\n    string constant BM_BOT_IS_NOT_REGISTERED = \\\"BM-05\\\";\\r\\n\\r\\n    // DABotModule (BMOD)\\r\\n    string constant BMOD_CALLER_IS_NOT_OWNER = \\\"BMOD-01\\\";\\r\\n    string constant BMOD_CALLER_IS_NOT_BOT_MANAGER = \\\"BMOD-02\\\";\\r\\n    string constant BMOD_BOT_IS_ABANDONED = \\\"BMOD-03\\\";\\r\\n\\r\\n    // DABotControllerLib (BCL)\\r\\n    string constant BCL_DUPLICATED_MODULE = \\\"BCL-01\\\";\\r\\n    string constant BCL_CERT_TOKEN_IS_NOT_CONFIGURED = \\\"BCL-02\\\";\\r\\n    string constant BCL_GOVERN_TOKEN_IS_NOT_CONFIGURED = \\\"BCL-03\\\";\\r\\n    string constant BCL_GOVERN_TOKEN_IS_NOT_DEPLOYED = \\\"BCL-04\\\";\\r\\n    string constant BCL_WARMUP_LOCKER_IS_NOT_CONFIGURED = \\\"BCL-05\\\";\\r\\n    string constant BCL_COOLDOWN_LOCKER_IS_NOT_CONFIGURED = \\\"BCL-06\\\";\\r\\n    string constant BCL_UKNOWN_MODULE_ID = \\\"BCL-07\\\";\\r\\n    string constant BCL_BOT_MANAGER_IS_NOT_CONFIGURED = \\\"BCL-08\\\";\\r\\n\\r\\n    // DABotController (BCMOD)\\r\\n    string constant BCMOD_CANNOT_CALL_TEMPLATE_METHOD_ON_BOT_INSTANCE = \\\"BCMOD-01\\\";\\r\\n    string constant BCMOD_CALLER_IS_NOT_OWNER = \\\"BCMOD-02\\\";\\r\\n    string constant BCMOD_MODULE_HANDLER_NOT_FOUND_FOR_METHOD_SIG = \\\"BCMOD-03\\\";\\r\\n    string constant BCMOD_NEW_OWNER_IS_ZERO = \\\"BCMOD-04\\\";\\r\\n\\r\\n    // CEXFundManagerModule (CFMOD)\\r\\n    string constant CFMOD_DUPLICATED_BENEFITCIARY = \\\"CFMOD-01\\\";\\r\\n    string constant CFMOD_INVALID_CERTIFICATE_OF_ASSET = \\\"CFMOD-02\\\";\\r\\n    string constant CFMOD_CALLER_IS_NOT_FUND_MANAGER = \\\"CFMOD-03\\\";\\r\\n\\r\\n    // DABotSettingLib (BSL)\\r\\n    string constant BSL_CALLER_IS_NOT_OWNER = \\\"BSL-01\\\";\\r\\n    string constant BSL_CALLER_IS_NOT_GOVERNANCE_EXECUTOR = \\\"BSL-02\\\";\\r\\n    string constant BSL_IBO_ENDTIME_IS_SOONER_THAN_IBO_STARTTIME = \\\"BSL-03\\\";\\r\\n    string constant BSL_BOT_IS_ABANDONED = \\\"BSL-04\\\";\\r\\n\\r\\n    // DABotSettingModule (BSMOD)\\r\\n    string constant BSMOD_IBO_ENDTIME_IS_SOONER_THAN_IBO_STARTTIME =  \\\"BSMOD-01\\\";\\r\\n    string constant BSMOD_INIT_DEPOSIT_IS_LESS_THAN_CONFIGURED_THRESHOLD = \\\"BSMOD-02\\\";\\r\\n    string constant BSMOD_FOUNDER_SHARE_IS_ZERO = \\\"BSMOD-03\\\";\\r\\n    string constant BSMOD_INSUFFICIENT_MAX_SHARE = \\\"BSMOD-04\\\";\\r\\n    string constant BSMOD_FOUNDER_SHARE_IS_GREATER_THAN_IBO_SHARE = \\\"BSMOD-05\\\";\\r\\n\\r\\n    // DABotCertLocker (LOCKER)\\r\\n    string constant LOCKER_CALLER_IS_NOT_OWNER_BOT = \\\"LOCKER-01\\\";\\r\\n\\r\\n    // DABotStakingModule (BSTMOD)\\r\\n    string constant BSTMOD_PRE_IBO_REQUIRED = \\\"BSTMOD-01\\\";\\r\\n    string constant BSTMOD_AFTER_IBO_REQUIRED = \\\"BSTMOD-02\\\";\\r\\n    string constant BSTMOD_INVALID_PORTFOLIO_ASSET = \\\"BSTMOD-03\\\";\\r\\n    string constant BSTMOD_PORTFOLIO_FULL = \\\"BSTMOD-04\\\";\\r\\n    string constant BSTMOD_INVALID_CERTIFICATE_ASSET = \\\"BSTMOD-05\\\";\\r\\n    string constant BSTMOD_PORTFOLIO_ASSET_NOT_FOUND = \\\"BSTMOD-06\\\";\\r\\n    string constant BSTMOD_ASSET_IS_ZERO = \\\"BSTMOD-07\\\";\\r\\n    string constant BSTMOD_INVALID_STAKING_CAP = \\\"BSTMOD-08\\\";\\r\\n    string constant BSTMOD_INSUFFICIENT_FUND = \\\"BSTMOD-09\\\";\\r\\n    string constant BSTMOD_CAP_IS_ZERO = \\\"BSTMOD-10\\\";\\r\\n    string constant BSTMOD_CAP_IS_LESS_THAN_STAKED_AND_IBO_CAP = \\\"BSTMOD-11\\\";\\r\\n    string constant BSTMOD_WERIGHT_IS_ZERO = \\\"BSTMOD-12\\\";\\r\\n\\r\\n    // CEX FundManager (CFM)\\r\\n    string constant CFM_REQ_TYPE_IS_MISMATCHED = \\\"CFM-01\\\";\\r\\n    string constant CFM_INVALID_REQUEST_ID = \\\"CFM-02\\\";\\r\\n    string constant CFM_CALLER_IS_NOT_BOT_TOKEN = \\\"CFM-03\\\";\\r\\n    string constant CFM_CLOSE_TYPE_VALUE_IS_NOT_SUPPORTED = \\\"CFM-04\\\";\\r\\n    string constant CFM_UNKNOWN_REQUEST_TYPE = \\\"CFM-05\\\";\\r\\n    string constant CFM_CALLER_IS_NOT_REQUESTER = \\\"CFM-06\\\";\\r\\n    string constant CFM_CALLER_IS_NOT_APPROVER = \\\"CFM-07\\\";\\r\\n    string constant CFM_CEX_CERTIFICATE_IS_REQUIRED = \\\"CFM-08\\\";\\r\\n    string constant CFM_TREASURY_ASSET_CERTIFICATE_IS_REQUIRED = \\\"CFM-09\\\";\\r\\n    string constant CFM_FAIL_TO_TRANSFER_VALUE = \\\"CFM-10\\\";\\r\\n    string constant CFM_AWARDED_ASSET_IS_NOT_TREASURY = \\\"CFM-11\\\";\\r\\n    string constant CFM_INSUFFIENT_ASSET_TO_MINT_STOKEN = \\\"CFM-12\\\";\\r\\n\\r\\n    // FarmBot Module (FBM)  string constant FBM_ = \\\"FBM-\\\";\\r\\n    string constant FBM_CANNOT_REMOVE_WORKER = \\\"FBM-01\\\";\\r\\n    string constant FBM_NULL_OPERATOR_ACCOUNT = \\\"FBM-02\\\";\\r\\n    string constant FBM_INVALID_WORKER = \\\"FBM-03\\\";\\r\\n    string constant FBM_REPAY_ERROR = \\\"FBM-04\\\";\\r\\n    string constant FBM_INVALID_SWAP_ADAPTER = \\\"FBM-05\\\";\\r\\n    string constant FBM_INVALID_SWAP_PATH = \\\"FBM-06\\\";\\r\\n    string constant FBM_INSUFFICIENT_FUND = \\\"FBM-07\\\";\\r\\n\\r\\n    // TreasuryAsset (TA)\\r\\n    string constant TA_MINT_ZERO_AMOUNT = \\\"TA-01\\\";\\r\\n    string constant TA_LOCK_AMOUNT_EXCEED_BALANCE = \\\"TA-02\\\";\\r\\n    string constant TA_UNLOCK_AMOUNT_AND_PASSED_VALUE_IS_MISMATCHED = \\\"TA-03\\\";\\r\\n    string constant TA_AMOUNT_EXCEED_AVAILABLE_BALANCE = \\\"TA-04\\\";\\r\\n    string constant TA_AMOUNT_EXCEED_VALUE_BALANCE = \\\"TA-05\\\";\\r\\n    string constant TA_FUND_MANAGER_IS_NOT_SET = \\\"TA-06\\\";\\r\\n    string constant TA_FAIL_TO_TRANSFER_VALUE = \\\"TA-07\\\";\\r\\n\\r\\n    // Governance (GOV)\\r\\n    string constant GOV_DEFAULT_STRATEGY_IS_NOT_SET = \\\"GOV-01\\\";\\r\\n    string constant GOV_INSUFFICIENT_POWER_TO_CREATE_PROPOSAL = \\\"GOV-02\\\";\\r\\n    string constant GOV_INSUFFICIENT_VICS_TO_CREATE_PROPOSAL = \\\"GOV-03\\\";\\r\\n    string constant GOV_INVALID_PROPOSAL_ID = \\\"GOV-04\\\";\\r\\n    string constant GOV_REQUIRED_PROPOSER_OR_GUARDIAN = \\\"GOV-05\\\";\\r\\n    string constant GOV_TARGET_SHOULD_BE_ZERO_OR_REGISTERED_BOT = \\\"GOV-06\\\";\\r\\n    string constant GOV_INSUFFICIENT_POWER_TO_VOTE = \\\"GOV-07\\\";\\r\\n    string constant GOV_INVALID_NEW_STATE = \\\"GOV-08\\\";\\r\\n    string constant GOV_CANNOT_CHANGE_STATE_OF_CLOSED_PROPOSAL = \\\"GOV-08\\\";\\r\\n    string constant GOV_INVALID_CREATION_DATA = \\\"GOV-09\\\";\\r\\n    string constant GOV_CANNOT_CHANGE_STATE_OF_ON_CHAIN_PROPOSAL = \\\"GOV-10\\\";\\r\\n    string constant GOV_PROPOSAL_DONT_ACCEPT_VOTE = \\\"GOV-11\\\";\\r\\n    string constant GOV_DUPLICATED_VOTE = \\\"GOV-12\\\";\\r\\n    string constant GOV_CAN_ONLY_QUEUE_PASSED_PROPOSAL = \\\"GOV-13\\\";\\r\\n    string constant GOV_DUPLICATED_ACTION = \\\"GOV-14\\\";\\r\\n    string constant GOV_INVALID_VICS_ADDRESS = \\\"GOV-15\\\";\\r\\n\\r\\n    // Timelock Executor (TLE)\\r\\n    string constant TLE_DELAY_SHORTER_THAN_MINIMUM = \\\"TLE-01\\\";\\r\\n    string constant TLE_DELAY_LONGER_THAN_MAXIMUM = \\\"TLE-02\\\";\\r\\n    string constant TLE_ONLY_BY_ADMIN = \\\"TLE-03\\\";\\r\\n    string constant TLE_ONLY_BY_PENDING_ADMIN = \\\"TLE-04\\\";\\r\\n    string constant TLE_ONLY_BY_THIS_TIMELOCK = \\\"TLE-05\\\";\\r\\n    string constant TLE_EXECUTION_TIME_UNDERESTIMATED = \\\"TLE-06\\\";\\r\\n    string constant TLE_ACTION_NOT_QUEUED = \\\"TLE-07\\\";\\r\\n    string constant TLE_TIMELOCK_NOT_FINISHED = \\\"TLE-08\\\";\\r\\n    string constant TLE_GRACE_PERIOD_FINISHED = \\\"TLE-09\\\";\\r\\n    string constant TLE_NOT_ENOUGH_MSG_VALUE = \\\"TLE-10\\\";\\r\\n\\r\\n    // DABotVoteStrategy (BVS) string constant BVS_ = \\\"BVS-\\\";\\r\\n    string constant BVS_NOT_A_REGISTERED_DABOT = \\\"BVS-01\\\";\\r\\n\\r\\n    // DABotWhiteList (BWL) string constant BWL_ = \\\"BWL-\\\";\\r\\n    string constant BWL_ACCOUNT_IS_ZERO = \\\"BWL-01\\\";\\r\\n    string constant BWL_ACCOUNT_IS_NOT_WHITELISTED = \\\"BWL-02\\\";\\r\\n\\r\\n    // Marginal Lending Worker string constant MLF_ = \\\"MLF-\\\";\\r\\n    string constant MLF_ZERO_DEPOSIT = \\\"MLF-01\\\";\\r\\n    string constant MLF_UNKNOWN_CONFIG_TOPIC = \\\"MLF-02\\\";\\r\\n    string constant MLF_REGISTERED_COLLATERAL_ID_EXPECTED = \\\"MLF-03\\\";\\r\\n    string constant MLF_CONFIG_TOPICS_AND_VALUES_MISMATCHED = \\\"MLF-04\\\";\\r\\n    string constant MLF_ADAPTER_IS_NOT_CONFIGURED = \\\"MLF-05\\\";\\r\\n    string constant MLF_CANNOT_REMOVE_IN_USED_COLLATERAL = \\\"MLF-06\\\";\\r\\n    string constant MLF_CANNOT_CHANGE_LENDING_ADAPTER = \\\"MLF-07\\\";\\r\\n    string constant MLF_INVALID_PLATFORM_TOKEN = \\\"MLF-08\\\";\\r\\n    string constant MLF_CANNOT_CHANGE_IN_USED_LEVERAGE_ASSET = \\\"MLF-09\\\";\\r\\n    string constant MLF_INVALID_EXPECTED_HEALTH_FACTOR = \\\"MLF-10\\\";\\r\\n    string constant MLF_LEVERAGE_ASSET_IS_NOT_SET = \\\"MLF-11\\\";\\r\\n    string constant MLF_INVALID_PRECISION = \\\"MLF-12\\\";\\r\\n    string constant MLF_INTERNAL_ERROR = \\\"MLF-13\\\";\\r\\n\\r\\n    // FarmCertTokenModule (FTM) string constant FTM_ = \\\"FTM-\\\";\\r\\n    string constant FTM_INSUFFICICIENT_AMOUNT_TO_DEPOSIT = \\\"FTM-01\\\";\\r\\n\\r\\n    // ILendingAdapter (ILA) string constant ILA_ = \\\"ILA-\\\";\\r\\n    string constant ILA_INVALID_EXPECTED_HEALTH_FACTOR = \\\"ILA-01\\\";\\r\\n    string constant ILA_DEPOSIT_FAILED = \\\"ILA-02\\\";\\r\\n    string constant ILA_WITHDRAW_FAILED = \\\"ILA-03\\\";\\r\\n    string constant ILA_BORROW_FAILED = \\\"ILA-04\\\";\\r\\n    string constant ILA_REPAY_BORROW_FAILED = \\\"ILA-05\\\";\\r\\n\\r\\n    // RoboFi game string constant RFG_ = \\\"RFG-\\\";\\r\\n    string constant RFG_CALLER_IS_NOT_REGISTERED_BOT = \\\"RFG-01\\\";\\r\\n    string constant RFG_CALLER_IS_NOT_BOT_OWNER = \\\"RFG-02\\\";\\r\\n    string constant RFG_CALLER_IS_NOT_VAULT = \\\"RFG-03\\\";\\r\\n    string constant RFG_ROUND_NOT_FINISHED = \\\"RFG-04\\\";\\r\\n    string constant RFG_ROUND_NOT_IN_COMMIT_PHASE = \\\"RFG-05\\\";\\r\\n    string constant RFG_ROUND_NOT_IN_REVEAL_PHASE = \\\"RFG-06\\\";\\r\\n    string constant RFG_ROUND_NOT_READY_CLOSE = \\\"RFG-07\\\";\\r\\n    string constant RFG_ROUND_NOT_CLOSED_YET = \\\"RFG-08\\\";\\r\\n    string constant RFG_INVALID_SECRET_NUMBER = \\\"RFG-09\\\";\\r\\n    string constant RFG_WINNER_IS_REQUIRE = \\\"RFG-10\\\";\\r\\n    string constant RFG_INVALID_SUBMIT_WINNERS = \\\"RFG-11\\\";\\r\\n    string constant RFG_INVALID_NUMBER_OF_WINNERS = \\\"RFG-12\\\";\\r\\n    string constant RFG_INVALID_WON_NUMBER = \\\"RFG-13\\\";\\r\\n    string constant RFG_INVALID_VICS_ADDRESS = \\\"RFG-14\\\";\\r\\n    string constant RFG_INVALID_COMMIT_DURATION = \\\"RFG-15\\\";\\r\\n    string constant RFG_INVALID_REVEAL_DURATION = \\\"RFG-16\\\";\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/common/IConfigurator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\nlibrary Roles {\\r\\n    bytes32 constant ROLE_ADMIN = keccak256('operator.dabot.role');\\r\\n    bytes32 constant ROLE_OPERATORS = keccak256('operator.dabot.role');\\r\\n    bytes32 constant ROLE_TEMPLATE_CREATOR = keccak256('creator.template.dabot.role');\\r\\n    bytes32 constant ROLE_BOT_CREATOR = keccak256('creator.dabot.role');\\r\\n    bytes32 constant ROLE_FUND_APPROVER = keccak256('approver.fund.role');\\r\\n}\\r\\n\\r\\nlibrary AddressBook {\\r\\n    bytes32 constant ADDR_FACTORY = keccak256('factory.address');\\r\\n    bytes32 constant ADDR_VICS = keccak256('vics.address');\\r\\n    bytes32 constant ADDR_TAX = keccak256('tax.address');\\r\\n    bytes32 constant ADDR_GOVERNANCE = keccak256('governance.address');\\r\\n    bytes32 constant ADDR_GOVERNANCE_EXECUTOR = keccak256('executor.governance.address');\\r\\n    bytes32 constant ADDR_BOT_MANAGER = keccak256('botmanager.address');\\r\\n    bytes32 constant ADDR_VICS_EXCHANGE = keccak256('exchange.vics.address');\\r\\n    bytes32 constant ADDR_TREASURY_MANAGER = keccak256('treasury-manager.address');\\r\\n    bytes32 constant ADDR_CEX_FUND_MANAGER = keccak256('fund-manager.address');\\r\\n    bytes32 constant ADDR_CEX_DEFAULT_MASTER_ACCOUNT = keccak256('default.master.address');\\r\\n    bytes32 constant ADDR_ROBOFI_GAME = keccak256('robofi-game.address');\\r\\n}\\r\\n\\r\\nlibrary Config {\\r\\n    /// The amount of VICS that a proposer has to pay when create a new proposal\\r\\n    bytes32 constant PROPOSAL_DEPOSIT = keccak256('deposit.proposal.config');\\r\\n\\r\\n    /// The percentage of proposal creation fee distributed to the account that execute a propsal\\r\\n    bytes32 constant PROPOSAL_REWARD_PERCENT = keccak256('reward.proposal.config');\\r\\n\\r\\n    /// The minimum VICS a bot creator has to deposit to a newly created bot\\r\\n    bytes32 constant CREATOR_DEPOSIT = keccak256('deposit.creator.config');\\r\\n\\r\\n    /// The minim \\r\\n    bytes32 constant PROPOSAL_CREATOR_MININUM_POWER = keccak256('minpower.goverance.config');\\r\\n    \\r\\n    /// The minimum percentage of for-votes over total votes a proposal has to achieve to be passed\\r\\n    bytes32 constant PROPOSAL_MINIMUM_QUORUM = keccak256('minquorum.governance.config');\\r\\n\\r\\n    /// The minimum difference (in percentage) between for-votes and against-vote for a proposal to be passed\\r\\n    bytes32 constant PROPOSAL_VOTE_DIFFERENTIAL = keccak256('differential.governance.config');\\r\\n\\r\\n    /// The voting duration of a proposal\\r\\n    bytes32 constant PROPOSAL_DURATION = keccak256('duration.goverance.config');\\r\\n\\r\\n    /// The interval that a passed proposed is waiting in queue before being executed\\r\\n    bytes32 constant PROPOSAL_EXECUTION_DELAY = keccak256('execdelay.governance.config');\\r\\n\\r\\n    // Number of winners of RoboFi Game\\r\\n    bytes32 constant GAME_NUMBER_WINNER = keccak256('num-of-winner.game.config');\\r\\n\\r\\n    // The commit phase duration of a game\\r\\n    bytes32 constant GAME_COMMIT_DURATION = keccak256('commit.game.config');\\r\\n\\r\\n    // The reveal phase duration of a game\\r\\n    bytes32 constant GAME_REVEAL_DURATION = keccak256('reveal.game.config');\\r\\n}\\r\\n\\r\\ninterface IConfigurator {\\r\\n    function addressOf(bytes32 addrId) external view returns(address);\\r\\n    function configOf(bytes32 configId) external view returns(uint);\\r\\n    function bytesConfigOf(bytes32 configId) external view returns(bytes memory);\\r\\n\\r\\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\\r\\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\\r\\n\\r\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\r\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\r\\n    function grantRole(bytes32 role, address account) external;\\r\\n    function revokeRole(bytes32 role, address account) external;\\r\\n    function renounceRole(bytes32 role, address account) external;\\r\\n\\r\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\r\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\r\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\r\\n}\\r\\n\\r\\n\"\r\n    },\r\n    \"contracts/common/IRoboFiFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IRoboFiFactory {\\r\\n    function deploy(address masterContract, \\r\\n                    bytes calldata data, \\r\\n                    bool useCreate2) \\r\\n        external \\r\\n        payable \\r\\n        returns(address);\\r\\n}\\r\\n\\r\\n\"\r\n    },\r\n    \"contracts/common/RoboFiAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\r\\nimport \\\"../treasury/ITreasuryAsset.sol\\\";\\r\\nimport \\\"../dabot/interfaces/IDABotCertToken.sol\\\";\\r\\nimport \\\"../dabot/interfaces/IDABotGovernToken.sol\\\";\\r\\n\\r\\nlibrary RoboFiAddress {\\r\\n\\r\\n    using ERC165Checker for address;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    function isTreasuryAsset(address account) internal view returns(bool) {\\r\\n        return account.supportsInterface(type(ITreasuryAsset).interfaceId);\\r\\n    } \\r\\n\\r\\n    function isCertToken(address account) internal view returns(bool) {\\r\\n        bool res = account.supportsInterface(type(IDABotCertToken).interfaceId);\\r\\n        if (res)\\r\\n            return true;\\r\\n        (bool success, bytes memory result) = \\r\\n            account.staticcall(abi.encodeWithSelector(IDABotCertToken.isCertToken.selector));\\r\\n        if (!success)\\r\\n            return false;\\r\\n        (res) = abi.decode(result, (bool));\\r\\n        return res;\\r\\n    }\\r\\n\\r\\n    function isGovernToken(address account) internal view returns(bool) {\\r\\n        bool res = account.supportsInterface(type(IDABotGovernToken).interfaceId);\\r\\n        if (res)\\r\\n            return true;\\r\\n        (bool success, bytes memory result) = \\r\\n            account.staticcall(abi.encodeWithSelector(IDABotGovernToken.isGovernToken.selector));\\r\\n        if (!success)\\r\\n            return false;\\r\\n        (res) = abi.decode(result, (bool));\\r\\n        return res;\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 asset, address from, address to, uint amount) internal {\\r\\n        if (isNativeAsset(address(asset))) {\\r\\n            // cannot do this\\r\\n        } else {\\r\\n            asset.safeTransferFrom(from, to, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function safeTransfer(IERC20 asset, address to, uint amount) internal {\\r\\n        if (isNativeAsset(address(asset))) {\\r\\n            payable(to).transfer(amount);\\r\\n        } else {\\r\\n            asset.safeTransfer(to, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isNativeAsset(address asset) internal pure returns(bool) {\\r\\n        return asset == NATIVE_ASSET_ADDRESS;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/controller/DABotControllerLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\r\\nimport \\\"../../common/Errors.sol\\\";\\r\\nimport \\\"../interfaces/IBotTemplateController.sol\\\";\\r\\nimport \\\"../interfaces/IDABotGovernToken.sol\\\";\\r\\nimport \\\"../interfaces/IDABotManager.sol\\\";\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\n\\r\\nstruct BotTemplateController {\\r\\n    mapping(bytes4 => bytes32) selectors;\\r\\n    mapping(bytes32 => address) moduleAddresses;\\r\\n    bytes32[] modules;\\r\\n}\\r\\n\\r\\nstruct BotCoreData {\\r\\n    BotTemplateController controller;\\r\\n    BotMetaData metadata;\\r\\n    BotSetting setting;\\r\\n}\\r\\n\\r\\nlibrary DABotTemplateControllerLib {\\r\\n\\r\\n    using DABotTemplateControllerLib for BotTemplateController;\\r\\n\\r\\n    bytes32 constant CORE_STORAGE_POSITION = keccak256(\\\"core.dabot.storage\\\");\\r\\n\\r\\n    function coredata() internal pure returns(BotCoreData storage ds) {\\r\\n        bytes32 position = CORE_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function controller() internal view returns (BotTemplateController storage) {\\r\\n        return coredata().controller;\\r\\n    }\\r\\n\\r\\n    function requireNewModule(bytes32 moduleId) internal view {\\r\\n        BotTemplateController storage ds = controller();\\r\\n        require(ds.module(moduleId) == address(0), Errors.BCL_DUPLICATED_MODULE);\\r\\n    }\\r\\n\\r\\n    function module(BotTemplateController storage ds, bytes32 moduleId) internal view returns(address) {\\r\\n        return ds.moduleAddresses[moduleId];\\r\\n    }\\r\\n\\r\\n    function moduleOfSelector(BotTemplateController storage ds, bytes4 selector) internal view returns(address) {\\r\\n        bytes32 moduleId = ds.selectors[selector];\\r\\n        return ds.moduleAddresses[moduleId];\\r\\n    }\\r\\n\\r\\n    function registerModule(BotTemplateController storage ds, bytes32 moduleId, address moduleAddress) internal returns(address oldModuleAddress) {\\r\\n        oldModuleAddress = ds.moduleAddresses[moduleId];\\r\\n        ds.moduleAddresses[moduleId] = moduleAddress;\\r\\n    }\\r\\n\\r\\n    function registerSelectors(BotTemplateController storage ds, bytes32 moduleId, bytes4[] memory selectors) internal {\\r\\n        for(uint i = 0; i < selectors.length; i++)\\r\\n            ds.selectors[selectors[i]] = moduleId;\\r\\n    }\\r\\n\\r\\n    \\r\\n}\\r\\n\\r\\nlibrary DABotMetaLib {\\r\\n\\r\\n    using DABotMetaLib for BotMetaData;\\r\\n    using DABotTemplateControllerLib for BotTemplateController;\\r\\n\\r\\n    bytes32 constant CORE_STORAGE_POSITION = keccak256(\\\"core.dabot.storage\\\");\\r\\n\\r\\n    function coredata() internal pure returns(BotCoreData storage ds) {\\r\\n        bytes32 position = CORE_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function metadata() internal view returns (BotMetaData storage) {\\r\\n        return coredata().metadata;\\r\\n    }\\r\\n\\r\\n    function manager(BotMetaData storage ds) internal view returns(IDABotManager _manager) {\\r\\n        _manager = IDABotManager(ds.botManager);\\r\\n        require(address(_manager) != address(0), Errors.BCL_BOT_MANAGER_IS_NOT_CONFIGURED);\\r\\n    }\\r\\n\\r\\n    function configurator(BotMetaData storage ds) internal view returns(IConfigurator _config) {\\r\\n        _config = ds.manager().configurator();\\r\\n    }\\r\\n\\r\\n    function factory(BotMetaData storage ds) internal view returns(IRoboFiFactory _factory) {\\r\\n        IConfigurator config = ds.configurator();\\r\\n        _factory = IRoboFiFactory(config.addressOf(AddressBook.ADDR_FACTORY));\\r\\n        require(address(_factory) != address(0), Errors.CM_FACTORY_ADDRESS_IS_NOT_CONFIGURED);\\r\\n    }\\r\\n\\r\\n    function governToken(BotMetaData storage ds) internal view returns(IDABotGovernToken) {\\r\\n        address gToken = ds.gToken;\\r\\n        require(gToken != address(0), Errors.BCL_GOVERN_TOKEN_IS_NOT_DEPLOYED);\\r\\n        return IDABotGovernToken(gToken);\\r\\n    }\\r\\n\\r\\n    function module(BotMetaData storage ds, bytes32 moduleId) internal view returns(address) {\\r\\n        if (ds.botTemplate == address(0)) {\\r\\n            return DABotTemplateControllerLib.controller().module(moduleId);\\r\\n        }\\r\\n        return IBotTemplateController(ds.botTemplate).module(moduleId);\\r\\n    }\\r\\n\\r\\n    function deployCertToken(BotMetaData storage ds, address asset) internal returns(address) {\\r\\n        address certTokenMaster = ds.module(BOT_CERT_TOKEN_TEMPLATE_ID);\\r\\n        if (certTokenMaster == address(0)) {\\r\\n            revert(string(abi.encodePacked(\\r\\n                Errors.BCL_CERT_TOKEN_IS_NOT_CONFIGURED, \\r\\n                '. template: ', \\r\\n                Strings.toHexString(uint160(ds.botTemplate), 20)\\r\\n                )));\\r\\n        }\\r\\n        require(certTokenMaster != address(0), Errors.BCL_CERT_TOKEN_IS_NOT_CONFIGURED);\\r\\n\\r\\n        return ds.factory().deploy(\\r\\n            certTokenMaster,\\r\\n            abi.encode(address(this), asset),\\r\\n            false\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function deployGovernanceToken(BotMetaData storage ds) internal returns(address) {\\r\\n        address governTokenMaster = ds.module(BOT_GOV_TOKEN_TEMPLATE_ID);\\r\\n        require(governTokenMaster != address(0), Errors.BCL_GOVERN_TOKEN_IS_NOT_CONFIGURED);\\r\\n\\r\\n        return ds.factory().deploy(\\r\\n            governTokenMaster,\\r\\n            abi.encode(address(this)),\\r\\n            false\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function deployLocker(BotMetaData storage ds, bytes32 lockerType, LockerData memory data) internal returns(address) {\\r\\n        address lockerMaster = ds.module(lockerType);\\r\\n        if (lockerMaster == address(0)) {\\r\\n            if (lockerType == BOT_CERT_TOKEN_COOLDOWN_HANDLER_ID) \\r\\n                revert(Errors.BCL_COOLDOWN_LOCKER_IS_NOT_CONFIGURED);\\r\\n            revert(Errors.BCL_UKNOWN_MODULE_ID);\\r\\n        }\\r\\n        return ds.factory().deploy(\\r\\n            lockerMaster,\\r\\n            abi.encode(data),\\r\\n            false\\r\\n        );\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/DABotCommon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\r\\n\\r\\nimport \\\"./interfaces/IDABotComponent.sol\\\";\\r\\n\\r\\nenum BotStatus { PRE_IBO, IN_IBO, ACTIVE, ABANDONED }\\r\\n\\r\\nstruct BotModuleInitData {\\r\\n    bytes32 moduleId;\\r\\n    bytes data;\\r\\n}\\r\\n\\r\\nstruct BotSetting {             // for saving storage, the meta-fields of a bot are encoded into a single uint256 byte slot.\\r\\n    uint64 iboTime;             // 32 bit low: iboStartTime (unix timestamp), \\r\\n                                // 32 bit high: iboEndTime (unix timestamp)\\r\\n    uint24 stakingTime;         // 8 bit low: warm-up time, \\r\\n                                // 8 bit mid: cool-down time\\r\\n                                // 8 bit high: time unit (0 - day, 1 - hour, 2 - minute, 3 - second)\\r\\n    uint32 pricePolicy;         // 16 bit low: price multiplier (fixed point, 2 digits for decimal)\\r\\n                                // 16 bit high: commission fee in percentage (fixed point, 2 digit for decimal)\\r\\n    uint128 profitSharing;      // packed of 16bit profit sharing: bot-creator, gov-user, stake-user, and robofi-game\\r\\n    uint initDeposit;           // the intial deposit (in VICS) of bot-creator\\r\\n    uint initFounderShare;      // the intial shares (i.e., governance token) distributed to bot-creator\\r\\n    uint maxShare;              // max cap of gtoken supply\\r\\n    uint iboShare;              // max supply of gtoken for IBO. Constraint: maxShare >= iboShare + initFounderShare\\r\\n}\\r\\n\\r\\nstruct BotMetaData {\\r\\n    string name;\\r\\n    string symbol;\\r\\n    string version;\\r\\n    uint8 botType;\\r\\n    bool abandoned;\\r\\n    bool isTemplate;        // determine this module is a template, not a bot instance\\r\\n    bool initialized;       // determines whether the bot has been initialized \\r\\n    address botOwner;       // the public address of the bot owner\\r\\n    address botManager;\\r\\n    address botTemplate;    // address of the template contract \\r\\n    address gToken;         // address of the governance token\\r\\n}\\r\\n\\r\\nstruct BotDetail { // represents a detail information of a bot, merely use for bot infomation query\\r\\n    uint id;                    // the unique id of a bot within its manager.\\r\\n                                // note: this id only has value when calling {DABotManager.queryBots}\\r\\n    address botAddress;         // the contract address of the bot.\\r\\n\\r\\n    BotStatus status;           // 0 - PreIBO, 1 - InIBO, 2 - Active, 3 - Abandonned\\r\\n    uint8 botType;              // type of the bot (inherits from the bot's template)\\r\\n    string botSymbol;           // get the bot name.\\r\\n    string botName;             // get the bot full name.\\r\\n    address governToken;        // the address of the governance token\\r\\n    address template;           // the address of the master contract which defines the behaviors of this bot.\\r\\n    string templateName;        // the template name.\\r\\n    string templateVersion;     // the template version.\\r\\n    uint iboStartTime;          // the time when IBO starts (unix second timestamp)\\r\\n    uint iboEndTime;            // the time when IBO ends (unix second timestamp)\\r\\n    uint warmup;                // the duration (in days) for which the staking profit starts counting\\r\\n    uint cooldown;              // the duration (in days) for which users could claim back their stake after submiting the redeem request.\\r\\n    uint priceMul;              // the price multiplier to calculate the price per gtoken (based on the IBO price).\\r\\n    uint commissionFee;         // the commission fee when buying gtoken after IBO time.\\r\\n    uint initDeposit;           \\r\\n    uint initFounderShare;\\r\\n    uint144 profitSharing;\\r\\n    uint maxShare;              // max supply of governance token.\\r\\n    uint circulatedShare;       // the current supply of governance token.\\r\\n    uint iboShare;              // the max supply of gtoken for IBO.\\r\\n    uint userShare;             // the amount of governance token in the caller's balance.\\r\\n    UserPortfolioAsset[] portfolio;\\r\\n}\\r\\n\\r\\nstruct BotModuleInfo {\\r\\n    string name;\\r\\n    string version;\\r\\n    address handler;\\r\\n}\\r\\n\\r\\nstruct PortfolioCreationData {\\r\\n    address asset;\\r\\n    uint256 cap;            // the maximum stake amount for this asset (bot-lifetime).\\r\\n    uint256 iboCap;         // the maximum stake amount for this asset within the IBO.\\r\\n    uint256 weight;         // preference weight for this asset. Use to calculate the max purchasable amount of governance tokens.\\r\\n}\\r\\n\\r\\nstruct PortfolioAsset {\\r\\n    address certToken;    // the certificate asset to return to stake-users\\r\\n    uint256 cap;            // the maximum stake amount for this asset (bot-lifetime).\\r\\n    uint256 iboCap;         // the maximum stake amount for this asset within the IBO.\\r\\n    uint256 weight;         // preference weight for this asset. Use to calculate the max purchasable amount of governance tokens.\\r\\n}\\r\\n\\r\\nstruct UserPortfolioAsset {\\r\\n    address asset;\\r\\n    PortfolioAsset info;\\r\\n    uint256 userStake;\\r\\n    uint256 totalStake;     // the total stake of all users.\\r\\n    uint256 certSupply;     // the total supply of the certificated token\\r\\n}\\r\\n\\r\\n/**\\r\\n@dev Records warming-up certificate tokens of a DABot.\\r\\n*/\\r\\nstruct LockerData {         \\r\\n    address bot;            // the DABOT which creates this locker.\\r\\n    address owner;          // the locker owner, who is albe to unlock and get tokens after the specified release time.\\r\\n    address token;          // the contract of the certificate token.\\r\\n    uint64 created_at;      // the moment when locker is created.\\r\\n    uint64 release_at;      // the monent when locker could be unlock. \\r\\n}\\r\\n\\r\\n/**\\r\\n@dev Provides detail information of a warming-up token lock, plus extra information.\\r\\n    */\\r\\nstruct LockerInfo {\\r\\n    address locker;\\r\\n    LockerData info;\\r\\n    uint256 amount;         // the locked amount of cert token within this locker.\\r\\n    uint256 reward;         // the accumulated rewards\\r\\n    address asset;          // the stake asset beyond the certificated token\\r\\n}\\r\\n\\r\\nstruct MintableShareDetail {\\r\\n    address asset;\\r\\n    uint stakeAmount;\\r\\n    uint mintableShare;\\r\\n    uint weight;\\r\\n    uint iboCap;\\r\\n}\\r\\n\\r\\nstruct AwardingDetail {\\r\\n    address asset;\\r\\n    uint compound;\\r\\n    uint reward;\\r\\n    uint compoundMode;  // 0 - increase, 1 - decrrease\\r\\n}\\r\\n\\r\\nstruct StakingReward {\\r\\n    address asset;\\r\\n    uint amount;\\r\\n}\\r\\n\\r\\nstruct BenefitciaryInfo {\\r\\n    address account;\\r\\n    string name;\\r\\n    string shortName;\\r\\n    uint weight;\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/DABotModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\r\\nimport \\\"../common/Errors.sol\\\";\\r\\nimport \\\"./DABotCommon.sol\\\";\\r\\nimport \\\"./interfaces/IDABotModule.sol\\\";\\r\\nimport \\\"./whitelist/DABotWhitelistLib.sol\\\";\\r\\nimport \\\"./controller/DABotControllerLib.sol\\\";\\r\\n\\r\\nabstract contract DABotModule is IDABotModule, Context {\\r\\n\\r\\n    using DABotMetaLib for BotMetaData;\\r\\n    using DABotTemplateControllerLib for BotTemplateController;\\r\\n\\r\\n    \\r\\n\\r\\n    modifier onlyTemplateAdmin() {\\r\\n        BotMetaData storage ds = DABotMetaLib.metadata();\\r\\n        require(ds.isTemplate && (ds.botOwner == _msgSender()), \\r\\n            \\\"BotModule: caller is not template admin\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyBotOwner() {\\r\\n        BotMetaData storage ds = DABotMetaLib.metadata();\\r\\n        require(!ds.isTemplate && (!ds.initialized || ds.botOwner == _msgSender()), Errors.BMOD_CALLER_IS_NOT_OWNER);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyBotManager() {\\r\\n        BotMetaData storage ds = DABotMetaLib.metadata();\\r\\n        require(!ds.initialized || ds.botManager == _msgSender(), Errors.BMOD_CALLER_IS_NOT_BOT_MANAGER);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier activeBot() {\\r\\n        BotMetaData storage ds = DABotMetaLib.metadata();\\r\\n        require(!ds.abandoned, Errors.BMOD_BOT_IS_ABANDONED);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier whitelistCheck(address account, uint scope) {\\r\\n        require(DABotWhitelistLib.isWhitelist(account, scope), Errors.BWL_ACCOUNT_IS_NOT_WHITELISTED);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier initializer() {\\r\\n        BotMetaData storage ds = DABotMetaLib.metadata();\\r\\n        require(!ds.initialized, Errors.CM_CONTRACT_HAS_BEEN_INITIALIZED);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function configurator() internal view returns(IConfigurator) {\\r\\n        BotMetaData storage meta = DABotMetaLib.metadata();\\r\\n        return meta.manager().configurator();\\r\\n    }\\r\\n\\r\\n    function onRegister(address moduleAddress) external override onlyTemplateAdmin {\\r\\n        _onRegister(moduleAddress);\\r\\n    }\\r\\n\\r\\n    function onInitialize(bytes calldata data) external override initializer {\\r\\n        _initialize(data);\\r\\n    }\\r\\n\\r\\n    function _initialize(bytes calldata data) internal virtual;\\r\\n    function _onRegister(address moduleAddress) internal virtual;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/dabot/fundmanager/CEXFundManagerModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./FundManagerModule.sol\\\";\\r\\n\\r\\ncontract CEXFundManagerModule is FundManagerModule {\\r\\n    constructor(IBotVaultManager _vault ) FundManagerModule(_vault) {\\r\\n    }\\r\\n\\r\\n    function _registerSelectors(BotTemplateController storage ds) internal override {\\r\\n        super._registerSelectors(ds);\\r\\n        bytes4[1] memory selectors =  [\\r\\n            CEXFundManagerModule.distributeReward.selector\\r\\n        ];\\r\\n        for (uint i = 0; i < selectors.length; i++)\\r\\n            ds.selectors[selectors[i]] = IDABotFundManagerModuleID;\\r\\n    } \\r\\n\\r\\n    function moduleInfo() external pure override returns(string memory name, string memory version, bytes32 moduleId) {\\r\\n        name = \\\"CEXFundManagerModule\\\";\\r\\n        version = \\\"v0.1.220501\\\";\\r\\n        moduleId = IDABotFundManagerModuleID;\\r\\n    }\\r\\n\\r\\n\\r\\n    function award(AwardingDetail[] calldata data) external override onlyBotOwner {\\r\\n        _fundManager().createAwardingRequest(address(this), data);\\r\\n    }\\r\\n\\r\\n    function distributeReward(AwardingDetail[] calldata data) external {\\r\\n        _distributeReward(data);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/dabot/fundmanager/DABotFundManagerLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../DABotCommon.sol\\\"; \\r\\nimport \\\"../interfaces/IBotBenefitciary.sol\\\"; \\r\\n\\r\\nstruct FundManagementData {\\r\\n    address[] benefitciaries;\\r\\n}\\r\\n\\r\\naddress constant BOT_CREATOR_BENEFITCIARY = address(1);\\r\\naddress constant GOV_USER_BENEFITCIARY = address(2);\\r\\naddress constant STAKE_USER_BENEFITCIARY = address(3);\\r\\n\\r\\nlibrary DABotFundManagerLib {\\r\\n    bytes32 constant FUND_MANAGER_STORAGE_POSITION = keccak256(\\\"fundmanager.dabot.storage\\\");\\r\\n\\r\\n\\r\\n    function fundData() internal pure returns(FundManagementData storage ds) {\\r\\n        bytes32 position = FUND_MANAGER_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot :=  position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function benefitciaryName(address benefitciary) internal view returns(string memory) {\\r\\n        if (benefitciary == BOT_CREATOR_BENEFITCIARY)\\r\\n            return \\\"Bot Creator\\\";\\r\\n        if (benefitciary == GOV_USER_BENEFITCIARY)\\r\\n            return \\\"Governance Users\\\";\\r\\n        if (benefitciary == STAKE_USER_BENEFITCIARY)\\r\\n            return \\\"Stake Users\\\";\\r\\n        return IBotBenefitciary(benefitciary).name();\\r\\n    }\\r\\n\\r\\n    function benefitciaryShortName(address benefitciary) internal view returns(string memory) {\\r\\n        if (benefitciary == BOT_CREATOR_BENEFITCIARY)\\r\\n            return \\\"Bot Creator\\\";\\r\\n        if (benefitciary == GOV_USER_BENEFITCIARY)\\r\\n            return \\\"Gov. Users\\\";\\r\\n        if (benefitciary == STAKE_USER_BENEFITCIARY)\\r\\n            return \\\"Stake Users\\\";\\r\\n        return IBotBenefitciary(benefitciary).shortName();\\r\\n    }\\r\\n\\r\\n    function addBenefitciary(FundManagementData storage ds, address benefitciary) internal {\\r\\n        ds.benefitciaries.push(benefitciary);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/fundmanager/FundManagerModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\r\\nimport \\\"../../common/IConfigurator.sol\\\";\\r\\nimport \\\"../../common/Errors.sol\\\";\\r\\nimport \\\"../../common/RoboFiAddress.sol\\\";\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\nimport \\\"../DABotModule.sol\\\";\\r\\nimport \\\"../interfaces/IVicsExchange.sol\\\";\\r\\nimport \\\"../interfaces/IBotVault.sol\\\";\\r\\nimport \\\"../interfaces/IFundManager.sol\\\";\\r\\nimport \\\"../interfaces/IDABotFundManagerModule.sol\\\";\\r\\nimport \\\"../setting/DABotSettingLib.sol\\\";\\r\\nimport \\\"../staking/DABotStakingLib.sol\\\";\\r\\nimport \\\"../controller/DABotControllerLib.sol\\\";\\r\\nimport \\\"./DABotFundManagerLib.sol\\\";\\r\\n\\r\\nabstract contract FundManagerModule is DABotModule, IDABotFundManagerModuleEvent {\\r\\n    using DABotTemplateControllerLib for BotTemplateController;\\r\\n    using DABotSettingLib for BotSetting;\\r\\n    using DABotStakingLib for BotStakingData;\\r\\n    using DABotMetaLib for BotMetaData;\\r\\n    using DABotFundManagerLib for FundManagementData;\\r\\n    using RoboFiAddress for IERC20;\\r\\n\\r\\n    bytes4 constant WARMUP_VAULT = 0x5f0378a7; // warmup.vault\\r\\n    bytes4 constant REGULAR_VAULT = 0x3e472239; //regular.vault\\r\\n    bytes4 constant VIP_VAULT = 0x2c52665a; // vip.vault\\r\\n\\r\\n    IBotVaultManager internal immutable vaultManager;\\r\\n\\r\\n    constructor(IBotVaultManager _vault) {\\r\\n        vaultManager = _vault;\\r\\n    }\\r\\n\\r\\n    modifier fundManagerOnly() {\\r\\n        require(_msgSender() == address(_fundManager()), Errors.CFMOD_CALLER_IS_NOT_FUND_MANAGER);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function _onRegister(address moduleAddress) internal override {\\r\\n        BotTemplateController storage ds = DABotTemplateControllerLib.controller();\\r\\n        ds.registerModule(IDABotFundManagerModuleID, moduleAddress); \\r\\n        _registerSelectors(ds);\\r\\n        emit ModuleRegistered(\\\"IDABotFundManagerModule\\\", IDABotFundManagerModuleID, moduleAddress);\\r\\n    }\\r\\n\\r\\n    function _registerSelectors(BotTemplateController storage ds) internal virtual {\\r\\n        bytes4[7] memory selectors =  [\\r\\n            IDABotFundManagerModule.benefitciaries.selector,\\r\\n            IDABotFundManagerModule.resetBenefitciaries.selector,\\r\\n            IDABotFundManagerModule.addBenefitciary.selector,\\r\\n            IDABotFundManagerModule.award.selector,\\r\\n            IDABotFundManagerModule.pendingStakeReward.selector,\\r\\n            IDABotFundManagerModule.pendingGovernReward.selector,\\r\\n            IDABotFundManagerModule.withdrawToken.selector\\r\\n        ];\\r\\n        for (uint i = 0; i < selectors.length; i++)\\r\\n            ds.selectors[selectors[i]] = IDABotFundManagerModuleID;\\r\\n    } \\r\\n\\r\\n    function _initialize(bytes calldata) internal override {\\r\\n        _resetBenefitciaries();\\r\\n    }\\r\\n\\r\\n    function resetBenefitciaries() external onlyBotOwner {\\r\\n        _resetBenefitciaries();\\r\\n    }\\r\\n\\r\\n    function _resetBenefitciaries() private {\\r\\n        BotMetaData storage meta = DABotMetaLib.metadata();\\r\\n        FundManagementData storage fund = DABotFundManagerLib.fundData();\\r\\n        delete fund.benefitciaries;\\r\\n        BenefitciaryInfo[] memory _benefitciaries = IDABotFundManagerModule(meta.botTemplate).benefitciaries();\\r\\n        for (uint i = 0; i < _benefitciaries.length; i++)\\r\\n            fund.addBenefitciary(_benefitciaries[i].account);\\r\\n    }\\r\\n\\r\\n    function addBenefitciary(address benefitciary) external onlyBotOwner {\\r\\n        FundManagementData storage fund = DABotFundManagerLib.fundData();\\r\\n        for (uint i = 0; i < fund.benefitciaries.length; i++)\\r\\n            require(fund.benefitciaries[i] != benefitciary, Errors.CFMOD_DUPLICATED_BENEFITCIARY);\\r\\n        fund.benefitciaries.push(benefitciary);\\r\\n\\r\\n        emit AddBenefitciary(benefitciary);\\r\\n    }\\r\\n\\r\\n    function benefitciaries() external view returns(BenefitciaryInfo[] memory result) {\\r\\n        FundManagementData storage data = DABotFundManagerLib.fundData();\\r\\n        result = new BenefitciaryInfo[](data.benefitciaries.length);\\r\\n        uint profitSharing = DABotSettingLib.setting().profitSharing;\\r\\n\\r\\n        for (uint i = 0; i < data.benefitciaries.length; i++) {\\r\\n            address account = data.benefitciaries[i];\\r\\n            result[i] = BenefitciaryInfo(\\r\\n                    account,\\r\\n                    DABotFundManagerLib.benefitciaryName(account),\\r\\n                    DABotFundManagerLib.benefitciaryShortName(account),\\r\\n                    profitSharing & 0xffff\\r\\n                );\\r\\n            profitSharing = profitSharing >> 16;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function award(AwardingDetail[] calldata data) external virtual {\\r\\n       _distributeReward(data);\\r\\n    }\\r\\n\\r\\n    function _distributeReward(AwardingDetail[] calldata data) internal {\\r\\n        BotStakingData storage ds = DABotStakingLib.staking();\\r\\n        uint[] memory totalStakes = new uint[](data.length);\\r\\n        uint[] memory certTokenValues = new uint[](data.length);\\r\\n        for (uint i = 0; i < data.length; i++) {\\r\\n            _updatePnl(data[i]);\\r\\n            IDABotCertToken certToken = ds.certificateOf(IRoboFiERC20(data[i].asset));\\r\\n            totalStakes[i] = certToken.totalStake();\\r\\n            certTokenValues[i] = certToken.value(1 ether);\\r\\n        }\\r\\n        emit Award(data, totalStakes, certTokenValues);\\r\\n    }\\r\\n\\r\\n    function pendingStakeReward(address account, IRoboFiERC20[] memory assets, \\r\\n        bytes memory subVaults) external view returns(StakingReward[] memory result) \\r\\n    {\\r\\n        BotStakingData storage ds = DABotStakingLib.staking();\\r\\n        if (assets.length == 0) \\r\\n            assets = ds.assets;\\r\\n        if (subVaults.length == 0) \\r\\n            subVaults = abi.encodePacked(uint8(0), uint8(1), uint8(2));\\r\\n\\r\\n        result = new StakingReward[](assets.length);\\r\\n        for (uint i = 0; i < assets.length; i++) {\\r\\n            result[i].asset = address(assets[i]);\\r\\n            uint vID = vaultManager.vaultId(ds.portfolio[assets[i]].certToken, 0);\\r\\n            for (uint j = 0; j < subVaults.length; j++) {\\r\\n                uint8 x = uint8(subVaults[j]);\\r\\n                result[i].amount += vaultManager.pendingReward(vID + uint(x), account);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function pendingGovernReward(address account, bytes memory subVaults) external view returns(uint result) {\\r\\n        if (subVaults.length == 0) \\r\\n            subVaults = abi.encodePacked(uint8(0), uint8(1));\\r\\n        result = 0;\\r\\n        uint vID = vaultManager.vaultId(DABotMetaLib.metadata().gToken, 1);\\r\\n        for (uint i = 0; i < subVaults.length; i++) {\\r\\n            uint8 x = uint8(subVaults[i]);\\r\\n            result += vaultManager.pendingReward(vID + uint(x), account);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function withdrawToken(address asset, address to) external onlyBotOwner {\\r\\n        uint balance = IERC20(asset).balanceOf(address(this));\\r\\n        if (balance > 0)\\r\\n            IERC20(asset).transfer(to, balance);\\r\\n    }\\r\\n\\r\\n    function _safeTransfer(IERC20 asset, address to,  uint amount) internal virtual {\\r\\n       asset.safeTransferFrom(msg.sender, to, amount);\\r\\n    }\\r\\n\\r\\n    function _updatePnl(AwardingDetail calldata pnl) internal {\\r\\n        BotStakingData storage ds = DABotStakingLib.staking();\\r\\n        IDABotCertToken certToken = ds.certificateOf(IRoboFiERC20(pnl.asset));\\r\\n        if (address(certToken) == address(0)) \\r\\n            revert(string(\\r\\n                abi.encodePacked(Errors.CFMOD_INVALID_CERTIFICATE_OF_ASSET, \\\" \\\", Strings.toHexString(uint160(pnl.asset), 20))));\\r\\n        IERC20 asset = IERC20(pnl.asset);\\r\\n        \\r\\n        if (pnl.compound > 0) {\\r\\n            if (pnl.compoundMode == 0) \\r\\n                _safeTransfer(asset, address(certToken), pnl.compound);\\r\\n            certToken.compound(pnl.compound, pnl.compoundMode == 0);\\r\\n            \\r\\n            emit AwardCompound(address(asset), pnl.compound, pnl.compoundMode);\\r\\n        }\\r\\n        if (pnl.reward > 0) {\\r\\n            FundManagementData storage fund = DABotFundManagerLib.fundData(); \\r\\n            uint128 shareScheme = DABotSettingLib.setting().profitSharing;\\r\\n            uint total = 0;\\r\\n            for(uint i = 0; i < fund.benefitciaries.length; i++) {\\r\\n                if (fund.benefitciaries[i] != address(0)) \\r\\n                    total += shareScheme & 0xffff;\\r\\n                shareScheme = shareScheme >> 16;\\r\\n            }\\r\\n            shareScheme = DABotSettingLib.setting().profitSharing;\\r\\n            for(uint i = 0; i < fund.benefitciaries.length; i++) {\\r\\n                if (fund.benefitciaries[i] != address(0)) {\\r\\n                    _awardSingle(address(certToken), asset, fund.benefitciaries[i], pnl.reward, (shareScheme & 0xffff), total);\\r\\n                }\\r\\n                shareScheme = shareScheme >> 16;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _awardSingle(address certToken, IERC20 asset, address benefitciary, uint reward, uint share, uint totalShare) internal {\\r\\n        BotMetaData storage meta = DABotMetaLib.metadata();\\r\\n        uint amount = reward * share / totalShare;\\r\\n\\r\\n        if (benefitciary == BOT_CREATOR_BENEFITCIARY) {\\r\\n            _safeTransfer(asset, meta.botOwner, amount);\\r\\n            emit AwardBenefitciary(benefitciary, address(asset), address(asset), amount, share, totalShare);\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        if (benefitciary == STAKE_USER_BENEFITCIARY) {\\r\\n            uint vID = vaultManager.vaultId(certToken, 0);\\r\\n            _safeTransfer(asset, address(vaultManager), amount);\\r\\n            _awardVault(vID, 3, amount, [uint(80), 100, 120]);\\r\\n            emit AwardBenefitciary(benefitciary, address(asset), address(asset), amount, share, totalShare);\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        IConfigurator config = meta.configurator();\\r\\n        IERC20 vics = IERC20(config.addressOf(AddressBook.ADDR_VICS));\\r\\n        _safeTransfer(asset, address(this), amount);\\r\\n        uint vicsAmount = _exchangeToVICS(config, asset, amount);\\r\\n\\r\\n        if (benefitciary == GOV_USER_BENEFITCIARY) {\\r\\n            IERC20 gToken = meta.governToken();\\r\\n            uint vID = vaultManager.vaultId(address(gToken), 1);\\r\\n\\r\\n            vics.transfer(address(vaultManager), vicsAmount);\\r\\n            _awardVault(vID, 2, vicsAmount, [uint(100), 120, 0]);\\r\\n        } else {\\r\\n            vics.transfer(benefitciary, vicsAmount);\\r\\n            IBotBenefitciary(benefitciary).onAward(vicsAmount);\\r\\n        }\\r\\n\\r\\n        emit AwardBenefitciary(benefitciary, address(asset), address(vics), vicsAmount, share, totalShare);\\r\\n    }\\r\\n\\r\\n    function _awardVault(uint vID, uint numVault, uint amount, uint[3] memory weight) internal {\\r\\n        uint[] memory deposit = new uint[](numVault);\\r\\n        uint total;\\r\\n        for (uint i = 0; i < numVault; i++) {\\r\\n            deposit[i] = vaultManager.getVaultInfo(vID + i, address(this)).totalDeposit * weight[i];\\r\\n            total += deposit[i];\\r\\n        }\\r\\n        if (total == 0)\\r\\n            return;\\r\\n        for (uint i = 0; i < numVault; i++) {\\r\\n            vaultManager.updateReward(vID + i, deposit[i] * amount / total); \\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _fundManager() internal view returns(IFundManager manager) {\\r\\n        manager = IFundManager(configurator().addressOf(AddressBook.ADDR_CEX_FUND_MANAGER));\\r\\n        require(address(manager) != address(0), Errors.CM_CEX_FUND_MANAGER_IS_NOT_CONFIGURED);\\r\\n    }\\r\\n\\r\\n    function _exchangeToVICS(IConfigurator config, IERC20 asset, uint amount) private returns(uint) {\\r\\n        IVicsExchange xchg = IVicsExchange(config.addressOf(AddressBook.ADDR_VICS_EXCHANGE));\\r\\n        require(address(xchg) != address(0), Errors.CM_VICS_EXCHANGE_IS_NOT_CONFIGURED);\\r\\n        asset.approve(address(xchg), amount);\\r\\n\\r\\n        return xchg.swap(asset, amount);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/dabot/interfaces/IBotBenefitciary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../DABotCommon.sol\\\"; \\r\\n\\r\\n\\r\\n/**\\r\\n@dev The interface of a bot benefitciary who is awarded from the bot's activities.\\r\\n */\\r\\ninterface IBotBenefitciary {\\r\\n\\r\\n    function name() external view returns(string memory);\\r\\n    function shortName() external view returns(string memory);\\r\\n    function onAward(uint amount) external;\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/interfaces/IBotTemplateController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\ninterface IBotTemplateController {\\r\\n    function registerModule(address moduleHandler) external;\\r\\n    function updateModuleHandler(bytes32 moduleId, address newModuleAddress) external;\\r\\n    function module(bytes32 moduleId) external view returns(address);\\r\\n    function moduleOfSelector(bytes32 selector) external view returns(address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/dabot/interfaces/IBotVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../../token/IRoboFiERC20.sol\\\";\\r\\n\\r\\nstruct VaultData {\\r\\n    address botToken;\\r\\n    IERC20 asset;\\r\\n    address bot;\\r\\n    uint8 index;                // the index-th vault generated from botToken\\r\\n                                //  0 - warmup vault, 1 - regular vault, 2 - VIP vault\\r\\n    bytes4 vaultType;           // type of the vault, used to determine the vault handler\\r\\n}\\r\\n\\r\\nstruct UserInfo {\\r\\n    uint deposit;\\r\\n    uint debtPoints;\\r\\n    uint debt;\\r\\n    uint lockPeriod;\\r\\n    uint lastDepositTime;\\r\\n}\\r\\n\\r\\nstruct VaultInfo {\\r\\n    VaultData data;             \\r\\n    UserInfo user;\\r\\n    uint totalDeposit;          // total deposits in the vault\\r\\n    uint accRewardPerShare;     // the pending reward per each unit of deposit\\r\\n    uint lastRewardTime;        // the block time of the last reward transaction\\r\\n    uint pendingReward;         // the pending reward for the caller\\r\\n    bytes option;               // vault option\\r\\n} \\r\\n\\r\\nstruct RegularVaultOption {\\r\\n    bool restricted;    // restrict deposit activity to bot only\\r\\n}\\r\\n\\r\\n\\r\\ninterface IBotVaultEvent {\\r\\n    event Deposit(uint vID, address indexed payor, address indexed account, uint amount);\\r\\n    event Widthdraw(uint vID, address indexed account, uint amount);\\r\\n    event RewardAdded(uint vID, uint assetAmount);\\r\\n    event RewardClaimed(uint vID, address indexed account, uint amount);\\r\\n    event Snapshot(uint vID, uint snapshotId);\\r\\n}\\r\\n\\r\\ninterface IBotVault is IBotVaultEvent {\\r\\n    function deposit(uint vID, uint amount) external;\\r\\n    function delegateDeposit(uint vID, address payor, address account, uint amount, uint lockTime) external;\\r\\n    function withdraw(uint vID, uint amount) external;\\r\\n    function delegateWithdraw(uint vID, address account, uint amount) external;\\r\\n    function pendingReward(uint vID, address account) external view returns(uint);\\r\\n    function balanceOf(uint vID, address account) external view returns(uint);\\r\\n    function balanceOfAt(uint vID, address account, uint blockNo) external view returns(uint);\\r\\n    function updateReward(uint vID, uint assetAmount) external;\\r\\n    function claimReward(uint vID, address account) external;\\r\\n\\r\\n    /**\\r\\n    @dev Queries user deposit info for the given vault.\\r\\n    @param vID the vault ID to query.\\r\\n    @param account the user account to query.\\r\\n     */\\r\\n    function getUserInfo(uint vID, address account) external view returns(UserInfo memory result);\\r\\n    function getVaultInfo(uint vID, address account) external view returns(VaultInfo memory);\\r\\n    function getVaultOption(uint vID) external view returns(bytes memory);\\r\\n    function setVaultOption(uint vID, bytes calldata option) external;\\r\\n}\\r\\n\\r\\ninterface IBotVaultManagerEvent is IBotVaultEvent {\\r\\n    event OpenVault(uint vID, VaultData data);\\r\\n    event DestroyVault(uint vID);\\r\\n    event RegisterHandler(bytes4 vaultType, address handler);\\r\\n    event BotManagerUpdated(address indexed botManager);\\r\\n}\\r\\n\\r\\ninterface IBotVaultManager is IBotVault, IBotVaultManagerEvent {\\r\\n    function vaultOf(uint vID) external view returns(VaultData memory result);\\r\\n    function validVault(uint vID) external view returns(bool);\\r\\n    function createVault(VaultData calldata data) external returns(uint);\\r\\n    function destroyVault(uint vID) external;\\r\\n    function vaultId(address botToken, uint8 vaultIndex) external pure returns(uint);\\r\\n    function registerHandler(bytes4 vaultType, IBotVault handler) external;\\r\\n    function botManager() external view returns(address);\\r\\n    function setBotManager(address account) external;\\r\\n    function snapshot(uint vID) external;\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotCertLocker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../../token/IRoboFiERC20.sol\\\";\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\n\\r\\ninterface IDABotCertLocker is IRoboFiERC20 {\\r\\n    function asset() external view returns(IRoboFiERC20);\\r\\n    function detail() external view returns(LockerInfo memory);\\r\\n    function lockedBalance() external view returns(uint);\\r\\n    function unlockerable() external view returns(bool);\\r\\n    function tryUnlock() external returns(bool, uint);\\r\\n    function finalize() external payable;\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotCertToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface IDABotCertTokenEvent {\\r\\n    /**\\r\\n    @dev Triggered when the bot owner locked an amount of certificate token for trading (or yield farming).\\r\\n    @param assetAmount the amount of the underlying asset locked.\\r\\n     */\\r\\n    event Lock(uint assetAmount);\\r\\n\\r\\n    /**\\r\\n    @dev Triggered when the bot owner unlocked an amount of certificate token.\\r\\n    @param assetAmount the amount of the underlying asset unlocked.\\r\\n     */\\r\\n    event Unlock(uint assetAmount);\\r\\n\\r\\n    /**\\r\\n    @dev Triggered when the amount of pegged assets of this certificate token has been changed.\\r\\n    @param amount the changed amount.\\r\\n    @param profitOrLoss true if the the pegged assets increase, false on otherwise.\\r\\n     */\\r\\n    event Compound(uint amount, bool profitOrLoss);\\r\\n}\\r\\n\\r\\ninterface IDABotCertToken is IERC20, IDABotCertTokenEvent {\\r\\n\\r\\n    function isCertToken() external view returns(bool);\\r\\n\\r\\n    /**\\r\\n    @dev Gets the total deposit of the underlying asset within this certificate.\\r\\n     */\\r\\n    function totalStake() external view returns(uint);\\r\\n\\r\\n    function totalLiquid() external view returns(uint);\\r\\n\\r\\n    /**\\r\\n    @dev Queries the bot who owned this certificate.\\r\\n     */\\r\\n    function owner() external view returns(address);\\r\\n    \\r\\n    /**\\r\\n    @dev Gets the underlying asset of this certificate.\\r\\n     */\\r\\n    function asset() external view returns (IERC20);\\r\\n    \\r\\n    /**\\r\\n    @dev Returns the equivalent amount of the underlying asset for the given amount\\r\\n        of certificate tokens.\\r\\n    @param certTokenAmount - the amount of certificate tokens.\\r\\n     */\\r\\n    function value(uint certTokenAmount) external view returns(uint);\\r\\n\\r\\n    function lock(uint assetAmount) external;\\r\\n\\r\\n    function unlock(uint assetAmount) external;\\r\\n\\r\\n    /**\\r\\n    @dev Mints an amount of certificate tokens to the given amount. The equivalent of\\r\\n        underlying asset should be tranfered to this certificate contract by the caller.\\r\\n    @param account - the address to recieve minted tokens.\\r\\n    @param certTokenAmount - the amount of tokens to mint.\\r\\n    @notice Only the owner bot can call this function.\\r\\n     */\\r\\n    function mint(address account, uint certTokenAmount) external returns(uint);\\r\\n\\r\\n    /**\\r\\n    @dev Burns an amount of certificate tokens, and returns the equivalant amount of\\r\\n        the underlying asset to the specified account.\\r\\n    @param account - the address holing certificate tokens to burn.\\r\\n    @param certTokenAmount - the amount of certificate token to burn.\\r\\n    @return the equivalent amount of underlying asset tranfered to the specified account.\\r\\n    @notice Only the owner bot can call this function.\\r\\n     */\\r\\n    function burn(address account, uint certTokenAmount) external returns (uint);\\r\\n\\r\\n    /**\\r\\n    @dev Burns an amount of certificate tokens, and returns the equivalent amount of the \\r\\n        underlying asset to the caller.\\r\\n    @param amount - the amount of certificate token to burn.\\r\\n    @return the equivalent amount of underlying asset transfered to the caller.\\r\\n     */\\r\\n    function burn(uint amount) external returns(uint);\\r\\n\\r\\n    /**\\r\\n    @dev Burns an amount of certificate tokens without returning any underlying assets.\\r\\n    @param account - the account holding certificate tokens to burn.\\r\\n    @param amount - the amount of certificate tokens to burn.\\r\\n    @notice Only owner bot can call this function.\\r\\n     */\\r\\n    function slash(address account, uint amount) external;\\r\\n\\r\\n    /**\\r\\n    @dev Compound a given amount of the underlying asset to the total deposit. \\r\\n        The compoud could be either profit or loss.\\r\\n    @param amount - the compound amount.\\r\\n    @param profitOrLoss - `true` to increase the total deposit, `false` to decrease.\\r\\n     */\\r\\n    function compound(uint amount, bool profitOrLoss) external;\\r\\n\\r\\n    /**\\r\\n    @dev Deletes this certificate token contracts.\\r\\n     */\\r\\n    function finalize() external payable;\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotComponent.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nbytes32 constant IDABotFarmingModuleID = keccak256(\\\"farming.module\\\");\\r\\nbytes32 constant IDABotFundManagerModuleID = keccak256('fundmanager.module');\\r\\nbytes32 constant IDABotStakingModuleID = keccak256(\\\"staking.module\\\");\\r\\nbytes32 constant IDABotGovernModuleID = keccak256('governance.module');\\r\\nbytes32 constant IDABotSettingModuleID = keccak256('setting.module');\\r\\nbytes32 constant IDABotWhitelistModuleID = keccak256(\\\"whitelist.module\\\");\\r\\n\\r\\nbytes32 constant GovTokenHandlerID = keccak256('govtokenimpl.dabot.module');\\r\\nbytes32 constant CertTokenHandlerID = keccak256('certtokenimpl.dabot.module');\\r\\n\\r\\nbytes32 constant BOT_CERT_TOKEN_COOLDOWN_HANDLER_ID = keccak256(\\\"cooldown.dabot.module\\\");\\r\\n\\r\\nbytes32 constant BOT_CERT_TOKEN_TEMPLATE_ID = keccak256(\\\"certificate-token.dabot.module\\\");\\r\\nbytes32 constant BOT_GOV_TOKEN_TEMPLATE_ID = keccak256(\\\"governance-token.dabot.module\\\");\\r\\n\\r\\n//bytes32 constant BOT_MODULE_COOLDOWN_LOCKER = keccak256(\\\"cooldown.dabot.module\\\");\\r\\n\\r\\ninterface IDABotComponent {   \\r\\n    function moduleInfo() external view returns(string memory name, string memory version, bytes32 moduleId);\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotFundManagerModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\n\\r\\ninterface IDABotFundManagerModuleEvent {\\r\\n    event Award(AwardingDetail[] pnl, uint[] totalStakes, uint[] certTokenValues);\\r\\n    event AwardCompound(address indexed asset, uint amount, uint mode);\\r\\n    event AwardBenefitciary(address indexed benefitciary, address indexed portfolioAsset, address indexed awardedAsset, uint amount, uint share, uint totalShare);\\r\\n    event AddBenefitciary(address indexed benefitciary);\\r\\n}\\r\\n\\r\\ninterface IDABotFundManagerModule is IDABotFundManagerModuleEvent {\\r\\n    \\r\\n    /**\\r\\n    @dev Gets detailed information about benefitciaries of staking rewards.\\r\\n     */\\r\\n    function benefitciaries() external view returns(BenefitciaryInfo[] memory result);\\r\\n\\r\\n    /**\\r\\n    @dev Replaces the current bot's benefitciaries with its bot template's\\r\\n    @notice Only bot owner can call.\\r\\n     */\\r\\n    function resetBenefitciaries() external; \\r\\n\\r\\n    /**\\r\\n    @dev Add new benefitciary\\r\\n    @param benefitciary - the benefitciary address. Should not be added before.\\r\\n     */\\r\\n    function addBenefitciary(address benefitciary) external;\\r\\n\\r\\n    /**\\r\\n     @dev Add profit/loss for each asset in the portfolio.\\r\\n     @param pnl - list of AwardingDetail data.\\r\\n     */\\r\\n    function award(AwardingDetail[] calldata pnl) external;\\r\\n\\r\\n    /**\\r\\n    @dev Checks the pending stake rewarod of a given account for specified assets.\\r\\n    @param account - the account to check.\\r\\n    @param assets - the list of assets to check for reward. \\r\\n        If empty list is passed, all assets in the portfolio are checked.\\r\\n    @param subVaults - the list of sub-vaults to check. \\r\\n        If empty list is passed, all sub vaults (i.e., [0, 1, 2]) are checked.\\r\\n     */\\r\\n    function pendingStakeReward(address account, address[] calldata assets, \\r\\n        bytes calldata subVaults) external view returns(StakingReward[] memory);\\r\\n\\r\\n    /**\\r\\n    @dev Checks the pending governance rewardsof a given account.\\r\\n    @param account - the account to check.\\r\\n    @param subVaults - the lst oof sub-vaults to check. \\r\\n        if empty list is passed, all sub vaults (i.e., [0, 1]) are checked.\\r\\n     */\\r\\n    function pendingGovernReward(address account, bytes calldata subVaults) external view returns(uint);\\r\\n\\r\\n    /**\\r\\n    @dev Withdraws tokens that have been transfered to the bot contract by mistake.\\r\\n    All balance of the specified token in the bot will be transfered to `to` address.\\r\\n    @param asset - the IERC20 token contract.\\r\\n    @param to - the recipient address\\r\\n     */\\r\\n    function withdrawToken(address asset, address to) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotGovernToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface IDABotGovernToken is IERC20 {\\r\\n\\r\\n    function isGovernToken() external view returns(bool);\\r\\n    \\r\\n    function owner() external view returns(address);\\r\\n    function asset() external view returns (IERC20);\\r\\n    function value(uint amount) external view returns(uint);\\r\\n    function mint(address account, uint amount) external;\\r\\n    function burn(uint amount) external returns(uint);\\r\\n\\r\\n    function snapshot() external;\\r\\n    function totalSupplyAt(uint256 snapshotId) external view returns(uint256);\\r\\n    function balanceOfAt(address account, uint256 snapshotId) external view returns (uint256);\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IBotVault.sol\\\";\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\nimport \\\"../../common/IRoboFiFactory.sol\\\";\\r\\nimport \\\"../../common/IConfigurator.sol\\\";\\r\\n\\r\\ninterface IDABotManagerEvent {\\r\\n    event BotRemoved(address indexed bot);\\r\\n    event BotDeployed(uint botId, address indexed bot, BotDetail detail); \\r\\n    event TemplateRegistered(address indexed template, string name, string version, uint8 templateType);\\r\\n}\\r\\n\\r\\ninterface IDABotManager is IDABotManagerEvent {\\r\\n    \\r\\n    function configurator() external view returns(IConfigurator);\\r\\n    function vaultManager() external view returns(IBotVaultManager);\\r\\n    function addTemplate(address template) external;\\r\\n    function templates() external view returns(address[] memory);\\r\\n    function isRegisteredTemplate(address template) external view returns(bool);\\r\\n    function isRegisteredBot(address botAccount) external view returns(bool);\\r\\n    function totalBots() external view returns(uint);\\r\\n    function botIdOf(string calldata qualifiedName) external view returns(int);\\r\\n    function queryBots(uint[] calldata botId) external view returns(BotDetail[] memory output);\\r\\n    function deployBot(address template, \\r\\n                        string calldata symbol, \\r\\n                        string calldata name,\\r\\n                        BotModuleInitData[] calldata initData\\r\\n                        ) external;\\r\\n    function snapshot(address botAccount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IDABotComponent.sol\\\";\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n@dev An common interface of a DABot module.\\r\\n */\\r\\ninterface IDABotModule is IDABotComponent {\\r\\n    event ModuleRegistered(string name, bytes32 moduleId, address indexed moduleAddress);\\r\\n    \\r\\n    function onRegister(address moduleAddress) external;\\r\\n    function onInitialize(bytes calldata data) external;\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotSettingModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\n\\r\\ninterface IDABotSettingModuleEvent {\\r\\n    event SettingChanged(uint what, BotSetting setting);  \\r\\n    event AddressWritten(bytes32 itemId, address indexed value);\\r\\n    event UintWritten(bytes32 itemId, uint value);\\r\\n    event BytesWritten(bytes32 itemId, bytes value);\\r\\n}\\r\\n\\r\\ninterface IDABotSettingModule is IDABotSettingModuleEvent {   \\r\\n    function status() external view returns(uint);\\r\\n    function iboTime() external view returns(uint startTime, uint endTime);\\r\\n    function stakingTime() external view returns(uint warmup, uint cooldown, uint unit);\\r\\n    function pricePolicy() external view returns(uint priceMul, uint commission);\\r\\n    function profitSharing() external view returns(uint128);\\r\\n    function setIBOTime(uint startTime, uint endTime) external;\\r\\n    function setStakingTime(uint warmup, uint cooldown, uint unit) external;\\r\\n    function setPricePolicy(uint priceMul, uint commission) external;\\r\\n    function setProfitSharing(uint sharingScheme) external;\\r\\n\\r\\n    function readAddress(bytes32 itemId, address defaultAddress) external view returns(address);\\r\\n    function readUint(bytes32 itemId, uint defaultValue) external view returns(uint);\\r\\n    function readBytes(bytes32 itemId, bytes calldata defaultValue) external view returns(bytes memory);\\r\\n\\r\\n    function writeAddress(bytes32 itemId, address value) external;\\r\\n    function writeUint(bytes32 itemId, uint value) external;\\r\\n    function writeBytes(bytes32 itemId, bytes calldata value) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotWhitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nuint constant WHITELIST_CHECK_STAKE_USERS = 1;\\r\\nuint constant WHITELIST_CHECK_GOV_USERS = 2;\\r\\n\\r\\ninterface IDABotWhitelistModuleEvent {\\r\\n    event WhitelistScope(uint scope);\\r\\n    event WhitelistAdd(address indexed account, uint scope);\\r\\n    event WhitelistRemove(address indexed account);\\r\\n}\\r\\n\\r\\ninterface IDABotWhitelistModule is IDABotWhitelistModuleEvent {\\r\\n\\r\\n    function whitelistScope() external view returns(uint);\\r\\n    function setWhitelistScope(uint scope) external;\\r\\n    function addWhitelist(address account, uint scope) external;\\r\\n    function removeWhitelist(address account) external;\\r\\n    function isWhitelist(address acount, uint scope) external view returns(bool);\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/interfaces/IFundManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\n\\r\\ninterface IFundManagerEvent {\\r\\n    /**\\r\\n    @dev Triggered when a new request has been created\\r\\n    @param reqType the type of the request.\\r\\n                        0x1f8a3e92 - locking request\\r\\n                        0xeaef5f92 - unlocking request\\r\\n                        0x467503a0 - awarding request\\r\\n    @param requestId the uniqude id for the generated request\\r\\n    @param botOrToken the address of the certificate token (lock/unlock request), or bot address (awarding request).\\r\\n    @param amount the amount of token associated with the request. For awarding request, amount is always 0.\\r\\n    @param requester the account who initiates the request. \\r\\n     */\\r\\n    event NewRequest(bytes4 reqType, uint requestId, address indexed botOrToken, uint amount, address indexed requester);\\r\\n\\r\\n    /**\\r\\n    @dev Triggered subsequently after an awarding request, which denotes the detail information of the request.\\r\\n    @param data the details of the awarding request.\\r\\n     */\\r\\n    event AwardingRequestDetail(AwardingDetail[] data);\\r\\n    \\r\\n    /**\\r\\n    @dev Triggered when a request has been closed\\r\\n    @param requestId the unique identifier of the request\\r\\n    @param closeType determines how request is closed: 0 - approved, 1 - rejected, 2 - canceled\\r\\n    @param approver the account closing this request\\r\\n     */\\r\\n    event CloseRequest(uint requestId, uint8 closeType, address indexed approver);\\r\\n}\\r\\n\\r\\ninterface IFundManager is IFundManagerEvent {\\r\\n    /**\\r\\n    @dev Creates a locking request, for internal call only.\\r\\n     */\\r\\n    function createLockingRequest(address botToken, uint assetAmount) external returns(uint requestId);\\r\\n\\r\\n    /**\\r\\n    @dev Creates an unlocking request, for internal call only.\\r\\n     */\\r\\n    function createUnlockingRequest(address botToken, uint assetAmount) external returns(uint requestId);\\r\\n\\r\\n    /**\\r\\n    @dev Creates an awarding request, for internal call only.\\r\\n     */\\r\\n    function createAwardingRequest(address bot, AwardingDetail[] calldata data) external returns(uint requestId);\\r\\n\\r\\n    /**\\r\\n    @dev Canceled a funding request, should be called by the request creator.\\r\\n    @param requestId the identifier of the request to cancel. Transaction reverts if no such request found.\\r\\n     */\\r\\n    function cancelRequest(uint requestId) external;\\r\\n\\r\\n    /**\\r\\n    @dev Closes a funding request. Could be either approve or reject the given request.\\r\\n    @param requestId the identifier of the request to close.\\r\\n    @param closeType determins whether to request is approved or rejected.\\r\\n                    0 - approved, 1 - rejected.\\r\\n    @param requestData the extra data when approving a request. For locking/unlock requests, this parameter\\r\\n            should be empty. For awarding request, this parameter should be exactly the same data passed to \\r\\n            the createAwardingRequest function. Otherwise, the transaction may be reverted.\\r\\n     */\\r\\n    function closeRequest(uint requestId, uint8 closeType, bytes calldata requestData) external;\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/interfaces/IVicsExchange.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\n\\r\\ninterface IVicsExchange {\\r\\n    /**\\r\\n    @dev Exchanges the given input amount of a specific asset to an equivalent amount\\r\\n        of VICS.\\r\\n     */\\r\\n    function swap(IERC20 asset, uint amountIn) external returns(uint amountOut);\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/setting/DABotSettingLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\r\\nimport \\\"../../common/Errors.sol\\\";\\r\\nimport \\\"../../common/IConfigurator.sol\\\";\\r\\nimport \\\"../interfaces/IDABotSettingModule.sol\\\";\\r\\nimport \\\"../controller/DABotControllerLib.sol\\\";\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\n\\r\\nstruct SettingStorage { \\r\\n    mapping(bytes32 => address) addrStorage;\\r\\n    mapping(bytes32 => uint) uintStorage;\\r\\n    mapping(bytes32 => bytes) blobStorage;\\r\\n}\\r\\n\\r\\nlibrary DABotSettingLib {\\r\\n\\r\\n    using DABotSettingLib for BotSetting;\\r\\n    using DABotMetaLib for BotMetaData;\\r\\n\\r\\n    bytes32 constant CORE_STORAGE_POSITION = keccak256(\\\"core.dabot.storage\\\");\\r\\n    bytes32 constant SETTING_STORAGE_POSITION = keccak256(\\\"setting.dabot.storage\\\");\\r\\n\\r\\n    function coredata() internal pure returns(BotCoreData storage ds) {\\r\\n        bytes32 position = CORE_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setting() internal view returns(BotSetting storage) {\\r\\n        return coredata().setting;\\r\\n    }\\r\\n\\r\\n    function settingStorage() internal pure returns(SettingStorage storage ds) {\\r\\n        bytes32 position = SETTING_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function status(BotSetting storage _setting) internal view returns(BotStatus result) {\\r\\n        BotMetaData storage meta = DABotMetaLib.metadata();\\r\\n\\r\\n        if (meta.abandoned) return BotStatus.ABANDONED;\\r\\n        if (block.timestamp < _setting.iboStartTime()) return BotStatus.PRE_IBO;\\r\\n        if (block.timestamp < _setting.iboEndTime()) return BotStatus.IN_IBO;\\r\\n        return BotStatus.ACTIVE;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    @dev Ensures that following conditions are met\\r\\n        1) bot is not abandoned, and\\r\\n        2) either bot is pre-ibo stage and sender is bot owner, or the sender is vote controller module\\r\\n     */\\r\\n    function requireSettingChangable(address account) internal view {\\r\\n        BotMetaData storage _metadata = DABotMetaLib.metadata();\\r\\n        \\r\\n        require(!_metadata.abandoned, Errors.BSL_BOT_IS_ABANDONED);\\r\\n\\r\\n        if (_metadata.isTemplate) {\\r\\n            require(account == _metadata.botOwner, Errors.BSL_CALLER_IS_NOT_OWNER);\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        BotSetting storage _setting = DABotSettingLib.setting();\\r\\n        if (block.timestamp < _setting.iboStartTime()) {\\r\\n            require(account == _metadata.botOwner, Errors.BSL_CALLER_IS_NOT_OWNER);\\r\\n            return;\\r\\n        }\\r\\n        address executor = _metadata.configurator().addressOf(AddressBook.ADDR_GOVERNANCE_EXECUTOR);\\r\\n        require(account == executor, Errors.BSL_CALLER_IS_NOT_GOVERNANCE_EXECUTOR);\\r\\n    }\\r\\n\\r\\n    function readAddress(SettingStorage storage ds, bytes32 itemId, address defaultAddress) internal view returns(address result) {\\r\\n        result = ds.addrStorage[itemId]; \\r\\n        if (result == address(0)) { \\r\\n            BotMetaData storage _metadata = DABotMetaLib.metadata();\\r\\n             if (_metadata.botManager == address(0))\\r\\n                return result;\\r\\n            if (_metadata.botTemplate != address(0))\\r\\n                result = IDABotSettingModule(_metadata.botTemplate).readAddress(itemId, defaultAddress);\\r\\n            if (result == address(0))\\r\\n                result = _metadata.configurator().addressOf(itemId);\\r\\n            if (result == address(0))\\r\\n                result = defaultAddress;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function writeAddress(SettingStorage storage ds, bytes32 itemId, address value) internal {\\r\\n        ds.addrStorage[itemId] = value;\\r\\n    }\\r\\n\\r\\n    function readUint(SettingStorage storage ds, bytes32 itemId, uint defaultValue) internal view returns(uint result) {\\r\\n        result = ds.uintStorage[itemId];\\r\\n        if (result == 0) {\\r\\n            BotMetaData storage _metadata = DABotMetaLib.metadata();\\r\\n            if (_metadata.botManager == address(0))\\r\\n                return result;\\r\\n            if (_metadata.botTemplate != address(0))\\r\\n                result = IDABotSettingModule(_metadata.botTemplate).readUint(itemId, defaultValue);\\r\\n            if (result == 0)\\r\\n                result = _metadata.configurator().configOf(itemId);\\r\\n            if (result == 0)\\r\\n                result = defaultValue;\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    function writeUint(SettingStorage storage ds, bytes32 itemId, uint value) internal {\\r\\n        ds.uintStorage[itemId] = value;\\r\\n    }\\r\\n\\r\\n    function readBytes(SettingStorage storage ds, bytes32 itemId, bytes calldata defaultValue) internal view returns(bytes memory result) {\\r\\n        result = ds.blobStorage[itemId];\\r\\n        if (result.length == 0) {\\r\\n            BotMetaData storage _metadata = DABotMetaLib.metadata();\\r\\n            if (_metadata.botManager == address(0))\\r\\n                return result;\\r\\n            if (_metadata.botTemplate != address(0))\\r\\n                result = IDABotSettingModule(_metadata.botTemplate).readBytes(itemId, defaultValue);\\r\\n            if (result.length == 0)\\r\\n                result = _metadata.configurator().bytesConfigOf(itemId);\\r\\n            if (result.length == 0)\\r\\n                result = defaultValue;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function writeBytes(SettingStorage storage ds, bytes32 itemId, bytes calldata defaultValue) internal {\\r\\n        ds.blobStorage[itemId] = defaultValue;\\r\\n    }\\r\\n\\r\\n    function iboStartTime(BotSetting memory info) internal pure returns(uint) {\\r\\n        return info.iboTime & 0xFFFFFFFF;\\r\\n    }\\r\\n\\r\\n    function iboEndTime(BotSetting memory info) internal pure returns(uint) {\\r\\n        return info.iboTime >> 32;\\r\\n    }\\r\\n\\r\\n    function setIboTime(BotSetting storage info, uint start, uint end) internal {\\r\\n        require(start < end, Errors.BSL_IBO_ENDTIME_IS_SOONER_THAN_IBO_STARTTIME);\\r\\n        info.iboTime = uint64((end << 32) | start);\\r\\n    }\\r\\n\\r\\n    function warmupTime(BotSetting storage info) internal view returns(uint) {\\r\\n        return info.stakingTime & 0xFF;\\r\\n    }\\r\\n\\r\\n    function cooldownTime(BotSetting storage info) internal view returns(uint) {\\r\\n        return (info.stakingTime >> 8) & 0xFF;\\r\\n    }\\r\\n\\r\\n    function getStakingTimeMultiplier(BotSetting storage info) internal view returns (uint) {\\r\\n        uint unit = stakingTimeUnit(info);\\r\\n        if (unit == 0) return 1 days;\\r\\n        if (unit == 1) return 1 hours;\\r\\n        if (unit == 2) return 1 minutes;\\r\\n        return 1 seconds;\\r\\n    }\\r\\n\\r\\n    function stakingTimeUnit(BotSetting storage info) internal view returns (uint) {\\r\\n        return (info.stakingTime >> 16);\\r\\n    }\\r\\n\\r\\n    function setStakingTime(BotSetting storage info, uint warmup, uint cooldown, uint unit) internal {\\r\\n        info.stakingTime = uint24((unit << 16) | (cooldown << 8) | warmup);\\r\\n    }\\r\\n\\r\\n    function priceMultiplier(BotSetting storage info) internal view returns(uint) {\\r\\n        return info.pricePolicy & 0xFFFF;\\r\\n    }\\r\\n\\r\\n    function commission(BotSetting storage info) internal view returns(uint) {\\r\\n        return info.pricePolicy >> 16;\\r\\n    }\\r\\n\\r\\n    function setPricePolicy(BotSetting storage info, uint _priceMul, uint _commission) internal {\\r\\n        info.pricePolicy = uint32((_commission << 16) | _priceMul);\\r\\n    }\\r\\n\\r\\n    function profitShare(BotSetting storage info, uint actor) internal view returns(uint) {\\r\\n        return (info.profitSharing >> actor * 16) & 0xFFFF;\\r\\n    }\\r\\n\\r\\n    function setProfitShare(BotSetting storage info, uint sharingScheme) internal {\\r\\n        info.profitSharing = uint128(sharingScheme);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/dabot/staking/DABotStakingLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../../token/IRoboFiERC20.sol\\\";\\r\\nimport \\\"../../common/Errors.sol\\\";\\r\\nimport \\\"../interfaces/IDABotCertLocker.sol\\\";\\r\\nimport \\\"../interfaces/IDABotCertToken.sol\\\";\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\nimport \\\"../controller/DABotControllerLib.sol\\\";\\r\\n\\r\\n\\r\\nstruct BotStakingData {\\r\\n    IRoboFiERC20[]  assets; \\r\\n    mapping(IRoboFiERC20 => PortfolioAsset) portfolio;\\r\\n    mapping(address => IDABotCertLocker[]) warmup;\\r\\n    mapping(address => IDABotCertLocker[]) cooldown;\\r\\n    mapping(address => bool) lockers;\\r\\n}\\r\\n\\r\\nlibrary DABotStakingLib {\\r\\n    bytes32 constant STAKING_STORAGE_POSITION = keccak256(\\\"staking.dabot.storage\\\");\\r\\n\\r\\n    using DABotStakingLib for BotStakingData;\\r\\n    using DABotMetaLib for BotMetaData;\\r\\n\\r\\n    function staking() internal pure returns(BotStakingData storage ds) {\\r\\n        bytes32 position = STAKING_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function stakeBalanceOf(BotStakingData storage ds, address account, IRoboFiERC20 asset) internal view returns(uint) {\\r\\n        BotMetaData storage meta = DABotMetaLib.metadata();\\r\\n        IBotVaultManager vault = IDABotManager(meta.botManager).vaultManager();\\r\\n        IDABotCertToken certToken = ds.certificateOf(asset);\\r\\n        uint vID = vault.vaultId(address(certToken), 0);\\r\\n\\r\\n        return certToken.balanceOf(account)\\r\\n                // + ds.warmupBalanceOf(account, asset)\\r\\n                + vault.balanceOf(vID, account)\\r\\n                + vault.balanceOf(vID + 1, account)\\r\\n                + vault.balanceOf(vID + 2, account)\\r\\n                + ds.cooldownBalanceOf(account, ds.certificateOf(asset));\\r\\n    }\\r\\n\\r\\n    function totalStake(BotStakingData storage ds, IRoboFiERC20 asset) internal view returns(uint) {\\r\\n        return IDABotCertToken(ds.portfolio[asset].certToken).totalStake();\\r\\n    }\\r\\n\\r\\n    function warmupBalanceOf(BotStakingData storage ds, address account, IRoboFiERC20 asset) internal view returns(uint) {\\r\\n        IDABotCertLocker[] storage lockers = ds.warmup[account];\\r\\n        return lockedBalance(lockers, address(asset));\\r\\n    }\\r\\n\\r\\n    function cooldownBalanceOf(BotStakingData storage ds, address account, IDABotCertToken certToken) internal view returns(uint) {\\r\\n        IDABotCertLocker[] storage lockers = ds.cooldown[account];\\r\\n        return lockedBalance(lockers, address(certToken.asset()));\\r\\n    }\\r\\n    \\r\\n    function certificateOf(BotStakingData storage ds, IRoboFiERC20 asset) internal view returns(IDABotCertToken) {\\r\\n        return IDABotCertToken(ds.portfolio[asset].certToken); \\r\\n    }\\r\\n\\r\\n    function assetOf(address certToken) public view returns(IERC20) {\\r\\n        return IDABotCertToken(certToken).asset(); \\r\\n    }\\r\\n\\r\\n    function lockedBalance(IDABotCertLocker[] storage lockers, address asset) internal view returns(uint result) {\\r\\n        result = 0;\\r\\n        for (uint i = 0; i < lockers.length; i++) \\r\\n            if (address(lockers[i].asset()) == asset)\\r\\n                result += lockers[i].lockedBalance();\\r\\n    }\\r\\n\\r\\n    function portfolioDetails(BotStakingData storage ds) internal view returns(UserPortfolioAsset[] memory output) {\\r\\n        output = new UserPortfolioAsset[](ds.assets.length);\\r\\n        for(uint i = 0; i < ds.assets.length; i++) {\\r\\n            IRoboFiERC20 asset = ds.assets[i];\\r\\n            output[i].asset = address(asset);\\r\\n            output[i].info = ds.portfolio[asset];\\r\\n            output[i].userStake = ds.stakeBalanceOf(msg.sender, asset);\\r\\n            output[i].totalStake = ds.totalStake(asset);\\r\\n            output[i].certSupply = IERC20(ds.portfolio[asset].certToken).totalSupply();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function portfolioOf(BotStakingData storage ds, IRoboFiERC20 asset) internal view returns(UserPortfolioAsset memory  output) {\\r\\n        output.asset = address(asset);\\r\\n        output.info = ds.portfolio[asset];\\r\\n        output.userStake = ds.stakeBalanceOf(msg.sender, asset);\\r\\n        output.totalStake = ds.totalStake(asset);\\r\\n        output.certSupply = IERC20(ds.portfolio[asset].certToken).totalSupply();\\r\\n    }\\r\\n\\r\\n    function updatePortfolioAsset(BotStakingData storage ds, IRoboFiERC20 asset, uint maxCap, uint iboCap, uint weight) internal {\\r\\n        PortfolioAsset storage pAsset = ds.portfolio[asset];\\r\\n\\r\\n        if (address(pAsset.certToken) == address(0)) {\\r\\n            pAsset.certToken = DABotMetaLib.metadata().deployCertToken(address(asset));\\r\\n            ds.assets.push(asset);\\r\\n        }\\r\\n\\r\\n        if (maxCap > 0) pAsset.cap = maxCap;\\r\\n        if (iboCap > 0) pAsset.iboCap = iboCap;\\r\\n        if (weight > 0) pAsset.weight = weight;\\r\\n\\r\\n        uint _totalStake = IDABotCertToken(pAsset.certToken).totalStake();\\r\\n\\r\\n        require((pAsset.cap >= _totalStake) && (pAsset.cap >= pAsset.iboCap), Errors.BSTMOD_INVALID_STAKING_CAP);\\r\\n    }\\r\\n\\r\\n    function removePortfolioAsset(BotStakingData storage ds, IRoboFiERC20 asset) internal returns(address) {\\r\\n        require(address(asset) != address(0), Errors.BSTMOD_ASSET_IS_ZERO);\\r\\n        for(uint i = 0; i < ds.assets.length; i++)\\r\\n            if (address(ds.assets[i]) == address(asset)) {\\r\\n                address certToken = ds.portfolio[asset].certToken;\\r\\n                IDABotCertToken(certToken).finalize(); \\r\\n                delete ds.portfolio[asset];\\r\\n                ds.assets[i] = ds.assets[ds.assets.length - 1];\\r\\n                ds.assets.pop();\\r\\n                return certToken;\\r\\n            }\\r\\n        revert(Errors.BSTMOD_PORTFOLIO_ASSET_NOT_FOUND);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/whitelist/DABotWhitelistLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../interfaces/IDABotWhitelist.sol\\\";\\r\\n\\r\\nstruct BotWhitelistData {\\r\\n    uint scope;    // an integer flag to determine the scope where whitelist is apply\\r\\n    mapping(address => uint) whitelist;\\r\\n}\\r\\n\\r\\nlibrary DABotWhitelistLib {\\r\\n\\r\\n    bytes32 constant WHITELIST_STORAGE_POSITION = keccak256(\\\"whitelist.dabot.storage\\\");\\r\\n\\r\\n    function whitelist() internal pure returns(BotWhitelistData storage ds) {\\r\\n        bytes32 position = WHITELIST_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isWhitelist(address account, uint scope) internal view returns(bool) {\\r\\n        BotWhitelistData storage data = whitelist();\\r\\n        if (data.scope & scope == 0)\\r\\n            return true;\\r\\n        return (data.whitelist[account] & scope) > 0;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/token/IRoboFiERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface IRoboFiERC20 is IERC20 {\\r\\n    function symbol() external view returns (string memory);\\r\\n    function name() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n}\"\r\n    },\r\n    \"contracts/treasury/ITreasuryAsset.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../token/IRoboFiERC20.sol\\\";\\r\\n\\r\\naddress constant NATIVE_ASSET_ADDRESS = address(0x1E1e1E1E1e1e1e1e1e1E1E1E1E1e1e1E1e1e1E1E);\\r\\n\\r\\ninterface ITreasuryAssetEvent {\\r\\n    event Lock(address indexed account, uint256 amount);\\r\\n    event Unlock(address indexed caller, uint256 amount, address indexed account);\\r\\n    event Slash(address indexed bot, uint256 amount);\\r\\n    event FundManagerChanged(address indexed fundmanager);\\r\\n}\\r\\n\\r\\ninterface ITreasuryAsset is IRoboFiERC20, ITreasuryAssetEvent {\\r\\n\\r\\n    /**\\r\\n    @dev Gets the total locked amount.\\r\\n     */\\r\\n    function totalLocked() external view returns(uint);\\r\\n\\r\\n    /**\\r\\n    @dev Gets the address of the underlying asset.\\r\\n     */\\r\\n    function asset() external view returns(IRoboFiERC20);\\r\\n\\r\\n    /**\\r\\n    @dev Deposits `amount` of original asset, and gets back an equivalent amount of token.\\r\\n    **/\\r\\n    function mint(address to, uint256 amount) external payable;\\r\\n\\r\\n    /**\\r\\n    @dev Burns `amount` of sToken to get back original  tokens\\r\\n     */\\r\\n    function burn(uint256 amount) external;\\r\\n\\r\\n    /**\\r\\n    @dev Burns `amount` of sToken WITHOUT get back the original tokens (this is for trading loss). \\r\\n    Only accept calls from registred DABot.\\r\\n     */\\r\\n    function slash(uint256 amount) external;\\r\\n\\r\\n    /**\\r\\n    @dev Locks `amount` of token from the caller's account. An equivalent amount of \\r\\n    original asset will be transferred to the fund manager.\\r\\n\\r\\n    Return the locked balanced of the caller's account.\\r\\n    **/    \\r\\n    function lock(uint256 amount) external;\\r\\n\\r\\n    /**\\r\\n    @dev Get the locked amounts of sToken for `user`\\r\\n    **/\\r\\n    function lockedBalanceOf(address user) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n    @dev Gets `amount` of tocken from the caller account, and decrease the locked balance of `user`. \\r\\n    **/\\r\\n    function unlock(address user, uint256 amount) external payable;\\r\\n\\r\\n    /**\\r\\n    @dev Determines if the underlying asset is native token or not.\\r\\n     */\\r\\n    function isNativeAsset() external view returns(bool);\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IBotVaultManager\",\"name\":\"_vault\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"benefitciary\",\"type\":\"address\"}],\"name\":\"AddBenefitciary\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"compound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compoundMode\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct AwardingDetail[]\",\"name\":\"pnl\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"totalStakes\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"certTokenValues\",\"type\":\"uint256[]\"}],\"name\":\"Award\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"benefitciary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"portfolioAsset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"awardedAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalShare\",\"type\":\"uint256\"}],\"name\":\"AwardBenefitciary\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mode\",\"type\":\"uint256\"}],\"name\":\"AwardCompound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"moduleAddress\",\"type\":\"address\"}],\"name\":\"ModuleRegistered\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"benefitciary\",\"type\":\"address\"}],\"name\":\"addBenefitciary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"compound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compoundMode\",\"type\":\"uint256\"}],\"internalType\":\"struct AwardingDetail[]\",\"name\":\"data\",\"type\":\"tuple[]\"}],\"name\":\"award\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"benefitciaries\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"shortName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"internalType\":\"struct BenefitciaryInfo[]\",\"name\":\"result\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"compound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compoundMode\",\"type\":\"uint256\"}],\"internalType\":\"struct AwardingDetail[]\",\"name\":\"data\",\"type\":\"tuple[]\"}],\"name\":\"distributeReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"moduleInfo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onInitialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"moduleAddress\",\"type\":\"address\"}],\"name\":\"onRegister\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"subVaults\",\"type\":\"bytes\"}],\"name\":\"pendingGovernReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"contract IRoboFiERC20[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"subVaults\",\"type\":\"bytes\"}],\"name\":\"pendingStakeReward\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct StakingReward[]\",\"name\":\"result\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetBenefitciaries\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CEXFundManagerModule", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000040c98bedb1e52eb733a02cc1beccbc773aadf6ee", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}