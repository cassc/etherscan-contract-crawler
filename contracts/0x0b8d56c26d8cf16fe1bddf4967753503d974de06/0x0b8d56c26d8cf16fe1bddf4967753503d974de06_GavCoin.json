{"SourceCode": "contract Token {\r\n    /// Get the total amount of tokens in the system.\r\n    function totalSupply() constant returns (uint256 total);\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract GavCoin {\r\n    struct Receipt {\r\n        uint units;\r\n        uint32 activation;\r\n    }\r\n    struct Account {\r\n        uint balance;\r\n        mapping (uint => Receipt) receipt;\r\n        mapping (address => uint) allowanceOf;\r\n    }\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Buyin(address indexed buyer, uint indexed price, uint indexed amount);\r\n    event Refund(address indexed buyer, uint indexed price, uint indexed amount);\r\n    event NewTranch(uint indexed price);\r\n    \r\n    modifier when_owns(address _owner, uint _amount) { if (accounts[_owner].balance < _amount) return; _ }\r\n    modifier when_has_allowance(address _owner, address _spender, uint _amount) { if (accounts[_owner].allowanceOf[_spender] < _amount) return; _ }\r\n    modifier when_have_active_receipt(uint _price, uint _units) { if (accounts[msg.sender].receipt[_price].units < _units || now < accounts[msg.sender].receipt[_price].activation) return; _ }\r\n\r\n    function balanceOf(address _who) constant returns (uint) { return accounts[_who].balance; }\r\n    \r\n    function transfer(address _to, uint256 _value) when_owns(msg.sender, _value) returns (bool success) {\r\n        Transfer(msg.sender, _to, _value);\r\n        accounts[msg.sender].balance -= _value;\r\n        accounts[_to].balance += _value;\r\n    }\r\n    function transferFrom(address _from, address _to, uint256 _value) when_owns(_from, _value) when_has_allowance(_from, msg.sender, _value) returns (bool success) {\r\n        Transfer(_from, _to, _value);\r\n        accounts[_from].allowanceOf[msg.sender] -= _value;\r\n        accounts[_from].balance -= _value;\r\n        accounts[_to].balance += _value;\r\n        return true;\r\n    }\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        Approval(msg.sender, _spender, _value);\r\n        accounts[msg.sender].allowanceOf[_spender] += _value;\r\n        return true;\r\n    }\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return accounts[_owner].allowanceOf[_spender];\r\n    }\r\n    \r\n    /// Simple buyin.\r\n    function() { buyinInternal(msg.sender, 2 ** 255); }\r\n\r\n    /// Extended buyin.\r\n    function buyin(address _who, uint _maxPrice) { buyinInternal(_who, _maxPrice); }\r\n\r\n    function refund(uint _price, uint _units) when_have_active_receipt(_price, _units) when_owns(msg.sender, _units) returns (bool) {\r\n        Refund(msg.sender, _price, _units);\r\n        accounts[msg.sender].balance -= _units;\r\n        totalSupply += _units;\r\n        accounts[msg.sender].receipt[_price].units -= _units;\r\n        if (accounts[msg.sender].receipt[_price].units == 0)\r\n            delete accounts[msg.sender].receipt[_price];\r\n        if (!msg.sender.send(_units * _price / base))\r\n            throw;\r\n        return true;\r\n    }\r\n\r\n    function buyinInternal(address _who, uint _maxPrice) internal {\r\n        var leftToSpend = msg.value;\r\n        while (leftToSpend > 0 && price <= _maxPrice) {\r\n            // How much the remaining tokens of this tranch cost to buy\r\n            var maxCanSpend = price * remaining / base;\r\n            // How much we will spend - the mininum of what's left in the tranch\r\n            // to buy and what we have remaining\r\n            var spend = leftToSpend > maxCanSpend ? maxCanSpend : leftToSpend;\r\n            // The number of units we get for spending that\r\n            var units = spend * base / price;\r\n\r\n            // Provide tokens and a purchase receipt\r\n            accounts[msg.sender].balance += units;\r\n            accounts[msg.sender].receipt[price].units += units;\r\n            accounts[msg.sender].receipt[price].activation = uint32(now) + refundActivationPeriod;\r\n            totalSupply += units;\r\n            Buyin(msg.sender, price, units);\r\n\r\n            // Reduce the amounts remaining\r\n            leftToSpend -= spend;\r\n            remaining -= units;\r\n            \r\n            // If this is the end of the tranch...\r\n            if (remaining == 0) {\r\n                // ...Increment price and reset remaining\r\n                price += tranchStep;\r\n                remaining = tokensPerTranch * base;\r\n                NewTranch(price);\r\n            }\r\n        }\r\n    }\r\n    \r\n    uint public totalSupply;\r\n    mapping (address => Account) accounts;\r\n    \r\n    uint constant base = 1000000;               // tokens are subdivisible by 1000000\r\n    uint constant tranchStep = 1 finney;        // raise price by 1 finney / tranch\r\n    uint constant tokensPerTranch = 100;        // 100 tokens per tranch\r\n    uint public price = 1 finney;               // begin at 1 finney / token\r\n    uint public remaining = tokensPerTranch * base;\r\n    uint32 constant refundActivationPeriod = 7 days;\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_maxPrice\",\"type\":\"uint256\"}],\"name\":\"buyin\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remaining\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_units\",\"type\":\"uint256\"}],\"name\":\"refund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Buyin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"NewTranch\",\"type\":\"event\"}]", "ContractName": "GavCoin", "CompilerVersion": "v0.3.6+commit.3fc68da", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}