{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/FeedRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {Auth} from \\\"chronicle-std/auth/Auth.sol\\\";\\n\\nimport {IFeedRegistry} from \\\"./IFeedRegistry.sol\\\";\\n\\n/**\\n * @title FeedRegistry\\n *\\n * @notice Single source of truth for all of Chronicle Protocol's feeds\\n *\\n * @dev This contract provides a registry for feeds via 1-byte feed ids.\\n *\\n *      A feeds feed id is computed as the highest-order byte of the feeds\\n *      address, ie `uint8 feedId = uint8(uint(uint160(feed)) >> 152);`\\n *\\n *      Due to feed ids being 1 byte, the maximum number of feeds supported is\\n *      256.\\n *\\n *      Note that a set of lifted feeds can be encoded in a single uint.\\n *      The code refers to it as `uint bloom`.\\n */\\ncontract FeedRegistry is IFeedRegistry, Auth {\\n    /// @dev Statically allocated array for feeds.\\n    ///      Indexed via feed's feed id.\\n    address[256] internal _feeds;\\n\\n    constructor(address initialAuthed) Auth(initialAuthed) {}\\n\\n    /// @inheritdoc IFeedRegistry\\n    function feeds() external view returns (address[] memory) {\\n        address[] memory feeds_ = new address[](256);\\n        uint ctr;\\n        for (uint i; i < 256; i++) {\\n            address feed = _feeds[i];\\n\\n            if (feed == address(0)) {\\n                continue;\\n            }\\n\\n            feeds_[ctr++] = feed;\\n        }\\n\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(feeds_, ctr)\\n        }\\n\\n        return feeds_;\\n    }\\n\\n    /// @inheritdoc IFeedRegistry\\n    function feeds(address feed) public view returns (bool) {\\n        uint8 feedId = uint8(uint(uint160(feed)) >> 152);\\n\\n        return _feeds[feedId] != address(0);\\n    }\\n\\n    /// @inheritdoc IFeedRegistry\\n    function encode(address[] calldata feeds_) external view returns (uint) {\\n        uint bloom;\\n\\n        for (uint i; i < feeds_.length; i++) {\\n            address feed = feeds_[i];\\n\\n            if (!feeds(feed)) {\\n                revert FeedNotLifted(feed);\\n            }\\n\\n            uint8 feedId = uint8(uint(uint160(feed)) >> 152);\\n            bloom |= (1 << feedId);\\n        }\\n\\n        return bloom;\\n    }\\n\\n    /// @inheritdoc IFeedRegistry\\n    function decode(uint bloom) external view returns (address[] memory) {\\n        address[] memory feeds_ = new address[](256);\\n        uint ctr;\\n        for (uint i; i < 256; i++) {\\n            if (bloom & (1 << i) == 0) {\\n                continue;\\n            }\\n\\n            address feed = _feeds[i];\\n\\n            if (feed == address(0)) {\\n                revert FeedIdNotLifted(uint8(i));\\n            }\\n\\n            feeds_[ctr++] = feed;\\n        }\\n\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(feeds_, ctr)\\n        }\\n\\n        return feeds_;\\n    }\\n\\n    // -- Auth'ed Functionality --\\n\\n    /// @inheritdoc IFeedRegistry\\n    function lift(address feed) external auth {\\n        _lift(feed);\\n    }\\n\\n    /// @inheritdoc IFeedRegistry\\n    function lift(address[] memory feeds_) external auth {\\n        for (uint i; i < feeds_.length; i++) {\\n            _lift(feeds_[i]);\\n        }\\n    }\\n\\n    /// @inheritdoc IFeedRegistry\\n    function drop(uint8 feedId) external auth {\\n        _drop(feedId);\\n    }\\n\\n    /// @inheritdoc IFeedRegistry\\n    function drop(uint8[] memory feedIds) external auth {\\n        for (uint i; i < feedIds.length; i++) {\\n            _drop(feedIds[i]);\\n        }\\n    }\\n\\n    // -- Internal Helpers --\\n\\n    function _lift(address feed) internal {\\n        require(feed != address(0));\\n\\n        uint8 feedId = uint8(uint(uint160(feed)) >> 152);\\n\\n        address current = _feeds[feedId];\\n        if (current != feed) {\\n            require(current == address(0));\\n\\n            _feeds[feedId] = feed;\\n            emit FeedLifted(msg.sender, feed);\\n        }\\n    }\\n\\n    function _drop(uint8 feedId) internal {\\n        address current = _feeds[feedId];\\n        if (current != address(0)) {\\n            delete _feeds[feedId];\\n            emit FeedDropped(msg.sender, current);\\n        }\\n    }\\n}\\n\\n/**\\n * @dev Contract overwrite to deploy contract instances with specific naming.\\n *\\n *      For more info, see docs/Deployment.md.\\n */\\ncontract FeedRegistry_1 is FeedRegistry {\\n    constructor(address initialAuthed) FeedRegistry(initialAuthed) {}\\n}\\n\"\r\n    },\r\n    \"lib/chronicle-std/src/auth/Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {IAuth} from \\\"./IAuth.sol\\\";\\n\\n/**\\n * @title Auth Module\\n *\\n * @dev The `Auth` contract module provides a basic access control mechanism,\\n *      where a set of addresses are granted access to protected functions.\\n *      These addresses are said to be _auth'ed_.\\n *\\n *      Initially, the address given as constructor argument is the only address\\n *      auth'ed. Through the `rely(address)` and `deny(address)` functions,\\n *      auth'ed callers are able to grant/renounce auth to/from addresses.\\n *\\n *      This module is used through inheritance. It will make available the\\n *      modifier `auth`, which can be applied to functions to restrict their\\n *      use to only auth'ed callers.\\n */\\nabstract contract Auth is IAuth {\\n    /// @dev Mapping storing whether address is auth'ed.\\n    /// @custom:invariant Image of mapping is {0, 1}.\\n    ///                     \u2200x \u220a Address: _wards[x] \u220a {0, 1}\\n    /// @custom:invariant Only address given as constructor argument is authenticated after deployment.\\n    ///                     deploy(initialAuthed) \u2192 (\u2200x \u220a Address: _wards[x] == 1 \u2192 x == initialAuthed)\\n    /// @custom:invariant Only functions `rely` and `deny` may mutate the mapping's state.\\n    ///                     \u2200x \u220a Address: preTx(_wards[x]) != postTx(_wards[x])\\n    ///                                     \u2192 (msg.sig == \\\"rely\\\" \u2228 msg.sig == \\\"deny\\\")\\n    /// @custom:invariant Mapping's state may only be mutated by authenticated caller.\\n    ///                     \u2200x \u220a Address: preTx(_wards[x]) != postTx(_wards[x]) \u2192 _wards[msg.sender] = 1\\n    mapping(address => uint) private _wards;\\n\\n    /// @dev List of addresses possibly being auth'ed.\\n    /// @dev May contain duplicates.\\n    /// @dev May contain addresses not being auth'ed anymore.\\n    /// @custom:invariant Every address being auth'ed once is element of the list.\\n    ///                     \u2200x \u220a Address: authed(x) -> x \u220a _wardsTouched\\n    address[] private _wardsTouched;\\n\\n    /// @dev Ensures caller is auth'ed.\\n    modifier auth() {\\n        assembly (\\\"memory-safe\\\") {\\n            // Compute slot of _wards[msg.sender].\\n            mstore(0x00, caller())\\n            mstore(0x20, _wards.slot)\\n            let slot := keccak256(0x00, 0x40)\\n\\n            // Revert if caller not auth'ed.\\n            let isAuthed := sload(slot)\\n            if iszero(isAuthed) {\\n                // Store selector of `NotAuthorized(address)`.\\n                mstore(0x00, 0x4a0bfec1)\\n                // Store msg.sender.\\n                mstore(0x20, caller())\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x24)\\n            }\\n        }\\n        _;\\n    }\\n\\n    constructor(address initialAuthed) {\\n        _wards[initialAuthed] = 1;\\n        _wardsTouched.push(initialAuthed);\\n\\n        // Note to use address(0) as caller to indicate address was auth'ed\\n        // during deployment.\\n        emit AuthGranted(address(0), initialAuthed);\\n    }\\n\\n    /// @inheritdoc IAuth\\n    function rely(address who) external auth {\\n        if (_wards[who] == 1) return;\\n\\n        _wards[who] = 1;\\n        _wardsTouched.push(who);\\n        emit AuthGranted(msg.sender, who);\\n    }\\n\\n    /// @inheritdoc IAuth\\n    function deny(address who) external auth {\\n        if (_wards[who] == 0) return;\\n\\n        _wards[who] = 0;\\n        emit AuthRenounced(msg.sender, who);\\n    }\\n\\n    /// @inheritdoc IAuth\\n    function authed(address who) public view returns (bool) {\\n        return _wards[who] == 1;\\n    }\\n\\n    /// @inheritdoc IAuth\\n    /// @custom:invariant Only contains auth'ed addresses.\\n    ///                     \u2200x \u220a authed(): _wards[x] == 1\\n    /// @custom:invariant Contains all auth'ed addresses.\\n    ///                     \u2200x \u220a Address: _wards[x] == 1 \u2192 x \u220a authed()\\n    function authed() public view returns (address[] memory) {\\n        // Initiate array with upper limit length.\\n        address[] memory wardsList = new address[](_wardsTouched.length);\\n\\n        // Iterate through all possible auth'ed addresses.\\n        uint ctr;\\n        for (uint i; i < wardsList.length; i++) {\\n            // Add address only if still auth'ed.\\n            if (_wards[_wardsTouched[i]] == 1) {\\n                wardsList[ctr++] = _wardsTouched[i];\\n            }\\n        }\\n\\n        // Set length of array to number of auth'ed addresses actually included.\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(wardsList, ctr)\\n        }\\n\\n        return wardsList;\\n    }\\n\\n    /// @inheritdoc IAuth\\n    function wards(address who) public view returns (uint) {\\n        return _wards[who];\\n    }\\n}\\n\"\r\n    },\r\n    \"src/IFeedRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\ninterface IFeedRegistry {\\n    /// @notice Thrown if feed `feed` not lifted.\\n    error FeedNotLifted(address feed);\\n\\n    /// @notice Thrown if feed id `feedId` not lifted.\\n    error FeedIdNotLifted(uint8 feedId);\\n\\n    /// @notice Emitted when new feed lifted.\\n    /// @param caller The caller's address.\\n    /// @param feed The feed address lifted.\\n    event FeedLifted(address indexed caller, address indexed feed);\\n\\n    /// @notice Emitted when feed dropped.\\n    /// @param caller The caller's address.\\n    /// @param feed The feed address dropped.\\n    event FeedDropped(address indexed caller, address indexed feed);\\n\\n    // -- Public Read Functions --\\n\\n    /// @notice Returns all of Chronicle Protocol's feeds.\\n    /// @return Chronicle Protocol's feeds.\\n    function feeds() external view returns (address[] memory);\\n\\n    /// @notice Returns whether address `feed` is a feed.\\n    /// @param feed Feed address.\\n    /// @return True if address `feed` is feed, false otherwise.\\n    function feeds(address feed) external view returns (bool);\\n\\n    /// @notice Returns list of feeds `feeds` in bloom encoding.\\n    ///\\n    /// @dev Reverts if:\\n    ///      - Any feed in `feeds` not a feed\\n    ///\\n    /// @param feeds The list of feeds to encode via bloom mechanism.\\n    /// @return Feeds encoded via bloom mechanism.\\n    function encode(address[] calldata feeds) external view returns (uint);\\n\\n    /// @notice Returns list of feeds encoded in `bloom`.\\n    ///\\n    /// @dev Reverts if:\\n    ///      - Any feed encoded in `bloom` not a feed\\n    ///\\n    /// @param bloom The list feeds encoded via bloom mechanism.\\n    /// @return List of feed encoded in `bloom`.\\n    function decode(uint bloom) external view returns (address[] memory);\\n\\n    // -- Auth'ed Functionality --\\n\\n    /// @notice Lifts feed `feed_`.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param feed The feed to lift.\\n    function lift(address feed) external;\\n\\n    /// @notice Lifts feeds `feeds_`.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param feeds The feeds to lift.\\n    function lift(address[] memory feeds) external;\\n\\n    /// @notice Drops feed with feed id `feedId`.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param feedId The feed id to drop.\\n    function drop(uint8 feedId) external;\\n\\n    /// @notice Drops feeds with feed ids `feedIds`.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param feedIds The feed ids to drop.\\n    function drop(uint8[] memory feedIds) external;\\n}\\n\"\r\n    },\r\n    \"lib/chronicle-std/src/auth/IAuth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\ninterface IAuth {\\n    /// @notice Thrown by protected function if caller not auth'ed.\\n    /// @param caller The caller's address.\\n    error NotAuthorized(address caller);\\n\\n    /// @notice Emitted when auth granted to address.\\n    /// @param caller The caller's address.\\n    /// @param who The address auth got granted to.\\n    event AuthGranted(address indexed caller, address indexed who);\\n\\n    /// @notice Emitted when auth renounced from address.\\n    /// @param caller The caller's address.\\n    /// @param who The address auth got renounced from.\\n    event AuthRenounced(address indexed caller, address indexed who);\\n\\n    /// @notice Grants address `who` auth.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param who The address to grant auth.\\n    function rely(address who) external;\\n\\n    /// @notice Renounces address `who`'s auth.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param who The address to renounce auth.\\n    function deny(address who) external;\\n\\n    /// @notice Returns whether address `who` is auth'ed.\\n    /// @param who The address to check.\\n    /// @return True if `who` is auth'ed, false otherwise.\\n    function authed(address who) external view returns (bool);\\n\\n    /// @notice Returns full list of addresses granted auth.\\n    /// @dev May contain duplicates.\\n    /// @return List of addresses granted auth.\\n    function authed() external view returns (address[] memory);\\n\\n    /// @notice Returns whether address `who` is auth'ed.\\n    /// @custom:deprecated Use `authed(address)(bool)` instead.\\n    /// @param who The address to check.\\n    /// @return 1 if `who` is auth'ed, 0 otherwise.\\n    function wards(address who) external view returns (uint);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"chronicle-std/=lib/chronicle-std/src/\",\r\n      \"@script/chronicle-std/=lib/chronicle-std/script/\",\r\n      \"greenhouse/=lib/greenhouse/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialAuthed\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"feedId\",\"type\":\"uint8\"}],\"name\":\"FeedIdNotLifted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feed\",\"type\":\"address\"}],\"name\":\"FeedNotLifted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"NotAuthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"AuthGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"AuthRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feed\",\"type\":\"address\"}],\"name\":\"FeedDropped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feed\",\"type\":\"address\"}],\"name\":\"FeedLifted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"authed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authed\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bloom\",\"type\":\"uint256\"}],\"name\":\"decode\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"feedIds\",\"type\":\"uint8[]\"}],\"name\":\"drop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"feedId\",\"type\":\"uint8\"}],\"name\":\"drop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"feeds_\",\"type\":\"address[]\"}],\"name\":\"encode\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feed\",\"type\":\"address\"}],\"name\":\"feeds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeds\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feed\",\"type\":\"address\"}],\"name\":\"lift\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"feeds_\",\"type\":\"address[]\"}],\"name\":\"lift\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FeedRegistry_1", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000c50dfedb7e93ef7a3daccad7987d0960c4e2cd4b", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}