{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/NDescriptorV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title The Punks NFT descriptor\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { Ownable } from '@openzeppelin/contracts/access/Ownable.sol';\\nimport { Strings } from '@openzeppelin/contracts/utils/Strings.sol';\\nimport { IDescriptorV2 } from './interfaces/IDescriptorV2.sol';\\nimport { ISeeder } from './interfaces/ISeeder.sol';\\nimport { NFTDescriptorV2 } from './libs/NFTDescriptorV2.sol';\\nimport { ISVGRenderer } from './interfaces/ISVGRenderer.sol';\\nimport { IArt } from './interfaces/IArt.sol';\\nimport { IInflator } from './interfaces/IInflator.sol';\\n\\ncontract NDescriptorV2 is IDescriptorV2, Ownable {\\n    using Strings for uint256;\\n\\n    // prettier-ignore\\n    // https://creativecommons.org/publicdomain/zero/1.0/legalcode.txt\\n    bytes32 constant COPYRIGHT_CC0_1_0_UNIVERSAL_LICENSE = 0xa2010f343487d3f7618affe54f789f5487602331c0a8d03f49e9a7c547cf0499;\\n\\n    /// @notice The contract responsible for holding compressed Punk art\\n    IArt public art;\\n\\n    /// @notice The contract responsible for constructing SVGs\\n    ISVGRenderer public renderer;\\n\\n    /// @notice Whether or not new Punk parts can be added\\n    bool public override arePartsLocked;\\n\\n    /// @notice Whether or not `tokenURI` should be returned as a data URI (Default: true)\\n    bool public override isDataURIEnabled = true;\\n\\n    /// @notice Base URI, used when isDataURIEnabled is false\\n    string public override baseURI;\\n\\n    /**\\n     * @notice Require that the parts have not been locked.\\n     */\\n    modifier whenPartsNotLocked() {\\n        require(!arePartsLocked, 'locked');\\n        _;\\n    }\\n\\n    constructor(IArt _art, ISVGRenderer _renderer) {\\n        art = _art;\\n        renderer = _renderer;\\n    }\\n\\n    /**\\n     * @notice Set the Punk's art contract.\\n     * @dev Only callable by the owner when not locked.\\n     */\\n    function setArt(IArt _art) external onlyOwner whenPartsNotLocked {\\n        art = _art;\\n\\n        emit ArtUpdated(_art);\\n    }\\n\\n    /**\\n     * @notice Set the SVG renderer.\\n     * @dev Only callable by the owner.\\n     * Reversible. Only view functions. No need to lock.\\n     */\\n    function setRenderer(ISVGRenderer _renderer) external onlyOwner {\\n        renderer = _renderer;\\n\\n        emit RendererUpdated(_renderer);\\n    }\\n\\n    /**\\n     * @notice Set the art contract's `descriptor`.\\n     * @param descriptor the address to set.\\n     * @dev Only callable by the owner.\\n     */\\n    function setArtDescriptor(address descriptor) external onlyOwner whenPartsNotLocked {\\n        art.setDescriptor(descriptor);\\n    }\\n\\n    /**\\n     * @notice Set the art contract's `inflator`.\\n     * @param inflator the address to set.\\n     * @dev Only callable by the owner.\\n     * Reversible. Only view functions. No need to lock.\\n     */\\n    function setArtInflator(IInflator inflator) external onlyOwner {\\n        art.setInflator(inflator);\\n    }\\n\\n    /**\\n     * @notice Get the number of available Punk `bodies`.\\n     */\\n    function punkTypeCount() external view override returns (uint256) {\\n        return art.getPunkTypesTrait().storedImagesCount;\\n    }\\n    function hatCount() external view override returns (uint256) {\\n        return art.getHatsTrait().storedImagesCount;\\n    }\\n    function helmetCount() external view override returns (uint256) {\\n        return art.getHelmetsTrait().storedImagesCount;\\n    }\\n    function hairCount() external view override returns (uint256) {\\n        return art.getHairsTrait().storedImagesCount;\\n    }\\n    function beardCount() external view override returns (uint256) {\\n        return art.getBeardsTrait().storedImagesCount;\\n    }\\n    function eyesCount() external view override returns (uint256) {\\n        return art.getEyesesTrait().storedImagesCount;\\n    }\\n    function glassesCount() external view override returns (uint256) {\\n        return art.getGlassesesTrait().storedImagesCount;\\n    }\\n    function gogglesCount() external view override returns (uint256) {\\n        return art.getGogglesesTrait().storedImagesCount;\\n    }\\n    function mouthCount() external view override returns (uint256) {\\n        return art.getMouthsTrait().storedImagesCount;\\n    }\\n    function teethCount() external view override returns (uint256) {\\n        return art.getTeethsTrait().storedImagesCount;\\n    }\\n    function lipsCount() external view override returns (uint256) {\\n        return art.getLipsesTrait().storedImagesCount;\\n    }\\n    function neckCount() external view override returns (uint256) {\\n        return art.getNecksTrait().storedImagesCount;\\n    }\\n    function emotionCount() external view override returns (uint256) {\\n        return art.getEmotionsTrait().storedImagesCount;\\n    }\\n    function faceCount() external view override returns (uint256) {\\n        return art.getFacesTrait().storedImagesCount;\\n    }\\n    function earsCount() external view override returns (uint256) {\\n        return art.getEarsesTrait().storedImagesCount;\\n    }\\n    function noseCount() external view override returns (uint256) {\\n        return art.getNosesTrait().storedImagesCount;\\n    }\\n    function cheeksCount() external view override returns (uint256) {\\n        return art.getCheeksesTrait().storedImagesCount;\\n    }\\n\\n    /**\\n     * @notice Update a single color palette. This function can be used to\\n     * add a new color palette or update an existing palette.\\n     * @param paletteIndex the identifier of this palette\\n     * @param palette byte array of colors. every 3 bytes represent an RGB color. max length: 256 * 3 = 768\\n     * @dev This function can only be called by the owner when not locked.\\n     */\\n    function setPalette(uint8 paletteIndex, bytes calldata palette) external override onlyOwner whenPartsNotLocked {\\n        art.setPalette(paletteIndex, palette);\\n    }\\n\\n    /**\\n     * @notice Add a batch of body images.\\n     * @param encodedCompressed bytes created by taking a string array of RLE-encoded images, abi encoding it as a bytes array,\\n     * and finally compressing it using deflate.\\n     * @param decompressedLength the size in bytes the images bytes were prior to compression; required input for Inflate.\\n     * @param imageCount the number of images in this batch; used when searching for images among batches.\\n     * @dev This function can only be called by the owner when not locked.\\n     */\\n    function addPunkTypes(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addPunkTypes(encodedCompressed, decompressedLength, imageCount);\\n    }\\n    function addHats(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addHats(encodedCompressed, decompressedLength, imageCount);\\n    }\\n    function addHelmets(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addHelmets(encodedCompressed, decompressedLength, imageCount);\\n    }\\n    function addHairs(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addHairs(encodedCompressed, decompressedLength, imageCount);\\n    }\\n    function addBeards(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addBeards(encodedCompressed, decompressedLength, imageCount);\\n    }\\n    function addEyeses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addEyeses(encodedCompressed, decompressedLength, imageCount);\\n    }\\n    function addGlasseses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addGlasseses(encodedCompressed, decompressedLength, imageCount);\\n    }\\n    function addGoggleses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addGoggleses(encodedCompressed, decompressedLength, imageCount);\\n    }\\n    function addMouths(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addMouths(encodedCompressed, decompressedLength, imageCount);\\n    }\\n    function addTeeths(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addTeeths(encodedCompressed, decompressedLength, imageCount);\\n    }\\n    function addLipses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addLipses(encodedCompressed, decompressedLength, imageCount);\\n    }\\n    function addNecks(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addNecks(encodedCompressed, decompressedLength, imageCount);\\n    }\\n    function addEmotions(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addEmotions(encodedCompressed, decompressedLength, imageCount);\\n    }\\n    function addFaces(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addFaces(encodedCompressed, decompressedLength, imageCount);\\n    }\\n    function addEarses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addEarses(encodedCompressed, decompressedLength, imageCount);\\n    }\\n    function addNoses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addNoses(encodedCompressed, decompressedLength, imageCount);\\n    }\\n    function addCheekses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addCheekses(encodedCompressed, decompressedLength, imageCount);\\n    }\\n\\n    /**\\n     * @notice Update a single color palette. This function can be used to\\n     * add a new color palette or update an existing palette. This function does not check for data length validity\\n     * (len <= 768, len % 3 == 0).\\n     * @param paletteIndex the identifier of this palette\\n     * @param pointer the address of the contract holding the palette bytes. every 3 bytes represent an RGB color.\\n     * max length: 256 * 3 = 768.\\n     * @dev This function can only be called by the owner when not locked.\\n     */\\n    function setPalettePointer(uint8 paletteIndex, address pointer) external override onlyOwner whenPartsNotLocked {\\n        art.setPalettePointer(paletteIndex, pointer);\\n    }\\n\\n    /**\\n     * @notice Add a batch of body images from an existing storage contract.\\n     * @param pointer the address of a contract where the image batch was stored using SSTORE2. The data\\n     * format is expected to be like {encodedCompressed}: bytes created by taking a string array of\\n     * RLE-encoded images, abi encoding it as a bytes array, and finally compressing it using deflate.\\n     * @param decompressedLength the size in bytes the images bytes were prior to compression; required input for Inflate.\\n     * @param imageCount the number of images in this batch; used when searching for images among batches.\\n     * @dev This function can only be called by the owner when not locked.\\n     */\\n    function addPunkTypesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addPunkTypesFromPointer(pointer, decompressedLength, imageCount);\\n    }\\n    function addHatsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addHatsFromPointer(pointer, decompressedLength, imageCount);\\n    }\\n    function addHelmetsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addHelmetsFromPointer(pointer, decompressedLength, imageCount);\\n    }\\n    function addHairsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addHairsFromPointer(pointer, decompressedLength, imageCount);\\n    }\\n    function addBeardsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addBeardsFromPointer(pointer, decompressedLength, imageCount);\\n    }\\n    function addEyesesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addEyesesFromPointer(pointer, decompressedLength, imageCount);\\n    }\\n    function addGlassesesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addGlassesesFromPointer(pointer, decompressedLength, imageCount);\\n    }\\n    function addGogglesesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addGogglesesFromPointer(pointer, decompressedLength, imageCount);\\n    }\\n    function addMouthsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addMouthsFromPointer(pointer, decompressedLength, imageCount);\\n    }\\n    function addTeethsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addTeethsFromPointer(pointer, decompressedLength, imageCount);\\n    }\\n    function addLipsesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addLipsesFromPointer(pointer, decompressedLength, imageCount);\\n    }\\n    function addNecksFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addNecksFromPointer(pointer, decompressedLength, imageCount);\\n    }\\n    function addEmotionsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addEmotionsFromPointer(pointer, decompressedLength, imageCount);\\n    }\\n    function addFacesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addFacesFromPointer(pointer, decompressedLength, imageCount);\\n    }\\n    function addEarsesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addEarsesFromPointer(pointer, decompressedLength, imageCount);\\n    }\\n    function addNosesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addNosesFromPointer(pointer, decompressedLength, imageCount);\\n    }\\n    function addCheeksesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addCheeksesFromPointer(pointer, decompressedLength, imageCount);\\n    }\\n\\n    /**\\n     * @notice Get a background color by ID.\\n     * @param index the index of the background.\\n     * @return string the RGB hex value of the background.\\n     */\\n    // function backgrounds(uint256 index) public view override returns (string memory) {\\n    //     return art.backgrounds(index);\\n    // }\\n\\n    /**\\n     * @notice Get a head image by ID.\\n     * @param index the index of the head.\\n     * @return bytes the RLE-encoded bytes of the image.\\n     */\\n    function punkTypes(uint256 index) public view override returns (bytes memory) {\\n        return art.punkTypes(index);\\n    }\\n    function hats(uint256 index) public view override returns (bytes memory) {\\n        return art.hats(index);\\n    }\\n    function helmets(uint256 index) public view override returns (bytes memory) {\\n        return art.helmets(index);\\n    }\\n    function hairs(uint256 index) public view override returns (bytes memory) {\\n        return art.hairs(index);\\n    }\\n    function beards(uint256 index) public view override returns (bytes memory) {\\n        return art.beards(index);\\n    }\\n    function eyeses(uint256 index) public view override returns (bytes memory) {\\n        return art.eyeses(index);\\n    }\\n    function glasseses(uint256 index) public view override returns (bytes memory) {\\n        return art.glasseses(index);\\n    }\\n    function goggleses(uint256 index) public view override returns (bytes memory) {\\n        return art.goggleses(index);\\n    }\\n    function mouths(uint256 index) public view override returns (bytes memory) {\\n        return art.mouths(index);\\n    }\\n    function teeths(uint256 index) public view override returns (bytes memory) {\\n        return art.teeths(index);\\n    }\\n    function lipses(uint256 index) public view override returns (bytes memory) {\\n        return art.lipses(index);\\n    }\\n    function necks(uint256 index) public view override returns (bytes memory) {\\n        return art.necks(index);\\n    }\\n    function emotions(uint256 index) public view override returns (bytes memory) {\\n        return art.emotions(index);\\n    }\\n    function faces(uint256 index) public view override returns (bytes memory) {\\n        return art.faces(index);\\n    }\\n    function earses(uint256 index) public view override returns (bytes memory) {\\n        return art.earses(index);\\n    }\\n    function noses(uint256 index) public view override returns (bytes memory) {\\n        return art.noses(index);\\n    }\\n    function cheekses(uint256 index) public view override returns (bytes memory) {\\n        return art.cheekses(index);\\n    }\\n\\n    /**\\n     * @notice Get a color palette by ID.\\n     * @param index the index of the palette.\\n     * @return bytes the palette bytes, where every 3 consecutive bytes represent a color in RGB format.\\n     */\\n    function palettes(uint8 index) public view override returns (bytes memory) {\\n        return art.palettes(index);\\n    }\\n\\n    /**\\n     * @notice Lock all Punk parts.\\n     * @dev This cannot be reversed and can only be called by the owner when not locked.\\n     */\\n    function lockParts() external override onlyOwner whenPartsNotLocked {\\n        arePartsLocked = true;\\n\\n        emit PartsLocked();\\n    }\\n\\n    /**\\n     * @notice Toggle a boolean value which determines if `tokenURI` returns a data URI\\n     * or an HTTP URL.\\n     * @dev This can only be called by the owner.\\n     */\\n    function toggleDataURIEnabled() external override onlyOwner {\\n        bool enabled = !isDataURIEnabled;\\n\\n        isDataURIEnabled = enabled;\\n        emit DataURIToggled(enabled);\\n    }\\n\\n    /**\\n     * @notice Set the base URI for all token IDs. It is automatically\\n     * added as a prefix to the value returned in {tokenURI}, or to the\\n     * token ID if {tokenURI} is empty.\\n     * @dev This can only be called by the owner.\\n     */\\n    function setBaseURI(string calldata _baseURI) external override onlyOwner {\\n        baseURI = _baseURI;\\n\\n        emit BaseURIUpdated(_baseURI);\\n    }\\n\\n    /**\\n     * @notice Given a token ID and seed, construct a token URI for an official Punks DAO token.\\n     * @dev The returned value may be a base64 encoded data URI or an API URL.\\n     */\\n    function tokenURI(uint256 tokenId, ISeeder.Seed memory seed) external view override returns (string memory) {\\n        if (isDataURIEnabled) {\\n            return dataURI(tokenId, seed);\\n        }\\n        return string(abi.encodePacked(baseURI, tokenId.toString()));\\n    }\\n\\n    /**\\n     * @notice Given a token ID and seed, construct a base64 encoded data URI for an official NDAO token.\\n     */\\n    function dataURI(uint256 tokenId, ISeeder.Seed memory seed) public view override returns (string memory) {\\n        string memory punkId = tokenId.toString();\\n        string memory name = string(abi.encodePacked('DAOpunk ', punkId));\\n        string memory description = string(abi.encodePacked('DAOpunk ', punkId, ' is a member of the Punkers DAO'));\\n\\n        return genericDataURI(name, description, seed);\\n    }\\n\\n    /**\\n     * @notice Given a name, description, and seed, construct a base64 encoded data URI.\\n     */\\n    function genericDataURI(\\n        string memory name,\\n        string memory description,\\n        ISeeder.Seed memory seed\\n    ) public view override returns (string memory) {\\n        NFTDescriptorV2.TokenURIParams memory params = NFTDescriptorV2.TokenURIParams({\\n            name: name,\\n            description: description,\\n            parts: getPartsForSeed(seed)\\n        });\\n        return NFTDescriptorV2.constructTokenURI(renderer, params);\\n    }\\n\\n    /**\\n     * @notice Given a seed, construct a base64 encoded SVG image.\\n     */\\n    function generateSVGImage(ISeeder.Seed memory seed) external view override returns (string memory) {\\n        ISVGRenderer.SVGParams memory params = ISVGRenderer.SVGParams({\\n            parts: getPartsForSeed(seed)\\n        });\\n        return NFTDescriptorV2.generateSVGImage(renderer, params);\\n    }\\n\\n    /**\\n     * @notice Get all Punk parts for the passed `seed`.\\n     */\\n    function getPartsForSeed(ISeeder.Seed memory seed) public view returns (ISVGRenderer.Part[] memory) {\\n        ISVGRenderer.Part[] memory parts = new ISVGRenderer.Part[](seed.accessories.length + 1);\\n\\n        bytes memory accBuffer;\\n        uint256 punkTypeId;\\n        if (seed.punkType == 0) {\\n            punkTypeId = seed.skinTone;\\n        } else if (seed.punkType == 1) {\\n            punkTypeId = 4 + seed.skinTone;\\n        } else {\\n            punkTypeId = 6 + seed.punkType;\\n        }\\n        accBuffer = art.punkTypes(punkTypeId);\\n        parts[0] = ISVGRenderer.Part({ image: accBuffer, palette: _getPalette(accBuffer) });\\n\\n        uint256[] memory sortedAccessories = new uint256[](16);\\n        for (uint256 i = 0 ; i < seed.accessories.length; i ++) {\\n            // 10_000 is a trick so filled entries are not zero\\n            unchecked {\\n                sortedAccessories[seed.accessories[i].accType] = 10_000 + seed.accessories[i].accId;\\n            }\\n        }\\n\\n        uint256 idx = 1; // starts from 1, 0 is taken by punkType\\n        for(uint i = 0; i < 16; i ++) {\\n            if (sortedAccessories[i] > 0) {\\n                // i is accType\\n                uint256 accIdImage = sortedAccessories[i] % 10_000;\\n                if(i == 0) accBuffer = art.necks(accIdImage);\\n                else if(i == 1) accBuffer = art.cheekses(accIdImage);\\n                else if(i == 2) accBuffer = art.faces(accIdImage);\\n                else if(i == 3) accBuffer = art.lipses(accIdImage);\\n                else if(i == 4) accBuffer = art.emotions(accIdImage);\\n                else if(i == 5) accBuffer = art.teeths(accIdImage);\\n                else if(i == 6) accBuffer = art.beards(accIdImage);\\n                else if(i == 7) accBuffer = art.earses(accIdImage);\\n                else if(i == 8) accBuffer = art.hats(accIdImage);\\n                else if(i == 9) accBuffer = art.helmets(accIdImage);\\n                else if(i == 10) accBuffer = art.hairs(accIdImage);\\n                else if(i == 11) accBuffer = art.mouths(accIdImage);\\n                else if(i == 12) accBuffer = art.glasseses(accIdImage);\\n                else if(i == 13) accBuffer = art.goggleses(accIdImage);\\n                else if(i == 14) accBuffer = art.eyeses(accIdImage);\\n                else if(i == 15) accBuffer = art.noses(accIdImage);\\n                else revert();\\n                parts[idx] = ISVGRenderer.Part({ image: accBuffer, palette: _getPalette(accBuffer) });\\n                idx ++;\\n            }\\n        }\\n        return parts;\\n    }\\n\\n    /**\\n     * @notice Get the color palette pointer for the passed part.\\n     */\\n    function _getPalette(bytes memory part) private view returns (bytes memory) {\\n        return art.palettes(uint8(part[0]));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDescriptorV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Interface for NDescriptorV2\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { ISeeder } from './ISeeder.sol';\\nimport { ISVGRenderer } from './ISVGRenderer.sol';\\nimport { IArt } from './IArt.sol';\\nimport { IDescriptorMinimal } from './IDescriptorMinimal.sol';\\n\\ninterface IDescriptorV2 is IDescriptorMinimal {\\n    event PartsLocked();\\n\\n    event DataURIToggled(bool enabled);\\n\\n    event BaseURIUpdated(string baseURI);\\n\\n    event ArtUpdated(IArt art);\\n\\n    event RendererUpdated(ISVGRenderer renderer);\\n\\n    error EmptyPalette();\\n    error BadPaletteLength();\\n    error IndexNotFound();\\n\\n    function arePartsLocked() external returns (bool);\\n\\n    function isDataURIEnabled() external returns (bool);\\n\\n    function baseURI() external returns (string memory);\\n\\n    function palettes(uint8 paletteIndex) external view returns (bytes memory);\\n\\n\\n    function punkTypes(uint256 index) external view returns (bytes memory);\\n    function hats(uint256 index) external view returns (bytes memory);\\n    function helmets(uint256 index) external view returns (bytes memory);\\n    function hairs(uint256 index) external view returns (bytes memory);\\n    function beards(uint256 index) external view returns (bytes memory);\\n    function eyeses(uint256 index) external view returns (bytes memory);\\n    function glasseses(uint256 index) external view returns (bytes memory);\\n    function goggleses(uint256 index) external view returns (bytes memory);\\n    function mouths(uint256 index) external view returns (bytes memory);\\n    function teeths(uint256 index) external view returns (bytes memory);\\n    function lipses(uint256 index) external view returns (bytes memory);\\n    function necks(uint256 index) external view returns (bytes memory);\\n    function emotions(uint256 index) external view returns (bytes memory);\\n    function faces(uint256 index) external view returns (bytes memory);\\n    function earses(uint256 index) external view returns (bytes memory);\\n    function noses(uint256 index) external view returns (bytes memory);\\n    function cheekses(uint256 index) external view returns (bytes memory);\\n\\n    function punkTypeCount() external view override returns (uint256);\\n    function hatCount() external view override returns (uint256);\\n    function helmetCount() external view override returns (uint256);\\n    function hairCount() external view override returns (uint256);\\n    function beardCount() external view override returns (uint256);\\n    function eyesCount() external view override returns (uint256);\\n    function glassesCount() external view override returns (uint256);\\n    function gogglesCount() external view override returns (uint256);\\n    function mouthCount() external view override returns (uint256);\\n    function teethCount() external view override returns (uint256);\\n    function lipsCount() external view override returns (uint256);\\n    function neckCount() external view override returns (uint256);\\n    function emotionCount() external view override returns (uint256);\\n    function faceCount() external view override returns (uint256);\\n    function earsCount() external view override returns (uint256);\\n    function noseCount() external view override returns (uint256);\\n    function cheeksCount() external view override returns (uint256);\\n\\n    function setPalette(uint8 paletteIndex, bytes calldata palette) external;\\n\\n    function addPunkTypes(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addHats(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addHelmets(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addHairs(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addBeards(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addEyeses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addGlasseses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addGoggleses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addMouths(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addTeeths(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addLipses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addNecks(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addEmotions(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addFaces(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addEarses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addNoses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addCheekses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function setPalettePointer(uint8 paletteIndex, address pointer) external;\\n\\n    function addPunkTypesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addHatsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addHelmetsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addHairsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addBeardsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addEyesesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addGlassesesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addGogglesesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addMouthsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addTeethsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addLipsesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addNecksFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addEmotionsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addFacesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addEarsesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addNosesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addCheeksesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function lockParts() external;\\n\\n    function toggleDataURIEnabled() external;\\n\\n    function setBaseURI(string calldata baseURI) external;\\n\\n    function tokenURI(uint256 tokenId, ISeeder.Seed memory seed) external view override returns (string memory);\\n\\n    function dataURI(uint256 tokenId, ISeeder.Seed memory seed) external view override returns (string memory);\\n\\n    function genericDataURI(\\n        string calldata name,\\n        string calldata description,\\n        ISeeder.Seed memory seed\\n    ) external view returns (string memory);\\n\\n    function generateSVGImage(ISeeder.Seed memory seed) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISeeder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Interface for NSeeder\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\ninterface ISeeder {\\n    struct Accessory {\\n        uint16 accType;\\n        uint16 accId;\\n    }\\n    struct Seed {\\n        uint8 punkType;\\n        uint8 skinTone;\\n        Accessory[] accessories;\\n    }\\n\\n    function generateSeed(uint256 punkId, uint256 salt) external view returns (Seed memory);\\n}\\n\"\r\n    },\r\n    \"contracts/libs/NFTDescriptorV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title A library used to construct ERC721 token URIs and SVG images\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { Base64 } from 'base64-sol/base64.sol';\\nimport { ISVGRenderer } from '../interfaces/ISVGRenderer.sol';\\n\\nlibrary NFTDescriptorV2 {\\n    struct TokenURIParams {\\n        string name;\\n        string description;\\n//        string background;\\n        ISVGRenderer.Part[] parts;\\n    }\\n\\n    /**\\n     * @notice Construct an ERC721 token URI.\\n     */\\n    function constructTokenURI(ISVGRenderer renderer, TokenURIParams memory params)\\n        public\\n        view\\n        returns (string memory)\\n    {\\n        string memory image = generateSVGImage(\\n            renderer,\\n            ISVGRenderer.SVGParams({ parts: params.parts/*, background: params.background */})\\n        );\\n\\n        // prettier-ignore\\n        return string(\\n            abi.encodePacked(\\n                'data:application/json;base64,',\\n                Base64.encode(\\n                    bytes(\\n                        abi.encodePacked('{\\\"name\\\":\\\"', params.name, '\\\", \\\"description\\\":\\\"', params.description, '\\\", \\\"image\\\": \\\"', 'data:image/svg+xml;base64,', image, '\\\"}')\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Generate an SVG image for use in the ERC721 token URI.\\n     */\\n    function generateSVGImage(ISVGRenderer renderer, ISVGRenderer.SVGParams memory params)\\n        public\\n        view\\n        returns (string memory svg)\\n    {\\n        return Base64.encode(bytes(renderer.generateSVG(params)));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISVGRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Interface for SVGRenderer\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\ninterface ISVGRenderer {\\n    struct Part {\\n        bytes image;\\n        bytes palette;\\n    }\\n\\n    struct SVGParams {\\n        Part[] parts;\\n//        string background;\\n    }\\n\\n    function generateSVG(SVGParams memory params) external view returns (string memory svg);\\n\\n    function generateSVGPart(Part memory part) external view returns (string memory partialSVG);\\n\\n    function generateSVGParts(Part[] memory parts) external view returns (string memory partialSVG);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IArt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Interface for NArt\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { Inflate } from '../libs/Inflate.sol';\\nimport { IInflator } from './IInflator.sol';\\n\\ninterface IArt {\\n    error SenderIsNotDescriptor();\\n\\n    error EmptyPalette();\\n\\n    error BadPaletteLength();\\n\\n    error EmptyBytes();\\n\\n    error BadDecompressedLength();\\n\\n    error BadImageCount();\\n\\n    error ImageNotFound();\\n\\n    error PaletteNotFound();\\n\\n    event DescriptorUpdated(address oldDescriptor, address newDescriptor);\\n\\n    event InflatorUpdated(address oldInflator, address newInflator);\\n\\n    event PaletteSet(uint8 paletteIndex);\\n\\n    event PunkTypesAdded(uint16 count);\\n    event HatsAdded(uint16 count);\\n    event HelmetsAdded(uint16 count);\\n    event HairsAdded(uint16 count);\\n    event BeardsAdded(uint16 count);\\n    event EyesesAdded(uint16 count);\\n    event GlassesesAdded(uint16 count);\\n    event GogglesesAdded(uint16 count);\\n    event MouthsAdded(uint16 count);\\n    event TeethsAdded(uint16 count);\\n    event LipsesAdded(uint16 count);\\n    event NecksAdded(uint16 count);\\n    event EmotionsAdded(uint16 count);\\n    event FacesAdded(uint16 count);\\n    event EarsesAdded(uint16 count);\\n    event NosesAdded(uint16 count);\\n    event CheeksesAdded(uint16 count);\\n\\n    struct NArtStoragePage {\\n        uint16 imageCount;\\n        uint80 decompressedLength;\\n        address pointer;\\n    }\\n\\n    struct Trait {\\n        NArtStoragePage[] storagePages;\\n        uint256 storedImagesCount;\\n    }\\n\\n    function descriptor() external view returns (address);\\n\\n    function inflator() external view returns (IInflator);\\n\\n    function setDescriptor(address descriptor) external;\\n\\n    function setInflator(IInflator inflator) external;\\n\\n    function palettes(uint8 paletteIndex) external view returns (bytes memory);\\n\\n    function setPalette(uint8 paletteIndex, bytes calldata palette) external;\\n\\n    function addPunkTypes(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addHats(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addHelmets(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addHairs(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addBeards(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addEyeses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addGlasseses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addGoggleses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addMouths(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addTeeths(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addLipses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addNecks(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addEmotions(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addFaces(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addEarses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addNoses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addCheekses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function setPalettePointer(uint8 paletteIndex, address pointer) external;\\n\\n    function addPunkTypesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addHatsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addHelmetsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addHairsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addBeardsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addEyesesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addGlassesesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addGogglesesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addMouthsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addTeethsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addLipsesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addNecksFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addEmotionsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addFacesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addEarsesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addNosesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addCheeksesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n\\n    function punkTypes(uint256 index) external view returns (bytes memory);\\n    function hats(uint256 index) external view returns (bytes memory);\\n    function helmets(uint256 index) external view returns (bytes memory);\\n    function hairs(uint256 index) external view returns (bytes memory);\\n    function beards(uint256 index) external view returns (bytes memory);\\n    function eyeses(uint256 index) external view returns (bytes memory);\\n    function glasseses(uint256 index) external view returns (bytes memory);\\n    function goggleses(uint256 index) external view returns (bytes memory);\\n    function mouths(uint256 index) external view returns (bytes memory);\\n    function teeths(uint256 index) external view returns (bytes memory);\\n    function lipses(uint256 index) external view returns (bytes memory);\\n    function necks(uint256 index) external view returns (bytes memory);\\n    function emotions(uint256 index) external view returns (bytes memory);\\n    function faces(uint256 index) external view returns (bytes memory);\\n    function earses(uint256 index) external view returns (bytes memory);\\n    function noses(uint256 index) external view returns (bytes memory);\\n    function cheekses(uint256 index) external view returns (bytes memory);\\n\\n    function getPunkTypesTrait() external view returns (Trait memory);\\n    function getHatsTrait() external view returns (Trait memory);\\n    function getHelmetsTrait() external view returns (Trait memory);\\n    function getHairsTrait() external view returns (Trait memory);\\n    function getBeardsTrait() external view returns (Trait memory);\\n    function getEyesesTrait() external view returns (Trait memory);\\n    function getGlassesesTrait() external view returns (Trait memory);\\n    function getGogglesesTrait() external view returns (Trait memory);\\n    function getMouthsTrait() external view returns (Trait memory);\\n    function getTeethsTrait() external view returns (Trait memory);\\n    function getLipsesTrait() external view returns (Trait memory);\\n    function getNecksTrait() external view returns (Trait memory);\\n    function getEmotionsTrait() external view returns (Trait memory);\\n    function getFacesTrait() external view returns (Trait memory);\\n    function getEarsesTrait() external view returns (Trait memory);\\n    function getNosesTrait() external view returns (Trait memory);\\n    function getCheeksesTrait() external view returns (Trait memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IInflator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Interface for Inflator\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { Inflate } from '../libs/Inflate.sol';\\n\\ninterface IInflator {\\n    function puff(bytes memory source, uint256 destlen) external pure returns (Inflate.ErrorCode, bytes memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDescriptorMinimal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Common interface for NDescriptor versions, as used by NToken and NSeeder.\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { ISeeder } from './ISeeder.sol';\\n\\ninterface IDescriptorMinimal {\\n    ///\\n    /// USED BY TOKEN\\n    ///\\n\\n    function tokenURI(uint256 tokenId, ISeeder.Seed memory seed) external view returns (string memory);\\n\\n    function dataURI(uint256 tokenId, ISeeder.Seed memory seed) external view returns (string memory);\\n\\n    ///\\n    /// USED BY SEEDER\\n    ///\\n\\n    function punkTypeCount() external view returns (uint256);\\n    function hatCount() external view returns (uint256);\\n    function helmetCount() external view returns (uint256);\\n    function hairCount() external view returns (uint256);\\n    function beardCount() external view returns (uint256);\\n    function eyesCount() external view returns (uint256);\\n    function glassesCount() external view returns (uint256);\\n    function gogglesCount() external view returns (uint256);\\n    function mouthCount() external view returns (uint256);\\n    function teethCount() external view returns (uint256);\\n    function lipsCount() external view returns (uint256);\\n    function neckCount() external view returns (uint256);\\n    function emotionCount() external view returns (uint256);\\n    function faceCount() external view returns (uint256);\\n    function earsCount() external view returns (uint256);\\n    function noseCount() external view returns (uint256);\\n    function cheeksCount() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/libs/Inflate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/// @notice Based on https://github.com/madler/zlib/blob/master/contrib/puff\\n/// @dev Modified the original code for gas optimizations\\n/// 1. Disable overflow/underflow checks\\n/// 2. Chunk some loop iterations\\nlibrary Inflate {\\n    // Maximum bits in a code\\n    uint256 constant MAXBITS = 15;\\n    // Maximum number of literal/length codes\\n    uint256 constant MAXLCODES = 286;\\n    // Maximum number of distance codes\\n    uint256 constant MAXDCODES = 30;\\n    // Maximum codes lengths to read\\n    uint256 constant MAXCODES = (MAXLCODES + MAXDCODES);\\n    // Number of fixed literal/length codes\\n    uint256 constant FIXLCODES = 288;\\n\\n    // Error codes\\n    enum ErrorCode {\\n        ERR_NONE, // 0 successful inflate\\n        ERR_NOT_TERMINATED, // 1 available inflate data did not terminate\\n        ERR_OUTPUT_EXHAUSTED, // 2 output space exhausted before completing inflate\\n        ERR_INVALID_BLOCK_TYPE, // 3 invalid block type (type == 3)\\n        ERR_STORED_LENGTH_NO_MATCH, // 4 stored block length did not match one's complement\\n        ERR_TOO_MANY_LENGTH_OR_DISTANCE_CODES, // 5 dynamic block code description: too many length or distance codes\\n        ERR_CODE_LENGTHS_CODES_INCOMPLETE, // 6 dynamic block code description: code lengths codes incomplete\\n        ERR_REPEAT_NO_FIRST_LENGTH, // 7 dynamic block code description: repeat lengths with no first length\\n        ERR_REPEAT_MORE, // 8 dynamic block code description: repeat more than specified lengths\\n        ERR_INVALID_LITERAL_LENGTH_CODE_LENGTHS, // 9 dynamic block code description: invalid literal/length code lengths\\n        ERR_INVALID_DISTANCE_CODE_LENGTHS, // 10 dynamic block code description: invalid distance code lengths\\n        ERR_MISSING_END_OF_BLOCK, // 11 dynamic block code description: missing end-of-block code\\n        ERR_INVALID_LENGTH_OR_DISTANCE_CODE, // 12 invalid literal/length or distance code in fixed or dynamic block\\n        ERR_DISTANCE_TOO_FAR, // 13 distance is too far back in fixed or dynamic block\\n        ERR_CONSTRUCT // 14 internal: error in construct()\\n    }\\n\\n    // Input and output state\\n    struct State {\\n        //////////////////\\n        // Output state //\\n        //////////////////\\n        // Output buffer\\n        bytes output;\\n        // Bytes written to out so far\\n        uint256 outcnt;\\n        /////////////////\\n        // Input state //\\n        /////////////////\\n        // Input buffer\\n        bytes input;\\n        // Bytes read so far\\n        uint256 incnt;\\n        ////////////////\\n        // Temp state //\\n        ////////////////\\n        // Bit buffer\\n        uint256 bitbuf;\\n        // Number of bits in bit buffer\\n        uint256 bitcnt;\\n        //////////////////////////\\n        // Static Huffman codes //\\n        //////////////////////////\\n        Huffman lencode;\\n        Huffman distcode;\\n    }\\n\\n    // Huffman code decoding tables\\n    struct Huffman {\\n        uint256[] counts;\\n        uint256[] symbols;\\n    }\\n\\n    function bits(State memory s, uint256 need) private pure returns (uint256) {\\n        unchecked {\\n            // Bit accumulator (can use up to 20 bits)\\n            uint256 val;\\n\\n            // Load at least need bits into val\\n            val = s.bitbuf;\\n            while (s.bitcnt < need) {\\n                require(s.incnt < s.input.length, \\\"Inflate: ErrorCode.ERR_NOT_TERMINATED\\\");\\n\\n                // Load eight bits\\n                // val |= uint256(uint8(s.input[s.incnt])) << s.bitcnt;\\n                // array length check is skipped\\n                assembly {\\n                    val := or(val, shl(mload(add(s, 0xa0)), shr(0xf8, mload(add(add(mload(add(s, 0x40)), 0x20), mload(add(s, 0x60)))))))\\n                }\\n                s.incnt++;\\n                s.bitcnt += 8;\\n            }\\n\\n            // Drop need bits and update buffer, always zero to seven bits left\\n            s.bitbuf = val >> need;\\n            s.bitcnt -= need;\\n\\n            // Return need bits, zeroing the bits above that\\n            uint256 ret = (val & ((1 << need) - 1));\\n            return ret;\\n        }\\n    }\\n\\n    function bits1(State memory s) private pure returns (uint256) {\\n        unchecked {\\n            uint256 val;\\n            if (s.bitcnt > 0) {\\n                val = s.bitbuf & 0x1;\\n                s.bitbuf >>= 1;\\n                s.bitcnt--;\\n            } else {\\n                require(s.incnt < s.input.length, \\\"Inflate: ErrorCode.ERR_NOT_TERMINATED\\\");\\n                // val = uint256(uint8(s.input[s.incnt]));\\n                // array length check is skipped\\n                assembly {\\n                    val := shr(0xf8, mload(add(add(mload(add(s, 0x40)), 0x20), mload(add(s, 0x60)))))\\n                }\\n                s.bitbuf = val >> 1;\\n                val &= 0x1;\\n                s.bitcnt = 7;\\n                s.incnt++;\\n            }\\n            return val;\\n        }\\n    }\\n\\n    function _stored(State memory s) private pure returns (ErrorCode) {\\n        unchecked {\\n            // Length of stored block\\n            uint256 len;\\n\\n            // Discard leftover bits from current byte (assumes s.bitcnt < 8)\\n            s.bitbuf = 0;\\n            s.bitcnt = 0;\\n\\n            // Get length and check against its one's complement\\n            if (s.incnt + 4 > s.input.length) {\\n                // Not enough input\\n                return ErrorCode.ERR_NOT_TERMINATED;\\n            }\\n            len = uint256(uint8(s.input[s.incnt++]));\\n            len |= uint256(uint8(s.input[s.incnt++])) << 8;\\n\\n            if (uint8(s.input[s.incnt++]) != (~len & 0xFF) || uint8(s.input[s.incnt++]) != ((~len >> 8) & 0xFF)) {\\n                // Didn't match complement!\\n                return ErrorCode.ERR_STORED_LENGTH_NO_MATCH;\\n            }\\n\\n            // Copy len bytes from in to out\\n            if (s.incnt + len > s.input.length) {\\n                // Not enough input\\n                return ErrorCode.ERR_NOT_TERMINATED;\\n            }\\n            if (s.outcnt + len > s.output.length) {\\n                // Not enough output space\\n                return ErrorCode.ERR_OUTPUT_EXHAUSTED;\\n            }\\n            while (len != 0) {\\n                // Note: Solidity reverts on underflow, so we decrement here\\n                len -= 1;\\n                s.output[s.outcnt++] = s.input[s.incnt++];\\n            }\\n\\n            // Done with a valid stored block\\n            return ErrorCode.ERR_NONE;\\n        }\\n    }\\n\\n    function _decode(State memory s, Huffman memory h) private pure returns (uint256) {\\n        unchecked {\\n            // Current number of bits in code\\n            uint256 len;\\n            // Len bits being decoded\\n            uint256 code = 0;\\n            // First code of length len\\n            uint256 first = 0;\\n            // Number of codes of length len\\n            uint256 count;\\n            // Index of first code of length len in symbol table\\n            uint256 index = 0;\\n\\n            for (len = 1; len <= MAXBITS; len += 5) {\\n                // Get next bit\\n                code |= bits1(s);\\n                count = h.counts[len];\\n\\n                // If length len, return symbol\\n                if (code < first + count) {\\n                    return h.symbols[index + (code - first)];\\n                }\\n                // Else update for next length\\n                index += count;\\n                first += count;\\n                first <<= 1;\\n                code <<= 1;\\n\\n                // Get next bit\\n                code |= bits1(s);\\n                count = h.counts[len + 1];\\n\\n                // If length len, return symbol\\n                if (code < first + count) {\\n                    return h.symbols[index + (code - first)];\\n                }\\n                // Else update for next length\\n                index += count;\\n                first += count;\\n                first <<= 1;\\n                code <<= 1;\\n\\n                // Get next bit\\n                code |= bits1(s);\\n                count = h.counts[len + 2];\\n\\n                // If length len, return symbol\\n                if (code < first + count) {\\n                    return h.symbols[index + (code - first)];\\n                }\\n                // Else update for next length\\n                index += count;\\n                first += count;\\n                first <<= 1;\\n                code <<= 1;\\n\\n                // Get next bit\\n                code |= bits1(s);\\n                count = h.counts[len + 3];\\n\\n                // If length len, return symbol\\n                if (code < first + count) {\\n                    return h.symbols[index + (code - first)];\\n                }\\n                // Else update for next length\\n                index += count;\\n                first += count;\\n                first <<= 1;\\n                code <<= 1;\\n\\n                // Get next bit\\n                code |= bits1(s);\\n                count = h.counts[len + 4];\\n\\n                // If length len, return symbol\\n                if (code < first + count) {\\n                    return h.symbols[index + (code - first)];\\n                }\\n                // Else update for next length\\n                index += count;\\n                first += count;\\n                first <<= 1;\\n                code <<= 1;\\n            }\\n\\n            // Ran out of codes\\n            revert(\\\"Inflate: ErrorCode.ERR_INVALID_LENGTH_OR_DISTANCE_CODE\\\");\\n        }\\n    }\\n\\n    function _construct(\\n        Huffman memory h,\\n        uint256[] memory lengths,\\n        uint256 n,\\n        uint256 start\\n    ) private pure returns (ErrorCode) {\\n        unchecked {\\n            // Current symbol when stepping through lengths[]\\n            uint256 symbol;\\n            // Current length when stepping through h.counts[]\\n            uint256 len;\\n            // Number of possible codes left of current length\\n            uint256 left;\\n            // Offsets in symbol table for each length\\n            uint256[MAXBITS + 1] memory offs;\\n\\n            // Count number of codes of each length\\n            for (len = 0; len <= MAXBITS; ++len) {\\n                h.counts[len] = 0;\\n            }\\n            for (symbol = 0; symbol < n; ++symbol) {\\n                // Assumes lengths are within bounds\\n                ++h.counts[lengths[start + symbol]];\\n            }\\n            // No codes!\\n            if (h.counts[0] == n) {\\n                // Complete, but decode() will fail\\n                return (ErrorCode.ERR_NONE);\\n            }\\n\\n            // Check for an over-subscribed or incomplete set of lengths\\n\\n            // One possible code of zero length\\n            left = 1;\\n\\n            for (len = 1; len <= MAXBITS; len += 5) {\\n                // One more bit, double codes left\\n                left <<= 1;\\n                if (left < h.counts[len]) {\\n                    // Over-subscribed--return error\\n                    return ErrorCode.ERR_CONSTRUCT;\\n                }\\n                // Deduct count from possible codes\\n                left -= h.counts[len];\\n\\n                // One more bit, double codes left\\n                left <<= 1;\\n                if (left < h.counts[len + 1]) {\\n                    // Over-subscribed--return error\\n                    return ErrorCode.ERR_CONSTRUCT;\\n                }\\n                // Deduct count from possible codes\\n                left -= h.counts[len + 1];\\n\\n                // One more bit, double codes left\\n                left <<= 1;\\n                if (left < h.counts[len + 2]) {\\n                    // Over-subscribed--return error\\n                    return ErrorCode.ERR_CONSTRUCT;\\n                }\\n                // Deduct count from possible codes\\n                left -= h.counts[len + 2];\\n\\n                // One more bit, double codes left\\n                left <<= 1;\\n                if (left < h.counts[len + 3]) {\\n                    // Over-subscribed--return error\\n                    return ErrorCode.ERR_CONSTRUCT;\\n                }\\n                // Deduct count from possible codes\\n                left -= h.counts[len + 3];\\n\\n                // One more bit, double codes left\\n                left <<= 1;\\n                if (left < h.counts[len + 4]) {\\n                    // Over-subscribed--return error\\n                    return ErrorCode.ERR_CONSTRUCT;\\n                }\\n                // Deduct count from possible codes\\n                left -= h.counts[len + 4];\\n            }\\n\\n            // Generate offsets into symbol table for each length for sorting\\n            offs[1] = 0;\\n            for (len = 1; len < MAXBITS; ++len) {\\n                offs[len + 1] = offs[len] + h.counts[len];\\n            }\\n\\n            // Put symbols in table sorted by length, by symbol order within each length\\n            for (symbol = 0; symbol < n; ++symbol) {\\n                if (lengths[start + symbol] != 0) {\\n                    h.symbols[offs[lengths[start + symbol]]++] = symbol;\\n                }\\n            }\\n\\n            // Left > 0 means incomplete\\n            return left > 0 ? ErrorCode.ERR_CONSTRUCT : ErrorCode.ERR_NONE;\\n        }\\n    }\\n\\n    function _codes(\\n        State memory s,\\n        Huffman memory lencode,\\n        Huffman memory distcode\\n    ) private pure returns (ErrorCode) {\\n        unchecked {\\n            // Decoded symbol\\n            uint256 symbol;\\n            // Length for copy\\n            uint256 len;\\n            // Distance for copy\\n            uint256 dist;\\n            // TODO Solidity doesn't support constant arrays, but these are fixed at compile-time\\n            uint16[118] memory fixedTabs = [\\n            // Size base for length codes 257..285\\n            // uint16[29] memory lens = [\\n                3,\\n                4,\\n                5,\\n                6,\\n                7,\\n                8,\\n                9,\\n                10,\\n                11,\\n                13,\\n                15,\\n                17,\\n                19,\\n                23,\\n                27,\\n                31,\\n                35,\\n                43,\\n                51,\\n                59,\\n                67,\\n                83,\\n                99,\\n                115,\\n                131,\\n                163,\\n                195,\\n                227,\\n                258,\\n            // ];\\n            // Extra bits for length codes 257..285\\n            // uint8[29] memory lext = [\\n                0,\\n                0,\\n                0,\\n                0,\\n                0,\\n                0,\\n                0,\\n                0,\\n                1,\\n                1,\\n                1,\\n                1,\\n                2,\\n                2,\\n                2,\\n                2,\\n                3,\\n                3,\\n                3,\\n                3,\\n                4,\\n                4,\\n                4,\\n                4,\\n                5,\\n                5,\\n                5,\\n                5,\\n                0,\\n            // ];\\n            // Offset base for distance codes 0..29\\n            // uint16[30] memory dists = [\\n                1,\\n                2,\\n                3,\\n                4,\\n                5,\\n                7,\\n                9,\\n                13,\\n                17,\\n                25,\\n                33,\\n                49,\\n                65,\\n                97,\\n                129,\\n                193,\\n                257,\\n                385,\\n                513,\\n                769,\\n                1025,\\n                1537,\\n                2049,\\n                3073,\\n                4097,\\n                6145,\\n                8193,\\n                12289,\\n                16385,\\n                24577,\\n            // ];\\n            // Extra bits for distance codes 0..29\\n            // uint8[30] memory dext = [\\n                0,\\n                0,\\n                0,\\n                0,\\n                1,\\n                1,\\n                2,\\n                2,\\n                3,\\n                3,\\n                4,\\n                4,\\n                5,\\n                5,\\n                6,\\n                6,\\n                7,\\n                7,\\n                8,\\n                8,\\n                9,\\n                9,\\n                10,\\n                10,\\n                11,\\n                11,\\n                12,\\n                12,\\n                13,\\n                13\\n            ];\\n\\n            // Decode literals and length/distance pairs\\n            while (symbol != 256) {\\n                symbol = _decode(s, lencode);\\n\\n                if (symbol < 256) {\\n                    // Literal: symbol is the byte\\n                    // Write out the literal\\n                    if (s.outcnt == s.output.length) {\\n                        return ErrorCode.ERR_OUTPUT_EXHAUSTED;\\n                    }\\n                    // s.output[s.outcnt] = bytes1(uint8(symbol));\\n                    // array length check is skipped\\n                    // symbol range trimming is skipped because symbol < 256\\n                    assembly {\\n                        mstore8(add(add(mload(s), 0x20), mload(add(s, 0x20))), symbol)\\n                    }\\n                    ++s.outcnt;\\n                } else if (symbol > 256) {\\n                    // Length\\n                    // Get and compute length\\n                    symbol -= 257;\\n                    if (symbol >= 29) {\\n                        // Invalid fixed code\\n                        return ErrorCode.ERR_INVALID_LENGTH_OR_DISTANCE_CODE;\\n                    }\\n\\n                    len = fixedTabs[symbol] + bits(s, fixedTabs[29 + symbol]);\\n\\n                    // Get and check distance\\n                    symbol = _decode(s, distcode);\\n                    dist = fixedTabs[58 + symbol] + bits(s, fixedTabs[88 + symbol]);\\n                    if (dist > s.outcnt) {\\n                        // Distance too far back\\n                        return ErrorCode.ERR_DISTANCE_TOO_FAR;\\n                    }\\n\\n                    // Copy length bytes from distance bytes back\\n                    if (s.outcnt + len > s.output.length) {\\n                        return ErrorCode.ERR_OUTPUT_EXHAUSTED;\\n                    }\\n                    uint256 pointer;\\n                    assembly {\\n                        pointer := add(add(mload(s), 0x20), mload(add(s, 0x20)))\\n                    }\\n                    s.outcnt += len;\\n                    if (dist < len && dist < 32) {  // copy dist bytes\\n                        uint256 mask;\\n                        assembly {\\n                            mask := shr(mul(dist, 8), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n                        }\\n                        while (len > dist) {\\n                            assembly {\\n                                mstore(pointer,\\n                                    or(\\n                                        and(mload(sub(pointer, dist)), not(mask)),\\n                                        and(mload(pointer), mask)\\n                                    )\\n                                )\\n                            }\\n                            pointer += dist;\\n                            len -= dist;\\n                        }\\n                    } else {  // copy 32 bytes\\n                        while (len > 32) {\\n                            assembly {\\n                                mstore(pointer, mload(sub(pointer, dist)))\\n                            }\\n                            pointer += 32;\\n                            len -= 32;\\n                        }\\n                    }\\n                    assembly {  // copy left\\n                        let mask := shr(mul(len, 8), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n                        mstore(pointer,\\n                            or(\\n                                and(mload(sub(pointer, dist)), not(mask)),\\n                                and(mload(pointer), mask)\\n                            )\\n                        )\\n                    }\\n                } else {\\n                    s.outcnt += len;\\n                }\\n            }\\n\\n            // Done with a valid fixed or dynamic block\\n            return ErrorCode.ERR_NONE;\\n        }\\n    }\\n\\n    function _build_fixed(State memory s) private pure returns (ErrorCode) {\\n        unchecked {\\n            // Build fixed Huffman tables\\n\\n            // _construct(s.lencode, lengths, FIXLCODES, 0);\\n            for (uint256 symbol = 0; symbol < 144; ++symbol) { // 8\\n                s.lencode.symbols[symbol + 24] = symbol;\\n            }\\n            for (uint256 symbol = 144; symbol < 256; ++symbol) { // 9\\n                s.lencode.symbols[symbol + FIXLCODES - 256] = symbol;\\n            }\\n            for (uint256 symbol = 256; symbol < 280; ++symbol) { // 7\\n                s.lencode.symbols[symbol - 256] = symbol;\\n            }\\n            for (uint256 symbol = 280; symbol < FIXLCODES; ++symbol) { // 8\\n                s.lencode.symbols[symbol - 112] = symbol;\\n            }\\n            s.lencode.counts[7] = 280 - 256;\\n            s.lencode.counts[8] = 144 + FIXLCODES - 280;\\n            s.lencode.counts[9] = 256 - 144;\\n\\n            // _construct(s.distcode, lengths, MAXDCODES, 0);\\n            for (uint256 symbol = 0; symbol < MAXDCODES; ++symbol) {\\n                s.distcode.symbols[symbol] = symbol;\\n            }\\n            s.distcode.counts[5] = MAXDCODES;\\n\\n            return ErrorCode.ERR_NONE;\\n        }\\n    }\\n\\n    function _fixed(State memory s) private pure returns (ErrorCode) {\\n        unchecked {\\n            // Decode data until end-of-block code\\n            return _codes(s, s.lencode, s.distcode);\\n        }\\n    }\\n\\n    function _build_dynamic_lengths(State memory s) private pure returns (ErrorCode, uint256[] memory) {\\n        unchecked {\\n            uint256 ncode;\\n            // Index of lengths[]\\n            uint256 index;\\n            // Descriptor code lengths\\n            uint256[] memory lengths = new uint256[](MAXCODES);\\n            // Permutation of code length codes\\n            uint8[19] memory order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\\n\\n            ncode = bits(s, 4) + 4;\\n\\n            // Read code length code lengths (really), missing lengths are zero\\n            for (index = 0; index < ncode; ++index) {\\n                lengths[order[index]] = bits(s, 3);\\n            }\\n            for (; index < 19; ++index) {\\n                lengths[order[index]] = 0;\\n            }\\n\\n            return (ErrorCode.ERR_NONE, lengths);\\n        }\\n    }\\n\\n    function _build_dynamic(State memory s)\\n        private\\n        pure\\n        returns (\\n            ErrorCode,\\n            Huffman memory,\\n            Huffman memory\\n        )\\n    {\\n        unchecked {\\n            // Number of lengths in descriptor\\n            uint256 nlen;\\n            uint256 ndist;\\n            // Index of lengths[]\\n            uint256 index;\\n            // Error code\\n            ErrorCode err;\\n            // Descriptor code lengths\\n            uint256[] memory lengths = new uint256[](MAXCODES);\\n            // Length and distance codes\\n            Huffman memory lencode = Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXLCODES));\\n            Huffman memory distcode = Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXDCODES));\\n\\n            // Get number of lengths in each table, check lengths\\n            nlen = bits(s, 5) + 257;\\n            ndist = bits(s, 5) + 1;\\n\\n            if (nlen > MAXLCODES || ndist > MAXDCODES) {\\n                // Bad counts\\n                return (ErrorCode.ERR_TOO_MANY_LENGTH_OR_DISTANCE_CODES, lencode, distcode);\\n            }\\n\\n            (err, lengths) = _build_dynamic_lengths(s);\\n            if (err != ErrorCode.ERR_NONE) {\\n                return (err, lencode, distcode);\\n            }\\n\\n            // Build huffman table for code lengths codes (use lencode temporarily)\\n            err = _construct(lencode, lengths, 19, 0);\\n            if (err != ErrorCode.ERR_NONE) {\\n                // Require complete code set here\\n                return (ErrorCode.ERR_CODE_LENGTHS_CODES_INCOMPLETE, lencode, distcode);\\n            }\\n\\n            // Read length/literal and distance code length tables\\n            index = 0;\\n            while (index < nlen + ndist) {\\n                // Decoded value\\n                uint256 symbol;\\n                // Last length to repeat\\n                uint256 len;\\n\\n                symbol = _decode(s, lencode);\\n\\n                if (symbol < 16) {\\n                    // Length in 0..15\\n                    lengths[index++] = symbol;\\n                } else {\\n                    // Repeat instruction\\n                    // Assume repeating zeros\\n                    len = 0;\\n                    if (symbol == 16) {\\n                        // Repeat last length 3..6 times\\n                        if (index == 0) {\\n                            // No last length!\\n                            return (ErrorCode.ERR_REPEAT_NO_FIRST_LENGTH, lencode, distcode);\\n                        }\\n                        // Last length\\n                        len = lengths[index - 1];\\n                        symbol = 3 + bits(s, 2);\\n                    } else if (symbol == 17) {\\n                        // Repeat zero 3..10 times\\n                        symbol = 3 + bits(s, 3);\\n                    } else {\\n                        // == 18, repeat zero 11..138 times\\n                        symbol = 11 + bits(s, 7);\\n                    }\\n\\n                    if (index + symbol > nlen + ndist) {\\n                        // Too many lengths!\\n                        return (ErrorCode.ERR_REPEAT_MORE, lencode, distcode);\\n                    }\\n                    while (symbol != 0) {\\n                        // Note: Solidity reverts on underflow, so we decrement here\\n                        symbol -= 1;\\n\\n                        // Repeat last or zero symbol times\\n                        lengths[index++] = len;\\n                    }\\n                }\\n            }\\n\\n            // Check for end-of-block code -- there better be one!\\n            if (lengths[256] == 0) {\\n                return (ErrorCode.ERR_MISSING_END_OF_BLOCK, lencode, distcode);\\n            }\\n\\n            // Build huffman table for literal/length codes\\n            err = _construct(lencode, lengths, nlen, 0);\\n            if (\\n                err != ErrorCode.ERR_NONE &&\\n                (err == ErrorCode.ERR_NOT_TERMINATED ||\\n                    err == ErrorCode.ERR_OUTPUT_EXHAUSTED ||\\n                    nlen != lencode.counts[0] + lencode.counts[1])\\n            ) {\\n                // Incomplete code ok only for single length 1 code\\n                return (ErrorCode.ERR_INVALID_LITERAL_LENGTH_CODE_LENGTHS, lencode, distcode);\\n            }\\n\\n            // Build huffman table for distance codes\\n            err = _construct(distcode, lengths, ndist, nlen);\\n            if (\\n                err != ErrorCode.ERR_NONE &&\\n                (err == ErrorCode.ERR_NOT_TERMINATED ||\\n                    err == ErrorCode.ERR_OUTPUT_EXHAUSTED ||\\n                    ndist != distcode.counts[0] + distcode.counts[1])\\n            ) {\\n                // Incomplete code ok only for single length 1 code\\n                return (ErrorCode.ERR_INVALID_DISTANCE_CODE_LENGTHS, lencode, distcode);\\n            }\\n\\n            return (ErrorCode.ERR_NONE, lencode, distcode);\\n        }\\n    }\\n\\n    function _dynamic(State memory s) private pure returns (ErrorCode) {\\n        unchecked {\\n            // Length and distance codes\\n            Huffman memory lencode;\\n            Huffman memory distcode;\\n            // Error code\\n            ErrorCode err;\\n\\n            (err, lencode, distcode) = _build_dynamic(s);\\n            if (err != ErrorCode.ERR_NONE) {\\n                return err;\\n            }\\n\\n            // Decode data until end-of-block code\\n            return _codes(s, lencode, distcode);\\n        }\\n    }\\n\\n    function puff(bytes memory source, uint256 destlen) internal pure returns (ErrorCode, bytes memory) {\\n        unchecked {\\n            // Input/output state\\n            State memory s = State(\\n                new bytes(destlen),\\n                0,\\n                source,\\n                0,\\n                0,\\n                0,\\n                Huffman(new uint256[](MAXBITS + 1), new uint256[](FIXLCODES)),\\n                Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXDCODES))\\n            );\\n            // Temp: last bit\\n            uint256 last;\\n            // Temp: block type bit\\n            uint256 t;\\n            // Error code\\n            ErrorCode err;\\n\\n            // Build fixed Huffman tables\\n            err = _build_fixed(s);\\n            if (err != ErrorCode.ERR_NONE) {\\n                return (err, s.output);\\n            }\\n\\n            // Process blocks until last block or error\\n            while (last == 0) {\\n                // One if last block\\n                last = bits1(s);\\n\\n                // Block type 0..3\\n                t = bits(s, 2);\\n\\n                err = (\\n                    t == 0\\n                        ? _stored(s)\\n                        : (t == 1 ? _fixed(s) : (t == 2 ? _dynamic(s) : ErrorCode.ERR_INVALID_BLOCK_TYPE))\\n                );\\n                // type == 3, invalid\\n\\n                if (err != ErrorCode.ERR_NONE) {\\n                    // Return with error\\n                    break;\\n                }\\n            }\\n\\n            return (err, s.output);\\n        }\\n    }\\n\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"base64-sol/base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides functions for encoding/decoding base64\\nlibrary Base64 {\\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n    bytes  internal constant TABLE_DECODE = hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\"\\n                                            hex\\\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\\\"\\n                                            hex\\\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\\\"\\n                                            hex\\\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\\\";\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return '';\\n\\n        // load the table into memory\\n        string memory table = TABLE_ENCODE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 3 bytes at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n                // read 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // write 4 characters\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n\\n        return result;\\n    }\\n\\n    function decode(string memory _data) internal pure returns (bytes memory) {\\n        bytes memory data = bytes(_data);\\n\\n        if (data.length == 0) return new bytes(0);\\n        require(data.length % 4 == 0, \\\"invalid base64 decoder input\\\");\\n\\n        // load the table into memory\\n        bytes memory table = TABLE_DECODE;\\n\\n        // every 4 characters represent 3 bytes\\n        uint256 decodedLen = (data.length / 4) * 3;\\n\\n        // add some extra buffer at the end required for the writing\\n        bytes memory result = new bytes(decodedLen + 32);\\n\\n        assembly {\\n            // padding with '='\\n            let lastBytes := mload(add(data, mload(data)))\\n            if eq(and(lastBytes, 0xFF), 0x3d) {\\n                decodedLen := sub(decodedLen, 1)\\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\\n                    decodedLen := sub(decodedLen, 1)\\n                }\\n            }\\n\\n            // set the actual output length\\n            mstore(result, decodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 4 characters at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n               // read 4 characters\\n               dataPtr := add(dataPtr, 4)\\n               let input := mload(dataPtr)\\n\\n               // write 3 bytes\\n               let output := add(\\n                   add(\\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\\n                   add(\\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\\n                    )\\n                )\\n                mstore(resultPtr, shl(232, output))\\n                resultPtr := add(resultPtr, 3)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libs/NFTDescriptorV2.sol\": {\r\n        \"NFTDescriptorV2\": \"0x65a35941050913d99019972a88147d17baeac647\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IArt\",\"name\":\"_art\",\"type\":\"address\"},{\"internalType\":\"contract ISVGRenderer\",\"name\":\"_renderer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BadPaletteLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyPalette\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IndexNotFound\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IArt\",\"name\":\"art\",\"type\":\"address\"}],\"name\":\"ArtUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"name\":\"BaseURIUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"DataURIToggled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PartsLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ISVGRenderer\",\"name\":\"renderer\",\"type\":\"address\"}],\"name\":\"RendererUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addBeards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addBeardsFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addCheekses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addCheeksesFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addEarses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addEarsesFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addEmotions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addEmotionsFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addEyeses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addEyesesFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addFaces\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addFacesFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addGlasseses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addGlassesesFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addGoggleses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addGogglesesFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addHairs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addHairsFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addHats\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addHatsFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addHelmets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addHelmetsFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addLipses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addLipsesFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addMouths\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addMouthsFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addNecks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addNecksFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addNoses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addNosesFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addPunkTypes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addPunkTypesFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addTeeths\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addTeethsFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"arePartsLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"art\",\"outputs\":[{\"internalType\":\"contract IArt\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beardCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"beards\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cheeksCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"cheekses\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"punkType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"skinTone\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"accType\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"accId\",\"type\":\"uint16\"}],\"internalType\":\"struct ISeeder.Accessory[]\",\"name\":\"accessories\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISeeder.Seed\",\"name\":\"seed\",\"type\":\"tuple\"}],\"name\":\"dataURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"earses\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emotionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"emotions\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eyesCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"eyeses\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"faceCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"faces\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"punkType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"skinTone\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"accType\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"accId\",\"type\":\"uint16\"}],\"internalType\":\"struct ISeeder.Accessory[]\",\"name\":\"accessories\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISeeder.Seed\",\"name\":\"seed\",\"type\":\"tuple\"}],\"name\":\"generateSVGImage\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"punkType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"skinTone\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"accType\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"accId\",\"type\":\"uint16\"}],\"internalType\":\"struct ISeeder.Accessory[]\",\"name\":\"accessories\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISeeder.Seed\",\"name\":\"seed\",\"type\":\"tuple\"}],\"name\":\"genericDataURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"punkType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"skinTone\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"accType\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"accId\",\"type\":\"uint16\"}],\"internalType\":\"struct ISeeder.Accessory[]\",\"name\":\"accessories\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISeeder.Seed\",\"name\":\"seed\",\"type\":\"tuple\"}],\"name\":\"getPartsForSeed\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"image\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"palette\",\"type\":\"bytes\"}],\"internalType\":\"struct ISVGRenderer.Part[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"glassesCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"glasseses\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gogglesCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"goggleses\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hairCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"hairs\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hatCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"hats\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"helmetCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"helmets\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isDataURIEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lipsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"lipses\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockParts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mouthCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"mouths\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"neckCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"necks\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"noseCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"noses\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"palettes\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"punkTypeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"punkTypes\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renderer\",\"outputs\":[{\"internalType\":\"contract ISVGRenderer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IArt\",\"name\":\"_art\",\"type\":\"address\"}],\"name\":\"setArt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"descriptor\",\"type\":\"address\"}],\"name\":\"setArtDescriptor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IInflator\",\"name\":\"inflator\",\"type\":\"address\"}],\"name\":\"setArtInflator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"paletteIndex\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"palette\",\"type\":\"bytes\"}],\"name\":\"setPalette\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"paletteIndex\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"name\":\"setPalettePointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISVGRenderer\",\"name\":\"_renderer\",\"type\":\"address\"}],\"name\":\"setRenderer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teethCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"teeths\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleDataURIEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"punkType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"skinTone\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"accType\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"accId\",\"type\":\"uint16\"}],\"internalType\":\"struct ISeeder.Accessory[]\",\"name\":\"accessories\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISeeder.Seed\",\"name\":\"seed\",\"type\":\"tuple\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NDescriptorV2", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000fde73dd610afc84b0af32dd0924ca5b719822e8600000000000000000000000018ab02ef2c3a47b3c92d0ac7e9fec95990a1b3d0", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}