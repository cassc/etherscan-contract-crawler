{"SourceCode": "//SPDX-License-Identifier: Unlicensed\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface IERC20 {\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n  function approve(address spender, uint256 value) external returns (bool);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address account) external view returns (uint256);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n  function decimals() external view returns (uint8);\r\n  function burn(uint256 amount) external;\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ninterface IPancakeRouter01 {\r\n    function factory () external pure returns (address);\r\n    function factoryV1 () external pure returns (address);\r\n    function factoryV2 () external pure returns (address);\r\n    function WETH () external pure returns (address);\r\n    function WPLS () external pure returns (address);\r\n    function WAVAX () external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\npragma solidity >=0.6.2;\r\n\r\ninterface IRouter is IPancakeRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\npragma solidity >=0.6.2;\r\n\r\ninterface IFactory {\r\nfunction getPair (address token1, address token2) external pure returns (address);\r\n}\r\n\r\n\r\n\r\ncontract DiamondHandToken {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    address payable public _dev = payable (0x60859bAF5f538c5F82219e286E73Df1DE43ceEde); // receives ETH of buy and vest function\r\n \r\n    uint8 public contractBuyFee = 30;\r\n\r\n    address public contrAddr;\r\n\r\n    address public constant _routerAddr = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; //  Uniswap V2 on test and mainnet equal on ETHEREUM\r\n    IRouter public constant _router = IRouter(_routerAddr);\r\n\r\n    IFactory public _factory = IFactory(_router.factory());\r\n    address public tradingPair = address(0);\r\n\r\n    uint256 public overallVestedToken;\r\n    uint256 public overallCollectedDividends;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Vest (address indexed user, uint256 stakeAmount, uint256 vestTime);\r\n    event EnterVesting (address indexed user, uint256 rawAmount, uint256 vestedTokenAmt, uint256 entryTime);\r\n    event ClaimRewards (address indexed user, uint256 rewardAmount, uint256 claimTime);\r\n    event ReinvestRewards (address indexed user, uint256 rewardAmount, uint256 reinvestTime);\r\n\r\n    modifier onlyDev() {\r\n        require(_dev == msg.sender, \"Ownable: caller is not the dev\");\r\n        _;\r\n    }\r\n\r\n    string public constant name = \"DiamondHandToken\";\r\n    string public constant symbol = \"DT\";\r\n    uint256 public constant decimals = 18;\r\n\r\n    uint256 public constant _monthlyDevmint = 2000 * 1e18; // 2 k token\r\n\r\n    uint256 public _totalSupply;\r\n\r\n    bool public noVestandBuyVest = false;\r\n\r\n    mapping(address => uint256) private _Balances;\r\n\r\n    /* Time of contract launch */\r\n    uint256 public constant launchTime = 1702128000; // Sets Starttime of the contract, Days and Month // TODO\r\n    uint256 public constant oneDay =  1 days;  // 60; // TODO\r\n    uint256 public constant oneMonth =  30 days; //699; // TODO\r\n\r\n    uint256 public currentDay;\r\n    uint256 public currentMonth;\r\n\r\n    uint256 public lastBuyVestDay;\r\n    uint8 public buyBackPerecent = 40; // 40 equals 4%\r\n    uint8 public percentToReceive = 20; // percentage of tokens to be received when doing a regular buy from DEX\r\n    \r\n    uint256 public constant rewardDays = 365; // rewarded days when user does vesting\r\n\r\n    uint256 private constant weiPerSfor1perDay = 11574074074074;  // this token/wei amount need to be accounted per second to have 1 ETH per day\r\n    \r\n    struct userVestData{\r\n      uint256 vestTime;\r\n      uint256 userVestDay;\r\n      uint256 userVestAmt;\r\n      uint256 amount;\r\n      uint256 claimed;\r\n      uint256 lastUpdate;\r\n      uint256 collected;\r\n    }   \r\n\r\n    // mapping for all user vesting data\r\n    mapping(address => mapping(uint256 => userVestData)) public vests;\r\n\r\n    // counter for users vesting \r\n    mapping(address => uint256) public vestID;\r\n\r\n    // day's total ETH vesting amount \r\n    mapping(uint256 => uint256) public vestingEntry;\r\n\r\n    // total ETH amount for vesting   \r\n    uint256 public vestingEntry_allDays;\r\n\r\n    // counting unique (unique for every day only) Auction enteries for each day\r\n    mapping(uint256 => uint256) public usersCountDaily;\r\n\r\n    // counting unique (unique for every day only) users\r\n    uint256 public usersCount = 0;\r\n\r\n    // mapping for allowance\r\n    mapping (address => mapping (address => uint256)) private _allowance;\r\n\r\n    // Auction memebrs overall data \r\n    struct userVesting_GlobalData{\r\n        uint256 overall_collectedTokens;\r\n        uint256 totalVestingAmount;\r\n        uint256 overall_stakedTokens;\r\n    }\r\n\r\n    // new map for every user's overall data  \r\n    mapping(address => userVesting_GlobalData) public mapUserVest_globalData;\r\n    \r\n\r\n    // Addresses that excluded from transferTax when receiving\r\n    mapping(address => bool) private _excludedFromTaxReceiver;\r\n    \r\n\r\n    constructor() {\r\n        contrAddr = address(this);\r\n\r\n        _excludedFromTaxReceiver[msg.sender] = true;\r\n        _excludedFromTaxReceiver[contrAddr] = true;\r\n        _excludedFromTaxReceiver[_routerAddr] = true;\r\n        _excludedFromTaxReceiver[_dev] = true;\r\n\r\n        _mint(_dev, 400000 * 1e18); // initial supply mint to DEV\r\n    }\r\n    \r\n\r\n    function totalSupply() external view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n\r\n    function balanceOf(address account) external view returns (uint256) {\r\n        return _Balances[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner_, address spender) external view returns (uint256) {\r\n        return _allowance[owner_][spender];\r\n    }\r\n\r\n\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\r\n        _allowance[msg.sender][spender] =\r\n        _allowance[msg.sender][spender].add(addedValue);\r\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\r\n        uint256 oldValue = _allowance[msg.sender][spender];\r\n        if (subtractedValue >= oldValue) {\r\n            _allowance[msg.sender][spender] = 0;\r\n        } else {\r\n            _allowance[msg.sender][spender] = oldValue.sub(subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n\r\n    // Set addresses of dev ad dev1\r\n    function setDevs(address payable dev) external onlyDev {\r\n        _dev = dev;\r\n     }\r\n\r\n\r\n    // Set the fee that goes to dev with each auction entry\r\n    function setDevBuyFee(uint8 _devBuyFee) external onlyDev {\r\n      require(_devBuyFee <= 30, \"setDevBuyFee: Dev Auction Fee cant be above 30%\" );\r\n        contractBuyFee = _devBuyFee;\r\n     }\r\n\r\n\r\n    // Set the bool to prefent users from using the vest and buyAndVest function.\r\n    function setNoVestandBuyVest(bool _noVestandBuyVest) external onlyDev {      \r\n        noVestandBuyVest = _noVestandBuyVest;\r\n     }\r\n\r\n\r\n\r\n    function devMint() external onlyDev {\r\n        uint256 thisMonth = (block.timestamp - launchTime) / oneMonth;\r\n\r\n        require (thisMonth > currentMonth, \"devMint: you already minted this month!\");\r\n\r\n        _mint(_dev, _monthlyDevmint);\r\n\r\n        currentMonth = thisMonth;\r\n    }\r\n\r\n\r\n    // Set the percentage to be received when buying from DEX\r\n     function setPercentToReceive(uint8 _percentToReceive) external onlyDev {\r\n        require (20 <= _percentToReceive, \"Value to small, use at least 20!\");\r\n        require (_percentToReceive <= 100, \"Value to big, use at max 100!\");\r\n        percentToReceive = _percentToReceive;\r\n     }\r\n     \r\n\r\n    // Set address to be in- or excluded from Tax when receiving\r\n    function setExcludedFromTaxReceiver(address _account, bool _excluded) external onlyDev {\r\n        _excludedFromTaxReceiver[_account] = _excluded;\r\n     }\r\n\r\n\r\n    // Returns if the address is excluded from Tax or not when receiving.    \r\n    function isExcludedFromTaxReceiver(address _account) public view returns (bool) {\r\n        return _excludedFromTaxReceiver[_account];\r\n    }\r\n\r\n\r\n   function transferToZero(uint256 amount) internal returns (bool) {\r\n        _Balances[contrAddr] = _Balances[contrAddr].sub(amount, \"Token: transfer amount exceeds balance\");\r\n        _Balances[address(0)] = _Balances[address(0)].add(amount);\r\n        emit Transfer(contrAddr, address(0), amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    function transfer(address to, uint256 amount) public returns (bool) {\r\n        _transfer(msg.sender, to, amount);\r\n        return true;\r\n    }  \r\n\r\n\r\n    function transferFrom(address from, address to, uint256 amount) public returns (bool) {\r\n        if( msg.sender != contrAddr ) {\r\n          _allowance[from][msg.sender] = _allowance[from][msg.sender].sub(amount);\r\n        }\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    // internal transfer function to apply the transfer tax ONLY for buys from DEX liquidity\r\n    function _transfer(address from, address to, uint256 amount) internal virtual {\r\n\r\n        // For Taxed Transfer (if pair is sender (token BUY) tax of \"percentToReceive\"-% applies)\r\n        bool _isTaxedRecipient = !isExcludedFromTaxReceiver(to);\r\n\r\n            if ( from == tradingPair && _isTaxedRecipient ) {   // if sender is pair (its a buy tx) AND if it is a TaxedRecipient  \r\n            _Balances[from] = _Balances[from].sub(amount, \"transfer amount exceeds balance\");\r\n            uint256 taxedAmount = amount.mul(percentToReceive).div(100);\r\n            _Balances[to] = _Balances[to].add(taxedAmount);\r\n            _Balances[address(0)] = _Balances[address(0)].add(amount.sub(taxedAmount));\r\n            emit Transfer(from, to, taxedAmount);\r\n            emit Transfer(from, address(0), amount.sub(taxedAmount));\r\n            } \r\n              else {\r\n            _Balances[from] = _Balances[from].sub(amount, \"transfer amount exceeds balance\");\r\n            _Balances[to] = _Balances[to].add(amount);\r\n            emit Transfer(from, to, amount);\r\n            }\r\n    }\r\n\r\n\r\n    function _mint(address _user, uint256 _amount) internal { \r\n      _Balances[_user] = _Balances[_user].add(_amount);\r\n      _totalSupply = _totalSupply.add(_amount);\r\n      emit Transfer(address(0), _user, _amount);\r\n    }\r\n\r\n\r\n\r\n    // internal function to stake user Token\r\n    function vestIntern (uint256 _amount) internal {\r\n      vests[msg.sender][vestID[msg.sender]].amount = _amount;\r\n      vests[msg.sender][vestID[msg.sender]].vestTime = block.timestamp;\r\n      vests[msg.sender][vestID[msg.sender]].lastUpdate = block.timestamp;\r\n\r\n      vestID[msg.sender]++;\r\n      overallVestedToken += _amount;\r\n\r\n      emit Vest(msg.sender, _amount, block.timestamp);\r\n    }\r\n \r\n\r\n\r\n    // function to see which day it is\r\n    function thisDay() public view returns (uint256) {\r\n        return 1 + ((block.timestamp - launchTime) / oneDay);\r\n    }\r\n\r\n\r\n    // function to see how many seconds until next day\r\n    function sToNextDay() public view returns (uint256) {\r\n        uint256 sSinceLaunch = (block.timestamp - launchTime);\r\n        uint256 sOfFullPassedDays = thisDay().sub(1).mul(oneDay);\r\n\r\n        return sSinceLaunch - sOfFullPassedDays;\r\n    }\r\n\r\n\r\n    // function to update the current day and to initiate the burn and buyback\r\n    function dailyUpdate() public { \r\n\r\n\r\n        // set the pair address if not done\r\n        if (tradingPair == address(0)) {\r\n            tradingPair = _factory.getPair(_router.WETH(), contrAddr);\r\n          }\r\n\r\n        // this is true once per day\r\n        if (currentDay != thisDay()) {\r\n          currentDay = thisDay();\r\n      }\r\n    }\r\n\r\n\r\n\r\n    // function for users to buy and vest tokens tax free\r\n    function buyAndVest (uint256 minTokenToReceive) external payable returns (bool) {\r\n        require(!noVestandBuyVest, \"Buy and Vest is currently disabled!\");\r\n\r\n        uint256 rawAmount = msg.value;\r\n        require(rawAmount > 0, \"No ETH to buy Token!\");\r\n\r\n        uint256 ETHtaxAmt = rawAmount.mul(contractBuyFee).div(100);\r\n\r\n        // transfer eth buy tax to dev\r\n        _dev.transfer(ETHtaxAmt);\r\n\r\n        uint256 tokenBalbefore = IERC20(contrAddr).balanceOf(address(0));\r\n\r\n        // swap ETH to Token\r\n        address[] memory path = new address[](2);\r\n          path[0] = _router.WETH();\r\n          path[1] = contrAddr;\r\n\r\n          // Buyback token from LP from received ETH\r\n           _router.swapExactETHForTokens { value: rawAmount.sub(ETHtaxAmt) } (\r\n          minTokenToReceive,\r\n          path,\r\n          address(0), // sends Token to manager to be vested\r\n          block.timestamp +100\r\n        ); \r\n\r\n        uint256 amountUserTokens = (IERC20(contrAddr).balanceOf(address(0))).sub(tokenBalbefore);\r\n\r\n        // stroing users vesting data\r\n        vestIntern(amountUserTokens);\r\n\r\n        // stroing global vesting data\r\n        mapUserVest_globalData[msg.sender].overall_stakedTokens += amountUserTokens;\r\n        mapUserVest_globalData[msg.sender].totalVestingAmount += rawAmount;\r\n\r\n        // update the day\r\n        dailyUpdate();\r\n\r\n        // storing spent ETH amounts\r\n        vestingEntry[currentDay] += rawAmount;\r\n        vestingEntry_allDays += rawAmount;    \r\n\r\n        // counting daiyl uinque users\r\n        if (vests[msg.sender][vestID[msg.sender] - 1].userVestAmt == 0) {\r\n            usersCount++;\r\n            usersCountDaily[currentDay]++;\r\n        }\r\n\r\n        vests[msg.sender][vestID[msg.sender] - 1].userVestAmt += rawAmount; \r\n        vests[msg.sender][vestID[msg.sender] - 1].userVestDay = currentDay;        \r\n\r\n        lastBuyVestDay = currentDay;        \r\n\r\n        emit EnterVesting (msg.sender, rawAmount, amountUserTokens,  block.timestamp);\r\n        \r\n        return true;        \r\n    }\r\n\r\n\r\n    // function for users to vest their tokens\r\n    function userVest (uint256 vestAmount) external returns (bool) {\r\n\r\n        require(!noVestandBuyVest, \"User Vest is currently disabled!\");\r\n        require ( vestAmount <= IERC20(contrAddr).balanceOf(msg.sender), \"Users token balance is to low!\");\r\n\r\n        IERC20(contrAddr).transferFrom(msg.sender, address(0), vestAmount);\r\n\r\n        // stroing users vesting data\r\n        vestIntern(vestAmount);\r\n\r\n        // stroing global vesting data\r\n        mapUserVest_globalData[msg.sender].overall_stakedTokens += vestAmount;\r\n\r\n        // update the day\r\n        dailyUpdate();\r\n\r\n        // counting daiyl uinque users\r\n        if (vests[msg.sender][vestID[msg.sender] - 1].userVestAmt == 0) {\r\n            usersCount++;\r\n            usersCountDaily[currentDay]++;\r\n        }\r\n\r\n        vests[msg.sender][vestID[msg.sender] - 1].userVestDay = currentDay; \r\n        \r\n        emit EnterVesting (msg.sender, 0 , vestAmount,  block.timestamp);\r\n        \r\n        return true;        \r\n    }\r\n\r\n\r\n  // only called when claim (collect) is called\r\n    // calculates the earned rewards since LAST UPDATE\r\n    // earning is 1% per day\r\n    function calcReward (address _user, uint256 _stakeIndex) public view returns (uint256) {\r\n      if(vests[_user][_stakeIndex].vestTime == 0){\r\n        return 0;\r\n      }\r\n      // value 11574074074074 gives 1 ether per day as multiplier!\r\n      uint256 multiplier = (block.timestamp - vests[_user][_stakeIndex].lastUpdate).mul(weiPerSfor1perDay);\r\n      // for example: if user amount is 100 and user has staked for 100 days and not collected so far,\r\n      // reward would be 100, if 100 was already collected reward will be 0\r\n      if(vests[_user][_stakeIndex].amount.mul(multiplier).div(100 ether).add(vests[_user][_stakeIndex].collected) >   \r\n        vests[_user][_stakeIndex].amount.mul(rewardDays).div(100)) {\r\n        return(vests[_user][_stakeIndex].amount.mul(rewardDays).div(100).sub(vests[_user][_stakeIndex].collected));\r\n      }\r\n      // in same example: below rewardDays days of vestIntern the reward is vests.amount * days/100\r\n      return vests[_user][_stakeIndex].amount.mul(multiplier).div(100 ether);\r\n    }\r\n\r\n\r\n    // (not called internally) Only for viewing the earned rewards in UI\r\n    // caculates claimable rewards\r\n    function calcClaim (address _user, uint256 _stakeIndex) external view returns (uint256) {\r\n      if (vests[_user][_stakeIndex].vestTime == 0){\r\n        return 0;\r\n      }\r\n      // value 11574074074074 gives 1 ether per day as multiplier!\r\n      uint256 multiplier = (block.timestamp - vests[_user][_stakeIndex].lastUpdate).mul(weiPerSfor1perDay);\r\n\r\n      if (multiplier.mul(vests[_user][_stakeIndex].amount).div(100 ether).add(vests[_user][_stakeIndex].collected) >\r\n        vests[_user][_stakeIndex].amount.mul(rewardDays).div(100)){\r\n        return(vests[_user][_stakeIndex].amount.mul(rewardDays).div(100).sub(vests[_user][_stakeIndex].claimed));\r\n      }\r\n      return vests[_user][_stakeIndex].amount.mul(multiplier).div(100 ether).add(vests[_user][_stakeIndex].collected)\r\n      .sub(vests[_user][_stakeIndex].claimed);\r\n    }\r\n\r\n\r\n    // function to update the collected rewards to user vestIntern collected value and update the last updated value\r\n    function _collect (address _user, uint256 _stakeIndex) internal {\r\n      vests[_user][_stakeIndex].collected = vests[_user][_stakeIndex].collected.add(calcReward(_user, _stakeIndex));\r\n      vests[_user][_stakeIndex].lastUpdate = block.timestamp;\r\n    }\r\n\r\n\r\n    // function for users to claim rewards\r\n    function claimRewards (uint256 _stakeIndex) external {\r\n\r\n      _collect(msg.sender, _stakeIndex);\r\n\r\n      uint256 reward = vests[msg.sender][_stakeIndex].collected.sub(vests[msg.sender][_stakeIndex].claimed);\r\n      vests[msg.sender][_stakeIndex].claimed = vests[msg.sender][_stakeIndex].collected;\r\n\r\n      // mint rewards to user\r\n      _mint(msg.sender, reward);\r\n\r\n      overallCollectedDividends += reward;\r\n\r\n      emit ClaimRewards (msg.sender, reward, block.timestamp);\r\n    }\r\n\r\n\r\n    function claimAll () external {\r\n\r\n        uint256 userVests = vestID[msg.sender];\r\n        uint256 totalClaim;\r\n\r\n        // update all vests and calculate totalClaim\r\n        for (uint256 i; i < userVests; i ++) \r\n        {\r\n            _collect(msg.sender, i);\r\n\r\n            totalClaim += vests[msg.sender][i].collected - (vests[msg.sender][i].claimed);\r\n            vests[msg.sender][i].claimed = vests[msg.sender][i].collected;\r\n\r\n        }\r\n\r\n        // mint all rewards to User\r\n        _mint(msg.sender, totalClaim);\r\n\r\n        overallCollectedDividends += totalClaim;\r\n\r\n        emit ClaimRewards (msg.sender, totalClaim, block.timestamp);\r\n\r\n    }\r\n\r\n\r\n\r\n    // function for users to claim rewards\r\n    function reinvestRewards (uint256 _stakeIndex) external {\r\n\r\n      _collect(msg.sender, _stakeIndex);\r\n\r\n      uint256 reward = vests[msg.sender][_stakeIndex].collected - (vests[msg.sender][_stakeIndex].claimed);\r\n      vests[msg.sender][_stakeIndex].claimed = vests[msg.sender][_stakeIndex].collected;\r\n\r\n      // mint rewards to user\r\n      vestIntern(reward);\r\n\r\n      overallCollectedDividends += reward;\r\n\r\n      \r\n        // stroing global vesting data\r\n        mapUserVest_globalData[msg.sender].overall_stakedTokens += reward;\r\n\r\n        // update the day\r\n        dailyUpdate();\r\n\r\n        // counting users\r\n        if (vests[msg.sender][vestID[msg.sender] - 1].userVestAmt == 0) {\r\n            usersCount++;\r\n            usersCountDaily[currentDay]++;\r\n        }\r\n\r\n        vests[msg.sender][vestID[msg.sender] - 1].userVestAmt += reward; \r\n        vests[msg.sender][vestID[msg.sender] - 1].userVestDay = currentDay;    \r\n\r\n      emit ReinvestRewards (msg.sender, reward, block.timestamp);\r\n    }\r\n\r\n\r\n\r\n\r\n    function reinvestAll () external {\r\n\r\n        uint256 userVests = vestID[msg.sender];\r\n        uint256 totalClaim;\r\n\r\n        // update all vests and calculate totalClaim\r\n        for (uint256 i; i < userVests; i ++) \r\n        {\r\n            _collect(msg.sender, i);\r\n\r\n            totalClaim += vests[msg.sender][i].collected - (vests[msg.sender][i].claimed);\r\n            vests[msg.sender][i].claimed = vests[msg.sender][i].collected;\r\n\r\n        }\r\n\r\n        // reinvest all rewards to new userVest\r\n        vestIntern(totalClaim);\r\n\r\n        overallCollectedDividends += totalClaim;\r\n\r\n        emit ReinvestRewards (msg.sender, totalClaim, block.timestamp);\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n////// Test functions TODO to be removed!!\r\n\r\n    function securityETHWithdrawal () public  onlyDev {\r\n\r\n        uint256 ETHbal = address(this).balance;\r\n        (_dev).transfer(ETHbal);\r\n    }\r\n    \r\n    function securityTokenWithdrawal (address tokenAddr) public onlyDev {        \r\n\r\n        uint256 tokenBal = IERC20(tokenAddr).balanceOf(address(this));\r\n        IERC20(tokenAddr).transfer(_dev, tokenBal);\r\n    }\r\n\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimTime\",\"type\":\"uint256\"}],\"name\":\"ClaimRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rawAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestedTokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"entryTime\",\"type\":\"uint256\"}],\"name\":\"EnterVesting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reinvestTime\",\"type\":\"uint256\"}],\"name\":\"ReinvestRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestTime\",\"type\":\"uint256\"}],\"name\":\"Vest\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_dev\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_factory\",\"outputs\":[{\"internalType\":\"contract IFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_monthlyDevmint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_router\",\"outputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_routerAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minTokenToReceive\",\"type\":\"uint256\"}],\"name\":\"buyAndVest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackPerecent\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakeIndex\",\"type\":\"uint256\"}],\"name\":\"calcClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakeIndex\",\"type\":\"uint256\"}],\"name\":\"calcReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeIndex\",\"type\":\"uint256\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contrAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractBuyFee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentMonth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dailyUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isExcludedFromTaxReceiver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBuyVestDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mapUserVest_globalData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"overall_collectedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalVestingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"overall_stakedTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"noVestandBuyVest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oneDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oneMonth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"overallCollectedDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"overallVestedToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentToReceive\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reinvestAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeIndex\",\"type\":\"uint256\"}],\"name\":\"reinvestRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardDays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sToNextDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"securityETHWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"}],\"name\":\"securityTokenWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_devBuyFee\",\"type\":\"uint8\"}],\"name\":\"setDevBuyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"dev\",\"type\":\"address\"}],\"name\":\"setDevs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_excluded\",\"type\":\"bool\"}],\"name\":\"setExcludedFromTaxReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_noVestandBuyVest\",\"type\":\"bool\"}],\"name\":\"setNoVestandBuyVest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_percentToReceive\",\"type\":\"uint8\"}],\"name\":\"setPercentToReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"thisDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vestAmount\",\"type\":\"uint256\"}],\"name\":\"userVest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"usersCountDaily\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vestID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vestingEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingEntry_allDays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vests\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vestTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userVestDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userVestAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collected\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DiamondHandToken", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ca7c205ffc2fc974a160b586229b327da19eceb1f8458222f1a8752dd37b2b56"}