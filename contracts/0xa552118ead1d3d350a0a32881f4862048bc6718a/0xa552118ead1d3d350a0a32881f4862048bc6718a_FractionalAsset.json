{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2023-12-01\r\n*/\r\n\r\n//SPDX-License-Identifier: Apache-2.0\r\npragma solidity 0.8.14;\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle Trees proofs.\r\n *\r\n * The proofs can be generated using the JavaScript library\r\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\r\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\r\n *\r\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(\r\n        bytes32[] memory proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        return processProof(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\r\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\r\n     * hash matches the root of the tree. When processing the proof, the pairs\r\n     * of leafs & pre-images are assumed to be sorted.\r\n     *\r\n     * _Available since v4.4._\r\n     */\r\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = _efficientHash(computedHash, proofElement);\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = _efficientHash(proofElement, computedHash);\r\n            }\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n        assembly {\r\n            mstore(0x00, a)\r\n            mstore(0x20, b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    \r\n    function symbol() external view returns(string memory);\r\n    \r\n    function name() external view returns(string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n    \r\n    /**\r\n     * @dev Returns the number of decimal places\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface INonFungibleToken is IERC165 {\r\n\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n}\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\ninterface IFractionalAsset is INonFungibleToken {\r\n\r\n    /**\r\n        Returns The URI To An Image Representing `tokenId`\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n\r\n    /**\r\n        Returns The URI Associated With The Collection\r\n     */\r\n    function URI() external view returns (string memory);\r\n\r\n    /**\r\n        Returns The Name Of A Collection\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n        Returns The Symbol (Ticker) Of A Collection\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n        Returns The Number Of Fractions This NFT Is Split Into\r\n     */\r\n    function numFractions() external view returns (uint256);\r\n\r\n    /**\r\n        Initializes The FractionalAsset\r\n     */\r\n    function __init__(\r\n        string[] calldata strings,\r\n        uint256[] calldata values,\r\n        address[] calldata addrs\r\n    ) external;\r\n}\r\n\r\ninterface IDatabase {\r\n    function isVerified(address account) external view returns (bool);\r\n    function isAuthorized(address account) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\r\n * deploying minimal proxy contracts, also known as \"clones\".\r\n *\r\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\r\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\r\n *\r\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\r\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\r\n * deterministic method.\r\n *\r\n * _Available since v3.4._\r\n */\r\ncontract Clones {\r\n\r\n    /**\r\n        @dev Deploys and returns the address of a clone of address(this\r\n        Created by DeFi Mark To Allow Clone Contract To Easily Create Clones Of Itself\r\n        Without redundancy\r\n     */\r\n    function clone() external returns(address) {\r\n        return _clone(address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create opcode, which should never revert.\r\n     */\r\n    function _clone(address implementation) internal returns (address instance) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            instance := create(0, ptr, 0x37)\r\n        }\r\n        require(instance != address(0), \"ERC1167: create failed\");\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n}\r\n\r\ncontract FractionalAssetData is Context {\r\n\r\n    /**\r\n        Master Database Which Interacts With KYC And Auth Databases\r\n     */\r\n    IDatabase public constant Database = IDatabase(0x238a94E37a1bAde56Cfcc5dbE7f48DA88aa9Db19);\r\n\r\n    /**\r\n        Is Initialized\r\n     */\r\n    bool internal initialized;\r\n\r\n    /**\r\n        Name For NFT Compatibility\r\n     */\r\n    string internal _name;\r\n\r\n    /**\r\n        Symbol For NFT Compatibility\r\n     */\r\n    string internal _symbol;\r\n\r\n    /**\r\n        Current Token ID For Tracking Purposes\r\n     */\r\n    uint256 internal _currentTokenID;\r\n\r\n    /**\r\n        Mapping From Mint Tokens To Cost\r\n     */\r\n    mapping ( address => uint256 ) public mintCost;\r\n\r\n    /**\r\n        Mapping From A TokenID To An Address Which Dictates Ownership Of That Specific ID\r\n     */\r\n    mapping(uint256 => address) internal _owners;\r\n\r\n    /**\r\n        List Of Registered Owners Containing At Least 1 Fractional Asset\r\n     */\r\n    address[] internal _registeredOwners;\r\n\r\n    /**\r\n        Mapping Between An Owner And Their Index In The `_registeredOwners` List\r\n     */\r\n    mapping( address => uint256 ) internal _ownerIndex;\r\n\r\n    /**\r\n        Mapping From Owner Address To The Number Of Fractional Assets They Own In Total\r\n        Ensures NFT Compatibility\r\n     */\r\n    mapping(address => uint256) internal _balances;\r\n\r\n    /**\r\n        Mapping from token ID to approved address\r\n     */\r\n    mapping(uint256 => address) internal _tokenApprovals;\r\n\r\n    /**\r\n        Mapping from owner to operator approvals\r\n    */\r\n    mapping(address => mapping(address => bool)) internal _operatorApprovals;\r\n\r\n    /**\r\n        Returns The URI Of The Images Associated With Each Collection\r\n     */\r\n    string internal baseURI;\r\n\r\n    /**\r\n        Number Of Fractions NFT Is Split Into\r\n     */\r\n    uint256 internal nFractions;\r\n\r\n    /**\r\n        Whether Or Not Minting Is Enabled\r\n     */\r\n    bool public mintingEnabled;\r\n\r\n    /**\r\n        Whether Or Not An Allowlist Is Enabled\r\n     */\r\n    bool public allowlistEnabled;\r\n\r\n    /**\r\n        Recipient of Mint Funds\r\n     */\r\n    address public mintRecipient;\r\n\r\n    // Mapping from owner to excluded rewards\r\n    mapping(address => uint256) totalExcluded;\r\n\r\n    // total dividends for tracking\r\n    uint256 internal dividendsPerNFT;\r\n\r\n    // total rewards received\r\n    uint256 public totalRewards;\r\n\r\n    // Reward Token\r\n    address public rewardToken;\r\n\r\n    // precision value\r\n    uint256 internal constant precision = 10**18;\r\n\r\n    // Merkle Root\r\n    bytes32 internal merkleRoot;\r\n\r\n    /**\r\n        Ensures `account` is KYC Verified Before Permitting\r\n        Access To Certain Functionality\r\n     */\r\n    modifier isVerified(address account) {\r\n        require(\r\n            account != address(0),\r\n            'Zero Address'\r\n        );\r\n        require(\r\n            Database.isVerified(account),\r\n            'Account Not KYC Verified'\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n        Ensures Caller Is Authorized To Call Restricted Functions\r\n     */\r\n    modifier onlyAuthorized() {\r\n        require(\r\n            Database.isAuthorized(_msgSender()) == true,\r\n            'Not Authorized To Call'\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n        Events To Support Data Tracking\r\n     */\r\n    event BaseURIChange(string oldURI, string newURI);\r\n\r\n}\r\n\r\n\r\ncontract FractionalAsset is FractionalAssetData, IFractionalAsset, Clones {\r\n\r\n  using Address for address;\r\n\r\n  // Event Declarations\r\nevent Mint(address indexed to, uint256 indexed tokenId);\r\nevent MintingEnabled();\r\nevent MintingDisabled();\r\nevent AllowlistEnabled();\r\nevent AllowlistDisabled();\r\nevent MerkleRootSet(bytes32 newRoot);\r\nevent Withdrawal(address indexed token, address indexed to, uint256 amount);\r\nevent MintCostSet(address indexed token, uint256 newCost);\r\nevent RewardsDeposited(uint256 amount);\r\nevent RewardsClaimed(address indexed user, uint256 amount);\r\n\r\n  /**\r\n      Initializes The FractionalAsset\r\n   */\r\n  function __init__(\r\n      string[] calldata strings,\r\n      uint256[] calldata values,\r\n      address[] calldata addrs\r\n  ) external override {\r\n      require(\r\n          !initialized,\r\n          'Already Initialized'\r\n      );\r\n      initialized = true;\r\n      _name = strings[0];\r\n      _symbol = strings[1];\r\n      baseURI = strings[2];\r\n      nFractions = values[0];\r\n      for (uint i = 0; i < values[1]; i++) {\r\n          mintCost[addrs[i]] = values[2 + i];\r\n      }\r\n      rewardToken = addrs[values[1]];\r\n      mintRecipient = addrs[values[1] + 1];\r\n  }\r\n  \r\n  /**\r\n      Sets The Base URI, Updating Images For ALL Collections\r\n   */\r\n  function setBaseURI(string calldata newURI) external onlyAuthorized {\r\n      emit BaseURIChange(baseURI, newURI);\r\n      baseURI = newURI;\r\n  }\r\n\r\n  function enableMinting() external onlyAuthorized {\r\n      mintingEnabled = true;\r\n      emit MintingEnabled();\r\n  }\r\n\r\n  function setMintRecipient(address newRecipient) external onlyAuthorized {\r\n      mintRecipient = newRecipient;\r\n  }\r\n\r\n  function disableMinting() external onlyAuthorized {\r\n      mintingEnabled = false;\r\n      emit MintingDisabled();\r\n  }\r\n\r\n  function enableAllowlist() external onlyAuthorized {\r\n      allowlistEnabled = true;\r\n      emit AllowlistEnabled();\r\n  }\r\n\r\n  function disableAllowlist() external onlyAuthorized {\r\n      allowlistEnabled = false;\r\n      emit AllowlistDisabled();\r\n  }\r\n\r\n  function setMerkleRoot(bytes32 root) external onlyAuthorized {\r\n      merkleRoot = root;\r\n      emit MerkleRootSet(root);\r\n  }\r\n\r\n  function withdrawETH(address to) external onlyAuthorized {\r\n      (bool s,) = payable(to).call{value: address(this).balance}(\"\");\r\n      require(s);\r\n      emit Withdrawal(address(0), to, address(this).balance);\r\n  }\r\n\r\n  function withdrawToken(address token, address to) external onlyAuthorized {\r\n      IERC20(token).transfer(to, IERC20(token).balanceOf(address(this)));\r\n      emit Withdrawal(token, to, IERC20(token).balanceOf(address(this)));\r\n  }\r\n\r\n  function setCost(address mintToken, uint256 newCost) external onlyAuthorized {\r\n      mintCost[mintToken] = newCost;\r\n      emit MintCostSet(mintToken, newCost);\r\n  }\r\n\r\n  function ownerMint(address to, uint256 num) external onlyAuthorized {\r\n      for (uint i = 0; i < num;) {\r\n          _safeMint(to, _currentTokenID);\r\n          unchecked { ++i; }\r\n      }\r\n  }\r\n\r\n  function batchClaim(address[] calldata users) external onlyAuthorized {\r\n      uint len = users.length;\r\n      for (uint i = 0; i < len;) {\r\n          _claimRewards(users[i]);\r\n          unchecked { ++i; }\r\n      }\r\n  }\r\n\r\n  function depositRewards(uint256 amount) external onlyAuthorized {\r\n      require(\r\n          _currentTokenID > 0,\r\n          'Zero Tokens'\r\n      );\r\n      require(\r\n          IERC20(rewardToken).allowance(msg.sender, address(this)) >= amount,\r\n          'Insufficient Allowance'\r\n      );\r\n      require(\r\n          IERC20(rewardToken).balanceOf(msg.sender) >= amount,\r\n          'Insufficient Balance'\r\n      );\r\n      require(\r\n          IERC20(rewardToken).transferFrom(msg.sender, address(this), amount),\r\n          'Error TransferFrom'\r\n      );\r\n      unchecked {\r\n          totalRewards += amount;\r\n          dividendsPerNFT += ( amount * precision ) / _currentTokenID;\r\n      }\r\n      emit RewardsDeposited(amount);\r\n  }\r\n\r\n  function claimRewards() external {\r\n      require(\r\n          _balances[msg.sender] > 0,\r\n          'Zero Balance'\r\n      );\r\n      _claimRewards(msg.sender);\r\n  }\r\n\r\n  function mint(address token, address to, uint256 num, bytes32[] calldata proof) external payable {\r\n      require(\r\n          mintingEnabled,\r\n          'Minting Is Disabled'\r\n      );\r\n      require(\r\n          to != address(0),\r\n          'Zero Address'\r\n      );\r\n      require(\r\n          num > 0,\r\n          'Zero Num'\r\n      );\r\n      if (allowlistEnabled) {\r\n          require(\r\n              MerkleProof.verify(\r\n                  proof,\r\n                  merkleRoot,\r\n                  keccak256(abi.encodePacked(_msgSender()))\r\n              ),\r\n              \"User Is Not Whitelisted\"\r\n          );\r\n      }\r\n\r\n      require(\r\n          mintCost[token] > 0,\r\n          'Invalid Mint Token'\r\n      );\r\n      uint totalCost = mintCost[token] * num;\r\n\r\n      if (token == address(0)) {\r\n          require(\r\n              msg.value >= totalCost,\r\n              'Insufficient Value'\r\n          );\r\n\r\n          // add logic to swap to USDC if ETH\r\n          (bool s,) = payable(mintRecipient).call{value: msg.value}(\"\");\r\n          require(s, 'Mint Recipient Transfer Failure');\r\n\r\n      } else {\r\n          require(\r\n              IERC20(token).balanceOf(msg.sender) >= totalCost,\r\n              'Insufficient Balance'\r\n          );\r\n          require(\r\n              IERC20(token).allowance(msg.sender, address(this)) >= totalCost,\r\n              'Insufficient Allowance'\r\n          );\r\n          require(\r\n              IERC20(token).transferFrom(msg.sender, mintRecipient, totalCost),\r\n              'Error Transfer From'\r\n          );\r\n      }\r\n      \r\n      for (uint i = 0; i < num;) {\r\n          _safeMint(to, _currentTokenID);\r\n          unchecked { ++i; }\r\n      }\r\n  }\r\n\r\n  /**\r\n      Cumulative Dividends For A Number Of Tokens\r\n   */\r\n  function getCumulativeDividends(uint256 share) internal view returns (uint256) {\r\n      return ( share * dividendsPerNFT ) / precision;\r\n  }\r\n\r\n  /**\r\n      Pending Rewards For `account`\r\n   */\r\n  function pendingRewards(address account) public view returns (uint256) {\r\n      if(_balances[account] == 0){ return 0; }\r\n      if (totalRewards == 0) { return 0; }\r\n\r\n      uint256 accountTotalDividends = getCumulativeDividends(_balances[account]);\r\n      uint256 accountTotalExcluded = totalExcluded[account];\r\n\r\n      if(accountTotalDividends <= accountTotalExcluded){ return 0; }\r\n\r\n      return accountTotalDividends - accountTotalExcluded;\r\n  }\r\n\r\n  /**\r\n      Total Supply of NFT\r\n   */\r\n  function totalSupply() external view returns (uint256) {\r\n      return _currentTokenID;\r\n  }\r\n\r\n  /**\r\n      Name Of The Collection\r\n   */\r\n  function name() external view override returns (string memory) {\r\n      return _name;\r\n  }\r\n\r\n  /**\r\n      Symbol (ticker) Of The Collection\r\n   */\r\n  function symbol() external view override returns (string memory) {\r\n      return _symbol;\r\n  }\r\n\r\n  /**\r\n      Returns The Number Of Fractions This NFT Is Split Into\r\n   */\r\n  function numFractions() external view override returns (uint256) {\r\n      return nFractions;\r\n  }\r\n\r\n  /**\r\n      Returns The URI To An Image Representing This Fractional Asset\r\n   */\r\n  function tokenURI(uint256) external view override returns (string memory) {\r\n      return baseURI;\r\n  }\r\n\r\n  /**\r\n      Returns The URI To An Image Representing This Fractional Asset\r\n   */\r\n  function URI() external view override returns (string memory) {\r\n      return baseURI;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of tokens in ``owner``'s account.\r\n   */\r\n  function balanceOf(address owner) external view override returns (uint256 balance) {\r\n      return _balances[owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the owner of the `tokenId` token.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must exist.\r\n   */\r\n  function ownerOf(uint256 tokenId) public view returns (address owner) {\r\n      require(\r\n          _exists(tokenId),\r\n          'Token Does Not Exist'\r\n      );\r\n      return _owners[tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must exist and be owned by `from`.\r\n   * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function safeTransferFrom(\r\n      address from,\r\n      address to,\r\n      uint256 tokenId\r\n  ) external override {\r\n      require(\r\n          _isApprovedOrOwner(_msgSender(), tokenId), \r\n          \"Transfer caller is not owner nor approved\"\r\n      );\r\n      _safeTransfer(from, to, tokenId, new bytes(0));\r\n  }\r\n\r\n  /**\r\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must exist and be owned by `from`.\r\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function safeTransferFrom(\r\n      address from,\r\n      address to,\r\n      uint256 tokenId,\r\n      bytes calldata data\r\n  ) public override {\r\n      require(\r\n          _isApprovedOrOwner(_msgSender(), tokenId), \r\n          \"Transfer caller is not owner nor approved\"\r\n      );\r\n      _safeTransfer(from, to, tokenId, data);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers `tokenId` token from `from` to `to`.\r\n   *\r\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must be owned by `from`.\r\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(\r\n      address from,\r\n      address to,\r\n      uint256 tokenId\r\n  ) external override {\r\n      require(\r\n          _isApprovedOrOwner(_msgSender(), tokenId), \r\n          \"Transfer caller is not owner nor approved\"\r\n      );\r\n      _transfer(from, to, tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n   * The approval is cleared when the token is transferred.\r\n   *\r\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The caller must own the token or be an approved operator.\r\n   * - `tokenId` must exist.\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address to, uint256 tokenId) external override {\r\n      address owner = ownerOf(tokenId);\r\n      require(\r\n          to != owner, \r\n          \"ERC721: approval to current owner\"\r\n      );\r\n      require(\r\n          _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n          \"ERC721: approve caller is not owner nor approved for all\"\r\n      );\r\n      _approve(to, tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the account approved for `tokenId` token.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must exist.\r\n   */\r\n  function getApproved(uint256 tokenId) public view override returns (address operator) {\r\n      require(\r\n          _exists(tokenId), \r\n          \"Non Existent Token\"\r\n      );\r\n      return _tokenApprovals[tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Approve or remove `operator` as an operator for the caller.\r\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The `operator` cannot be the caller.\r\n   *\r\n   * Emits an {ApprovalForAll} event.\r\n   */\r\n  function setApprovalForAll(address operator, bool _approved) external override {\r\n      _setApprovalForAll(_msgSender(), operator, _approved);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n   *\r\n   * See {setApprovalForAll}\r\n   */\r\n  function isApprovedForAll(address owner, address operator) public view override returns (bool) {\r\n      return _operatorApprovals[owner][operator];\r\n  }\r\n\r\n  /**\r\n      Claims Reward For User\r\n   */\r\n  function _claimRewards(address user) internal {\r\n\r\n      // return if zero balance\r\n      if (_balances[user] == 0) {\r\n          return;\r\n      }\r\n\r\n      // fetch pending rewards\r\n      uint pending = pendingRewards(user);\r\n      uint bal = IERC20(rewardToken).balanceOf(address(this));\r\n      if (pending > bal) {\r\n          pending = bal;\r\n      }\r\n\r\n      // return if no rewards\r\n      if (pending == 0) {\r\n          return;\r\n      }\r\n      \r\n      // reset total rewards\r\n      totalExcluded[user] = getCumulativeDividends(_balances[user]);\r\n\r\n      // transfer reward to user\r\n      IERC20(rewardToken).transfer(user, pending);\r\n      emit RewardsClaimed(user, pending);\r\n  }\r\n\r\n  /**\r\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n   *\r\n   * `_data` is additional data, it has no specified format and it is sent in call to `to`.\r\n   *\r\n   * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\r\n   * implement alternative mechanisms to perform token transfer, such as signature-based.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must exist and be owned by `from`.\r\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function _safeTransfer(\r\n      address from,\r\n      address to,\r\n      uint256 tokenId,\r\n      bytes memory _data\r\n  ) internal {\r\n      _transfer(from, to, tokenId);\r\n      require(\r\n          _checkOnERC721Received(from, to, tokenId, _data), \r\n          \"ERC721: Transfer to non ERC721Receiver implementer\"\r\n      );\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers `tokenId` from `from` to `to`.\r\n   *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `to` cannot be the zero address and must be KYC Verified\r\n   * - `tokenId` token must be owned by `from`.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function _transfer(\r\n      address from,\r\n      address to,\r\n      uint256 tokenId\r\n  ) internal isVerified(to) {\r\n      \r\n      // Ensure State\r\n      require(\r\n          ownerOf(tokenId) == from,\r\n          \"ERC721: transfer from incorrect owner\"\r\n      );\r\n      require(\r\n          _balances[from] > 0, \r\n          'Zero Balance'\r\n      );\r\n\r\n      // Clear approvals from the previous owner\r\n      _approve(address(0), tokenId);\r\n\r\n      // claim rewards for from\r\n      _claimRewards(from);\r\n\r\n      // Register Owner If Zero Balance Update\r\n      if (_balances[to] == 0) {\r\n          _registerOwner(to);\r\n      } else {\r\n          _claimRewards(to);\r\n      }\r\n\r\n      // Reassign Total Balances\r\n      unchecked {\r\n          _balances[from] -= 1;\r\n          _balances[to] += 1;\r\n      }\r\n\r\n      // Reassign Ownership\r\n      _owners[tokenId] = to;\r\n\r\n      // Remove Owner If New Balance Is Zero\r\n      if (_balances[from] == 0) {\r\n          _removeOwner(from);\r\n      }\r\n\r\n      // reset reward allocations\r\n      totalExcluded[from] = getCumulativeDividends(_balances[from]);\r\n      totalExcluded[to] = getCumulativeDividends(_balances[to]);\r\n\r\n      emit Transfer(from, to, tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\r\n   * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\r\n   */\r\n  function _safeMint(\r\n      address to,\r\n      uint256 tokenId\r\n  ) internal isVerified(to) {\r\n      _mint(to, tokenId);\r\n      require(\r\n          _checkOnERC721Received(address(0), to, tokenId, \"\"),\r\n          \"ERC721: transfer to non ERC721Receiver implementer\"\r\n      );\r\n  }\r\n\r\n  /**\r\n   * @dev Mints `tokenId` and transfers it to `to`.\r\n   *\r\n   * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must not exist.\r\n   * - `to` cannot be the zero address.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function _mint(address to, uint256 tokenId) internal {\r\n      require(!_exists(tokenId), \"ERC721: token already minted\");\r\n      require(_currentTokenID < nFractions, 'All NFTs Have Been Minted');\r\n\r\n      // Register Owner If Zero Balance Update\r\n      if (_balances[to] == 0) {\r\n          _registerOwner(to);\r\n      }\r\n\r\n      // set ownership\r\n      _owners[tokenId] = to;\r\n\r\n      // increment balance of minter plus the current token ID\r\n      unchecked {\r\n          _balances[to]++;\r\n          _currentTokenID++;\r\n      }\r\n\r\n      // set excluded\r\n      totalExcluded[to] = getCumulativeDividends(_balances[to]);\r\n\r\n      emit Transfer(address(0), to, tokenId);\r\n      emit Mint(to, tokenId);\r\n  }\r\n\r\n  /**\r\n      Registers `owner` in registeredOwner List\r\n   */\r\n  function _registerOwner(address owner) internal {\r\n      _ownerIndex[owner] = _registeredOwners.length;\r\n      _registeredOwners.push(owner);\r\n  }\r\n\r\n  /**\r\n      Removes `owner` from registeredOwner List\r\n   */\r\n  function _removeOwner(address owner) internal {\r\n\r\n      // set last element index to be removed index\r\n      _ownerIndex[\r\n          _registeredOwners[_registeredOwners.length - 1]\r\n      ] = _ownerIndex[owner];\r\n\r\n      // set removed element to be last element\r\n      _registeredOwners[\r\n          _ownerIndex[owner]\r\n      ] = _registeredOwners[_registeredOwners.length - 1];\r\n\r\n      // pop off last element\r\n      _registeredOwners.pop();\r\n      delete _ownerIndex[owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Approve `to` to operate on `tokenId`\r\n   *\r\n   * Emits a {Approval} event.\r\n   */\r\n  function _approve(address to, uint256 tokenId) internal {\r\n      _tokenApprovals[tokenId] = to;\r\n      emit Approval(ownerOf(tokenId), to, tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether `tokenId` exists.\r\n   *\r\n   * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n   */\r\n  function _exists(uint256 tokenId) internal view returns (bool) {\r\n      return _owners[tokenId] != address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Approve `operator` to operate on all of `owner` tokens\r\n   *\r\n   * Emits a {ApprovalForAll} event.\r\n   */\r\n  function _setApprovalForAll(\r\n      address owner,\r\n      address operator,\r\n      bool approved\r\n  ) internal {\r\n      require(\r\n          owner != operator, \r\n          \"Caller Cannot Approve Itself\"\r\n      );\r\n      _operatorApprovals[owner][operator] = approved;\r\n      emit ApprovalForAll(owner, operator, approved);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must exist.\r\n   */\r\n  function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n      require(\r\n          _exists(tokenId), \r\n          \"Non Existent Token\"\r\n      );\r\n      address owner = ownerOf(tokenId);\r\n      return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n   * The call is not executed if the target address is not a contract.\r\n   *\r\n   * @param from address representing the previous owner of the given token ID\r\n   * @param to target address that will receive the tokens\r\n   * @param tokenId uint256 ID of the token to be transferred\r\n   * @param _data bytes optional data to send along with the call\r\n   * @return bool whether the call correctly returned the expected magic value\r\n   */\r\n  function _checkOnERC721Received(\r\n      address from,\r\n      address to,\r\n      uint256 tokenId,\r\n      bytes memory _data\r\n  ) private returns (bool) {\r\n      if (to.isContract()) {\r\n          try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\r\n              return retval == IERC721Receiver.onERC721Received.selector;\r\n          } catch (bytes memory reason) {\r\n              if (reason.length == 0) {\r\n                  revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n              } else {\r\n                  assembly {\r\n                      revert(add(32, reason), mload(reason))\r\n                  }\r\n              }\r\n          }\r\n      } else {\r\n          return true;\r\n      }\r\n  }\r\n\r\n  /**\r\n      Returns A List Of All Accounts With A Fractional Asset Balance Greater Than 0\r\n   */\r\n  function listAllOwners() external view returns (address[] memory) {\r\n      return _registeredOwners;\r\n  }\r\n\r\n  /**\r\n      Returns A List Of All Token IDs Belonging To `user`\r\n   */\r\n  function listIDsOwnedByUser(address user) external view returns (uint256[] memory) {\r\n      // If Zero Balance Return Empty List\r\n      uint balance = _balances[user];\r\n      uint256[] memory arr = new uint256[](balance);\r\n      if (balance <= 0) {\r\n          return arr;\r\n      }\r\n      uint count = 0;\r\n      // Loop Through All IDs To Create List\r\n      for (uint i = 0; i < _currentTokenID;) {\r\n          if (_owners[i] == user) {\r\n              arr[count] = i;\r\n              unchecked {\r\n                  ++count;\r\n              }\r\n          }\r\n          unchecked { ++i; }\r\n      }\r\n      return arr;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev See {IERC165-supportsInterface}.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n      return interfaceId == type(IERC165).interfaceId ||\r\n          interfaceId == type(INonFungibleToken).interfaceId ||\r\n          interfaceId == type(IFractionalAsset).interfaceId;\r\n  }\r\n\r\n  /**\r\n      Converts A Uint Into a String\r\n  */\r\n  function uint2str(uint _i) internal pure returns (string memory) {\r\n      if (_i == 0) {\r\n          return \"0\";\r\n      }\r\n      uint j = _i;\r\n      uint len;\r\n      while (j != 0) {\r\n          len++;\r\n          j /= 10;\r\n      }\r\n      bytes memory bstr = new bytes(len);\r\n      uint k = len;\r\n      while (_i != 0) {\r\n          k = k-1;\r\n          uint8 temp = (48 + uint8(_i - _i / 10 * 10));\r\n          bytes1 b1 = bytes1(temp);\r\n          bstr[k] = b1;\r\n          _i /= 10;\r\n      }\r\n      return string(bstr);\r\n  }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[],\"name\":\"AllowlistDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AllowlistEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"oldURI\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"}],\"name\":\"BaseURIChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newRoot\",\"type\":\"bytes32\"}],\"name\":\"MerkleRootSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCost\",\"type\":\"uint256\"}],\"name\":\"MintCostSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintingDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintingEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardsDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Database\",\"outputs\":[{\"internalType\":\"contract IDatabase\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"URI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"strings\",\"type\":\"string[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"__init__\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowlistEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"batchClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clone\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableAllowlist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableMinting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableAllowlist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableMinting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listAllOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"listIDsOwnedByUser\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mintCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numFractions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"ownerMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"pendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mintToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newCost\",\"type\":\"uint256\"}],\"name\":\"setCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRecipient\",\"type\":\"address\"}],\"name\":\"setMintRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FractionalAsset", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4e71f6604e03af6644ed7ef0a58b6df20428027a0829ccd216ac1c31cf7473e7"}