{"SourceCode": "# @title Uniswap Exchange Interface V1\r\n# @notice Source code found at https://github.com/uniswap\r\n# @notice Use at your own risk\r\n\r\ncontract Factory():\r\n    def getExchange(token_addr: address) -> address: constant\r\n\r\ncontract Exchange():\r\n    def getEthToTokenOutputPrice(tokens_bought: uint256) -> uint256(wei): constant\r\n    def ethToTokenTransferInput(min_tokens: uint256, deadline: timestamp, recipient: address) -> uint256: modifying\r\n    def ethToTokenTransferOutput(tokens_bought: uint256, deadline: timestamp, recipient: address) -> uint256(wei): modifying\r\n\r\nTokenPurchase: event({buyer: indexed(address), eth_sold: indexed(uint256(wei)), tokens_bought: indexed(uint256)})\r\nEthPurchase: event({buyer: indexed(address), tokens_sold: indexed(uint256), eth_bought: indexed(uint256(wei))})\r\nAddLiquidity: event({provider: indexed(address), eth_amount: indexed(uint256(wei)), token_amount: indexed(uint256)})\r\nRemoveLiquidity: event({provider: indexed(address), eth_amount: indexed(uint256(wei)), token_amount: indexed(uint256)})\r\nTransfer: event({_from: indexed(address), _to: indexed(address), _value: uint256})\r\nApproval: event({_owner: indexed(address), _spender: indexed(address), _value: uint256})\r\n\r\nname: public(bytes32)                             # Uniswap V1\r\nsymbol: public(bytes32)                           # UNI-V1\r\ndecimals: public(uint256)                         # 18\r\ntotalSupply: public(uint256)                      # total number of UNI in existence\r\nbalances: uint256[address]                        # UNI balance of an address\r\nallowances: (uint256[address])[address]           # UNI allowance of one address on another\r\ntoken: address(ERC20)                             # address of the ERC20 token traded on this contract\r\nfactory: Factory                                  # interface for the factory that created this contract\r\n\r\n# @dev This function acts as a contract constructor which is not currently supported in contracts deployed\r\n#      using create_with_code_of(). It is called once by the factory during contract creation.\r\n@public\r\ndef setup(token_addr: address):\r\n    assert (self.factory == ZERO_ADDRESS and self.token == ZERO_ADDRESS) and token_addr != ZERO_ADDRESS\r\n    self.factory = msg.sender\r\n    self.token = token_addr\r\n    self.name = 0x556e697377617020563100000000000000000000000000000000000000000000\r\n    self.symbol = 0x554e492d56310000000000000000000000000000000000000000000000000000\r\n    self.decimals = 18\r\n\r\n# @notice Deposit ETH and Tokens (self.token) at current ratio to mint UNI tokens.\r\n# @dev min_liquidity does nothing when total UNI supply is 0.\r\n# @param min_liquidity Minimum number of UNI sender will mint if total UNI supply is greater than 0.\r\n# @param max_tokens Maximum number of tokens deposited. Deposits max amount if total UNI supply is 0.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return The amount of UNI minted.\r\n@public\r\n@payable\r\ndef addLiquidity(min_liquidity: uint256, max_tokens: uint256, deadline: timestamp) -> uint256:\r\n    assert deadline > block.timestamp and (max_tokens > 0 and msg.value > 0)\r\n    total_liquidity: uint256 = self.totalSupply\r\n    if total_liquidity > 0:\r\n        assert min_liquidity > 0\r\n        eth_reserve: uint256(wei) = self.balance - msg.value\r\n        token_reserve: uint256 = self.token.balanceOf(self)\r\n        token_amount: uint256 = msg.value * token_reserve / eth_reserve + 1\r\n        liquidity_minted: uint256 = msg.value * total_liquidity / eth_reserve\r\n        assert max_tokens >= token_amount and liquidity_minted >= min_liquidity\r\n        self.balances[msg.sender] += liquidity_minted\r\n        self.totalSupply = total_liquidity + liquidity_minted\r\n        assert self.token.transferFrom(msg.sender, self, token_amount)\r\n        log.AddLiquidity(msg.sender, msg.value, token_amount)\r\n        log.Transfer(ZERO_ADDRESS, msg.sender, liquidity_minted)\r\n        return liquidity_minted\r\n    else:\r\n        assert (self.factory != ZERO_ADDRESS and self.token != ZERO_ADDRESS) and msg.value >= 1000000000\r\n        assert self.factory.getExchange(self.token) == self\r\n        token_amount: uint256 = max_tokens\r\n        initial_liquidity: uint256 = as_unitless_number(self.balance)\r\n        self.totalSupply = initial_liquidity\r\n        self.balances[msg.sender] = initial_liquidity\r\n        assert self.token.transferFrom(msg.sender, self, token_amount)\r\n        log.AddLiquidity(msg.sender, msg.value, token_amount)\r\n        log.Transfer(ZERO_ADDRESS, msg.sender, initial_liquidity)\r\n        return initial_liquidity\r\n\r\n# @dev Burn UNI tokens to withdraw ETH and Tokens at current ratio.\r\n# @param amount Amount of UNI burned.\r\n# @param min_eth Minimum ETH withdrawn.\r\n# @param min_tokens Minimum Tokens withdrawn.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return The amount of ETH and Tokens withdrawn.\r\n@public\r\ndef removeLiquidity(amount: uint256, min_eth: uint256(wei), min_tokens: uint256, deadline: timestamp) -> (uint256(wei), uint256):\r\n    assert (amount > 0 and deadline > block.timestamp) and (min_eth > 0 and min_tokens > 0)\r\n    total_liquidity: uint256 = self.totalSupply\r\n    assert total_liquidity > 0\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    eth_amount: uint256(wei) = amount * self.balance / total_liquidity\r\n    token_amount: uint256 = amount * token_reserve / total_liquidity\r\n    assert eth_amount >= min_eth and token_amount >= min_tokens\r\n    self.balances[msg.sender] -= amount\r\n    self.totalSupply = total_liquidity - amount\r\n    send(msg.sender, eth_amount)\r\n    assert self.token.transfer(msg.sender, token_amount)\r\n    log.RemoveLiquidity(msg.sender, eth_amount, token_amount)\r\n    log.Transfer(msg.sender, ZERO_ADDRESS, amount)\r\n    return eth_amount, token_amount\r\n\r\n# @dev Pricing function for converting between ETH and Tokens.\r\n# @param input_amount Amount of ETH or Tokens being sold.\r\n# @param input_reserve Amount of ETH or Tokens (input type) in exchange reserves.\r\n# @param output_reserve Amount of ETH or Tokens (output type) in exchange reserves.\r\n# @return Amount of ETH or Tokens bought.\r\n@private\r\n@constant\r\ndef getInputPrice(input_amount: uint256, input_reserve: uint256, output_reserve: uint256) -> uint256:\r\n    assert input_reserve > 0 and output_reserve > 0\r\n    input_amount_with_fee: uint256 = input_amount * 997\r\n    numerator: uint256 = input_amount_with_fee * output_reserve\r\n    denominator: uint256 = (input_reserve * 1000) + input_amount_with_fee\r\n    return numerator / denominator\r\n\r\n# @dev Pricing function for converting between ETH and Tokens.\r\n# @param output_amount Amount of ETH or Tokens being bought.\r\n# @param input_reserve Amount of ETH or Tokens (input type) in exchange reserves.\r\n# @param output_reserve Amount of ETH or Tokens (output type) in exchange reserves.\r\n# @return Amount of ETH or Tokens sold.\r\n@private\r\n@constant\r\ndef getOutputPrice(output_amount: uint256, input_reserve: uint256, output_reserve: uint256) -> uint256:\r\n    assert input_reserve > 0 and output_reserve > 0\r\n    numerator: uint256 = input_reserve * output_amount * 1000\r\n    denominator: uint256 = (output_reserve - output_amount) * 997\r\n    return numerator / denominator + 1\r\n\r\n@private\r\ndef ethToTokenInput(eth_sold: uint256(wei), min_tokens: uint256, deadline: timestamp, buyer: address, recipient: address) -> uint256:\r\n    assert deadline >= block.timestamp and (eth_sold > 0 and min_tokens > 0)\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    tokens_bought: uint256 = self.getInputPrice(as_unitless_number(eth_sold), as_unitless_number(self.balance - eth_sold), token_reserve)\r\n    assert tokens_bought >= min_tokens\r\n    assert self.token.transfer(recipient, tokens_bought)\r\n    log.TokenPurchase(buyer, eth_sold, tokens_bought)\r\n    return tokens_bought\r\n\r\n# @notice Convert ETH to Tokens.\r\n# @dev User specifies exact input (msg.value).\r\n# @dev User cannot specify minimum output or deadline.\r\n@public\r\n@payable\r\ndef __default__():\r\n    self.ethToTokenInput(msg.value, 1, block.timestamp, msg.sender, msg.sender)\r\n\r\n# @notice Convert ETH to Tokens.\r\n# @dev User specifies exact input (msg.value) and minimum output.\r\n# @param min_tokens Minimum Tokens bought.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return Amount of Tokens bought.\r\n@public\r\n@payable\r\ndef ethToTokenSwapInput(min_tokens: uint256, deadline: timestamp) -> uint256:\r\n    return self.ethToTokenInput(msg.value, min_tokens, deadline, msg.sender, msg.sender)\r\n\r\n# @notice Convert ETH to Tokens and transfers Tokens to recipient.\r\n# @dev User specifies exact input (msg.value) and minimum output\r\n# @param min_tokens Minimum Tokens bought.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output Tokens.\r\n# @return Amount of Tokens bought.\r\n@public\r\n@payable\r\ndef ethToTokenTransferInput(min_tokens: uint256, deadline: timestamp, recipient: address) -> uint256:\r\n    assert recipient != self and recipient != ZERO_ADDRESS\r\n    return self.ethToTokenInput(msg.value, min_tokens, deadline, msg.sender, recipient)\r\n\r\n@private\r\ndef ethToTokenOutput(tokens_bought: uint256, max_eth: uint256(wei), deadline: timestamp, buyer: address, recipient: address) -> uint256(wei):\r\n    assert deadline >= block.timestamp and (tokens_bought > 0 and max_eth > 0)\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    eth_sold: uint256 = self.getOutputPrice(tokens_bought, as_unitless_number(self.balance - max_eth), token_reserve)\r\n    # Throws if eth_sold > max_eth\r\n    eth_refund: uint256(wei) = max_eth - as_wei_value(eth_sold, 'wei')\r\n    if eth_refund > 0:\r\n        send(buyer, eth_refund)\r\n    assert self.token.transfer(recipient, tokens_bought)\r\n    log.TokenPurchase(buyer, as_wei_value(eth_sold, 'wei'), tokens_bought)\r\n    return as_wei_value(eth_sold, 'wei')\r\n\r\n# @notice Convert ETH to Tokens.\r\n# @dev User specifies maximum input (msg.value) and exact output.\r\n# @param tokens_bought Amount of tokens bought.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return Amount of ETH sold.\r\n@public\r\n@payable\r\ndef ethToTokenSwapOutput(tokens_bought: uint256, deadline: timestamp) -> uint256(wei):\r\n    return self.ethToTokenOutput(tokens_bought, msg.value, deadline, msg.sender, msg.sender)\r\n\r\n# @notice Convert ETH to Tokens and transfers Tokens to recipient.\r\n# @dev User specifies maximum input (msg.value) and exact output.\r\n# @param tokens_bought Amount of tokens bought.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output Tokens.\r\n# @return Amount of ETH sold.\r\n@public\r\n@payable\r\ndef ethToTokenTransferOutput(tokens_bought: uint256, deadline: timestamp, recipient: address) -> uint256(wei):\r\n    assert recipient != self and recipient != ZERO_ADDRESS\r\n    return self.ethToTokenOutput(tokens_bought, msg.value, deadline, msg.sender, recipient)\r\n\r\n@private\r\ndef tokenToEthInput(tokens_sold: uint256, min_eth: uint256(wei), deadline: timestamp, buyer: address, recipient: address) -> uint256(wei):\r\n    assert deadline >= block.timestamp and (tokens_sold > 0 and min_eth > 0)\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    eth_bought: uint256 = self.getInputPrice(tokens_sold, token_reserve, as_unitless_number(self.balance))\r\n    wei_bought: uint256(wei) = as_wei_value(eth_bought, 'wei')\r\n    assert wei_bought >= min_eth\r\n    send(recipient, wei_bought)\r\n    assert self.token.transferFrom(buyer, self, tokens_sold)\r\n    log.EthPurchase(buyer, tokens_sold, wei_bought)\r\n    return wei_bought\r\n\r\n\r\n# @notice Convert Tokens to ETH.\r\n# @dev User specifies exact input and minimum output.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @param min_eth Minimum ETH purchased.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return Amount of ETH bought.\r\n@public\r\ndef tokenToEthSwapInput(tokens_sold: uint256, min_eth: uint256(wei), deadline: timestamp) -> uint256(wei):\r\n    return self.tokenToEthInput(tokens_sold, min_eth, deadline, msg.sender, msg.sender)\r\n\r\n# @notice Convert Tokens to ETH and transfers ETH to recipient.\r\n# @dev User specifies exact input and minimum output.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @param min_eth Minimum ETH purchased.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output ETH.\r\n# @return Amount of ETH bought.\r\n@public\r\ndef tokenToEthTransferInput(tokens_sold: uint256, min_eth: uint256(wei), deadline: timestamp, recipient: address) -> uint256(wei):\r\n    assert recipient != self and recipient != ZERO_ADDRESS\r\n    return self.tokenToEthInput(tokens_sold, min_eth, deadline, msg.sender, recipient)\r\n\r\n@private\r\ndef tokenToEthOutput(eth_bought: uint256(wei), max_tokens: uint256, deadline: timestamp, buyer: address, recipient: address) -> uint256:\r\n    assert deadline >= block.timestamp and eth_bought > 0\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    tokens_sold: uint256 = self.getOutputPrice(as_unitless_number(eth_bought), token_reserve, as_unitless_number(self.balance))\r\n    # tokens sold is always > 0\r\n    assert max_tokens >= tokens_sold\r\n    send(recipient, eth_bought)\r\n    assert self.token.transferFrom(buyer, self, tokens_sold)\r\n    log.EthPurchase(buyer, tokens_sold, eth_bought)\r\n    return tokens_sold\r\n\r\n# @notice Convert Tokens to ETH.\r\n# @dev User specifies maximum input and exact output.\r\n# @param eth_bought Amount of ETH purchased.\r\n# @param max_tokens Maximum Tokens sold.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return Amount of Tokens sold.\r\n@public\r\ndef tokenToEthSwapOutput(eth_bought: uint256(wei), max_tokens: uint256, deadline: timestamp) -> uint256:\r\n    return self.tokenToEthOutput(eth_bought, max_tokens, deadline, msg.sender, msg.sender)\r\n\r\n# @notice Convert Tokens to ETH and transfers ETH to recipient.\r\n# @dev User specifies maximum input and exact output.\r\n# @param eth_bought Amount of ETH purchased.\r\n# @param max_tokens Maximum Tokens sold.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output ETH.\r\n# @return Amount of Tokens sold.\r\n@public\r\ndef tokenToEthTransferOutput(eth_bought: uint256(wei), max_tokens: uint256, deadline: timestamp, recipient: address) -> uint256:\r\n    assert recipient != self and recipient != ZERO_ADDRESS\r\n    return self.tokenToEthOutput(eth_bought, max_tokens, deadline, msg.sender, recipient)\r\n\r\n@private\r\ndef tokenToTokenInput(tokens_sold: uint256, min_tokens_bought: uint256, min_eth_bought: uint256(wei), deadline: timestamp, buyer: address, recipient: address, exchange_addr: address) -> uint256:\r\n    assert (deadline >= block.timestamp and tokens_sold > 0) and (min_tokens_bought > 0 and min_eth_bought > 0)\r\n    assert exchange_addr != self and exchange_addr != ZERO_ADDRESS\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    eth_bought: uint256 = self.getInputPrice(tokens_sold, token_reserve, as_unitless_number(self.balance))\r\n    wei_bought: uint256(wei) = as_wei_value(eth_bought, 'wei')\r\n    assert wei_bought >= min_eth_bought\r\n    assert self.token.transferFrom(buyer, self, tokens_sold)\r\n    tokens_bought: uint256 = Exchange(exchange_addr).ethToTokenTransferInput(min_tokens_bought, deadline, recipient, value=wei_bought)\r\n    log.EthPurchase(buyer, tokens_sold, wei_bought)\r\n    return tokens_bought\r\n\r\n# @notice Convert Tokens (self.token) to Tokens (token_addr).\r\n# @dev User specifies exact input and minimum output.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @param min_tokens_bought Minimum Tokens (token_addr) purchased.\r\n# @param min_eth_bought Minimum ETH purchased as intermediary.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param token_addr The address of the token being purchased.\r\n# @return Amount of Tokens (token_addr) bought.\r\n@public\r\ndef tokenToTokenSwapInput(tokens_sold: uint256, min_tokens_bought: uint256, min_eth_bought: uint256(wei), deadline: timestamp, token_addr: address) -> uint256:\r\n    exchange_addr: address = self.factory.getExchange(token_addr)\r\n    return self.tokenToTokenInput(tokens_sold, min_tokens_bought, min_eth_bought, deadline, msg.sender, msg.sender, exchange_addr)\r\n\r\n# @notice Convert Tokens (self.token) to Tokens (token_addr) and transfers\r\n#         Tokens (token_addr) to recipient.\r\n# @dev User specifies exact input and minimum output.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @param min_tokens_bought Minimum Tokens (token_addr) purchased.\r\n# @param min_eth_bought Minimum ETH purchased as intermediary.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output ETH.\r\n# @param token_addr The address of the token being purchased.\r\n# @return Amount of Tokens (token_addr) bought.\r\n@public\r\ndef tokenToTokenTransferInput(tokens_sold: uint256, min_tokens_bought: uint256, min_eth_bought: uint256(wei), deadline: timestamp, recipient: address, token_addr: address) -> uint256:\r\n    exchange_addr: address = self.factory.getExchange(token_addr)\r\n    return self.tokenToTokenInput(tokens_sold, min_tokens_bought, min_eth_bought, deadline, msg.sender, recipient, exchange_addr)\r\n\r\n@private\r\ndef tokenToTokenOutput(tokens_bought: uint256, max_tokens_sold: uint256, max_eth_sold: uint256(wei), deadline: timestamp, buyer: address, recipient: address, exchange_addr: address) -> uint256:\r\n    assert deadline >= block.timestamp and (tokens_bought > 0 and max_eth_sold > 0)\r\n    assert exchange_addr != self and exchange_addr != ZERO_ADDRESS\r\n    eth_bought: uint256(wei) = Exchange(exchange_addr).getEthToTokenOutputPrice(tokens_bought)\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    tokens_sold: uint256 = self.getOutputPrice(as_unitless_number(eth_bought), token_reserve, as_unitless_number(self.balance))\r\n    # tokens sold is always > 0\r\n    assert max_tokens_sold >= tokens_sold and max_eth_sold >= eth_bought\r\n    assert self.token.transferFrom(buyer, self, tokens_sold)\r\n    eth_sold: uint256(wei) = Exchange(exchange_addr).ethToTokenTransferOutput(tokens_bought, deadline, recipient, value=eth_bought)\r\n    log.EthPurchase(buyer, tokens_sold, eth_bought)\r\n    return tokens_sold\r\n\r\n# @notice Convert Tokens (self.token) to Tokens (token_addr).\r\n# @dev User specifies maximum input and exact output.\r\n# @param tokens_bought Amount of Tokens (token_addr) bought.\r\n# @param max_tokens_sold Maximum Tokens (self.token) sold.\r\n# @param max_eth_sold Maximum ETH purchased as intermediary.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param token_addr The address of the token being purchased.\r\n# @return Amount of Tokens (self.token) sold.\r\n@public\r\ndef tokenToTokenSwapOutput(tokens_bought: uint256, max_tokens_sold: uint256, max_eth_sold: uint256(wei), deadline: timestamp, token_addr: address) -> uint256:\r\n    exchange_addr: address = self.factory.getExchange(token_addr)\r\n    return self.tokenToTokenOutput(tokens_bought, max_tokens_sold, max_eth_sold, deadline, msg.sender, msg.sender, exchange_addr)\r\n\r\n# @notice Convert Tokens (self.token) to Tokens (token_addr) and transfers\r\n#         Tokens (token_addr) to recipient.\r\n# @dev User specifies maximum input and exact output.\r\n# @param tokens_bought Amount of Tokens (token_addr) bought.\r\n# @param max_tokens_sold Maximum Tokens (self.token) sold.\r\n# @param max_eth_sold Maximum ETH purchased as intermediary.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output ETH.\r\n# @param token_addr The address of the token being purchased.\r\n# @return Amount of Tokens (self.token) sold.\r\n@public\r\ndef tokenToTokenTransferOutput(tokens_bought: uint256, max_tokens_sold: uint256, max_eth_sold: uint256(wei), deadline: timestamp, recipient: address, token_addr: address) -> uint256:\r\n    exchange_addr: address = self.factory.getExchange(token_addr)\r\n    return self.tokenToTokenOutput(tokens_bought, max_tokens_sold, max_eth_sold, deadline, msg.sender, recipient, exchange_addr)\r\n\r\n# @notice Convert Tokens (self.token) to Tokens (exchange_addr.token).\r\n# @dev Allows trades through contracts that were not deployed from the same factory.\r\n# @dev User specifies exact input and minimum output.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @param min_tokens_bought Minimum Tokens (token_addr) purchased.\r\n# @param min_eth_bought Minimum ETH purchased as intermediary.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param exchange_addr The address of the exchange for the token being purchased.\r\n# @return Amount of Tokens (exchange_addr.token) bought.\r\n@public\r\ndef tokenToExchangeSwapInput(tokens_sold: uint256, min_tokens_bought: uint256, min_eth_bought: uint256(wei), deadline: timestamp, exchange_addr: address) -> uint256:\r\n    return self.tokenToTokenInput(tokens_sold, min_tokens_bought, min_eth_bought, deadline, msg.sender, msg.sender, exchange_addr)\r\n\r\n# @notice Convert Tokens (self.token) to Tokens (exchange_addr.token) and transfers\r\n#         Tokens (exchange_addr.token) to recipient.\r\n# @dev Allows trades through contracts that were not deployed from the same factory.\r\n# @dev User specifies exact input and minimum output.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @param min_tokens_bought Minimum Tokens (token_addr) purchased.\r\n# @param min_eth_bought Minimum ETH purchased as intermediary.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output ETH.\r\n# @param exchange_addr The address of the exchange for the token being purchased.\r\n# @return Amount of Tokens (exchange_addr.token) bought.\r\n@public\r\ndef tokenToExchangeTransferInput(tokens_sold: uint256, min_tokens_bought: uint256, min_eth_bought: uint256(wei), deadline: timestamp, recipient: address, exchange_addr: address) -> uint256:\r\n    assert recipient != self\r\n    return self.tokenToTokenInput(tokens_sold, min_tokens_bought, min_eth_bought, deadline, msg.sender, recipient, exchange_addr)\r\n\r\n# @notice Convert Tokens (self.token) to Tokens (exchange_addr.token).\r\n# @dev Allows trades through contracts that were not deployed from the same factory.\r\n# @dev User specifies maximum input and exact output.\r\n# @param tokens_bought Amount of Tokens (token_addr) bought.\r\n# @param max_tokens_sold Maximum Tokens (self.token) sold.\r\n# @param max_eth_sold Maximum ETH purchased as intermediary.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param exchange_addr The address of the exchange for the token being purchased.\r\n# @return Amount of Tokens (self.token) sold.\r\n@public\r\ndef tokenToExchangeSwapOutput(tokens_bought: uint256, max_tokens_sold: uint256, max_eth_sold: uint256(wei), deadline: timestamp, exchange_addr: address) -> uint256:\r\n    return self.tokenToTokenOutput(tokens_bought, max_tokens_sold, max_eth_sold, deadline, msg.sender, msg.sender, exchange_addr)\r\n\r\n# @notice Convert Tokens (self.token) to Tokens (exchange_addr.token) and transfers\r\n#         Tokens (exchange_addr.token) to recipient.\r\n# @dev Allows trades through contracts that were not deployed from the same factory.\r\n# @dev User specifies maximum input and exact output.\r\n# @param tokens_bought Amount of Tokens (token_addr) bought.\r\n# @param max_tokens_sold Maximum Tokens (self.token) sold.\r\n# @param max_eth_sold Maximum ETH purchased as intermediary.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output ETH.\r\n# @param token_addr The address of the token being purchased.\r\n# @return Amount of Tokens (self.token) sold.\r\n@public\r\ndef tokenToExchangeTransferOutput(tokens_bought: uint256, max_tokens_sold: uint256, max_eth_sold: uint256(wei), deadline: timestamp, recipient: address, exchange_addr: address) -> uint256:\r\n    assert recipient != self\r\n    return self.tokenToTokenOutput(tokens_bought, max_tokens_sold, max_eth_sold, deadline, msg.sender, recipient, exchange_addr)\r\n\r\n# @notice Public price function for ETH to Token trades with an exact input.\r\n# @param eth_sold Amount of ETH sold.\r\n# @return Amount of Tokens that can be bought with input ETH.\r\n@public\r\n@constant\r\ndef getEthToTokenInputPrice(eth_sold: uint256(wei)) -> uint256:\r\n    assert eth_sold > 0\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    return self.getInputPrice(as_unitless_number(eth_sold), as_unitless_number(self.balance), token_reserve)\r\n\r\n# @notice Public price function for ETH to Token trades with an exact output.\r\n# @param tokens_bought Amount of Tokens bought.\r\n# @return Amount of ETH needed to buy output Tokens.\r\n@public\r\n@constant\r\ndef getEthToTokenOutputPrice(tokens_bought: uint256) -> uint256(wei):\r\n    assert tokens_bought > 0\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    eth_sold: uint256 = self.getOutputPrice(tokens_bought, as_unitless_number(self.balance), token_reserve)\r\n    return as_wei_value(eth_sold, 'wei')\r\n\r\n# @notice Public price function for Token to ETH trades with an exact input.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @return Amount of ETH that can be bought with input Tokens.\r\n@public\r\n@constant\r\ndef getTokenToEthInputPrice(tokens_sold: uint256) -> uint256(wei):\r\n    assert tokens_sold > 0\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    eth_bought: uint256 = self.getInputPrice(tokens_sold, token_reserve, as_unitless_number(self.balance))\r\n    return as_wei_value(eth_bought, 'wei')\r\n\r\n# @notice Public price function for Token to ETH trades with an exact output.\r\n# @param eth_bought Amount of output ETH.\r\n# @return Amount of Tokens needed to buy output ETH.\r\n@public\r\n@constant\r\ndef getTokenToEthOutputPrice(eth_bought: uint256(wei)) -> uint256:\r\n    assert eth_bought > 0\r\n    token_reserve: uint256 = self.token.balanceOf(self)\r\n    return self.getOutputPrice(as_unitless_number(eth_bought), token_reserve, as_unitless_number(self.balance))\r\n\r\n# @return Address of Token that is sold on this exchange.\r\n@public\r\n@constant\r\ndef tokenAddress() -> address:\r\n    return self.token\r\n\r\n# @return Address of factory that created this exchange.\r\n@public\r\n@constant\r\ndef factoryAddress() -> address(Factory):\r\n    return self.factory\r\n\r\n# ERC20 compatibility for exchange liquidity modified from\r\n# https://github.com/ethereum/vyper/blob/master/examples/tokens/ERC20.vy\r\n@public\r\n@constant\r\ndef balanceOf(_owner : address) -> uint256:\r\n    return self.balances[_owner]\r\n\r\n@public\r\ndef transfer(_to : address, _value : uint256) -> bool:\r\n    self.balances[msg.sender] -= _value\r\n    self.balances[_to] += _value\r\n    log.Transfer(msg.sender, _to, _value)\r\n    return True\r\n\r\n@public\r\ndef transferFrom(_from : address, _to : address, _value : uint256) -> bool:\r\n    self.balances[_from] -= _value\r\n    self.balances[_to] += _value\r\n    self.allowances[_from][msg.sender] -= _value\r\n    log.Transfer(_from, _to, _value)\r\n    return True\r\n\r\n@public\r\ndef approve(_spender : address, _value : uint256) -> bool:\r\n    self.allowances[msg.sender][_spender] = _value\r\n    log.Approval(msg.sender, _spender, _value)\r\n    return True\r\n\r\n@public\r\n@constant\r\ndef allowance(_owner : address, _spender : address) -> uint256:\r\n    return self.allowances[_owner][_spender]", "ABI": "[{\"name\":\"TokenPurchase\",\"inputs\":[{\"type\":\"address\",\"name\":\"buyer\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"eth_sold\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"tokens_bought\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"EthPurchase\",\"inputs\":[{\"type\":\"address\",\"name\":\"buyer\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"tokens_sold\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"eth_bought\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AddLiquidity\",\"inputs\":[{\"type\":\"address\",\"name\":\"provider\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"eth_amount\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"token_amount\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveLiquidity\",\"inputs\":[{\"type\":\"address\",\"name\":\"provider\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"eth_amount\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"token_amount\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Transfer\",\"inputs\":[{\"type\":\"address\",\"name\":\"_from\",\"indexed\":true},{\"type\":\"address\",\"name\":\"_to\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"_value\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Approval\",\"inputs\":[{\"type\":\"address\",\"name\":\"_owner\",\"indexed\":true},{\"type\":\"address\",\"name\":\"_spender\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"_value\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"setup\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"token_addr\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":175875},{\"name\":\"addLiquidity\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"min_liquidity\"},{\"type\":\"uint256\",\"name\":\"max_tokens\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"constant\":false,\"payable\":true,\"type\":\"function\",\"gas\":82616},{\"name\":\"removeLiquidity\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"},{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"amount\"},{\"type\":\"uint256\",\"name\":\"min_eth\"},{\"type\":\"uint256\",\"name\":\"min_tokens\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":116814},{\"name\":\"__default__\",\"outputs\":[],\"inputs\":[],\"constant\":false,\"payable\":true,\"type\":\"function\"},{\"name\":\"ethToTokenSwapInput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"min_tokens\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"constant\":false,\"payable\":true,\"type\":\"function\",\"gas\":12757},{\"name\":\"ethToTokenTransferInput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"min_tokens\"},{\"type\":\"uint256\",\"name\":\"deadline\"},{\"type\":\"address\",\"name\":\"recipient\"}],\"constant\":false,\"payable\":true,\"type\":\"function\",\"gas\":12965},{\"name\":\"ethToTokenSwapOutput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_bought\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"constant\":false,\"payable\":true,\"type\":\"function\",\"gas\":50463},{\"name\":\"ethToTokenTransferOutput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_bought\"},{\"type\":\"uint256\",\"name\":\"deadline\"},{\"type\":\"address\",\"name\":\"recipient\"}],\"constant\":false,\"payable\":true,\"type\":\"function\",\"gas\":50671},{\"name\":\"tokenToEthSwapInput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_sold\"},{\"type\":\"uint256\",\"name\":\"min_eth\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":47503},{\"name\":\"tokenToEthTransferInput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_sold\"},{\"type\":\"uint256\",\"name\":\"min_eth\"},{\"type\":\"uint256\",\"name\":\"deadline\"},{\"type\":\"address\",\"name\":\"recipient\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":47712},{\"name\":\"tokenToEthSwapOutput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"eth_bought\"},{\"type\":\"uint256\",\"name\":\"max_tokens\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":50175},{\"name\":\"tokenToEthTransferOutput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"eth_bought\"},{\"type\":\"uint256\",\"name\":\"max_tokens\"},{\"type\":\"uint256\",\"name\":\"deadline\"},{\"type\":\"address\",\"name\":\"recipient\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":50384},{\"name\":\"tokenToTokenSwapInput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_sold\"},{\"type\":\"uint256\",\"name\":\"min_tokens_bought\"},{\"type\":\"uint256\",\"name\":\"min_eth_bought\"},{\"type\":\"uint256\",\"name\":\"deadline\"},{\"type\":\"address\",\"name\":\"token_addr\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":51007},{\"name\":\"tokenToTokenTransferInput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_sold\"},{\"type\":\"uint256\",\"name\":\"min_tokens_bought\"},{\"type\":\"uint256\",\"name\":\"min_eth_bought\"},{\"type\":\"uint256\",\"name\":\"deadline\"},{\"type\":\"address\",\"name\":\"recipient\"},{\"type\":\"address\",\"name\":\"token_addr\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":51098},{\"name\":\"tokenToTokenSwapOutput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_bought\"},{\"type\":\"uint256\",\"name\":\"max_tokens_sold\"},{\"type\":\"uint256\",\"name\":\"max_eth_sold\"},{\"type\":\"uint256\",\"name\":\"deadline\"},{\"type\":\"address\",\"name\":\"token_addr\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":54928},{\"name\":\"tokenToTokenTransferOutput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_bought\"},{\"type\":\"uint256\",\"name\":\"max_tokens_sold\"},{\"type\":\"uint256\",\"name\":\"max_eth_sold\"},{\"type\":\"uint256\",\"name\":\"deadline\"},{\"type\":\"address\",\"name\":\"recipient\"},{\"type\":\"address\",\"name\":\"token_addr\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":55019},{\"name\":\"tokenToExchangeSwapInput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_sold\"},{\"type\":\"uint256\",\"name\":\"min_tokens_bought\"},{\"type\":\"uint256\",\"name\":\"min_eth_bought\"},{\"type\":\"uint256\",\"name\":\"deadline\"},{\"type\":\"address\",\"name\":\"exchange_addr\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":49342},{\"name\":\"tokenToExchangeTransferInput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_sold\"},{\"type\":\"uint256\",\"name\":\"min_tokens_bought\"},{\"type\":\"uint256\",\"name\":\"min_eth_bought\"},{\"type\":\"uint256\",\"name\":\"deadline\"},{\"type\":\"address\",\"name\":\"recipient\"},{\"type\":\"address\",\"name\":\"exchange_addr\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":49532},{\"name\":\"tokenToExchangeSwapOutput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_bought\"},{\"type\":\"uint256\",\"name\":\"max_tokens_sold\"},{\"type\":\"uint256\",\"name\":\"max_eth_sold\"},{\"type\":\"uint256\",\"name\":\"deadline\"},{\"type\":\"address\",\"name\":\"exchange_addr\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":53233},{\"name\":\"tokenToExchangeTransferOutput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_bought\"},{\"type\":\"uint256\",\"name\":\"max_tokens_sold\"},{\"type\":\"uint256\",\"name\":\"max_eth_sold\"},{\"type\":\"uint256\",\"name\":\"deadline\"},{\"type\":\"address\",\"name\":\"recipient\"},{\"type\":\"address\",\"name\":\"exchange_addr\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":53423},{\"name\":\"getEthToTokenInputPrice\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"eth_sold\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":5542},{\"name\":\"getEthToTokenOutputPrice\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_bought\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":6872},{\"name\":\"getTokenToEthInputPrice\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_sold\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":5637},{\"name\":\"getTokenToEthOutputPrice\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"eth_bought\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":6897},{\"name\":\"tokenAddress\",\"outputs\":[{\"type\":\"address\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1413},{\"name\":\"factoryAddress\",\"outputs\":[{\"type\":\"address\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1443},{\"name\":\"balanceOf\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_owner\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1645},{\"name\":\"transfer\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":75034},{\"name\":\"transferFrom\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":110907},{\"name\":\"approve\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_spender\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":38769},{\"name\":\"allowance\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_owner\"},{\"type\":\"address\",\"name\":\"_spender\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1925},{\"name\":\"name\",\"outputs\":[{\"type\":\"bytes32\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1623},{\"name\":\"symbol\",\"outputs\":[{\"type\":\"bytes32\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1653},{\"name\":\"decimals\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1683},{\"name\":\"totalSupply\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1713}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.1.0b4", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}