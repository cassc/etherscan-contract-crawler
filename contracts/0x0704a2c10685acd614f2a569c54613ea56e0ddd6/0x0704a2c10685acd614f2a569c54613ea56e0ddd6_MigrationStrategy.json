{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/MigrationStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.8.0;\\n\\nimport \\\"./BaseStrategy.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\n\\ncontract MigrationStrategy is BaseStrategy {\\n    using SafeTransferLib for ERC20;\\n\\n    address public abraMultiSig;\\n    int256 public lossValue;\\n\\n    constructor(\\n        address _bentoBox,\\n        address _strategyToken,\\n        address _strategyExecutor,\\n        address _feeTo,\\n        address _owner,\\n        uint256 _fee,\\n        address _abraMultiSig\\n    ) BaseStrategy(_bentoBox, _strategyToken, _strategyExecutor, _feeTo, _owner, _fee) {\\n        abraMultiSig = _abraMultiSig;\\n    }\\n\\n    function _skim(uint256 amount) internal override {\\n        strategyToken.safeTransfer(abraMultiSig, amount);\\n    }\\n\\n    function _harvest(uint256 /*balance*/) internal view override returns (int256) {\\n        return int256(lossValue);\\n    }\\n\\n    function withdraw(uint256 /*amount*/) external pure override returns (uint256) {\\n        revert();\\n    }\\n\\n    function _exit() internal override {}\\n\\n    function setLossValue(int256 _val) public onlyExecutor {\\n        lossValue = _val;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/BaseStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.8.0;\\n\\nimport {IStrategy} from \\\"interfaces/IStrategy.sol\\\";\\nimport {IBentoBoxMinimal} from \\\"interfaces/IBentoBoxMinimal.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {Owned} from \\\"solmate/auth/Owned.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\n\\n/// @title Base contract for BentoBox Strategies\\n/// @dev Extend the contract and implement _skim, _harvest, _withdraw, _exit and _harvestRewards methods.\\nabstract contract BaseStrategy is IStrategy, Owned {\\n    using SafeTransferLib for ERC20;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                ADDRESSES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice address of the token in strategy\\n    ERC20 public immutable strategyToken;\\n\\n    /// @notice address of bentobox\\n    IBentoBoxMinimal private immutable bentoBox;\\n\\n    /// @notice address of the performance fee receiver\\n    address public feeTo;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            STRATEGY STATES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice status of the exit strategy\\n    /// @dev After bentobox 'exits' the strategy harvest and withdraw functions can no longer be called.\\n    bool private _exited;\\n\\n    /// @notice slippage protection during harvest\\n    uint256 private _maxBentoBoxBalance;\\n\\n    /// @notice performance fee\\n    uint256 public fee;\\n\\n    /// @notice performance fee precision\\n    uint256 public FEE_PRECISION = 1e18;\\n\\n    /// @notice executors address status\\n    mapping(address => bool) public strategyExecutors;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event LogSetStrategyExecutor(address indexed executor, bool allowed);\\n    event LogSetSwapPath(address indexed input, address indexed output);\\n    event LogFeeUpdated(uint256 fee);\\n    event LogFeeToUpdated(address newFeeTo);\\n    event LogPerformanceFee(ERC20 indexed token, uint256 indexed amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 ERRORS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    error StrategyExited();\\n    error StrategyNotExited();\\n    error OnlyBentoBox();\\n    error OnlyExecutor();\\n    error InvalidFee();\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice sets the strategy configurations\\n    /// @param _bentoBox address of the bentobox\\n    /// @param _strategyToken address of the token in strategy\\n    /// @param _strategyExecutor address of the executor\\n    /// @param _feeTo address of the fee recipient\\n    /// @param _owner address of the owner of the strategy\\n    /// @param _fee fee for the strategy\\n    constructor(\\n        address _bentoBox,\\n        address _strategyToken,\\n        address _strategyExecutor,\\n        address _feeTo,\\n        address _owner,\\n        uint256 _fee\\n    ) Owned(_owner) {\\n        strategyToken = ERC20(_strategyToken);\\n        bentoBox = IBentoBoxMinimal(_bentoBox);\\n        strategyExecutors[_strategyExecutor] = true;\\n        feeTo = _feeTo;\\n        if (_fee >= 1e18) revert InvalidFee();\\n        fee = _fee;\\n        emit LogFeeUpdated(_fee);\\n        emit LogSetStrategyExecutor(_strategyExecutor, true);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            MODIFIERS \\n    //////////////////////////////////////////////////////////////*/\\n\\n    modifier isActive() {\\n        if (_exited) {\\n            revert StrategyExited();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyBentoBox() {\\n        if (msg.sender != address(bentoBox)) {\\n            revert OnlyBentoBox();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyExecutor() {\\n        if (!strategyExecutors[msg.sender]) {\\n            revert OnlyExecutor();\\n        }\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        STRATEGY CONFIG FUNCTIONS \\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Sets the status of the executors\\n    /// @param executor address of the executor to be updated\\n    /// @param status status of the exectuor to be updated\\n    function setStrategyExecutor(address executor, bool status) external onlyOwner {\\n        strategyExecutors[executor] = status;\\n        emit LogSetStrategyExecutor(executor, status);\\n    }\\n\\n    /// @notice Sets the performance fee\\n    /// @param newFee new fee\\n    /// @dev should be less than 1e18 (cannot set it to 100%)\\n    function setFee(uint256 newFee) external onlyOwner {\\n        if (newFee >= 1e18) revert InvalidFee();\\n        fee = newFee;\\n        emit LogFeeUpdated(newFee);\\n    }\\n\\n    /// @notice Sets the fee receiver\\n    /// @param newFeeTo address of the new fee receiver\\n    function setFeeTo(address newFeeTo) external onlyOwner {\\n        feeTo = newFeeTo;\\n        emit LogFeeToUpdated(newFeeTo);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        OVERRIDE FUNCTIONS \\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Invests the underlying asset.\\n    /// @param amount The amount of tokens to invest.\\n    /// @dev Assume the contract's balance is greater than the amount.\\n    function _skim(uint256 amount) internal virtual;\\n\\n    /// @notice Harvest any profits made and transfer them to address(this) or report a loss.\\n    /// @param balance The amount of tokens that have been invested.\\n    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.\\n    /// @dev amountAdded can be left at 0 when reporting profits (gas savings).\\n    /// amountAdded should not reflect any rewards or tokens the strategy received.\\n    /// Calculate the amount added based on what the current deposit is worth.\\n    /// (The Base Strategy harvest function accounts for rewards).\\n    function _harvest(uint256 balance) internal virtual returns (int256 amountAdded);\\n\\n    /// @notice Withdraw the maximum available amount of the invested assets to address(this).\\n    /// @dev This shouldn't revert (use try catch).\\n    function _exit() internal virtual;\\n\\n    /// @notice Claim any reward tokens and optionally sell them for the underlying token.\\n    /// @dev Doesn't need to be implemented if we don't expect any rewards.\\n    function _harvestRewards() internal virtual {}\\n\\n    /// @inheritdoc IStrategy\\n    function skim(uint256 amount) external override {\\n        _skim(amount);\\n    }\\n\\n    /// @notice Harvest profits while preventing a sandwich attack exploit.\\n    /// @param maxBalanceInBentoBox The maximum balance of the underlying token that is allowed to be in BentoBox.\\n    /// @param rebalance Whether BentoBox should rebalance the strategy assets to acheive it's target allocation.\\n    /// @param maxChangeAmount When rebalancing - the maximum amount that will be deposited to or withdrawn from a strategy to BentoBox.\\n    /// @param harvestRewards If we want to claim any accrued reward tokens\\n    /// @dev maxBalance can be set to 0 to keep the previous value.\\n    /// @dev maxChangeAmount can be set to 0 to allow for full rebalancing.\\n    function safeHarvest(uint256 maxBalanceInBentoBox, bool rebalance, uint256 maxChangeAmount, bool harvestRewards) external onlyExecutor {\\n        if (harvestRewards) {\\n            _harvestRewards();\\n        }\\n\\n        if (maxBalanceInBentoBox > 0) {\\n            _maxBentoBoxBalance = maxBalanceInBentoBox;\\n        }\\n\\n        bentoBox.harvest(address(strategyToken), rebalance, maxChangeAmount);\\n    }\\n\\n    /** @inheritdoc IStrategy\\n    @dev Only BentoBox can call harvest on this strategy.\\n    @dev Ensures that (1) the caller was this contract (called through the safeHarvest function)\\n        and (2) that we are not being frontrun by a large BentoBox deposit when harvesting profits. */\\n    function harvest(uint256 balance, address sender) external override isActive onlyBentoBox returns (int256) {\\n        /** @dev Don't revert if conditions aren't met in order to allow\\n            BentoBox to continue execution as it might need to do a rebalance. */\\n        if (sender != address(this) || bentoBox.totals(address(strategyToken)).elastic > _maxBentoBoxBalance || balance == 0)\\n            return int256(0);\\n\\n        int256 amount = _harvest(balance);\\n\\n        /** @dev We might have some underlying tokens in the contract that the _harvest call doesn't report. \\n        E.g. reward tokens that have been sold into the underlying tokens which are now sitting in the contract.\\n        Meaning the amount returned by the internal _harvest function isn't necessary the final profit/loss amount */\\n\\n        uint256 contractBalance = strategyToken.balanceOf(address(this)); // Reasonably assume this is less than type(int256).max\\n\\n        if (amount > 0) {\\n            // _harvest reported a profit\\n\\n            uint256 totalFee = (contractBalance * fee) / FEE_PRECISION;\\n            uint256 deltaProfit = contractBalance - totalFee;\\n\\n            strategyToken.safeTransfer(feeTo, totalFee);\\n\\n            emit LogPerformanceFee(strategyToken, totalFee);\\n\\n            strategyToken.safeTransfer(address(bentoBox), deltaProfit);\\n\\n            return int256(deltaProfit);\\n        } else if (contractBalance > 0) {\\n            // _harvest reported a loss but we have some tokens sitting in the contract\\n\\n            int256 diff = amount + int256(contractBalance);\\n\\n            if (diff > 0) {\\n                // We still made some profit.\\n                uint256 totalFee = (uint256(diff) * fee) / FEE_PRECISION;\\n                diff = diff - int256(totalFee);\\n\\n                strategyToken.safeTransfer(feeTo, totalFee);\\n                emit LogPerformanceFee(strategyToken, totalFee);\\n\\n                // Send the profit to BentoBox and reinvest the rest.\\n                strategyToken.safeTransfer(address(bentoBox), uint256(diff));\\n                _skim(contractBalance - uint256(diff) - totalFee);\\n            } else {\\n                // We made a loss but we have some tokens we can reinvest.\\n\\n                _skim(contractBalance);\\n            }\\n\\n            return diff;\\n        } else {\\n            // We made a loss.\\n\\n            return amount;\\n        }\\n    }\\n\\n    /// @inheritdoc IStrategy\\n    /// @dev Do not use isActive modifier here. Allow bentobox to call strategy.exit() multiple times\\n    /// This is to ensure that the strategy isn't locked if its (accidentally) set twice in a row as a token's strategy in bentobox.\\n    function exit(uint256 balance) external override onlyBentoBox returns (int256 amountAdded) {\\n        _exit();\\n        // Flag as exited, allowing the owner to manually deal with any amounts available later.\\n        _exited = true;\\n        // Check balance of token on the contract.\\n        uint256 actualBalance = strategyToken.balanceOf(address(this));\\n        // Calculate tokens added (or lost).\\n        // We reasonably assume actualBalance and balance are less than type(int256).max\\n        amountAdded = int256(actualBalance) - int256(balance);\\n        // Transfer all tokens to bentoBox.\\n        strategyToken.safeTransfer(address(bentoBox), actualBalance);\\n    }\\n\\n    /** @dev After exited, the owner can perform ANY call. This is to rescue any funds that didn't\\n        get released during exit or got earned afterwards due to vesting or airdrops, etc. */\\n    function afterExit(address to, uint256 value, bytes memory data) external onlyOwner returns (bool success) {\\n        if (!_exited) {\\n            revert StrategyNotExited();\\n        }\\n        (success, ) = to.call{value: value}(data);\\n        require(success);\\n    }\\n\\n    function exited() public view returns (bool) {\\n        return _exited;\\n    }\\n\\n    function maxBentoBoxBalance() public view returns (uint256) {\\n        return _maxBentoBoxBalance;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.8.0;\\n\\ninterface IStrategy {\\n    /// @notice Send the assets to the Strategy and call skim to invest them.\\n    /// @param amount The amount of tokens to invest.\\n    function skim(uint256 amount) external;\\n\\n    /// @notice Harvest any profits made converted to the asset and pass them to the caller.\\n    /// @param balance The amount of tokens the caller thinks it has invested.\\n    /// @param sender The address of the initiator of this transaction. Can be used for reimbursements, etc.\\n    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.\\n    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);\\n\\n    /// @notice Withdraw assets. The returned amount can differ from the requested amount due to rounding.\\n    /// @dev The `actualAmount` should be very close to the amount.\\n    /// The difference should NOT be used to report a loss. That's what harvest is for.\\n    /// @param amount The requested amount the caller wants to withdraw.\\n    /// @return actualAmount The real amount that is withdrawn.\\n    function withdraw(uint256 amount) external returns (uint256 actualAmount);\\n\\n    /// @notice Withdraw all assets in the safest way possible. This shouldn't fail.\\n    /// @param balance The amount of tokens the caller thinks it has invested.\\n    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.\\n    function exit(uint256 balance) external returns (int256 amountAdded);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBentoBoxMinimal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\nimport \\\"./IStrategy.sol\\\";\\n\\ninterface IBentoBoxMinimal {\\n    struct Rebase {\\n        uint128 elastic;\\n        uint128 base;\\n    }\\n\\n    struct StrategyData {\\n        uint64 strategyStartDate;\\n        uint64 targetPercentage;\\n        uint128 balance; // the balance of the strategy that BentoBox thinks is in there\\n    }\\n\\n    function balanceOf(address, address) external view returns (uint256);\\n\\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results);\\n\\n    function claimOwnership() external;\\n\\n    function deploy(address masterContract, bytes calldata data, bool useCreate2) external payable;\\n\\n    function deposit(\\n        address token_,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 share\\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\\n\\n    function harvest(address token, bool balance, uint256 maxChangeAmount) external;\\n\\n    function masterContractApproved(address, address) external view returns (bool);\\n\\n    function masterContractOf(address) external view returns (address);\\n\\n    function nonces(address) external view returns (uint256);\\n\\n    function owner() external view returns (address);\\n\\n    function pendingOwner() external view returns (address);\\n\\n    function pendingStrategy(address) external view returns (IStrategy);\\n\\n    function registerProtocol() external;\\n\\n    function setMasterContractApproval(address user, address masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    function setStrategy(address token, address newStrategy) external;\\n\\n    function setStrategyTargetPercentage(address token, uint64 targetPercentage_) external;\\n\\n    function strategy(address) external view returns (IStrategy);\\n\\n    function strategyData(address) external view returns (uint64 strategyStartDate, uint64 targetPercentage, uint128 balance);\\n\\n    function toAmount(address token, uint256 share, bool roundUp) external view returns (uint256 amount);\\n\\n    function toShare(address token, uint256 amount, bool roundUp) external view returns (uint256 share);\\n\\n    function totals(address) external view returns (Rebase memory totals_);\\n\\n    function transfer(address token, address from, address to, uint256 share) external;\\n\\n    function transferMultiple(address token, address from, address[] calldata tos, uint256[] calldata shares) external;\\n\\n    function transferOwnership(address newOwner, bool direct, bool renounce) external;\\n\\n    function whitelistMasterContract(address masterContract, bool approved) external;\\n\\n    function whitelistedMasterContracts(address) external view returns (bool);\\n\\n    function withdraw(\\n        address token_,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 share\\n    ) external returns (uint256 amountOut, uint256 shareOut);\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"/=src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"libraries/=src/libraries/\",\r\n      \"interfaces/=src/interfaces/\",\r\n      \"mixins/=src/mixins/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"forge-deploy/=lib/forge-deploy/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bentoBox\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_strategyToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_strategyExecutor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeTo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_abraMultiSig\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyBentoBox\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyExecutor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StrategyExited\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StrategyNotExited\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFeeTo\",\"type\":\"address\"}],\"name\":\"LogFeeToUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"LogFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogPerformanceFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"LogSetStrategyExecutor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"input\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"output\",\"type\":\"address\"}],\"name\":\"LogSetSwapPath\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEE_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"abraMultiSig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"afterExit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"exit\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"amountAdded\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exited\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"harvest\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lossValue\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBentoBoxBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxBalanceInBentoBox\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"rebalance\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"maxChangeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"harvestRewards\",\"type\":\"bool\"}],\"name\":\"safeHarvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFeeTo\",\"type\":\"address\"}],\"name\":\"setFeeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"_val\",\"type\":\"int256\"}],\"name\":\"setLossValue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setStrategyExecutor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"skim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"strategyExecutors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategyToken\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "MigrationStrategy", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "000000000000000000000000f5bce5077908a1b7370b9ae04adc565ebd643966000000000000000000000000a258c4606ca8206d8aa700ce2143d7db854d168c0000000000000000000000005adb2336602955905190fdb0f3f56c4da195af160000000000000000000000005adb2336602955905190fdb0f3f56c4da195af16000000000000000000000000fb3485c2e209a5cfbdc1447674256578f1a80ee300000000000000000000000000000000000000000000000000000000000000000000000000000000000000005adb2336602955905190fdb0f3f56c4da195af16", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}