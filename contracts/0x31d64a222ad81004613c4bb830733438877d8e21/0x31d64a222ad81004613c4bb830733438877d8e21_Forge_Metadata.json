{"SourceCode": "/**\r\n *Submitted for verification at polygonscan.com on 2023-04-26\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n// File: @openzeppelin/contracts/utils/math/Math.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    enum Rounding {\r\n        Down, // Toward negative infinity\r\n        Up, // Toward infinity\r\n        Zero // Toward zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\r\n     * with further edits by Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod0 := mul(x, y)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            require(denominator > prod1);\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n            // See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 twos = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator,\r\n        Rounding rounding\r\n    ) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10**64) {\r\n                value /= 10**64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10**32) {\r\n                value /= 10**32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10**16) {\r\n                value /= 10**16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10**8) {\r\n                value /= 10**8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10**4) {\r\n                value /= 10**4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10**2) {\r\n                value /= 10**2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10**1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 16;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 8;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 4;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 2;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Strings.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\r\n    uint8 private constant _ADDRESS_LENGTH = 20;\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            uint256 length = Math.log10(value) + 1;\r\n            string memory buffer = new string(length);\r\n            uint256 ptr;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                ptr := add(buffer, add(32, length))\r\n            }\r\n            while (true) {\r\n                ptr--;\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\r\n                }\r\n                value /= 10;\r\n                if (value == 0) break;\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            return toHexString(value, Math.log256(value) + 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(address addr) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Base64.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides a set of functions to operate with Base64 strings.\r\n *\r\n * _Available since v4.5._\r\n */\r\nlibrary Base64 {\r\n    /**\r\n     * @dev Base64 Encoding/Decoding Table\r\n     */\r\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n\r\n    /**\r\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\r\n     */\r\n    function encode(bytes memory data) internal pure returns (string memory) {\r\n        /**\r\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\r\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\r\n         */\r\n        if (data.length == 0) return \"\";\r\n\r\n        // Loads the table into memory\r\n        string memory table = _TABLE;\r\n\r\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\r\n        // and split into 4 numbers of 6 bits.\r\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\r\n        // - `data.length + 2`  -> Round up\r\n        // - `/ 3`              -> Number of 3-bytes chunks\r\n        // - `4 *`              -> 4 characters for each chunk\r\n        string memory result = new string(4 * ((data.length + 2) / 3));\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Prepare the lookup table (skip the first \"length\" byte)\r\n            let tablePtr := add(table, 1)\r\n\r\n            // Prepare result pointer, jump over length\r\n            let resultPtr := add(result, 32)\r\n\r\n            // Run over the input, 3 bytes at a time\r\n            for {\r\n                let dataPtr := data\r\n                let endPtr := add(data, mload(data))\r\n            } lt(dataPtr, endPtr) {\r\n\r\n            } {\r\n                // Advance 3 bytes\r\n                dataPtr := add(dataPtr, 3)\r\n                let input := mload(dataPtr)\r\n\r\n                // To write each character, shift the 3 bytes (18 bits) chunk\r\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\r\n                // and apply logical AND with 0x3F which is the number of\r\n                // the previous character in the ASCII table prior to the Base64 Table\r\n                // The result is then added to the table to get the character to write,\r\n                // and finally write it in the result pointer but with a left shift\r\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\r\n\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1) // Advance\r\n\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1) // Advance\r\n\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1) // Advance\r\n\r\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\r\n                resultPtr := add(resultPtr, 1) // Advance\r\n            }\r\n\r\n            // When data `bytes` is not exactly 3 bytes long\r\n            // it is padded with `=` characters at the end\r\n            switch mod(mload(data), 3)\r\n            case 1 {\r\n                mstore8(sub(resultPtr, 1), 0x3d)\r\n                mstore8(sub(resultPtr, 2), 0x3d)\r\n            }\r\n            case 2 {\r\n                mstore8(sub(resultPtr, 1), 0x3d)\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: Forge Token/Forge_Metadata.sol\r\n\r\n// Contract based on https://docs.openzeppelin.com/contracts/4.x/erc721\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n\r\n\r\ninterface ForgeToken {\r\n    struct TokenAttributes { uint16 xp; bool isSpecialVariant; }\r\n    \r\n    function tokenAttributes(uint _tokenId)\r\n        external\r\n        view\r\n        returns(TokenAttributes memory);\r\n}\r\n\r\n//=============================================================================\r\n/// @title Forge_Metadata\r\n/// @dev Implementation of the tokenURI function.\r\n///  - This implementation was created to support returning metadata as data\r\n///  to remove the requirement of hosting a JSON object on a web2 endpoint,\r\n///  and to make metadata immediately queryable upon mint.\r\n///  - This is implemented as an independent smart contract to enable future\r\n///  modification of returned information.\r\n//=============================================================================\r\ncontract Forge_Metadata is Ownable {\r\n\r\n    // Token Contract for attributes reference\r\n    ForgeToken public forgeTokenContract;\r\n    // base URI for images/mp4\r\n    string public baseURI = \"https://forge.gg/nft/images/\";\r\n    string public defaultURI = \"hot\";\r\n    string public specialVariantURI = \"cold\";\r\n    // extensions for images/mp4\r\n    string public imageExtension = \".png\";\r\n    string public animationExtension = \".mp4\";\r\n    // token names\r\n    string public defaultName = \"Forge Day 0 Badge\";\r\n    string public specialVariantName = \"Forge Day 0 Cold Fire Badge\";\r\n    // token trait name and values\r\n    string public xpTraitName = \"XP\";\r\n    string public mintNumberTraitName = \"Limited Edition Number\";\r\n    string public specialVariantTraitName = \"Heat\";\r\n    string public defaultTraitValue = \"Fire\";\r\n    string public specialVariantTraitValue = \"Cold Fire\";\r\n    // token description\r\n    string public defaultDescription = \"The Forge Day 0 badge is a symbol of your early commitment to the Forge community and unlocks unique perks on the Forge platform.\";\r\n    string public specialVariantDescription = \"The Forge Day 0 badge is a symbol of your early commitment to the Forge community and unlocks unique perks on the Forge platform.\";\r\n    // display types\r\n    string public xpDisplayType = \"boost_number\";\r\n    string public mintNumberDisplayType = \"number\";\r\n\r\n    //-------------------------------------------------------------------------\r\n    //-------------------------------------------------------------------------\r\n    function setContract_ForgeToken(address _forgeTokenAddress)\r\n        external\r\n        onlyOwner\r\n    {\r\n        forgeTokenContract = ForgeToken(_forgeTokenAddress);\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    //-------------------------------------------------------------------------\r\n    function setURI_Base(string calldata _baseURI)\r\n        external\r\n        onlyOwner\r\n    {\r\n        baseURI = _baseURI;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    //-------------------------------------------------------------------------\r\n    function setURI_Default(string calldata _defaultURI)\r\n        external\r\n        onlyOwner\r\n    {\r\n        defaultURI = _defaultURI;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    //-------------------------------------------------------------------------\r\n    function setURI_SpecialVariant(string calldata _specialVariantURI)\r\n        external\r\n        onlyOwner\r\n    {\r\n        specialVariantURI = _specialVariantURI;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    //-------------------------------------------------------------------------\r\n    function setImageExtension(string calldata _extension)\r\n        external\r\n        onlyOwner\r\n    {\r\n        imageExtension = _extension;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    //-------------------------------------------------------------------------\r\n    function setAnimationExtension(string calldata _extension)\r\n        external\r\n        onlyOwner\r\n    {\r\n        animationExtension = _extension;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    //-------------------------------------------------------------------------\r\n    function setName_Default(string calldata _defaultName)\r\n        external\r\n        onlyOwner\r\n    {\r\n        defaultName = _defaultName;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    //-------------------------------------------------------------------------\r\n    function setName_SpecialVariant(string calldata _specialVariantName)\r\n        external\r\n        onlyOwner\r\n    {\r\n        specialVariantName = _specialVariantName;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    //-------------------------------------------------------------------------\r\n    function setTraitName_XP(string calldata _xpTraitName)\r\n        external\r\n        onlyOwner\r\n    {\r\n        xpTraitName = _xpTraitName;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    //-------------------------------------------------------------------------\r\n    function setTraitName_MintNumber(string calldata _mintNumberTraitName)\r\n        external\r\n        onlyOwner\r\n    {\r\n        mintNumberTraitName = _mintNumberTraitName;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    //-------------------------------------------------------------------------\r\n    function setTraitName_SpecialVariant(string calldata _specialVariantTraitName)\r\n        external\r\n        onlyOwner\r\n    {\r\n        specialVariantTraitName = _specialVariantTraitName;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    //-------------------------------------------------------------------------\r\n    function setTraitValue_Default(string calldata _defaultTraitValue)\r\n        external\r\n        onlyOwner\r\n    {\r\n        defaultTraitValue = _defaultTraitValue;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    //-------------------------------------------------------------------------\r\n    function setTraitValue_SpecialVariant(string calldata _specialVariantTraitValue)\r\n        external\r\n        onlyOwner\r\n    {\r\n        specialVariantTraitValue = _specialVariantTraitValue;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    //-------------------------------------------------------------------------\r\n    function setDescription_Default(string calldata _defaultDescription)\r\n        external\r\n        onlyOwner\r\n    {\r\n        defaultDescription = _defaultDescription;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    //-------------------------------------------------------------------------\r\n    function setDescription_SpecialVariant(string calldata _specialVariantDescription)\r\n        external\r\n        onlyOwner\r\n    {\r\n        specialVariantDescription = _specialVariantDescription;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    //-------------------------------------------------------------------------\r\n    function setDisplayType_XP(string calldata _xpDisplayType)\r\n        external\r\n        onlyOwner\r\n    {\r\n        xpDisplayType = _xpDisplayType;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    //-------------------------------------------------------------------------\r\n    function setDisplayType_MintNumber(string calldata _mintNumberDisplayType)\r\n        external\r\n        onlyOwner\r\n    {\r\n        mintNumberDisplayType = _mintNumberDisplayType;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Generates a URL containing metadata as data\r\n    /// @dev This is an extremely costly function. Never call this as part of\r\n    ///  a transaction.\r\n    //-------------------------------------------------------------------------\r\n    function tokenURI(uint _tokenId) public view returns (string memory) {\r\n        ForgeToken.TokenAttributes memory tokenData = forgeTokenContract.tokenAttributes(_tokenId);\r\n\r\n        bytes memory dataURI = generateMetadata(tokenData, _tokenId);\r\n\r\n        return string(\r\n            abi.encodePacked(\r\n                \"data:application/json;base64,\",\r\n                Base64.encode(dataURI)\r\n            )\r\n        );\r\n    }\r\n\r\n    function generateMetadata(ForgeToken.TokenAttributes memory tokenData, uint _tokenId) internal view returns (bytes memory) {\r\n        string memory tokenId = Strings.toString(_tokenId);\r\n        string memory imgUrl = generateImgUrl(tokenData.isSpecialVariant);\r\n        string memory animationURL = generateAnimationUrl(tokenData.isSpecialVariant);\r\n        string memory attributes = generateAttributes(tokenData, tokenId);\r\n\r\n        return abi.encodePacked(\r\n            \"{\\n\",\r\n            \"\\t\\\"name\\\": \\\"\", tokenData.isSpecialVariant ? specialVariantName : defaultName, \" #\", tokenId, \"\\\",\\n\",\r\n            \"\\t\\\"description\\\": \\\"\", tokenData.isSpecialVariant ? specialVariantDescription : defaultDescription, \"\\\",\\n\",\r\n            \"\\t\\\"image\\\": \\\"\", imgUrl, \"\\\",\\n\",\r\n            \"\\t\\\"animation_url\\\": \\\"\", animationURL, \"\\\",\\n\",\r\n            \"\\t\\\"attributes\\\": [\\n\", attributes, \"\\t]\\n\",\r\n            \"}\"\r\n        );\r\n    }\r\n\r\n    function generateImgUrl(bool isSpecialVariant) internal view returns (string memory) {\r\n        return string(abi.encodePacked(baseURI, isSpecialVariant ? specialVariantURI : defaultURI, imageExtension));\r\n    }\r\n\r\n    function generateAnimationUrl(bool isSpecialVariant) internal view returns (string memory) {\r\n        return string(abi.encodePacked(baseURI, isSpecialVariant ? specialVariantURI : defaultURI, animationExtension));\r\n    }\r\n\r\n    function generateAttributes(ForgeToken.TokenAttributes memory tokenData, string memory tokenId) internal view returns (string memory) {\r\n        return string(\r\n            abi.encodePacked(\r\n                generateSpecialVariantAttribute(tokenData),\r\n                generateXpAttribute(tokenData),\r\n                generateMintNumberAttribute(tokenId)\r\n            )\r\n        );\r\n    }\r\n\r\n    function generateSpecialVariantAttribute(ForgeToken.TokenAttributes memory tokenData) internal view returns (string memory) {\r\n        return string(\r\n            abi.encodePacked(\r\n                \"\\t\\t{\\n\",\r\n                \"\\t\\t\\t\\\"trait_type\\\": \\\"\", specialVariantTraitName, \"\\\",\\n\",\r\n                \"\\t\\t\\t\\\"value\\\":\\\"\", tokenData.isSpecialVariant ? specialVariantTraitValue : defaultTraitValue, \"\\\"\\n\",\r\n                \"\\t\\t},\"\r\n            )\r\n        );\r\n    }\r\n\r\n    function generateXpAttribute(ForgeToken.TokenAttributes memory tokenData) internal view returns (string memory) {\r\n        return string(\r\n            abi.encodePacked(\r\n                \"\\t\\t{\\n\",\r\n                \"\\t\\t\\t\\\"display_type\\\": \\\"\", xpDisplayType, \"\\\",\\n\",\r\n                \"\\t\\t\\t\\\"trait_type\\\": \\\"\", xpTraitName, \"\\\",\\n\",\r\n                \"\\t\\t\\t\\\"max_value\\\": 32760,\\n\",\r\n                \"\\t\\t\\t\\\"value\\\":\", Strings.toString(tokenData.xp), \"\\n\",\r\n                \"\\t\\t},\"\r\n            )\r\n        );\r\n    }\r\n\r\n    function generateMintNumberAttribute(string memory tokenId) internal view returns (string memory) {\r\n        return string(\r\n            abi.encodePacked(\r\n                \"\\t\\t{\\n\",\r\n                \"\\t\\t\\t\\\"display_type\\\": \\\"\", mintNumberDisplayType, \"\\\",\\n\",\r\n                \"\\t\\t\\t\\\"trait_type\\\": \\\"\", mintNumberTraitName, \"\\\",\\n\",\r\n                \"\\t\\t\\t\\\"value\\\":\", tokenId, \"\\n\",\r\n                \"\\t\\t}\\n\"\r\n            )\r\n        );\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"animationExtension\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultDescription\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultTraitValue\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forgeTokenContract\",\"outputs\":[{\"internalType\":\"contract ForgeToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"imageExtension\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintNumberDisplayType\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintNumberTraitName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_extension\",\"type\":\"string\"}],\"name\":\"setAnimationExtension\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_forgeTokenAddress\",\"type\":\"address\"}],\"name\":\"setContract_ForgeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_defaultDescription\",\"type\":\"string\"}],\"name\":\"setDescription_Default\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_specialVariantDescription\",\"type\":\"string\"}],\"name\":\"setDescription_SpecialVariant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_mintNumberDisplayType\",\"type\":\"string\"}],\"name\":\"setDisplayType_MintNumber\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_xpDisplayType\",\"type\":\"string\"}],\"name\":\"setDisplayType_XP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_extension\",\"type\":\"string\"}],\"name\":\"setImageExtension\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_defaultName\",\"type\":\"string\"}],\"name\":\"setName_Default\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_specialVariantName\",\"type\":\"string\"}],\"name\":\"setName_SpecialVariant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_mintNumberTraitName\",\"type\":\"string\"}],\"name\":\"setTraitName_MintNumber\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_specialVariantTraitName\",\"type\":\"string\"}],\"name\":\"setTraitName_SpecialVariant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_xpTraitName\",\"type\":\"string\"}],\"name\":\"setTraitName_XP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_defaultTraitValue\",\"type\":\"string\"}],\"name\":\"setTraitValue_Default\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_specialVariantTraitValue\",\"type\":\"string\"}],\"name\":\"setTraitValue_SpecialVariant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"name\":\"setURI_Base\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_defaultURI\",\"type\":\"string\"}],\"name\":\"setURI_Default\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_specialVariantURI\",\"type\":\"string\"}],\"name\":\"setURI_SpecialVariant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"specialVariantDescription\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"specialVariantName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"specialVariantTraitName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"specialVariantTraitValue\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"specialVariantURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xpDisplayType\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xpTraitName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Forge_Metadata", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c39015a83a7f675743bad4df731a040492b0a5ac569ce9e9ed373d76ad346624"}