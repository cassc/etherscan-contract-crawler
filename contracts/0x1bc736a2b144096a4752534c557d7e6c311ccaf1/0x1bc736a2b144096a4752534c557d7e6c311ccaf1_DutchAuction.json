{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/minters/DutchAuction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\nimport {Allowlist} from \\\"src/minters/extensions/Allowlist.sol\\\";\\nimport {LibBitmap} from \\\"solady/src/utils/LibBitmap.sol\\\";\\nimport {LibMap} from \\\"solady/src/utils/LibMap.sol\\\";\\nimport {MintPass} from \\\"src/minters/extensions/MintPass.sol\\\";\\nimport {Ownable} from \\\"solady/src/auth/Ownable.sol\\\";\\nimport {Pausable} from \\\"openzeppelin/contracts/security/Pausable.sol\\\";\\nimport {SafeCastLib} from \\\"solmate/src/utils/SafeCastLib.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/src/utils/SafeTransferLib.sol\\\";\\n\\nimport {IDutchAuction, AuctionInfo, MinterInfo, RefundInfo} from \\\"src/interfaces/IDutchAuction.sol\\\";\\nimport {IFxGenArt721, ReserveInfo} from \\\"src/interfaces/IFxGenArt721.sol\\\";\\nimport {IToken} from \\\"src/interfaces/IToken.sol\\\";\\n\\n/**\\n * @title DutchAuction\\n * @author fx(hash)\\n * @dev See the documentation in {IDutchAuction}\\n */\\ncontract DutchAuction is IDutchAuction, Allowlist, MintPass, Ownable, Pausable {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                    STORAGE\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @dev Mapping of token address to reserve ID to Bitmap of claimed merkle tree slots\\n     */\\n    mapping(address => mapping(uint256 => LibBitmap.Bitmap)) internal claimedMerkleTreeSlots;\\n\\n    /**\\n     * @dev Mapping of token address to reserve ID to Bitmap of claimed mint passes\\n     */\\n    mapping(address => mapping(uint256 => LibBitmap.Bitmap)) internal claimedMintPasses;\\n\\n    /**\\n     * @dev Mapping of token address to timestamp of latest update made for token reserves\\n     */\\n    LibMap.Uint40Map internal latestUpdates;\\n\\n    /**\\n     * @dev Mapping of token to the last valid reserveId that can mint on behalf of the token\\n     */\\n    LibMap.Uint40Map internal firstValidReserve;\\n\\n    /**\\n     * @inheritdoc IDutchAuction\\n     */\\n    mapping(address => AuctionInfo[]) public auctions;\\n\\n    /**\\n     * @inheritdoc IDutchAuction\\n     */\\n    mapping(address => mapping(uint256 => bytes32)) public merkleRoots;\\n\\n    /**\\n     * @inheritdoc IDutchAuction\\n     */\\n    mapping(address => mapping(uint256 => RefundInfo)) public refunds;\\n\\n    /**\\n     * @inheritdoc IDutchAuction\\n     */\\n    mapping(address => ReserveInfo[]) public reserves;\\n\\n    /**\\n     * @inheritdoc IDutchAuction\\n     */\\n    mapping(address => mapping(uint256 => uint256)) public saleProceeds;\\n\\n    /**\\n     * @inheritdoc IDutchAuction\\n     */\\n    mapping(address => mapping(uint256 => uint256)) public numberMinted;\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                EXTERNAL FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @inheritdoc IDutchAuction\\n     */\\n    function buy(address _token, uint256 _reserveId, uint256 _amount, address _to) external payable whenNotPaused {\\n        bytes32 merkleRoot = _getMerkleRoot(_token, _reserveId);\\n        address signer = signingAuthorities[_token][_reserveId];\\n        if (merkleRoot != bytes32(0)) revert NoPublicMint();\\n        if (signer != address(0)) revert AddressZero();\\n        _buy(_token, _reserveId, _amount, _to);\\n    }\\n\\n    /**\\n     * @inheritdoc IDutchAuction\\n     */\\n    function buyAllowlist(\\n        address _token,\\n        uint256 _reserveId,\\n        address _to,\\n        uint256[] calldata _indexes,\\n        bytes32[][] calldata _proofs\\n    ) external payable whenNotPaused {\\n        bytes32 merkleRoot = _getMerkleRoot(_token, _reserveId);\\n        if (merkleRoot == bytes32(0)) revert NoAllowlist();\\n        LibBitmap.Bitmap storage claimBitmap = claimedMerkleTreeSlots[_token][_reserveId];\\n        uint256 amount = _proofs.length;\\n        for (uint256 i; i < amount; ++i) {\\n            _claimSlot(_token, _reserveId, _indexes[i], _to, _proofs[i], claimBitmap);\\n        }\\n\\n        _buy(_token, _reserveId, amount, _to);\\n    }\\n\\n    /**\\n     * @inheritdoc IDutchAuction\\n     */\\n    function buyMintPass(\\n        address _token,\\n        uint256 _reserveId,\\n        uint256 _amount,\\n        address _to,\\n        uint256 _index,\\n        bytes calldata _signature\\n    ) external payable whenNotPaused {\\n        address signer = signingAuthorities[_token][_reserveId];\\n        if (signer == address(0)) revert NoSigningAuthority();\\n        LibBitmap.Bitmap storage claimBitmap = claimedMintPasses[_token][_reserveId];\\n        _claimMintPass(_token, _reserveId, _index, _to, _signature, claimBitmap);\\n        _buy(_token, _reserveId, _amount, _to);\\n    }\\n\\n    /**\\n     * @inheritdoc IDutchAuction\\n     */\\n    function refund(address _token, uint256 _reserveId, address _buyer) external whenNotPaused {\\n        // Validates token address, reserve information and given account\\n        _validateInput(_token, _reserveId, _buyer);\\n\\n        ReserveInfo storage reserve = reserves[_token][_reserveId];\\n        uint256 lastPrice = refunds[_token][_reserveId].lastPrice;\\n\\n        bool refundAuction = auctions[_token][_reserveId].refunded;\\n        // Checks if refunds are enabled and there is a last price\\n        if (!refundAuction) revert NonRefundableDA();\\n\\n        // Checks if the auction has ended and if the reserve allocation is fully sold out\\n        if (block.timestamp < reserve.endTime && reserve.allocation > 0) revert NotEnded();\\n        // checks if the rebate auction ended, but didn't sellout.  Refunds lowest price\\n        if (lastPrice == 0) {\\n            lastPrice = _recordLastPrice(reserve, _token, _reserveId);\\n        }\\n        // Get the user's refund information\\n        MinterInfo memory minterInfo = refunds[_token][_reserveId].minterInfo[_buyer];\\n        uint128 refundAmount = SafeCastLib.safeCastTo128(minterInfo.totalPaid - minterInfo.totalMints * lastPrice);\\n\\n        // Deletes the minter's refund information\\n        if (refundAmount == 0) revert NoRefund();\\n        delete refunds[_token][_reserveId].minterInfo[_buyer];\\n\\n        emit RefundClaimed(_token, _reserveId, _buyer, refundAmount);\\n\\n        // Sends refund to the user\\n        SafeTransferLib.safeTransferETH(_buyer, refundAmount);\\n    }\\n\\n    /**\\n     * @inheritdoc IDutchAuction\\n     */\\n    function setMintDetails(ReserveInfo calldata _reserve, bytes calldata _mintDetails) external whenNotPaused {\\n        uint256 nextReserve = reserves[msg.sender].length;\\n        if (_reserve.allocation == 0) revert InvalidAllocation();\\n        (AuctionInfo memory daInfo, bytes32 merkleRoot, address signer) = abi.decode(\\n            _mintDetails,\\n            (AuctionInfo, bytes32, address)\\n        );\\n        if (getLatestUpdate(msg.sender) != block.timestamp) {\\n            _setLatestUpdate(msg.sender, block.timestamp);\\n            _setFirstValidReserve(msg.sender, nextReserve);\\n        }\\n\\n        // Checks if the step length is evenly divisible by the auction duration\\n        if (_reserve.endTime - _reserve.startTime != daInfo.prices.length * daInfo.stepLength) revert InvalidStep();\\n\\n        if (merkleRoot != bytes32(0)) {\\n            if (signer != address(0)) revert OnlyAuthorityOrAllowlist();\\n            merkleRoots[msg.sender][nextReserve] = merkleRoot;\\n        } else if (signer != address(0)) {\\n            signingAuthorities[msg.sender][nextReserve] = signer;\\n            reserveNonce[msg.sender][nextReserve]++;\\n        }\\n\\n        // Checks if the price curve is descending\\n        uint256 pricesLength = daInfo.prices.length;\\n        if (pricesLength < 2) revert InvalidPriceCurve();\\n        for (uint256 i = 1; i < pricesLength; ++i) {\\n            if (!(daInfo.prices[i - 1] > daInfo.prices[i])) revert PricesOutOfOrder();\\n        }\\n\\n        // Adds the reserve and auction info to the mappings\\n        reserves[msg.sender].push(_reserve);\\n        auctions[msg.sender].push(daInfo);\\n\\n        emit MintDetailsSet(msg.sender, nextReserve, _reserve, merkleRoot, signer, daInfo);\\n    }\\n\\n    /**\\n     * @inheritdoc IDutchAuction\\n     */\\n    function withdraw(address _token, uint256 _reserveId) external whenNotPaused {\\n        // Validates token address, reserve information and given account\\n        uint256 length = reserves[_token].length;\\n        if (length == 0) revert InvalidToken();\\n        if (_token == address(0)) revert AddressZero();\\n        if (_reserveId >= length) revert InvalidReserve();\\n\\n        ReserveInfo storage reserve = reserves[_token][_reserveId];\\n\\n        // Checks if the auction has ended and the reserve allocation is fully sold out\\n        if (block.timestamp < reserve.endTime && reserve.allocation > 0) revert NotEnded();\\n        address saleReceiver = IToken(_token).primaryReceiver();\\n        uint256 lastPrice = refunds[_token][_reserveId].lastPrice;\\n        bool refundAuction = auctions[_token][_reserveId].refunded;\\n        if (lastPrice == 0 && refundAuction) {\\n            lastPrice = _recordLastPrice(reserve, _token, _reserveId);\\n        }\\n        refunds[_token][_reserveId].lastPrice = lastPrice;\\n\\n        // Gets the sale proceeds for the reserve\\n        uint256 proceeds;\\n        if (refundAuction) {\\n            proceeds = lastPrice * numberMinted[_token][_reserveId];\\n        } else {\\n            proceeds = saleProceeds[_token][_reserveId];\\n        }\\n        if (proceeds == 0) revert InsufficientFunds();\\n\\n        // Clears the sale proceeds for the reserve\\n        delete numberMinted[_token][_reserveId];\\n        delete saleProceeds[_token][_reserveId];\\n\\n        emit Withdrawn(_token, _reserveId, saleReceiver, proceeds);\\n\\n        // Transfers the sale proceeds to the sale receiver\\n        SafeTransferLib.safeTransferETH(saleReceiver, proceeds);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                OWNER FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @inheritdoc IDutchAuction\\n     */\\n    function pause() external onlyOwner {\\n        _pause();\\n    }\\n\\n    /**\\n     * @inheritdoc IDutchAuction\\n     */\\n    function unpause() external onlyOwner {\\n        _unpause();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                READ FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @inheritdoc IDutchAuction\\n     */\\n    function getFirstValidReserve(address _token) public view returns (uint256) {\\n        return LibMap.get(firstValidReserve, uint256(uint160(_token)));\\n    }\\n\\n    /**\\n     * @inheritdoc IDutchAuction\\n     */\\n    function getLatestUpdate(address _token) public view returns (uint40) {\\n        return LibMap.get(latestUpdates, uint256(uint160(_token)));\\n    }\\n\\n    /**\\n     * @inheritdoc IDutchAuction\\n     */\\n    function getPrice(address _token, uint256 _reserveId) public view returns (uint256) {\\n        ReserveInfo memory reserve = reserves[_token][_reserveId];\\n        AuctionInfo storage daInfo = auctions[_token][_reserveId];\\n        return _getPrice(reserve, daInfo);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                INTERNAL FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @dev Purchases arbitrary amount of tokens at auction price and mints tokens to given account\\n     */\\n    function _buy(address _token, uint256 _reserveId, uint256 _amount, address _to) internal {\\n        // Validates token address, reserve information and given account\\n        _validateInput(_token, _reserveId, _to);\\n        if (_amount == 0) revert InvalidAmount();\\n\\n        ReserveInfo storage reserve = reserves[_token][_reserveId];\\n\\n        // Checks if the auction has started and not ended\\n        if (block.timestamp < reserve.startTime) revert NotStarted();\\n\\n        // Checks if the requested amount is within the available allocation for the reserve\\n        if (_amount > reserve.allocation) revert InvalidAmount();\\n\\n        AuctionInfo storage daInfo = auctions[_token][_reserveId];\\n        uint256 price = _getPrice(reserve, daInfo);\\n        if (msg.value != price * _amount) revert InvalidPayment();\\n\\n        // Updates the allocation for the reserve\\n        uint128 amount = SafeCastLib.safeCastTo128(_amount);\\n        reserve.allocation -= amount;\\n\\n        // If the reserve allocation is fully sold out and refunds are enabled, store the last price\\n        if (reserve.allocation == 0 && daInfo.refunded) {\\n            refunds[_token][_reserveId].lastPrice = price;\\n        }\\n\\n        // Updates the minter's total mints and total paid amounts\\n        uint128 totalPayment = SafeCastLib.safeCastTo128(price * _amount);\\n        MinterInfo storage minterInfo = refunds[_token][_reserveId].minterInfo[_to];\\n        minterInfo.totalMints += amount;\\n        minterInfo.totalPaid += totalPayment;\\n\\n        // Adds the sale proceeds to the total for the reserve\\n        saleProceeds[_token][_reserveId] += totalPayment;\\n        numberMinted[_token][_reserveId] += _amount;\\n        emit Purchase(_token, _reserveId, msg.sender, _to, _amount, price);\\n\\n        IToken(_token).mint(_to, _amount, totalPayment);\\n    }\\n\\n    /**\\n     * @dev Sets timestamp of the latest update to token reserves\\n     */\\n    function _setLatestUpdate(address _token, uint256 _timestamp) internal {\\n        LibMap.set(latestUpdates, uint256(uint160(_token)), uint40(_timestamp));\\n    }\\n\\n    /*\\n     * @dev Sets earliest valid reserve\\n     */\\n    function _setFirstValidReserve(address _token, uint256 _reserveId) internal {\\n        LibMap.set(firstValidReserve, uint256(uint160(_token)), uint40(_reserveId));\\n    }\\n\\n    /**\\n     * @dev Gets the merkle root of a token reserve\\n     */\\n    function _getMerkleRoot(address _token, uint256 _reserveId) internal view override returns (bytes32) {\\n        return merkleRoots[_token][_reserveId];\\n    }\\n\\n    /**\\n     * @dev Gets the current price of auction reserve\\n     */\\n    function _getPrice(ReserveInfo memory _reserve, AuctionInfo storage _daInfo) internal view returns (uint256) {\\n        if (block.timestamp < _reserve.startTime) revert NotStarted();\\n        uint256 timeSinceStart = block.timestamp - _reserve.startTime;\\n\\n        // Calculates the step based on the time since the start of the auction and the step length\\n        uint256 step = timeSinceStart / _daInfo.stepLength;\\n\\n        // Checks if the step is within the range of prices\\n        uint256 length = _daInfo.prices.length;\\n        if (step >= length) return _daInfo.prices[length - 1];\\n        return _daInfo.prices[step];\\n    }\\n\\n    function _recordLastPrice(\\n        ReserveInfo memory _reserve,\\n        address _token,\\n        uint256 _reserveId\\n    ) internal returns (uint256 lastPrice) {\\n        if (block.timestamp > _reserve.endTime && _reserve.allocation > 0) {\\n            uint256 length = auctions[_token][_reserveId].prices.length;\\n            lastPrice = auctions[_token][_reserveId].prices[length - 1];\\n            refunds[_token][_reserveId].lastPrice = lastPrice;\\n        }\\n    }\\n\\n    /**\\n     * @dev Validates token address, reserve information and given account\\n     */\\n    function _validateInput(address _token, uint256 _reserveId, address _buyer) internal view {\\n        uint256 validReserve = getFirstValidReserve(_token);\\n        uint256 length = reserves[_token].length;\\n        if (length == 0) revert InvalidToken();\\n        if (_reserveId >= length || _reserveId < validReserve) revert InvalidReserve();\\n        if (_buyer == address(0)) revert AddressZero();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/minters/extensions/Allowlist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\nimport {LibBitmap} from \\\"solady/src/utils/LibBitmap.sol\\\";\\nimport {MerkleProof} from \\\"openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\n\\n/**\\n * @title Allowlist\\n * @author fx(hash)\\n * @notice Extension for claiming tokens through merkle trees\\n */\\nabstract contract Allowlist {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                    EVENTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Event emitted when allowlist slot is claimed\\n     * @param _token Address of the token\\n     * @param _reserveId ID of the reserve\\n     * @param _claimer Address of the claimer\\n     * @param _index Index of purchase info inside the BitMap\\n     */\\n    event SlotClaimed(address indexed _token, uint256 indexed _reserveId, address indexed _claimer, uint256 _index);\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                    ERRORS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Error thrown when the merkle proof for an index is invalid\\n     */\\n    error InvalidProof();\\n\\n    /**\\n     * @notice Error thrown when an index in the merkle tree has already been claimed\\n     */\\n    error SlotAlreadyClaimed();\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                INTERNAL FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @dev Claims a merkle tree slot\\n     * @param _token Address of the token contract\\n     * @param _reserveId ID of the reserve\\n     * @param _index Index in the merkle tree\\n     * @param _claimer Address of allowlist slot claimer\\n     * @param _proof Merkle proof used for validating claim\\n     * @param _bitmap Bitmap used for checking if index is already claimed\\n     */\\n    function _claimSlot(\\n        address _token,\\n        uint256 _reserveId,\\n        uint256 _index,\\n        address _claimer,\\n        bytes32[] memory _proof,\\n        LibBitmap.Bitmap storage _bitmap\\n    ) internal {\\n        if (LibBitmap.get(_bitmap, _index)) revert SlotAlreadyClaimed();\\n        bytes32 root = _getMerkleRoot(_token, _reserveId);\\n        bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(_index, _claimer))));\\n        if (!MerkleProof.verify(_proof, root, leaf)) revert InvalidProof();\\n        LibBitmap.set(_bitmap, _index);\\n\\n        emit SlotClaimed(_token, _reserveId, _claimer, _index);\\n    }\\n\\n    /**\\n     * @dev Gets the merkle root of a token reserve\\n     * @param _token Address of the token contract\\n     * @param _reserveId ID of the reserve\\n     */\\n    function _getMerkleRoot(address _token, uint256 _reserveId) internal view virtual returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/LibBitmap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {LibBit} from \\\"./LibBit.sol\\\";\\n\\n/// @notice Library for storage of packed unsigned booleans.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBitmap.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibBitmap.sol)\\n/// @author Modified from Solidity-Bits (https://github.com/estarriolvetch/solidity-bits/blob/main/contracts/BitMaps.sol)\\nlibrary LibBitmap {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The constant returned when a bitmap scan does not find a result.\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev A bitmap in storage.\\n    struct Bitmap {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         OPERATIONS                         */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the boolean value of the bit at `index` in `bitmap`.\\n    function get(Bitmap storage bitmap, uint256 index) internal view returns (bool isSet) {\\n        // It is better to set `isSet` to either 0 or 1, than zero vs non-zero.\\n        // Both cost the same amount of gas, but the former allows the returned value\\n        // to be reused without cleaning the upper bits.\\n        uint256 b = (bitmap.map[index >> 8] >> (index & 0xff)) & 1;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            isSet := b\\n        }\\n    }\\n\\n    /// @dev Updates the bit at `index` in `bitmap` to true.\\n    function set(Bitmap storage bitmap, uint256 index) internal {\\n        bitmap.map[index >> 8] |= (1 << (index & 0xff));\\n    }\\n\\n    /// @dev Updates the bit at `index` in `bitmap` to false.\\n    function unset(Bitmap storage bitmap, uint256 index) internal {\\n        bitmap.map[index >> 8] &= ~(1 << (index & 0xff));\\n    }\\n\\n    /// @dev Flips the bit at `index` in `bitmap`.\\n    /// Returns the boolean result of the flipped bit.\\n    function toggle(Bitmap storage bitmap, uint256 index) internal returns (bool newIsSet) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, shr(8, index))\\n            mstore(0x20, bitmap.slot)\\n            let storageSlot := keccak256(0x00, 0x40)\\n            let shift := and(index, 0xff)\\n            let storageValue := sload(storageSlot)\\n\\n            let mask := shl(shift, 1)\\n            storageValue := xor(storageValue, mask)\\n            // It makes sense to return the `newIsSet`,\\n            // as it allow us to skip an additional warm `sload`,\\n            // and it costs minimal gas (about 15),\\n            // which may be optimized away if the returned value is unused.\\n            newIsSet := iszero(iszero(and(storageValue, mask)))\\n            sstore(storageSlot, storageValue)\\n        }\\n    }\\n\\n    /// @dev Updates the bit at `index` in `bitmap` to `shouldSet`.\\n    function setTo(Bitmap storage bitmap, uint256 index, bool shouldSet) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, bitmap.slot)\\n            mstore(0x00, shr(8, index))\\n            let storageSlot := keccak256(0x00, 0x40)\\n            let storageValue := sload(storageSlot)\\n            let shift := and(index, 0xff)\\n\\n            sstore(\\n                storageSlot,\\n                // Unsets the bit at `shift` via `and`, then sets its new value via `or`.\\n                or(and(storageValue, not(shl(shift, 1))), shl(shift, iszero(iszero(shouldSet))))\\n            )\\n        }\\n    }\\n\\n    /// @dev Consecutively sets `amount` of bits starting from the bit at `start`.\\n    function setBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let max := not(0)\\n            let shift := and(start, 0xff)\\n            mstore(0x20, bitmap.slot)\\n            mstore(0x00, shr(8, start))\\n            if iszero(lt(add(shift, amount), 257)) {\\n                let storageSlot := keccak256(0x00, 0x40)\\n                sstore(storageSlot, or(sload(storageSlot), shl(shift, max)))\\n                let bucket := add(mload(0x00), 1)\\n                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))\\n                amount := and(add(amount, shift), 0xff)\\n                shift := 0\\n                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {\\n                    mstore(0x00, bucket)\\n                    sstore(keccak256(0x00, 0x40), max)\\n                }\\n                mstore(0x00, bucket)\\n            }\\n            let storageSlot := keccak256(0x00, 0x40)\\n            sstore(storageSlot, or(sload(storageSlot), shl(shift, shr(sub(256, amount), max))))\\n        }\\n    }\\n\\n    /// @dev Consecutively unsets `amount` of bits starting from the bit at `start`.\\n    function unsetBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let shift := and(start, 0xff)\\n            mstore(0x20, bitmap.slot)\\n            mstore(0x00, shr(8, start))\\n            if iszero(lt(add(shift, amount), 257)) {\\n                let storageSlot := keccak256(0x00, 0x40)\\n                sstore(storageSlot, and(sload(storageSlot), not(shl(shift, not(0)))))\\n                let bucket := add(mload(0x00), 1)\\n                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))\\n                amount := and(add(amount, shift), 0xff)\\n                shift := 0\\n                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {\\n                    mstore(0x00, bucket)\\n                    sstore(keccak256(0x00, 0x40), 0)\\n                }\\n                mstore(0x00, bucket)\\n            }\\n            let storageSlot := keccak256(0x00, 0x40)\\n            sstore(\\n                storageSlot, and(sload(storageSlot), not(shl(shift, shr(sub(256, amount), not(0)))))\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns number of set bits within a range by\\n    /// scanning `amount` of bits starting from the bit at `start`.\\n    function popCount(Bitmap storage bitmap, uint256 start, uint256 amount)\\n        internal\\n        view\\n        returns (uint256 count)\\n    {\\n        unchecked {\\n            uint256 bucket = start >> 8;\\n            uint256 shift = start & 0xff;\\n            if (!(amount + shift < 257)) {\\n                count = LibBit.popCount(bitmap.map[bucket] >> shift);\\n                uint256 bucketEnd = bucket + ((amount + shift) >> 8);\\n                amount = (amount + shift) & 0xff;\\n                shift = 0;\\n                for (++bucket; bucket != bucketEnd; ++bucket) {\\n                    count += LibBit.popCount(bitmap.map[bucket]);\\n                }\\n            }\\n            count += LibBit.popCount((bitmap.map[bucket] >> shift) << (256 - amount));\\n        }\\n    }\\n\\n    /// @dev Returns the index of the most significant set bit before the bit at `before`.\\n    /// If no set bit is found, returns `NOT_FOUND`.\\n    function findLastSet(Bitmap storage bitmap, uint256 before)\\n        internal\\n        view\\n        returns (uint256 setBitIndex)\\n    {\\n        uint256 bucket;\\n        uint256 bucketBits;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            setBitIndex := not(0)\\n            bucket := shr(8, before)\\n            mstore(0x00, bucket)\\n            mstore(0x20, bitmap.slot)\\n            let offset := and(0xff, not(before)) // `256 - (255 & before) - 1`.\\n            bucketBits := shr(offset, shl(offset, sload(keccak256(0x00, 0x40))))\\n            if iszero(bucketBits) {\\n                for {} bucket {} {\\n                    bucket := add(bucket, setBitIndex) // `sub(bucket, 1)`.\\n                    mstore(0x00, bucket)\\n                    bucketBits := sload(keccak256(0x00, 0x40))\\n                    if bucketBits { break }\\n                }\\n            }\\n        }\\n        if (bucketBits != 0) {\\n            setBitIndex = (bucket << 8) | LibBit.fls(bucketBits);\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                setBitIndex := or(setBitIndex, sub(0, gt(setBitIndex, before)))\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/LibMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for storage of packed unsigned integers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibMap.sol)\\nlibrary LibMap {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev A uint8 map in storage.\\n    struct Uint8Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /// @dev A uint16 map in storage.\\n    struct Uint16Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /// @dev A uint32 map in storage.\\n    struct Uint32Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /// @dev A uint40 map in storage. Useful for storing timestamps up to 34841 A.D.\\n    struct Uint40Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /// @dev A uint64 map in storage.\\n    struct Uint64Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /// @dev A uint128 map in storage.\\n    struct Uint128Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     GETTERS / SETTERS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the uint8 value at `index` in `map`.\\n    function get(Uint8Map storage map, uint256 index) internal view returns (uint8 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(5, index))\\n            result := byte(and(31, not(index)), sload(keccak256(0x00, 0x40)))\\n        }\\n    }\\n\\n    /// @dev Updates the uint8 value at `index` in `map`.\\n    function set(Uint8Map storage map, uint256 index, uint8 value) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(5, index))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            mstore(0x00, sload(s))\\n            mstore8(and(31, not(index)), value)\\n            sstore(s, mload(0x00))\\n        }\\n    }\\n\\n    /// @dev Returns the uint16 value at `index` in `map`.\\n    function get(Uint16Map storage map, uint256 index) internal view returns (uint16 result) {\\n        result = uint16(map.map[index >> 4] >> ((index & 15) << 4));\\n    }\\n\\n    /// @dev Updates the uint16 value at `index` in `map`.\\n    function set(Uint16Map storage map, uint256 index, uint16 value) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(4, index))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := shl(4, and(index, 15)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n\\n    /// @dev Returns the uint32 value at `index` in `map`.\\n    function get(Uint32Map storage map, uint256 index) internal view returns (uint32 result) {\\n        result = uint32(map.map[index >> 3] >> ((index & 7) << 5));\\n    }\\n\\n    /// @dev Updates the uint32 value at `index` in `map`.\\n    function set(Uint32Map storage map, uint256 index, uint32 value) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(3, index))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := shl(5, and(index, 7)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n\\n    /// @dev Returns the uint40 value at `index` in `map`.\\n    function get(Uint40Map storage map, uint256 index) internal view returns (uint40 result) {\\n        unchecked {\\n            result = uint40(map.map[index / 6] >> ((index % 6) * 40));\\n        }\\n    }\\n\\n    /// @dev Updates the uint40 value at `index` in `map`.\\n    function set(Uint40Map storage map, uint256 index, uint40 value) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, div(index, 6))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := mul(40, mod(index, 6)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n\\n    /// @dev Returns the uint64 value at `index` in `map`.\\n    function get(Uint64Map storage map, uint256 index) internal view returns (uint64 result) {\\n        result = uint64(map.map[index >> 2] >> ((index & 3) << 6));\\n    }\\n\\n    /// @dev Updates the uint64 value at `index` in `map`.\\n    function set(Uint64Map storage map, uint256 index, uint64 value) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(2, index))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := shl(6, and(index, 3)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffffffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n\\n    /// @dev Returns the uint128 value at `index` in `map`.\\n    function get(Uint128Map storage map, uint256 index) internal view returns (uint128 result) {\\n        result = uint128(map.map[index >> 1] >> ((index & 1) << 7));\\n    }\\n\\n    /// @dev Updates the uint128 value at `index` in `map`.\\n    function set(Uint128Map storage map, uint256 index, uint128 value) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(1, index))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := shl(7, and(index, 1)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffffffffffffffffffffffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n\\n    /// @dev Returns the value at `index` in `map`.\\n    function get(mapping(uint256 => uint256) storage map, uint256 index, uint256 bitWidth)\\n        internal\\n        view\\n        returns (uint256 result)\\n    {\\n        unchecked {\\n            uint256 d = _rawDiv(256, bitWidth); // Bucket size.\\n            uint256 m = (1 << bitWidth) - 1; // Value mask.\\n            result = (map[_rawDiv(index, d)] >> (_rawMod(index, d) * bitWidth)) & m;\\n        }\\n    }\\n\\n    /// @dev Updates the value at `index` in `map`.\\n    function set(\\n        mapping(uint256 => uint256) storage map,\\n        uint256 index,\\n        uint256 value,\\n        uint256 bitWidth\\n    ) internal {\\n        unchecked {\\n            uint256 d = _rawDiv(256, bitWidth); // Bucket size.\\n            uint256 m = (1 << bitWidth) - 1; // Value mask.\\n            uint256 o = _rawMod(index, d) * bitWidth; // Storage slot offset (bits).\\n            map[_rawDiv(index, d)] ^= (((map[_rawDiv(index, d)] >> o) ^ value) & m) << o;\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       BINARY SEARCH                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // The following functions search in the range of [`start`, `end`)\\n    // (i.e. `start <= index < end`).\\n    // The range must be sorted in ascending order.\\n    // `index` precedence: equal to > nearest before > nearest after.\\n    // An invalid search range will simply return `(found = false, index = start)`.\\n\\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\\n    function searchSorted(Uint8Map storage map, uint8 needle, uint256 start, uint256 end)\\n        internal\\n        view\\n        returns (bool found, uint256 index)\\n    {\\n        return searchSorted(map.map, needle, start, end, 8);\\n    }\\n\\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\\n    function searchSorted(Uint16Map storage map, uint16 needle, uint256 start, uint256 end)\\n        internal\\n        view\\n        returns (bool found, uint256 index)\\n    {\\n        return searchSorted(map.map, needle, start, end, 16);\\n    }\\n\\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\\n    function searchSorted(Uint32Map storage map, uint32 needle, uint256 start, uint256 end)\\n        internal\\n        view\\n        returns (bool found, uint256 index)\\n    {\\n        return searchSorted(map.map, needle, start, end, 32);\\n    }\\n\\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\\n    function searchSorted(Uint40Map storage map, uint40 needle, uint256 start, uint256 end)\\n        internal\\n        view\\n        returns (bool found, uint256 index)\\n    {\\n        return searchSorted(map.map, needle, start, end, 40);\\n    }\\n\\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\\n    function searchSorted(Uint64Map storage map, uint64 needle, uint256 start, uint256 end)\\n        internal\\n        view\\n        returns (bool found, uint256 index)\\n    {\\n        return searchSorted(map.map, needle, start, end, 64);\\n    }\\n\\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\\n    function searchSorted(Uint128Map storage map, uint128 needle, uint256 start, uint256 end)\\n        internal\\n        view\\n        returns (bool found, uint256 index)\\n    {\\n        return searchSorted(map.map, needle, start, end, 128);\\n    }\\n\\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\\n    function searchSorted(\\n        mapping(uint256 => uint256) storage map,\\n        uint256 needle,\\n        uint256 start,\\n        uint256 end,\\n        uint256 bitWidth\\n    ) internal view returns (bool found, uint256 index) {\\n        unchecked {\\n            if (start >= end) end = start;\\n            uint256 t;\\n            uint256 o = start - 1; // Offset to derive the actual index.\\n            uint256 l = 1; // Low.\\n            uint256 d = _rawDiv(256, bitWidth); // Bucket size.\\n            uint256 m = (1 << bitWidth) - 1; // Value mask.\\n            uint256 h = end - start; // High.\\n            while (true) {\\n                index = (l & h) + ((l ^ h) >> 1);\\n                if (l > h) break;\\n                t = (map[_rawDiv(index + o, d)] >> (_rawMod(index + o, d) * bitWidth)) & m;\\n                if (t == needle) break;\\n                if (needle <= t) h = index - 1;\\n                else l = index + 1;\\n            }\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                m := or(iszero(index), iszero(bitWidth))\\n                found := iszero(or(xor(t, needle), m))\\n                index := add(o, xor(index, mul(xor(index, 1), m)))\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\\n    function _rawDiv(uint256 x, uint256 y) private pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := div(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\\n    function _rawMod(uint256 x, uint256 y) private pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mod(x, y)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/minters/extensions/MintPass.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\nimport {EIP712} from \\\"openzeppelin/contracts/utils/cryptography/EIP712.sol\\\";\\nimport {LibBitmap} from \\\"solady/src/utils/LibBitmap.sol\\\";\\nimport {SignatureChecker} from \\\"openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\\\";\\n\\nimport {CLAIM_TYPEHASH} from \\\"src/utils/Constants.sol\\\";\\n\\n/**\\n * @title MintPass\\n * @author fx(hash)\\n * @notice Extension for claiming tokens through mint passes\\n */\\nabstract contract MintPass is EIP712 {\\n    using SignatureChecker for address;\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                    STORAGE\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Mapping of token address to reserve ID to reserve nonce\\n     */\\n    mapping(address => mapping(uint256 => uint256)) public reserveNonce;\\n\\n    /**\\n     * @notice Mapping of token address to reserve ID to address of mint pass authority\\n     */\\n    mapping(address => mapping(uint256 => address)) public signingAuthorities;\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                    EVENTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Event emitted when mint pass is claimed\\n     * @param _token Address of the token\\n     * @param _reserveId ID of the reserve\\n     * @param _claimer Address of the mint pass claimer\\n     * @param _index Index of purchase info inside the BitMap\\n     */\\n    event PassClaimed(address indexed _token, uint256 indexed _reserveId, address indexed _claimer, uint256 _index);\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                    ERRORS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Error thrown when the signature of mint pass claimer is invalid\\n     */\\n    error InvalidSignature();\\n\\n    /**\\n     * @notice Error thrown when a mint pass has already been claimed\\n     */\\n    error PassAlreadyClaimed();\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @dev Initializes EIP-712\\n     */\\n    constructor() EIP712(\\\"MINT_PASS\\\", \\\"1\\\") {}\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                PUBLIC FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Generates the typed data hash for a mint pass claim\\n     * @param _token address of token for the reserve\\n     * @param _reserveId Id of the reserve to mint the token from\\n     * @param _index Index of the mint pass\\n     * @param _claimer Address of mint pass claimer\\n     * @return Digest of typed data hash claimer\\n     */\\n    function generateTypedDataHash(\\n        address _token,\\n        uint256 _reserveId,\\n        uint256 _reserveNonce,\\n        uint256 _index,\\n        address _claimer\\n    ) public view returns (bytes32) {\\n        bytes32 structHash = keccak256(abi.encode(CLAIM_TYPEHASH, _token, _reserveNonce, _reserveId, _index, _claimer));\\n        return _hashTypedDataV4(structHash);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                INTERNAL FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @dev Validates a mint pass claim\\n     * @param _token Address of the token contract\\n     * @param _reserveId ID of the reserve\\n     * @param _index Index of the mint pass\\n     * @param _claimer Account associated with the mint pass\\n     * @param _signature Signature of the mint pass claimer\\n     * @param _bitmap Bitmap used for checking if index is already claimed\\n     */\\n    function _claimMintPass(\\n        address _token,\\n        uint256 _reserveId,\\n        uint256 _index,\\n        address _claimer,\\n        bytes calldata _signature,\\n        LibBitmap.Bitmap storage _bitmap\\n    ) internal {\\n        if (LibBitmap.get(_bitmap, _index)) revert PassAlreadyClaimed();\\n        uint256 nonce = reserveNonce[_token][_reserveId];\\n        bytes32 hash = generateTypedDataHash(_token, _reserveId, nonce, _index, _claimer);\\n        address signer = signingAuthorities[_token][_reserveId];\\n        if (!signer.isValidSignatureNow(hash, _signature)) revert InvalidSignature();\\n        LibBitmap.set(_bitmap, _index);\\n\\n        emit PassClaimed(_token, _reserveId, _claimer, _index);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/auth/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n///\\n/// @dev Note:\\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\\n///\\n/// While the ownable portion follows\\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\\nabstract contract Ownable {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The caller is not authorized to call the function.\\n    error Unauthorized();\\n\\n    /// @dev The `newOwner` cannot be the zero address.\\n    error NewOwnerIsZeroAddress();\\n\\n    /// @dev The `pendingOwner` does not have a valid handover request.\\n    error NoHandoverRequest();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\n    /// despite it not being as lightweight as a single argument event.\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @dev An ownership handover to `pendingOwner` has been requested.\\n    event OwnershipHandoverRequested(address indexed pendingOwner);\\n\\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\\n    /// It is intentionally chosen to be a high value\\n    /// to avoid collision with lower slots.\\n    /// The choice of manual storage layout is to enable compatibility\\n    /// with both regular and upgradeable contracts.\\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\\n\\n    /// The ownership handover slot of `newOwner` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\n    ///     let handoverSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// It stores the expiry timestamp of the two-step ownership handover.\\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Initializes the owner directly without authorization guard.\\n    /// This function must be called upon initialization,\\n    /// regardless of whether the contract is upgradeable or not.\\n    /// This is to enable generalization to both regular and upgradeable contracts,\\n    /// and to save gas in case the initial owner is not the caller.\\n    /// For performance reasons, this function will not check if there\\n    /// is an existing owner.\\n    function _initializeOwner(address newOwner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Store the new value.\\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n        }\\n    }\\n\\n    /// @dev Sets the owner directly without authorization guard.\\n    function _setOwner(address newOwner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ownerSlot := not(_OWNER_SLOT_NOT)\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n            // Store the new value.\\n            sstore(ownerSlot, newOwner)\\n        }\\n    }\\n\\n    /// @dev Throws if the sender is not the owner.\\n    function _checkOwner() internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the caller is not the stored owner, revert.\\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\\n    /// Override to return a different value if needed.\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\\n        return 48 * 3600;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(shl(96, newOwner)) {\\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @dev Allows the owner to renounce their ownership.\\n    function renounceOwnership() public payable virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /// @dev Request a two-step ownership handover to the caller.\\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\\n    function requestOwnershipHandover() public payable virtual {\\n        unchecked {\\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Compute and set the handover slot to `expires`.\\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\\n                mstore(0x00, caller())\\n                sstore(keccak256(0x0c, 0x20), expires)\\n                // Emit the {OwnershipHandoverRequested} event.\\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\n            }\\n        }\\n    }\\n\\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\\n    function cancelOwnershipHandover() public payable virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x20), 0)\\n            // Emit the {OwnershipHandoverCanceled} event.\\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\n        }\\n    }\\n\\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            let handoverSlot := keccak256(0x0c, 0x20)\\n            // If the handover does not exist, or has expired.\\n            if gt(timestamp(), sload(handoverSlot)) {\\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Set the handover slot to 0.\\n            sstore(handoverSlot, 0)\\n        }\\n        _setOwner(pendingOwner);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the owner of the contract.\\n    function owner() public view virtual returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(not(_OWNER_SLOT_NOT))\\n        }\\n    }\\n\\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\n    function ownershipHandoverExpiresAt(address pendingOwner)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the handover slot.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            // Load the handover slot.\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Marks a function as only callable by the owner.\\n    modifier onlyOwner() virtual {\\n        _checkOwner();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeCastLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Safe unsigned integer casting library that reverts on overflow.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\\nlibrary SafeCastLib {\\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\\n        require(x < 1 << 248);\\n\\n        y = uint248(x);\\n    }\\n\\n    function safeCastTo240(uint256 x) internal pure returns (uint240 y) {\\n        require(x < 1 << 240);\\n\\n        y = uint240(x);\\n    }\\n\\n    function safeCastTo232(uint256 x) internal pure returns (uint232 y) {\\n        require(x < 1 << 232);\\n\\n        y = uint232(x);\\n    }\\n\\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\\n        require(x < 1 << 224);\\n\\n        y = uint224(x);\\n    }\\n\\n    function safeCastTo216(uint256 x) internal pure returns (uint216 y) {\\n        require(x < 1 << 216);\\n\\n        y = uint216(x);\\n    }\\n\\n    function safeCastTo208(uint256 x) internal pure returns (uint208 y) {\\n        require(x < 1 << 208);\\n\\n        y = uint208(x);\\n    }\\n\\n    function safeCastTo200(uint256 x) internal pure returns (uint200 y) {\\n        require(x < 1 << 200);\\n\\n        y = uint200(x);\\n    }\\n\\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\\n        require(x < 1 << 192);\\n\\n        y = uint192(x);\\n    }\\n\\n    function safeCastTo184(uint256 x) internal pure returns (uint184 y) {\\n        require(x < 1 << 184);\\n\\n        y = uint184(x);\\n    }\\n\\n    function safeCastTo176(uint256 x) internal pure returns (uint176 y) {\\n        require(x < 1 << 176);\\n\\n        y = uint176(x);\\n    }\\n\\n    function safeCastTo168(uint256 x) internal pure returns (uint168 y) {\\n        require(x < 1 << 168);\\n\\n        y = uint168(x);\\n    }\\n\\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\\n        require(x < 1 << 160);\\n\\n        y = uint160(x);\\n    }\\n\\n    function safeCastTo152(uint256 x) internal pure returns (uint152 y) {\\n        require(x < 1 << 152);\\n\\n        y = uint152(x);\\n    }\\n\\n    function safeCastTo144(uint256 x) internal pure returns (uint144 y) {\\n        require(x < 1 << 144);\\n\\n        y = uint144(x);\\n    }\\n\\n    function safeCastTo136(uint256 x) internal pure returns (uint136 y) {\\n        require(x < 1 << 136);\\n\\n        y = uint136(x);\\n    }\\n\\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\\n        require(x < 1 << 128);\\n\\n        y = uint128(x);\\n    }\\n\\n    function safeCastTo120(uint256 x) internal pure returns (uint120 y) {\\n        require(x < 1 << 120);\\n\\n        y = uint120(x);\\n    }\\n\\n    function safeCastTo112(uint256 x) internal pure returns (uint112 y) {\\n        require(x < 1 << 112);\\n\\n        y = uint112(x);\\n    }\\n\\n    function safeCastTo104(uint256 x) internal pure returns (uint104 y) {\\n        require(x < 1 << 104);\\n\\n        y = uint104(x);\\n    }\\n\\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\\n        require(x < 1 << 96);\\n\\n        y = uint96(x);\\n    }\\n\\n    function safeCastTo88(uint256 x) internal pure returns (uint88 y) {\\n        require(x < 1 << 88);\\n\\n        y = uint88(x);\\n    }\\n\\n    function safeCastTo80(uint256 x) internal pure returns (uint80 y) {\\n        require(x < 1 << 80);\\n\\n        y = uint80(x);\\n    }\\n\\n    function safeCastTo72(uint256 x) internal pure returns (uint72 y) {\\n        require(x < 1 << 72);\\n\\n        y = uint72(x);\\n    }\\n\\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\\n        require(x < 1 << 64);\\n\\n        y = uint64(x);\\n    }\\n\\n    function safeCastTo56(uint256 x) internal pure returns (uint56 y) {\\n        require(x < 1 << 56);\\n\\n        y = uint56(x);\\n    }\\n\\n    function safeCastTo48(uint256 x) internal pure returns (uint48 y) {\\n        require(x < 1 << 48);\\n\\n        y = uint48(x);\\n    }\\n\\n    function safeCastTo40(uint256 x) internal pure returns (uint40 y) {\\n        require(x < 1 << 40);\\n\\n        y = uint40(x);\\n    }\\n\\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\\n        require(x < 1 << 32);\\n\\n        y = uint32(x);\\n    }\\n\\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\\n        require(x < 1 << 24);\\n\\n        y = uint24(x);\\n    }\\n\\n    function safeCastTo16(uint256 x) internal pure returns (uint16 y) {\\n        require(x < 1 << 16);\\n\\n        y = uint16(x);\\n    }\\n\\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\\n        require(x < 1 << 8);\\n\\n        y = uint8(x);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IDutchAuction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\nimport {AuctionInfo, MinterInfo, RefundInfo, ReserveInfo} from \\\"src/lib/Structs.sol\\\";\\nimport {IMinter} from \\\"src/interfaces/IMinter.sol\\\";\\n\\n/**\\n * @title DutchAuction\\n * @author fx(hash)\\n * @notice Minter for distributing tokens at linear prices over fixed periods of time\\n */\\ninterface IDutchAuction is IMinter {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Event emitted when the mint details for a Dutch auction are set\\n     * @param _token Address of the token being minted\\n     * @param _reserveId ID of the reserve\\n     * @param _reserveInfo The reserve info of the Dutch auction\\n     * @param _merkleRoot The merkle root allowlisted buyers\\n     * @param _mintPassSigner The signing account for mint passes\\n     * @param _auctionInfo Dutch auction information\\n     */\\n    event MintDetailsSet(\\n        address indexed _token,\\n        uint256 indexed _reserveId,\\n        ReserveInfo _reserveInfo,\\n        bytes32 _merkleRoot,\\n        address _mintPassSigner,\\n        AuctionInfo _auctionInfo\\n    );\\n\\n    /**\\n     * @notice Event emitted when a purchase is made during the auction\\n     * @param _token Address of the token being purchased\\n     * @param _reserveId ID of the reserve\\n     * @param _buyer Address of the buyer\\n     * @param _to Address where the purchased tokens will be sent\\n     * @param _amount Amount of tokens purchased\\n     * @param _price Price at which the tokens were purchased\\n     */\\n    event Purchase(\\n        address indexed _token,\\n        uint256 indexed _reserveId,\\n        address indexed _buyer,\\n        address _to,\\n        uint256 _amount,\\n        uint256 _price\\n    );\\n\\n    /**\\n     * @notice Event emitted when a refund is claimed by a buyer\\n     * @param _token Address of the token for which the refund is claimed\\n     * @param _reserveId ID of the reserve\\n     * @param _buyer Address of the buyer claiming the refund\\n     * @param _refundAmount Amount of refund claimed\\n     */\\n    event RefundClaimed(\\n        address indexed _token,\\n        uint256 indexed _reserveId,\\n        address indexed _buyer,\\n        uint256 _refundAmount\\n    );\\n\\n    /**\\n     * @notice Event emitted when the sale proceeds are withdrawn\\n     * @param _token Address of the token\\n     * @param _reserveId ID of the reserve\\n     * @param _creator Address of the creator of the project\\n     * @param _proceeds Amount of sale proceeds withdrawn\\n     */\\n    event Withdrawn(address indexed _token, uint256 indexed _reserveId, address indexed _creator, uint256 _proceeds);\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  ERRORS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Error thrown when receiver is zero address\\n     */\\n    error AddressZero();\\n\\n    /**\\n     * @notice Error thrown when no funds available to withdraw\\n     */\\n    error InsufficientFunds();\\n\\n    /**\\n     * @notice Error thrown when the price is insufficient\\n     */\\n    error InsufficientPrice();\\n\\n    /**\\n     * @notice Error thrown when the allocation amount is zero\\n     */\\n    error InvalidAllocation();\\n\\n    /**\\n     * @notice Error thrown when the purchase amount is zero\\n     */\\n    error InvalidAmount();\\n\\n    /**\\n     * @notice Error thrown when payment does not equal price\\n     */\\n    error InvalidPayment();\\n\\n    /**\\n     * @notice Error thrown when the price is zero\\n     */\\n    error InvalidPrice();\\n\\n    /**\\n     * @notice Error thrown when the passing a price curve with less than 2 points\\n     */\\n    error InvalidPriceCurve();\\n\\n    /**\\n     * @notice Error thrown when a reserve does not exist\\n     */\\n    error InvalidReserve();\\n\\n    /**\\n     * @notice Error thrown when the step length is not equally divisible by the auction duration\\n     */\\n    error InvalidStep();\\n\\n    /**\\n     * @notice Error thrown when the token is address zero\\n     */\\n    error InvalidToken();\\n\\n    /**\\n     * @notice Error thrown when buying through allowlist and no allowlist exists\\n     */\\n    error NoAllowlist();\\n\\n    /**\\n     * @notice Error thrown when calling buy when either an allowlist or signer exists\\n     */\\n    error NoPublicMint();\\n\\n    /**\\n     * @notice Error thrown when there is no refund available\\n     */\\n    error NoRefund();\\n\\n    /**\\n     * @notice Error thrown when buy with a mint pass and no signing authority exists\\n     */\\n    error NoSigningAuthority();\\n\\n    /**\\n     * @notice Error thrown if auction has not ended\\n     */\\n    error NotEnded();\\n\\n    /**\\n     * @notice Error thrown if auction is not a refundable dutch auction\\n     */\\n    error NonRefundableDA();\\n\\n    /**\\n     * @notice Error thrown when the auction has not started\\n     */\\n    error NotStarted();\\n\\n    /**\\n     * @notice Error thrown when setting both an allowlist and mint signer\\n     */\\n    error OnlyAuthorityOrAllowlist();\\n\\n    /**\\n     * @notice Error thrown when the prices are out of order\\n     */\\n    error PricesOutOfOrder();\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Mapping of token address to reserve ID to reserve information\\n     */\\n    function auctions(address, uint256) external view returns (bool, uint248);\\n\\n    /**\\n     * @notice Purchases tokens at a linear price over fixed amount of time\\n     * @param _token Address of the token being purchased\\n     * @param _reserveId ID of the reserve\\n     * @param _amount Amount of tokens to purchase\\n     * @param _to Address receiving the purchased tokens\\n     */\\n    function buy(address _token, uint256 _reserveId, uint256 _amount, address _to) external payable;\\n\\n    /**\\n     * @notice Purchases tokens through an allowlist at a linear price over fixed amount of time\\n     * @param _token Address of the token being purchased\\n     * @param _reserveId ID of the reserve\\n     * @param _to Address receiving the purchased tokens\\n     * @param _indexes Array of indices containing purchase info inside the BitMap\\n     * @param _proofs Array of merkle proofs used for verifying the purchase\\n     */\\n    function buyAllowlist(\\n        address _token,\\n        uint256 _reserveId,\\n        address _to,\\n        uint256[] calldata _indexes,\\n        bytes32[][] calldata _proofs\\n    ) external payable;\\n\\n    /**\\n     * @notice Purchases tokens through a mint pass at a linear price over fixed amount of time\\n     * @param _token Address of the token being purchased\\n     * @param _reserveId ID of the reserve\\n     * @param _amount Number of tokens being purchased\\n     * @param _to Address receiving the purchased tokens\\n     * @param _index Index of puchase info inside the BitMap\\n     * @param _signature Array of merkle proofs used for verifying the purchase\\n     */\\n    function buyMintPass(\\n        address _token,\\n        uint256 _reserveId,\\n        uint256 _amount,\\n        address _to,\\n        uint256 _index,\\n        bytes calldata _signature\\n    ) external payable;\\n\\n    /**\\n     * @notice Returns the earliest valid reserveId that can mint a token\\n     */\\n    function getFirstValidReserve(address _token) external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the latest timestamp update made to token reserves\\n     * @param _token Address of the token contract\\n     * @return Timestamp of latest update\\n     */\\n    function getLatestUpdate(address _token) external view returns (uint40);\\n\\n    /**\\n     * @notice Gets the current auction price\\n     * @param _token Address of the token contract\\n     * @param _reserveId ID of the reserve\\n     * @return price Price of the token\\n     */\\n    function getPrice(address _token, uint256 _reserveId) external view returns (uint256);\\n\\n    /**\\n     * @notice Mapping of token address to reserve ID to merkle root\\n     */\\n    function merkleRoots(address, uint256) external view returns (bytes32);\\n\\n    /**\\n     * @notice Mapping of token address to reserve ID to number of tokens minted\\n     */\\n    function numberMinted(address _token, uint256 _reserveId) external view returns (uint256);\\n\\n    /**\\n     * @notice Pauses all function executions where modifier is applied\\n     */\\n    function pause() external;\\n\\n    /**\\n     * @notice Refunds an auction buyer with their rebate amount\\n     * @param _reserveId ID of the mint\\n     * @param _token Address of the token contract\\n     * @param _buyer Address of the buyer receiving the refund\\n     */\\n    function refund(address _token, uint256 _reserveId, address _buyer) external;\\n\\n    /**\\n     * @notice Mapping of token address to reserve ID to refund amount\\n     */\\n    function refunds(address, uint256) external view returns (uint256);\\n\\n    /**\\n     * @notice Mapping of token address to reserve ID to reserve information (allocation, price, max mint)\\n     */\\n    function reserves(address _token, uint256 _reserveId) external view returns (uint64, uint64, uint128);\\n\\n    /**\\n     * @notice Mapping of token address to reserve ID to amount of sale proceeds\\n     */\\n    function saleProceeds(address _token, uint256 _reserveId) external view returns (uint256);\\n\\n    /**\\n     * @inheritdoc IMinter\\n     * @dev Mint Details: struct of auction information, merkle root, and signer address\\n     */\\n    function setMintDetails(ReserveInfo calldata _reserveInfo, bytes calldata _mintDetails) external;\\n\\n    /**\\n     * @notice Unpauses all function executions where modifier is applied\\n     */\\n    function unpause() external;\\n\\n    /**\\n     * @notice Withdraws sale processed of primary sales to receiver\\n     * @param _reserveId ID of the reserve\\n     * @param _token Address of the token contract\\n     */\\n    function withdraw(address _token, uint256 _reserveId) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IFxGenArt721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\nimport {GenArtInfo, InitInfo, IssuerInfo, MetadataInfo, MintInfo, ProjectInfo, ReserveInfo} from \\\"src/lib/Structs.sol\\\";\\nimport {ISeedConsumer} from \\\"src/interfaces/ISeedConsumer.sol\\\";\\nimport {IToken} from \\\"src/interfaces/IToken.sol\\\";\\n\\n/**\\n * @title IFxGenArt721\\n * @author fx(hash)\\n * @notice ERC-721 token for generative art projects created on fxhash\\n */\\ninterface IFxGenArt721 is ISeedConsumer, IToken {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Event emitted when the base URI is updated\\n     * @param _uri Decoded content identifier of metadata pointer\\n     */\\n    event BaseURIUpdated(bytes _uri);\\n\\n    /**\\n     * @notice Event emitted when public burn is enabled or disabled\\n     * @param _flag Status of burn\\n     */\\n    event BurnEnabled(bool indexed _flag);\\n\\n    /**\\n     * @notice Event emitted when public mint is enabled or disabled\\n     * @param _flag Status of mint\\n     */\\n    event MintEnabled(bool indexed _flag);\\n\\n    /**\\n     * @notice Event emitted when project is deleted only once supply is set to zero\\n     */\\n    event ProjectDeleted();\\n\\n    /**\\n     * @notice Event emitted when new project is initialized\\n     * @param _primaryReceiver Address of splitter contract receiving primary sales\\n     * @param _projectInfo Project information\\n     * @param _metadataInfo Metadata information of token\\n     * @param _mintInfo Array of authorized minter contracts and their reserves\\n     */\\n    event ProjectInitialized(\\n        address indexed _primaryReceiver,\\n        ProjectInfo _projectInfo,\\n        MetadataInfo _metadataInfo,\\n        MintInfo[] _mintInfo\\n    );\\n\\n    /**\\n     * @notice Event emitted when the primary receiver address is updated\\n     * @param _receiver The split address receiving funds on behalf of the users\\n     * @param _receivers Array of addresses receiving a portion of the funds in a split\\n     * @param _allocations Array of allocation shares for the split\\n     */\\n    event PrimaryReceiverUpdated(address indexed _receiver, address[] _receivers, uint32[] _allocations);\\n\\n    /**\\n     * @notice Event emitted when project tags are set\\n     * @param _tagIds Array of tag IDs describing the project\\n     */\\n    event ProjectTags(uint256[] indexed _tagIds);\\n\\n    /**\\n     * @notice Event emitted when Randomizer contract is updated\\n     * @param _randomizer Address of new Randomizer contract\\n     */\\n    event RandomizerUpdated(address indexed _randomizer);\\n\\n    /**\\n     * @notice Event emitted when Renderer contract is updated\\n     * @param _renderer Address of new Renderer contract\\n     */\\n    event RendererUpdated(address indexed _renderer);\\n\\n    /**\\n     * @notice Event emitted when onchain data of project is updated\\n     * @param _pointer SSTORE2 pointer to the onchain data\\n     */\\n    event OnchainPointerUpdated(address _pointer);\\n\\n    /**\\n     * @notice Event emitted when maximum supply is reduced\\n     * @param _prevSupply Amount of previous supply\\n     * @param _newSupply Amount of new supply\\n     */\\n    event SupplyReduced(uint120 indexed _prevSupply, uint120 indexed _newSupply);\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  ERRORS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Error thrown when total minter allocation exceeds maximum supply\\n     */\\n    error AllocationExceeded();\\n\\n    /**\\n     *  @notice Error thrown when burning is inactive\\n     */\\n    error BurnInactive();\\n\\n    /**\\n     * @notice Error thrown when the fee receiver address is not included in the receiver allocations\\n     */\\n    error FeeReceiverMissing();\\n\\n    /**\\n     * @notice Error thrown when remaining supply is zero\\n     */\\n    error InsufficientSupply();\\n\\n    /**\\n     * @notice Error thrown when max supply amount is invalid\\n     */\\n    error InvalidAmount();\\n\\n    /**\\n     * @notice Error thrown when input size does not match actual byte size of params data\\n     */\\n    error InvalidInputSize();\\n\\n    /**\\n     * @notice Error thrown when reserve start time is invalid\\n     */\\n    error InvalidStartTime();\\n\\n    /**\\n     * @notice Error thrown when reserve end time is invalid\\n     */\\n    error InvalidEndTime();\\n\\n    /**\\n     * @notice Error thrown when the configured fee receiver is not valid\\n     */\\n    error InvalidFeeReceiver();\\n\\n    /**\\n     * @notice Error thrown when minting is active\\n     */\\n    error MintActive();\\n\\n    /**\\n     *  @notice Error thrown when minting is inactive\\n     */\\n    error MintInactive();\\n\\n    /**\\n     * @notice Error thrown when caller is not authorized to execute transaction\\n     */\\n    error NotAuthorized();\\n\\n    /**\\n     * @notice Error thrown when signer is not the owner\\n     */\\n    error NotOwner();\\n\\n    /**\\n     * @notice Error thrown when supply is remaining\\n     */\\n    error SupplyRemaining();\\n\\n    /**\\n     * @notice Error thrown when caller does not have the specified role\\n     */\\n    error UnauthorizedAccount();\\n\\n    /**\\n     * @notice Error thrown when caller does not have minter role\\n     */\\n    error UnauthorizedMinter();\\n\\n    /**\\n     * @notice Error thrown when minter is not registered on token contract\\n     */\\n    error UnregisteredMinter();\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /*\\n     * @notice Returns the list of minter contracts currently active on the token\\n     */\\n    function activeMinters() external view returns (address[] memory);\\n\\n    /**\\n     * @notice Burns token ID from the circulating supply\\n     * @param _tokenId ID of the token\\n     */\\n    function burn(uint256 _tokenId) external;\\n\\n    /**\\n     * @notice Returns address of the FxContractRegistry contract\\n     */\\n    function contractRegistry() external view returns (address);\\n\\n    /**\\n     * @notice Returns contract-level metadata for storefront marketplaces\\n     */\\n    function contractURI() external view returns (string memory);\\n\\n    /**\\n     * @inheritdoc ISeedConsumer\\n     */\\n    function fulfillSeedRequest(uint256 _tokenId, bytes32 _seed) external;\\n\\n    /**\\n     * @notice Mapping of token ID to GenArtInfo struct (minter, seed, fxParams)\\n     */\\n    function genArtInfo(uint256 _tokenId) external view returns (address, bytes32, bytes memory);\\n\\n    /**\\n     * @notice Generates typed data hash for setting project metadata onchain\\n     * @param _data Bytes-encoded onchain data\\n     * @return Typed data hash\\n     */\\n    function generateOnchainPointerHash(bytes calldata _data) external view returns (bytes32);\\n\\n    /**\\n     * @notice Generates typed data hash for setting the primary receiver address\\n     * @param _renderer Address of the new renderer contract\\n     * @return Typed data hash\\n     */\\n    function generateRendererHash(address _renderer) external view returns (bytes32);\\n\\n    /**\\n     * @notice Initializes new generative art project\\n     * @param _owner Address of token proxy owner\\n     * @param _initInfo Initialization information set on project creation\\n     * @param _projectInfo Project information\\n     * @param _metadataInfo Metadata information\\n     * @param _mintInfo Array of authorized minter contracts and their reserves\\n     * @param _royaltyReceivers Array of addresses receiving royalties\\n     * @param _allocations Array of allocation amounts for calculating royalty shares\\n     * @param _basisPoints Total allocation scalar for calculating royalty shares\\n     */\\n    function initialize(\\n        address _owner,\\n        InitInfo calldata _initInfo,\\n        ProjectInfo calldata _projectInfo,\\n        MetadataInfo calldata _metadataInfo,\\n        MintInfo[] calldata _mintInfo,\\n        address[] calldata _royaltyReceivers,\\n        uint32[] calldata _allocations,\\n        uint96 _basisPoints\\n    ) external;\\n\\n    /**\\n     * @notice Gets the authorization status for the given minter contract\\n     * @param _minter Address of the minter contract\\n     * @return Authorization status\\n     */\\n    function isMinter(address _minter) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the issuer information of the project (primaryReceiver, ProjectInfo)\\n     */\\n    function issuerInfo() external view returns (address, ProjectInfo memory);\\n\\n    /**\\n     * @notice Returns the metadata information of the project (baseURI, onchainPointer)\\n     */\\n    function metadataInfo() external view returns (bytes memory, address);\\n\\n    /**\\n     * @inheritdoc IToken\\n     */\\n    function mint(address _to, uint256 _amount, uint256 _payment) external;\\n\\n    /**\\n     * @notice Mints single fxParams token\\n     * @dev Only callable by registered minter contracts\\n     * @param _to Address receiving minted token\\n     * @param _fxParams Random sequence of fixed-length bytes used as input\\n     */\\n    function mintParams(address _to, bytes calldata _fxParams) external;\\n\\n    /**\\n     * @notice Current nonce for admin signatures\\n     */\\n    function nonce() external returns (uint96);\\n\\n    /**\\n     * @notice Mints single token with randomly generated seed\\n     * @dev Only callable by contract owner\\n     * @param _to Address receiving token\\n     */\\n    function ownerMint(address _to) external;\\n\\n    /**\\n     * @notice Mints single fxParams token\\n     * @dev Only callable by contract owner\\n     * @param _to Address receiving minted token\\n     * @param _fxParams Random sequence of fixed-length bytes used as input\\n     */\\n    function ownerMintParams(address _to, bytes calldata _fxParams) external;\\n\\n    /**\\n     * @notice Pauses all function executions where modifier is applied\\n     */\\n    function pause() external;\\n\\n    /**\\n     * @inheritdoc IToken\\n     */\\n    function primaryReceiver() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the randomizer contract\\n     */\\n    function randomizer() external view returns (address);\\n\\n    /**\\n     * @notice Reduces maximum supply of collection\\n     * @param _supply Maximum supply amount\\n     */\\n    function reduceSupply(uint120 _supply) external;\\n\\n    /**\\n     * @notice Registers minter contracts with resereve info\\n     * @param _mintInfo Mint information of token reserves\\n     */\\n    function registerMinters(MintInfo[] memory _mintInfo) external;\\n\\n    /**\\n     * @notice Returns the remaining supply of tokens left to mint\\n     */\\n    function remainingSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the address of the Renderer contract\\n     */\\n    function renderer() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the FxRoleRegistry contract\\n     */\\n    function roleRegistry() external view returns (address);\\n\\n    /**\\n     * @notice Sets the base royalties for all secondary token sales\\n     * @param _receivers Array of addresses receiving royalties\\n     * @param _allocations Array of allocations used to calculate royalty payments\\n     * @param _basisPoints basis points used to calculate royalty payments\\n     */\\n    function setBaseRoyalties(\\n        address[] calldata _receivers,\\n        uint32[] calldata _allocations,\\n        uint96 _basisPoints\\n    ) external;\\n\\n    /**\\n     * @notice Sets the new URI of the token metadata\\n     * @param _uri Decoded content identifier of metadata pointer\\n     */\\n    function setBaseURI(bytes calldata _uri) external;\\n\\n    /**\\n     * @notice Sets flag status of public burn to enabled or disabled\\n     * @param _flag Status of burn\\n     */\\n    function setBurnEnabled(bool _flag) external;\\n\\n    /**\\n     * @notice Sets flag status of public mint to enabled or disabled\\n     * @param _flag Status of mint\\n     */\\n    function setMintEnabled(bool _flag) external;\\n\\n    /**\\n     * @notice Sets the onchain pointer for reconstructing project metadata onchain\\n     * @param _onchainData Bytes-encoded metadata\\n     * @param _signature Signature of creator used to verify metadata update\\n     */\\n    function setOnchainPointer(bytes calldata _onchainData, bytes calldata _signature) external;\\n\\n    /**\\n     * @notice Sets the primary receiver address for primary sale proceeds\\n     * @param _receivers Array of addresses receiving shares from primary sales\\n     * @param _allocations Array of allocation amounts for calculating primary sales shares\\n     */\\n    function setPrimaryReceivers(address[] calldata _receivers, uint32[] calldata _allocations) external;\\n\\n    /**\\n     * @notice Sets the new randomizer contract\\n     * @param _randomizer Address of the randomizer contract\\n     */\\n    function setRandomizer(address _randomizer) external;\\n\\n    /**\\n     * @notice Sets the new renderer contract\\n     * @param _renderer Address of the renderer contract\\n     * @param _signature Signature of creator used to verify renderer update\\n     */\\n    function setRenderer(address _renderer, bytes calldata _signature) external;\\n\\n    /**\\n     * @notice Emits an event for setting tag descriptions for the project\\n     * @param _tagIds Array of tag IDs describing the project\\n     */\\n    function setTags(uint256[] calldata _tagIds) external;\\n\\n    /**\\n     * @notice Returns the current circulating supply of tokens\\n     */\\n    function totalSupply() external view returns (uint96);\\n\\n    /**\\n     * @notice Unpauses all function executions where modifier is applied\\n     */\\n    function unpause() external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\n/**\\n * @title IToken\\n * @author fx(hash)\\n * @notice Interface for minters to interact with tokens\\n */\\ninterface IToken {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Mints arbitrary number of tokens\\n     * @dev Only callable by registered minter contracts\\n     * @param _to Address receiving tokens\\n     * @param _amount Number of tokens being minted\\n     * @param _payment Total payment amount of the transaction\\n     */\\n    function mint(address _to, uint256 _amount, uint256 _payment) external;\\n\\n    /**\\n     * @notice Returns address of primary receiver for token sales\\n     */\\n    function primaryReceiver() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proofLen - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            require(proofPos == proofLen, \\\"MerkleProof: invalid multiproof\\\");\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proofLen - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            require(proofPos == proofLen, \\\"MerkleProof: invalid multiproof\\\");\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/LibBit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for bit twiddling and boolean operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBit.sol)\\n/// @author Inspired by (https://graphics.stanford.edu/~seander/bithacks.html)\\nlibrary LibBit {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  BIT TWIDDLING OPERATIONS                  */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Find last set.\\n    /// Returns the index of the most significant bit of `x`,\\n    /// counting from the least significant bit position.\\n    /// If `x` is zero, returns 256.\\n    /// Equivalent to `log2(x)`, but without reverting for the zero case.\\n    function fls(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := shl(8, iszero(x))\\n\\n            r := or(r, shl(7, lt(0xffffffffffffffffffffffffffffffff, x)))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n\\n            // For the remaining 32 bits, use a De Bruijn lookup.\\n            x := shr(r, x)\\n            x := or(x, shr(1, x))\\n            x := or(x, shr(2, x))\\n            x := or(x, shr(4, x))\\n            x := or(x, shr(8, x))\\n            x := or(x, shr(16, x))\\n\\n            // forgefmt: disable-next-item\\n            r := or(r, byte(shr(251, mul(x, shl(224, 0x07c4acdd))),\\n                0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f))\\n        }\\n    }\\n\\n    /// @dev Count leading zeros.\\n    /// Returns the number of zeros preceding the most significant one bit.\\n    /// If `x` is zero, returns 256.\\n    function clz(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let t := add(iszero(x), 255)\\n\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n\\n            // For the remaining 32 bits, use a De Bruijn lookup.\\n            x := shr(r, x)\\n            x := or(x, shr(1, x))\\n            x := or(x, shr(2, x))\\n            x := or(x, shr(4, x))\\n            x := or(x, shr(8, x))\\n            x := or(x, shr(16, x))\\n\\n            // forgefmt: disable-next-item\\n            r := sub(t, or(r, byte(shr(251, mul(x, shl(224, 0x07c4acdd))),\\n                0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f)))\\n        }\\n    }\\n\\n    /// @dev Find first set.\\n    /// Returns the index of the least significant bit of `x`,\\n    /// counting from the least significant bit position.\\n    /// If `x` is zero, returns 256.\\n    /// Equivalent to `ctz` (count trailing zeros), which gives\\n    /// the number of zeros following the least significant one bit.\\n    function ffs(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := shl(8, iszero(x))\\n\\n            // Isolate the least significant bit.\\n            x := and(x, add(not(x), 1))\\n\\n            r := or(r, shl(7, lt(0xffffffffffffffffffffffffffffffff, x)))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n\\n            // For the remaining 32 bits, use a De Bruijn lookup.\\n            // forgefmt: disable-next-item\\n            r := or(r, byte(shr(251, mul(shr(r, x), shl(224, 0x077cb531))), \\n                0x00011c021d0e18031e16140f191104081f1b0d17151310071a0c12060b050a09))\\n        }\\n    }\\n\\n    /// @dev Returns the number of set bits in `x`.\\n    function popCount(uint256 x) internal pure returns (uint256 c) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let max := not(0)\\n            let isMax := eq(x, max)\\n            x := sub(x, and(shr(1, x), div(max, 3)))\\n            x := add(and(x, div(max, 5)), and(shr(2, x), div(max, 5)))\\n            x := and(add(x, shr(4, x)), div(max, 17))\\n            c := or(shl(8, isMax), shr(248, mul(x, div(max, 255))))\\n        }\\n    }\\n\\n    /// @dev Returns whether `x` is a power of 2.\\n    function isPo2(uint256 x) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `x && !(x & (x - 1))`.\\n            result := iszero(add(and(x, sub(x, 1)), iszero(x)))\\n        }\\n    }\\n\\n    /// @dev Returns `x` reversed at the bit level.\\n    function reverseBits(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Computing masks on-the-fly reduces bytecode size by about 500 bytes.\\n            let m := not(0)\\n            r := x\\n            for { let s := 128 } 1 {} {\\n                m := xor(m, shl(s, m))\\n                r := or(and(shr(s, r), m), and(shl(s, r), not(m)))\\n                s := shr(1, s)\\n                if iszero(s) { break }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns `x` reversed at the byte level.\\n    function reverseBytes(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Computing masks on-the-fly reduces bytecode size by about 200 bytes.\\n            let m := not(0)\\n            r := x\\n            for { let s := 128 } 1 {} {\\n                m := xor(m, shl(s, m))\\n                r := or(and(shr(s, r), m), and(shl(s, r), not(m)))\\n                s := shr(1, s)\\n                if eq(s, 4) { break }\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     BOOLEAN OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns `x & y`.\\n    function and(bool x, bool y) internal pure returns (bool z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := and(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x | y`.\\n    function or(bool x, bool y) internal pure returns (bool z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := or(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns a non-zero number if `b` is true, else 0.\\n    /// If `b` is from plain Solidity, the non-zero number will be 1.\\n    function toUint(bool b) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := b\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"./ECDSA.sol\\\";\\nimport \\\"../ShortStrings.sol\\\";\\nimport \\\"../../interfaces/IERC5267.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\\n *\\n * _Available since v3.4._\\n *\\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n */\\nabstract contract EIP712 is IERC5267 {\\n    using ShortStrings for *;\\n\\n    bytes32 private constant _TYPE_HASH =\\n        keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _cachedDomainSeparator;\\n    uint256 private immutable _cachedChainId;\\n    address private immutable _cachedThis;\\n\\n    bytes32 private immutable _hashedName;\\n    bytes32 private immutable _hashedVersion;\\n\\n    ShortString private immutable _name;\\n    ShortString private immutable _version;\\n    string private _nameFallback;\\n    string private _versionFallback;\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        _name = name.toShortStringWithFallback(_nameFallback);\\n        _version = version.toShortStringWithFallback(_versionFallback);\\n        _hashedName = keccak256(bytes(name));\\n        _hashedVersion = keccak256(bytes(version));\\n\\n        _cachedChainId = block.chainid;\\n        _cachedDomainSeparator = _buildDomainSeparator();\\n        _cachedThis = address(this);\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\\n            return _cachedDomainSeparator;\\n        } else {\\n            return _buildDomainSeparator();\\n        }\\n    }\\n\\n    function _buildDomainSeparator() private view returns (bytes32) {\\n        return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n\\n    /**\\n     * @dev See {EIP-5267}.\\n     *\\n     * _Available since v4.9._\\n     */\\n    function eip712Domain()\\n        public\\n        view\\n        virtual\\n        override\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        )\\n    {\\n        return (\\n            hex\\\"0f\\\", // 01111\\n            _name.toStringWithFallback(_nameFallback),\\n            _version.toStringWithFallback(_versionFallback),\\n            block.chainid,\\n            address(this),\\n            bytes32(0),\\n            new uint256[](0)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/SignatureChecker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\nimport \\\"../../interfaces/IERC1271.sol\\\";\\n\\n/**\\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\\n * Argent and Gnosis Safe.\\n *\\n * _Available since v4.1._\\n */\\nlibrary SignatureChecker {\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\\n        return\\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\\n            isValidERC1271SignatureNow(signer, hash, signature);\\n    }\\n\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\\n     * against the signer smart contract using ERC1271.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidERC1271SignatureNow(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        (bool success, bytes memory result) = signer.staticcall(\\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\\n        );\\n        return (success &&\\n            result.length >= 32 &&\\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/utils/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                CONSTANTS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n// Core\\nstring constant FX_CONTRACT_REGISTRY = \\\"FX_CONTRACT_REGISTRY\\\";\\nstring constant FX_GEN_ART_721 = \\\"FX_GEN_ART_721\\\";\\nstring constant FX_ISSUER_FACTORY = \\\"FX_ISSUER_FACTORY\\\";\\nstring constant FX_MINT_TICKET_721 = \\\"FX_MINT_TICKET_721\\\";\\nstring constant FX_ROLE_REGISTRY = \\\"FX_ROLE_REGISTRY\\\";\\nstring constant FX_TICKET_FACTORY = \\\"FX_TICKET_FACTORY\\\";\\n\\n// Periphery\\nstring constant DUTCH_AUCTION = \\\"DUTCH_AUCTION\\\";\\nstring constant FIXED_PRICE = \\\"FIXED_PRICE\\\";\\nstring constant ONCHFS_RENDERER = \\\"ONCHFS_RENDERER\\\";\\nstring constant IPFS_RENDERER = \\\"IPFS_RENDERER\\\";\\nstring constant PSEUDO_RANDOMIZER = \\\"PSEUDO_RANDOMIZER\\\";\\nstring constant TICKET_REDEEMER = \\\"TICKET_REDEEMER\\\";\\n\\n// EIP-712\\nbytes32 constant CLAIM_TYPEHASH = keccak256(\\n    \\\"Claim(address token,uint256 reserveId,uint96 nonce,uint256 index,address user)\\\"\\n);\\nbytes32 constant SET_ONCHAIN_POINTER_TYPEHASH = keccak256(\\\"SetOnchainPointer(bytes onchainData,uint96 nonce)\\\");\\nbytes32 constant SET_PRIMARY_RECEIVER_TYPEHASH = keccak256(\\\"SetPrimaryReceiver(address receiver,uint96 nonce)\\\");\\nbytes32 constant SET_RENDERER_TYPEHASH = keccak256(\\\"SetRenderer(address renderer,uint96 nonce)\\\");\\n\\n// IPFS\\nbytes constant IPFS_URL = hex\\\"697066733a2f2f172c151325290607391d2c391b242225180a020b291b260929391d1b31222525202804120031280917120b280400\\\";\\nstring constant IPFS_PREFIX = \\\"ipfs://\\\";\\n\\n// Metadata\\nstring constant API_VERSION = \\\"0.2\\\";\\nstring constant ATTRIBUTES_ENDPOINT = \\\"/attributes.json\\\";\\nstring constant METADATA_ENDPOINT = \\\"/metadata.json\\\";\\nstring constant THUMBNAIL_ENDPOINT = \\\"/thumbnail.json\\\";\\n\\n// ONCHFS\\nstring constant FX_HASH_QUERY = \\\"/?fxhash=\\\";\\nstring constant FX_PARAMS_QUERY = \\\"#0x\\\";\\nstring constant ITERATION_QUERY = \\\"&fxiteration=\\\";\\nstring constant MINTER_QUERY = \\\"&fxminter=\\\";\\nstring constant ONCHFS_PREFIX = \\\"onchfs://\\\";\\n\\n// Minters\\nuint8 constant UNINITIALIZED = 0;\\nuint8 constant FALSE = 1;\\nuint8 constant TRUE = 2;\\n\\n// Project\\nuint32 constant LOCK_TIME = 3600; // 1 hour\\nuint64 constant TIME_UNLIMITED = type(uint64).max;\\nuint120 constant OPEN_EDITION_SUPPLY = type(uint120).max;\\nuint256 constant LAUNCH_TIMESTAMP = 1702558800; // 12/14/23 14:00 CET\\n\\n// Roles\\nbytes32 constant ADMIN_ROLE = keccak256(\\\"ADMIN_ROLE\\\");\\nbytes32 constant BANNED_USER_ROLE = keccak256(\\\"BANNED_USER_ROLE\\\");\\nbytes32 constant CREATOR_ROLE = keccak256(\\\"CREATOR_ROLE\\\");\\nbytes32 constant METADATA_ROLE = keccak256(\\\"METADATA_ROLE\\\");\\nbytes32 constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\nbytes32 constant MODERATOR_ROLE = keccak256(\\\"MODERATOR_ROLE\\\");\\nbytes32 constant SIGNER_ROLE = keccak256(\\\"SIGNER_ROLE\\\");\\n\\n// Royalties\\nuint32 constant ALLOCATION_DENOMINATOR = 1_000_000;\\nuint96 constant FEE_DENOMINATOR = 10_000;\\nuint96 constant MAX_ROYALTY_BPS = 2500; // 25%\\n\\n// Splits\\naddress constant SPLITS_MAIN = 0x2ed6c4B5dA6378c7897AC67Ba9e43102Feb694EE;\\n\\n// Ticket\\nuint256 constant AUCTION_DECAY_RATE = 200; // 2%\\nuint256 constant DAILY_TAX_RATE = 27; // 0.274%\\nuint256 constant MINIMUM_PRICE = 0.001 ether;\\nuint256 constant ONE_DAY = 86_400;\\nuint256 constant SCALING_FACTOR = 10_000;\\nuint256 constant TEN_MINUTES = 600;\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/Structs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                  STRUCTS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/**\\n * @notice Struct of dutch auction information\\n * - `refunded` Flag indicating if refunds are enabled\\n * - `stepLength` Duration (in seconds) of each auction step\\n * - `prices` Array of prices for each step of the auction\\n */\\nstruct AuctionInfo {\\n    bool refunded;\\n    uint248 stepLength;\\n    uint256[] prices;\\n}\\n\\n/**\\n * @notice Struct of system config information\\n * - `feeReceiver` Address receiving platform fees\\n * - `primaryFeeAllocation` Amount of basis points allocated to calculate platform fees on primary sale proceeds\\n * - `secondaryFeeAllocation` Amount of basis points allocated to calculate platform fees on royalty payments\\n * - `lockTime` Locked time duration added to mint start time for unverified creators\\n * - `referrerShare` Share amount distributed to accounts referring tokens\\n * - `defaultMetadataURI` Default base URI of token metadata\\n * - `externalURI` External URI for displaying tokens\\n */\\nstruct ConfigInfo {\\n    address feeReceiver;\\n    uint32 primaryFeeAllocation;\\n    uint32 secondaryFeeAllocation;\\n    uint32 lockTime;\\n    uint64 referrerShare;\\n    string defaultMetadataURI;\\n    string externalURI;\\n}\\n\\n/**\\n * @notice Struct of generative art information\\n * - `minter` Address of initial token owner\\n * - `seed` Hash of randomly generated seed\\n * - `fxParams` Random sequence of fixed-length bytes used as token input\\n */\\nstruct GenArtInfo {\\n    address minter;\\n    bytes32 seed;\\n    bytes fxParams;\\n}\\n\\n/**\\n * @notice Struct of initialization information used on project creation\\n * - `name` Name of project\\n * - `symbol` Symbol of project\\n * - `primaryReceiver` Address of splitter contract receiving primary sales\\n * - `randomizer` Address of Randomizer contract\\n * - `renderer` Address of Renderer contract\\n * - `tagIds` Array of tag IDs describing the project\\n * - 'onchainData' Onchain data to be stored using SSTORE2 and available to renderers\\n */\\nstruct InitInfo {\\n    string name;\\n    string symbol;\\n    address[] primaryReceivers;\\n    uint32[] allocations;\\n    address randomizer;\\n    address renderer;\\n    uint256[] tagIds;\\n    bytes onchainData;\\n}\\n\\n/**\\n * @notice Struct of issuer information\\n * - `primaryReceiver` Address of splitter contract receiving primary sales\\n * - `projectInfo` Project information\\n * - `activeMinters` Array of authorized minter contracts used for enumeration\\n * - `minters` Mapping of minter contract to authorization status\\n */\\nstruct IssuerInfo {\\n    address primaryReceiver;\\n    ProjectInfo projectInfo;\\n    address[] activeMinters;\\n    mapping(address => uint8) minters;\\n}\\n\\n/**\\n * @notice Struct of metadata information\\n * - `baseURI` Decoded URI of content identifier\\n * - `onchainPointer` Address of bytes-encoded data rendered onchain\\n */\\nstruct MetadataInfo {\\n    bytes baseURI;\\n    address onchainPointer;\\n}\\n\\n/**\\n * @notice Struct of mint information\\n * - `minter` Address of the minter contract\\n * - `reserveInfo` Reserve information\\n * - `params` Optional bytes data decoded inside minter\\n */\\nstruct MintInfo {\\n    address minter;\\n    ReserveInfo reserveInfo;\\n    bytes params;\\n}\\n\\n/**\\n * @notice Struct of minter information\\n * - `totalMints` Total number of mints executed by the minter\\n * - `totalPaid` Total amount paid by the minter\\n */\\nstruct MinterInfo {\\n    uint128 totalMints;\\n    uint128 totalPaid;\\n}\\n\\n/**\\n * @notice Struct of project information\\n * - `mintEnabled` Flag inidicating if minting is enabled\\n * - `burnEnabled` Flag inidicating if burning is enabled\\n * - `maxSupply` Maximum supply of tokens\\n * - `inputSize` Maximum input size of fxParams bytes data\\n * - `earliestStartTime` Earliest possible start time for registering minters\\n */\\nstruct ProjectInfo {\\n    bool mintEnabled;\\n    bool burnEnabled;\\n    uint120 maxSupply;\\n    uint88 inputSize;\\n    uint32 earliestStartTime;\\n}\\n\\n/**\\n * @notice Struct of refund information\\n * - `lastPrice` Price of last sale before selling out\\n * - `minterInfo` Mapping of minter address to struct of minter information\\n */\\nstruct RefundInfo {\\n    uint256 lastPrice;\\n    mapping(address minter => MinterInfo) minterInfo;\\n}\\n\\n/**\\n * @notice Struct of reserve information\\n * - `startTime` Start timestamp of minter\\n * - `endTime` End timestamp of minter\\n * - `allocation` Allocation amount for minter\\n */\\nstruct ReserveInfo {\\n    uint64 startTime;\\n    uint64 endTime;\\n    uint128 allocation;\\n}\\n\\n/**\\n * @notice Struct of royalty information\\n * - `receiver` Address receiving royalties\\n * - `basisPoints` Points used to calculate the royalty payment (0.01%)\\n */\\nstruct RoyaltyInfo {\\n    address receiver;\\n    uint96 basisPoints;\\n}\\n\\n/**\\n * @notice Struct of tax information\\n * - `startTime` Timestamp of when harberger taxation begins\\n * - `foreclosureTime` Timestamp of token foreclosure\\n * - `currentPrice` Current listing price of token\\n * - `depositAmount` Total amount of taxes deposited\\n */\\nstruct TaxInfo {\\n    uint48 startTime;\\n    uint48 foreclosureTime;\\n    uint80 currentPrice;\\n    uint80 depositAmount;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\nimport {ReserveInfo} from \\\"src/lib/Structs.sol\\\";\\n\\n/**\\n * @title IMinter\\n * @author fx(hash)\\n * @notice Interface for FxGenArt721 tokens to interact with minters\\n */\\ninterface IMinter {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Sets the mint details for token reserves\\n     * @param _reserveInfo Reserve information for the token\\n     * @param _mintDetails Details of the mint pertaining to the minter\\n     */\\n    function setMintDetails(ReserveInfo calldata _reserveInfo, bytes calldata _mintDetails) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISeedConsumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\n/**\\n * @title ISeedConsumer\\n * @author fx(hash)\\n * @notice Interface for randomizers to interact with FxGenArt721 tokens\\n */\\ninterface ISeedConsumer {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Event emitted when a seed request is fulfilled for a specific token\\n     * @param _randomizer Address of the randomizer contract\\n     * @param _tokenId ID of the token\\n     * @param _seed Hash of the random seed\\n     */\\n    event SeedFulfilled(address indexed _randomizer, uint256 indexed _tokenId, bytes32 _seed);\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Fullfills the random seed request on the FxGenArt721 token contract\\n     * @param _tokenId ID of the token\\n     * @param _seed Hash of the random seed\\n     */\\n    function fulfillSeedRequest(uint256 _tokenId, bytes32 _seed) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/ShortStrings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/ShortStrings.sol)\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"./StorageSlot.sol\\\";\\n\\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\\n// | length  | 0x                                                              BB |\\ntype ShortString is bytes32;\\n\\n/**\\n * @dev This library provides functions to convert short memory strings\\n * into a `ShortString` type that can be used as an immutable variable.\\n *\\n * Strings of arbitrary length can be optimized using this library if\\n * they are short enough (up to 31 bytes) by packing them with their\\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\\n * fallback mechanism can be used for every other case.\\n *\\n * Usage example:\\n *\\n * ```solidity\\n * contract Named {\\n *     using ShortStrings for *;\\n *\\n *     ShortString private immutable _name;\\n *     string private _nameFallback;\\n *\\n *     constructor(string memory contractName) {\\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\\n *     }\\n *\\n *     function name() external view returns (string memory) {\\n *         return _name.toStringWithFallback(_nameFallback);\\n *     }\\n * }\\n * ```\\n */\\nlibrary ShortStrings {\\n    // Used as an identifier for strings longer than 31 bytes.\\n    bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\\n\\n    error StringTooLong(string str);\\n    error InvalidShortString();\\n\\n    /**\\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\\n     *\\n     * This will trigger a `StringTooLong` error is the input string is too long.\\n     */\\n    function toShortString(string memory str) internal pure returns (ShortString) {\\n        bytes memory bstr = bytes(str);\\n        if (bstr.length > 31) {\\n            revert StringTooLong(str);\\n        }\\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\\n    }\\n\\n    /**\\n     * @dev Decode a `ShortString` back to a \\\"normal\\\" string.\\n     */\\n    function toString(ShortString sstr) internal pure returns (string memory) {\\n        uint256 len = byteLength(sstr);\\n        // using `new string(len)` would work locally but is not memory safe.\\n        string memory str = new string(32);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(str, len)\\n            mstore(add(str, 0x20), sstr)\\n        }\\n        return str;\\n    }\\n\\n    /**\\n     * @dev Return the length of a `ShortString`.\\n     */\\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\\n        if (result > 31) {\\n            revert InvalidShortString();\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\\n     */\\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\\n        if (bytes(value).length < 32) {\\n            return toShortString(value);\\n        } else {\\n            StorageSlot.getStringSlot(store).value = value;\\n            return ShortString.wrap(_FALLBACK_SENTINEL);\\n        }\\n    }\\n\\n    /**\\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\\n     */\\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\\n            return toString(value);\\n        } else {\\n            return store;\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\\n     *\\n     * WARNING: This will return the \\\"byte length\\\" of the string. This may not reflect the actual length in terms of\\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\\n     */\\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\\n            return byteLength(value);\\n        } else {\\n            return bytes(store).length;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC5267.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC5267 {\\n    /**\\n     * @dev MAY be emitted to signal that the domain could have changed.\\n     */\\n    event EIP712DomainChanged();\\n\\n    /**\\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\\n     * signature.\\n     */\\n    function eip712Domain()\\n        external\\n        view\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        );\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\n * _Available since v4.9 for `string`, `bytes`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"scripty.sol/=lib/scripty.sol/\",\r\n      \"solady/=lib/solady/\",\r\n      \"solmate/=lib/solmate/\",\r\n      \"sstore2/=lib/sstore2/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"AddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientFunds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAllocation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPayment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPriceCurve\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProof\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidReserve\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidShortString\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidStep\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoAllowlist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoPublicMint\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoRefund\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoSigningAuthority\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonRefundableDA\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotStarted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyAuthorityOrAllowlist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PassAlreadyClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PricesOutOfOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SlotAlreadyClaimed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"StringTooLong\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EIP712DomainChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_reserveId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"allocation\",\"type\":\"uint128\"}],\"indexed\":false,\"internalType\":\"struct ReserveInfo\",\"name\":\"_reserveInfo\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_mintPassSigner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"refunded\",\"type\":\"bool\"},{\"internalType\":\"uint248\",\"name\":\"stepLength\",\"type\":\"uint248\"},{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"}],\"indexed\":false,\"internalType\":\"struct AuctionInfo\",\"name\":\"_auctionInfo\",\"type\":\"tuple\"}],\"name\":\"MintDetailsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_reserveId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"PassClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_reserveId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"Purchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_reserveId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_refundAmount\",\"type\":\"uint256\"}],\"name\":\"RefundClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_reserveId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"SlotClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_reserveId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_proceeds\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"refunded\",\"type\":\"bool\"},{\"internalType\":\"uint248\",\"name\":\"stepLength\",\"type\":\"uint248\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_reserveId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_reserveId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_indexes\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"_proofs\",\"type\":\"bytes32[][]\"}],\"name\":\"buyAllowlist\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_reserveId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"buyMintPass\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eip712Domain\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"fields\",\"type\":\"bytes1\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifyingContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"extensions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_reserveId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserveNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_claimer\",\"type\":\"address\"}],\"name\":\"generateTypedDataHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getFirstValidReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getLatestUpdate\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_reserveId\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"merkleRoots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"numberMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_reserveId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"refunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reserveNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reserves\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"allocation\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"saleProceeds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"allocation\",\"type\":\"uint128\"}],\"internalType\":\"struct ReserveInfo\",\"name\":\"_reserve\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"_mintDetails\",\"type\":\"bytes\"}],\"name\":\"setMintDetails\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"signingAuthorities\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_reserveId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DutchAuction", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "2", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}