{"SourceCode": "{\"ECVerify.sol\":{\"content\":\"pragma solidity 0.5.8;\\r\\n\\r\\nlibrary ECVerify {\\r\\n\\r\\n    function ecverify(bytes32 hash, bytes memory signature) internal pure returns (address signature_address) {\\r\\n        require(signature.length == 65);\\r\\n\\r\\n        bytes32 r;\\r\\n        bytes32 s;\\r\\n        uint8 v;\\r\\n\\r\\n        // The signature format is a compact form of:\\r\\n        //   {bytes32 r}{bytes32 s}{uint8 v}\\r\\n        // Compact means, uint8 is not padded to 32 bytes.\\r\\n        assembly {\\r\\n            r := mload(add(signature, 32))\\r\\n            s := mload(add(signature, 64))\\r\\n\\r\\n            // Here we are loading the last 32 bytes, including 31 bytes of \\u0027s\\u0027.\\r\\n            v := byte(0, mload(add(signature, 96)))\\r\\n        }\\r\\n\\r\\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible\\r\\n        if (v \\u003c 27) {\\r\\n            v += 27;\\r\\n        }\\r\\n\\r\\n        require(v == 27 || v == 28);\\r\\n\\r\\n        signature_address = ecrecover(hash, v, r, s);\\r\\n\\r\\n        // ecrecover returns zero on error\\r\\n        require(signature_address != address(0x0));\\r\\n\\r\\n        return signature_address;\\r\\n    }\\r\\n}\\r\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity 0.5.8;\\r\\n\\r\\n\\r\\nimport \\u0027./ERC20Basic.sol\\u0027;\\r\\n\\r\\n\\r\\n/**\\r\\n * @title ERC20 interface\\r\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\r\\n */\\r\\ncontract ERC20 is ERC20Basic {\\r\\n  function allowance(address owner, address spender) public view returns (uint256);\\r\\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\\r\\n  function approve(address spender, uint256 value) public returns (bool);\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"},\"ERC20Basic.sol\":{\"content\":\"pragma solidity 0.5.8;\\r\\n\\r\\n\\r\\n/**\\r\\n * @title ERC20Basic\\r\\n * @dev Simpler version of ERC20 interface\\r\\n * @dev see https://github.com/ethereum/EIPs/issues/179\\r\\n */\\r\\ncontract ERC20Basic {\\r\\n  uint256 public totalSupply;\\r\\n  function balanceOf(address who) public view returns (uint256);\\r\\n  function transfer(address to, uint256 value) public returns (bool);\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n}\\r\\n\"},\"Migrations.sol\":{\"content\":\"pragma solidity 0.5.8;\\r\\n\\r\\ncontract Migrations {\\r\\n  address public owner;\\r\\n  uint public last_completed_migration;\\r\\n\\r\\n  modifier restricted() {\\r\\n    if (msg.sender == owner) _;\\r\\n  }\\r\\n\\r\\n  constructor() public {\\r\\n    owner = msg.sender;\\r\\n  }\\r\\n\\r\\n  function setCompleted(uint completed) public restricted {\\r\\n    last_completed_migration = completed;\\r\\n  }\\r\\n\\r\\n  function upgrade(address new_address) public restricted {\\r\\n    Migrations upgraded = Migrations(new_address);\\r\\n    upgraded.setCompleted(last_completed_migration);\\r\\n  }\\r\\n}\\r\\n\"},\"MultiOwners.sol\":{\"content\":\"pragma solidity 0.5.8;\\r\\n\\r\\n\\r\\ncontract MultiOwners {\\r\\n\\r\\n    event AccessGrant(address indexed owner);\\r\\n    event AccessRevoke(address indexed owner);\\r\\n    \\r\\n    mapping(address =\\u003e bool) owners;\\r\\n\\r\\n    constructor() public {\\r\\n        owners[msg.sender] = true;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() { \\r\\n        require(owners[msg.sender] == true);\\r\\n        _; \\r\\n    }\\r\\n\\r\\n    function isOwner() view public returns (bool) {\\r\\n        return owners[msg.sender] ? true : false;\\r\\n    }\\r\\n\\r\\n    function checkOwner(address maybe_owner) view public returns (bool) {\\r\\n        return owners[maybe_owner] ? true : false;\\r\\n    }\\r\\n\\r\\n\\r\\n    function grant(address _owner) public onlyOwner {\\r\\n        owners[_owner] = true;\\r\\n        emit AccessGrant(_owner);\\r\\n    }\\r\\n\\r\\n    function revoke(address _owner) public onlyOwner {\\r\\n        require(msg.sender != _owner);\\r\\n        owners[_owner] = false;\\r\\n        emit AccessRevoke(_owner);\\r\\n    }\\r\\n}\\r\\n\"},\"PrivatixServiceContract.sol\":{\"content\":\"pragma solidity 0.5.8;\\r\\n\\r\\nimport \\u0027./ERC20.sol\\u0027;\\r\\nimport \\u0027./ECVerify.sol\\u0027;\\r\\nimport \\u0027./SafeMath64.sol\\u0027;\\r\\n\\r\\n/// @title Privatix Service Contract.\\r\\ncontract PrivatixServiceContract {\\r\\n    using SafeMath64 for uint64;\\r\\n\\r\\n    /*\\r\\n     *  Data structures\\r\\n     */\\r\\n\\r\\n    // Number of blocks Agent must wait from last popupServiceOffering or from registerServiceOffering before\\r\\n    // he can popupServiceOffering.\\r\\n    uint32 public popup_period;\\r\\n\\r\\n    // Number of blocks to wait from an uncooperativeClose initiated by the Client\\r\\n    // in order to give the Agent a chance to respond with a balance proof\\r\\n    // in case the sender cheats. After the remove period, the sender can settle\\r\\n    // and delete the channel.\\r\\n    uint32 public challenge_period;\\r\\n\\r\\n    // Number of blocks Agent will wait from registerServiceOffering or from last popupServiceOffering before\\r\\n    // he can delete service offering and receive Agent\\u0027s deposit back.\\r\\n    uint32 public remove_period;\\r\\n\\r\\n    // Fee that goes to network_fee_address from each closed channel balance.\\r\\n    uint32 public network_fee;\\r\\n    \\r\\n    // Address where network_fee is transferred.\\r\\n    address public network_fee_address;\\r\\n\\r\\n    // We temporarily limit total token deposits in a channel to 300 PRIX.\\r\\n    // This is just for the bug bounty release, as a safety measure.\\r\\n    uint64 public constant channel_deposit_bugbounty_limit = 10 ** 8 * 300;\\r\\n\\r\\n    ERC20 public token;\\r\\n\\r\\n    mapping (bytes32 =\\u003e Channel) private channels;\\r\\n    mapping (bytes32 =\\u003e ClosingRequest) private closing_requests;\\r\\n    mapping (address =\\u003e uint64) private internal_balances;\\r\\n    mapping(bytes32 =\\u003e ServiceOffering) private service_offering_s;\\r\\n\\r\\n    // 52 bytes\\r\\n    struct ServiceOffering{\\r\\n      uint64 min_deposit;  // bytes8 - Minimum deposit that Client should place to open state channel.\\r\\n      address agent_address; //bytes20 - Address of Agent.\\r\\n      uint16 max_supply; // bytes2 - Maximum supply of services according to service offerings.\\r\\n      uint16 current_supply; // bytes2 - Currently remaining available supply.\\r\\n\\r\\n      // bytes4 - Last block number when service offering was created, popped-up or channel opened.\\r\\n      // If 0 - offering was removed.\\r\\n      uint32 update_block_number;\\r\\n    }\\r\\n\\r\\n    // 28 bytes\\r\\n    struct Channel {\\r\\n        // uint64 is the maximum uint size needed for deposit based on a\\r\\n        // log2(10^8 * 1275455 token totalSupply) = 46.85.\\r\\n        uint64 deposit;\\r\\n\\r\\n        // Block number at which the channel was opened. Used in creating\\r\\n        // a unique identifier for the channel between a sender and receiver.\\r\\n        // Supports creation of multiple channels between the 2 parties and prevents\\r\\n        // replay of messages in later channels.\\r\\n        uint32 open_block_number;\\r\\n    }\\r\\n\\r\\n    // 28 bytes\\r\\n    struct ClosingRequest {\\r\\n        // Number of tokens owed by the Client when closing the channel.\\r\\n        uint64 closing_balance;\\r\\n\\r\\n        // Block number at which the remove period ends, in case it has been initiated.\\r\\n        uint32 settle_block_number;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     *  Events\\r\\n     */\\r\\n\\r\\n    event LogChannelCreated(\\r\\n        address indexed _agent,\\r\\n        address indexed _client,\\r\\n        bytes32 indexed _offering_hash,\\r\\n        uint64 _deposit);\\r\\n    event LogChannelToppedUp(\\r\\n        address indexed _agent,\\r\\n        address indexed _client,\\r\\n        bytes32 indexed _offering_hash,\\r\\n        uint32 _open_block_number,\\r\\n        uint64 _added_deposit);\\r\\n    event LogChannelCloseRequested(\\r\\n        address indexed _agent,\\r\\n        address indexed _client,\\r\\n        bytes32 indexed _offering_hash,\\r\\n        uint32 _open_block_number,\\r\\n        uint64 _balance);\\r\\n    event LogOfferingCreated(\\r\\n        address indexed _agent,\\r\\n        bytes32 indexed _offering_hash,\\r\\n        uint64 indexed _min_deposit,\\r\\n        uint16 _current_supply,\\r\\n        uint8 _source_type,\\r\\n        string _source);\\r\\n    event LogOfferingDeleted(\\r\\n      address indexed _agent,\\r\\n      bytes32 indexed _offering_hash);\\r\\n    event LogOfferingPopedUp(\\r\\n      address indexed _agent,\\r\\n      bytes32 indexed _offering_hash,\\r\\n      uint64 indexed _min_deposit,\\r\\n      uint16 _current_supply,\\r\\n      uint8 _source_type,\\r\\n      string _source);\\r\\n    event LogCooperativeChannelClose(\\r\\n      address indexed _agent,\\r\\n      address indexed _client,\\r\\n      bytes32 indexed _offering_hash,\\r\\n      uint32 _open_block_number,\\r\\n      uint64 _balance);\\r\\n    event LogUnCooperativeChannelClose(\\r\\n      address indexed _agent,\\r\\n      address indexed _client,\\r\\n      bytes32 indexed _offering_hash,\\r\\n      uint32 _open_block_number,\\r\\n      uint64 _balance);\\r\\n\\r\\n    /*\\r\\n     *  Modifiers\\r\\n     */\\r\\n\\r\\n    /*\\r\\n     *  Constructor\\r\\n     */\\r\\n\\r\\n    /// @notice Constructor for creating the Privatix Service Contract.\\r\\n    /// @param _token_address The address of the PTC (Privatix Token Contract)\\r\\n    /// @param _popup_period A fixed number of blocks representing the pop-up period.\\r\\n    /// @param _remove_period A fixed number of blocks representing the remove period.\\r\\n    /// @param _challenge_period A fixed number of blocks representing the challenge period.\\r\\n    /// We enforce a minimum of 500 blocks waiting period.\\r\\n    /// after a sender requests the closing of the channel without the receiver\\u0027s signature.\\r\\n    constructor(\\r\\n      address _token_address,\\r\\n      address _network_fee_address,\\r\\n      uint32 _popup_period,\\r\\n      uint32 _remove_period,\\r\\n      uint32 _challenge_period\\r\\n      ) public {\\r\\n        require(_token_address != address(0x0));\\r\\n        require(addressHasCode(_token_address));\\r\\n        require(_network_fee_address != address(0x0));\\r\\n        require(_remove_period \\u003e= 100);\\r\\n        require(_popup_period \\u003e= 500);\\r\\n        require(_challenge_period \\u003e= 5000);\\r\\n\\r\\n        token = ERC20(_token_address);\\r\\n\\r\\n        // Check if the contract is indeed a token contract\\r\\n        require(token.totalSupply() \\u003e 0);\\r\\n\\r\\n        network_fee_address = _network_fee_address;\\r\\n        popup_period = _popup_period;\\r\\n        remove_period = _remove_period;\\r\\n        challenge_period = _challenge_period;\\r\\n\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     *  External functions\\r\\n     */\\r\\n\\r\\n    /// @notice Creates a new internal balance by transferring from PTC ERC20 token.\\r\\n    /// @param _value Token transfered to internal balance.\\r\\n    function addBalanceERC20(uint64 _value) external {\\r\\n      internal_balances[msg.sender] = internal_balances[msg.sender].add(_value);\\r\\n      // transferFrom deposit from sender to contract\\r\\n      // ! needs prior approval on token contract.\\r\\n      require(token.transferFrom(msg.sender, address(this), _value));\\r\\n    }\\r\\n\\r\\n    /// @notice Transfers tokens from internal balance to PTC ERC20 token.\\r\\n    /// @param _value Token amount to return.\\r\\n    function returnBalanceERC20(uint64 _value) external {\\r\\n      internal_balances[msg.sender] = internal_balances[msg.sender].sub(_value); // test S21\\r\\n      require(token.transfer(msg.sender, _value));\\r\\n    }\\r\\n\\r\\n    /// @notice Returns user internal balance.\\r\\n    function balanceOf(address _address) external view\\r\\n    returns(uint64)\\r\\n    {\\r\\n      return (internal_balances[_address]); // test U1\\r\\n    }\\r\\n\\r\\n    /// @notice Change address where fee is transferred\\r\\n    /// @param  _network_fee_address Address where network_fee is transferred.\\r\\n    function setNetworkFeeAddress(address _network_fee_address) external { // test S24\\r\\n        require(msg.sender == network_fee_address);\\r\\n        network_fee_address = _network_fee_address;\\r\\n    }\\r\\n\\r\\n    /// @notice Change network fee value. It is limited from 0 to 10%.\\r\\n    /// @param  _network_fee Fee that goes to network_fee_address from each closed channel balance.\\r\\n    function setNetworkFee(uint32 _network_fee) external { // test S22\\r\\n        require(msg.sender == network_fee_address);\\r\\n        require(_network_fee \\u003c= 10000); // test S23\\r\\n        network_fee = _network_fee;\\r\\n    }\\r\\n\\r\\n    /// @notice Creates a new channel between `msg.sender` (Client) and Agent and places\\r\\n    /// the `_deposit` tokens from internal_balances to channel.\\r\\n    /// @param _agent_address The address of Agent that receives tokens.\\r\\n    /// @param _offering_hash Service Offering hash that uniquely identifies it.\\r\\n    /// @param _deposit The amount of tokens that the Client escrows.\\r\\n    function createChannel(address _agent_address, bytes32 _offering_hash, uint64 _deposit) external {\\r\\n        require(_deposit \\u003e= service_offering_s[_offering_hash].min_deposit); // test S4\\r\\n        require(internal_balances[msg.sender] \\u003e= _deposit); // test S5\\r\\n\\r\\n        decreaseOfferingSupply(_agent_address, _offering_hash);\\r\\n        createChannelPrivate(msg.sender, _agent_address, _offering_hash, _deposit);\\r\\n        internal_balances[msg.sender] = internal_balances[msg.sender].sub(_deposit); //test S5\\r\\n        emit LogChannelCreated(_agent_address, msg.sender, _offering_hash, _deposit); //test E1\\r\\n    }\\r\\n\\r\\n    /// @notice Increase the channel deposit with `_added_deposit`.\\r\\n    /// @param _agent_address The address of Agent that receives tokens.\\r\\n    /// @param _open_block_number The block number at which a channel between the\\r\\n    /// Client and Agent was created.\\r\\n    /// @param _offering_hash Service Offering hash that uniquely identifies it.\\r\\n    /// @param _added_deposit The added token deposit with which the current deposit is increased.\\r\\n    function topUpChannel(\\r\\n        address _agent_address,\\r\\n        uint32 _open_block_number,\\r\\n        bytes32 _offering_hash,\\r\\n        uint64 _added_deposit)\\r\\n        external\\r\\n    {\\r\\n        updateInternalBalanceStructs(\\r\\n            msg.sender,\\r\\n            _agent_address,\\r\\n            _open_block_number,\\r\\n            _offering_hash,\\r\\n            _added_deposit\\r\\n        );\\r\\n\\r\\n        internal_balances[msg.sender] = internal_balances[msg.sender].sub(_added_deposit);\\r\\n    }\\r\\n\\r\\n    /// @notice Function called by the Client or Agent, with all the needed\\r\\n    /// signatures to close the channel and settle immediately.\\r\\n    /// @param _agent_address The address of Agent that receives tokens.\\r\\n    /// @param _open_block_number The block number at which a channel between the\\r\\n    /// Client and Agent was created.\\r\\n    /// @param _offering_hash Service Offering hash that uniquely identifies it.\\r\\n    /// @param _balance The amount of tokens owed by the Client to the Agent.\\r\\n    /// @param _balance_msg_sig The balance message signed by the Client.\\r\\n    /// @param _closing_sig The Agent\\u0027s signed balance message, containing the Client\\u0027s address.\\r\\n    function cooperativeClose(\\r\\n        address _agent_address,\\r\\n        uint32 _open_block_number,\\r\\n        bytes32 _offering_hash,\\r\\n        uint64 _balance,\\r\\n        bytes calldata _balance_msg_sig,\\r\\n        bytes calldata _closing_sig)\\r\\n        external\\r\\n    {\\r\\n        // Derive Client address from signed balance proof\\r\\n        address sender = extractSignature(_agent_address, _open_block_number, _offering_hash, _balance, _balance_msg_sig, true);\\r\\n\\r\\n        // Derive Agent address from closing signature\\r\\n        address receiver = extractSignature(sender, _open_block_number, _offering_hash, _balance, _closing_sig, false);\\r\\n        require(receiver == _agent_address); // tests S6, I1a-I1f\\r\\n\\r\\n        // Both signatures have been verified and the channel can be settled.\\r\\n        settleChannel(sender, receiver, _open_block_number, _offering_hash, _balance);\\r\\n        emit LogCooperativeChannelClose(receiver, sender, _offering_hash, _open_block_number, _balance); // test E7\\r\\n    }\\r\\n\\r\\n    /// @notice Client requests the closing of the channel and starts the remove period.\\r\\n    /// This can only happen once.\\r\\n    /// @param _agent_address The address of Agent that receives tokens.\\r\\n    /// @param _open_block_number The block number at which a channel between\\r\\n    /// the Client and Agent was created.\\r\\n    /// @param _offering_hash Service Offering hash that uniquely identifies it.\\r\\n    /// @param _balance The amount of tokens owed by the Client to the Agent.\\r\\n    function uncooperativeClose(\\r\\n        address _agent_address,\\r\\n        uint32 _open_block_number,\\r\\n        bytes32 _offering_hash,\\r\\n        uint64 _balance)\\r\\n        external\\r\\n    {\\r\\n        bytes32 key = getKey(msg.sender, _agent_address, _open_block_number, _offering_hash);\\r\\n\\r\\n        require(channels[key].open_block_number \\u003e 0); // test S9\\r\\n        require(closing_requests[key].settle_block_number == 0); // test S10\\r\\n        require(_balance \\u003c= channels[key].deposit); // test S11\\r\\n\\r\\n        // Mark channel as closed\\r\\n        closing_requests[key].settle_block_number = uint32(block.number) + challenge_period;\\r\\n        require(closing_requests[key].settle_block_number \\u003e block.number);\\r\\n        closing_requests[key].closing_balance = _balance;\\r\\n\\r\\n        emit LogChannelCloseRequested(_agent_address, msg.sender, _offering_hash, _open_block_number, _balance); // test E3\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @notice Function called by the Client after the remove period has ended, in order to\\r\\n    /// settle and delete the channel, in case the Agent has not closed the channel himself.\\r\\n    /// @param _agent_address The address of Agent that receives tokens.\\r\\n    /// @param _open_block_number The block number at which a channel between\\r\\n    /// the Client and Agent was created.\\r\\n    /// @param _offering_hash Service Offering hash that uniquely identifies it.\\r\\n    function settle(address _agent_address, uint32 _open_block_number, bytes32 _offering_hash) external {\\r\\n        bytes32 key = getKey(msg.sender, _agent_address, _open_block_number, _offering_hash);\\r\\n\\r\\n        // Make sure an uncooperativeClose has been initiated\\r\\n        require(closing_requests[key].settle_block_number \\u003e 0); // test S7\\r\\n\\r\\n        // Make sure the challenge_period has ended\\r\\n        require(block.number \\u003e closing_requests[key].settle_block_number); // test S8\\r\\n        uint64 balance = closing_requests[key].closing_balance;\\r\\n        settleChannel(msg.sender, _agent_address, _open_block_number, _offering_hash,\\r\\n           closing_requests[key].closing_balance\\r\\n        );\\r\\n\\r\\n        emit LogUnCooperativeChannelClose(_agent_address, msg.sender, _offering_hash,\\r\\n           _open_block_number, balance\\r\\n        ); // test E9\\r\\n    }\\r\\n\\r\\n    /// @notice Function for retrieving information about a channel.\\r\\n    /// @param _client_address The address of Client hat sends tokens.\\r\\n    /// @param _agent_address The address of Agent that receives tokens.\\r\\n    /// @param _open_block_number The block number at which a channel between the\\r\\n    /// Client and Agent was created.\\r\\n    /// @param _offering_hash Service Offering hash that uniquely identifies it.\\r\\n    /// @return Channel information (unique_identifier, deposit, settle_block_number, closing_balance).\\r\\n    function getChannelInfo(\\r\\n        address _client_address,\\r\\n        address _agent_address,\\r\\n        uint32 _open_block_number,\\r\\n        bytes32 _offering_hash)\\r\\n        external\\r\\n        view\\r\\n        returns (uint64, uint32, uint64)\\r\\n    {\\r\\n        bytes32 key = getKey(_client_address, _agent_address, _open_block_number, _offering_hash);\\r\\n\\r\\n        return (\\r\\n            channels[key].deposit,\\r\\n            closing_requests[key].settle_block_number,\\r\\n            closing_requests[key].closing_balance\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function getOfferingInfo(bytes32 offering_hash)\\r\\n        external\\r\\n        view\\r\\n        returns(address, uint64, uint16, uint16, uint32)\\r\\n    {\\r\\n        ServiceOffering memory offering = service_offering_s[offering_hash];\\r\\n        return (offering.agent_address,\\r\\n                offering.min_deposit,\\r\\n                offering.max_supply,\\r\\n                offering.current_supply,\\r\\n                offering.update_block_number\\r\\n        );\\r\\n        // test U2\\r\\n    }\\r\\n\\r\\n\\r\\n    /*\\r\\n     *  Public functions\\r\\n     */\\r\\n\\r\\n    /// @notice Called by Agent to register service offering\\r\\n    /// @param _offering_hash Service Offering hash that uniquely identifies it.\\r\\n    /// @param _min_deposit Minimum deposit that Client should place to open state channel.\\r\\n    /// @param _max_supply Maximum supply of services according to service offerings.\\r\\n    function registerServiceOffering (\\r\\n     bytes32 _offering_hash,\\r\\n     uint64 _min_deposit,\\r\\n     uint16 _max_supply,\\r\\n     uint8 _source_type,\\r\\n     string calldata _source)\\r\\n     external\\r\\n    {\\r\\n      // Service offering not exists, test S2\\r\\n      require(service_offering_s[_offering_hash].update_block_number == 0);\\r\\n\\r\\n      //Agent deposit greater than max allowed, test S1\\r\\n      require(_min_deposit.mul(_max_supply) \\u003c channel_deposit_bugbounty_limit);\\r\\n      require(_min_deposit \\u003e 0); // zero deposit is not allowed, test S3\\r\\n\\r\\n      service_offering_s[_offering_hash] = ServiceOffering(_min_deposit,\\r\\n                                                           msg.sender,\\r\\n                                                           _max_supply,\\r\\n                                                           _max_supply,\\r\\n                                                           uint32(block.number)\\r\\n                                                          );\\r\\n\\r\\n      // Substitute deposit amount for each offering slot from agent\\u0027s internal balance\\r\\n      // Service provider internal balance must be not less then _min_deposit * _max_supply\\r\\n      internal_balances[msg.sender] = internal_balances[msg.sender].sub(_min_deposit.mul(_max_supply)); // test S26\\r\\n\\r\\n      emit LogOfferingCreated(msg.sender, _offering_hash, _min_deposit, _max_supply, _source_type, _source); // test E4\\r\\n    }\\r\\n\\r\\n    /// @notice Called by Agent to permanently deactivate service offering.\\r\\n    /// @param _offering_hash Service Offering hash that uniquely identifies it.\\r\\n    function removeServiceOffering (\\r\\n     bytes32 _offering_hash)\\r\\n     external\\r\\n    {\\r\\n      require(service_offering_s[_offering_hash].update_block_number \\u003e 0); // test S13\\r\\n      // only creator can delete his offering\\r\\n      assert(service_offering_s[_offering_hash].agent_address == msg.sender); // test S14\\r\\n      // At least remove_period blocks were mined after last offering structure update\\r\\n      require(service_offering_s[_offering_hash].update_block_number + remove_period \\u003c block.number); // test S15\\r\\n      // return Agent\\u0027s deposit back to his internal balance\\r\\n      internal_balances[msg.sender] = internal_balances[msg.sender].add(\\r\\n\\r\\n        // it\\u0027s safe because it was checked in registerServiceOffering\\r\\n        service_offering_s[_offering_hash].min_deposit * service_offering_s[_offering_hash].max_supply\\r\\n\\r\\n      );\\r\\n      // this marks offering as deleted\\r\\n      service_offering_s[_offering_hash].update_block_number = 0;\\r\\n\\r\\n      emit LogOfferingDeleted(msg.sender, _offering_hash); // test E5\\r\\n    }\\r\\n\\r\\n    /// @notice Called by Agent to signal that service offering is actual\\r\\n    /// @param _offering_hash Service Offering hash that uniquely identifies it.\\r\\n    function popupServiceOffering (\\r\\n        bytes32 _offering_hash,\\r\\n        uint8 _source_type,\\r\\n        string calldata _source)\\r\\n    external\\r\\n    {\\r\\n      require(service_offering_s[_offering_hash].update_block_number \\u003e 0); // Service offering already exists, test S16\\r\\n      // At least popup_period blocks were mined after last offering structure update\\r\\n      require(service_offering_s[_offering_hash].update_block_number + popup_period \\u003c block.number); // test S16a\\r\\n      require(service_offering_s[_offering_hash].agent_address == msg.sender); // test S17\\r\\n      // require(block.number \\u003e service_offering_s[_offering_hash].update_block_number);\\r\\n\\r\\n      ServiceOffering memory offering = service_offering_s[_offering_hash];\\r\\n      service_offering_s[_offering_hash].update_block_number = uint32(block.number);\\r\\n\\r\\n      emit LogOfferingPopedUp(msg.sender,\\r\\n                              _offering_hash,\\r\\n                              offering.min_deposit,\\r\\n                              offering.current_supply,\\r\\n                              _source_type, _source\\r\\n                             ); // test E8\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the sender address extracted from the balance proof or closing signature.\\r\\n    /// @param _address The address of Agent or Client that receives/sends tokens.\\r\\n    /// @param _open_block_number The block number at which a channel between the\\r\\n    /// Client and Agent was created.\\r\\n    /// @param _offering_hash Service Offering hash that uniquely identifies it.\\r\\n    /// @param _balance The amount of tokens owed by the Client to the Agent.\\r\\n    /// @param _msg_sig The balance message signed by the Client or Agent (depends on _type).\\r\\n    /// @param _type true - extract from BalanceProofSignature signed by Client,\\r\\n    /// false - extract from ClosingSignature signed by Agent\\r\\n    /// @return Address of the balance proof signer.\\r\\n    function extractSignature(\\r\\n        address _address,\\r\\n        uint32 _open_block_number,\\r\\n        bytes32 _offering_hash,\\r\\n        uint64 _balance,\\r\\n        bytes memory _msg_sig,\\r\\n        bool _type)\\r\\n        public\\r\\n        view\\r\\n        returns (address)\\r\\n    {\\r\\n        // The hashed strings should be kept in sync with this function\\u0027s parameters\\r\\n        // (variable names and types).\\r\\n        bytes32 message_hash =\\r\\n        keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\r\\n            keccak256(abi.encodePacked(\\r\\n                _type ? \\u0027Privatix: sender balance proof signature\\u0027 : \\u0027Privatix: receiver closing signature\\u0027,\\r\\n                _address,\\r\\n                _open_block_number,\\r\\n                _offering_hash,\\r\\n                _balance,\\r\\n                address(this)\\r\\n            ))\\r\\n        ));\\r\\n\\r\\n        // Derive address from signature\\r\\n        address signer = ECVerify.ecverify(message_hash, _msg_sig);\\r\\n        return signer;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the unique channel identifier used in the contract.\\r\\n    /// @param _client_address The address of Client that sends tokens.\\r\\n    /// @param _agent_address The address of Agent that receives tokens.\\r\\n    /// @param _open_block_number The block number at which a channel between the\\r\\n    /// Client and Agent was created.\\r\\n    /// @param _offering_hash Service Offering hash that uniquely identifies it.\\r\\n    /// @return Unique channel identifier.\\r\\n    function getKey(\\r\\n        address _client_address,\\r\\n        address _agent_address,\\r\\n        uint32 _open_block_number,\\r\\n        bytes32 _offering_hash)\\r\\n        public\\r\\n        pure\\r\\n        returns (bytes32 data)\\r\\n    {\\r\\n        return keccak256(abi.encodePacked(_client_address, _agent_address, _open_block_number, _offering_hash));\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     *  Private functions\\r\\n     */\\r\\n\\r\\n     /// @notice Increases available service offering supply.\\r\\n     /// @param _agent_address The address of Agent that created service offering.\\r\\n     /// @param _offering_hash Service Offering hash that uniquely identifies it.\\r\\n     /// @return True in both case, when Service Offering still active or already deactivated.\\r\\n     function increaseOfferingSupply(address _agent_address, bytes32 _offering_hash)\\r\\n      private\\r\\n      returns (bool)\\r\\n    {\\r\\n      require(service_offering_s[_offering_hash].current_supply \\u003c service_offering_s[_offering_hash].max_supply);\\r\\n      // Verify that Agent owns this offering\\r\\n      require(service_offering_s[_offering_hash].agent_address == _agent_address);\\r\\n      // saving gas, as no need to update state\\r\\n      if(service_offering_s[_offering_hash].update_block_number == 0) return true;\\r\\n\\r\\n      service_offering_s[_offering_hash].current_supply = service_offering_s[_offering_hash].current_supply+1;\\r\\n\\r\\n      return true;\\r\\n    }\\r\\n\\r\\n    /// @notice Decreases available service offering supply.\\r\\n    /// @param _agent_address The address of Agent that created service offering.\\r\\n    /// @param _offering_hash Service Offering hash that uniquely identifies it.\\r\\n\\r\\n    function decreaseOfferingSupply(address _agent_address, bytes32 _offering_hash)\\r\\n     private\\r\\n   {\\r\\n     require(service_offering_s[_offering_hash].update_block_number \\u003e 0);\\r\\n     require(service_offering_s[_offering_hash].agent_address == _agent_address);\\r\\n     require(service_offering_s[_offering_hash].current_supply \\u003e 0); // test I5\\r\\n\\r\\n     service_offering_s[_offering_hash].current_supply = service_offering_s[_offering_hash].current_supply-1;\\r\\n\\r\\n   }\\r\\n\\r\\n    /// @dev Creates a new channel between a Client and a Agent.\\r\\n    /// @param _client_address The address of Client that sends tokens.\\r\\n    /// @param _agent_address The address of Agent that receives tokens.\\r\\n    /// @param _offering_hash Service Offering hash that uniquely identifies it.\\r\\n    /// @param _deposit The amount of tokens that the Client escrows.\\r\\n    function createChannelPrivate(address _client_address,\\r\\n                                  address _agent_address,\\r\\n                                  bytes32 _offering_hash,\\r\\n                                  uint64 _deposit) private {\\r\\n\\r\\n        require(_deposit \\u003c= channel_deposit_bugbounty_limit);\\r\\n\\r\\n        uint32 open_block_number = uint32(block.number);\\r\\n\\r\\n        // Create unique identifier from sender, receiver and current block number\\r\\n        bytes32 key = getKey(_client_address, _agent_address, open_block_number, _offering_hash);\\r\\n\\r\\n        require(channels[key].deposit == 0);\\r\\n        require(channels[key].open_block_number == 0);\\r\\n        require(closing_requests[key].settle_block_number == 0);\\r\\n\\r\\n        // Store channel information\\r\\n        channels[key] = Channel({deposit: _deposit, open_block_number: open_block_number});\\r\\n    }\\r\\n\\r\\n    /// @dev Updates internal balance Structures when the sender adds tokens to the channel.\\r\\n    /// @param _client_address The address that sends tokens.\\r\\n    /// @param _agent_address The address that receives tokens.\\r\\n    /// @param _open_block_number The block number at which a channel between the\\r\\n    /// sender and receiver was created.\\r\\n    /// @param _offering_hash Service Offering hash that uniquely identifies it.\\r\\n    /// @param _added_deposit The added token deposit with which the current deposit is increased.\\r\\n    function updateInternalBalanceStructs(\\r\\n        address _client_address,\\r\\n        address _agent_address,\\r\\n        uint32 _open_block_number,\\r\\n        bytes32 _offering_hash,\\r\\n        uint64 _added_deposit)\\r\\n        private\\r\\n    {\\r\\n        require(_added_deposit \\u003e 0);\\r\\n        require(_open_block_number \\u003e 0);\\r\\n\\r\\n        bytes32 key = getKey(_client_address, _agent_address, _open_block_number, _offering_hash);\\r\\n\\r\\n        require(channels[key].deposit \\u003e 0);\\r\\n        require(closing_requests[key].settle_block_number == 0);\\r\\n        require(channels[key].deposit + _added_deposit \\u003c= channel_deposit_bugbounty_limit);\\r\\n\\r\\n        channels[key].deposit += _added_deposit;\\r\\n        assert(channels[key].deposit \\u003e _added_deposit);\\r\\n\\r\\n        emit LogChannelToppedUp(_agent_address, _client_address, _offering_hash, _open_block_number, _added_deposit); // test E2\\r\\n    }\\r\\n\\r\\n    /// @dev Deletes the channel and settles by transferring the balance to the Agent\\r\\n    /// and the rest of the deposit back to the Client.\\r\\n    /// @param _client_address The address of Client that sends tokens.\\r\\n    /// @param _agent_address The address of Agent that receives tokens.\\r\\n    /// @param _open_block_number The block number at which a channel between the\\r\\n    /// sender and receiver was created.\\r\\n    /// @param _offering_hash Service Offering hash that uniquely identifies it.\\r\\n    /// @param _balance The amount of tokens owed by the sender to the receiver.\\r\\n    function settleChannel(\\r\\n        address _client_address,\\r\\n        address _agent_address,\\r\\n        uint32 _open_block_number,\\r\\n        bytes32 _offering_hash,\\r\\n        uint64 _balance)\\r\\n        private\\r\\n    {\\r\\n        bytes32 key = getKey(_client_address, _agent_address, _open_block_number, _offering_hash);\\r\\n        Channel memory channel = channels[key];\\r\\n\\r\\n        require(channel.open_block_number \\u003e 0);\\r\\n        require(_balance \\u003c= channel.deposit);\\r\\n\\r\\n        // Remove closed channel structures\\r\\n        // channel.open_block_number will become 0\\r\\n        delete channels[key];\\r\\n        delete closing_requests[key];\\r\\n\\r\\n        require(increaseOfferingSupply(_agent_address, _offering_hash));\\r\\n        // Send _balance to the receiver, as it is always \\u003c= deposit\\r\\n        uint64 fee = 0;\\r\\n        if(network_fee \\u003e 0) {\\r\\n            fee = (_balance/100000)*network_fee; // it\\u0027s safe because network_fee can\\u0027t be more than 10000\\r\\n            internal_balances[network_fee_address] = internal_balances[network_fee_address].add(fee);\\r\\n            _balance -= fee;\\r\\n        }\\r\\n\\r\\n        internal_balances[_agent_address] = internal_balances[_agent_address].add(_balance);\\r\\n\\r\\n        // Send deposit - balance back to Client\\r\\n        internal_balances[_client_address] = internal_balances[_client_address].add(channel.deposit - _balance - fee); // I4 test\\r\\n\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     *  Internal functions\\r\\n     */\\r\\n\\r\\n    /// @dev Check if a contract exists.\\r\\n    /// @param _contract The address of the contract to check for.\\r\\n    /// @return True if a contract exists, false otherwise\\r\\n    function addressHasCode(address _contract) private view returns (bool) {\\r\\n        uint size;\\r\\n        assembly {\\r\\n            size := extcodesize(_contract)\\r\\n        }\\r\\n\\r\\n        return size \\u003e 0;\\r\\n    }\\r\\n}\\r\\n\"},\"SafeMath64.sol\":{\"content\":\"pragma solidity 0.5.8;\\r\\n\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Math operations with safety checks that throw on error\\r\\n */\\r\\nlibrary SafeMath64 {\\r\\n\\r\\n  /**\\r\\n  * @dev Multiplies two numbers, throws on overflow.\\r\\n  */\\r\\n  function mul(uint64 a, uint64 b) internal pure returns (uint64) {\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n    uint64 c = a * b;\\r\\n    assert(c / a == b);\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\r\\n  */\\r\\n  function sub(uint64 a, uint64 b) internal pure returns (uint64) {\\r\\n    assert(b \\u003c= a);\\r\\n    return a - b;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Adds two numbers, throws on overflow.\\r\\n  */\\r\\n  function add(uint64 a, uint64 b) internal pure returns (uint64) {\\r\\n    uint64 c = a + b;\\r\\n    assert(c \\u003e= a);\\r\\n    return c;\\r\\n  }\\r\\n}\\r\\n\"}}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"challenge_period\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint64\"}],\"name\":\"returnBalanceERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_network_fee\",\"type\":\"uint32\"}],\"name\":\"setNetworkFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_agent_address\",\"type\":\"address\"},{\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"name\":\"_offering_hash\",\"type\":\"bytes32\"},{\"name\":\"_balance\",\"type\":\"uint64\"},{\"name\":\"_balance_msg_sig\",\"type\":\"bytes\"},{\"name\":\"_closing_sig\",\"type\":\"bytes\"}],\"name\":\"cooperativeClose\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_agent_address\",\"type\":\"address\"},{\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"name\":\"_offering_hash\",\"type\":\"bytes32\"}],\"name\":\"settle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_client_address\",\"type\":\"address\"},{\"name\":\"_agent_address\",\"type\":\"address\"},{\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"name\":\"_offering_hash\",\"type\":\"bytes32\"}],\"name\":\"getKey\",\"outputs\":[{\"name\":\"data\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_agent_address\",\"type\":\"address\"},{\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"name\":\"_offering_hash\",\"type\":\"bytes32\"},{\"name\":\"_added_deposit\",\"type\":\"uint64\"}],\"name\":\"topUpChannel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_agent_address\",\"type\":\"address\"},{\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"name\":\"_offering_hash\",\"type\":\"bytes32\"},{\"name\":\"_balance\",\"type\":\"uint64\"}],\"name\":\"uncooperativeClose\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_agent_address\",\"type\":\"address\"},{\"name\":\"_offering_hash\",\"type\":\"bytes32\"},{\"name\":\"_deposit\",\"type\":\"uint64\"}],\"name\":\"createChannel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_client_address\",\"type\":\"address\"},{\"name\":\"_agent_address\",\"type\":\"address\"},{\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"name\":\"_offering_hash\",\"type\":\"bytes32\"}],\"name\":\"getChannelInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_network_fee_address\",\"type\":\"address\"}],\"name\":\"setNetworkFeeAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"offering_hash\",\"type\":\"bytes32\"}],\"name\":\"getOfferingInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"uint16\"},{\"name\":\"\",\"type\":\"uint16\"},{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"channel_deposit_bugbounty_limit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"network_fee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"popup_period\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remove_period\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_offering_hash\",\"type\":\"bytes32\"},{\"name\":\"_source_type\",\"type\":\"uint8\"},{\"name\":\"_source\",\"type\":\"string\"}],\"name\":\"popupServiceOffering\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_offering_hash\",\"type\":\"bytes32\"}],\"name\":\"removeServiceOffering\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"name\":\"_offering_hash\",\"type\":\"bytes32\"},{\"name\":\"_balance\",\"type\":\"uint64\"},{\"name\":\"_msg_sig\",\"type\":\"bytes\"},{\"name\":\"_type\",\"type\":\"bool\"}],\"name\":\"extractSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_offering_hash\",\"type\":\"bytes32\"},{\"name\":\"_min_deposit\",\"type\":\"uint64\"},{\"name\":\"_max_supply\",\"type\":\"uint16\"},{\"name\":\"_source_type\",\"type\":\"uint8\"},{\"name\":\"_source\",\"type\":\"string\"}],\"name\":\"registerServiceOffering\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"network_fee_address\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint64\"}],\"name\":\"addBalanceERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token_address\",\"type\":\"address\"},{\"name\":\"_network_fee_address\",\"type\":\"address\"},{\"name\":\"_popup_period\",\"type\":\"uint32\"},{\"name\":\"_remove_period\",\"type\":\"uint32\"},{\"name\":\"_challenge_period\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_agent\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_client\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_offering_hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_deposit\",\"type\":\"uint64\"}],\"name\":\"LogChannelCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_agent\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_client\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_offering_hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"_added_deposit\",\"type\":\"uint64\"}],\"name\":\"LogChannelToppedUp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_agent\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_client\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_offering_hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"_balance\",\"type\":\"uint64\"}],\"name\":\"LogChannelCloseRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_agent\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_offering_hash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_min_deposit\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"_current_supply\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"_source_type\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_source\",\"type\":\"string\"}],\"name\":\"LogOfferingCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_agent\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_offering_hash\",\"type\":\"bytes32\"}],\"name\":\"LogOfferingDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_agent\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_offering_hash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_min_deposit\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"_current_supply\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"_source_type\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_source\",\"type\":\"string\"}],\"name\":\"LogOfferingPopedUp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_agent\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_client\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_offering_hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"_balance\",\"type\":\"uint64\"}],\"name\":\"LogCooperativeChannelClose\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_agent\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_client\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_offering_hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"_balance\",\"type\":\"uint64\"}],\"name\":\"LogUnCooperativeChannelClose\",\"type\":\"event\"}]", "ContractName": "PrivatixServiceContract", "CompilerVersion": "v0.5.8+commit.23d335f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000003adfc4999f77d04c8341bac5f3a76f58dff5b37a000000000000000000000000990b255cf54fec4b866358dd7e2b6e54ef6645c800000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000001388", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://b44bb9526728d3fdb11f5aef95a4ba3924233908b355173ddaba032057c8549e"}