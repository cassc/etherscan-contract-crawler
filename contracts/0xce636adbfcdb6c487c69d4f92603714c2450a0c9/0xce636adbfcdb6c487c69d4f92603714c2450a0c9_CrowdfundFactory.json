{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/crowdfund/CrowdfundFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport { LibRawResult } from \\\"../utils/LibRawResult.sol\\\";\\nimport { Proxy } from \\\"../utils/Proxy.sol\\\";\\nimport { Implementation } from \\\"../utils/Implementation.sol\\\";\\nimport { IGateKeeper } from \\\"../gatekeepers/IGateKeeper.sol\\\";\\n\\nimport { AuctionCrowdfund, AuctionCrowdfundBase } from \\\"./AuctionCrowdfund.sol\\\";\\nimport { BuyCrowdfund } from \\\"./BuyCrowdfund.sol\\\";\\nimport { CollectionBuyCrowdfund } from \\\"./CollectionBuyCrowdfund.sol\\\";\\nimport { RollingAuctionCrowdfund } from \\\"./RollingAuctionCrowdfund.sol\\\";\\nimport { CollectionBatchBuyCrowdfund } from \\\"./CollectionBatchBuyCrowdfund.sol\\\";\\nimport { InitialETHCrowdfund, ETHCrowdfundBase } from \\\"./InitialETHCrowdfund.sol\\\";\\nimport { ReraiseETHCrowdfund } from \\\"./ReraiseETHCrowdfund.sol\\\";\\nimport { MetadataProvider } from \\\"../renderers/MetadataProvider.sol\\\";\\nimport { Party } from \\\"../party/Party.sol\\\";\\n\\n/// @notice Factory used to deploys new proxified `Crowdfund` instances.\\ncontract CrowdfundFactory {\\n    using LibRawResult for bytes;\\n\\n    event BuyCrowdfundCreated(\\n        address indexed creator,\\n        BuyCrowdfund indexed crowdfund,\\n        BuyCrowdfund.BuyCrowdfundOptions opts\\n    );\\n    event AuctionCrowdfundCreated(\\n        address indexed creator,\\n        AuctionCrowdfund indexed crowdfund,\\n        AuctionCrowdfundBase.AuctionCrowdfundOptions opts\\n    );\\n    event CollectionBuyCrowdfundCreated(\\n        address indexed creator,\\n        CollectionBuyCrowdfund indexed crowdfund,\\n        CollectionBuyCrowdfund.CollectionBuyCrowdfundOptions opts\\n    );\\n    event RollingAuctionCrowdfundCreated(\\n        address indexed creator,\\n        RollingAuctionCrowdfund indexed crowdfund,\\n        AuctionCrowdfundBase.AuctionCrowdfundOptions opts,\\n        bytes32 allowedAuctionsMerkleRoot\\n    );\\n    event CollectionBatchBuyCrowdfundCreated(\\n        address indexed creator,\\n        CollectionBatchBuyCrowdfund indexed crowdfund,\\n        CollectionBatchBuyCrowdfund.CollectionBatchBuyCrowdfundOptions opts\\n    );\\n    event InitialETHCrowdfundCreated(\\n        address indexed creator,\\n        InitialETHCrowdfund indexed crowdfund,\\n        Party indexed party,\\n        InitialETHCrowdfund.InitialETHCrowdfundOptions crowdfundOpts,\\n        InitialETHCrowdfund.ETHPartyOptions partyOpts\\n    );\\n    event ReraiseETHCrowdfundCreated(\\n        address indexed creator,\\n        ReraiseETHCrowdfund indexed crowdfund,\\n        ETHCrowdfundBase.ETHCrowdfundOptions opts\\n    );\\n\\n    /// @notice Create a new crowdfund to purchase a specific NFT (i.e., with a\\n    ///         known token ID) listing for a known price.\\n    /// @param crowdfundImpl The implementation contract of the crowdfund to create.\\n    /// @param opts Options used to initialize the crowdfund. These are fixed\\n    ///             and cannot be changed later.\\n    /// @param createGateCallData Encoded calldata used by `createGate()` to\\n    ///                           create the crowdfund if one is specified in `opts`.\\n    function createBuyCrowdfund(\\n        BuyCrowdfund crowdfundImpl,\\n        BuyCrowdfund.BuyCrowdfundOptions memory opts,\\n        bytes memory createGateCallData\\n    ) external payable returns (BuyCrowdfund inst) {\\n        opts.gateKeeperId = _prepareGate(opts.gateKeeper, opts.gateKeeperId, createGateCallData);\\n        inst = BuyCrowdfund(\\n            payable(\\n                new Proxy{ value: msg.value }(\\n                    Implementation(address(crowdfundImpl)),\\n                    abi.encodeCall(BuyCrowdfund.initialize, (opts))\\n                )\\n            )\\n        );\\n        emit BuyCrowdfundCreated(msg.sender, inst, opts);\\n    }\\n\\n    /// @notice Create a new crowdfund to bid on an auction for a specific NFT\\n    ///         (i.e. with a known token ID).\\n    /// @param crowdfundImpl The implementation contract of the crowdfund to create.\\n    /// @param opts Options used to initialize the crowdfund. These are fixed\\n    ///             and cannot be changed later.\\n    /// @param createGateCallData Encoded calldata used by `createGate()` to create\\n    ///                           the crowdfund if one is specified in `opts`.\\n    function createAuctionCrowdfund(\\n        AuctionCrowdfund crowdfundImpl,\\n        AuctionCrowdfundBase.AuctionCrowdfundOptions memory opts,\\n        bytes memory createGateCallData\\n    ) external payable returns (AuctionCrowdfund inst) {\\n        opts.gateKeeperId = _prepareGate(opts.gateKeeper, opts.gateKeeperId, createGateCallData);\\n        inst = AuctionCrowdfund(\\n            payable(\\n                new Proxy{ value: msg.value }(\\n                    Implementation(address(crowdfundImpl)),\\n                    abi.encodeCall(AuctionCrowdfund.initialize, (opts))\\n                )\\n            )\\n        );\\n        emit AuctionCrowdfundCreated(msg.sender, inst, opts);\\n    }\\n\\n    /// @notice Create a new crowdfund to bid on an auctions for an NFT from a collection\\n    ///         on a market (e.g. Nouns).\\n    /// @param crowdfundImpl The implementation contract of the crowdfund to create.\\n    /// @param opts Options used to initialize the crowdfund. These are fixed\\n    ///             and cannot be changed later.\\n    /// @param createGateCallData Encoded calldata used by `createGate()` to create\\n    ///                           the crowdfund if one is specified in `opts`.\\n    function createRollingAuctionCrowdfund(\\n        RollingAuctionCrowdfund crowdfundImpl,\\n        AuctionCrowdfundBase.AuctionCrowdfundOptions memory opts,\\n        bytes32 allowedAuctionsMerkleRoot,\\n        bytes memory createGateCallData\\n    ) external payable returns (RollingAuctionCrowdfund inst) {\\n        opts.gateKeeperId = _prepareGate(opts.gateKeeper, opts.gateKeeperId, createGateCallData);\\n        inst = RollingAuctionCrowdfund(\\n            payable(\\n                new Proxy{ value: msg.value }(\\n                    Implementation(address(crowdfundImpl)),\\n                    abi.encodeCall(\\n                        RollingAuctionCrowdfund.initialize,\\n                        (opts, allowedAuctionsMerkleRoot)\\n                    )\\n                )\\n            )\\n        );\\n        emit RollingAuctionCrowdfundCreated(msg.sender, inst, opts, allowedAuctionsMerkleRoot);\\n    }\\n\\n    /// @notice Create a new crowdfund to purchases any NFT from a collection\\n    ///         (i.e. any token ID) from a collection for a known price.\\n    /// @param opts Options used to initialize the crowdfund. These are fixed\\n    ///             and cannot be changed later.\\n    /// @param createGateCallData Encoded calldata used by `createGate()` to create\\n    ///                           the crowdfund if one is specified in `opts`.\\n    function createCollectionBuyCrowdfund(\\n        CollectionBuyCrowdfund crowdfundImpl,\\n        CollectionBuyCrowdfund.CollectionBuyCrowdfundOptions memory opts,\\n        bytes memory createGateCallData\\n    ) external payable returns (CollectionBuyCrowdfund inst) {\\n        opts.gateKeeperId = _prepareGate(opts.gateKeeper, opts.gateKeeperId, createGateCallData);\\n        inst = CollectionBuyCrowdfund(\\n            payable(\\n                new Proxy{ value: msg.value }(\\n                    Implementation(address(crowdfundImpl)),\\n                    abi.encodeCall(CollectionBuyCrowdfund.initialize, (opts))\\n                )\\n            )\\n        );\\n        emit CollectionBuyCrowdfundCreated(msg.sender, inst, opts);\\n    }\\n\\n    /// @notice Create a new crowdfund to purchase multiple NFTs from a collection\\n    ///         (i.e. any token ID) from a collection for known prices.\\n    /// @param opts Options used to initialize the crowdfund. These are fixed\\n    ///             and cannot be changed later.\\n    /// @param createGateCallData Encoded calldata used by `createGate()` to create\\n    ///                           the crowdfund if one is specified in `opts`.\\n    function createCollectionBatchBuyCrowdfund(\\n        CollectionBatchBuyCrowdfund crowdfundImpl,\\n        CollectionBatchBuyCrowdfund.CollectionBatchBuyCrowdfundOptions memory opts,\\n        bytes memory createGateCallData\\n    ) external payable returns (CollectionBatchBuyCrowdfund inst) {\\n        opts.gateKeeperId = _prepareGate(opts.gateKeeper, opts.gateKeeperId, createGateCallData);\\n        inst = CollectionBatchBuyCrowdfund(\\n            payable(\\n                new Proxy{ value: msg.value }(\\n                    Implementation(address(crowdfundImpl)),\\n                    abi.encodeCall(CollectionBatchBuyCrowdfund.initialize, (opts))\\n                )\\n            )\\n        );\\n        emit CollectionBatchBuyCrowdfundCreated(msg.sender, inst, opts);\\n    }\\n\\n    /// @notice Create a new crowdfund to raise ETH for a new party.\\n    /// @param crowdfundImpl The implementation contract of the crowdfund to create.\\n    /// @param crowdfundOpts Options used to initialize the crowdfund. These are fixed\\n    ///                      and cannot be changed later.\\n    /// @param partyOpts Options used to initialize the party created by the crowdfund.\\n    ///                  These are fixed and cannot be changed later.\\n    /// @param createGateCallData Encoded calldata used by `createGate()` to create\\n    ///                           the crowdfund if one is specified in `opts`.\\n    function createInitialETHCrowdfund(\\n        InitialETHCrowdfund crowdfundImpl,\\n        InitialETHCrowdfund.InitialETHCrowdfundOptions memory crowdfundOpts,\\n        InitialETHCrowdfund.ETHPartyOptions memory partyOpts,\\n        bytes memory createGateCallData\\n    ) external payable returns (InitialETHCrowdfund inst) {\\n        return\\n            createInitialETHCrowdfundWithMetadata(\\n                crowdfundImpl,\\n                crowdfundOpts,\\n                partyOpts,\\n                MetadataProvider(address(0)),\\n                \\\"\\\",\\n                createGateCallData\\n            );\\n    }\\n\\n    /// @notice Create a new crowdfund to raise ETH for a new party.\\n    /// @param crowdfundImpl The implementation contract of the crowdfund to create.\\n    /// @param crowdfundOpts Options used to initialize the crowdfund.\\n    /// @param partyOpts Options used to initialize the party created by the crowdfund.\\n    /// @param customMetadataProvider A custom metadata provider to use for the party.\\n    /// @param customMetadata Custom metadata to use for the party.\\n    /// @param createGateCallData Encoded calldata used by `createGate()` to create\\n    ///                           the crowdfund if one is specified in `opts`.\\n    function createInitialETHCrowdfundWithMetadata(\\n        InitialETHCrowdfund crowdfundImpl,\\n        InitialETHCrowdfund.InitialETHCrowdfundOptions memory crowdfundOpts,\\n        InitialETHCrowdfund.ETHPartyOptions memory partyOpts,\\n        MetadataProvider customMetadataProvider,\\n        bytes memory customMetadata,\\n        bytes memory createGateCallData\\n    ) public payable returns (InitialETHCrowdfund inst) {\\n        crowdfundOpts.gateKeeperId = _prepareGate(\\n            crowdfundOpts.gateKeeper,\\n            crowdfundOpts.gateKeeperId,\\n            createGateCallData\\n        );\\n        inst = InitialETHCrowdfund(\\n            payable(\\n                new Proxy{ value: msg.value }(\\n                    Implementation(address(crowdfundImpl)),\\n                    abi.encodeCall(\\n                        InitialETHCrowdfund.initialize,\\n                        (crowdfundOpts, partyOpts, customMetadataProvider, customMetadata)\\n                    )\\n                )\\n            )\\n        );\\n        emit InitialETHCrowdfundCreated(msg.sender, inst, inst.party(), crowdfundOpts, partyOpts);\\n    }\\n\\n    /// @notice Create a new crowdfund to raise ETH for an existing party.\\n    /// @param crowdfundImpl The implementation contract of the crowdfund to create.\\n    /// @param opts Options used to initialize the crowdfund. These are fixed\\n    ///             and cannot be changed later.\\n    /// @param createGateCallData Encoded calldata used by `createGate()` to create\\n    ///                           the crowdfund if one is specified in `opts`.\\n    function createReraiseETHCrowdfund(\\n        ReraiseETHCrowdfund crowdfundImpl,\\n        ETHCrowdfundBase.ETHCrowdfundOptions memory opts,\\n        bytes memory createGateCallData\\n    ) external payable returns (ReraiseETHCrowdfund inst) {\\n        opts.gateKeeperId = _prepareGate(opts.gateKeeper, opts.gateKeeperId, createGateCallData);\\n        inst = ReraiseETHCrowdfund(\\n            payable(\\n                new Proxy{ value: msg.value }(\\n                    Implementation(address(crowdfundImpl)),\\n                    abi.encodeCall(ReraiseETHCrowdfund.initialize, (opts))\\n                )\\n            )\\n        );\\n        emit ReraiseETHCrowdfundCreated(msg.sender, inst, opts);\\n    }\\n\\n    function _prepareGate(\\n        IGateKeeper gateKeeper,\\n        bytes12 gateKeeperId,\\n        bytes memory createGateCallData\\n    ) private returns (bytes12 newGateKeeperId) {\\n        if (address(gateKeeper) == address(0) || gateKeeperId != bytes12(0)) {\\n            // Using an existing gate on the gatekeeper\\n            // or not using a gate at all.\\n            return gateKeeperId;\\n        }\\n        // Call the gate creation function on the gatekeeper.\\n        (bool s, bytes memory r) = address(gateKeeper).call(createGateCallData);\\n        if (!s) {\\n            r.rawRevert();\\n        }\\n        // Result is always a bytes12.\\n        return abi.decode(r, (bytes12));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/LibRawResult.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nlibrary LibRawResult {\\n    // Revert with the data in `b`.\\n    function rawRevert(bytes memory b) internal pure {\\n        assembly {\\n            revert(add(b, 32), mload(b))\\n        }\\n    }\\n\\n    // Return with the data in `b`.\\n    function rawReturn(bytes memory b) internal pure {\\n        assembly {\\n            return(add(b, 32), mload(b))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"./LibRawResult.sol\\\";\\nimport \\\"./Implementation.sol\\\";\\n\\n/// @notice Base class for all proxy contracts.\\ncontract Proxy {\\n    using LibRawResult for bytes;\\n\\n    /// @notice The address of the implementation contract used by this proxy.\\n    Implementation public immutable IMPL;\\n\\n    // Made `payable` to allow initialized crowdfunds to receive ETH as an\\n    // initial contribution.\\n    constructor(Implementation impl, bytes memory initCallData) payable {\\n        IMPL = impl;\\n        (bool s, bytes memory r) = address(impl).delegatecall(initCallData);\\n        if (!s) {\\n            r.rawRevert();\\n        }\\n    }\\n\\n    // Forward all calls to the implementation.\\n    fallback() external payable {\\n        Implementation impl = IMPL;\\n        assembly {\\n            calldatacopy(0x00, 0x00, calldatasize())\\n            let s := delegatecall(gas(), impl, 0x00, calldatasize(), 0x00, 0)\\n            returndatacopy(0x00, 0x00, returndatasize())\\n            if iszero(s) {\\n                revert(0x00, returndatasize())\\n            }\\n            return(0x00, returndatasize())\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Implementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\n// Base contract for all contracts intended to be delegatecalled into.\\nabstract contract Implementation {\\n    error OnlyDelegateCallError();\\n    error OnlyConstructorError();\\n\\n    address public immutable IMPL;\\n\\n    constructor() {\\n        IMPL = address(this);\\n    }\\n\\n    // Reverts if the current function context is not inside of a delegatecall.\\n    modifier onlyDelegateCall() virtual {\\n        if (address(this) == IMPL) {\\n            revert OnlyDelegateCallError();\\n        }\\n        _;\\n    }\\n\\n    // Reverts if the current function context is not inside of a constructor.\\n    modifier onlyConstructor() {\\n        if (address(this).code.length != 0) {\\n            revert OnlyConstructorError();\\n        }\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gatekeepers/IGateKeeper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\n// Interface for a gatekeeper contract used for private crowdfund instances.\\ninterface IGateKeeper {\\n    /// @notice Check if a participant is eligible to participate in a crowdfund.\\n    /// @param participant The address of the participant.\\n    /// @param id The ID of the gate to eligibility against.\\n    /// @param userData The data used to check eligibility.\\n    /// @return `true` if the participant is allowed to participate, `false` otherwise.\\n    function isAllowed(\\n        address participant,\\n        bytes12 id,\\n        bytes memory userData\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/crowdfund/AuctionCrowdfund.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"./AuctionCrowdfundBase.sol\\\";\\n\\n/// @notice A crowdfund that can repeatedly bid on an auction for a specific NFT\\n///         (i.e. with a known token ID) until it wins.\\ncontract AuctionCrowdfund is AuctionCrowdfundBase {\\n    using LibSafeERC721 for IERC721;\\n    using LibSafeCast for uint256;\\n    using LibRawResult for bytes;\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) AuctionCrowdfundBase(globals) {}\\n\\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\\n    ///         revert if called outside the constructor.\\n    /// @param opts Options used to initialize the crowdfund. These are fixed\\n    ///             and cannot be changed later.\\n    function initialize(AuctionCrowdfundOptions memory opts) external payable onlyConstructor {\\n        AuctionCrowdfundBase._initialize(opts);\\n    }\\n\\n    /// @notice Calls `finalize()` on the market adapter, which will claim the NFT\\n    ///         (if necessary) if the crowdfund won, or recover the bid (if\\n    ///         necessary) if lost. If won, a party will also be created.\\n    /// @param governanceOpts The options used to initialize governance in the\\n    ///                       `Party` instance created if the crowdfund wins.\\n    /// @param proposalEngineOpts The options used to initialize the proposal\\n    ///                           engine in the `Party` instance created if the\\n    ///                           crowdfund wins.\\n    /// @return party_ Address of the `Party` instance created if successful.\\n    function finalize(\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts\\n    ) external onlyDelegateCall returns (Party party_) {\\n        // Check that the auction is still active and has not passed the `expiry` time.\\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n        if (lc != CrowdfundLifecycle.Active && lc != CrowdfundLifecycle.Expired) {\\n            revert WrongLifecycleError(lc);\\n        }\\n\\n        // Finalize the auction if it is not already finalized.\\n        uint96 lastBid_ = lastBid;\\n        _finalizeAuction(lc, market, auctionId, lastBid_);\\n\\n        IERC721 nftContract_ = nftContract;\\n        uint256 nftTokenId_ = nftTokenId;\\n        // Are we now in possession of the NFT?\\n        if (nftContract_.safeOwnerOf(nftTokenId_) == address(this) && lastBid_ != 0) {\\n            // If we placed a bid before then consider it won for that price.\\n            // Create a governance party around the NFT.\\n            party_ = _createParty(\\n                governanceOpts,\\n                proposalEngineOpts,\\n                false,\\n                nftContract_,\\n                nftTokenId_\\n            );\\n            emit Won(lastBid_, party_);\\n        } else {\\n            // Otherwise we lost the auction or the NFT was gifted to us.\\n            // Clear `lastBid` so `_getFinalPrice()` is 0 and people can redeem their\\n            // full contributions when they burn their participation NFTs.\\n            lastBid = 0;\\n            emit Lost();\\n        }\\n        _bidStatus = AuctionCrowdfundStatus.Finalized;\\n\\n        // Notify third-party platforms that the crowdfund NFT metadata has\\n        // updated for all tokens.\\n        emit BatchMetadataUpdate(0, type(uint256).max);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/crowdfund/BuyCrowdfund.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../tokens/IERC721.sol\\\";\\nimport \\\"../party/Party.sol\\\";\\nimport \\\"../utils/LibSafeERC721.sol\\\";\\nimport \\\"../globals/IGlobals.sol\\\";\\nimport \\\"../gatekeepers/IGateKeeper.sol\\\";\\n\\nimport \\\"./BuyCrowdfundBase.sol\\\";\\n\\n/// @notice A crowdfund that purchases a specific NFT (i.e., with a known token\\n///         ID) listing for a known price.\\ncontract BuyCrowdfund is BuyCrowdfundBase {\\n    using LibSafeERC721 for IERC721;\\n    using LibSafeCast for uint256;\\n    using LibRawResult for bytes;\\n\\n    struct BuyCrowdfundOptions {\\n        // The name of the crowdfund.\\n        // This will also carry over to the governance party.\\n        string name;\\n        // The token symbol for both the crowdfund and the governance NFTs.\\n        string symbol;\\n        // Customization preset ID to use for the crowdfund and governance NFTs.\\n        uint256 customizationPresetId;\\n        // The ERC721 contract of the NFT being bought.\\n        IERC721 nftContract;\\n        // ID of the NFT being bought.\\n        uint256 nftTokenId;\\n        // How long this crowdfund has to buy the NFT, in seconds.\\n        uint40 duration;\\n        // Maximum amount this crowdfund will pay for the NFT.\\n        uint96 maximumPrice;\\n        // An address that receives a portion of the final voting power\\n        // when the party transitions into governance.\\n        address payable splitRecipient;\\n        // What percentage (in bps) of the final total voting power `splitRecipient`\\n        // receives.\\n        uint16 splitBps;\\n        // If ETH is attached during deployment, it will be interpreted\\n        // as a contribution. This is who gets credit for that contribution.\\n        address initialContributor;\\n        // If there is an initial contribution, this is who they will delegate their\\n        // voting power to when the crowdfund transitions to governance.\\n        address initialDelegate;\\n        // Minimum amount of ETH that can be contributed to this crowdfund per address.\\n        uint96 minContribution;\\n        // Maximum amount of ETH that can be contributed to this crowdfund per address.\\n        uint96 maxContribution;\\n        // The gatekeeper contract to use (if non-null) to restrict who can\\n        // contribute to this crowdfund. If used, only contributors or hosts can\\n        // call `buy()`.\\n        IGateKeeper gateKeeper;\\n        // The gate ID within the gateKeeper contract to use.\\n        bytes12 gateKeeperId;\\n        // Whether the party is only allowing a host to call `buy()`.\\n        bool onlyHostCanBuy;\\n        // Fixed governance options (i.e. cannot be changed) that the governance\\n        // `Party` will be created with if the crowdfund succeeds.\\n        FixedGovernanceOpts governanceOpts;\\n        // Options for the proposal engine that the governance `Party` will be\\n        // created with if the crowdfund succeeds.\\n        ProposalStorage.ProposalEngineOpts proposalEngineOpts;\\n    }\\n\\n    /// @notice The NFT token ID to buy.\\n    uint256 public nftTokenId;\\n    /// @notice The NFT contract to buy.\\n    IERC721 public nftContract;\\n    /// @notice Whether the party is only allowing a host to call `buy()`.\\n    bool public onlyHostCanBuy;\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) BuyCrowdfundBase(globals) {}\\n\\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\\n    ///         revert if called outside the constructor.\\n    /// @param opts Options used to initialize the crowdfund. These are fixed\\n    ///             and cannot be changed later.\\n    function initialize(BuyCrowdfundOptions memory opts) external payable onlyConstructor {\\n        if (opts.onlyHostCanBuy && opts.governanceOpts.hosts.length == 0) {\\n            revert MissingHostsError();\\n        }\\n        BuyCrowdfundBase._initialize(\\n            BuyCrowdfundBaseOptions({\\n                name: opts.name,\\n                symbol: opts.symbol,\\n                customizationPresetId: opts.customizationPresetId,\\n                duration: opts.duration,\\n                maximumPrice: opts.maximumPrice,\\n                splitRecipient: opts.splitRecipient,\\n                splitBps: opts.splitBps,\\n                initialContributor: opts.initialContributor,\\n                initialDelegate: opts.initialDelegate,\\n                minContribution: opts.minContribution,\\n                maxContribution: opts.maxContribution,\\n                gateKeeper: opts.gateKeeper,\\n                gateKeeperId: opts.gateKeeperId,\\n                governanceOpts: opts.governanceOpts,\\n                proposalEngineOpts: opts.proposalEngineOpts\\n            })\\n        );\\n        onlyHostCanBuy = opts.onlyHostCanBuy;\\n        nftTokenId = opts.nftTokenId;\\n        nftContract = opts.nftContract;\\n    }\\n\\n    /// @notice Execute arbitrary calldata to perform a buy, creating a party\\n    ///         if it successfully buys the NFT.\\n    /// @param callTarget The target contract to call to buy the NFT.\\n    /// @param callValue The amount of ETH to send with the call.\\n    /// @param callData The calldata to execute.\\n    /// @param governanceOpts The options used to initialize governance in the\\n    ///                       `Party` instance created if the buy was successful.\\n    /// @param proposalEngineOpts The options used to initialize the proposal\\n    ///                           engine in the `Party` instance created if the\\n    ///                           crowdfund wins.\\n    /// @param hostIndex If the caller is a host, this is the index of the caller in the\\n    ///                  `governanceOpts.hosts` array.\\n    /// @return party_ Address of the `Party` instance created after its bought.\\n    function buy(\\n        address payable callTarget,\\n        uint96 callValue,\\n        bytes memory callData,\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        uint256 hostIndex\\n    ) external onlyDelegateCall returns (Party party_) {\\n        // This function can be optionally restricted in different ways.\\n        bool isValidatedGovernanceOpts;\\n        if (onlyHostCanBuy) {\\n            // Only a host can call this function.\\n            _assertIsHost(msg.sender, governanceOpts, proposalEngineOpts, hostIndex);\\n            // If _assertIsHost() succeeded, the governance opts were validated.\\n            isValidatedGovernanceOpts = true;\\n        } else if (address(gateKeeper) != address(0)) {\\n            // `onlyHostCanBuy` is false and we are using a gatekeeper.\\n            // Only a contributor can call this function.\\n            _assertIsContributor(msg.sender);\\n        }\\n        {\\n            // Ensure that the crowdfund is still active.\\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n            if (lc != CrowdfundLifecycle.Active) {\\n                revert WrongLifecycleError(lc);\\n            }\\n        }\\n\\n        // Temporarily set to non-zero as a reentrancy guard.\\n        settledPrice = type(uint96).max;\\n\\n        // Buy the NFT and check NFT is owned by the crowdfund.\\n        (bool success, bytes memory revertData) = _buy(\\n            nftContract,\\n            nftTokenId,\\n            callTarget,\\n            callValue,\\n            callData\\n        );\\n\\n        if (!success) {\\n            if (revertData.length > 0) {\\n                revertData.rawRevert();\\n            } else {\\n                revert FailedToBuyNFTError(nftContract, nftTokenId);\\n            }\\n        }\\n\\n        return\\n            _finalize(\\n                nftContract,\\n                nftTokenId,\\n                callValue,\\n                governanceOpts,\\n                proposalEngineOpts,\\n                isValidatedGovernanceOpts\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/crowdfund/CollectionBuyCrowdfund.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../tokens/IERC721.sol\\\";\\nimport \\\"../party/Party.sol\\\";\\nimport \\\"../utils/LibSafeERC721.sol\\\";\\nimport \\\"../utils/LibRawResult.sol\\\";\\nimport \\\"../globals/IGlobals.sol\\\";\\nimport \\\"../gatekeepers/IGateKeeper.sol\\\";\\n\\nimport \\\"./BuyCrowdfundBase.sol\\\";\\n\\n/// @notice A crowdfund that purchases any NFT from a collection (i.e., any\\n///         token ID) from a collection for a known price. Like `BuyCrowdfund`\\n///         but allows any token ID to be bought.\\ncontract CollectionBuyCrowdfund is BuyCrowdfundBase {\\n    using LibSafeERC721 for IERC721;\\n    using LibSafeCast for uint256;\\n    using LibRawResult for bytes;\\n\\n    struct CollectionBuyCrowdfundOptions {\\n        // The name of the crowdfund.\\n        // This will also carry over to the governance party.\\n        string name;\\n        // The token symbol for both the crowdfund and the governance NFTs.\\n        string symbol;\\n        // Customization preset ID to use for the crowdfund and governance NFTs.\\n        uint256 customizationPresetId;\\n        // The ERC721 contract of the NFT being bought.\\n        IERC721 nftContract;\\n        // How long this crowdfund has to buy the NFT, in seconds.\\n        uint40 duration;\\n        // Maximum amount this crowdfund will pay for the NFT.\\n        uint96 maximumPrice;\\n        // An address that receives a portion of the final voting power\\n        // when the party transitions into governance.\\n        address payable splitRecipient;\\n        // What percentage (in bps) of the final total voting power `splitRecipient`\\n        // receives.\\n        uint16 splitBps;\\n        // If ETH is attached during deployment, it will be interpreted\\n        // as a contribution. This is who gets credit for that contribution.\\n        address initialContributor;\\n        // If there is an initial contribution, this is who they will delegate their\\n        // voting power to when the crowdfund transitions to governance.\\n        address initialDelegate;\\n        // Minimum amount of ETH that can be contributed to this crowdfund per address.\\n        uint96 minContribution;\\n        // Maximum amount of ETH that can be contributed to this crowdfund per address.\\n        uint96 maxContribution;\\n        // The gatekeeper contract to use (if non-null) to restrict who can\\n        // contribute to this crowdfund.\\n        IGateKeeper gateKeeper;\\n        // The gate ID within the gateKeeper contract to use.\\n        bytes12 gateKeeperId;\\n        // Fixed governance options (i.e. cannot be changed) that the governance\\n        // `Party` will be created with if the crowdfund succeeds.\\n        FixedGovernanceOpts governanceOpts;\\n        // Options for the proposal engine that the governance `Party` will be\\n        // created with if the crowdfund succeeds.\\n        ProposalStorage.ProposalEngineOpts proposalEngineOpts;\\n    }\\n\\n    /// @notice The NFT contract to buy.\\n    IERC721 public nftContract;\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) BuyCrowdfundBase(globals) {}\\n\\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\\n    ///         revert if called outside the constructor.\\n    /// @param opts Options used to initialize the crowdfund. These are fixed\\n    ///             and cannot be changed later.\\n    function initialize(\\n        CollectionBuyCrowdfundOptions memory opts\\n    ) external payable onlyConstructor {\\n        if (opts.governanceOpts.hosts.length == 0) {\\n            revert MissingHostsError();\\n        }\\n        BuyCrowdfundBase._initialize(\\n            BuyCrowdfundBaseOptions({\\n                name: opts.name,\\n                symbol: opts.symbol,\\n                customizationPresetId: opts.customizationPresetId,\\n                duration: opts.duration,\\n                maximumPrice: opts.maximumPrice,\\n                splitRecipient: opts.splitRecipient,\\n                splitBps: opts.splitBps,\\n                initialContributor: opts.initialContributor,\\n                initialDelegate: opts.initialDelegate,\\n                minContribution: opts.minContribution,\\n                maxContribution: opts.maxContribution,\\n                gateKeeper: opts.gateKeeper,\\n                gateKeeperId: opts.gateKeeperId,\\n                governanceOpts: opts.governanceOpts,\\n                proposalEngineOpts: opts.proposalEngineOpts\\n            })\\n        );\\n        nftContract = opts.nftContract;\\n    }\\n\\n    /// @notice Execute arbitrary calldata to perform a buy, creating a party\\n    ///         if it successfully buys the NFT. Only a host may call this.\\n    /// @param tokenId The token ID of the NFT in the collection to buy.\\n    /// @param callTarget The target contract to call to buy the NFT.\\n    /// @param callValue The amount of ETH to send with the call.\\n    /// @param callData The calldata to execute.\\n    /// @param governanceOpts The options used to initialize governance in the\\n    ///                       `Party` instance created if the buy was successful.\\n    /// @param proposalEngineOpts The options used to initialize the proposal\\n    ///                           engine in the `Party` instance created if the\\n    ///                           crowdfund wins.\\n    /// @param hostIndex This is the index of the caller in the `governanceOpts.hosts` array.\\n    /// @return party_ Address of the `Party` instance created after its bought.\\n    function buy(\\n        uint256 tokenId,\\n        address payable callTarget,\\n        uint96 callValue,\\n        bytes memory callData,\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        uint256 hostIndex\\n    ) external onlyDelegateCall returns (Party party_) {\\n        // This function is always restricted to hosts.\\n        _assertIsHost(msg.sender, governanceOpts, proposalEngineOpts, hostIndex);\\n\\n        {\\n            // Ensure that the crowdfund is still active.\\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n            if (lc != CrowdfundLifecycle.Active) {\\n                revert WrongLifecycleError(lc);\\n            }\\n        }\\n\\n        // Temporarily set to non-zero as a reentrancy guard.\\n        settledPrice = type(uint96).max;\\n\\n        // Buy the NFT and check NFT is owned by the crowdfund.\\n        (bool success, bytes memory revertData) = _buy(\\n            nftContract,\\n            tokenId,\\n            callTarget,\\n            callValue,\\n            callData\\n        );\\n\\n        if (!success) {\\n            if (revertData.length > 0) {\\n                revertData.rawRevert();\\n            } else {\\n                revert FailedToBuyNFTError(nftContract, tokenId);\\n            }\\n        }\\n\\n        return\\n            _finalize(\\n                nftContract,\\n                tokenId,\\n                callValue,\\n                governanceOpts,\\n                proposalEngineOpts,\\n                // If `_assertIsHost()` succeeded, the governance opts were validated.\\n                true\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/crowdfund/RollingAuctionCrowdfund.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Beta Software\\n// http://ipfs.io/ipfs/QmbGX2MFCaMAsMNMugRFND6DtYygRkwkvrqEyTKhTdBLo5\\npragma solidity 0.8.20;\\n\\nimport \\\"openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\n\\nimport \\\"./AuctionCrowdfundBase.sol\\\";\\n\\n/// @notice A crowdfund that can repeatedly bid on auctions for an NFT from a\\n///         specific collection on a specific market (e.g. Nouns) and can\\n///         continue bidding on new auctions until it wins.\\ncontract RollingAuctionCrowdfund is AuctionCrowdfundBase {\\n    using LibSafeERC721 for IERC721;\\n    using LibSafeCast for uint256;\\n    using LibRawResult for bytes;\\n\\n    struct RollOverArgs {\\n        // The `tokenId` of the next NFT to bid on in the next auction.\\n        // Only used if the crowdfund lost the current auction.\\n        uint256 nextNftTokenId;\\n        // The `auctionId` of the the next auction. Only used if the\\n        // crowdfund lost the current auction.\\n        uint256 nextAuctionId;\\n        // The maximum bid the party can place for the next auction.\\n        // Only used if the crowdfund lost the current auction.\\n        uint96 nextMaximumBid;\\n        // The Merkle proof used to verify that `nextAuctionId` and\\n        // `nextNftTokenId` are allowed. Only used if the crowdfund\\n        // lost the current auction.\\n        bytes32[] proof;\\n        // If the caller is a host, this is the index of the caller in the\\n        // `governanceOpts.hosts` array. Only used if the crowdfund lost the\\n        // current auction AND host are allowed to choose any next auction.\\n        uint256 hostIndex;\\n    }\\n\\n    event AuctionUpdated(uint256 nextNftTokenId, uint256 nextAuctionId, uint256 nextMaximumBid);\\n\\n    error BadNextAuctionError();\\n\\n    /// @notice Merkle root of list of allowed next auctions that can be rolled\\n    ///         over to if the current auction loses. Each leaf should be hashed\\n    ///         as `keccak256(abi.encodePacked(auctionId, tokenId)))` where\\n    ///         `auctionId` is the auction ID of the auction to allow and\\n    ///         `tokenId` is the `tokenId` of the NFT being auctioned.\\n    bytes32 public allowedAuctionsMerkleRoot;\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) AuctionCrowdfundBase(globals) {}\\n\\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\\n    ///         revert if called outside the constructor.\\n    /// @param opts Options used to initialize the crowdfund. These are fixed\\n    ///             and cannot be changed later.\\n    /// @param allowedAuctionsMerkleRoot_ Merkle root of list of allowed next\\n    ///                                   auctions that can be rolled over to\\n    ///                                   if the current auction loses.\\n    function initialize(\\n        AuctionCrowdfundBase.AuctionCrowdfundOptions memory opts,\\n        bytes32 allowedAuctionsMerkleRoot_\\n    ) external payable onlyConstructor {\\n        // Initialize the base contract.\\n        AuctionCrowdfundBase._initialize(opts);\\n\\n        // Set the merkle root of allowed auctions.\\n        allowedAuctionsMerkleRoot = allowedAuctionsMerkleRoot_;\\n    }\\n\\n    /// @notice Calls `finalize()` on the market adapter, which will claim the NFT\\n    ///         (if necessary) if we won, or recover our bid (if necessary)\\n    ///         if the crowfund expired and we lost the current auction. If we\\n    ///         lost but the crowdfund has not expired, this will revert. Only\\n    ///         call this to finalize the result of a won or expired crowdfund,\\n    ///         otherwise call `finalizeOrRollOver()`.\\n    /// @param governanceOpts The options used to initialize governance in the\\n    ///                       `Party` instance created if the crowdfund wins.\\n    /// @param proposalEngineOpts The options used to initialize the proposal\\n    ///                           engine in the `Party` instance created if the\\n    ///                           crowdfund wins.\\n    /// @return party_ Address of the `Party` instance created if successful.\\n    function finalize(\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts\\n    ) external onlyDelegateCall returns (Party party_) {\\n        // Empty args because we don't need to roll over to another auction.\\n        RollOverArgs memory args;\\n\\n        // If the crowdfund won, only `governanceOpts` is relevant. The rest are ignored.\\n        return finalizeOrRollOver(args, governanceOpts, proposalEngineOpts);\\n    }\\n\\n    /// @notice Calls `finalize()` on the market adapter, which will claim the NFT\\n    ///         (if necessary) if we won, or recover our bid (if necessary)\\n    ///         if the crowfund expired and we lost. If we lost but the\\n    ///         crowdfund has not expired, it will move on to the next auction\\n    ///         specified (if allowed).\\n    /// @param args Arguments used to roll over to the next auction if the\\n    ///             crowdfund lost the current auction.\\n    /// @param governanceOpts The options used to initialize governance in the\\n    ///                       `Party` instance created if the crowdfund wins.\\n    /// @param proposalEngineOpts The options used to initialize the proposal\\n    ///                           engine in the `Party` instance created if the\\n    ///                           crowdfund wins.\\n    /// @param party_ Address of the `Party` instance created if successful.\\n    function finalizeOrRollOver(\\n        RollOverArgs memory args,\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts\\n    ) public onlyDelegateCall returns (Party party_) {\\n        // Check that the auction is still active and has not passed the `expiry` time.\\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n        if (lc != CrowdfundLifecycle.Active && lc != CrowdfundLifecycle.Expired) {\\n            revert WrongLifecycleError(lc);\\n        }\\n\\n        // Finalize the auction if it is not already finalized.\\n        uint96 lastBid_ = lastBid;\\n        _finalizeAuction(lc, market, auctionId, lastBid_);\\n\\n        IERC721 nftContract_ = nftContract;\\n        uint256 nftTokenId_ = nftTokenId;\\n        // Are we now in possession of the NFT?\\n        if (nftContract_.safeOwnerOf(nftTokenId_) == address(this) && lastBid_ != 0) {\\n            // Create a governance party around the NFT.\\n            party_ = _createParty(\\n                governanceOpts,\\n                proposalEngineOpts,\\n                false,\\n                nftContract,\\n                nftTokenId\\n            );\\n            emit Won(lastBid, party_);\\n            // Notify third-party platforms that the crowdfund NFT metadata has\\n            // updated for all tokens.\\n            emit BatchMetadataUpdate(0, type(uint256).max);\\n\\n            _bidStatus = AuctionCrowdfundStatus.Finalized;\\n        } else if (lc == CrowdfundLifecycle.Expired) {\\n            // Crowdfund expired without NFT; finalize a loss.\\n\\n            // Clear `lastBid` so `_getFinalPrice()` is 0 and people can redeem their\\n            // full contributions when they burn their participation NFTs.\\n            lastBid = 0;\\n            emit Lost();\\n            // Notify third-party platforms that the crowdfund NFT metadata has\\n            // updated for all tokens.\\n            emit BatchMetadataUpdate(0, type(uint256).max);\\n\\n            _bidStatus = AuctionCrowdfundStatus.Finalized;\\n        } else {\\n            // Move on to the next auction if this one has been lost (or, in\\n            // rare cases, if the NFT was acquired for free and funds remain\\n            // unused).\\n\\n            if (allowedAuctionsMerkleRoot != bytes32(0)) {\\n                // Check that the next `auctionId` and `tokenId` for the next\\n                // auction to roll over have been allowed.\\n                if (\\n                    !MerkleProof.verify(\\n                        args.proof,\\n                        allowedAuctionsMerkleRoot,\\n                        // Hash leaf with extra (empty) 32 bytes to prevent a second\\n                        // preimage attack by hashing >64 bytes.\\n                        keccak256(\\n                            abi.encodePacked(bytes32(0), args.nextAuctionId, args.nextNftTokenId)\\n                        )\\n                    )\\n                ) {\\n                    revert BadNextAuctionError();\\n                }\\n            } else {\\n                // Let the host change to any next auction.\\n                _assertIsHost(msg.sender, governanceOpts, proposalEngineOpts, args.hostIndex);\\n            }\\n\\n            // Check that the new auction can be bid on and is valid.\\n            _validateAuction(market, args.nextAuctionId, nftContract, args.nextNftTokenId);\\n\\n            // Check that the next maximum bid is greater than the auction's minimum bid.\\n            uint256 minimumBid = market.getMinimumBid(args.nextAuctionId);\\n            if (args.nextMaximumBid < minimumBid) {\\n                revert MinimumBidExceedsMaximumBidError(minimumBid, args.nextMaximumBid);\\n            }\\n\\n            // Update state for next auction.\\n            nftTokenId = args.nextNftTokenId;\\n            auctionId = args.nextAuctionId;\\n            maximumBid = args.nextMaximumBid;\\n            lastBid = 0;\\n\\n            emit AuctionUpdated(args.nextNftTokenId, args.nextAuctionId, args.nextMaximumBid);\\n\\n            // Change back the auction status from `Busy` to `Active`.\\n            _bidStatus = AuctionCrowdfundStatus.Active;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/crowdfund/CollectionBatchBuyCrowdfund.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Beta Software\\n// http://ipfs.io/ipfs/QmbGX2MFCaMAsMNMugRFND6DtYygRkwkvrqEyTKhTdBLo5\\npragma solidity 0.8.20;\\n\\nimport \\\"../tokens/IERC721.sol\\\";\\nimport \\\"../party/Party.sol\\\";\\nimport \\\"../utils/LibSafeERC721.sol\\\";\\nimport \\\"../globals/IGlobals.sol\\\";\\nimport \\\"../gatekeepers/IGateKeeper.sol\\\";\\nimport \\\"openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\n\\nimport \\\"./BuyCrowdfundBase.sol\\\";\\n\\n/// @notice A highly customizable crowdfund that can be used to buying one or\\n///         many NFTs in batch from a specific collection.\\ncontract CollectionBatchBuyCrowdfund is BuyCrowdfundBase {\\n    using LibSafeERC721 for IERC721;\\n    using LibSafeCast for uint256;\\n    using LibRawResult for bytes;\\n\\n    struct CollectionBatchBuyCrowdfundOptions {\\n        // The name of the crowdfund.\\n        // This will also carry over to the governance party.\\n        string name;\\n        // The token symbol for both the crowdfund and the governance NFTs.\\n        string symbol;\\n        // Customization preset ID to use for the crowdfund and governance NFTs.\\n        uint256 customizationPresetId;\\n        // The ERC721 contract of the NFTs being bought.\\n        IERC721 nftContract;\\n        // The merkle root of the token IDs that can be bought. If null, any\\n        // token ID in the collection can be bought.\\n        bytes32 nftTokenIdsMerkleRoot;\\n        // How long this crowdfund has to buy the NFTs, in seconds.\\n        uint40 duration;\\n        // Maximum amount this crowdfund will pay for an NFT.\\n        uint96 maximumPrice;\\n        // An address that receives a portion of the final voting power\\n        // when the party transitions into governance.\\n        address payable splitRecipient;\\n        // What percentage (in bps) of the final total voting power `splitRecipient`\\n        // receives.\\n        uint16 splitBps;\\n        // If ETH is attached during deployment, it will be interpreted\\n        // as a contribution. This is who gets credit for that contribution.\\n        address initialContributor;\\n        // If there is an initial contribution, this is who they will delegate their\\n        // voting power to when the crowdfund transitions to governance.\\n        address initialDelegate;\\n        // Minimum amount of ETH that can be contributed to this crowdfund per address.\\n        uint96 minContribution;\\n        // Maximum amount of ETH that can be contributed to this crowdfund per address.\\n        uint96 maxContribution;\\n        // The gatekeeper contract to use (if non-null) to restrict who can\\n        // contribute to this crowdfund.\\n        IGateKeeper gateKeeper;\\n        // The gate ID within the gateKeeper contract to use.\\n        bytes12 gateKeeperId;\\n        // Fixed governance options (i.e. cannot be changed) that the governance\\n        // `Party` will be created with if the crowdfund succeeds.\\n        FixedGovernanceOpts governanceOpts;\\n        // Options for the proposal engine that the governance `Party` will be\\n        // created with if the crowdfund succeeds.\\n        ProposalStorage.ProposalEngineOpts proposalEngineOpts;\\n    }\\n\\n    struct BatchBuyArgs {\\n        uint256[] tokenIds;\\n        address payable[] callTargets;\\n        uint96[] callValues;\\n        bytes[] callDatas;\\n        bytes32[][] proofs;\\n        uint256 minTokensBought;\\n        uint256 minTotalEthUsed;\\n        FixedGovernanceOpts governanceOpts;\\n        ProposalStorage.ProposalEngineOpts proposalEngineOpts;\\n        uint256 hostIndex;\\n    }\\n\\n    error NothingBoughtError();\\n    error InvalidMinTokensBoughtError(uint256 minTokensBought);\\n    error InvalidTokenIdError();\\n    error ContributionsSpentForFailedBuyError();\\n    error NotEnoughTokensBoughtError(uint256 tokensBought, uint256 minTokensBought);\\n    error NotEnoughEthUsedError(uint256 ethUsed, uint256 minTotalEthUsed);\\n    error MismatchedCallArgLengthsError();\\n\\n    /// @notice The contract of NFTs to buy.\\n    IERC721 public nftContract;\\n    /// @notice The merkle root of the token IDs that can be bought. If null,\\n    ///         allow any token ID in the collection to be bought.\\n    bytes32 public nftTokenIdsMerkleRoot;\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) BuyCrowdfundBase(globals) {}\\n\\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\\n    ///         revert if called outside the constructor.\\n    /// @param opts Options used to initialize the crowdfund. These are fixed\\n    ///             and cannot be changed later.\\n    function initialize(\\n        CollectionBatchBuyCrowdfundOptions memory opts\\n    ) external payable onlyConstructor {\\n        if (opts.governanceOpts.hosts.length == 0) {\\n            revert MissingHostsError();\\n        }\\n        BuyCrowdfundBase._initialize(\\n            BuyCrowdfundBaseOptions({\\n                name: opts.name,\\n                symbol: opts.symbol,\\n                customizationPresetId: opts.customizationPresetId,\\n                duration: opts.duration,\\n                maximumPrice: opts.maximumPrice,\\n                splitRecipient: opts.splitRecipient,\\n                splitBps: opts.splitBps,\\n                initialContributor: opts.initialContributor,\\n                initialDelegate: opts.initialDelegate,\\n                minContribution: opts.minContribution,\\n                maxContribution: opts.maxContribution,\\n                gateKeeper: opts.gateKeeper,\\n                gateKeeperId: opts.gateKeeperId,\\n                governanceOpts: opts.governanceOpts,\\n                proposalEngineOpts: opts.proposalEngineOpts\\n            })\\n        );\\n        nftContract = opts.nftContract;\\n        nftTokenIdsMerkleRoot = opts.nftTokenIdsMerkleRoot;\\n    }\\n\\n    /// @notice Execute arbitrary calldata to perform a batch buy, creating a party\\n    ///         if it successfully buys the NFT. Only a host may call this.\\n    /// @param args Arguments for the batch buy.\\n    /// @return party_ Address of the `Party` instance created after its bought.\\n    function batchBuy(BatchBuyArgs memory args) external onlyDelegateCall returns (Party party_) {\\n        // This function is restricted to hosts.\\n        _assertIsHost(msg.sender, args.governanceOpts, args.proposalEngineOpts, args.hostIndex);\\n\\n        {\\n            // Ensure that the crowdfund is still active.\\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n            if (lc != CrowdfundLifecycle.Active) {\\n                revert WrongLifecycleError(lc);\\n            }\\n        }\\n\\n        if (args.minTokensBought == 0) {\\n            // Must buy at least one token.\\n            revert InvalidMinTokensBoughtError(0);\\n        }\\n\\n        // Check length of all arg arrays.\\n        if (\\n            args.tokenIds.length != args.callTargets.length ||\\n            args.tokenIds.length != args.callValues.length ||\\n            args.tokenIds.length != args.callDatas.length ||\\n            args.tokenIds.length != args.proofs.length\\n        ) {\\n            revert MismatchedCallArgLengthsError();\\n        }\\n\\n        // Temporarily set to non-zero as a reentrancy guard.\\n        settledPrice = type(uint96).max;\\n\\n        uint96 totalEthUsed;\\n        uint256 tokensBought;\\n        IERC721[] memory tokens = new IERC721[](args.tokenIds.length);\\n        IERC721 token = nftContract;\\n        bytes32 root = nftTokenIdsMerkleRoot;\\n        for (uint256 i; i < args.tokenIds.length; ++i) {\\n            if (root != bytes32(0)) {\\n                // Verify the token ID is in the merkle tree.\\n                _verifyTokenId(args.tokenIds[i], root, args.proofs[i]);\\n            }\\n\\n            // Used to ensure no ETH is spent if the call fails.\\n            uint256 balanceBefore = address(this).balance;\\n\\n            // Execute the call to buy the NFT.\\n            (bool success, bytes memory revertData) = _buy(\\n                token,\\n                args.tokenIds[i],\\n                args.callTargets[i],\\n                args.callValues[i],\\n                args.callDatas[i]\\n            );\\n\\n            if (!success) {\\n                if (args.minTokensBought >= args.tokenIds.length) {\\n                    // If the call failed with revert data, revert with that data.\\n                    if (revertData.length > 0) {\\n                        revertData.rawRevert();\\n                    } else {\\n                        revert FailedToBuyNFTError(token, args.tokenIds[i]);\\n                    }\\n                } else {\\n                    // If the call failed, ensure no ETH was spent and skip this NFT.\\n                    if (address(this).balance != balanceBefore) {\\n                        revert ContributionsSpentForFailedBuyError();\\n                    }\\n\\n                    continue;\\n                }\\n            }\\n\\n            totalEthUsed += args.callValues[i];\\n\\n            ++tokensBought;\\n            tokens[tokensBought - 1] = token;\\n            args.tokenIds[tokensBought - 1] = args.tokenIds[i];\\n        }\\n\\n        // This is to prevent this crowdfund from finalizing a loss if nothing\\n        // was attempted to be bought (ie. `tokenIds` is empty) or all NFTs were\\n        // bought for free.\\n        if (totalEthUsed == 0) revert NothingBoughtError();\\n\\n        // Check number of tokens bought is not less than the minimum.\\n        if (tokensBought < args.minTokensBought) {\\n            revert NotEnoughTokensBoughtError(tokensBought, args.minTokensBought);\\n        }\\n\\n        // Check total ETH used is not less than the minimum.\\n        if (totalEthUsed < args.minTotalEthUsed) {\\n            revert NotEnoughEthUsedError(totalEthUsed, args.minTotalEthUsed);\\n        }\\n\\n        assembly {\\n            // Update length of `tokens`\\n            mstore(tokens, tokensBought)\\n            // Update length of `tokenIds`\\n            mstore(mload(args), tokensBought)\\n        }\\n\\n        return\\n            _finalize(\\n                tokens,\\n                args.tokenIds,\\n                totalEthUsed,\\n                args.governanceOpts,\\n                args.proposalEngineOpts,\\n                // If `_assertIsHost()` succeeded, the governance opts were validated.\\n                true\\n            );\\n    }\\n\\n    function _verifyTokenId(uint256 tokenId, bytes32 root, bytes32[] memory proof) private pure {\\n        bytes32 leaf;\\n        assembly {\\n            mstore(0x00, tokenId)\\n            leaf := keccak256(0x00, 0x20)\\n        }\\n\\n        if (!MerkleProof.verify(proof, root, leaf)) revert InvalidTokenIdError();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/crowdfund/InitialETHCrowdfund.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport { ETHCrowdfundBase } from \\\"./ETHCrowdfundBase.sol\\\";\\nimport { ProposalStorage } from \\\"../proposals/ProposalStorage.sol\\\";\\nimport { LibAddress } from \\\"../utils/LibAddress.sol\\\";\\nimport { LibRawResult } from \\\"../utils/LibRawResult.sol\\\";\\nimport { LibSafeCast } from \\\"../utils/LibSafeCast.sol\\\";\\nimport { Party, PartyGovernance } from \\\"../party/Party.sol\\\";\\nimport { Crowdfund } from \\\"../crowdfund/Crowdfund.sol\\\";\\nimport { MetadataProvider } from \\\"../renderers/MetadataProvider.sol\\\";\\nimport { IGateKeeper } from \\\"../gatekeepers/IGateKeeper.sol\\\";\\nimport { IGlobals } from \\\"../globals/IGlobals.sol\\\";\\nimport { IERC721 } from \\\"../tokens/IERC721.sol\\\";\\n\\n/// @notice A crowdfund for raising the initial funds for new parties.\\n///         Unlike other crowdfunds that are started for the purpose of\\n///         acquiring NFT(s), this crowdfund simply bootstraps a party with\\n///         funds and lets its members coordinate on what to do with it after.\\ncontract InitialETHCrowdfund is ETHCrowdfundBase {\\n    using LibRawResult for bytes;\\n    using LibSafeCast for uint256;\\n    using LibAddress for address payable;\\n\\n    // Options to be passed into `initialize()` when the crowdfund is created.\\n    struct InitialETHCrowdfundOptions {\\n        address payable initialContributor;\\n        address initialDelegate;\\n        uint96 minContribution;\\n        uint96 maxContribution;\\n        bool disableContributingForExistingCard;\\n        uint96 minTotalContributions;\\n        uint96 maxTotalContributions;\\n        uint16 exchangeRateBps;\\n        uint16 fundingSplitBps;\\n        address payable fundingSplitRecipient;\\n        uint40 duration;\\n        IGateKeeper gateKeeper;\\n        bytes12 gateKeeperId;\\n    }\\n\\n    struct ETHPartyOptions {\\n        // Name of the party.\\n        string name;\\n        // Symbol of the party.\\n        string symbol;\\n        // The ID of the customization preset to use for the party card.\\n        uint256 customizationPresetId;\\n        // Options to initialize party governance with.\\n        Crowdfund.FixedGovernanceOpts governanceOpts;\\n        // Options to initialize party proposal engine with.\\n        ProposalStorage.ProposalEngineOpts proposalEngineOpts;\\n        // The tokens that are considered precious by the party.These are\\n        // protected assets and are subject to extra restrictions in proposals\\n        // vs other assets.\\n        IERC721[] preciousTokens;\\n        // The IDs associated with each token in `preciousTokens`.\\n        uint256[] preciousTokenIds;\\n        // The timestamp until which ragequit is enabled.\\n        uint40 rageQuitTimestamp;\\n    }\\n\\n    struct BatchContributeArgs {\\n        // IDs of cards to credit the contributions to. When set to 0, it means\\n        uint256[] tokenIds;\\n        // The address to which voting power will be delegated for all contributions.\\n        address delegate;\\n        // The contribution amounts in wei. The length of this array must be\\n        // equal to the length of `tokenIds`.\\n        uint96[] values;\\n        // The data required to be validated by the `gatekeeper`, if set. If no\\n        // `gatekeeper` is set, this can be empty.\\n        bytes[] gateDatas;\\n    }\\n\\n    struct BatchContributeForArgs {\\n        // IDs of cards to credit the contributions to. When set to 0, it means\\n        // a new one should be minted.\\n        uint256[] tokenIds;\\n        // Addresses of to credit the contributions under. Each contribution\\n        // amount in `values` corresponds to a recipient in this array.\\n        address payable[] recipients;\\n        // The delegate to set for each recipient if they have not delegated\\n        // before.\\n        address[] initialDelegates;\\n        // The contribution amounts in wei. The length of this array must be\\n        // equal to the length of `recipients`.\\n        uint96[] values;\\n        // The data required to be validated by the `gatekeeper`, if set. If no\\n        // `gatekeeper` is set, this can be empty.\\n        bytes[] gateDatas;\\n        // Whether to revert if any individual contribution fails or continue.\\n        bool revertOnFailure;\\n    }\\n\\n    event Refunded(address indexed contributor, uint256 indexed tokenId, uint256 amount);\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) ETHCrowdfundBase(globals) {}\\n\\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\\n    ///         revert if called outside the constructor.\\n    /// @param crowdfundOpts Options to initialize the crowdfund with.\\n    /// @param partyOpts Options to initialize the party with.\\n    /// @param customMetadataProvider Optional provider to use for the party for\\n    ///                               rendering custom metadata.\\n    /// @param customMetadata Optional custom metadata to use for the party.\\n    function initialize(\\n        InitialETHCrowdfundOptions memory crowdfundOpts,\\n        ETHPartyOptions memory partyOpts,\\n        MetadataProvider customMetadataProvider,\\n        bytes memory customMetadata\\n    ) external payable onlyConstructor {\\n        // Create party the initial crowdfund will be for.\\n        Party party_ = _createParty(partyOpts, customMetadataProvider, customMetadata);\\n\\n        // Initialize the crowdfund.\\n        _initialize(\\n            ETHCrowdfundOptions({\\n                party: party_,\\n                initialContributor: crowdfundOpts.initialContributor,\\n                initialDelegate: crowdfundOpts.initialDelegate,\\n                minContribution: crowdfundOpts.minContribution,\\n                maxContribution: crowdfundOpts.maxContribution,\\n                disableContributingForExistingCard: crowdfundOpts\\n                    .disableContributingForExistingCard,\\n                minTotalContributions: crowdfundOpts.minTotalContributions,\\n                maxTotalContributions: crowdfundOpts.maxTotalContributions,\\n                exchangeRateBps: crowdfundOpts.exchangeRateBps,\\n                fundingSplitBps: crowdfundOpts.fundingSplitBps,\\n                fundingSplitRecipient: crowdfundOpts.fundingSplitRecipient,\\n                duration: crowdfundOpts.duration,\\n                gateKeeper: crowdfundOpts.gateKeeper,\\n                gateKeeperId: crowdfundOpts.gateKeeperId\\n            })\\n        );\\n\\n        // If the deployer passed in some ETH during deployment, credit them\\n        // for the initial contribution.\\n        uint96 initialContribution = msg.value.safeCastUint256ToUint96();\\n        if (initialContribution > 0) {\\n            // If this contract has ETH, either passed in during deployment or\\n            // pre-existing, credit it to the `initialContributor`.\\n            _contribute(\\n                crowdfundOpts.initialContributor,\\n                crowdfundOpts.initialDelegate,\\n                initialContribution,\\n                0,\\n                \\\"\\\"\\n            );\\n        }\\n\\n        // Set up gatekeeper after initial contribution (initial always gets in).\\n        gateKeeper = crowdfundOpts.gateKeeper;\\n        gateKeeperId = crowdfundOpts.gateKeeperId;\\n    }\\n\\n    /// @notice Contribute ETH to this crowdfund on behalf of a contributor.\\n    /// @param delegate The address to which voting power will be delegated to\\n    ///                 during the governance phase.\\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\\n    /// @return votingPower The voting power the contributor receives for their\\n    ///                     contribution.\\n    function contribute(\\n        address delegate,\\n        bytes memory gateData\\n    ) public payable onlyDelegateCall returns (uint96 votingPower) {\\n        return\\n            _contribute(\\n                payable(msg.sender),\\n                delegate,\\n                msg.value.safeCastUint256ToUint96(),\\n                0, // Mint a new party card for the contributor.\\n                gateData\\n            );\\n    }\\n\\n    /// @notice Contribute ETH to this crowdfund on behalf of a contributor.\\n    /// @param tokenId The ID of the card the contribution is being made towards.\\n    /// @param delegate The address to which voting power will be delegated to\\n    ///                 during the governance phase.\\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\\n    /// @return votingPower The voting power the contributor receives for their\\n    ///                     contribution.\\n    function contribute(\\n        uint256 tokenId,\\n        address delegate,\\n        bytes memory gateData\\n    ) public payable onlyDelegateCall returns (uint96 votingPower) {\\n        return\\n            _contribute(\\n                payable(msg.sender),\\n                delegate,\\n                msg.value.safeCastUint256ToUint96(),\\n                tokenId,\\n                gateData\\n            );\\n    }\\n\\n    /// @notice `contribute()` in batch form.\\n    ///         May not revert if any individual contribution fails.\\n    /// @param args The arguments to pass to each `contribute()` call.\\n    /// @return votingPowers The voting power received for each contribution.\\n    function batchContribute(\\n        BatchContributeArgs calldata args\\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\\n        uint256 numContributions = args.tokenIds.length;\\n        votingPowers = new uint96[](numContributions);\\n\\n        uint256 ethAvailable = msg.value;\\n        for (uint256 i; i < numContributions; ++i) {\\n            ethAvailable -= args.values[i];\\n\\n            votingPowers[i] = _contribute(\\n                payable(msg.sender),\\n                args.delegate,\\n                args.values[i],\\n                args.tokenIds[i],\\n                args.gateDatas[i]\\n            );\\n        }\\n\\n        // Refund any unused ETH.\\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\\n    }\\n\\n    /// @notice Contribute to this crowdfund on behalf of another address.\\n    /// @param tokenId The ID of the token to credit the contribution to, or\\n    ///                zero to mint a new party card for the recipient\\n    /// @param recipient The address to record the contribution under\\n    /// @param initialDelegate The address to delegate to for the governance\\n    ///                        phase if recipient hasn't delegated\\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility\\n    /// @return votingPower The voting power received for the contribution\\n    function contributeFor(\\n        uint256 tokenId,\\n        address payable recipient,\\n        address initialDelegate,\\n        bytes memory gateData\\n    ) external payable onlyDelegateCall returns (uint96 votingPower) {\\n        return\\n            _contribute(\\n                recipient,\\n                initialDelegate,\\n                msg.value.safeCastUint256ToUint96(),\\n                tokenId,\\n                gateData\\n            );\\n    }\\n\\n    /// @notice `contributeFor()` in batch form.\\n    ///         May not revert if any individual contribution fails.\\n    /// @param args The arguments for the batched `contributeFor()` calls.\\n    /// @return votingPowers The voting power received for each contribution.\\n    function batchContributeFor(\\n        BatchContributeForArgs calldata args\\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\\n        uint256 numContributions = args.recipients.length;\\n        votingPowers = new uint96[](numContributions);\\n\\n        uint256 ethAvailable = msg.value;\\n        for (uint256 i; i < numContributions; ++i) {\\n            (bool s, bytes memory r) = address(this).call{ value: args.values[i] }(\\n                abi.encodeCall(\\n                    this.contributeFor,\\n                    (\\n                        args.tokenIds[i],\\n                        args.recipients[i],\\n                        args.initialDelegates[i],\\n                        args.gateDatas[i]\\n                    )\\n                )\\n            );\\n\\n            if (!s) {\\n                if (args.revertOnFailure) {\\n                    r.rawRevert();\\n                }\\n            } else {\\n                votingPowers[i] = abi.decode(r, (uint96));\\n                ethAvailable -= args.values[i];\\n            }\\n        }\\n\\n        // Refund any unused ETH.\\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\\n    }\\n\\n    function _contribute(\\n        address payable contributor,\\n        address delegate,\\n        uint96 amount,\\n        uint256 tokenId,\\n        bytes memory gateData\\n    ) private returns (uint96 votingPower) {\\n        // Require a non-null delegate.\\n        if (delegate == address(0)) {\\n            revert InvalidDelegateError();\\n        }\\n\\n        // Must not be blocked by gatekeeper.\\n        IGateKeeper _gateKeeper = gateKeeper;\\n        if (_gateKeeper != IGateKeeper(address(0))) {\\n            if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {\\n                revert NotAllowedByGateKeeperError(\\n                    contributor,\\n                    _gateKeeper,\\n                    gateKeeperId,\\n                    gateData\\n                );\\n            }\\n        }\\n\\n        votingPower = _processContribution(contributor, delegate, amount);\\n\\n        // OK to contribute with zero just to update delegate.\\n        if (amount == 0) return 0;\\n\\n        if (tokenId == 0) {\\n            // Mint contributor a new party card.\\n            party.mint(contributor, votingPower, delegate);\\n        } else if (disableContributingForExistingCard) {\\n            revert ContributingForExistingCardDisabledError();\\n        } else if (party.ownerOf(tokenId) == contributor) {\\n            // Increase voting power of contributor's existing party card.\\n            party.addVotingPower(tokenId, votingPower);\\n        } else {\\n            revert NotOwnerError(tokenId);\\n        }\\n    }\\n\\n    /// @notice Refund the owner of a party card and burn it. Only available if\\n    ///         the crowdfund lost. Can be called to refund for self or on\\n    ///         another's behalf.\\n    /// @param tokenId The ID of the party card to refund the owner of then burn.\\n    /// @return amount The amount of ETH refunded to the contributor.\\n    function refund(uint256 tokenId) external returns (uint96 amount) {\\n        // Check crowdfund lifecycle.\\n        {\\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n            if (lc != CrowdfundLifecycle.Lost) {\\n                revert WrongLifecycleError(lc);\\n            }\\n        }\\n\\n        // Get amount to refund.\\n        uint96 votingPower = party.votingPowerByTokenId(tokenId).safeCastUint256ToUint96();\\n        amount = convertVotingPowerToContribution(votingPower);\\n\\n        if (amount > 0) {\\n            // Get contributor to refund.\\n            address payable contributor = payable(party.ownerOf(tokenId));\\n\\n            // Burn contributor's party card.\\n            party.burn(tokenId);\\n\\n            // Refund contributor.\\n            contributor.transferEth(amount);\\n\\n            emit Refunded(contributor, tokenId, amount);\\n        }\\n    }\\n\\n    /// @notice `refund()` in batch form.\\n    ///         May not revert if any individual refund fails.\\n    /// @param tokenIds The IDs of the party cards to burn and refund the owners of.\\n    /// @param revertOnFailure If true, revert if any refund fails.\\n    /// @return amounts The amounts of ETH refunded for each refund.\\n    function batchRefund(\\n        uint256[] calldata tokenIds,\\n        bool revertOnFailure\\n    ) external returns (uint96[] memory amounts) {\\n        uint256 numRefunds = tokenIds.length;\\n        amounts = new uint96[](numRefunds);\\n\\n        for (uint256 i; i < numRefunds; ++i) {\\n            (bool s, bytes memory r) = address(this).call(\\n                abi.encodeCall(this.refund, (tokenIds[i]))\\n            );\\n\\n            if (!s) {\\n                if (revertOnFailure) {\\n                    r.rawRevert();\\n                }\\n            } else {\\n                amounts[i] = abi.decode(r, (uint96));\\n            }\\n        }\\n    }\\n\\n    function _createParty(\\n        ETHPartyOptions memory opts,\\n        MetadataProvider customMetadataProvider,\\n        bytes memory customMetadata\\n    ) private returns (Party) {\\n        address[] memory authorities = new address[](1);\\n        authorities[0] = address(this);\\n\\n        if (address(customMetadataProvider) == address(0)) {\\n            return\\n                opts.governanceOpts.partyFactory.createParty(\\n                    opts.governanceOpts.partyImpl,\\n                    authorities,\\n                    Party.PartyOptions({\\n                        name: opts.name,\\n                        symbol: opts.symbol,\\n                        customizationPresetId: opts.customizationPresetId,\\n                        governance: PartyGovernance.GovernanceOpts({\\n                            hosts: opts.governanceOpts.hosts,\\n                            voteDuration: opts.governanceOpts.voteDuration,\\n                            executionDelay: opts.governanceOpts.executionDelay,\\n                            passThresholdBps: opts.governanceOpts.passThresholdBps,\\n                            totalVotingPower: 0,\\n                            feeBps: opts.governanceOpts.feeBps,\\n                            feeRecipient: opts.governanceOpts.feeRecipient\\n                        }),\\n                        proposalEngine: opts.proposalEngineOpts\\n                    }),\\n                    opts.preciousTokens,\\n                    opts.preciousTokenIds,\\n                    opts.rageQuitTimestamp\\n                );\\n        } else {\\n            return\\n                opts.governanceOpts.partyFactory.createPartyWithMetadata(\\n                    opts.governanceOpts.partyImpl,\\n                    authorities,\\n                    Party.PartyOptions({\\n                        name: opts.name,\\n                        symbol: opts.symbol,\\n                        customizationPresetId: opts.customizationPresetId,\\n                        governance: PartyGovernance.GovernanceOpts({\\n                            hosts: opts.governanceOpts.hosts,\\n                            voteDuration: opts.governanceOpts.voteDuration,\\n                            executionDelay: opts.governanceOpts.executionDelay,\\n                            passThresholdBps: opts.governanceOpts.passThresholdBps,\\n                            totalVotingPower: 0,\\n                            feeBps: opts.governanceOpts.feeBps,\\n                            feeRecipient: opts.governanceOpts.feeRecipient\\n                        }),\\n                        proposalEngine: opts.proposalEngineOpts\\n                    }),\\n                    opts.preciousTokens,\\n                    opts.preciousTokenIds,\\n                    opts.rageQuitTimestamp,\\n                    customMetadataProvider,\\n                    customMetadata\\n                );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/crowdfund/ReraiseETHCrowdfund.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"./ETHCrowdfundBase.sol\\\";\\nimport \\\"../crowdfund/CrowdfundNFT.sol\\\";\\nimport \\\"../utils/LibAddress.sol\\\";\\nimport \\\"../utils/LibRawResult.sol\\\";\\nimport \\\"../utils/LibSafeCast.sol\\\";\\nimport \\\"../party/Party.sol\\\";\\nimport \\\"../globals/IGlobals.sol\\\";\\nimport \\\"../gatekeepers/IGateKeeper.sol\\\";\\n\\n/// @notice A crowdfund for raising additional funds for an existing parties.\\ncontract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {\\n    using LibRawResult for bytes;\\n    using LibSafeCast for uint256;\\n    using LibAddress for address payable;\\n\\n    struct BatchContributeArgs {\\n        // The address to which voting power will be delegated for all contributions.\\n        address delegate;\\n        // The contribution amounts in wei. The length of this array must be\\n        // equal to the length of `tokenIds`.\\n        uint96[] values;\\n        // The data required to be validated by the `gatekeeper`, if set. If no\\n        // `gatekeeper` is set, this can be empty.\\n        bytes[] gateDatas;\\n    }\\n\\n    struct BatchContributeForArgs {\\n        // Addresses of to credit the contributions under. Each contribution\\n        // amount in `values` corresponds to a recipient in this array.\\n        address payable[] recipients;\\n        // The delegate to set for each recipient if they have not delegated\\n        // before.\\n        address[] initialDelegates;\\n        // The contribution amounts in wei. The length of this array must be\\n        // equal to the length of `recipients`.\\n        uint96[] values;\\n        // The data required to be validated by the `gatekeeper`, if set. If no\\n        // `gatekeeper` is set, this can be empty.\\n        bytes[] gateDatas;\\n        // Whether to revert if any individual contribution fails or continue.\\n        bool revertOnFailure;\\n    }\\n\\n    event Claimed(address indexed contributor, uint256 indexed tokenId, uint256 votingPower);\\n    event Refunded(address indexed contributor, uint256 amount);\\n\\n    error RemainingVotingPowerAfterClaimError(uint256 remainingVotingPower);\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and it\u2019s address will never change.\\n    IGlobals private immutable _GLOBALS;\\n\\n    /// @notice The amount of voting power that will be received by a\\n    ///         contributor after the crowdfund is won.\\n    mapping(address => uint96) public pendingVotingPower;\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) CrowdfundNFT(globals) ETHCrowdfundBase(globals) {\\n        _GLOBALS = globals;\\n    }\\n\\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\\n    ///         revert if called outside the constructor.\\n    /// @param opts The options to initialize the crowdfund with.\\n    function initialize(ETHCrowdfundOptions memory opts) external payable onlyConstructor {\\n        // Initialize the crowdfund.\\n        ETHCrowdfundBase._initialize(opts);\\n\\n        // Initialize the crowdfund NFT.\\n        _initialize(\\n            opts.party.name(),\\n            opts.party.symbol(),\\n            0 // Ignored. Will use customization preset from party.\\n        );\\n\\n        // If the deployer passed in some ETH during deployment, credit them\\n        // for the initial contribution.\\n        uint96 initialContribution = msg.value.safeCastUint256ToUint96();\\n        if (initialContribution > 0) {\\n            // If this contract has ETH, either passed in during deployment or\\n            // pre-existing, credit it to the `initialContributor`.\\n            _contribute(opts.initialContributor, opts.initialDelegate, initialContribution, \\\"\\\");\\n        }\\n\\n        // Set up gatekeeper after initial contribution (initial always gets in).\\n        gateKeeper = opts.gateKeeper;\\n        gateKeeperId = opts.gateKeeperId;\\n    }\\n\\n    // Initialize name and symbol for crowdfund NFT.\\n    function _initialize(string memory name_, string memory symbol_, uint256) internal override {\\n        name = name_;\\n        symbol = symbol_;\\n\\n        RendererStorage rendererStorage = RendererStorage(\\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE)\\n        );\\n\\n        // Use the same customization preset as the party.\\n        uint256 customizationPresetId = rendererStorage.getPresetFor(address(party));\\n        if (customizationPresetId != 0) {\\n            rendererStorage.useCustomizationPreset(customizationPresetId);\\n        }\\n    }\\n\\n    /// @notice Contribute ETH to this crowdfund on behalf of a contributor.\\n    /// @param delegate The address to which voting power will be delegated to\\n    ///                 during the governance phase.\\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\\n    /// @return votingPower The voting power the contributor receives for their\\n    ///                     contribution.\\n    function contribute(\\n        address delegate,\\n        bytes memory gateData\\n    ) public payable onlyDelegateCall returns (uint96 votingPower) {\\n        return\\n            _contribute(\\n                payable(msg.sender),\\n                delegate,\\n                msg.value.safeCastUint256ToUint96(),\\n                gateData\\n            );\\n    }\\n\\n    /// @notice `contribute()` in batch form.\\n    ///         May not revert if any individual contribution fails.\\n    /// @param args The arguments to pass to each `contribute()` call.\\n    /// @return votingPowers The voting power received for each contribution.\\n    function batchContribute(\\n        BatchContributeArgs calldata args\\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\\n        uint256 numContributions = args.values.length;\\n        votingPowers = new uint96[](numContributions);\\n\\n        uint256 ethAvailable = msg.value;\\n        for (uint256 i; i < numContributions; ++i) {\\n            ethAvailable -= args.values[i];\\n\\n            votingPowers[i] = _contribute(\\n                payable(msg.sender),\\n                args.delegate,\\n                args.values[i],\\n                args.gateDatas[i]\\n            );\\n        }\\n\\n        // Refund any unused ETH.\\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\\n    }\\n\\n    /// @notice Contribute to this crowdfund on behalf of another address.\\n    /// @param recipient The address to record the contribution under\\n    /// @param initialDelegate The address to delegate to for the governance\\n    ///                        phase if recipient hasn't delegated\\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility\\n    /// @return votingPower The voting power received for the contribution\\n    function contributeFor(\\n        address payable recipient,\\n        address initialDelegate,\\n        bytes memory gateData\\n    ) external payable onlyDelegateCall returns (uint96 votingPower) {\\n        return\\n            _contribute(recipient, initialDelegate, msg.value.safeCastUint256ToUint96(), gateData);\\n    }\\n\\n    /// @notice `contributeFor()` in batch form.\\n    ///         May not revert if any individual contribution fails.\\n    /// @param args The arguments for the batched `contributeFor()` calls.\\n    /// @return votingPowers The voting power received for each contribution.\\n    function batchContributeFor(\\n        BatchContributeForArgs memory args\\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\\n        uint256 numContributions = args.recipients.length;\\n        votingPowers = new uint96[](numContributions);\\n\\n        uint256 ethAvailable = msg.value;\\n        for (uint256 i; i < numContributions; ++i) {\\n            (bool s, bytes memory r) = address(this).call{ value: args.values[i] }(\\n                abi.encodeCall(\\n                    this.contributeFor,\\n                    (args.recipients[i], args.initialDelegates[i], args.gateDatas[i])\\n                )\\n            );\\n\\n            if (!s) {\\n                if (args.revertOnFailure) {\\n                    r.rawRevert();\\n                }\\n            } else {\\n                votingPowers[i] = abi.decode(r, (uint96));\\n                ethAvailable -= args.values[i];\\n            }\\n        }\\n\\n        // Refund any unused ETH.\\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\\n    }\\n\\n    function _contribute(\\n        address payable contributor,\\n        address delegate,\\n        uint96 amount,\\n        bytes memory gateData\\n    ) private returns (uint96 votingPower) {\\n        // Require a non-null delegate.\\n        if (delegate == address(0)) {\\n            revert InvalidDelegateError();\\n        }\\n\\n        // Must not be blocked by gatekeeper.\\n        IGateKeeper _gateKeeper = gateKeeper;\\n        if (_gateKeeper != IGateKeeper(address(0))) {\\n            if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {\\n                revert NotAllowedByGateKeeperError(\\n                    contributor,\\n                    _gateKeeper,\\n                    gateKeeperId,\\n                    gateData\\n                );\\n            }\\n        }\\n\\n        votingPower = _processContribution(contributor, delegate, amount);\\n\\n        // OK to contribute with zero just to update delegate.\\n        if (amount == 0) return 0;\\n\\n        uint256 previousVotingPower = pendingVotingPower[contributor];\\n\\n        pendingVotingPower[contributor] += votingPower;\\n\\n        // Mint a crowdfund NFT if this is their first contribution.\\n        if (previousVotingPower == 0) _mint(contributor);\\n    }\\n\\n    /// @notice Claim a party card for a contributor if the crowdfund won. Can be called\\n    ///         to claim for self or on another's behalf.\\n    /// @param contributor The contributor to claim for.\\n    function claim(address contributor) external {\\n        claim(\\n            0, // Mint a new party card.\\n            contributor\\n        );\\n    }\\n\\n    /// @notice Claim a party card for a contributor if the crowdfund won. Can be called\\n    ///         to claim for self or on another's behalf.\\n    /// @param tokenId The ID of the party card to add voting power to. If 0, a\\n    ///                new card will be minted.\\n    /// @param contributor The contributor to claim for.\\n    function claim(uint256 tokenId, address contributor) public {\\n        // Check crowdfund lifecycle.\\n        {\\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n            if (lc != CrowdfundLifecycle.Finalized) {\\n                revert WrongLifecycleError(lc);\\n            }\\n        }\\n\\n        uint96 votingPower = pendingVotingPower[contributor];\\n\\n        if (votingPower == 0) return;\\n\\n        {\\n            uint96 contribution = convertVotingPowerToContribution(votingPower);\\n            uint96 maxContribution_ = maxContribution;\\n            // Check that the contribution equivalent of total pending voting\\n            // power is not above the max contribution range. This can happen\\n            // for contributors who contributed multiple times In this case, the\\n            // `claimMultiple` function should be called instead. This is done\\n            // so parties may use the minimum and maximum contribution values to\\n            // limit the voting power of each card (e.g.  a party desiring a \\\"1\\n            // card = 1 vote\\\"-like governance system where each card has equal\\n            // voting power).\\n            if (contribution > maxContribution_) {\\n                revert AboveMaximumContributionsError(contribution, maxContribution_);\\n            }\\n        }\\n\\n        // Burn the crowdfund NFT.\\n        _burn(contributor);\\n\\n        delete pendingVotingPower[contributor];\\n\\n        if (tokenId == 0) {\\n            // Mint contributor a new party card.\\n            tokenId = party.mint(contributor, votingPower, delegationsByContributor[contributor]);\\n        } else if (disableContributingForExistingCard) {\\n            revert ContributingForExistingCardDisabledError();\\n        } else if (party.ownerOf(tokenId) == contributor) {\\n            // Increase voting power of contributor's existing party card.\\n            party.addVotingPower(tokenId, votingPower);\\n        } else {\\n            revert NotOwnerError(tokenId);\\n        }\\n\\n        emit Claimed(contributor, tokenId, votingPower);\\n    }\\n\\n    /// @notice `claim()` in batch form.\\n    ///         May not revert if any individual refund fails.\\n    /// @param tokenIds The IDs of the party cards to add voting power to. If 0, a\\n    ///                 new card will be minted.\\n    /// @param contributors The contributors to claim for.\\n    /// @param revertOnFailure If true, reverts if any individual claim fails.\\n    function batchClaim(\\n        uint256[] calldata tokenIds,\\n        address[] calldata contributors,\\n        bool revertOnFailure\\n    ) external {\\n        for (uint256 i; i < contributors.length; ++i) {\\n            (bool s, bytes memory r) = address(this).call(\\n                // Using `abi.encodeWithSignature()` instead of `abi.encodeCall()`\\n                // because `abi.encodeCall()` doesn't support overloaded functions.\\n                abi.encodeWithSignature(\\\"claim(uint256,address)\\\", tokenIds[i], contributors[i])\\n            );\\n            if (revertOnFailure && !s) {\\n                r.rawRevert();\\n            }\\n        }\\n    }\\n\\n    /// @notice Claim multiple party cards for a contributor if the crowdfund won. Can be called\\n    ///         to claim for self or on another's behalf.\\n    /// @param votingPowerByCard The voting power for each card claimed. Must add up to the\\n    ///                          total pending voting power for the contributor.\\n    /// @param tokenIds The IDs of the party cards to add voting power to. If 0,\\n    ///                 a new card will be minted.\\n    /// @param contributor The contributor to claim for.\\n    function claimMultiple(\\n        uint96[] memory votingPowerByCard,\\n        uint256[] memory tokenIds,\\n        address contributor\\n    ) external {\\n        // Check crowdfund lifecycle.\\n        {\\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n            if (lc != CrowdfundLifecycle.Finalized) {\\n                revert WrongLifecycleError(lc);\\n            }\\n        }\\n\\n        uint256 votingPower = pendingVotingPower[contributor];\\n\\n        if (votingPower == 0) return;\\n\\n        // Burn the crowdfund NFT.\\n        _burn(contributor);\\n\\n        delete pendingVotingPower[contributor];\\n\\n        address delegate = delegationsByContributor[contributor];\\n        uint96 minContribution_ = minContribution;\\n        uint96 maxContribution_ = maxContribution;\\n        for (uint256 i; i < votingPowerByCard.length; ++i) {\\n            uint96 votingPowerForCard = votingPowerByCard[i];\\n\\n            if (votingPowerForCard == 0) continue;\\n\\n            // Check that the contribution equivalent of voting power is within\\n            // contribution range. This is done so parties may use the minimum\\n            // and maximum contribution values to limit the voting power of each\\n            // card (e.g. a party desiring a \\\"1 card = 1 vote\\\"-like governance\\n            // system where each card has equal voting power).\\n            uint96 contribution = convertVotingPowerToContribution(votingPowerByCard[i]);\\n            if (contribution < minContribution_) {\\n                revert BelowMinimumContributionsError(contribution, minContribution_);\\n            }\\n\\n            if (contribution > maxContribution_) {\\n                revert AboveMaximumContributionsError(contribution, maxContribution_);\\n            }\\n\\n            votingPower -= votingPowerForCard;\\n\\n            uint256 tokenId = tokenIds[i];\\n            if (tokenId == 0) {\\n                // Mint contributor a new party card.\\n                tokenId = party.mint(contributor, votingPowerForCard, delegate);\\n            } else if (disableContributingForExistingCard) {\\n                revert ContributingForExistingCardDisabledError();\\n            } else if (party.ownerOf(tokenId) == contributor) {\\n                // Increase voting power of contributor's existing party card.\\n                party.addVotingPower(tokenId, votingPowerForCard);\\n            } else {\\n                revert NotOwnerError(tokenId);\\n            }\\n\\n            emit Claimed(contributor, tokenId, votingPowerForCard);\\n        }\\n\\n        // Requires that all voting power is claimed because the contributor is\\n        // expected to have burned their crowdfund NFT.\\n        if (votingPower != 0) revert RemainingVotingPowerAfterClaimError(votingPower);\\n    }\\n\\n    /// @notice `claimMultiple()` in batch form.\\n    ///         May not revert if any individual refund fails.\\n    /// @param votingPowerByCards The voting power for each card claimed for each\\n    ///                           contributor. Must add up to the total pending\\n    ///                           voting power for the contributor.\\n    /// @param tokenIds The IDs of the party cards to add voting power to for each\\n    ///                 contributor. If 0, a new card will be minted.\\n    /// @param contributors The contributors to claim for.\\n    /// @param revertOnFailure If true, reverts if any individual claim fails.\\n    function batchClaimMultiple(\\n        uint96[][] calldata votingPowerByCards,\\n        uint256[][] calldata tokenIds,\\n        address[] calldata contributors,\\n        bool revertOnFailure\\n    ) external {\\n        for (uint256 i; i < contributors.length; ++i) {\\n            (bool s, bytes memory r) = address(this).call(\\n                abi.encodeCall(\\n                    this.claimMultiple,\\n                    (votingPowerByCards[i], tokenIds[i], contributors[i])\\n                )\\n            );\\n            if (revertOnFailure && !s) {\\n                r.rawRevert();\\n            }\\n        }\\n    }\\n\\n    /// @notice Refund the owner of a party card and burn it. Only available if\\n    ///         the crowdfund lost. Can be called to refund for self or on\\n    ///         another's behalf.\\n    /// @param contributor The contributor to refund.\\n    function refund(address payable contributor) external returns (uint96 amount) {\\n        // Check crowdfund lifecycle.\\n        {\\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n            if (lc != CrowdfundLifecycle.Lost) {\\n                revert WrongLifecycleError(lc);\\n            }\\n        }\\n\\n        // Get amount to refund.\\n        uint96 votingPower = pendingVotingPower[contributor];\\n        amount = convertVotingPowerToContribution(votingPower);\\n\\n        if (amount == 0) return 0;\\n\\n        // Burn the crowdfund NFT.\\n        _burn(contributor);\\n\\n        delete pendingVotingPower[contributor];\\n\\n        // Refund contributor.\\n        contributor.transferEth(amount);\\n\\n        emit Refunded(contributor, amount);\\n    }\\n\\n    /// @notice `refund()` in batch form.\\n    ///         May not revert if any individual refund fails.\\n    /// @param contributors The contributors to refund.\\n    /// @param revertOnFailure If true, revert if any refund fails.\\n    /// @return amounts The amounts of ETH refunded for each refund.\\n    function batchRefund(\\n        address payable[] calldata contributors,\\n        bool revertOnFailure\\n    ) external returns (uint96[] memory amounts) {\\n        uint256 numRefunds = contributors.length;\\n        amounts = new uint96[](numRefunds);\\n\\n        for (uint256 i; i < numRefunds; ++i) {\\n            (bool s, bytes memory r) = address(this).call(\\n                abi.encodeCall(this.refund, (contributors[i]))\\n            );\\n\\n            if (!s) {\\n                if (revertOnFailure) {\\n                    r.rawRevert();\\n                }\\n            } else {\\n                amounts[i] = abi.decode(r, (uint96));\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/renderers/MetadataProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport { Multicall } from \\\"../utils/Multicall.sol\\\";\\nimport { MetadataRegistry } from \\\"./MetadataRegistry.sol\\\";\\nimport { IMetadataProvider } from \\\"./IMetadataProvider.sol\\\";\\nimport { IGlobals } from \\\"../globals/IGlobals.sol\\\";\\nimport { LibGlobals } from \\\"../globals/LibGlobals.sol\\\";\\n\\n/// @notice A contract that provides custom metadata for Party Cards.\\ncontract MetadataProvider is IMetadataProvider, Multicall {\\n    event MetadataSet(address indexed instance, bytes metadata);\\n\\n    error NotAuthorized(address caller, address instance);\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and it\u2019s address will never change.\\n    IGlobals private immutable _GLOBALS;\\n\\n    /// @inheritdoc IMetadataProvider\\n    bool public constant supportsRegistrars = true;\\n\\n    // The metadata for each Party instance.\\n    mapping(address instance => bytes metadata) private _metadata;\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) {\\n        _GLOBALS = globals;\\n    }\\n\\n    /// @inheritdoc IMetadataProvider\\n    function getMetadata(address instance, uint256) external view override returns (bytes memory) {\\n        return _metadata[instance];\\n    }\\n\\n    /// @notice Set the metadata for a Party instance.\\n    /// @param instance The address of the instance.\\n    /// @param metadata The encoded metadata.\\n    function setMetadata(address instance, bytes memory metadata) external {\\n        if (instance != msg.sender) {\\n            MetadataRegistry registry = MetadataRegistry(\\n                _GLOBALS.getAddress(LibGlobals.GLOBAL_METADATA_REGISTRY)\\n            );\\n\\n            // Check if the caller is authorized to set metadata for the instance.\\n            if (!registry.isRegistrar(msg.sender, instance)) {\\n                revert NotAuthorized(msg.sender, instance);\\n            }\\n        }\\n\\n        _metadata[instance] = metadata;\\n\\n        emit MetadataSet(instance, metadata);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/party/Party.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../tokens/IERC721.sol\\\";\\n\\nimport \\\"./PartyGovernanceNFT.sol\\\";\\nimport \\\"./PartyGovernance.sol\\\";\\n\\n/// @notice The governance contract that also custodies the precious NFTs. This\\n///         is also the Governance NFT 721 contract.\\ncontract Party is PartyGovernanceNFT {\\n    // Arguments used to initialize the party.\\n    struct PartyOptions {\\n        PartyGovernance.GovernanceOpts governance;\\n        ProposalStorage.ProposalEngineOpts proposalEngine;\\n        string name;\\n        string symbol;\\n        uint256 customizationPresetId;\\n    }\\n\\n    // Arguments used to initialize the `PartyGovernanceNFT`.\\n    struct PartyInitData {\\n        PartyOptions options;\\n        IERC721[] preciousTokens;\\n        uint256[] preciousTokenIds;\\n        address[] authorities;\\n        uint40 rageQuitTimestamp;\\n    }\\n\\n    /// @notice Version ID of the party implementation contract.\\n    uint16 public constant VERSION_ID = 1;\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) PartyGovernanceNFT(globals) {}\\n\\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\\n    ///         revert if called outside the constructor.\\n    /// @param initData Options used to initialize the party governance.\\n    function initialize(PartyInitData memory initData) external onlyConstructor {\\n        PartyGovernanceNFT._initialize(\\n            initData.options.name,\\n            initData.options.symbol,\\n            initData.options.customizationPresetId,\\n            initData.options.governance,\\n            initData.options.proposalEngine,\\n            initData.preciousTokens,\\n            initData.preciousTokenIds,\\n            initData.authorities,\\n            initData.rageQuitTimestamp\\n        );\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/crowdfund/AuctionCrowdfundBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../tokens/IERC721.sol\\\";\\nimport \\\"../party/Party.sol\\\";\\nimport \\\"../utils/LibSafeERC721.sol\\\";\\nimport \\\"../utils/LibRawResult.sol\\\";\\nimport \\\"../globals/IGlobals.sol\\\";\\nimport \\\"../gatekeepers/IGateKeeper.sol\\\";\\n\\nimport \\\"../market-wrapper/IMarketWrapper.sol\\\";\\nimport \\\"./Crowdfund.sol\\\";\\n\\nabstract contract AuctionCrowdfundBase is Crowdfund {\\n    using LibSafeERC721 for IERC721;\\n    using LibSafeCast for uint256;\\n    using LibRawResult for bytes;\\n\\n    enum AuctionCrowdfundStatus {\\n        // The crowdfund has been created and contributions can be made and\\n        // acquisition functions may be called.\\n        Active,\\n        // A temporary state set by the contract during complex operations to\\n        // act as a reentrancy guard.\\n        Busy,\\n        // The crowdfund is over and has either won or lost.\\n        Finalized\\n    }\\n\\n    struct AuctionCrowdfundOptions {\\n        // The name of the crowdfund.\\n        // This will also carry over to the governance party.\\n        string name;\\n        // The token symbol for both the crowdfund and the governance NFTs.\\n        string symbol;\\n        // Customization preset ID to use for the crowdfund and governance NFTs.\\n        uint256 customizationPresetId;\\n        // The auction ID (specific to the IMarketWrapper).\\n        uint256 auctionId;\\n        // IMarketWrapper contract that handles interactions with auction markets.\\n        IMarketWrapper market;\\n        // The ERC721 contract of the NFT being bought.\\n        IERC721 nftContract;\\n        // ID of the NFT being bought.\\n        uint256 nftTokenId;\\n        // How long this crowdfund has to bid on the NFT, in seconds.\\n        uint40 duration;\\n        // Maximum bid allowed.\\n        uint96 maximumBid;\\n        // An address that receives a portion of the final voting power\\n        // when the party transitions into governance.\\n        address payable splitRecipient;\\n        // What percentage (in bps) of the final total voting power `splitRecipient`\\n        // receives.\\n        uint16 splitBps;\\n        // If ETH is attached during deployment, it will be interpreted\\n        // as a contribution. This is who gets credit for that contribution.\\n        address initialContributor;\\n        // If there is an initial contribution, this is who they will delegate their\\n        // voting power to when the crowdfund transitions to governance.\\n        address initialDelegate;\\n        // Minimum amount of ETH that can be contributed to this crowdfund per address.\\n        uint96 minContribution;\\n        // Maximum amount of ETH that can be contributed to this crowdfund per address.\\n        uint96 maxContribution;\\n        // The gatekeeper contract to use (if non-null) to restrict who can\\n        // contribute to this crowdfund. If used, only contributors or hosts can\\n        // call `bid()`.\\n        IGateKeeper gateKeeper;\\n        // The gate ID within the gateKeeper contract to use.\\n        bytes12 gateKeeperId;\\n        // Whether the party is only allowing a host to call `bid()`.\\n        bool onlyHostCanBid;\\n        // Fixed governance options (i.e. cannot be changed) that the governance\\n        // `Party` will be created with if the crowdfund succeeds.\\n        FixedGovernanceOpts governanceOpts;\\n        // Options for the proposal engine that the governance `Party` will be\\n        // created with if the crowdfund succeeds.\\n        ProposalStorage.ProposalEngineOpts proposalEngineOpts;\\n    }\\n\\n    event Bid(uint256 bidAmount);\\n    event Won(uint256 bid, Party party);\\n    event Lost();\\n\\n    error InvalidAuctionIdError();\\n    error AuctionFinalizedError(uint256 auctionId);\\n    error AlreadyHighestBidderError();\\n    error ExceedsMaximumBidError(uint256 bidAmount, uint256 maximumBid);\\n    error MinimumBidExceedsMaximumBidError(uint256 bidAmount, uint256 maximumBid);\\n    error NoContributionsError();\\n    error AuctionNotExpiredError();\\n\\n    /// @notice The NFT contract to buy.\\n    IERC721 public nftContract;\\n    /// @notice The NFT token ID to buy.\\n    uint256 public nftTokenId;\\n    /// @notice An adapter for the auction market (Zora, OpenSea, etc).\\n    /// @dev This will be delegatecalled into to execute bids.\\n    IMarketWrapper public market;\\n    /// @notice The auction ID to identify the auction on the `market`.\\n    uint256 public auctionId;\\n    /// @notice The maximum possible bid this crowdfund can make.\\n    uint96 public maximumBid;\\n    /// @notice The last successful bid() amount.\\n    uint96 public lastBid;\\n    /// @notice When this crowdfund expires. If the NFT has not been bought\\n    ///         by this time, participants can withdraw their contributions.\\n    uint40 public expiry;\\n    /// @notice Whether the party is only allowing a host to call `bid()`.\\n    bool public onlyHostCanBid;\\n    // Track extra status of the crowdfund specific to bids.\\n    AuctionCrowdfundStatus internal _bidStatus;\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) Crowdfund(globals) {}\\n\\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\\n    ///         revert if called outside the constructor.\\n    /// @param opts Options used to initialize the crowdfund. These are fixed\\n    ///             and cannot be changed later.\\n    function _initialize(AuctionCrowdfundOptions memory opts) internal {\\n        if (opts.onlyHostCanBid && opts.governanceOpts.hosts.length == 0) {\\n            revert MissingHostsError();\\n        }\\n        nftContract = opts.nftContract;\\n        nftTokenId = opts.nftTokenId;\\n        market = opts.market;\\n        expiry = uint40(opts.duration + block.timestamp);\\n        auctionId = opts.auctionId;\\n        maximumBid = opts.maximumBid;\\n        onlyHostCanBid = opts.onlyHostCanBid;\\n        Crowdfund._initialize(\\n            CrowdfundOptions({\\n                name: opts.name,\\n                symbol: opts.symbol,\\n                customizationPresetId: opts.customizationPresetId,\\n                splitRecipient: opts.splitRecipient,\\n                splitBps: opts.splitBps,\\n                initialContributor: opts.initialContributor,\\n                initialDelegate: opts.initialDelegate,\\n                minContribution: opts.minContribution,\\n                maxContribution: opts.maxContribution,\\n                gateKeeper: opts.gateKeeper,\\n                gateKeeperId: opts.gateKeeperId,\\n                governanceOpts: opts.governanceOpts,\\n                proposalEngineOpts: opts.proposalEngineOpts\\n            })\\n        );\\n\\n        // Check that the auction can be bid on and is valid.\\n        _validateAuction(opts.market, opts.auctionId, opts.nftContract, opts.nftTokenId);\\n\\n        // Check that the minimum bid is less than the maximum bid.\\n        uint256 minimumBid = opts.market.getMinimumBid(opts.auctionId);\\n        if (minimumBid > opts.maximumBid) {\\n            revert MinimumBidExceedsMaximumBidError(minimumBid, opts.maximumBid);\\n        }\\n    }\\n\\n    /// @notice Accept ETH, e.g., if an auction needs to return ETH to us.\\n    receive() external payable {}\\n\\n    /// @notice Place a bid on the NFT using the funds in this crowdfund,\\n    ///         placing the minimum possible bid to be the highest bidder, up to\\n    ///         `maximumBid`. Only callable by contributors if `onlyHostCanBid`\\n    ///         is not enabled.\\n    function bid() external {\\n        if (onlyHostCanBid) revert OnlyPartyHostError();\\n\\n        // Bid with the minimum amount to be the highest bidder.\\n        _bid(type(uint96).max);\\n    }\\n\\n    /// @notice Place a bid on the NFT using the funds in this crowdfund,\\n    ///         placing the minimum possible bid to be the highest bidder, up to\\n    ///         `maximumBid`.\\n    /// @param governanceOpts The governance options the crowdfund was created\\n    ///                       with. Only used for crowdfunds where only a host\\n    ///                       can bid to verify the caller is a host.\\n    /// @param proposalEngineOpts The options used to initialize the proposal\\n    ///                           engine in the `Party` instance created if the\\n    ///                           crowdfund wins.\\n    /// @param hostIndex If the caller is a host, this is the index of the caller in the\\n    ///                  `governanceOpts.hosts` array. Only used for crowdfunds where only\\n    ///                  a host can bid to verify the caller is a host.\\n    function bid(\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        uint256 hostIndex\\n    ) external {\\n        // This function can be optionally restricted in different ways.\\n        if (onlyHostCanBid) {\\n            // Only a host can call this function.\\n            _assertIsHost(msg.sender, governanceOpts, proposalEngineOpts, hostIndex);\\n        } else if (address(gateKeeper) != address(0)) {\\n            // `onlyHostCanBid` is false and we are using a gatekeeper.\\n            // Only a contributor can call this function.\\n            _assertIsContributor(msg.sender);\\n        }\\n\\n        // Bid with the minimum amount to be the highest bidder.\\n        _bid(type(uint96).max);\\n    }\\n\\n    /// @notice Place a bid on the NFT using the funds in this crowdfund,\\n    ///         placing a bid, up to `maximumBid`. Only host can call this.\\n    /// @param amount The amount to bid.\\n    /// @param governanceOpts The governance options the crowdfund was created\\n    ///                       with. Used to verify the caller is a host.\\n    /// @param proposalEngineOpts The options used to initialize the proposal\\n    ///                           engine in the `Party` instance created if the\\n    ///                           crowdfund wins.\\n    /// @param hostIndex If the caller is a host, this is the index of the caller in the\\n    ///                  `governanceOpts.hosts` array. Used to verify the caller is a host.\\n    function bid(\\n        uint96 amount,\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        uint256 hostIndex\\n    ) external {\\n        // Only a host can specify a custom bid amount.\\n        _assertIsHost(msg.sender, governanceOpts, proposalEngineOpts, hostIndex);\\n\\n        _bid(amount);\\n    }\\n\\n    function _bid(uint96 amount) private onlyDelegateCall {\\n        // Check that the auction is still active.\\n        {\\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n            if (lc != CrowdfundLifecycle.Active) {\\n                revert WrongLifecycleError(lc);\\n            }\\n        }\\n\\n        // Mark as busy to prevent `burn()`, `bid()`, and `contribute()`\\n        // getting called because this will result in a `CrowdfundLifecycle.Busy`.\\n        _bidStatus = AuctionCrowdfundStatus.Busy;\\n\\n        // Make sure the auction is not finalized.\\n        IMarketWrapper market_ = market;\\n        uint256 auctionId_ = auctionId;\\n        if (market_.isFinalized(auctionId_)) {\\n            revert AuctionFinalizedError(auctionId_);\\n        }\\n\\n        // Only bid if we are not already the highest bidder.\\n        if (market_.getCurrentHighestBidder(auctionId_) == address(this)) {\\n            revert AlreadyHighestBidderError();\\n        }\\n\\n        if (amount == type(uint96).max) {\\n            // Get the minimum necessary bid to be the highest bidder.\\n            amount = market_.getMinimumBid(auctionId_).safeCastUint256ToUint96();\\n        }\\n\\n        // Prevent unaccounted ETH from being used to inflate the bid and\\n        // create \\\"ghost shares\\\" in voting power.\\n        uint96 totalContributions_ = totalContributions;\\n        if (amount > totalContributions_) {\\n            revert ExceedsTotalContributionsError(amount, totalContributions_);\\n        }\\n        // Make sure the bid is less than the maximum bid.\\n        uint96 maximumBid_ = maximumBid;\\n        if (amount > maximumBid_) {\\n            revert ExceedsMaximumBidError(amount, maximumBid_);\\n        }\\n        lastBid = amount;\\n\\n        // No need to check that we have `amount` since this will attempt to\\n        // transfer `amount` ETH to the auction platform.\\n        (bool s, bytes memory r) = address(market_).delegatecall(\\n            abi.encodeCall(IMarketWrapper.bid, (auctionId_, amount))\\n        );\\n        if (!s) {\\n            r.rawRevert();\\n        }\\n        emit Bid(amount);\\n\\n        _bidStatus = AuctionCrowdfundStatus.Active;\\n    }\\n\\n    /// @inheritdoc Crowdfund\\n    function getCrowdfundLifecycle() public view override returns (CrowdfundLifecycle) {\\n        // Do not rely on `market.isFinalized()` in case `auctionId` gets reused.\\n        AuctionCrowdfundStatus status = _bidStatus;\\n        if (status == AuctionCrowdfundStatus.Busy) {\\n            // In the midst of finalizing/bidding (trying to reenter).\\n            return CrowdfundLifecycle.Busy;\\n        }\\n        if (status == AuctionCrowdfundStatus.Finalized) {\\n            return\\n                address(party) != address(0) // If we're fully finalized and we have a party instance then we won.\\n                    ? CrowdfundLifecycle.Won // Otherwise we lost.\\n                    : CrowdfundLifecycle.Lost;\\n        }\\n        if (block.timestamp >= expiry) {\\n            // Expired. `finalize()` needs to be called.\\n            return CrowdfundLifecycle.Expired;\\n        }\\n        return CrowdfundLifecycle.Active;\\n    }\\n\\n    function _getFinalPrice() internal view override returns (uint256 price) {\\n        return lastBid;\\n    }\\n\\n    function _validateAuction(\\n        IMarketWrapper market_,\\n        uint256 auctionId_,\\n        IERC721 nftContract_,\\n        uint256 nftTokenId_\\n    ) internal view {\\n        if (!market_.auctionIdMatchesToken(auctionId_, address(nftContract_), nftTokenId_)) {\\n            revert InvalidAuctionIdError();\\n        }\\n    }\\n\\n    function _finalizeAuction(\\n        CrowdfundLifecycle lc,\\n        IMarketWrapper market_,\\n        uint256 auctionId_,\\n        uint96 lastBid_\\n    ) internal {\\n        // Mark as busy to prevent `burn()`, `bid()`, and `contribute()`\\n        // getting called because this will result in a `CrowdfundLifecycle.Busy`.\\n        _bidStatus = AuctionCrowdfundStatus.Busy;\\n\\n        // If we've bid before or the CF is not expired, finalize the auction.\\n        if (lastBid_ != 0 || lc == CrowdfundLifecycle.Active) {\\n            if (!market_.isFinalized(auctionId_)) {\\n                // If the crowdfund has expired and we are not the highest\\n                // bidder, skip finalization because there is no chance of\\n                // winning the auction.\\n                if (\\n                    lc == CrowdfundLifecycle.Expired &&\\n                    market_.getCurrentHighestBidder(auctionId_) != address(this)\\n                ) return;\\n\\n                (bool s, bytes memory r) = address(market_).call(\\n                    abi.encodeCall(IMarketWrapper.finalize, auctionId_)\\n                );\\n                if (!s) {\\n                    r.rawRevert();\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8;\\n\\n// Minimal ERC721 interface.\\ninterface IERC721 {\\n    event Transfer(address indexed owner, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed operator, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    function approve(address operator, uint256 tokenId) external;\\n\\n    function setApprovalForAll(address operator, bool isApproved) external;\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function getApproved(uint256 tokenId) external view returns (address);\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/LibSafeERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../tokens/IERC721.sol\\\";\\nimport \\\"./LibRawResult.sol\\\";\\n\\nlibrary LibSafeERC721 {\\n    using LibRawResult for bytes;\\n\\n    // Call `IERC721.ownerOf()` without reverting and return `address(0)` if:\\n    // - `tokenID` does not exist.\\n    // - `token` is an EOA\\n    // - `token` is an empty contract\\n    // - `token` is a \\\"bad\\\" implementation of ERC721 that returns nothing for\\n    //   `ownerOf()`\\n    function safeOwnerOf(IERC721 token, uint256 tokenId) internal view returns (address owner) {\\n        (bool s, bytes memory r) = address(token).staticcall(\\n            abi.encodeCall(token.ownerOf, (tokenId))\\n        );\\n\\n        if (!s || r.length < 32) {\\n            return address(0);\\n        }\\n\\n        return abi.decode(r, (address));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/globals/IGlobals.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../utils/Implementation.sol\\\";\\n\\n// Single registry of global values controlled by multisig.\\n// See `LibGlobals` for all valid keys.\\ninterface IGlobals {\\n    function multiSig() external view returns (address);\\n\\n    function getBytes32(uint256 key) external view returns (bytes32);\\n\\n    function getUint256(uint256 key) external view returns (uint256);\\n\\n    function getBool(uint256 key) external view returns (bool);\\n\\n    function getAddress(uint256 key) external view returns (address);\\n\\n    function getImplementation(uint256 key) external view returns (Implementation);\\n\\n    function getIncludesBytes32(uint256 key, bytes32 value) external view returns (bool);\\n\\n    function getIncludesUint256(uint256 key, uint256 value) external view returns (bool);\\n\\n    function getIncludesAddress(uint256 key, address value) external view returns (bool);\\n\\n    function setBytes32(uint256 key, bytes32 value) external;\\n\\n    function setUint256(uint256 key, uint256 value) external;\\n\\n    function setBool(uint256 key, bool value) external;\\n\\n    function setAddress(uint256 key, address value) external;\\n\\n    function setIncludesBytes32(uint256 key, bytes32 value, bool isIncluded) external;\\n\\n    function setIncludesUint256(uint256 key, uint256 value, bool isIncluded) external;\\n\\n    function setIncludesAddress(uint256 key, address value, bool isIncluded) external;\\n}\\n\"\r\n    },\r\n    \"contracts/crowdfund/BuyCrowdfundBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../tokens/IERC721.sol\\\";\\nimport \\\"../party/Party.sol\\\";\\nimport \\\"../utils/LibSafeERC721.sol\\\";\\nimport \\\"../globals/IGlobals.sol\\\";\\nimport \\\"../gatekeepers/IGateKeeper.sol\\\";\\n\\nimport \\\"./Crowdfund.sol\\\";\\n\\n// Base for BuyCrowdfund and CollectionBuyCrowdfund\\nabstract contract BuyCrowdfundBase is Crowdfund {\\n    using LibSafeERC721 for IERC721;\\n    using LibSafeCast for uint256;\\n\\n    struct BuyCrowdfundBaseOptions {\\n        // The name of the crowdfund.\\n        // This will also carry over to the governance party.\\n        string name;\\n        // The token symbol for both the crowdfund and the governance NFTs.\\n        string symbol;\\n        // Customization preset ID to use for the crowdfund and governance NFTs.\\n        uint256 customizationPresetId;\\n        // How long this crowdfund has to buy the NFT, in seconds.\\n        uint40 duration;\\n        // Maximum amount this crowdfund will pay for the NFT.\\n        uint96 maximumPrice;\\n        // An address that receives an extra share of the final voting power\\n        // when the party transitions into governance.\\n        address payable splitRecipient;\\n        // What percentage (in bps) of the final total voting power `splitRecipient`\\n        // receives.\\n        uint16 splitBps;\\n        // If ETH is attached during deployment, it will be interpreted\\n        // as a contribution. This is who gets credit for that contribution.\\n        address initialContributor;\\n        // If there is an initial contribution, this is who they will delegate their\\n        // voting power to when the crowdfund transitions to governance.\\n        address initialDelegate;\\n        // Minimum amount of ETH that can be contributed to this crowdfund per address.\\n        uint96 minContribution;\\n        // Maximum amount of ETH that can be contributed to this crowdfund per address.\\n        uint96 maxContribution;\\n        // The gatekeeper contract to use (if non-null) to restrict who can\\n        // contribute to this crowdfund.\\n        IGateKeeper gateKeeper;\\n        // The gatekeeper contract to use (if non-null).\\n        bytes12 gateKeeperId;\\n        // Fixed governance options (i.e. cannot be changed) that the governance\\n        // `Party` will be created with if the crowdfund succeeds.\\n        FixedGovernanceOpts governanceOpts;\\n        // Options for the proposal engine that the governance `Party` will be\\n        // created with if the crowdfund succeeds.\\n        ProposalStorage.ProposalEngineOpts proposalEngineOpts;\\n    }\\n\\n    event Won(Party party, IERC721[] tokens, uint256[] tokenIds, uint256 settledPrice);\\n    event Lost();\\n\\n    error MaximumPriceError(uint96 callValue, uint96 maximumPrice);\\n    error NoContributionsError();\\n    error CallProhibitedError(address target, bytes data);\\n    error FailedToBuyNFTError(IERC721 token, uint256 tokenId);\\n\\n    /// @notice When this crowdfund expires.\\n    uint40 public expiry;\\n    /// @notice Maximum amount this crowdfund will pay for the NFT.\\n    uint96 public maximumPrice;\\n    /// @notice What the NFT was actually bought for.\\n    uint96 public settledPrice;\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) Crowdfund(globals) {}\\n\\n    // Initialize storage for proxy contracts.\\n    function _initialize(BuyCrowdfundBaseOptions memory opts) internal {\\n        expiry = uint40(opts.duration + block.timestamp);\\n        maximumPrice = opts.maximumPrice;\\n        Crowdfund._initialize(\\n            CrowdfundOptions({\\n                name: opts.name,\\n                symbol: opts.symbol,\\n                customizationPresetId: opts.customizationPresetId,\\n                splitRecipient: opts.splitRecipient,\\n                splitBps: opts.splitBps,\\n                initialContributor: opts.initialContributor,\\n                initialDelegate: opts.initialDelegate,\\n                minContribution: opts.minContribution,\\n                maxContribution: opts.maxContribution,\\n                gateKeeper: opts.gateKeeper,\\n                gateKeeperId: opts.gateKeeperId,\\n                governanceOpts: opts.governanceOpts,\\n                proposalEngineOpts: opts.proposalEngineOpts\\n            })\\n        );\\n    }\\n\\n    // Execute arbitrary calldata to perform a buy, creating a party\\n    // if it successfully buys the NFT.\\n    function _buy(\\n        IERC721 token,\\n        uint256 tokenId,\\n        address payable callTarget,\\n        uint96 callValue,\\n        bytes memory callData\\n    ) internal returns (bool success, bytes memory revertData) {\\n        // Check that the call is not prohibited.\\n        if (!_isCallAllowed(callTarget, callData, token)) {\\n            revert CallProhibitedError(callTarget, callData);\\n        }\\n        // Check that the call value is under the maximum price.\\n        {\\n            uint96 maximumPrice_ = maximumPrice;\\n            if (callValue > maximumPrice_) {\\n                revert MaximumPriceError(callValue, maximumPrice_);\\n            }\\n        }\\n        // Execute the call to buy the NFT.\\n        (bool s, bytes memory r) = callTarget.call{ value: callValue }(callData);\\n        if (!s) {\\n            return (false, r);\\n        }\\n        // Return whether the NFT was successfully bought.\\n        return (token.safeOwnerOf(tokenId) == address(this), \\\"\\\");\\n    }\\n\\n    function _finalize(\\n        IERC721[] memory tokens,\\n        uint256[] memory tokenIds,\\n        uint96 totalEthUsed,\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        bool isValidatedGovernanceOpts\\n    ) internal returns (Party party_) {\\n        {\\n            // Prevent unaccounted ETH from being used to inflate the price and\\n            // create \\\"ghost shares\\\" in voting power.\\n            uint96 totalContributions_ = totalContributions;\\n            if (totalEthUsed > totalContributions_) {\\n                revert ExceedsTotalContributionsError(totalEthUsed, totalContributions_);\\n            }\\n        }\\n        if (totalEthUsed != 0) {\\n            // Create a party around the newly bought NFTs and finalize a win.\\n            settledPrice = totalEthUsed;\\n            party_ = _createParty(\\n                governanceOpts,\\n                proposalEngineOpts,\\n                isValidatedGovernanceOpts,\\n                tokens,\\n                tokenIds\\n            );\\n            emit Won(party_, tokens, tokenIds, totalEthUsed);\\n        } else {\\n            // If all NFTs were purchased for free or were all \\\"gifted\\\" to us,\\n            // refund all contributors by finalizing a loss.\\n            settledPrice = 0;\\n            expiry = uint40(block.timestamp);\\n            emit Lost();\\n        }\\n\\n        // Notify third-party platforms that the crowdfund NFT metadata has\\n        // updated for all tokens.\\n        emit BatchMetadataUpdate(0, type(uint256).max);\\n    }\\n\\n    function _finalize(\\n        IERC721 token,\\n        uint256 tokenId,\\n        uint96 totalEthUsed,\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        bool isValidatedGovernanceOpts\\n    ) internal returns (Party party_) {\\n        IERC721[] memory tokens = new IERC721[](1);\\n        tokens[0] = token;\\n        uint256[] memory tokenIds = new uint256[](1);\\n        tokenIds[0] = tokenId;\\n        return\\n            _finalize(\\n                tokens,\\n                tokenIds,\\n                totalEthUsed,\\n                governanceOpts,\\n                proposalEngineOpts,\\n                isValidatedGovernanceOpts\\n            );\\n    }\\n\\n    /// @inheritdoc Crowdfund\\n    function getCrowdfundLifecycle() public view override returns (CrowdfundLifecycle) {\\n        // If there is a settled price then we tried to buy the NFT.\\n        if (settledPrice != 0) {\\n            return\\n                address(party) != address(0)\\n                    ? CrowdfundLifecycle.Won // If we have a party, then we succeeded buying the NFT.\\n                    : CrowdfundLifecycle.Busy; // Otherwise we're in the middle of the `buy()`.\\n        }\\n        if (block.timestamp >= expiry) {\\n            // Expired, but nothing to do so skip straight to lost, or NFT was\\n            // acquired for free so refund contributors and trigger lost.\\n            return CrowdfundLifecycle.Lost;\\n        }\\n        return CrowdfundLifecycle.Active;\\n    }\\n\\n    function _getFinalPrice() internal view override returns (uint256) {\\n        return settledPrice;\\n    }\\n\\n    function _isCallAllowed(\\n        address payable callTarget,\\n        bytes memory callData,\\n        IERC721 token\\n    ) private view returns (bool isAllowed) {\\n        // Ensure the call target isn't trying to reenter\\n        if (callTarget == address(this)) {\\n            return false;\\n        }\\n        if (callTarget == address(token) && callData.length >= 4) {\\n            // Get the function selector of the call (first 4 bytes of calldata).\\n            bytes4 selector;\\n            assembly {\\n                selector := and(\\n                    mload(add(callData, 32)),\\n                    0xffffffff00000000000000000000000000000000000000000000000000000000\\n                )\\n            }\\n            // Prevent approving the NFT to be transferred out from the crowdfund.\\n            if (\\n                selector == IERC721.approve.selector ||\\n                selector == IERC721.setApprovalForAll.selector\\n            ) {\\n                return false;\\n            }\\n        }\\n        // All other calls are allowed.\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     *@dev The multiproof provided is not valid.\\n     */\\n    error MerkleProofInvalidMultiproof();\\n\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proofLen - 1 != totalHashes) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            if (proofPos != proofLen) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proofLen - 1 != totalHashes) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            if (proofPos != proofLen) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/crowdfund/ETHCrowdfundBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../utils/LibAddress.sol\\\";\\nimport \\\"../utils/LibSafeCast.sol\\\";\\nimport \\\"../party/Party.sol\\\";\\nimport \\\"../gatekeepers/IGateKeeper.sol\\\";\\n\\ncontract ETHCrowdfundBase is Implementation {\\n    using LibRawResult for bytes;\\n    using LibSafeCast for uint256;\\n    using LibAddress for address payable;\\n\\n    enum CrowdfundLifecycle {\\n        // In practice, this state is never used. If the crowdfund is ever in\\n        // this stage, something is wrong (e.g. crowdfund was never initialized).\\n        Invalid,\\n        // Ready to accept contributions to reach contribution targets\\n        // until a deadline or the minimum contribution target is reached and\\n        // host finalizes.\\n        Active,\\n        // Expired and the minimum contribution target was not reached.\\n        Lost,\\n        // The crowdfund has expired and reached the minimum contribution\\n        // target. It is now ready to finalize.\\n        Won,\\n        // A won crowdfund has been finalized, with funds transferred to the\\n        // party and voting power successfully updated.\\n        Finalized\\n    }\\n\\n    // Options to be passed into `initialize()` when the crowdfund is created.\\n    struct ETHCrowdfundOptions {\\n        Party party;\\n        address payable initialContributor;\\n        address initialDelegate;\\n        uint96 minContribution;\\n        uint96 maxContribution;\\n        bool disableContributingForExistingCard;\\n        uint96 minTotalContributions;\\n        uint96 maxTotalContributions;\\n        uint16 exchangeRateBps;\\n        uint16 fundingSplitBps;\\n        address payable fundingSplitRecipient;\\n        uint40 duration;\\n        IGateKeeper gateKeeper;\\n        bytes12 gateKeeperId;\\n    }\\n\\n    error WrongLifecycleError(CrowdfundLifecycle lc);\\n    error NotAllowedByGateKeeperError(\\n        address contributor,\\n        IGateKeeper gateKeeper,\\n        bytes12 gateKeeperId,\\n        bytes gateData\\n    );\\n    error OnlyPartyHostError();\\n    error OnlyPartyDaoError(address notDao);\\n    error OnlyPartyDaoOrHostError(address notDao);\\n    error NotOwnerError(uint256 tokenId);\\n    error OnlyWhenEmergencyActionsAllowedError();\\n    error InvalidDelegateError();\\n    error NotEnoughContributionsError(uint96 totalContribution, uint96 minTotalContributions);\\n    error MinGreaterThanMaxError(uint96 min, uint96 max);\\n    error MaxTotalContributionsCannotBeZeroError(uint96 maxTotalContributions);\\n    error BelowMinimumContributionsError(uint96 contributions, uint96 minContributions);\\n    error AboveMaximumContributionsError(uint96 contributions, uint96 maxContributions);\\n    error InvalidExchangeRateError(uint16 exchangeRateBps);\\n    error ContributingForExistingCardDisabledError();\\n    error ZeroVotingPowerError();\\n    error FundingSplitAlreadyPaidError();\\n    error FundingSplitNotConfiguredError();\\n\\n    event Contributed(\\n        address indexed sender,\\n        address indexed contributor,\\n        uint256 amount,\\n        address delegate\\n    );\\n    event Finalized();\\n    event FundingSplitSent(address indexed fundingSplitRecipient, uint256 amount);\\n    event EmergencyExecuteDisabled();\\n    event EmergencyExecute(address target, bytes data, uint256 amountEth);\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and it\u2019s address will never change.\\n    IGlobals private immutable _GLOBALS;\\n\\n    /// @notice The address of the `Party` contract instance associated\\n    ///         with the crowdfund.\\n    Party public party;\\n    /// @notice The minimum amount of ETH that a contributor can send to\\n    ///         participate in the crowdfund.\\n    uint96 public minContribution;\\n    /// @notice The maximum amount of ETH that a contributor can send to\\n    ///         participate in the crowdfund per address.\\n    uint96 public maxContribution;\\n    /// @notice A boolean flag that determines whether contributors are allowed\\n    ///         to increase the voting power of their existing party cards.\\n    bool public disableContributingForExistingCard;\\n    /// @notice Whether the funding split has been claimed by the funding split\\n    ///         recipient.\\n    bool public fundingSplitPaid;\\n    /// @notice Whether the DAO has emergency powers for this crowdfund.\\n    bool public emergencyExecuteDisabled;\\n    /// @notice The minimum amount of total ETH contributions required for the\\n    ///         crowdfund to be considered successful.\\n    uint96 public minTotalContributions;\\n    /// @notice The maximum amount of total ETH contributions allowed for the\\n    ///         crowdfund.\\n    uint96 public maxTotalContributions;\\n    /// @notice The total amount of ETH contributed to the crowdfund so far.\\n    uint96 public totalContributions;\\n    /// @notice The timestamp at which the crowdfund will end or ended. If 0, the\\n    ///         crowdfund has finalized.\\n    uint40 public expiry;\\n    /// @notice The exchange rate to use for converting ETH contributions to\\n    ///         voting power in basis points (e.g. 10000 = 1:1).\\n    uint16 public exchangeRateBps;\\n    /// @notice The portion of contributions to send to the funding recipient in\\n    ///         basis points (e.g. 100 = 1%).\\n    uint16 public fundingSplitBps;\\n    /// @notice The address to which a portion of the contributions is sent to.\\n    address payable public fundingSplitRecipient;\\n    /// @notice The gatekeeper contract used to restrict who can contribute to the party.\\n    IGateKeeper public gateKeeper;\\n    /// @notice The ID of the gatekeeper to use for restricting contributions to the party.\\n    bytes12 public gateKeeperId;\\n    /// @notice The address a contributor is delegating their voting power to.\\n    mapping(address => address) public delegationsByContributor;\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) {\\n        _GLOBALS = globals;\\n    }\\n\\n    // Initialize storage for proxy contracts, credit initial contribution (if\\n    // any), and setup gatekeeper.\\n    function _initialize(ETHCrowdfundOptions memory opts) internal {\\n        // Set the minimum and maximum contribution amounts.\\n        if (opts.minContribution > opts.maxContribution) {\\n            revert MinGreaterThanMaxError(opts.minContribution, opts.maxContribution);\\n        }\\n        minContribution = opts.minContribution;\\n        maxContribution = opts.maxContribution;\\n        // Set the min total contributions.\\n        if (opts.minTotalContributions > opts.maxTotalContributions) {\\n            revert MinGreaterThanMaxError(opts.minTotalContributions, opts.maxTotalContributions);\\n        }\\n        minTotalContributions = opts.minTotalContributions;\\n        // Set the max total contributions.\\n        if (opts.maxTotalContributions == 0) {\\n            // Prevent this because when `maxTotalContributions` is 0 the\\n            // crowdfund is invalid in `getCrowdfundLifecycle()` meaning it has\\n            // never been initialized.\\n            revert MaxTotalContributionsCannotBeZeroError(opts.maxTotalContributions);\\n        }\\n        maxTotalContributions = opts.maxTotalContributions;\\n        // Set the party crowdfund is for.\\n        party = opts.party;\\n        // Set the crowdfund start and end timestamps.\\n        expiry = uint40(block.timestamp + opts.duration);\\n        // Set the exchange rate.\\n        if (opts.exchangeRateBps == 0) revert InvalidExchangeRateError(opts.exchangeRateBps);\\n        exchangeRateBps = opts.exchangeRateBps;\\n        // Set the funding split and its recipient.\\n        fundingSplitBps = opts.fundingSplitBps;\\n        fundingSplitRecipient = opts.fundingSplitRecipient;\\n        // Set whether to disable contributing for existing card.\\n        disableContributingForExistingCard = opts.disableContributingForExistingCard;\\n    }\\n\\n    /// @notice Get the current lifecycle of the crowdfund.\\n    function getCrowdfundLifecycle() public view returns (CrowdfundLifecycle lifecycle) {\\n        if (maxTotalContributions == 0) {\\n            return CrowdfundLifecycle.Invalid;\\n        }\\n\\n        uint256 expiry_ = expiry;\\n        if (expiry_ == 0) {\\n            return CrowdfundLifecycle.Finalized;\\n        }\\n\\n        if (block.timestamp >= expiry_) {\\n            if (totalContributions >= minTotalContributions) {\\n                return CrowdfundLifecycle.Won;\\n            } else {\\n                return CrowdfundLifecycle.Lost;\\n            }\\n        }\\n\\n        return CrowdfundLifecycle.Active;\\n    }\\n\\n    function _processContribution(\\n        address payable contributor,\\n        address delegate,\\n        uint96 amount\\n    ) internal returns (uint96 votingPower) {\\n        address oldDelegate = delegationsByContributor[contributor];\\n        if (msg.sender == contributor || oldDelegate == address(0)) {\\n            // Update delegate.\\n            delegationsByContributor[contributor] = delegate;\\n        } else {\\n            // Prevent changing another's delegate if already delegated.\\n            delegate = oldDelegate;\\n        }\\n\\n        emit Contributed(msg.sender, contributor, amount, delegate);\\n\\n        // OK to contribute with zero just to update delegate.\\n        if (amount == 0) return 0;\\n\\n        // Only allow contributions while the crowdfund is active.\\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n        if (lc != CrowdfundLifecycle.Active) {\\n            revert WrongLifecycleError(lc);\\n        }\\n\\n        // Check that the contribution amount is at or below the maximum.\\n        uint96 maxContribution_ = maxContribution;\\n        if (amount > maxContribution_) {\\n            revert AboveMaximumContributionsError(amount, maxContribution_);\\n        }\\n\\n        uint96 newTotalContributions = totalContributions + amount;\\n        uint96 maxTotalContributions_ = maxTotalContributions;\\n        if (newTotalContributions >= maxTotalContributions_) {\\n            totalContributions = maxTotalContributions_;\\n\\n            // Finalize the crowdfund.\\n            // This occurs before refunding excess contribution to act as a\\n            // reentrancy guard.\\n            _finalize(maxTotalContributions_);\\n\\n            // Refund excess contribution.\\n            uint96 refundAmount = newTotalContributions - maxTotalContributions;\\n            if (refundAmount > 0) {\\n                amount -= refundAmount;\\n                payable(msg.sender).transferEth(refundAmount);\\n            }\\n        } else {\\n            totalContributions = newTotalContributions;\\n        }\\n\\n        // Check that the contribution amount is at or above the minimum. This\\n        // is done after `amount` is potentially reduced if refunding excess\\n        // contribution. There is a case where this prevents a crowdfunds from\\n        // reaching `maxTotalContributions` if the `minContribution` is greater\\n        // than the difference between `maxTotalContributions` and the current\\n        // `totalContributions`. In this scenario users will have to wait until\\n        // the crowdfund expires or a host finalizes after\\n        // `minTotalContribution` has been reached by calling `finalize()`.\\n        uint96 minContribution_ = minContribution;\\n        if (amount < minContribution_) {\\n            revert BelowMinimumContributionsError(amount, minContribution_);\\n        }\\n\\n        // Subtract fee from contribution amount if applicable.\\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\\n        uint16 fundingSplitBps_ = fundingSplitBps;\\n        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\\n            // Removes funding split from contribution amount in a way that\\n            // avoids rounding errors for very small contributions <1e4 wei.\\n            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;\\n        }\\n\\n        // Calculate voting power.\\n        votingPower = (amount * exchangeRateBps) / 1e4;\\n\\n        if (votingPower == 0) revert ZeroVotingPowerError();\\n    }\\n\\n    /// @notice Calculate the contribution amount from the given voting power.\\n    /// @param votingPower The voting power to convert to a contribution amount.\\n    /// @return amount The contribution amount.\\n    function convertVotingPowerToContribution(\\n        uint96 votingPower\\n    ) public view returns (uint96 amount) {\\n        amount = (votingPower * 1e4) / exchangeRateBps;\\n\\n        // Add back funding split to contribution amount if applicable.\\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\\n        uint16 fundingSplitBps_ = fundingSplitBps;\\n        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\\n            amount = (amount * 1e4) / (1e4 - fundingSplitBps_);\\n        }\\n    }\\n\\n    function finalize() external {\\n        uint96 totalContributions_ = totalContributions;\\n\\n        // Check that the crowdfund is not already finalized.\\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n        if (lc == CrowdfundLifecycle.Active) {\\n            // Allow host to finalize crowdfund early if it has reached its minimum goal.\\n            if (!party.isHost(msg.sender)) revert OnlyPartyHostError();\\n\\n            // Check that the crowdfund has reached its minimum goal.\\n            uint96 minTotalContributions_ = minTotalContributions;\\n            if (totalContributions_ < minTotalContributions_) {\\n                revert NotEnoughContributionsError(totalContributions_, minTotalContributions_);\\n            }\\n        } else {\\n            // Otherwise only allow finalization if the crowdfund has expired\\n            // and been won. Can be finalized by anyone.\\n            if (lc != CrowdfundLifecycle.Won) {\\n                revert WrongLifecycleError(lc);\\n            }\\n        }\\n\\n        // Finalize the crowdfund.\\n        _finalize(totalContributions_);\\n    }\\n\\n    function _finalize(uint96 totalContributions_) internal {\\n        // Finalize the crowdfund.\\n        delete expiry;\\n\\n        // Transfer funding split to recipient if applicable.\\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\\n        uint16 fundingSplitBps_ = fundingSplitBps;\\n        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\\n            totalContributions_ -= (totalContributions_ * fundingSplitBps_) / 1e4;\\n        }\\n\\n        // Update the party's total voting power.\\n        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;\\n        party.increaseTotalVotingPower(newVotingPower);\\n\\n        // Transfer ETH to the party.\\n        payable(address(party)).transferEth(totalContributions_);\\n\\n        emit Finalized();\\n    }\\n\\n    /// @notice Send the funding split to the recipient if applicable.\\n    function sendFundingSplit() external returns (uint96 splitAmount) {\\n        // Check that the crowdfund is finalized.\\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n        if (lc != CrowdfundLifecycle.Finalized) revert WrongLifecycleError(lc);\\n\\n        if (fundingSplitPaid) revert FundingSplitAlreadyPaidError();\\n\\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\\n        uint16 fundingSplitBps_ = fundingSplitBps;\\n        if (fundingSplitRecipient_ == address(0) || fundingSplitBps_ == 0) {\\n            revert FundingSplitNotConfiguredError();\\n        }\\n\\n        fundingSplitPaid = true;\\n\\n        // Transfer funding split to recipient.\\n        splitAmount = (totalContributions * fundingSplitBps_) / 1e4;\\n        payable(fundingSplitRecipient_).transferEth(splitAmount);\\n\\n        emit FundingSplitSent(fundingSplitRecipient_, splitAmount);\\n    }\\n\\n    /// @notice As the DAO, execute an arbitrary function call from this contract.\\n    /// @dev Emergency actions must not be revoked for this to work.\\n    /// @param targetAddress The contract to call.\\n    /// @param targetCallData The data to pass to the contract.\\n    /// @param amountEth The amount of ETH to send to the contract.\\n    function emergencyExecute(\\n        address targetAddress,\\n        bytes calldata targetCallData,\\n        uint256 amountEth\\n    ) external payable {\\n        // Must be called by the DAO.\\n        if (_GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender) {\\n            revert OnlyPartyDaoError(msg.sender);\\n        }\\n        // Must not be disabled by DAO or host.\\n        if (emergencyExecuteDisabled) {\\n            revert OnlyWhenEmergencyActionsAllowedError();\\n        }\\n        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);\\n        if (!success) {\\n            res.rawRevert();\\n        }\\n        emit EmergencyExecute(targetAddress, targetCallData, amountEth);\\n    }\\n\\n    /// @notice Revoke the DAO's ability to call emergencyExecute().\\n    /// @dev Either the DAO or the party host can call this.\\n    function disableEmergencyExecute() external {\\n        // Only the DAO or a host can call this.\\n        if (\\n            !party.isHost(msg.sender) &&\\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender\\n        ) {\\n            revert OnlyPartyDaoOrHostError(msg.sender);\\n        }\\n        emergencyExecuteDisabled = true;\\n        emit EmergencyExecuteDisabled();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/proposals/ProposalStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"./IProposalExecutionEngine.sol\\\";\\nimport \\\"../utils/LibRawResult.sol\\\";\\n\\n// The storage bucket shared by `PartyGovernance` and the `ProposalExecutionEngine`.\\n// Read this for more context on the pattern motivating this:\\n// https://github.com/dragonfly-xyz/useful-solidity-patterns/tree/main/patterns/explicit-storage-buckets\\nabstract contract ProposalStorage {\\n    using LibRawResult for bytes;\\n\\n    struct SharedProposalStorage {\\n        IProposalExecutionEngine engineImpl;\\n        ProposalEngineOpts opts;\\n    }\\n\\n    struct ProposalEngineOpts {\\n        // Whether the party can add new authorities with the add authority proposal.\\n        bool enableAddAuthorityProposal;\\n        // Whether the party can spend ETH from the party's balance with\\n        // arbitrary call proposals.\\n        bool allowArbCallsToSpendPartyEth;\\n        // Whether operators can be used.\\n        bool allowOperators;\\n        // Whether distributions require a vote or can be executed by any active member.\\n        bool distributionsRequireVote;\\n    }\\n\\n    uint256 internal constant PROPOSAL_FLAG_UNANIMOUS = 0x1;\\n    uint256 private constant SHARED_STORAGE_SLOT =\\n        uint256(keccak256(\\\"ProposalStorage.SharedProposalStorage\\\"));\\n\\n    function _initProposalImpl(IProposalExecutionEngine impl, bytes memory initData) internal {\\n        SharedProposalStorage storage stor = _getSharedProposalStorage();\\n        IProposalExecutionEngine oldImpl = stor.engineImpl;\\n        stor.engineImpl = impl;\\n        (bool s, bytes memory r) = address(impl).delegatecall(\\n            abi.encodeCall(IProposalExecutionEngine.initialize, (address(oldImpl), initData))\\n        );\\n        if (!s) {\\n            r.rawRevert();\\n        }\\n    }\\n\\n    function _getSharedProposalStorage()\\n        internal\\n        pure\\n        returns (SharedProposalStorage storage stor)\\n    {\\n        uint256 s = SHARED_STORAGE_SLOT;\\n        assembly {\\n            stor.slot := s\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/LibAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nlibrary LibAddress {\\n    error EthTransferFailed(address receiver, bytes errData);\\n\\n    // Transfer ETH with full gas stipend.\\n    function transferEth(address payable receiver, uint256 amount) internal {\\n        if (amount == 0) return;\\n\\n        (bool s, bytes memory r) = receiver.call{ value: amount }(\\\"\\\");\\n        if (!s) {\\n            revert EthTransferFailed(receiver, r);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/LibSafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nlibrary LibSafeCast {\\n    error Uint256ToUint96CastOutOfRange(uint256 v);\\n    error Uint256ToInt192CastOutOfRange(uint256 v);\\n    error Int192ToUint96CastOutOfRange(int192 i192);\\n    error Uint256ToInt128CastOutOfRangeError(uint256 u256);\\n    error Uint256ToUint128CastOutOfRangeError(uint256 u256);\\n    error Uint256ToUint40CastOutOfRangeError(uint256 u256);\\n\\n    function safeCastUint256ToUint96(uint256 v) internal pure returns (uint96) {\\n        if (v > uint256(type(uint96).max)) {\\n            revert Uint256ToUint96CastOutOfRange(v);\\n        }\\n        return uint96(v);\\n    }\\n\\n    function safeCastUint256ToUint128(uint256 v) internal pure returns (uint128) {\\n        if (v > uint256(type(uint128).max)) {\\n            revert Uint256ToUint128CastOutOfRangeError(v);\\n        }\\n        return uint128(v);\\n    }\\n\\n    function safeCastUint256ToInt192(uint256 v) internal pure returns (int192) {\\n        if (v > uint256(uint192(type(int192).max))) {\\n            revert Uint256ToInt192CastOutOfRange(v);\\n        }\\n        return int192(uint192(v));\\n    }\\n\\n    function safeCastUint96ToInt192(uint96 v) internal pure returns (int192) {\\n        return int192(uint192(v));\\n    }\\n\\n    function safeCastInt192ToUint96(int192 i192) internal pure returns (uint96) {\\n        if (i192 < 0 || i192 > int192(uint192(type(uint96).max))) {\\n            revert Int192ToUint96CastOutOfRange(i192);\\n        }\\n        return uint96(uint192(i192));\\n    }\\n\\n    function safeCastUint256ToInt128(uint256 x) internal pure returns (int128) {\\n        if (x > uint256(uint128(type(int128).max))) {\\n            revert Uint256ToInt128CastOutOfRangeError(x);\\n        }\\n        return int128(uint128(x));\\n    }\\n\\n    function safeCastUint256ToUint40(uint256 x) internal pure returns (uint40) {\\n        if (x > uint256(type(uint40).max)) {\\n            revert Uint256ToUint40CastOutOfRangeError(x);\\n        }\\n        return uint40(x);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/crowdfund/Crowdfund.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../utils/LibAddress.sol\\\";\\nimport \\\"../utils/LibRawResult.sol\\\";\\nimport \\\"../utils/LibSafeCast.sol\\\";\\nimport \\\"../tokens/ERC721Receiver.sol\\\";\\nimport \\\"../party/Party.sol\\\";\\nimport \\\"../globals/IGlobals.sol\\\";\\nimport \\\"../gatekeepers/IGateKeeper.sol\\\";\\nimport \\\"../party/IPartyFactory.sol\\\";\\nimport \\\"../renderers/RendererStorage.sol\\\";\\n\\nimport \\\"./CrowdfundNFT.sol\\\";\\n\\n// Base contract for AuctionCrowdfund/BuyCrowdfund.\\n// Holds post-win/loss logic. E.g., burning contribution NFTs and creating a\\n// party after winning.\\nabstract contract Crowdfund is Implementation, ERC721Receiver, CrowdfundNFT {\\n    using LibRawResult for bytes;\\n    using LibSafeCast for uint256;\\n    using LibAddress for address payable;\\n\\n    enum CrowdfundLifecycle {\\n        Invalid,\\n        Active,\\n        Expired,\\n        Busy, // Temporary. mid-settlement state\\n        Lost,\\n        Won\\n    }\\n\\n    // PartyGovernance options that must be known and fixed at crowdfund creation.\\n    // This is a subset of PartyGovernance.GovernanceOpts.\\n    struct FixedGovernanceOpts {\\n        // The implementation of the party to be created.\\n        Party partyImpl;\\n        // The factory to use to create the party.\\n        IPartyFactory partyFactory;\\n        // Address of initial party hosts.\\n        address[] hosts;\\n        // How long people can vote on a proposal.\\n        uint40 voteDuration;\\n        // How long to wait after a proposal passes before it can be\\n        // executed.\\n        uint40 executionDelay;\\n        // Minimum ratio of accept votes to consider a proposal passed,\\n        // in bps, where 10,000 == 100%.\\n        uint16 passThresholdBps;\\n        // Fee bps for governance distributions.\\n        uint16 feeBps;\\n        // Fee recipeint for governance distributions.\\n        address payable feeRecipient;\\n    }\\n\\n    // Options to be passed into `_initialize()` when the crowdfund is created.\\n    struct CrowdfundOptions {\\n        string name;\\n        string symbol;\\n        uint256 customizationPresetId;\\n        address payable splitRecipient;\\n        uint16 splitBps;\\n        address initialContributor;\\n        address initialDelegate;\\n        uint96 minContribution;\\n        uint96 maxContribution;\\n        IGateKeeper gateKeeper;\\n        bytes12 gateKeeperId;\\n        FixedGovernanceOpts governanceOpts;\\n        ProposalStorage.ProposalEngineOpts proposalEngineOpts;\\n    }\\n\\n    // A record of a single contribution made by a user.\\n    // Stored in `_contributionsByContributor`.\\n    struct Contribution {\\n        // The value of `Crowdfund.totalContributions` when this contribution was made.\\n        uint96 previousTotalContributions;\\n        // How much was this contribution.\\n        uint96 amount;\\n    }\\n\\n    // A record of the refund and governance NFT owed to a contributor if it\\n    // could not be received by them from `burn()`.\\n    struct Claim {\\n        uint256 refund;\\n        uint256 governanceTokenId;\\n    }\\n\\n    error PartyAlreadyExistsError(Party party);\\n    error WrongLifecycleError(CrowdfundLifecycle lc);\\n    error InvalidGovernanceOptionsError();\\n    error InvalidDelegateError();\\n    error InvalidContributorError();\\n    error NoPartyError();\\n    error NotAllowedByGateKeeperError(\\n        address contributor,\\n        IGateKeeper gateKeeper,\\n        bytes12 gateKeeperId,\\n        bytes gateData\\n    );\\n    error SplitRecipientAlreadyBurnedError();\\n    error InvalidBpsError(uint16 bps);\\n    error ExceedsTotalContributionsError(uint96 value, uint96 totalContributions);\\n    error NothingToClaimError();\\n    error OnlyPartyHostError();\\n    error OnlyContributorError();\\n    error MissingHostsError();\\n    error OnlyPartyDaoError(address notDao);\\n    error OnlyPartyDaoOrHostError(address notDao);\\n    error OnlyWhenEmergencyActionsAllowedError();\\n    error BelowMinimumContributionsError(uint96 contributions, uint96 minContributions);\\n    error AboveMaximumContributionsError(uint96 contributions, uint96 maxContributions);\\n\\n    event Burned(address contributor, uint256 ethUsed, uint256 ethOwed, uint256 votingPower);\\n    event Contributed(\\n        address sender,\\n        address contributor,\\n        uint256 amount,\\n        address delegate,\\n        uint256 previousTotalContributions\\n    );\\n    event EmergencyExecute(address target, bytes data, uint256 amountEth);\\n    event EmergencyExecuteDisabled();\\n\\n    uint40 private constant DISABLE_RAGEQUIT_PERMANENTLY = 0xab2cb21860; // uint40(uint256(keccak256(\\\"DISABLE_RAGEQUIT_PERMANENTLY\\\")))\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and it\u2019s address will never change.\\n    IGlobals private immutable _GLOBALS;\\n\\n    /// @notice The party instance created by `_createParty()`, if any after a\\n    ///         successful crowdfund.\\n    Party public party;\\n    /// @notice The total (recorded) ETH contributed to this crowdfund.\\n    uint96 public totalContributions;\\n    /// @notice The gatekeeper contract to use (if non-null) to restrict who can\\n    ///         contribute to the party.\\n    IGateKeeper public gateKeeper;\\n    /// @notice The ID of the gatekeeper strategy to use.\\n    bytes12 public gateKeeperId;\\n    /// @notice Who will receive a reserved portion of governance power when\\n    ///         the governance party is created.\\n    address payable public splitRecipient;\\n    /// @notice How much governance power to reserve for `splitRecipient`,\\n    ///         in bps, where 10,000 = 100%.\\n    uint16 public splitBps;\\n    // Whether the share for split recipient has been claimed through `burn()`.\\n    bool private _splitRecipientHasBurned;\\n    /// @notice Hash of party options passed into `initialize()`.\\n    ///         Used to check whether the options passed into `_createParty()`\\n    ///         matches.\\n    bytes32 public partyOptsHash;\\n    /// @notice Who a contributor last delegated to.\\n    mapping(address => address) public delegationsByContributor;\\n    // Array of contributions by a contributor.\\n    // One is created for every nonzero contribution made.\\n    // `internal` for testing purposes only.\\n    mapping(address => Contribution[]) internal _contributionsByContributor;\\n    /// @notice Stores the amount of ETH owed back to a contributor and governance NFT\\n    ///         that should be minted to them if it could not be transferred to\\n    ///         them with `burn()`.\\n    mapping(address => Claim) public claims;\\n    /// @notice Minimum amount of ETH that can be contributed to this crowdfund per address.\\n    uint96 public minContribution;\\n    /// @notice Maximum amount of ETH that can be contributed to this crowdfund per address.\\n    uint96 public maxContribution;\\n    /// @notice Whether the DAO has emergency powers for this party.\\n    bool public emergencyExecuteDisabled;\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) CrowdfundNFT(globals) {\\n        _GLOBALS = globals;\\n    }\\n\\n    // Initialize storage for proxy contracts, credit initial contribution (if\\n    // any), and setup gatekeeper.\\n    function _initialize(CrowdfundOptions memory opts) internal {\\n        CrowdfundNFT._initialize(opts.name, opts.symbol, opts.customizationPresetId);\\n        // Check that BPS values do not exceed the max.\\n        if (opts.governanceOpts.feeBps > 1e4) {\\n            revert InvalidBpsError(opts.governanceOpts.feeBps);\\n        }\\n        if (opts.governanceOpts.passThresholdBps > 1e4) {\\n            revert InvalidBpsError(opts.governanceOpts.passThresholdBps);\\n        }\\n        if (opts.splitBps > 1e4) {\\n            revert InvalidBpsError(opts.splitBps);\\n        }\\n        partyOptsHash = _hashOpts(opts.governanceOpts, opts.proposalEngineOpts);\\n        splitRecipient = opts.splitRecipient;\\n        splitBps = opts.splitBps;\\n        // Set the minimum and maximum contribution amounts.\\n        minContribution = opts.minContribution;\\n        maxContribution = opts.maxContribution;\\n        // If the deployer passed in some ETH during deployment, credit them\\n        // for the initial contribution.\\n        uint96 initialContribution = msg.value.safeCastUint256ToUint96();\\n        if (initialContribution > 0) {\\n            _setDelegate(opts.initialContributor, opts.initialDelegate);\\n            // If this ETH is passed in, credit it to the `initialContributor`.\\n            _contribute(opts.initialContributor, opts.initialDelegate, initialContribution, 0, \\\"\\\");\\n        }\\n        // Set up gatekeeper after initial contribution (initial always gets in).\\n        gateKeeper = opts.gateKeeper;\\n        gateKeeperId = opts.gateKeeperId;\\n    }\\n\\n    /// @notice As the DAO, execute an arbitrary function call from this contract.\\n    /// @dev Emergency actions must not be revoked for this to work.\\n    /// @param targetAddress The contract to call.\\n    /// @param targetCallData The data to pass to the contract.\\n    /// @param amountEth The amount of ETH to send to the contract.\\n    function emergencyExecute(\\n        address targetAddress,\\n        bytes calldata targetCallData,\\n        uint256 amountEth\\n    ) external payable onlyDelegateCall {\\n        // Must be called by the DAO.\\n        if (!_isPartyDao(msg.sender)) {\\n            revert OnlyPartyDaoError(msg.sender);\\n        }\\n        // Must not be disabled by DAO or host.\\n        if (emergencyExecuteDisabled) {\\n            revert OnlyWhenEmergencyActionsAllowedError();\\n        }\\n        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);\\n        if (!success) {\\n            res.rawRevert();\\n        }\\n        emit EmergencyExecute(targetAddress, targetCallData, amountEth);\\n    }\\n\\n    /// @notice Revoke the DAO's ability to call emergencyExecute().\\n    /// @dev Either the DAO or the party host can call this.\\n    /// @param governanceOpts The fixed governance opts the crowdfund was created with.\\n    /// @param proposalEngineOpts The options used to initialize the proposal\\n    ///                           engine in the `Party` instance.\\n    /// @param hostIndex The index of the party host (caller).\\n    function disableEmergencyExecute(\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        uint256 hostIndex\\n    ) external onlyDelegateCall {\\n        // Only the DAO or a host can call this.\\n        if (\\n            !_isHost(msg.sender, governanceOpts, proposalEngineOpts, hostIndex) &&\\n            !_isPartyDao(msg.sender)\\n        ) {\\n            revert OnlyPartyDaoOrHostError(msg.sender);\\n        }\\n        emergencyExecuteDisabled = true;\\n        emit EmergencyExecuteDisabled();\\n    }\\n\\n    /// @notice Burn the participation NFT for `contributor`, potentially\\n    ///         minting voting power and/or refunding unused ETH. `contributor`\\n    ///         may also be the split recipient, regardless of whether they are\\n    ///         also a contributor or not. This can be called by anyone on a\\n    ///         contributor's behalf to unlock their voting power in the\\n    ///         governance stage ensuring delegates receive their voting\\n    ///         power and governance is not stalled.\\n    /// @param contributor The contributor whose NFT to burn for.\\n    function burn(address payable contributor) public {\\n        return _burn(contributor, getCrowdfundLifecycle(), party);\\n    }\\n\\n    /// @dev Alias for `burn()`.\\n    function activateOrRefund(address payable contributor) external {\\n        burn(contributor);\\n    }\\n\\n    /// @notice `burn()` in batch form.\\n    ///         Will not revert if any individual burn fails.\\n    /// @param contributors The contributors whose NFT to burn for.\\n    /// @param revertOnFailure If true, revert if any burn fails.\\n    function batchBurn(address payable[] calldata contributors, bool revertOnFailure) public {\\n        for (uint256 i = 0; i < contributors.length; ++i) {\\n            (bool s, bytes memory r) = address(this).delegatecall(\\n                abi.encodeCall(this.burn, (contributors[i]))\\n            );\\n            if (revertOnFailure && !s) {\\n                r.rawRevert();\\n            }\\n        }\\n    }\\n\\n    /// @dev Alias for `batchBurn()`.\\n    function batchActivateOrRefund(\\n        address payable[] calldata contributors,\\n        bool revertOnFailure\\n    ) external {\\n        batchBurn(contributors, revertOnFailure);\\n    }\\n\\n    /// @notice Claim a governance NFT or refund that is owed back but could not be\\n    ///         given due to error in `_burn()` (e.g. a contract that does not\\n    ///         implement `onERC721Received()` or cannot receive ETH). Only call\\n    ///         this if refund and governance NFT minting could not be returned\\n    ///         with `burn()`.\\n    /// @param receiver The address to receive the NFT or refund.\\n    function claim(address payable receiver) external {\\n        Claim memory claimInfo = claims[msg.sender];\\n        delete claims[msg.sender];\\n\\n        if (claimInfo.refund == 0 && claimInfo.governanceTokenId == 0) {\\n            revert NothingToClaimError();\\n        }\\n\\n        if (claimInfo.refund != 0) {\\n            receiver.transferEth(claimInfo.refund);\\n        }\\n\\n        if (claimInfo.governanceTokenId != 0) {\\n            party.safeTransferFrom(address(this), receiver, claimInfo.governanceTokenId);\\n        }\\n    }\\n\\n    /// @notice Contribute to this crowdfund and/or update your delegation for the\\n    ///         governance phase should the crowdfund succeed.\\n    ///         For restricted crowdfunds, `gateData` can be provided to prove\\n    ///         membership to the gatekeeper.\\n    /// @param delegate The address to delegate to for the governance phase.\\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\\n    function contribute(address delegate, bytes memory gateData) external payable onlyDelegateCall {\\n        _setDelegate(msg.sender, delegate);\\n\\n        _contribute(\\n            msg.sender,\\n            delegate,\\n            msg.value.safeCastUint256ToUint96(),\\n            // We cannot use `address(this).balance - msg.value` as the previous\\n            // total contributions in case someone forces (suicides) ETH into this\\n            // contract. This wouldn't be such a big deal for open crowdfunds\\n            // but private ones (protected by a gatekeeper) could be griefed\\n            // because it would ultimately result in governance power that\\n            // is unattributed/unclaimable, meaning that party will never be\\n            // able to reach 100% consensus.\\n            totalContributions,\\n            gateData\\n        );\\n    }\\n\\n    /// @notice Contribute to this crowdfund on behalf of another address.\\n    /// @param recipient The address to record the contribution under.\\n    /// @param initialDelegate The address to delegate to for the governance phase if recipient hasn't delegated.\\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\\n    function contributeFor(\\n        address recipient,\\n        address initialDelegate,\\n        bytes memory gateData\\n    ) external payable onlyDelegateCall {\\n        _setDelegate(recipient, initialDelegate);\\n\\n        _contribute(\\n            recipient,\\n            initialDelegate,\\n            msg.value.safeCastUint256ToUint96(),\\n            totalContributions,\\n            gateData\\n        );\\n    }\\n\\n    /// @notice `contributeFor()` in batch form.\\n    ///         May not revert if any individual contribution fails.\\n    /// @param recipients The addresses to record the contributions under.\\n    /// @param initialDelegates The addresses to delegate to for each recipient.\\n    /// @param values The ETH to contribute for each recipient.\\n    /// @param gateDatas Data to pass to the gatekeeper to prove eligibility.\\n    /// @param revertOnFailure If true, revert if any contribution fails.\\n    function batchContributeFor(\\n        address[] memory recipients,\\n        address[] memory initialDelegates,\\n        uint256[] memory values,\\n        bytes[] memory gateDatas,\\n        bool revertOnFailure\\n    ) external payable {\\n        for (uint256 i; i < recipients.length; ++i) {\\n            (bool s, bytes memory r) = address(this).call{ value: values[i] }(\\n                abi.encodeCall(\\n                    this.contributeFor,\\n                    (recipients[i], initialDelegates[i], gateDatas[i])\\n                )\\n            );\\n            if (revertOnFailure && !s) {\\n                r.rawRevert();\\n            }\\n        }\\n    }\\n\\n    /// @inheritdoc EIP165\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public pure override(ERC721Receiver, CrowdfundNFT) returns (bool) {\\n        return\\n            ERC721Receiver.supportsInterface(interfaceId) ||\\n            CrowdfundNFT.supportsInterface(interfaceId);\\n    }\\n\\n    /// @notice Retrieve info about a participant's contributions.\\n    /// @dev This will only be called off-chain so doesn't have to be optimal.\\n    /// @param contributor The contributor to retrieve contributions for.\\n    /// @return ethContributed The total ETH contributed by `contributor`.\\n    /// @return ethUsed The total ETH used by `contributor` to acquire the NFT.\\n    /// @return ethOwed The total ETH refunded back to `contributor`.\\n    /// @return votingPower The total voting power minted to `contributor`.\\n    function getContributorInfo(\\n        address contributor\\n    )\\n        external\\n        view\\n        returns (uint256 ethContributed, uint256 ethUsed, uint256 ethOwed, uint256 votingPower)\\n    {\\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n        if (lc == CrowdfundLifecycle.Won || lc == CrowdfundLifecycle.Lost) {\\n            (ethUsed, ethOwed, votingPower) = _getFinalContribution(contributor);\\n            ethContributed = ethUsed + ethOwed;\\n        } else {\\n            Contribution[] memory contributions = _contributionsByContributor[contributor];\\n            uint256 numContributions = contributions.length;\\n            for (uint256 i; i < numContributions; ++i) {\\n                ethContributed += contributions[i].amount;\\n            }\\n        }\\n    }\\n\\n    /// @notice Get the current lifecycle of the crowdfund.\\n    function getCrowdfundLifecycle() public view virtual returns (CrowdfundLifecycle lifecycle);\\n\\n    // Get the final sale price of the bought assets. This will also be the total\\n    // voting power of the governance party.\\n    function _getFinalPrice() internal view virtual returns (uint256);\\n\\n    // Assert that `who` is a host at `governanceOpts.hosts[hostIndex]` and,\\n    // if so, assert that the governance opts is the same as the crowdfund\\n    // was created with.\\n    // Return true if `governanceOpts` was validated in the process.\\n    function _assertIsHost(\\n        address who,\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        uint256 hostIndex\\n    ) internal view {\\n        if (!_isHost(who, governanceOpts, proposalEngineOpts, hostIndex)) {\\n            revert OnlyPartyHostError();\\n        }\\n    }\\n\\n    // Check if `who` is a host at `hostIndex` index. Validates governance opts if so.\\n    function _isHost(\\n        address who,\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        uint256 hostIndex\\n    ) private view returns (bool isHost) {\\n        if (hostIndex < governanceOpts.hosts.length && who == governanceOpts.hosts[hostIndex]) {\\n            // Validate governance opts if the host was found.\\n            _assertValidOpts(governanceOpts, proposalEngineOpts);\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    function _isPartyDao(address who) private view returns (bool isPartyDao) {\\n        return who == _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\\n    }\\n\\n    // Assert that `who` is a contributor to the crowdfund.\\n    function _assertIsContributor(address who) internal view {\\n        if (_contributionsByContributor[who].length == 0) {\\n            revert OnlyContributorError();\\n        }\\n    }\\n\\n    // Can be called after a party has won.\\n    // Deploys and initializes a `Party` instance via the `PartyFactory`\\n    // and transfers the bought NFT to it.\\n    // After calling this, anyone can burn CF tokens on a contributor's behalf\\n    // with the `burn()` function.\\n    function _createParty(\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        bool governanceOptsAlreadyValidated,\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds\\n    ) internal returns (Party party_) {\\n        if (party != Party(payable(0))) {\\n            revert PartyAlreadyExistsError(party);\\n        }\\n        // If the governance opts haven't already been validated, make sure that\\n        // it hasn't been tampered with.\\n        if (!governanceOptsAlreadyValidated) {\\n            _assertValidOpts(governanceOpts, proposalEngineOpts);\\n        }\\n        // Get options used to create the party.\\n        RendererStorage rendererStorage = RendererStorage(\\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE)\\n        );\\n        address[] memory authorities = new address[](1);\\n        authorities[0] = address(this);\\n        // Create a party.\\n        party = party_ = governanceOpts.partyFactory.createParty(\\n            governanceOpts.partyImpl,\\n            authorities,\\n            Party.PartyOptions({\\n                name: name,\\n                symbol: symbol,\\n                customizationPresetId: rendererStorage.getPresetFor(address(this)),\\n                governance: PartyGovernance.GovernanceOpts({\\n                    hosts: governanceOpts.hosts,\\n                    voteDuration: governanceOpts.voteDuration,\\n                    executionDelay: governanceOpts.executionDelay,\\n                    passThresholdBps: governanceOpts.passThresholdBps,\\n                    totalVotingPower: _getFinalPrice().safeCastUint256ToUint96(),\\n                    feeBps: governanceOpts.feeBps,\\n                    feeRecipient: governanceOpts.feeRecipient\\n                }),\\n                proposalEngine: proposalEngineOpts\\n            }),\\n            preciousTokens,\\n            preciousTokenIds,\\n            // Ragequit is not applicable for NFT parties which primarily own\\n            // non-fungible assets (which cannot be split) and can perform\\n            // distributions without needing a vote.\\n            DISABLE_RAGEQUIT_PERMANENTLY\\n        );\\n        // Transfer the acquired NFTs to the new party.\\n        for (uint256 i; i < preciousTokens.length; ++i) {\\n            preciousTokens[i].transferFrom(address(this), address(party_), preciousTokenIds[i]);\\n        }\\n    }\\n\\n    // Overloaded single token wrapper for _createParty()\\n    function _createParty(\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        bool governanceOptsAlreadyValidated,\\n        IERC721 preciousToken,\\n        uint256 preciousTokenId\\n    ) internal returns (Party party_) {\\n        IERC721[] memory tokens = new IERC721[](1);\\n        tokens[0] = preciousToken;\\n        uint256[] memory tokenIds = new uint256[](1);\\n        tokenIds[0] = preciousTokenId;\\n        return\\n            _createParty(\\n                governanceOpts,\\n                proposalEngineOpts,\\n                governanceOptsAlreadyValidated,\\n                tokens,\\n                tokenIds\\n            );\\n    }\\n\\n    // Assert that the hash of `opts` matches the hash this crowdfund was initialized with.\\n    function _assertValidOpts(\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts\\n    ) private view {\\n        bytes32 partyOptsHash_ = _hashOpts(governanceOpts, proposalEngineOpts);\\n        if (partyOptsHash_ != partyOptsHash) {\\n            revert InvalidGovernanceOptionsError();\\n        }\\n    }\\n\\n    function _hashOpts(\\n        FixedGovernanceOpts memory govOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts\\n    ) internal pure returns (bytes32 h) {\\n        return keccak256(abi.encode(govOpts, proposalEngineOpts));\\n    }\\n\\n    function _getFinalContribution(\\n        address contributor\\n    ) internal view returns (uint256 ethUsed, uint256 ethOwed, uint256 votingPower) {\\n        uint256 totalEthUsed = _getFinalPrice();\\n        {\\n            Contribution[] memory contributions = _contributionsByContributor[contributor];\\n            uint256 numContributions = contributions.length;\\n            for (uint256 i; i < numContributions; ++i) {\\n                Contribution memory c = contributions[i];\\n                if (c.previousTotalContributions >= totalEthUsed) {\\n                    // This entire contribution was not used.\\n                    ethOwed += c.amount;\\n                } else if (c.previousTotalContributions + c.amount <= totalEthUsed) {\\n                    // This entire contribution was used.\\n                    ethUsed += c.amount;\\n                } else {\\n                    // This contribution was partially used.\\n                    uint256 partialEthUsed = totalEthUsed - c.previousTotalContributions;\\n                    ethUsed += partialEthUsed;\\n                    ethOwed = c.amount - partialEthUsed;\\n                }\\n            }\\n        }\\n        // one SLOAD with optimizer on\\n        address splitRecipient_ = splitRecipient;\\n        uint256 splitBps_ = splitBps;\\n        if (splitRecipient_ == address(0)) {\\n            splitBps_ = 0;\\n        }\\n        votingPower = ((1e4 - splitBps_) * ethUsed) / 1e4;\\n        if (splitRecipient_ == contributor) {\\n            // Split recipient is also the contributor so just add the split\\n            // voting power.\\n            votingPower += (splitBps_ * totalEthUsed + (1e4 - 1)) / 1e4; // round up\\n        }\\n    }\\n\\n    function _setDelegate(address contributor, address delegate) private {\\n        if (delegate == address(0)) revert InvalidDelegateError();\\n\\n        // Only need to update delegate if there was a change.\\n        address oldDelegate = delegationsByContributor[contributor];\\n        if (oldDelegate == delegate) return;\\n\\n        // Only allow setting delegate on another's behalf if the delegate is unset.\\n        if (msg.sender != contributor && oldDelegate != address(0)) return;\\n\\n        // Update delegate.\\n        delegationsByContributor[contributor] = delegate;\\n    }\\n\\n    /// @dev While it is not necessary to pass in `delegate` to this because the\\n    ///      function does not require it, it is here to emit in the\\n    ///      `Contribute` event so that the PartyBid frontend can access it more\\n    ///      easily.\\n    function _contribute(\\n        address contributor,\\n        address delegate,\\n        uint96 amount,\\n        uint96 previousTotalContributions,\\n        bytes memory gateData\\n    ) private {\\n        if (contributor == address(this)) revert InvalidContributorError();\\n\\n        if (amount == 0) return;\\n\\n        // Must not be blocked by gatekeeper.\\n        {\\n            IGateKeeper _gateKeeper = gateKeeper;\\n            if (_gateKeeper != IGateKeeper(address(0))) {\\n                if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {\\n                    revert NotAllowedByGateKeeperError(\\n                        msg.sender,\\n                        _gateKeeper,\\n                        gateKeeperId,\\n                        gateData\\n                    );\\n                }\\n            }\\n        }\\n        // Only allow contributions while the crowdfund is active.\\n        {\\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n            if (lc != CrowdfundLifecycle.Active) {\\n                revert WrongLifecycleError(lc);\\n            }\\n        }\\n        // Increase total contributions.\\n        totalContributions += amount;\\n        // Create contributions entry for this contributor.\\n        Contribution[] storage contributions = _contributionsByContributor[contributor];\\n        uint256 numContributions = contributions.length;\\n        uint96 ethContributed;\\n        for (uint256 i; i < numContributions; ++i) {\\n            ethContributed += contributions[i].amount;\\n        }\\n        // Check contribution is greater than minimum contribution.\\n        if (ethContributed + amount < minContribution) {\\n            revert BelowMinimumContributionsError(ethContributed + amount, minContribution);\\n        }\\n        // Check contribution is less than maximum contribution.\\n        if (ethContributed + amount > maxContribution) {\\n            revert AboveMaximumContributionsError(ethContributed + amount, maxContribution);\\n        }\\n\\n        emit Contributed(msg.sender, contributor, amount, delegate, previousTotalContributions);\\n\\n        // Notify third-party platforms that the crowdfund NFT metadata has updated.\\n        emit MetadataUpdate(uint256(uint160(contributor)));\\n\\n        if (numContributions >= 1) {\\n            Contribution memory lastContribution = contributions[numContributions - 1];\\n            // If no one else (other than this contributor) has contributed since,\\n            // we can just reuse this contributor's last entry.\\n            uint256 totalContributionsAmountForReuse = lastContribution.previousTotalContributions +\\n                lastContribution.amount;\\n            if (totalContributionsAmountForReuse == previousTotalContributions) {\\n                lastContribution.amount += amount;\\n                contributions[numContributions - 1] = lastContribution;\\n                return;\\n            }\\n        }\\n        // Add a new contribution entry.\\n        contributions.push(\\n            Contribution({ previousTotalContributions: previousTotalContributions, amount: amount })\\n        );\\n        // Mint a participation NFT if this is their first contribution.\\n        if (numContributions == 0) {\\n            _mint(contributor);\\n        }\\n    }\\n\\n    function _burn(address payable contributor, CrowdfundLifecycle lc, Party party_) private {\\n        // If the CF has won, a party must have been created prior.\\n        if (lc == CrowdfundLifecycle.Won) {\\n            if (party_ == Party(payable(0))) {\\n                revert NoPartyError();\\n            }\\n        } else if (lc != CrowdfundLifecycle.Lost) {\\n            // Otherwise it must have lost.\\n            revert WrongLifecycleError(lc);\\n        }\\n        // Split recipient can burn even if they don't have a token.\\n        {\\n            address splitRecipient_ = splitRecipient;\\n            if (contributor == splitRecipient_) {\\n                if (_splitRecipientHasBurned) {\\n                    revert SplitRecipientAlreadyBurnedError();\\n                }\\n                _splitRecipientHasBurned = true;\\n            }\\n            // Revert if already burned or does not exist.\\n            if (splitRecipient_ != contributor || _doesTokenExistFor(contributor)) {\\n                CrowdfundNFT._burn(contributor);\\n            }\\n        }\\n        // Compute the contributions used and owed to the contributor, along\\n        // with the voting power they'll have in the governance stage.\\n        (uint256 ethUsed, uint256 ethOwed, uint256 votingPower) = _getFinalContribution(\\n            contributor\\n        );\\n        if (votingPower > 0) {\\n            // Get the address to delegate voting power to. If null, delegate to self.\\n            address delegate = delegationsByContributor[contributor];\\n            if (delegate == address(0)) {\\n                // Delegate can be unset for the split recipient if they never\\n                // contribute. Self-delegate if this occurs.\\n                delegate = contributor;\\n            }\\n            // Mint governance NFT for the contributor.\\n            try party_.mint(contributor, votingPower, delegate) returns (uint256) {\\n                // OK\\n            } catch {\\n                // Mint to the crowdfund itself to escrow for contributor to\\n                // come claim later on.\\n                uint256 tokenId = party_.mint(address(this), votingPower, delegate);\\n                claims[contributor].governanceTokenId = tokenId;\\n            }\\n        }\\n        // Refund any ETH owed back to the contributor.\\n        (bool s, ) = contributor.call{ value: ethOwed }(\\\"\\\");\\n        if (!s) {\\n            // If the transfer fails, the contributor can still come claim it\\n            // from the crowdfund.\\n            claims[contributor].refund = ethOwed;\\n        }\\n        emit Burned(contributor, ethUsed, ethOwed, votingPower);\\n    }\\n}\\n\\nfunction _hashFixedGovernanceOpts(\\n    Crowdfund.FixedGovernanceOpts memory opts\\n) pure returns (bytes32 h) {\\n    // Hash in place.\\n    assembly {\\n        // Replace the address[] hosts field with its hash temporarily.\\n        let oldHostsFieldValue := mload(opts)\\n        mstore(opts, keccak256(add(oldHostsFieldValue, 0x20), mul(mload(oldHostsFieldValue), 32)))\\n        // Hash the entire struct.\\n        h := keccak256(opts, 0xC0)\\n        // Restore old hosts field value.\\n        mstore(opts, oldHostsFieldValue)\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/crowdfund/CrowdfundNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../tokens/IERC721.sol\\\";\\nimport \\\"../utils/ReadOnlyDelegateCall.sol\\\";\\nimport \\\"../utils/EIP165.sol\\\";\\nimport \\\"../utils/IERC4906.sol\\\";\\nimport \\\"../globals/IGlobals.sol\\\";\\nimport \\\"../globals/LibGlobals.sol\\\";\\nimport \\\"../renderers/RendererStorage.sol\\\";\\n\\n/// @notice NFT functionality for crowdfund types. This NFT is soulbound and read-only.\\ncontract CrowdfundNFT is IERC721, IERC4906, EIP165, ReadOnlyDelegateCall {\\n    error AlreadyMintedError(address owner, uint256 tokenId);\\n    error AlreadyBurnedError(address owner, uint256 tokenId);\\n    error InvalidTokenError(uint256 tokenId);\\n    error InvalidAddressError();\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and it\u2019s address will never change.\\n    IGlobals private immutable _GLOBALS;\\n\\n    /// @notice The name of the crowdfund. This will also carry over to the\\n    ///         governance party.\\n    string public name;\\n    /// @notice The token symbol for the crowdfund. This will also carry over to\\n    ///         the governance party.\\n    string public symbol;\\n\\n    mapping(uint256 => address) private _owners;\\n\\n    modifier alwaysRevert() {\\n        revert(\\\"ALWAYS FAILING\\\");\\n        _; // Compiler requires this.\\n    }\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) {\\n        _GLOBALS = globals;\\n    }\\n\\n    // Initialize name and symbol for crowdfund.\\n    function _initialize(\\n        string memory name_,\\n        string memory symbol_,\\n        uint256 customizationPresetId\\n    ) internal virtual {\\n        name = name_;\\n        symbol = symbol_;\\n        if (customizationPresetId != 0) {\\n            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))\\n                .useCustomizationPreset(customizationPresetId);\\n        }\\n    }\\n\\n    /// @notice DO NOT CALL. This is a soulbound NFT and cannot be transferred.\\n    ///         Attempting to call this function will always fail.\\n    function transferFrom(address, address, uint256) external pure alwaysRevert {}\\n\\n    /// @notice DO NOT CALL. This is a soulbound NFT and cannot be transferred.\\n    ///         Attempting to call this function will always fail.\\n    function safeTransferFrom(address, address, uint256) external pure alwaysRevert {}\\n\\n    /// @notice DO NOT CALL. This is a soulbound NFT and cannot be transferred.\\n    ///         Attempting to call this function will always fail.\\n    function safeTransferFrom(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external pure alwaysRevert {}\\n\\n    /// @notice DO NOT CALL. This is a soulbound NFT and cannot be transferred.\\n    ///         Attempting to call this function will always fail.\\n    function approve(address, uint256) external pure alwaysRevert {}\\n\\n    /// @notice DO NOT CALL. This is a soulbound NFT and cannot be transferred.\\n    ///         Attempting to call this function will always fail.\\n    function setApprovalForAll(address, bool) external pure alwaysRevert {}\\n\\n    /// @notice This is a soulbound NFT and cannot be transferred.\\n    ///         Attempting to call this function will always return null.\\n    function getApproved(uint256) external pure returns (address) {\\n        return address(0);\\n    }\\n\\n    /// @notice This is a soulbound NFT and cannot be transferred.\\n    ///         Attempting to call this function will always return false.\\n    function isApprovedForAll(address, address) external pure returns (bool) {\\n        return false;\\n    }\\n\\n    /// @inheritdoc EIP165\\n    function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\\n        return\\n            super.supportsInterface(interfaceId) ||\\n            // ERC721 interface ID\\n            interfaceId == 0x80ac58cd ||\\n            // ERC4906 interface ID\\n            interfaceId == 0x49064906;\\n    }\\n\\n    /// @notice Returns a URI to render the NFT.\\n    function tokenURI(uint256) external view returns (string memory) {\\n        return _delegateToRenderer();\\n    }\\n\\n    /// @notice Returns a URI for the storefront-level metadata for your contract.\\n    function contractURI() external view returns (string memory) {\\n        return _delegateToRenderer();\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function ownerOf(uint256 tokenId) external view returns (address owner) {\\n        owner = _owners[tokenId];\\n        if (owner == address(0)) {\\n            revert InvalidTokenError(tokenId);\\n        }\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function balanceOf(address owner) external view returns (uint256 numTokens) {\\n        return _doesTokenExistFor(owner) ? 1 : 0;\\n    }\\n\\n    function _doesTokenExistFor(address owner) internal view returns (bool) {\\n        return _owners[uint256(uint160(owner))] != address(0);\\n    }\\n\\n    function _mint(address owner) internal returns (uint256 tokenId) {\\n        if (owner == address(0)) revert InvalidAddressError();\\n        tokenId = uint256(uint160(owner));\\n        if (_owners[tokenId] != owner) {\\n            _owners[tokenId] = owner;\\n            emit Transfer(address(0), owner, tokenId);\\n        } else {\\n            revert AlreadyMintedError(owner, tokenId);\\n        }\\n    }\\n\\n    function _burn(address owner) internal {\\n        uint256 tokenId = uint256(uint160(owner));\\n        if (_owners[tokenId] == owner) {\\n            _owners[tokenId] = address(0);\\n            emit Transfer(owner, address(0), tokenId);\\n            return;\\n        }\\n        revert AlreadyBurnedError(owner, tokenId);\\n    }\\n\\n    function _delegateToRenderer() private view returns (string memory) {\\n        _readOnlyDelegateCall(\\n            // Instance of IERC721Renderer.\\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_CF_NFT_RENDER_IMPL),\\n            msg.data\\n        );\\n        assert(false); // Will not be reached.\\n        return \\\"\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../utils/LibRawResult.sol\\\";\\n\\nabstract contract Multicall {\\n    using LibRawResult for bytes;\\n\\n    /// @notice Perform multiple delegatecalls on ourselves.\\n    function multicall(bytes[] calldata multicallData) external {\\n        for (uint256 i; i < multicallData.length; ++i) {\\n            (bool s, bytes memory r) = address(this).delegatecall(multicallData[i]);\\n            if (!s) {\\n                r.rawRevert();\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/renderers/MetadataRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport { IGlobals } from \\\"../globals/IGlobals.sol\\\";\\nimport { LibGlobals } from \\\"../globals/LibGlobals.sol\\\";\\nimport { IMetadataProvider } from \\\"./IMetadataProvider.sol\\\";\\nimport { Multicall } from \\\"../utils/Multicall.sol\\\";\\n\\n/// @notice A registry of custom metadata providers for Party Cards.\\ncontract MetadataRegistry is Multicall {\\n    event ProviderSet(address indexed instance, IMetadataProvider indexed provider);\\n    event RegistrarSet(address indexed registrar, address indexed instance, bool canSetData);\\n\\n    error NotAuthorized(address caller, address instance);\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and it\u2019s address will never change.\\n    IGlobals private immutable _GLOBALS;\\n\\n    /// @notice Get the metadata provider for a Party instance.\\n    mapping(address instance => IMetadataProvider provider) public getProvider;\\n\\n    /// @notice Whether or not an address is a registar that can set the\\n    ///         provider and metadata for another instance. If registrar is set\\n    ///         true for `address(1)`, the address is a universal registar and\\n    ///         can set data for any instance.\\n    /// @dev Registrars' ability to set metadata for another instance must also be\\n    ///      supported by the metadata provider used by that instance, indicated by\\n    ///      `IMetadataProvider.supportsRegistrars()`.\\n    mapping(address registrar => mapping(address instance => bool canSetData)) private _isRegistrar;\\n\\n    /// @param globals The address of the `Globals` contract.\\n    /// @param registrars The addresses of the initial universal registrars.\\n    constructor(IGlobals globals, address[] memory registrars) {\\n        _GLOBALS = globals;\\n\\n        // Set the initial universal registrars.\\n        for (uint256 i = 0; i < registrars.length; i++) {\\n            _isRegistrar[registrars[i]][address(1)] = true;\\n        }\\n    }\\n\\n    /// @notice Set the metadata provider for a Party instance.\\n    /// @param instance The address of the instance.\\n    /// @param provider The address of the metadata provider.\\n    function setProvider(address instance, IMetadataProvider provider) external {\\n        // Check if the caller is authorized to set the provider for the instance.\\n        if (!isRegistrar(msg.sender, instance)) revert NotAuthorized(msg.sender, instance);\\n\\n        getProvider[instance] = provider;\\n\\n        emit ProviderSet(instance, provider);\\n    }\\n\\n    /// @notice Set whether or not an address can set metadata for a Party instance.\\n    /// @param registrar The address of the possible registrar.\\n    /// @param instance The address of the instance the registrar can set\\n    ///                 metadata for.\\n    /// @param canSetData Whether or not the address can set data for the instance.\\n    function setRegistrar(address registrar, address instance, bool canSetData) external {\\n        if (\\n            msg.sender != instance &&\\n            msg.sender != _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET)\\n        ) {\\n            revert NotAuthorized(msg.sender, instance);\\n        }\\n\\n        _isRegistrar[registrar][instance] = canSetData;\\n\\n        emit RegistrarSet(registrar, instance, canSetData);\\n    }\\n\\n    /// @notice Get whether or not an address can set metadata for a Party instance.\\n    /// @param registrar The address of the possible registrar.\\n    /// @param instance The address of the instance the registrar can set\\n    ///                 metadata for.\\n    /// @return canSetData Whether or not the address can set data for the instance.\\n    function isRegistrar(address registrar, address instance) public view returns (bool) {\\n        return\\n            registrar == instance ||\\n            _isRegistrar[registrar][address(1)] ||\\n            _isRegistrar[registrar][instance];\\n    }\\n\\n    /// @notice Get the metadata for a Party instance.\\n    /// @param instance The address of the instance.\\n    /// @param tokenId The ID of the token to get the metadata for.\\n    /// @return metadata The encoded metadata.\\n    function getMetadata(address instance, uint256 tokenId) external view returns (bytes memory) {\\n        IMetadataProvider provider = getProvider[instance];\\n\\n        return\\n            address(provider) != address(0) ? provider.getMetadata(instance, tokenId) : bytes(\\\"\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/renderers/IMetadataProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8;\\n\\ninterface IMetadataProvider {\\n    /// @notice Whether or not the metadata provider supports registrars that can\\n    ///         set metadata for other instances.\\n    /// @dev See `MetadataRegistry` for more information on the registrar role.\\n    function supportsRegistrars() external view returns (bool);\\n\\n    /// @notice Get the metadata for a Party instance.\\n    /// @param instance The address of the instance.\\n    /// @param tokenId The ID of the token to get the metadata for.\\n    /// @return metadata The encoded metadata.\\n    function getMetadata(\\n        address instance,\\n        uint256 tokenId\\n    ) external view returns (bytes memory metadata);\\n}\\n\"\r\n    },\r\n    \"contracts/globals/LibGlobals.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\n// Valid keys in `IGlobals`. Append-only.\\nlibrary LibGlobals {\\n    // The Globals commented out below were depreciated in 1.2; factories\\n    // can now choose the implementation address to deploy and no longer\\n    // deploy the latest implementation. They will no longer be updated\\n    // in future releases.\\n    //\\n    // See https://github.com/PartyDAO/party-migrations for\\n    // implementation addresses by release.\\n\\n    uint256 internal constant GLOBAL_PARTY_IMPL = 1;\\n    uint256 internal constant GLOBAL_PROPOSAL_ENGINE_IMPL = 2;\\n    // uint256 internal constant GLOBAL_PARTY_FACTORY = 3;\\n    uint256 internal constant GLOBAL_GOVERNANCE_NFT_RENDER_IMPL = 4;\\n    uint256 internal constant GLOBAL_CF_NFT_RENDER_IMPL = 5;\\n    uint256 internal constant GLOBAL_OS_ZORA_AUCTION_TIMEOUT = 6;\\n    uint256 internal constant GLOBAL_OS_ZORA_AUCTION_DURATION = 7;\\n    // uint256 internal constant GLOBAL_AUCTION_CF_IMPL = 8;\\n    // uint256 internal constant GLOBAL_BUY_CF_IMPL = 9;\\n    // uint256 internal constant GLOBAL_COLLECTION_BUY_CF_IMPL = 10;\\n    uint256 internal constant GLOBAL_DAO_WALLET = 11;\\n    uint256 internal constant GLOBAL_TOKEN_DISTRIBUTOR = 12;\\n    uint256 internal constant GLOBAL_OPENSEA_CONDUIT_KEY = 13;\\n    uint256 internal constant GLOBAL_OPENSEA_ZONE = 14;\\n    uint256 internal constant GLOBAL_PROPOSAL_MAX_CANCEL_DURATION = 15;\\n    uint256 internal constant GLOBAL_ZORA_MIN_AUCTION_DURATION = 16;\\n    uint256 internal constant GLOBAL_ZORA_MAX_AUCTION_DURATION = 17;\\n    uint256 internal constant GLOBAL_ZORA_MAX_AUCTION_TIMEOUT = 18;\\n    uint256 internal constant GLOBAL_OS_MIN_ORDER_DURATION = 19;\\n    uint256 internal constant GLOBAL_OS_MAX_ORDER_DURATION = 20;\\n    uint256 internal constant GLOBAL_DISABLE_PARTY_ACTIONS = 21;\\n    uint256 internal constant GLOBAL_RENDERER_STORAGE = 22;\\n    uint256 internal constant GLOBAL_PROPOSAL_MIN_CANCEL_DURATION = 23;\\n    // uint256 internal constant GLOBAL_ROLLING_AUCTION_CF_IMPL = 24;\\n    // uint256 internal constant GLOBAL_COLLECTION_BATCH_BUY_CF_IMPL = 25;\\n    uint256 internal constant GLOBAL_METADATA_REGISTRY = 26;\\n    // uint256 internal constant GLOBAL_CROWDFUND_FACTORY = 27;\\n    // uint256 internal constant GLOBAL_INITIAL_ETH_CF_IMPL = 28;\\n    // uint256 internal constant GLOBAL_RERAISE_ETH_CF_IMPL = 29;\\n    uint256 internal constant GLOBAL_SEAPORT = 30;\\n    uint256 internal constant GLOBAL_CONDUIT_CONTROLLER = 31;\\n    uint256 internal constant GLOBAL_OFF_CHAIN_SIGNATURE_VALIDATOR = 32;\\n}\\n\"\r\n    },\r\n    \"contracts/party/PartyGovernanceNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../utils/LibSafeCast.sol\\\";\\nimport \\\"../utils/LibAddress.sol\\\";\\nimport \\\"openzeppelin/contracts/interfaces/IERC2981.sol\\\";\\nimport \\\"../globals/IGlobals.sol\\\";\\nimport \\\"../tokens/IERC721.sol\\\";\\nimport \\\"../vendor/solmate/ERC721.sol\\\";\\nimport \\\"./PartyGovernance.sol\\\";\\nimport \\\"../renderers/RendererStorage.sol\\\";\\n\\n/// @notice ERC721 functionality built on top of `PartyGovernance`.\\ncontract PartyGovernanceNFT is PartyGovernance, ERC721, IERC2981 {\\n    using LibSafeCast for uint256;\\n    using LibSafeCast for uint96;\\n    using LibERC20Compat for IERC20;\\n    using LibAddress for address payable;\\n\\n    error OnlyAuthorityError();\\n    error OnlySelfError();\\n    error UnauthorizedToBurnError();\\n    error FixedRageQuitTimestampError(uint40 rageQuitTimestamp);\\n    error CannotRageQuitError(uint40 rageQuitTimestamp);\\n    error CannotDisableRageQuitAfterInitializationError();\\n    error InvalidTokenOrderError();\\n    error BelowMinWithdrawAmountError(uint256 amount, uint256 minAmount);\\n    error NothingToBurnError();\\n\\n    event AuthorityAdded(address indexed authority);\\n    event AuthorityRemoved(address indexed authority);\\n    event RageQuitSet(uint40 oldRageQuitTimestamp, uint40 newRageQuitTimestamp);\\n    event Burn(address caller, uint256 tokenId, uint256 votingPower);\\n    event RageQuit(address caller, uint256[] tokenIds, IERC20[] withdrawTokens, address receiver);\\n\\n    uint40 private constant ENABLE_RAGEQUIT_PERMANENTLY = 0x6b5b567bfe; // uint40(uint256(keccak256(\\\"ENABLE_RAGEQUIT_PERMANENTLY\\\")))\\n    uint40 private constant DISABLE_RAGEQUIT_PERMANENTLY = 0xab2cb21860; // uint40(uint256(keccak256(\\\"DISABLE_RAGEQUIT_PERMANENTLY\\\")))\\n\\n    // Token address used to indicate ETH.\\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and its address will never change.\\n    IGlobals private immutable _GLOBALS;\\n\\n    /// @notice The number of tokens that have been minted.\\n    uint96 public tokenCount;\\n    /// @notice The total minted voting power.\\n    ///         Capped to `_governanceValues.totalVotingPower` unless minting\\n    ///         party cards for initial crowdfund.\\n    uint96 public mintedVotingPower;\\n    /// @notice The timestamp until which ragequit is enabled. Can be set to the\\n    ///         `ENABLE_RAGEQUIT_PERMANENTLY`/`DISABLE_RAGEQUIT_PERMANENTLY`\\n    ///         values to enable/disable ragequit permanently.\\n    ///         `DISABLE_RAGEQUIT_PERMANENTLY` can only be set during\\n    ///         initialization.\\n    uint40 public rageQuitTimestamp;\\n    /// @notice The voting power of `tokenId`.\\n    mapping(uint256 => uint256) public votingPowerByTokenId;\\n    /// @notice Address with authority to mint cards and update voting power for the party.\\n    mapping(address => bool) public isAuthority;\\n\\n    modifier onlyAuthority() {\\n        if (!isAuthority[msg.sender]) {\\n            revert OnlyAuthorityError();\\n        }\\n        _;\\n    }\\n\\n    modifier onlySelf() {\\n        if (msg.sender != address(this)) {\\n            revert OnlySelfError();\\n        }\\n        _;\\n    }\\n\\n    // Set the `Globals` contract. The name or symbol of ERC721 does not matter;\\n    // it will be set in `_initialize()`.\\n    constructor(IGlobals globals) payable PartyGovernance(globals) ERC721(\\\"\\\", \\\"\\\") {\\n        _GLOBALS = globals;\\n    }\\n\\n    // Initialize storage for proxy contracts.\\n    function _initialize(\\n        string memory name_,\\n        string memory symbol_,\\n        uint256 customizationPresetId,\\n        PartyGovernance.GovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds,\\n        address[] memory authorities,\\n        uint40 rageQuitTimestamp_\\n    ) internal {\\n        PartyGovernance._initialize(\\n            governanceOpts,\\n            proposalEngineOpts,\\n            preciousTokens,\\n            preciousTokenIds\\n        );\\n        name = name_;\\n        symbol = symbol_;\\n        rageQuitTimestamp = rageQuitTimestamp_;\\n        unchecked {\\n            for (uint256 i; i < authorities.length; ++i) {\\n                isAuthority[authorities[i]] = true;\\n            }\\n        }\\n        if (customizationPresetId != 0) {\\n            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))\\n                .useCustomizationPreset(customizationPresetId);\\n        }\\n    }\\n\\n    /// @inheritdoc ERC721\\n    function ownerOf(uint256 tokenId) public view override returns (address owner) {\\n        return ERC721.ownerOf(tokenId);\\n    }\\n\\n    /// @inheritdoc EIP165\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public pure override(PartyGovernance, ERC721, IERC165) returns (bool) {\\n        return\\n            PartyGovernance.supportsInterface(interfaceId) ||\\n            ERC721.supportsInterface(interfaceId) ||\\n            interfaceId == type(IERC2981).interfaceId;\\n    }\\n\\n    /// @inheritdoc ERC721\\n    function tokenURI(uint256) public view override returns (string memory) {\\n        _delegateToRenderer();\\n        return \\\"\\\"; // Just to make the compiler happy.\\n    }\\n\\n    /// @notice Returns a URI for the storefront-level metadata for your contract.\\n    function contractURI() external view returns (string memory) {\\n        _delegateToRenderer();\\n        return \\\"\\\"; // Just to make the compiler happy.\\n    }\\n\\n    /// @notice Called with the sale price to determine how much royalty\\n    //          is owed and to whom.\\n    function royaltyInfo(uint256, uint256) external view returns (address, uint256) {\\n        _delegateToRenderer();\\n        return (address(0), 0); // Just to make the compiler happy.\\n    }\\n\\n    /// @notice Return the distribution share amount of a token. Included as an alias\\n    ///         for `votePowerByTokenId` for backwards compatibility with old\\n    ///         `TokenDistributor` implementations.\\n    /// @param tokenId The token ID to query.\\n    /// @return share The distribution shares of `tokenId`.\\n    function getDistributionShareOf(uint256 tokenId) public view returns (uint256) {\\n        return votingPowerByTokenId[tokenId];\\n    }\\n\\n    /// @notice Return the voting power share of a token. Denominated\\n    ///         fractions of 1e18. I.e., 1e18 = 100%.\\n    /// @param tokenId The token ID to query.\\n    /// @return share The voting power percentage of `tokenId`.\\n    function getVotingPowerShareOf(uint256 tokenId) public view returns (uint256) {\\n        uint256 totalVotingPower = _governanceValues.totalVotingPower;\\n        return\\n            totalVotingPower == 0 ? 0 : (votingPowerByTokenId[tokenId] * 1e18) / totalVotingPower;\\n    }\\n\\n    /// @notice Mint a governance NFT for `owner` with `votingPower` and\\n    ///         immediately delegate voting power to `delegate.` Only callable\\n    ///         by an authority.\\n    /// @param owner The owner of the NFT.\\n    /// @param votingPower The voting power of the NFT.\\n    /// @param delegate The address to delegate voting power to.\\n    function mint(\\n        address owner,\\n        uint256 votingPower,\\n        address delegate\\n    ) external onlyAuthority returns (uint256 tokenId) {\\n        uint96 mintedVotingPower_ = mintedVotingPower;\\n        uint96 totalVotingPower = _governanceValues.totalVotingPower;\\n\\n        // Cap voting power to remaining unminted voting power supply.\\n        uint96 votingPower_ = votingPower.safeCastUint256ToUint96();\\n        // Allow minting past total voting power if minting party cards for\\n        // initial crowdfund when there is no total voting power.\\n        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower_) {\\n            unchecked {\\n                votingPower_ = totalVotingPower - mintedVotingPower_;\\n            }\\n        }\\n\\n        // Update state.\\n        unchecked {\\n            tokenId = ++tokenCount;\\n        }\\n        mintedVotingPower += votingPower_;\\n        votingPowerByTokenId[tokenId] = votingPower_;\\n\\n        // Use delegate from party over the one set during crowdfund.\\n        address delegate_ = delegationsByVoter[owner];\\n        if (delegate_ != address(0)) {\\n            delegate = delegate_;\\n        }\\n\\n        _adjustVotingPower(owner, votingPower_.safeCastUint96ToInt192(), delegate);\\n        _safeMint(owner, tokenId);\\n    }\\n\\n    /// @notice Add voting power to an existing NFT. Only callable by an\\n    ///         authority.\\n    /// @param tokenId The ID of the NFT to add voting power to.\\n    /// @param votingPower The amount of voting power to add.\\n    function addVotingPower(uint256 tokenId, uint256 votingPower) external onlyAuthority {\\n        uint96 mintedVotingPower_ = mintedVotingPower;\\n        uint96 totalVotingPower = _governanceValues.totalVotingPower;\\n        // Cap voting power to remaining unminted voting power supply.\\n        uint96 votingPower_ = votingPower.safeCastUint256ToUint96();\\n        // Allow minting past total voting power if minting party cards for\\n        // initial crowdfund when there is no total voting power.\\n        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower_) {\\n            unchecked {\\n                votingPower_ = totalVotingPower - mintedVotingPower_;\\n            }\\n        }\\n\\n        // Update state.\\n        mintedVotingPower += votingPower_;\\n        votingPowerByTokenId[tokenId] += votingPower_;\\n\\n        _adjustVotingPower(ownerOf(tokenId), votingPower_.safeCastUint96ToInt192(), address(0));\\n    }\\n\\n    /// @notice Update the total voting power of the party. Only callable by\\n    ///         an authority.\\n    /// @param newVotingPower The new total voting power to add.\\n    function increaseTotalVotingPower(uint96 newVotingPower) external onlyAuthority {\\n        _governanceValues.totalVotingPower += newVotingPower;\\n    }\\n\\n    /// @notice Burn governance NFTs and remove their voting power. Can only\\n    ///         be called by an authority before the party has started.\\n    /// @param tokenIds The IDs of the governance NFTs to burn.\\n    function burn(uint256[] memory tokenIds) public onlyAuthority {\\n        // Authority needs to be able to burn cards during the initial\\n        // crowdfund to process refunds but not after the party has started.\\n        if (_governanceValues.totalVotingPower != 0) revert UnauthorizedToBurnError();\\n\\n        // Used to update voting power state of party at the end.\\n        _burnAndUpdateVotingPower(tokenIds, false);\\n    }\\n\\n    function _burnAndUpdateVotingPower(\\n        uint256[] memory tokenIds,\\n        bool checkIfAuthorizedToBurn\\n    ) private returns (uint96 totalVotingPowerBurned) {\\n        for (uint256 i; i < tokenIds.length; ++i) {\\n            uint256 tokenId = tokenIds[i];\\n\\n            // Check if caller is authorized to burn the token.\\n            address owner = ownerOf(tokenId);\\n            if (checkIfAuthorizedToBurn) {\\n                if (\\n                    msg.sender != owner &&\\n                    getApproved[tokenId] != msg.sender &&\\n                    !isApprovedForAll[owner][msg.sender]\\n                ) {\\n                    revert UnauthorizedToBurnError();\\n                }\\n            }\\n\\n            // Must be retrieved before updating voting power for token to be burned.\\n            uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();\\n\\n            totalVotingPowerBurned += votingPower;\\n\\n            // Update voting power for token to be burned.\\n            delete votingPowerByTokenId[tokenId];\\n            _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));\\n\\n            // Burn token.\\n            _burn(tokenId);\\n\\n            emit Burn(msg.sender, tokenId, votingPower);\\n        }\\n\\n        // Update minted voting power.\\n        mintedVotingPower -= totalVotingPowerBurned;\\n    }\\n\\n    /// @notice Burn governance NFT and remove its voting power. Can only be\\n    ///         called by an authority before the party has started.\\n    /// @param tokenId The ID of the governance NFTs to burn.\\n    function burn(uint256 tokenId) external {\\n        uint256[] memory tokenIds = new uint256[](1);\\n        tokenIds[0] = tokenId;\\n        burn(tokenIds);\\n    }\\n\\n    /// @notice Set the timestamp until which ragequit is enabled.\\n    /// @param newRageQuitTimestamp The new ragequit timestamp.\\n    function setRageQuit(uint40 newRageQuitTimestamp) external onlyHost {\\n        // Prevent disabling ragequit after initialization.\\n        if (newRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY) {\\n            revert CannotDisableRageQuitAfterInitializationError();\\n        }\\n\\n        uint40 oldRageQuitTimestamp = rageQuitTimestamp;\\n\\n        // Prevent setting timestamp if it is permanently enabled/disabled.\\n        if (\\n            oldRageQuitTimestamp == ENABLE_RAGEQUIT_PERMANENTLY ||\\n            oldRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY\\n        ) {\\n            revert FixedRageQuitTimestampError(oldRageQuitTimestamp);\\n        }\\n\\n        emit RageQuitSet(oldRageQuitTimestamp, rageQuitTimestamp = newRageQuitTimestamp);\\n    }\\n\\n    /// @notice Burn a governance NFT and withdraw a fair share of fungible tokens from the party.\\n    /// @param tokenIds The IDs of the governance NFTs to burn.\\n    /// @param withdrawTokens The fungible tokens to withdraw. Specify the\\n    ///                       `ETH_ADDRESS` value to withdraw ETH.\\n    /// @param minWithdrawAmounts The minimum amount of to withdraw for each token.\\n    /// @param receiver The address to receive the withdrawn tokens.\\n    function rageQuit(\\n        uint256[] calldata tokenIds,\\n        IERC20[] calldata withdrawTokens,\\n        uint256[] calldata minWithdrawAmounts,\\n        address receiver\\n    ) external {\\n        if (tokenIds.length == 0) revert NothingToBurnError();\\n\\n        // Check if ragequit is allowed.\\n        uint40 currentRageQuitTimestamp = rageQuitTimestamp;\\n        if (currentRageQuitTimestamp != ENABLE_RAGEQUIT_PERMANENTLY) {\\n            if (\\n                currentRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY ||\\n                currentRageQuitTimestamp < block.timestamp\\n            ) {\\n                revert CannotRageQuitError(currentRageQuitTimestamp);\\n            }\\n        }\\n\\n        // Used as a reentrancy guard. Will be updated back after ragequit.\\n        rageQuitTimestamp = DISABLE_RAGEQUIT_PERMANENTLY;\\n\\n        // Update last rage quit timestamp.\\n        lastRageQuitTimestamp = uint40(block.timestamp);\\n\\n        // Sum up total amount of each token to withdraw.\\n        uint256[] memory withdrawAmounts = new uint256[](withdrawTokens.length);\\n        {\\n            IERC20 prevToken;\\n            for (uint256 i; i < withdrawTokens.length; ++i) {\\n                IERC20 token = withdrawTokens[i];\\n\\n                // Check if order of tokens to transfer is valid.\\n                // Prevent null and duplicate transfers.\\n                if (prevToken >= token) revert InvalidTokenOrderError();\\n\\n                prevToken = token;\\n\\n                // Check token's balance.\\n                uint256 balance = address(token) == ETH_ADDRESS\\n                    ? address(this).balance\\n                    : token.balanceOf(address(this));\\n\\n                // Add fair share of tokens from the party to total.\\n                for (uint256 j; j < tokenIds.length; ++j) {\\n                    // Must be retrieved before burning the token.\\n                    uint256 shareOfVotingPower = getVotingPowerShareOf(tokenIds[j]);\\n\\n                    withdrawAmounts[i] += (balance * shareOfVotingPower) / 1e18;\\n                }\\n            }\\n        }\\n        {\\n            // Burn caller's party cards. This will revert if caller is not the\\n            // the owner or approved for any of the card they are attempting to\\n            // burn or if there are duplicate token IDs.\\n            uint96 totalVotingPowerBurned = _burnAndUpdateVotingPower(tokenIds, true);\\n\\n            // Update total voting power of party.\\n            _governanceValues.totalVotingPower -= totalVotingPowerBurned;\\n        }\\n        {\\n            uint16 feeBps_ = feeBps;\\n            for (uint256 i; i < withdrawTokens.length; ++i) {\\n                IERC20 token = withdrawTokens[i];\\n                uint256 amount = withdrawAmounts[i];\\n\\n                // Take fee from amount.\\n                uint256 fee = (amount * feeBps_) / 1e4;\\n\\n                if (fee > 0) {\\n                    amount -= fee;\\n\\n                    // Transfer fee to fee recipient.\\n                    if (address(token) == ETH_ADDRESS) {\\n                        payable(feeRecipient).transferEth(fee);\\n                    } else {\\n                        token.compatTransfer(feeRecipient, fee);\\n                    }\\n                }\\n\\n                if (amount > 0) {\\n                    uint256 minAmount = minWithdrawAmounts[i];\\n\\n                    // Check amount is at least minimum.\\n                    if (amount < minAmount) {\\n                        revert BelowMinWithdrawAmountError(amount, minAmount);\\n                    }\\n\\n                    // Transfer token from party to recipient.\\n                    if (address(token) == ETH_ADDRESS) {\\n                        payable(receiver).transferEth(amount);\\n                    } else {\\n                        token.compatTransfer(receiver, amount);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Update ragequit timestamp back to before.\\n        rageQuitTimestamp = currentRageQuitTimestamp;\\n\\n        emit RageQuit(msg.sender, tokenIds, withdrawTokens, receiver);\\n    }\\n\\n    /// @inheritdoc ERC721\\n    function transferFrom(address owner, address to, uint256 tokenId) public override {\\n        // Transfer voting along with token.\\n        _transferVotingPower(owner, to, votingPowerByTokenId[tokenId]);\\n        super.transferFrom(owner, to, tokenId);\\n    }\\n\\n    /// @inheritdoc ERC721\\n    function safeTransferFrom(address owner, address to, uint256 tokenId) public override {\\n        // super.safeTransferFrom() will call transferFrom() first which will\\n        // transfer voting power.\\n        super.safeTransferFrom(owner, to, tokenId);\\n    }\\n\\n    /// @inheritdoc ERC721\\n    function safeTransferFrom(\\n        address owner,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) public override {\\n        // super.safeTransferFrom() will call transferFrom() first which will\\n        // transfer voting power.\\n        super.safeTransferFrom(owner, to, tokenId, data);\\n    }\\n\\n    /// @notice Add a new authority.\\n    /// @dev Used in `AddAuthorityProposal`. Only the party itself can add\\n    ///      authorities to prevent it from being used anywhere else.\\n    function addAuthority(address authority) external onlySelf {\\n        isAuthority[authority] = true;\\n\\n        emit AuthorityAdded(authority);\\n    }\\n\\n    /// @notice Relinquish the authority role.\\n    function abdicateAuthority() external onlyAuthority {\\n        delete isAuthority[msg.sender];\\n\\n        emit AuthorityRemoved(msg.sender);\\n    }\\n\\n    function _delegateToRenderer() private view {\\n        _readOnlyDelegateCall(\\n            // Instance of IERC721Renderer.\\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_GOVERNANCE_NFT_RENDER_IMPL),\\n            msg.data\\n        );\\n        assert(false); // Will not be reached.\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/party/PartyGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../distribution/ITokenDistributor.sol\\\";\\nimport \\\"../utils/ReadOnlyDelegateCall.sol\\\";\\nimport \\\"../tokens/IERC721.sol\\\";\\nimport \\\"../tokens/IERC20.sol\\\";\\nimport \\\"../tokens/ERC721Receiver.sol\\\";\\nimport \\\"../tokens/ERC1155Receiver.sol\\\";\\nimport \\\"../utils/LibERC20Compat.sol\\\";\\nimport \\\"../utils/LibRawResult.sol\\\";\\nimport \\\"../utils/LibSafeCast.sol\\\";\\nimport \\\"../utils/IERC4906.sol\\\";\\nimport \\\"../globals/IGlobals.sol\\\";\\nimport \\\"../globals/LibGlobals.sol\\\";\\nimport \\\"../proposals/IProposalExecutionEngine.sol\\\";\\nimport \\\"../proposals/LibProposal.sol\\\";\\nimport \\\"../proposals/ProposalStorage.sol\\\";\\n\\nimport \\\"./Party.sol\\\";\\n\\n/// @notice Base contract for a Party encapsulating all governance functionality.\\nabstract contract PartyGovernance is\\n    ERC721Receiver,\\n    ERC1155Receiver,\\n    ProposalStorage,\\n    Implementation,\\n    IERC4906,\\n    ReadOnlyDelegateCall\\n{\\n    using LibERC20Compat for IERC20;\\n    using LibRawResult for bytes;\\n    using LibSafeCast for uint256;\\n    using LibSafeCast for int192;\\n    using LibSafeCast for uint96;\\n\\n    // States a proposal can be in.\\n    enum ProposalStatus {\\n        // The proposal does not exist.\\n        Invalid,\\n        // The proposal has been proposed (via `propose()`), has not been vetoed\\n        // by a party host, and is within the voting window. Members can vote on\\n        // the proposal and party hosts can veto the proposal.\\n        Voting,\\n        // The proposal has either exceeded its voting window without reaching\\n        // `passThresholdBps` of votes or was vetoed by a party host.\\n        Defeated,\\n        // The proposal reached at least `passThresholdBps` of votes but is still\\n        // waiting for `executionDelay` to pass before it can be executed. Members\\n        // can continue to vote on the proposal and party hosts can veto at this time.\\n        Passed,\\n        // Same as `Passed` but now `executionDelay` has been satisfied. Any member\\n        // may execute the proposal via `execute()`, unless `maxExecutableTime`\\n        // has arrived.\\n        Ready,\\n        // The proposal has been executed at least once but has further steps to\\n        // complete so it needs to be executed again. No other proposals may be\\n        // executed while a proposal is in the `InProgress` state. No voting or\\n        // vetoing of the proposal is allowed, however it may be forcibly cancelled\\n        // via `cancel()` if the `cancelDelay` has passed since being first executed.\\n        InProgress,\\n        // The proposal was executed and completed all its steps. No voting or\\n        // vetoing can occur and it cannot be cancelled nor executed again.\\n        Complete,\\n        // The proposal was executed at least once but did not complete before\\n        // `cancelDelay` seconds passed since the first execute and was forcibly cancelled.\\n        Cancelled\\n    }\\n\\n    struct GovernanceOpts {\\n        // Address of initial party hosts.\\n        address[] hosts;\\n        // How long people can vote on a proposal.\\n        uint40 voteDuration;\\n        // How long to wait after a proposal passes before it can be\\n        // executed.\\n        uint40 executionDelay;\\n        // Minimum ratio of accept votes to consider a proposal passed,\\n        // in bps, where 10,000 == 100%.\\n        uint16 passThresholdBps;\\n        // Total voting power of governance NFTs.\\n        uint96 totalVotingPower;\\n        // Fee bps for distributions.\\n        uint16 feeBps;\\n        // Fee recipeint for distributions.\\n        address payable feeRecipient;\\n    }\\n\\n    // Subset of `GovernanceOpts` that are commonly read together for\\n    // efficiency.\\n    struct GovernanceValues {\\n        uint40 voteDuration;\\n        uint40 executionDelay;\\n        uint16 passThresholdBps;\\n        uint96 totalVotingPower;\\n    }\\n\\n    // A snapshot of voting power for a member.\\n    struct VotingPowerSnapshot {\\n        // The timestamp when the snapshot was taken.\\n        uint40 timestamp;\\n        // Voting power that was delegated to this user by others.\\n        uint96 delegatedVotingPower;\\n        // The intrinsic (not delegated from someone else) voting power of this user.\\n        uint96 intrinsicVotingPower;\\n        // Whether the user was delegated to another at this snapshot.\\n        bool isDelegated;\\n    }\\n\\n    // Proposal details chosen by proposer.\\n    struct Proposal {\\n        // Time beyond which the proposal can no longer be executed.\\n        // If the proposal has already been executed, and is still InProgress,\\n        // this value is ignored.\\n        uint40 maxExecutableTime;\\n        // The minimum seconds this proposal can remain in the InProgress status\\n        // before it can be cancelled.\\n        uint40 cancelDelay;\\n        // Encoded proposal data. The first 4 bytes are the proposal type, followed\\n        // by encoded proposal args specific to the proposal type. See\\n        // ProposalExecutionEngine for details.\\n        bytes proposalData;\\n    }\\n\\n    // Accounting and state tracking values for a proposal.\\n    struct ProposalStateValues {\\n        // When the proposal was proposed.\\n        uint40 proposedTime;\\n        // When the proposal passed the vote.\\n        uint40 passedTime;\\n        // When the proposal was first executed.\\n        uint40 executedTime;\\n        // When the proposal completed.\\n        uint40 completedTime;\\n        // Number of accept votes.\\n        uint96 votes; // -1 == vetoed\\n        // Number of total voting power at time proposal created.\\n        uint96 totalVotingPower;\\n    }\\n\\n    // Storage states for a proposal.\\n    struct ProposalState {\\n        // Accounting and state tracking values.\\n        ProposalStateValues values;\\n        // Hash of the proposal.\\n        bytes32 hash;\\n        // Whether a member has voted for (accepted) this proposal already.\\n        mapping(address => bool) hasVoted;\\n    }\\n\\n    event Proposed(uint256 proposalId, address proposer, Proposal proposal);\\n    event ProposalAccepted(uint256 proposalId, address voter, uint256 weight);\\n    event EmergencyExecute(address target, bytes data, uint256 amountEth);\\n\\n    event ProposalPassed(uint256 indexed proposalId);\\n    event ProposalVetoed(uint256 indexed proposalId, address host);\\n    event ProposalExecuted(uint256 indexed proposalId, address executor, bytes nextProgressData);\\n    event ProposalCancelled(uint256 indexed proposalId);\\n    event DistributionCreated(\\n        ITokenDistributor.TokenType tokenType,\\n        address token,\\n        uint256 tokenId\\n    );\\n    event VotingPowerDelegated(address indexed owner, address indexed delegate);\\n    event HostStatusTransferred(address oldHost, address newHost);\\n    event EmergencyExecuteDisabled();\\n\\n    error MismatchedPreciousListLengths();\\n    error BadProposalStatusError(ProposalStatus status);\\n    error BadProposalHashError(bytes32 proposalHash, bytes32 actualHash);\\n    error ExecutionTimeExceededError(uint40 maxExecutableTime, uint40 timestamp);\\n    error OnlyPartyHostError();\\n    error OnlyActiveMemberError();\\n    error OnlyTokenDistributorOrSelfError();\\n    error InvalidDelegateError();\\n    error BadPreciousListError();\\n    error OnlyPartyDaoError(address notDao, address partyDao);\\n    error OnlyPartyDaoOrHostError(address notDao, address partyDao);\\n    error OnlyWhenEmergencyActionsAllowedError();\\n    error OnlyWhenEnabledError();\\n    error AlreadyVotedError(address voter);\\n    error InvalidNewHostError();\\n    error ProposalCannotBeCancelledYetError(uint40 currentTime, uint40 cancelTime);\\n    error InvalidBpsError(uint16 bps);\\n    error DistributionsRequireVoteError();\\n    error PartyNotStartedError();\\n    error CannotRageQuitAndAcceptError();\\n\\n    uint256 private constant UINT40_HIGH_BIT = 1 << 39;\\n    uint96 private constant VETO_VALUE = type(uint96).max;\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and it\u2019s address will never change.\\n    IGlobals private immutable _GLOBALS;\\n\\n    /// @notice Whether the DAO has emergency powers for this party.\\n    bool public emergencyExecuteDisabled;\\n    /// @notice Distribution fee bps.\\n    uint16 public feeBps;\\n    /// @notice Distribution fee recipient.\\n    address payable public feeRecipient;\\n    /// @notice The timestamp of the last time `rageQuit()` was called.\\n    uint40 public lastRageQuitTimestamp;\\n    /// @notice The hash of the list of precious NFTs guarded by the party.\\n    bytes32 public preciousListHash;\\n    /// @notice The last proposal ID that was used. 0 means no proposals have been made.\\n    uint256 public lastProposalId;\\n    /// @notice Whether an address is a party host.\\n    mapping(address => bool) public isHost;\\n    /// @notice The last person a voter delegated its voting power to.\\n    mapping(address => address) public delegationsByVoter;\\n    // Governance parameters for this party.\\n    GovernanceValues internal _governanceValues;\\n    // ProposalState by proposal ID.\\n    mapping(uint256 => ProposalState) private _proposalStateByProposalId;\\n    // Snapshots of voting power per user, each sorted by increasing time.\\n    mapping(address => VotingPowerSnapshot[]) private _votingPowerSnapshotsByVoter;\\n\\n    modifier onlyHost() {\\n        if (!isHost[msg.sender]) {\\n            revert OnlyPartyHostError();\\n        }\\n        _;\\n    }\\n\\n    // Caller must have voting power at the current time.\\n    modifier onlyActiveMember() {\\n        {\\n            VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);\\n            // Must have either delegated voting power or intrinsic voting power.\\n            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {\\n                revert OnlyActiveMemberError();\\n            }\\n        }\\n        _;\\n    }\\n\\n    // Only the party DAO multisig can call.\\n    modifier onlyPartyDao() {\\n        {\\n            address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\\n            if (msg.sender != partyDao) {\\n                revert OnlyPartyDaoError(msg.sender, partyDao);\\n            }\\n        }\\n        _;\\n    }\\n\\n    // Only the party DAO multisig or a party host can call.\\n    modifier onlyPartyDaoOrHost() {\\n        address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\\n        if (msg.sender != partyDao && !isHost[msg.sender]) {\\n            revert OnlyPartyDaoOrHostError(msg.sender, partyDao);\\n        }\\n        _;\\n    }\\n\\n    // Only if `emergencyExecuteDisabled` is not true.\\n    modifier onlyWhenEmergencyExecuteAllowed() {\\n        if (emergencyExecuteDisabled) {\\n            revert OnlyWhenEmergencyActionsAllowedError();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyWhenNotGloballyDisabled() {\\n        if (_GLOBALS.getBool(LibGlobals.GLOBAL_DISABLE_PARTY_ACTIONS)) {\\n            revert OnlyWhenEnabledError();\\n        }\\n        _;\\n    }\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) {\\n        _GLOBALS = globals;\\n    }\\n\\n    // Initialize storage for proxy contracts and initialize the proposal execution engine.\\n    function _initialize(\\n        GovernanceOpts memory govOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds\\n    ) internal virtual {\\n        // Check BPS are valid.\\n        if (govOpts.feeBps > 1e4) {\\n            revert InvalidBpsError(govOpts.feeBps);\\n        }\\n        if (govOpts.passThresholdBps > 1e4) {\\n            revert InvalidBpsError(govOpts.passThresholdBps);\\n        }\\n        // Initialize the proposal execution engine.\\n        _initProposalImpl(\\n            IProposalExecutionEngine(_GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)),\\n            abi.encode(proposalEngineOpts)\\n        );\\n        // Set the governance parameters.\\n        _governanceValues = GovernanceValues({\\n            voteDuration: govOpts.voteDuration,\\n            executionDelay: govOpts.executionDelay,\\n            passThresholdBps: govOpts.passThresholdBps,\\n            totalVotingPower: govOpts.totalVotingPower\\n        });\\n        // Set fees.\\n        feeBps = govOpts.feeBps;\\n        feeRecipient = govOpts.feeRecipient;\\n        // Set the precious list.\\n        _setPreciousList(preciousTokens, preciousTokenIds);\\n        // Set the party hosts.\\n        for (uint256 i = 0; i < govOpts.hosts.length; ++i) {\\n            isHost[govOpts.hosts[i]] = true;\\n        }\\n    }\\n\\n    /// @dev Forward all unknown read-only calls to the proposal execution engine.\\n    ///      Initial use case is to facilitate eip-1271 signatures.\\n    fallback() external {\\n        _readOnlyDelegateCall(address(_getSharedProposalStorage().engineImpl), msg.data);\\n    }\\n\\n    /// @inheritdoc EIP165\\n    /// @dev Combined logic for `ERC721Receiver` and `ERC1155Receiver`.\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public pure virtual override(ERC721Receiver, ERC1155Receiver) returns (bool) {\\n        return\\n            ERC721Receiver.supportsInterface(interfaceId) ||\\n            ERC1155Receiver.supportsInterface(interfaceId) ||\\n            // ERC4906 interface ID\\n            interfaceId == 0x49064906;\\n    }\\n\\n    /// @notice Get the current `ProposalExecutionEngine` instance.\\n    function getProposalExecutionEngine() external view returns (IProposalExecutionEngine) {\\n        return _getSharedProposalStorage().engineImpl;\\n    }\\n\\n    /// @notice Get the current `ProposalEngineOpts` options.\\n    function getProposalEngineOpts() external view returns (ProposalEngineOpts memory) {\\n        return _getSharedProposalStorage().opts;\\n    }\\n\\n    /// @notice Get the total voting power of `voter` at a `timestamp`.\\n    /// @param voter The address of the voter.\\n    /// @param timestamp The timestamp to get the voting power at.\\n    /// @return votingPower The total voting power of `voter` at `timestamp`.\\n    function getVotingPowerAt(\\n        address voter,\\n        uint40 timestamp\\n    ) external view returns (uint96 votingPower) {\\n        return getVotingPowerAt(voter, timestamp, type(uint256).max);\\n    }\\n\\n    /// @notice Get the total voting power of `voter` at a snapshot `snapIndex`, with checks to\\n    ///         make sure it is the latest voting snapshot =< `timestamp`.\\n    /// @param voter The address of the voter.\\n    /// @param timestamp The timestamp to get the voting power at.\\n    /// @param snapIndex The index of the snapshot to get the voting power at.\\n    /// @return votingPower The total voting power of `voter` at `timestamp`.\\n    function getVotingPowerAt(\\n        address voter,\\n        uint40 timestamp,\\n        uint256 snapIndex\\n    ) public view returns (uint96 votingPower) {\\n        VotingPowerSnapshot memory snap = _getVotingPowerSnapshotAt(voter, timestamp, snapIndex);\\n        return (snap.isDelegated ? 0 : snap.intrinsicVotingPower) + snap.delegatedVotingPower;\\n    }\\n\\n    /// @notice Get the state of a proposal.\\n    /// @param proposalId The ID of the proposal.\\n    /// @return status The status of the proposal.\\n    /// @return values The state of the proposal.\\n    function getProposalStateInfo(\\n        uint256 proposalId\\n    ) external view returns (ProposalStatus status, ProposalStateValues memory values) {\\n        values = _proposalStateByProposalId[proposalId].values;\\n        status = _getProposalStatus(values);\\n    }\\n\\n    /// @notice Retrieve fixed governance parameters.\\n    /// @return gv The governance parameters of this party.\\n    function getGovernanceValues() external view returns (GovernanceValues memory gv) {\\n        return _governanceValues;\\n    }\\n\\n    /// @notice Get the hash of a proposal.\\n    /// @dev Proposal details are not stored on-chain so the hash is used to enforce\\n    ///      consistency between calls.\\n    /// @param proposal The proposal to hash.\\n    /// @return proposalHash The hash of the proposal.\\n    function getProposalHash(Proposal memory proposal) public pure returns (bytes32 proposalHash) {\\n        // Hash the proposal in-place. Equivalent to:\\n        // keccak256(abi.encode(\\n        //   proposal.maxExecutableTime,\\n        //   proposal.cancelDelay,\\n        //   keccak256(proposal.proposalData)\\n        // ))\\n        bytes32 dataHash = keccak256(proposal.proposalData);\\n        assembly {\\n            // Overwrite the data field with the hash of its contents and then\\n            // hash the struct.\\n            let dataPos := add(proposal, 0x40)\\n            let t := mload(dataPos)\\n            mstore(dataPos, dataHash)\\n            proposalHash := keccak256(proposal, 0x60)\\n            // Restore the data field.\\n            mstore(dataPos, t)\\n        }\\n    }\\n\\n    /// @notice Get the index of the most recent voting power snapshot <= `timestamp`.\\n    /// @param voter The address of the voter.\\n    /// @param timestamp The timestamp to get the snapshot index at.\\n    /// @return index The index of the snapshot.\\n    function findVotingPowerSnapshotIndex(\\n        address voter,\\n        uint40 timestamp\\n    ) public view returns (uint256 index) {\\n        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];\\n\\n        // Derived from Open Zeppelin binary search\\n        // ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Checkpoints.sol#L39\\n        uint256 high = snaps.length;\\n        uint256 low = 0;\\n        while (low < high) {\\n            uint256 mid = (low + high) / 2;\\n            if (snaps[mid].timestamp > timestamp) {\\n                // Entry is too recent.\\n                high = mid;\\n            } else {\\n                // Entry is older. This is our best guess for now.\\n                low = mid + 1;\\n            }\\n        }\\n\\n        // Return `type(uint256).max` if no valid voting snapshots found.\\n        return high == 0 ? type(uint256).max : high - 1;\\n    }\\n\\n    /// @notice Pledge your intrinsic voting power to a new delegate, removing it from\\n    ///         the old one (if any).\\n    /// @param delegate The address to delegating voting power to.\\n    function delegateVotingPower(address delegate) external {\\n        _adjustVotingPower(msg.sender, 0, delegate);\\n        emit VotingPowerDelegated(msg.sender, delegate);\\n    }\\n\\n    /// @notice Transfer party host status to another.\\n    /// @param newPartyHost The address of the new host.\\n    function abdicateHost(address newPartyHost) external onlyHost {\\n        // 0 is a special case burn address.\\n        if (newPartyHost != address(0)) {\\n            // Cannot transfer host status to an existing host.\\n            if (isHost[newPartyHost]) {\\n                revert InvalidNewHostError();\\n            }\\n            isHost[newPartyHost] = true;\\n        }\\n        isHost[msg.sender] = false;\\n        emit HostStatusTransferred(msg.sender, newPartyHost);\\n    }\\n\\n    /// @notice Create a token distribution by moving the party's entire balance\\n    ///         to the `TokenDistributor` contract and immediately creating a\\n    ///         distribution governed by this party.\\n    /// @dev The `feeBps` and `feeRecipient` this party was created with will be\\n    ///      propagated to the distribution. Party members are entitled to a\\n    ///      share of the distribution's tokens proportionate to their relative\\n    ///      voting power in this party (less the fee).\\n    /// @dev Allow this to be called by the party itself for `FractionalizeProposal`.\\n    /// @param tokenType The type of token to distribute.\\n    /// @param token The address of the token to distribute.\\n    /// @param tokenId The ID of the token to distribute. Currently unused but\\n    ///                may be used in the future to support other distribution types.\\n    /// @return distInfo The information about the created distribution.\\n    function distribute(\\n        uint256 amount,\\n        ITokenDistributor.TokenType tokenType,\\n        address token,\\n        uint256 tokenId\\n    )\\n        external\\n        onlyWhenNotGloballyDisabled\\n        returns (ITokenDistributor.DistributionInfo memory distInfo)\\n    {\\n        // Ignore if the party is calling functions on itself, like with\\n        // `FractionalizeProposal` and `DistributionProposal`.\\n        if (msg.sender != address(this)) {\\n            // Must not require a vote to create a distribution, otherwise\\n            // distributions can only be created through a distribution\\n            // proposal.\\n            if (_getSharedProposalStorage().opts.distributionsRequireVote) {\\n                revert DistributionsRequireVoteError();\\n            }\\n            // Must be an active member.\\n            VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);\\n            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {\\n                revert OnlyActiveMemberError();\\n            }\\n        }\\n        // Prevent creating a distribution if the party has not started.\\n        if (_governanceValues.totalVotingPower == 0) {\\n            revert PartyNotStartedError();\\n        }\\n        // Get the address of the token distributor.\\n        ITokenDistributor distributor = ITokenDistributor(\\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_TOKEN_DISTRIBUTOR)\\n        );\\n        emit DistributionCreated(tokenType, token, tokenId);\\n        // Notify third-party platforms that the governance NFT metadata has\\n        // updated for all tokens.\\n        emit BatchMetadataUpdate(0, type(uint256).max);\\n        // Create a native token distribution.\\n        address payable feeRecipient_ = feeRecipient;\\n        uint16 feeBps_ = feeBps;\\n        if (tokenType == ITokenDistributor.TokenType.Native) {\\n            return\\n                distributor.createNativeDistribution{ value: amount }(\\n                    Party(payable(address(this))),\\n                    feeRecipient_,\\n                    feeBps_\\n                );\\n        }\\n        // Otherwise must be an ERC20 token distribution.\\n        assert(tokenType == ITokenDistributor.TokenType.Erc20);\\n        IERC20(token).compatTransfer(address(distributor), amount);\\n        return\\n            distributor.createErc20Distribution(\\n                IERC20(token),\\n                Party(payable(address(this))),\\n                feeRecipient_,\\n                feeBps_\\n            );\\n    }\\n\\n    /// @notice Make a proposal for members to vote on and cast a vote to accept it\\n    ///         as well.\\n    /// @dev Only an active member (has voting power) can call this.\\n    ///      Afterwards, members can vote to support it with `accept()` or a party\\n    ///      host can unilaterally reject the proposal with `veto()`.\\n    /// @param proposal The details of the proposal.\\n    /// @param latestSnapIndex The index of the caller's most recent voting power\\n    ///                        snapshot before the proposal was created. Should\\n    ///                        be retrieved off-chain and passed in.\\n    function propose(\\n        Proposal memory proposal,\\n        uint256 latestSnapIndex\\n    ) external onlyActiveMember returns (uint256 proposalId) {\\n        proposalId = ++lastProposalId;\\n        // Store the time the proposal was created and the proposal hash.\\n        (\\n            _proposalStateByProposalId[proposalId].values,\\n            _proposalStateByProposalId[proposalId].hash\\n        ) = (\\n            ProposalStateValues({\\n                proposedTime: uint40(block.timestamp),\\n                passedTime: 0,\\n                executedTime: 0,\\n                completedTime: 0,\\n                votes: 0,\\n                totalVotingPower: _governanceValues.totalVotingPower\\n            }),\\n            getProposalHash(proposal)\\n        );\\n        emit Proposed(proposalId, msg.sender, proposal);\\n        accept(proposalId, latestSnapIndex);\\n\\n        // Notify third-party platforms that the governance NFT metadata has\\n        // updated for all tokens.\\n        emit BatchMetadataUpdate(0, type(uint256).max);\\n    }\\n\\n    /// @notice Vote to support a proposed proposal.\\n    /// @dev The voting power cast will be the effective voting power of the caller\\n    ///      just before `propose()` was called (see `getVotingPowerAt()`).\\n    ///      If the proposal reaches `passThresholdBps` acceptance ratio then the\\n    ///      proposal will be in the `Passed` state and will be executable after\\n    ///      the `executionDelay` has passed, putting it in the `Ready` state.\\n    /// @param proposalId The ID of the proposal to accept.\\n    /// @param snapIndex The index of the caller's last voting power snapshot\\n    ///                  before the proposal was created. Should be retrieved\\n    ///                  off-chain and passed in.\\n    /// @return totalVotes The total votes cast on the proposal.\\n    function accept(uint256 proposalId, uint256 snapIndex) public returns (uint256 totalVotes) {\\n        // Get the information about the proposal.\\n        ProposalState storage info = _proposalStateByProposalId[proposalId];\\n        ProposalStateValues memory values = info.values;\\n\\n        // Can only vote in certain proposal statuses.\\n        {\\n            ProposalStatus status = _getProposalStatus(values);\\n            // Allow voting even if the proposal is passed/ready so it can\\n            // potentially reach 100% consensus, which unlocks special\\n            // behaviors for certain proposal types.\\n            if (\\n                status != ProposalStatus.Voting &&\\n                status != ProposalStatus.Passed &&\\n                status != ProposalStatus.Ready\\n            ) {\\n                revert BadProposalStatusError(status);\\n            }\\n        }\\n\\n        // Prevent voting in the same block as the last rage quit timestamp.\\n        // This is to prevent an exploit where a member can rage quit to reduce\\n        // the total voting power of the party, then propose and vote in the\\n        // same block since `getVotingPowerAt()` uses `values.proposedTime - 1`.\\n        // This would allow them to use the voting power snapshot just before\\n        // their card was burned to vote, potentially passing a proposal that\\n        // would have otherwise not passed.\\n        if (lastRageQuitTimestamp == block.timestamp) {\\n            revert CannotRageQuitAndAcceptError();\\n        }\\n\\n        // Cannot vote twice.\\n        if (info.hasVoted[msg.sender]) {\\n            revert AlreadyVotedError(msg.sender);\\n        }\\n        // Mark the caller as having voted.\\n        info.hasVoted[msg.sender] = true;\\n\\n        // Increase the total votes that have been cast on this proposal.\\n        uint96 votingPower = getVotingPowerAt(msg.sender, values.proposedTime - 1, snapIndex);\\n        values.votes += votingPower;\\n        info.values = values;\\n        emit ProposalAccepted(proposalId, msg.sender, votingPower);\\n\\n        // Update the proposal status if it has reached the pass threshold.\\n        if (\\n            values.passedTime == 0 &&\\n            _areVotesPassing(\\n                values.votes,\\n                values.totalVotingPower,\\n                _governanceValues.passThresholdBps\\n            )\\n        ) {\\n            info.values.passedTime = uint40(block.timestamp);\\n            emit ProposalPassed(proposalId);\\n            // Notify third-party platforms that the governance NFT metadata has\\n            // updated for all tokens.\\n            emit BatchMetadataUpdate(0, type(uint256).max);\\n        }\\n        return values.votes;\\n    }\\n\\n    /// @notice As a party host, veto a proposal, unilaterally rejecting it.\\n    /// @dev The proposal will never be executable and cannot be voted on anymore.\\n    ///      A proposal that has been already executed at least once (in the `InProgress` status)\\n    ///      cannot be vetoed.\\n    /// @param proposalId The ID of the proposal to veto.\\n    function veto(uint256 proposalId) external onlyHost {\\n        // Setting `votes` to -1 indicates a veto.\\n        ProposalState storage info = _proposalStateByProposalId[proposalId];\\n        ProposalStateValues memory values = info.values;\\n\\n        {\\n            ProposalStatus status = _getProposalStatus(values);\\n            // Proposal must be in one of the following states.\\n            if (\\n                status != ProposalStatus.Voting &&\\n                status != ProposalStatus.Passed &&\\n                status != ProposalStatus.Ready\\n            ) {\\n                revert BadProposalStatusError(status);\\n            }\\n        }\\n\\n        // -1 indicates veto.\\n        info.values.votes = VETO_VALUE;\\n        emit ProposalVetoed(proposalId, msg.sender);\\n        // Notify third-party platforms that the governance NFT metadata has\\n        // updated for all tokens.\\n        emit BatchMetadataUpdate(0, type(uint256).max);\\n    }\\n\\n    /// @notice Executes a proposal that has passed governance.\\n    /// @dev The proposal must be in the `Ready` or `InProgress` status.\\n    ///      A `ProposalExecuted` event will be emitted with a non-empty `nextProgressData`\\n    ///      if the proposal has extra steps (must be executed again) to carry out,\\n    ///      in which case `nextProgressData` should be passed into the next `execute()` call.\\n    ///      The `ProposalExecutionEngine` enforces that only one `InProgress` proposal\\n    ///      is active at a time, so that proposal must be completed or cancelled via `cancel()`\\n    ///      in order to execute a different proposal.\\n    ///      `extraData` is optional, off-chain data a proposal might need to execute a step.\\n    /// @param proposalId The ID of the proposal to execute.\\n    /// @param proposal The details of the proposal.\\n    /// @param preciousTokens The tokens that the party considers precious.\\n    /// @param preciousTokenIds The token IDs associated with each precious token.\\n    /// @param progressData The data returned from the last `execute()` call, if any.\\n    /// @param extraData Off-chain data a proposal might need to execute a step.\\n    function execute(\\n        uint256 proposalId,\\n        Proposal memory proposal,\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds,\\n        bytes calldata progressData,\\n        bytes calldata extraData\\n    ) external payable onlyActiveMember onlyWhenNotGloballyDisabled onlyDelegateCall {\\n        // Get information about the proposal.\\n        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];\\n        // Proposal details must remain the same from `propose()`.\\n        _validateProposalHash(proposal, proposalState.hash);\\n        ProposalStateValues memory values = proposalState.values;\\n        ProposalStatus status = _getProposalStatus(values);\\n        // The proposal must be executable or have already been executed but still\\n        // has more steps to go.\\n        if (status != ProposalStatus.Ready && status != ProposalStatus.InProgress) {\\n            revert BadProposalStatusError(status);\\n        }\\n        if (status == ProposalStatus.Ready) {\\n            // If the proposal has not been executed yet, make sure it hasn't\\n            // expired. Note that proposals that have been executed\\n            // (but still have more steps) ignore `maxExecutableTime`.\\n            if (proposal.maxExecutableTime < block.timestamp) {\\n                revert ExecutionTimeExceededError(\\n                    proposal.maxExecutableTime,\\n                    uint40(block.timestamp)\\n                );\\n            }\\n            proposalState.values.executedTime = uint40(block.timestamp);\\n        }\\n        // Check that the precious list is valid.\\n        if (!_isPreciousListCorrect(preciousTokens, preciousTokenIds)) {\\n            revert BadPreciousListError();\\n        }\\n        // Preemptively set the proposal to completed to avoid it being executed\\n        // again in a deeper call.\\n        proposalState.values.completedTime = uint40(block.timestamp);\\n        // Execute the proposal.\\n        bool completed = _executeProposal(\\n            proposalId,\\n            proposal,\\n            preciousTokens,\\n            preciousTokenIds,\\n            _getProposalFlags(values),\\n            progressData,\\n            extraData\\n        );\\n        if (!completed) {\\n            // Proposal did not complete.\\n            proposalState.values.completedTime = 0;\\n        }\\n    }\\n\\n    /// @notice Cancel a (probably stuck) InProgress proposal.\\n    /// @dev `proposal.cancelDelay` seconds must have passed since it was first\\n    ///      executed for this to be valid. The currently active proposal will\\n    ///      simply be yeeted out of existence so another proposal can execute.\\n    ///      This is intended to be a last resort and can leave the party in a\\n    ///      broken state. Whenever possible, active proposals should be\\n    ///      allowed to complete their lifecycle.\\n    /// @param proposalId The ID of the proposal to cancel.\\n    /// @param proposal The details of the proposal to cancel.\\n    function cancel(uint256 proposalId, Proposal calldata proposal) external onlyActiveMember {\\n        // Get information about the proposal.\\n        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];\\n        // Proposal details must remain the same from `propose()`.\\n        _validateProposalHash(proposal, proposalState.hash);\\n        ProposalStateValues memory values = proposalState.values;\\n        {\\n            // Must be `InProgress`.\\n            ProposalStatus status = _getProposalStatus(values);\\n            if (status != ProposalStatus.InProgress) {\\n                revert BadProposalStatusError(status);\\n            }\\n        }\\n        {\\n            // Limit the `cancelDelay` to the global max and min cancel delay\\n            // to mitigate parties accidentally getting stuck forever by setting an\\n            // unrealistic `cancelDelay` or being reckless with too low a\\n            // cancel delay.\\n            uint256 cancelDelay = proposal.cancelDelay;\\n            uint256 globalMaxCancelDelay = _GLOBALS.getUint256(\\n                LibGlobals.GLOBAL_PROPOSAL_MAX_CANCEL_DURATION\\n            );\\n            uint256 globalMinCancelDelay = _GLOBALS.getUint256(\\n                LibGlobals.GLOBAL_PROPOSAL_MIN_CANCEL_DURATION\\n            );\\n            if (globalMaxCancelDelay != 0) {\\n                // Only if we have one set.\\n                if (cancelDelay > globalMaxCancelDelay) {\\n                    cancelDelay = globalMaxCancelDelay;\\n                }\\n            }\\n            if (globalMinCancelDelay != 0) {\\n                // Only if we have one set.\\n                if (cancelDelay < globalMinCancelDelay) {\\n                    cancelDelay = globalMinCancelDelay;\\n                }\\n            }\\n            uint256 cancelTime = values.executedTime + cancelDelay;\\n            // Must not be too early.\\n            if (block.timestamp < cancelTime) {\\n                revert ProposalCannotBeCancelledYetError(\\n                    uint40(block.timestamp),\\n                    uint40(cancelTime)\\n                );\\n            }\\n        }\\n        // Mark the proposal as cancelled by setting the completed time to the current\\n        // time with the high bit set.\\n        proposalState.values.completedTime = uint40(block.timestamp | UINT40_HIGH_BIT);\\n        {\\n            // Delegatecall into the proposal engine impl to perform the cancel.\\n            (bool success, bytes memory resultData) = (\\n                address(_getSharedProposalStorage().engineImpl)\\n            ).delegatecall(abi.encodeCall(IProposalExecutionEngine.cancelProposal, (proposalId)));\\n            if (!success) {\\n                resultData.rawRevert();\\n            }\\n        }\\n        emit ProposalCancelled(proposalId);\\n        // Notify third-party platforms that the governance NFT metadata has\\n        // updated for all tokens.\\n        emit BatchMetadataUpdate(0, type(uint256).max);\\n    }\\n\\n    /// @notice As the DAO, execute an arbitrary function call from this contract.\\n    /// @dev Emergency actions must not be revoked for this to work.\\n    /// @param targetAddress The contract to call.\\n    /// @param targetCallData The data to pass to the contract.\\n    /// @param amountEth The amount of ETH to send to the contract.\\n    function emergencyExecute(\\n        address targetAddress,\\n        bytes calldata targetCallData,\\n        uint256 amountEth\\n    ) external payable onlyPartyDao onlyWhenEmergencyExecuteAllowed onlyDelegateCall {\\n        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);\\n        if (!success) {\\n            res.rawRevert();\\n        }\\n        emit EmergencyExecute(targetAddress, targetCallData, amountEth);\\n    }\\n\\n    /// @notice Revoke the DAO's ability to call emergencyExecute().\\n    /// @dev Either the DAO or the party host can call this.\\n    function disableEmergencyExecute() external onlyPartyDaoOrHost {\\n        emergencyExecuteDisabled = true;\\n        emit EmergencyExecuteDisabled();\\n    }\\n\\n    function _executeProposal(\\n        uint256 proposalId,\\n        Proposal memory proposal,\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds,\\n        uint256 flags,\\n        bytes memory progressData,\\n        bytes memory extraData\\n    ) private returns (bool completed) {\\n        // Setup the arguments for the proposal execution engine.\\n        IProposalExecutionEngine.ExecuteProposalParams\\n            memory executeParams = IProposalExecutionEngine.ExecuteProposalParams({\\n                proposalId: proposalId,\\n                proposalData: proposal.proposalData,\\n                progressData: progressData,\\n                extraData: extraData,\\n                preciousTokens: preciousTokens,\\n                preciousTokenIds: preciousTokenIds,\\n                flags: flags\\n            });\\n        // Get the progress data returned after the proposal is executed.\\n        bytes memory nextProgressData;\\n        {\\n            // Execute the proposal.\\n            (bool success, bytes memory resultData) = address(\\n                _getSharedProposalStorage().engineImpl\\n            ).delegatecall(\\n                    abi.encodeCall(IProposalExecutionEngine.executeProposal, (executeParams))\\n                );\\n            if (!success) {\\n                resultData.rawRevert();\\n            }\\n            nextProgressData = abi.decode(resultData, (bytes));\\n        }\\n        emit ProposalExecuted(proposalId, msg.sender, nextProgressData);\\n        // Notify third-party platforms that the governance NFT metadata has\\n        // updated for all tokens.\\n        emit BatchMetadataUpdate(0, type(uint256).max);\\n        // If the returned progress data is empty, then the proposal completed\\n        // and it should not be executed again.\\n        return nextProgressData.length == 0;\\n    }\\n\\n    // Get the most recent voting power snapshot <= timestamp using `hintindex` as a \\\"hint\\\".\\n    function _getVotingPowerSnapshotAt(\\n        address voter,\\n        uint40 timestamp,\\n        uint256 hintIndex\\n    ) internal view returns (VotingPowerSnapshot memory snap) {\\n        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];\\n        uint256 snapsLength = snaps.length;\\n        if (snapsLength != 0) {\\n            if (\\n                // Hint is within bounds.\\n                hintIndex < snapsLength &&\\n                // Snapshot is not too recent.\\n                snaps[hintIndex].timestamp <= timestamp &&\\n                // Snapshot is not too old.\\n                (hintIndex == snapsLength - 1 || snaps[hintIndex + 1].timestamp > timestamp)\\n            ) {\\n                return snaps[hintIndex];\\n            }\\n\\n            // Hint was wrong, fallback to binary search to find snapshot.\\n            hintIndex = findVotingPowerSnapshotIndex(voter, timestamp);\\n            // Check that snapshot was found.\\n            if (hintIndex != type(uint256).max) {\\n                return snaps[hintIndex];\\n            }\\n        }\\n\\n        // No snapshot found.\\n        return snap;\\n    }\\n\\n    // Transfers some voting power of `from` to `to`. The total voting power of\\n    // their respective delegates will be updated as well.\\n    function _transferVotingPower(address from, address to, uint256 power) internal {\\n        int192 powerI192 = power.safeCastUint256ToInt192();\\n        _adjustVotingPower(from, -powerI192, address(0));\\n        _adjustVotingPower(to, powerI192, address(0));\\n    }\\n\\n    // Increase `voter`'s intrinsic voting power and update their delegate if delegate is nonzero.\\n    function _adjustVotingPower(address voter, int192 votingPower, address delegate) internal {\\n        VotingPowerSnapshot memory oldSnap = _getLastVotingPowerSnapshotForVoter(voter);\\n        address oldDelegate = delegationsByVoter[voter];\\n        // If `oldDelegate` is zero and `voter` never delegated, then have\\n        // `voter` delegate to themself.\\n        oldDelegate = oldDelegate == address(0) ? voter : oldDelegate;\\n        // If the new `delegate` is zero, use the current (old) delegate.\\n        delegate = delegate == address(0) ? oldDelegate : delegate;\\n\\n        VotingPowerSnapshot memory newSnap = VotingPowerSnapshot({\\n            timestamp: uint40(block.timestamp),\\n            delegatedVotingPower: oldSnap.delegatedVotingPower,\\n            intrinsicVotingPower: (oldSnap.intrinsicVotingPower.safeCastUint96ToInt192() +\\n                votingPower).safeCastInt192ToUint96(),\\n            isDelegated: delegate != voter\\n        });\\n        _insertVotingPowerSnapshot(voter, newSnap);\\n        delegationsByVoter[voter] = delegate;\\n        // Handle rebalancing delegates.\\n        _rebalanceDelegates(voter, oldDelegate, delegate, oldSnap, newSnap);\\n    }\\n\\n    // Update the delegated voting power of the old and new delegates delegated to\\n    // by `voter` based on the snapshot change.\\n    function _rebalanceDelegates(\\n        address voter,\\n        address oldDelegate,\\n        address newDelegate,\\n        VotingPowerSnapshot memory oldSnap,\\n        VotingPowerSnapshot memory newSnap\\n    ) private {\\n        if (newDelegate == address(0) || oldDelegate == address(0)) {\\n            revert InvalidDelegateError();\\n        }\\n        if (oldDelegate != voter && oldDelegate != newDelegate) {\\n            // Remove past voting power from old delegate.\\n            VotingPowerSnapshot memory oldDelegateSnap = _getLastVotingPowerSnapshotForVoter(\\n                oldDelegate\\n            );\\n            VotingPowerSnapshot memory updatedOldDelegateSnap = VotingPowerSnapshot({\\n                timestamp: uint40(block.timestamp),\\n                delegatedVotingPower: oldDelegateSnap.delegatedVotingPower -\\n                    oldSnap.intrinsicVotingPower,\\n                intrinsicVotingPower: oldDelegateSnap.intrinsicVotingPower,\\n                isDelegated: oldDelegateSnap.isDelegated\\n            });\\n            _insertVotingPowerSnapshot(oldDelegate, updatedOldDelegateSnap);\\n        }\\n        if (newDelegate != voter) {\\n            // Not delegating to self.\\n            // Add new voting power to new delegate.\\n            VotingPowerSnapshot memory newDelegateSnap = _getLastVotingPowerSnapshotForVoter(\\n                newDelegate\\n            );\\n            uint96 newDelegateDelegatedVotingPower = newDelegateSnap.delegatedVotingPower +\\n                newSnap.intrinsicVotingPower;\\n            if (newDelegate == oldDelegate) {\\n                // If the old and new delegate are the same, subtract the old\\n                // intrinsic voting power of the voter, or else we will double\\n                // count a portion of it.\\n                newDelegateDelegatedVotingPower -= oldSnap.intrinsicVotingPower;\\n            }\\n            VotingPowerSnapshot memory updatedNewDelegateSnap = VotingPowerSnapshot({\\n                timestamp: uint40(block.timestamp),\\n                delegatedVotingPower: newDelegateDelegatedVotingPower,\\n                intrinsicVotingPower: newDelegateSnap.intrinsicVotingPower,\\n                isDelegated: newDelegateSnap.isDelegated\\n            });\\n            _insertVotingPowerSnapshot(newDelegate, updatedNewDelegateSnap);\\n        }\\n    }\\n\\n    // Append a new voting power snapshot, overwriting the last one if possible.\\n    function _insertVotingPowerSnapshot(address voter, VotingPowerSnapshot memory snap) private {\\n        VotingPowerSnapshot[] storage voterSnaps = _votingPowerSnapshotsByVoter[voter];\\n        uint256 n = voterSnaps.length;\\n        // If same timestamp as last entry, overwrite the last snapshot, otherwise append.\\n        if (n != 0) {\\n            VotingPowerSnapshot memory lastSnap = voterSnaps[n - 1];\\n            if (lastSnap.timestamp == snap.timestamp) {\\n                voterSnaps[n - 1] = snap;\\n                return;\\n            }\\n        }\\n        voterSnaps.push(snap);\\n    }\\n\\n    function _getLastVotingPowerSnapshotForVoter(\\n        address voter\\n    ) private view returns (VotingPowerSnapshot memory snap) {\\n        VotingPowerSnapshot[] storage voterSnaps = _votingPowerSnapshotsByVoter[voter];\\n        uint256 n = voterSnaps.length;\\n        if (n != 0) {\\n            snap = voterSnaps[n - 1];\\n        }\\n    }\\n\\n    function _getProposalFlags(ProposalStateValues memory pv) private pure returns (uint256) {\\n        if (_isUnanimousVotes(pv.votes, pv.totalVotingPower)) {\\n            return LibProposal.PROPOSAL_FLAG_UNANIMOUS;\\n        }\\n        return 0;\\n    }\\n\\n    function _getProposalStatus(\\n        ProposalStateValues memory pv\\n    ) private view returns (ProposalStatus status) {\\n        // Never proposed.\\n        if (pv.proposedTime == 0) {\\n            return ProposalStatus.Invalid;\\n        }\\n        // Executed at least once.\\n        if (pv.executedTime != 0) {\\n            if (pv.completedTime == 0) {\\n                return ProposalStatus.InProgress;\\n            }\\n            // completedTime high bit will be set if cancelled.\\n            if (pv.completedTime & UINT40_HIGH_BIT == UINT40_HIGH_BIT) {\\n                return ProposalStatus.Cancelled;\\n            }\\n            return ProposalStatus.Complete;\\n        }\\n        // Vetoed.\\n        if (pv.votes == type(uint96).max) {\\n            return ProposalStatus.Defeated;\\n        }\\n        uint40 t = uint40(block.timestamp);\\n        GovernanceValues memory gv = _governanceValues;\\n        if (pv.passedTime != 0) {\\n            // Ready.\\n            if (pv.passedTime + gv.executionDelay <= t) {\\n                return ProposalStatus.Ready;\\n            }\\n            // If unanimous, we skip the execution delay.\\n            if (_isUnanimousVotes(pv.votes, pv.totalVotingPower)) {\\n                return ProposalStatus.Ready;\\n            }\\n            // Passed.\\n            return ProposalStatus.Passed;\\n        }\\n        // Voting window expired.\\n        if (pv.proposedTime + gv.voteDuration <= t) {\\n            return ProposalStatus.Defeated;\\n        }\\n        return ProposalStatus.Voting;\\n    }\\n\\n    function _isUnanimousVotes(\\n        uint96 totalVotes,\\n        uint96 totalVotingPower\\n    ) private pure returns (bool) {\\n        uint256 acceptanceRatio = (totalVotes * 1e4) / totalVotingPower;\\n        // If >= 99.99% acceptance, consider it unanimous.\\n        // The minting formula for voting power is a bit lossy, so we check\\n        // for slightly less than 100%.\\n        return acceptanceRatio >= 0.9999e4;\\n    }\\n\\n    function _areVotesPassing(\\n        uint96 voteCount,\\n        uint96 totalVotingPower,\\n        uint16 passThresholdBps\\n    ) private pure returns (bool) {\\n        return (uint256(voteCount) * 1e4) / uint256(totalVotingPower) >= uint256(passThresholdBps);\\n    }\\n\\n    function _setPreciousList(\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds\\n    ) private {\\n        if (preciousTokens.length != preciousTokenIds.length) {\\n            revert MismatchedPreciousListLengths();\\n        }\\n        preciousListHash = _hashPreciousList(preciousTokens, preciousTokenIds);\\n    }\\n\\n    function _isPreciousListCorrect(\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds\\n    ) private view returns (bool) {\\n        return preciousListHash == _hashPreciousList(preciousTokens, preciousTokenIds);\\n    }\\n\\n    function _hashPreciousList(\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds\\n    ) internal pure returns (bytes32 h) {\\n        assembly {\\n            mstore(0x00, keccak256(add(preciousTokens, 0x20), mul(mload(preciousTokens), 0x20)))\\n            mstore(0x20, keccak256(add(preciousTokenIds, 0x20), mul(mload(preciousTokenIds), 0x20)))\\n            h := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    // Assert that the hash of a proposal matches expectedHash.\\n    function _validateProposalHash(Proposal memory proposal, bytes32 expectedHash) private pure {\\n        bytes32 actualHash = getProposalHash(proposal);\\n        if (expectedHash != actualHash) {\\n            revert BadProposalHashError(actualHash, expectedHash);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/market-wrapper/IMarketWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.20;\\n\\n/**\\n * @title IMarketWrapper\\n * @author Anna Carroll\\n * @notice IMarketWrapper provides a common interface for\\n * interacting with NFT auction markets.\\n * Contracts can abstract their interactions with\\n * different NFT markets using IMarketWrapper.\\n * NFT markets can become compatible with any contract\\n * using IMarketWrapper by deploying a MarketWrapper contract\\n * that implements this interface using the logic of their Market.\\n *\\n * WARNING: MarketWrapper contracts should NEVER write to storage!\\n * When implementing a MarketWrapper, exercise caution; a poorly implemented\\n * MarketWrapper contract could permanently lose access to the NFT or user funds.\\n */\\ninterface IMarketWrapper {\\n    /**\\n     * @notice Given the auctionId, nftContract, and tokenId, check that:\\n     * 1. the auction ID matches the token\\n     * referred to by tokenId + nftContract\\n     * 2. the auctionId refers to an *ACTIVE* auction\\n     * (e.g. an auction that will accept bids)\\n     * within this market contract\\n     * 3. any additional validation to ensure that\\n     * a PartyBid can bid on this auction\\n     * (ex: if the market allows arbitrary bidding currencies,\\n     * check that the auction currency is ETH)\\n     * Note: This function probably should have been named \\\"isValidAuction\\\"\\n     * @dev Called in PartyBid.sol in `initialize` at line 174\\n     * @return TRUE if the auction is valid\\n     */\\n    function auctionIdMatchesToken(\\n        uint256 auctionId,\\n        address nftContract,\\n        uint256 tokenId\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Calculate the minimum next bid for this auction.\\n     * PartyBid contracts always submit the minimum possible\\n     * bid that will be accepted by the Market contract.\\n     * usually, this is either the reserve price (if there are no bids)\\n     * or a certain percentage increase above the current highest bid\\n     * @dev Called in PartyBid.sol in `bid` at line 251\\n     * @return minimum bid amount\\n     */\\n    function getMinimumBid(uint256 auctionId) external view returns (uint256);\\n\\n    /**\\n     * @notice Query the current highest bidder for this auction\\n     * It is assumed that there is always 1 winning highest bidder for an auction\\n     * This is used to ensure that PartyBid cannot outbid itself if it is already winning\\n     * @dev Called in PartyBid.sol in `bid` at line 241\\n     * @return highest bidder\\n     */\\n    function getCurrentHighestBidder(uint256 auctionId) external view returns (address);\\n\\n    /**\\n     * @notice Submit bid to Market contract\\n     * @dev Called in PartyBid.sol in `bid` at line 259\\n     */\\n    function bid(uint256 auctionId, uint256 bidAmount) external;\\n\\n    /**\\n     * @notice Determine whether the auction has been finalized\\n     * Used to check if it is still possible to bid\\n     * And to determine whether the PartyBid should finalize the auction\\n     * @dev Called in PartyBid.sol in `bid` at line 247\\n     * @dev and in `finalize` at line 288\\n     * @return TRUE if the auction has been finalized\\n     */\\n    function isFinalized(uint256 auctionId) external view returns (bool);\\n\\n    /**\\n     * @notice Finalize the results of the auction\\n     * on the Market contract\\n     * It is assumed  that this operation is performed once for each auction,\\n     * that after it is done the auction is over and the NFT has been\\n     * transferred to the auction winner.\\n     * @dev Called in PartyBid.sol in `finalize` at line 289\\n     */\\n    function finalize(uint256 auctionId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/proposals/IProposalExecutionEngine.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../tokens/IERC721.sol\\\";\\n\\n// Upgradeable proposals logic contract interface.\\ninterface IProposalExecutionEngine {\\n    struct ExecuteProposalParams {\\n        uint256 proposalId;\\n        bytes proposalData;\\n        bytes progressData;\\n        bytes extraData;\\n        uint256 flags;\\n        IERC721[] preciousTokens;\\n        uint256[] preciousTokenIds;\\n    }\\n\\n    function initialize(address oldImpl, bytes memory initData) external;\\n\\n    /// @notice Execute a proposal.\\n    /// @dev Must be delegatecalled into by PartyGovernance.\\n    ///      If the proposal is incomplete, continues its next step (if possible).\\n    ///      If another proposal is incomplete, this will fail. Only one\\n    ///      incomplete proposal is allowed at a time.\\n    /// @param params The data needed to execute the proposal.\\n    /// @return nextProgressData Bytes to be passed into the next `execute()` call,\\n    ///         if the proposal execution is incomplete. Otherwise, empty bytes\\n    ///         to indicate the proposal is complete.\\n    function executeProposal(\\n        ExecuteProposalParams memory params\\n    ) external returns (bytes memory nextProgressData);\\n\\n    /// @notice Forcibly cancel an incomplete proposal.\\n    /// @param proposalId The ID of the proposal to cancel.\\n    /// @dev This is intended to be a last resort as it can leave a party in a\\n    ///      broken step. Whenever possible, proposals should be allowed to\\n    ///      complete their entire lifecycle.\\n    function cancelProposal(uint256 proposalId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/ERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8;\\n\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"../utils/EIP165.sol\\\";\\nimport \\\"../vendor/solmate/ERC721.sol\\\";\\n\\n/// @notice Mixin for contracts that want to receive ERC721 tokens.\\n/// @dev Use this instead of solmate's ERC721TokenReceiver because the\\n///      compiler has issues when overriding EIP165/IERC721Receiver functions.\\nabstract contract ERC721Receiver is IERC721Receiver, EIP165, ERC721TokenReceiver {\\n    /// @inheritdoc IERC721Receiver\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override(IERC721Receiver, ERC721TokenReceiver) returns (bytes4) {\\n        return IERC721Receiver.onERC721Received.selector;\\n    }\\n\\n    /// @inheritdoc EIP165\\n    function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\\n        return\\n            EIP165.supportsInterface(interfaceId) ||\\n            interfaceId == type(IERC721Receiver).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/party/IPartyFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport { Party } from \\\"../party/Party.sol\\\";\\nimport { IERC721 } from \\\"../tokens/IERC721.sol\\\";\\nimport { MetadataProvider } from \\\"../renderers/MetadataProvider.sol\\\";\\n\\n// Creates generic Party instances.\\ninterface IPartyFactory {\\n    event PartyCreated(\\n        Party indexed party,\\n        Party.PartyOptions opts,\\n        IERC721[] preciousTokens,\\n        uint256[] preciousTokenIds,\\n        address creator\\n    );\\n\\n    /// @notice Deploy a new party instance.\\n    /// @param partyImpl The implementation of the party to deploy.\\n    /// @param authorities The addresses set as authorities for the party.\\n    /// @param opts Options used to initialize the party. These are fixed\\n    ///             and cannot be changed later.\\n    /// @param preciousTokens The tokens that are considered precious by the\\n    ///                       party.These are protected assets and are subject\\n    ///                       to extra restrictions in proposals vs other\\n    ///                       assets.\\n    /// @param preciousTokenIds The IDs associated with each token in `preciousTokens`.\\n    /// @param rageQuitTimestamp The timestamp until which ragequit is enabled.\\n    /// @return party The newly created `Party` instance.\\n    function createParty(\\n        Party partyImpl,\\n        address[] memory authorities,\\n        Party.PartyOptions calldata opts,\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds,\\n        uint40 rageQuitTimestamp\\n    ) external returns (Party party);\\n\\n    /// @notice Deploy a new party instance with custom metadata.\\n    /// @param partyImpl The implementation of the party to deploy.\\n    /// @param authorities The addresses set as authorities for the party.\\n    /// @param opts Options used to initialize the party.\\n    /// @param preciousTokens The tokens that are considered precious by the\\n    ///                       party.These are protected assets and are subject\\n    ///                       to extra restrictions in proposals vs other\\n    ///                       assets.\\n    /// @param preciousTokenIds The IDs associated with each token in `preciousTokens`.\\n    /// @param rageQuitTimestamp The timestamp until which ragequit is enabled.\\n    /// @param provider The metadata provider to use for the party.\\n    /// @param metadata The metadata to use for the party.\\n    /// @return party The newly created `Party` instance.\\n    function createPartyWithMetadata(\\n        Party partyImpl,\\n        address[] memory authorities,\\n        Party.PartyOptions memory opts,\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds,\\n        uint40 rageQuitTimestamp,\\n        MetadataProvider provider,\\n        bytes memory metadata\\n    ) external returns (Party party);\\n}\\n\"\r\n    },\r\n    \"contracts/renderers/RendererStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"solmate/utils/SSTORE2.sol\\\";\\nimport \\\"../utils/Multicall.sol\\\";\\n\\ncontract RendererStorage is Multicall {\\n    error AlreadySetError();\\n    error NotOwnerError(address caller, address owner);\\n\\n    event OwnershipTransferred(address previousOwner, address newOwner);\\n\\n    uint256 constant CROWDFUND_CARD_DATA = 0;\\n    uint256 constant PARTY_CARD_DATA = 1;\\n\\n    /// @notice Address allowed to store new data.\\n    address public owner;\\n\\n    /// @notice Customization presets by ID, used for rendering cards. Begins at\\n    ///         1, 0 is reserved to indicate in `getPresetFor()` that a\\n    ///         party instance use the preset set by the crowdfund instance that\\n    ///         created it.\\n    mapping(uint256 => bytes) public customizationPresets;\\n    /// @notice Customization preset used by a crowdfund or party instance.\\n    mapping(address => uint256) public getPresetFor;\\n    /// @notice Addresses where URI data chunks are stored.\\n    mapping(uint256 => address) public files;\\n\\n    modifier onlyOwner() {\\n        address owner_ = owner;\\n        if (msg.sender != owner_) {\\n            revert NotOwnerError(msg.sender, owner_);\\n        }\\n\\n        _;\\n    }\\n\\n    constructor(address _owner) {\\n        // Set the address allowed to write new data.\\n        owner = _owner;\\n\\n        // Write URI data used by V1 of the renderers:\\n\\n        files[CROWDFUND_CARD_DATA] = SSTORE2.write(\\n            bytes(\\n                '<path class=\\\"o\\\" d=\\\"M118.4 419.5h5.82v1.73h-4.02v1.87h3.74v1.73h-3.74v1.94h4.11v1.73h-5.91v-9Zm9.93 1.76h-2.6v-1.76h7.06v1.76h-2.61v7.24h-1.85v-7.24Zm6.06-1.76h1.84v3.55h3.93v-3.55H142v9h-1.84v-3.67h-3.93v3.67h-1.84v-9Z\\\"/><path class=\\\"o\\\" d=\\\"M145 413a4 4 0 0 1 4 4v14a4 4 0 0 1-4 4H35a4 4 0 0 1-4-4v-14a4 4 0 0 1 4-4h110m0-1H35a5 5 0 0 0-5 5v14a5 5 0 0 0 5 5h110a5 5 0 0 0 5-5v-14a5 5 0 0 0-5-5Z\\\"/><path d=\\\"M239.24 399.83h3.04c1.7 0 2.82 1 2.82 2.55 0 2.1-1.27 3.32-3.57 3.32h-1.97l-.71 3.3h-1.56l1.96-9.17Zm2.34 4.38c1.23 0 1.88-.58 1.88-1.68 0-.73-.49-1.2-1.48-1.2h-1.51l-.6 2.88h1.7Zm3.57 1.86c0-2.27 1.44-3.83 3.57-3.83 1.82 0 3.06 1.25 3.06 3.09 0 2.28-1.43 3.83-3.57 3.83-1.82 0-3.06-1.25-3.06-3.09Zm3.13 1.74c1.19 0 1.93-1.02 1.93-2.52 0-1.06-.62-1.69-1.56-1.69-1.19 0-1.93 1.02-1.93 2.52 0 1.06.62 1.69 1.56 1.69Zm4.74-5.41h1.49l.28 4.73 2.25-4.73h1.64l.23 4.77 2.25-4.77h1.56l-3.3 6.61h-1.62l-.25-5.04-2.42 5.04h-1.63l-.48-6.61Zm9.54 3.66c0-2.27 1.45-3.81 3.6-3.81 2 0 3.05 1.58 2.33 3.92h-4.46c0 1.1.81 1.68 2.05 1.68.8 0 1.45-.2 2.1-.59l-.31 1.46a4.2 4.2 0 0 1-2.04.44c-2.06 0-3.26-1.19-3.26-3.11Zm4.7-1.07c.12-.86-.31-1.46-1.22-1.46s-1.57.61-1.82 1.46h3.05Zm3.46-2.59h1.55l-.28 1.28c.81-1.7 2.56-1.36 2.77-1.29l-.35 1.46c-.18-.06-2.3-.63-2.82 1.68l-.74 3.48h-1.55l1.42-6.61Zm3.91 3.66c0-2.27 1.45-3.81 3.6-3.81 2 0 3.05 1.58 2.33 3.92h-4.46c0 1.1.81 1.68 2.05 1.68.8 0 1.45-.2 2.1-.59l-.31 1.46a4.2 4.2 0 0 1-2.04.44c-2.06 0-3.26-1.19-3.26-3.11Zm4.7-1.07c.12-.86-.31-1.46-1.22-1.46s-1.57.61-1.82 1.46h3.05Zm2.25 1.36c0-2.44 1.36-4.1 3.26-4.1 1 0 1.76.53 2.05 1.31l.79-3.72h1.55l-1.96 9.17h-1.55l.2-.92a2.15 2.15 0 0 1-1.92 1.08c-1.49 0-2.43-1.18-2.43-2.82Zm3 1.51c.88 0 1.51-.58 1.73-1.56l.17-.81c.24-1.1-.31-1.93-1.36-1.93-1.19 0-1.94 1.08-1.94 2.59 0 1.06.55 1.71 1.4 1.71Zm9.6-.01-.25 1.16h-1.55l1.96-9.17h1.55l-.73 3.47a2.35 2.35 0 0 1 1.99-1.05c1.49 0 2.35 1.16 2.35 2.76 0 2.52-1.36 4.16-3.21 4.16-.98 0-1.81-.53-2.1-1.32Zm1.83.01c1.16 0 1.87-1.06 1.87-2.61 0-1.04-.5-1.69-1.39-1.69s-1.52.56-1.73 1.55l-.17.79c-.24 1.14.34 1.97 1.42 1.97Zm5.68 1.16-1.04-6.62h1.52l.66 4.75 2.66-4.75h1.69l-5.31 9.13h-1.73l1.55-2.51Zm23.48-6.8a42.14 42.14 0 0 0-.75 6.01 43.12 43.12 0 0 0 5.58 2.35 42.54 42.54 0 0 0 5.58-2.35 45.32 45.32 0 0 0-.75-6.01c-.91-.79-2.6-2.21-4.83-3.66a42.5 42.5 0 0 0-4.83 3.66Zm13.07-7.95s.82-.29 1.76-.45a14.9 14.9 0 0 0-9.53-3.81c.66.71 1.28 1.67 1.84 2.75 1.84.22 4.07.7 5.92 1.51Zm-2.71 18.36c-2.06-.4-4.05-.97-5.53-1.51a38.65 38.65 0 0 1-5.53 1.51c.12 1.5.35 3.04.76 4.58 0 0 1.54 1.82 4.78 2.8 3.23-.98 4.78-2.8 4.78-2.8.4-1.53.64-3.08.76-4.58Zm-13.77-18.37a22.3 22.3 0 0 1 5.93-1.51 12.4 12.4 0 0 1 1.84-2.75 14.97 14.97 0 0 0-9.53 3.81c.95.16 1.76.45 1.76.45Zm-4.72 8.77a25.74 25.74 0 0 0 3.58 2.94 37.48 37.48 0 0 1 4.08-4.04c.27-1.56.77-3.57 1.46-5.55a25.24 25.24 0 0 0-4.34-1.63s-2.35.42-4.81 2.74c-.77 3.29.04 5.54.04 5.54Zm25.92 0s.81-2.25.04-5.54c-2.46-2.31-4.81-2.74-4.81-2.74-1.53.42-2.99.99-4.34 1.63a37.79 37.79 0 0 1 1.46 5.55 37.44 37.44 0 0 1 4.08 4.04 25.86 25.86 0 0 0 3.58-2.94Zm-26.38.2s-.66-.56-1.27-1.3c-.7 3.34-.27 6.93 1.46 10.16.28-.93.8-1.94 1.46-2.97a22.32 22.32 0 0 1-1.66-5.88Zm8.24 14.27a22.07 22.07 0 0 1-4.27-4.38c-1.22.06-2.36 0-3.3-.22a14.91 14.91 0 0 0 8.07 6.34c-.34-.9-.5-1.75-.5-1.75Zm18.6-14.27s.66-.56 1.27-1.3c.7 3.34.27 6.93-1.46 10.16-.28-.93-.8-1.94-1.46-2.97a22.32 22.32 0 0 0 1.66-5.88Zm-8.24 14.27a22.07 22.07 0 0 0 4.27-4.38c1.22.06 2.36 0 3.3-.22a14.91 14.91 0 0 1-8.07 6.34c.34-.9.5-1.75.5-1.75ZM330 391.84l-4.12 2.45 1.26 3.91h5.72l1.26-3.91-4.12-2.45Zm-11.4 19.74 4.18 2.35 2.75-3.05-2.86-4.95-4.02.86-.06 4.79Zm22.79 0-.06-4.79-4.02-.86-2.86 4.95 2.75 3.05 4.18-2.35Z\\\" style=\\\"fill:#00c1fa\\\"/><use height=\\\"300\\\" transform=\\\"matrix(1 0 0 .09 29.85 444)\\\" width=\\\"300.15\\\" xlink:href=\\\"#a\\\"/><use height=\\\"21.15\\\" transform=\\\"translate(30 446.92)\\\" width=\\\"300\\\" xlink:href=\\\"#b\\\"/><g><path d=\\\"m191.54 428.67-28.09-24.34A29.98 29.98 0 0 0 143.8 397H30a15 15 0 0 0-15 15v98a15 15 0 0 0 15 15h300a15 15 0 0 0 15-15v-59a15 15 0 0 0-15-15H211.19a30 30 0 0 1-19.65-7.33Z\\\" style=\\\"fill:url(#i)\\\"/></g></svg>'\\n            )\\n        );\\n\\n        files[PARTY_CARD_DATA] = SSTORE2.write(\\n            bytes(\\n                ' d=\\\"M188 444.3h2.4l2.6 8.2 2.7-8.2h2.3l-3.7 10.7h-2.8l-3.5-10.7zm10.5 5.3c0-3.2 2.2-5.6 5.3-5.6 3.1 0 5.3 2.3 5.3 5.6 0 3.2-2.2 5.5-5.3 5.5-3.1.1-5.3-2.2-5.3-5.5zm5.3 3.5c1.8 0 3-1.3 3-3.4 0-2.1-1.1-3.5-3-3.5s-3 1.3-3 3.5c0 2.1 1.1 3.4 3 3.4zm8.7-6.7h-3.1v-2.1h8.4v2.1h-3.1v8.6h-2.2v-8.6zm6.9-2.1h2.2V455h-2.2v-10.7zm4.3 0h2.9l4 8.2v-8.2h2.1V455h-2.9l-4-8.2v8.2h-2.1v-10.7zm10.6 5.4c0-3.4 2.3-5.6 6-5.6 1.2 0 2.3.2 3.1.6v2.3c-.9-.6-1.9-.8-3.1-.8-2.4 0-3.8 1.3-3.8 3.5 0 2.1 1.3 3.4 3.5 3.4.5 0 .9-.1 1.3-.2v-2.2h-2.2v-1.9h4.3v5.6c-1 .5-2.2.8-3.4.8-3.5 0-5.7-2.2-5.7-5.5zm15.1-5.4h4.3c2.3 0 3.7 1.3 3.7 3.5s-1.4 3.5-3.7 3.5h-2.1v3.7h-2.2v-10.7zm4.1 5c1.1 0 1.6-.5 1.6-1.5s-.5-1.5-1.6-1.5h-1.9v2.9h1.9zm4.8.3c0-3.2 2.2-5.6 5.3-5.6 3.1 0 5.3 2.3 5.3 5.6 0 3.2-2.2 5.5-5.3 5.5-3.1.1-5.3-2.2-5.3-5.5zm5.3 3.5c1.8 0 3-1.3 3-3.4 0-2.1-1.1-3.5-3-3.5s-3 1.3-3 3.5c0 2.1 1.1 3.4 3 3.4zm5.8-8.8h2.3l1.7 7.8 1.9-7.8h2.4l1.8 7.8 1.8-7.8h2.3l-2.7 10.7h-2.5l-1.9-8.2-1.8 8.2h-2.5l-2.8-10.7zm15.4 0h6.9v2.1H287v2.2h4.5v2.1H287v2.3h4.9v2.1h-7v-10.8zm9 0h4.5c2 0 3.3 1.3 3.3 3.2 0 1.9-1.2 3.1-3 3.2l3.5 4.3h-2.7l-3.5-4.4v4.4h-2.1v-10.7zm4.1 4.8c1 0 1.5-.5 1.5-1.4 0-.9-.6-1.4-1.5-1.4h-2v2.9h2zM30 444.3h4.3c3 0 5.2 2.1 5.2 5.4s-2.1 5.4-5.2 5.4H30v-10.8zm4 8.6c2.1 0 3.2-1.2 3.2-3.2s-1.2-3.3-3.2-3.3h-1.8v6.5H34zm7.7-8.6h2.2V455h-2.2v-10.7zm4.8 10V452c1 .7 2.1 1.1 3.2 1.1s1.7-.5 1.7-1.2-.4-1-1.2-1.2l-1.2-.3c-1.8-.5-2.7-1.5-2.7-3.1 0-2 1.5-3.2 3.9-3.2 1 0 2.1.2 2.9.7v2.3c-.9-.6-1.9-.8-3-.8-.9 0-1.6.4-1.6 1.1 0 .6.4.9 1.2 1.1l1.3.4c1.8.5 2.6 1.4 2.6 3.1 0 2.1-1.5 3.4-3.8 3.4-1.1-.2-2.3-.5-3.3-1.1zm12-7.9h-3.1v-2.1h8.4v2.1h-3.1v8.6h-2.2v-8.6zm7.5-2.1h4.5c2 0 3.3 1.3 3.3 3.2 0 1.9-1.2 3.1-3 3.2l3.5 4.3h-2.7l-3.5-4.4v4.4H66v-10.7zm4.1 4.8c1 0 1.5-.5 1.5-1.4s-.6-1.4-1.5-1.4h-2v2.9h2zm6.1-4.8h2.2V455h-2.2v-10.7zm5 0h4.5c2 0 3.2 1.1 3.2 2.8 0 1.1-.5 1.9-1.4 2.3 1.1.3 1.8 1.3 1.8 2.5 0 1.9-1.3 3.1-3.5 3.1h-4.6v-10.7zm4.2 4.4c.9 0 1.4-.5 1.4-1.3s-.5-1.3-1.4-1.3h-2.1v2.5l2.1.1zm.3 4.4c.9 0 1.5-.5 1.5-1.3s-.6-1.3-1.5-1.3h-2.4v2.6h2.4zm5.7-2.5v-6.3h2.2v6.3c0 1.6.9 2.5 2.3 2.5s2.3-.9 2.3-2.5v-6.3h2.2v6.3c0 2.9-1.7 4.6-4.5 4.6s-4.6-1.7-4.5-4.6zm14.2-4.2h-3.1v-2.1h8.4v2.1h-3.1v8.6h-2.2v-8.6zm7.5-2.1h2.2V455h-2.2v-10.7zm4.5 5.3c0-3.2 2.2-5.6 5.3-5.6s5.3 2.3 5.3 5.6-2.2 5.5-5.3 5.5-5.3-2.2-5.3-5.5zm5.3 3.5c1.8 0 3-1.3 3-3.5s-1.2-3.5-3-3.5-3 1.3-3 3.5 1.1 3.5 3 3.5zm7.5-8.8h2.9l4 8.2v-8.2h2.1V455h-2.9l-4-8.2v8.2h-2.1v-10.7zm11.7 10V452c1 .7 2.1 1.1 3.2 1.1s1.7-.5 1.7-1.2-.4-1-1.2-1.2l-1.2-.3c-1.8-.5-2.6-1.5-2.6-3.1 0-2 1.5-3.2 3.9-3.2 1.1 0 2.1.2 2.9.7v2.3c-.9-.6-1.9-.8-3-.8-.9 0-1.6.4-1.6 1.1 0 .6.4.9 1.2 1.1l1.3.4c1.8.5 2.6 1.4 2.6 3.1 0 2.1-1.5 3.4-3.8 3.4a9.7 9.7 0 0 1-3.4-1.1zM30 259.3h4.3c2.2 0 3.7 1.3 3.7 3.5s-1.4 3.5-3.7 3.5h-2.1v3.7H30v-10.7zm4.1 5c1.1 0 1.6-.5 1.6-1.5s-.5-1.5-1.6-1.5h-1.9v2.9h1.9zm6.1-5h4.5c2 0 3.3 1.3 3.3 3.2 0 1.9-1.2 3.1-3 3.2l3.5 4.3h-2.7l-3.5-4.4v4.4h-2.1v-10.7zm4.1 4.8c1 0 1.5-.5 1.5-1.4s-.6-1.4-1.5-1.4h-2v2.9h2zm5.4.5c0-3.2 2.2-5.6 5.3-5.6s5.3 2.3 5.3 5.6-2.2 5.5-5.3 5.5-5.3-2.2-5.3-5.5zm5.3 3.5c1.8 0 3-1.3 3-3.5s-1.2-3.5-3-3.5-3 1.3-3 3.5 1.1 3.5 3 3.5zm7.6-8.8h4.3c2.2 0 3.7 1.3 3.7 3.5s-1.4 3.5-3.7 3.5h-2.1v3.7h-2.2v-10.7zm4.1 5c1.1 0 1.6-.5 1.6-1.5s-.6-1.5-1.6-1.5h-1.9v2.9h1.9zm5.4.4c0-3.2 2.2-5.6 5.3-5.6s5.3 2.3 5.3 5.6-2.2 5.5-5.3 5.5-5.3-2.3-5.3-5.5zm5.4 3.4c1.8 0 3-1.3 3-3.5s-1.2-3.5-3-3.5-3 1.3-3 3.5 1.1 3.5 3 3.5zm7.2 1.2V267c1 .7 2.1 1.1 3.2 1.1s1.7-.5 1.7-1.2-.4-1-1.2-1.2l-1.2-.3c-1.8-.5-2.7-1.5-2.7-3.1 0-2 1.5-3.2 3.9-3.2 1.1 0 2.1.2 2.9.7v2.3c-.9-.6-1.9-.8-3-.8-.9 0-1.6.4-1.6 1.1 0 .6.4.9 1.2 1.1l1.3.4c1.8.5 2.6 1.4 2.6 3.1 0 2.1-1.5 3.4-3.8 3.4-1.1-.2-2.3-.5-3.3-1.1zm12.2-10h2.8l3.7 10.7h-2.3l-.8-2.5h-4l-.8 2.5h-2.2l3.6-10.7zm2.8 6.3-1.4-4.2-1.4 4.2h2.8zm5.7-6.3h2.2v8.6h4.7v2.1h-6.9v-10.7zm9.1 10V267c1 .7 2.1 1.1 3.2 1.1s1.7-.5 1.7-1.2-.4-1-1.2-1.2l-1.2-.3c-1.8-.5-2.7-1.5-2.7-3.1 0-2 1.5-3.2 3.9-3.2 1.1 0 2.1.2 2.9.7v2.3c-.9-.6-1.9-.8-3-.8-.9 0-1.6.4-1.6 1.1 0 .6.4.9 1.2 1.1l1.3.4c1.8.5 2.6 1.4 2.6 3.1 0 2.1-1.5 3.4-3.8 3.4-1.1-.2-2.3-.5-3.3-1.1zm-84.5-70h2.9l4 8.2v-8.2H39V210h-2.9l-4-8.2v8.2H30v-10.7zm14.7 0h2.8l3.7 10.7h-2.3l-.8-2.6h-4l-.8 2.6H41l3.7-10.7zm2.8 6.2-1.4-4.2-1.4 4.2h2.8zm5.7-6.2h3.3l2.5 8.2 2.5-8.2h3.3V210h-2v-8.6L60 210h-2.1l-2.7-8.5v8.5h-2v-10.7zm14.4 0h6.9v2.1h-4.8v2.2h4.4v2.1h-4.4v2.3h4.9v2.1h-7v-10.8z\\\" /><path d=\\\"M239.24 24.83h3.04c1.7 0 2.82 1 2.82 2.55 0 2.1-1.27 3.32-3.57 3.32h-1.97l-.71 3.3h-1.56l1.96-9.17Zm2.34 4.38c1.23 0 1.88-.58 1.88-1.68 0-.73-.49-1.2-1.48-1.2h-1.51l-.6 2.88h1.7Zm3.57 1.86c0-2.27 1.44-3.83 3.57-3.83 1.82 0 3.06 1.25 3.06 3.09 0 2.28-1.43 3.83-3.57 3.83-1.82 0-3.06-1.25-3.06-3.09Zm3.13 1.74c1.19 0 1.93-1.02 1.93-2.52 0-1.06-.62-1.69-1.56-1.69-1.19 0-1.93 1.02-1.93 2.52 0 1.06.62 1.69 1.56 1.69Zm4.74-5.41h1.49l.28 4.73 2.25-4.73h1.64l.23 4.77 2.25-4.77h1.56l-3.3 6.61h-1.62l-.25-5.04-2.42 5.04h-1.63l-.48-6.61Zm9.54 3.66c0-2.27 1.45-3.81 3.6-3.81 2 0 3.05 1.58 2.33 3.92h-4.46c0 1.1.81 1.68 2.05 1.68.8 0 1.45-.2 2.1-.59l-.31 1.46a4.2 4.2 0 0 1-2.04.44c-2.06 0-3.26-1.19-3.26-3.11Zm4.7-1.07c.12-.86-.31-1.46-1.22-1.46s-1.57.61-1.82 1.46h3.05Zm3.46-2.59h1.55l-.28 1.28c.81-1.7 2.56-1.36 2.77-1.29l-.35 1.46c-.18-.06-2.3-.63-2.82 1.68l-.74 3.48h-1.55l1.42-6.61Zm3.91 3.66c0-2.27 1.45-3.81 3.6-3.81 2 0 3.05 1.58 2.33 3.92h-4.46c0 1.1.81 1.68 2.05 1.68.8 0 1.45-.2 2.1-.59l-.31 1.46a4.2 4.2 0 0 1-2.04.44c-2.06 0-3.26-1.19-3.26-3.11Zm4.7-1.07c.12-.86-.31-1.46-1.22-1.46s-1.57.61-1.82 1.46h3.05Zm2.25 1.36c0-2.44 1.36-4.1 3.26-4.1 1 0 1.76.53 2.05 1.31l.79-3.72h1.55l-1.96 9.17h-1.55l.2-.92a2.15 2.15 0 0 1-1.92 1.08c-1.49 0-2.43-1.18-2.43-2.82Zm3 1.51c.88 0 1.51-.58 1.73-1.56l.17-.81c.24-1.1-.31-1.93-1.36-1.93-1.19 0-1.94 1.08-1.94 2.59 0 1.06.55 1.71 1.4 1.71Zm9.6-.01-.25 1.16h-1.55l1.96-9.17h1.55l-.73 3.47a2.35 2.35 0 0 1 1.99-1.05c1.49 0 2.35 1.16 2.35 2.76 0 2.52-1.36 4.16-3.21 4.16-.98 0-1.81-.53-2.1-1.32Zm1.83.01c1.16 0 1.87-1.06 1.87-2.61 0-1.04-.5-1.69-1.39-1.69s-1.52.56-1.73 1.55l-.17.79c-.24 1.14.34 1.97 1.42 1.97Zm5.68 1.16-1.04-6.62h1.52l.66 4.75 2.66-4.75h1.69l-5.31 9.13h-1.73l1.55-2.51Zm23.47-6.8c.91-.79 2.6-2.21 4.83-3.66a42.5 42.5 0 0 1 4.83 3.66c.23 1.18.62 3.36.75 6.01a43.12 43.12 0 0 1-5.58 2.35 42.54 42.54 0 0 1-5.58-2.35c.14-2.65.53-4.83.75-6.01Zm13.07-7.95s.82-.29 1.76-.45a14.9 14.9 0 0 0-9.53-3.81c.66.71 1.28 1.67 1.84 2.75 1.84.22 4.07.7 5.92 1.51Zm-2.71 18.36c-2.06-.4-4.05-.97-5.53-1.51a38.65 38.65 0 0 1-5.53 1.51c.12 1.5.35 3.04.76 4.58 0 0 1.54 1.82 4.78 2.8 3.23-.98 4.78-2.8 4.78-2.8.4-1.53.64-3.08.76-4.58Zm-13.77-18.37a22.3 22.3 0 0 1 5.93-1.51 12.4 12.4 0 0 1 1.84-2.75 14.97 14.97 0 0 0-9.53 3.81c.95.16 1.76.45 1.76.45Zm-4.72 8.77a25.74 25.74 0 0 0 3.58 2.94 37.48 37.48 0 0 1 4.08-4.04c.27-1.56.77-3.57 1.46-5.55a25.24 25.24 0 0 0-4.34-1.63s-2.35.42-4.81 2.74c-.77 3.29.04 5.54.04 5.54Zm25.92 0s.81-2.25.04-5.54c-2.46-2.31-4.81-2.74-4.81-2.74-1.53.42-2.99.99-4.34 1.63a37.79 37.79 0 0 1 1.46 5.55 37.44 37.44 0 0 1 4.08 4.04 25.86 25.86 0 0 0 3.58-2.94Zm-26.38.2s-.66-.56-1.27-1.3c-.7 3.34-.27 6.93 1.46 10.16.28-.93.8-1.94 1.46-2.97a22.32 22.32 0 0 1-1.66-5.88Zm8.24 14.27a22.07 22.07 0 0 1-4.27-4.38c-1.22.06-2.36 0-3.3-.22a14.91 14.91 0 0 0 8.07 6.34c-.34-.9-.5-1.75-.5-1.75Zm18.6-14.27s.66-.56 1.27-1.3c.7 3.34.27 6.93-1.46 10.16-.28-.93-.8-1.94-1.46-2.97a22.32 22.32 0 0 0 1.66-5.88Zm-8.24 14.27a22.07 22.07 0 0 0 4.27-4.38c1.22.06 2.36 0 3.3-.22a14.91 14.91 0 0 1-8.07 6.34c.34-.9.5-1.75.5-1.75Zm-5.18-25.66-4.12 2.45 1.26 3.91h5.72l1.26-3.91-4.12-2.45Zm-11.4 19.74 4.18 2.35 2.75-3.05-2.86-4.95-4.02.86-.06 4.79Zm22.79 0-.06-4.79-4.02-.86-2.86 4.95 2.75 3.05 4.18-2.35Z\\\" style=\\\"fill:#00c1fa\\\"/><path d=\\\"M106.67 109.1a304.9 304.9 0 0 0-3.72-10.89c5.04-5.53 35.28-40.74 24.54-68.91 10.57 10.67 8.19 28.85 3.59 41.95-4.79 13.14-13.43 26.48-24.4 37.84Zm30.89 20.82c-5.87 6.12-20.46 17.92-21.67 18.77a99.37 99.37 0 0 0 7.94 6.02 133.26 133.26 0 0 0 20.09-18.48 353.47 353.47 0 0 0-6.36-6.31Zm-29.65-16.74a380.9 380.9 0 0 1 3.13 11.56c-4.8-1.37-8.66-2.53-12.36-3.82a123.4 123.4 0 0 1-21.16 13.21l15.84 5.47c14.83-8.23 28.13-20.82 37.81-34.68 0 0 8.56-12.55 12.42-23.68 2.62-7.48 4.46-16.57 3.49-24.89-2.21-12.27-6.95-15.84-9.32-17.66 6.16 5.72 3.25 27.8-2.79 39.89-6.08 12.16-15.73 24.27-27.05 34.59Zm59.05-37.86c-.03 7.72-3.05 15.69-6.44 22.69 1.7 2.2 3.18 4.36 4.42 6.49 7.97-16.51 3.74-26.67 2.02-29.18ZM61.18 128.51l12.5 4.3a101.45 101.45 0 0 0 21.42-13.19 163.26 163.26 0 0 1-10.61-4.51 101.28 101.28 0 0 1-23.3 13.4Zm87.78-42.73c.86.77 5.44 5.18 6.75 6.59 6.39-16.61.78-28.86-1.27-30.56.72 8.05-2.02 16.51-5.48 23.98Zm-14.29 40.62-2.47-15.18a142.42 142.42 0 0 1-35.74 29.45c6.81 2.36 12.69 4.4 15.45 5.38a115.98 115.98 0 0 0 22.75-19.66Zm-42.62 34.73c4.48 2.93 12.94 4.24 18.8 1.23 6.03-3.84-.6-8.34-8.01-9.88-9.8-2.03-16.82 1.22-13.4 6.21.41.6 1.19 1.5 2.62 2.44m-1.84.4c-3.56-2.37-6.77-7.2-.23-10.08 10.41-3.43 28.39 3.2 24.99 9.22-.58 1.04-1.46 1.6-2.38 2.19h-.03v.02h-.03v.02h-.03c-7.04 3.65-17.06 2.13-22.3-1.36m5.48-3.86a4.94 4.94 0 0 0 5.06.49l1.35-.74-4.68-2.38-1.47.79c-.38.22-1.53.88-.26 1.84m-1.7.59c-2.35-1.57-.78-2.61-.02-3.11 1.09-.57 2.19-1.15 3.28-1.77 6.95 3.67 7.22 3.81 13.19 6.17l-1.38.81c-1.93-.78-4.52-1.82-6.42-2.68.86 1.4 1.99 3.27 2.9 4.64l-1.68.87c-.75-1.28-1.76-2.99-2.47-4.29-3.19 2.06-6.99-.36-7.42-.64\\\" style=\\\"fill:url(#f2)\\\"/><path d=\\\"M159.13 52.37C143.51 24.04 119.45 15 103.6 15c-11.92 0-25.97 5.78-36.84 13.17 9.54 4.38 21.86 15.96 22.02 16.11-7.94-3.05-17.83-6.72-33.23-7.87a135.1 135.1 0 0 0-19.77 20.38c.77 7.66 2.88 15.68 2.88 15.68-6.28-4.75-11.02-4.61-18 9.45-5.4 12.66-6.93 24.25-4.65 33.18 0 0 4.72 26.8 36.23 40.07-1.3-4.61-1.58-9.91-.93-15.73a87.96 87.96 0 0 1-15.63-9.87c.79-6.61 2.79-13.82 6-21.36 4.42-10.66 4.35-15.14 4.35-15.19.03.07 5.48 12.43 12.95 22.08 4.23-8.84 9.46-16.08 13.67-21.83l-3.77-6.75a143.73 143.73 0 0 1 18.19-18.75c2.05 1.07 4.79 2.47 6.84 3.58 8.68-7.27 19.25-14.05 30.56-18.29-7-11.49-16.02-19.27-16.02-19.27s27.7 2.74 42.02 15.69a25.8 25.8 0 0 1 8.65 2.89ZM28.58 107.52a70.1 70.1 0 0 0-2.74 12.52 55.65 55.65 0 0 1-6.19-8.84 69.17 69.17 0 0 1 2.65-12.1c1.77-5.31 3.35-5.91 5.86-2.23v-.05c2.14 3.07 1.81 6.14.42 10.7ZM61.69 72.2l-.05.05a221.85 221.85 0 0 1-7.77-18.1l.14-.14a194.51 194.51 0 0 1 18.56 6.98 144.44 144.44 0 0 0-10.88 11.22Zm54.84-47.38c-4.42.7-9.02 1.95-13.67 3.72a65.03 65.03 0 0 0-7.81-5.31 66.04 66.04 0 0 1 13.02-3.54c1.53-.19 6.23-.79 10.32 2.42v-.05c2.47 1.91.14 2.37-1.86 2.75Z\\\" style=\\\"fill:url(#h)\\\"/>'\\n            )\\n        );\\n    }\\n\\n    /// @notice Transfer ownership to a new owner.\\n    /// @param newOwner The address to transfer ownership to.\\n    function transferOwnership(address newOwner) external onlyOwner {\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n\\n    /// @notice Write data to be accessed by a given file key.\\n    /// @param key The key to access the written data.\\n    /// @param data The data to be written.\\n    function writeFile(uint256 key, string memory data) external onlyOwner {\\n        files[key] = SSTORE2.write(bytes(data));\\n    }\\n\\n    /// @notice Read data using a given file key.\\n    /// @param key The key to access the stored data.\\n    /// @return data The data stored at the given key.\\n    function readFile(uint256 key) external view returns (string memory data) {\\n        return string(SSTORE2.read(files[key]));\\n    }\\n\\n    /// @notice Create or set a customization preset for renderers to use.\\n    /// @param id The ID of the customization preset.\\n    /// @param customizationData Data decoded by renderers used to render the SVG according to the preset.\\n    function createCustomizationPreset(\\n        uint256 id,\\n        bytes memory customizationData\\n    ) external onlyOwner {\\n        customizationPresets[id] = customizationData;\\n    }\\n\\n    /// @notice For crowdfund or party instances to set the customization preset they want to use.\\n    /// @param id The ID of the customization preset.\\n    function useCustomizationPreset(uint256 id) external {\\n        getPresetFor[msg.sender] = id;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ReadOnlyDelegateCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"./LibRawResult.sol\\\";\\n\\ninterface IReadOnlyDelegateCall {\\n    // Marked `view` so that `_readOnlyDelegateCall` can be `view` as well.\\n    function delegateCallAndRevert(address impl, bytes memory callData) external view;\\n}\\n\\n// Inherited by contracts to perform read-only delegate calls.\\nabstract contract ReadOnlyDelegateCall {\\n    using LibRawResult for bytes;\\n\\n    // Delegatecall into implement and revert with the raw result.\\n    function delegateCallAndRevert(address impl, bytes memory callData) external {\\n        // Attempt to gate to only `_readOnlyDelegateCall()` invocations.\\n        require(msg.sender == address(this));\\n        (bool s, bytes memory r) = impl.delegatecall(callData);\\n        // Revert with success status and return data.\\n        abi.encode(s, r).rawRevert();\\n    }\\n\\n    // Perform a `delegateCallAndRevert()` then return the raw result data.\\n    function _readOnlyDelegateCall(address impl, bytes memory callData) internal view {\\n        try IReadOnlyDelegateCall(address(this)).delegateCallAndRevert(impl, callData) {\\n            // Should never happen.\\n            assert(false);\\n        } catch (bytes memory r) {\\n            (bool success, bytes memory resultData) = abi.decode(r, (bool, bytes));\\n            if (!success) {\\n                resultData.rawRevert();\\n            }\\n            resultData.rawReturn();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/EIP165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nabstract contract EIP165 {\\n    /// @notice Query if a contract implements an interface.\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\n    /// @return `true` if the contract implements `interfaceId` and\\n    ///         `interfaceId` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\\n        return interfaceId == this.supportsInterface.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/IERC4906.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8;\\n\\ninterface IERC4906 {\\n    event MetadataUpdate(uint256 _tokenId);\\n\\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(\\n        uint256 tokenId,\\n        uint256 salePrice\\n    ) external view returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/solmate/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n// Based on solmate commit 1681dc505f4897ef636f0435d01b1aa027fdafaf (v6.4.0)\\n//  @ https://github.com/Rari-Capital/solmate/blob/1681dc505f4897ef636f0435d01b1aa027fdafaf/src/tokens/ERC1155.sol\\n// Only modified to inherit IERC721 and EIP165.\\npragma solidity >=0.8.0;\\n\\n// NOTE: Only modified to inherit IERC20 and EIP165\\nimport \\\"../../tokens/IERC721.sol\\\";\\nimport \\\"../../utils/EIP165.sol\\\";\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 is IERC721, EIP165 {\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id /* view */) public virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(address from, address to, uint256 id) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from ||\\n                isApprovedForAll[from][msg.sender] ||\\n                msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 id) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\\n        // NOTE: modified from original to call super.\\n        return\\n            super.supportsInterface(interfaceId) ||\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(address to, uint256 id, bytes memory data) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/distribution/ITokenDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../tokens/IERC20.sol\\\";\\n\\nimport \\\"../party/Party.sol\\\";\\n\\n/// @notice Creates token distributions for parties.\\ninterface ITokenDistributor {\\n    enum TokenType {\\n        Native,\\n        Erc20\\n    }\\n\\n    // Info on a distribution, created by createDistribution().\\n    struct DistributionInfo {\\n        // Type of distribution/token.\\n        TokenType tokenType;\\n        // ID of the distribution. Assigned by createDistribution().\\n        uint256 distributionId;\\n        // The party whose members can claim the distribution.\\n        Party party;\\n        // Who can claim `fee`.\\n        address payable feeRecipient;\\n        // The token being distributed.\\n        address token;\\n        // Total amount of `token` that can be claimed by party members.\\n        uint128 memberSupply;\\n        // Amount of `token` to be redeemed by `feeRecipient`.\\n        uint128 fee;\\n        // Total shares at time distribution was created.\\n        uint96 totalShares;\\n    }\\n\\n    event DistributionCreated(Party indexed party, DistributionInfo info);\\n    event DistributionFeeClaimed(\\n        Party indexed party,\\n        address indexed feeRecipient,\\n        TokenType tokenType,\\n        address token,\\n        uint256 amount\\n    );\\n    event DistributionClaimedByPartyToken(\\n        Party indexed party,\\n        uint256 indexed partyTokenId,\\n        address indexed owner,\\n        TokenType tokenType,\\n        address token,\\n        uint256 amountClaimed\\n    );\\n\\n    /// @notice Create a new distribution for an outstanding native token balance\\n    ///         governed by a party.\\n    /// @dev Native tokens should be transferred directly into this contract\\n    ///      immediately prior (same tx) to calling `createDistribution()` or\\n    ///      attached to the call itself.\\n    /// @param party The party whose members can claim the distribution.\\n    /// @param feeRecipient Who can claim `fee`.\\n    /// @param feeBps Percentage (in bps) of the distribution `feeRecipient` receives.\\n    /// @return info Information on the created distribution.\\n    function createNativeDistribution(\\n        Party party,\\n        address payable feeRecipient,\\n        uint16 feeBps\\n    ) external payable returns (DistributionInfo memory info);\\n\\n    /// @notice Create a new distribution for an outstanding ERC20 token balance\\n    ///         governed by a party.\\n    /// @dev ERC20 tokens should be transferred directly into this contract\\n    ///      immediately prior (same tx) to calling `createDistribution()` or\\n    ///      attached to the call itself.\\n    /// @param token The ERC20 token to distribute.\\n    /// @param party The party whose members can claim the distribution.\\n    /// @param feeRecipient Who can claim `fee`.\\n    /// @param feeBps Percentage (in bps) of the distribution `feeRecipient` receives.\\n    /// @return info Information on the created distribution.\\n    function createErc20Distribution(\\n        IERC20 token,\\n        Party party,\\n        address payable feeRecipient,\\n        uint16 feeBps\\n    ) external returns (DistributionInfo memory info);\\n\\n    /// @notice Claim a portion of a distribution owed to a `partyTokenId` belonging\\n    ///         to the party that created the distribution. The caller\\n    ///         must own this token.\\n    /// @param info Information on the distribution being claimed.\\n    /// @param partyTokenId The ID of the party token to claim for.\\n    /// @return amountClaimed The amount of the distribution claimed.\\n    function claim(\\n        DistributionInfo calldata info,\\n        uint256 partyTokenId\\n    ) external returns (uint128 amountClaimed);\\n\\n    /// @notice Claim the fee for a distribution. Only a distribution's `feeRecipient`\\n    ///         can call this.\\n    /// @param info Information on the distribution being claimed.\\n    /// @param recipient The address to send the fee to.\\n    function claimFee(DistributionInfo calldata info, address payable recipient) external;\\n\\n    /// @notice Batch version of `claim()`.\\n    /// @param infos Information on the distributions being claimed.\\n    /// @param partyTokenIds The ID of the party tokens to claim for.\\n    /// @return amountsClaimed The amount of the distributions claimed.\\n    function batchClaim(\\n        DistributionInfo[] calldata infos,\\n        uint256[] calldata partyTokenIds\\n    ) external returns (uint128[] memory amountsClaimed);\\n\\n    /// @notice Batch version of `claimFee()`.\\n    /// @param infos Information on the distributions to claim fees for.\\n    /// @param recipients The addresses to send the fees to.\\n    function batchClaimFee(\\n        DistributionInfo[] calldata infos,\\n        address payable[] calldata recipients\\n    ) external;\\n\\n    /// @notice Compute the amount of a distribution's token are owed to a party\\n    ///         member, identified by the `partyTokenId`.\\n    /// @param info Information on the distribution being claimed.\\n    /// @param partyTokenId The ID of the party token to claim for.\\n    /// @return claimAmount The amount of the distribution owed to the party member.\\n    function getClaimAmount(\\n        DistributionInfo calldata info,\\n        uint256 partyTokenId\\n    ) external view returns (uint128);\\n\\n    /// @notice Check whether the fee has been claimed for a distribution.\\n    /// @param party The party to use for checking whether the fee has been claimed.\\n    /// @param distributionId The ID of the distribution to check.\\n    /// @return feeClaimed Whether the fee has been claimed.\\n    function wasFeeClaimed(Party party, uint256 distributionId) external view returns (bool);\\n\\n    /// @notice Check whether a `partyTokenId` has claimed their share of a distribution.\\n    /// @param party The party to use for checking whether the `partyTokenId` has claimed.\\n    /// @param partyTokenId The ID of the party token to check.\\n    /// @param distributionId The ID of the distribution to check.\\n    /// @return hasClaimed Whether the `partyTokenId` has claimed.\\n    function hasPartyTokenIdClaimed(\\n        Party party,\\n        uint256 partyTokenId,\\n        uint256 distributionId\\n    ) external view returns (bool);\\n\\n    /// @notice Get how much unclaimed member tokens are left in a distribution.\\n    /// @param party The party to use for checking the unclaimed member tokens.\\n    /// @param distributionId The ID of the distribution to check.\\n    /// @return remainingMemberSupply The amount of distribution supply remaining.\\n    function getRemainingMemberSupply(\\n        Party party,\\n        uint256 distributionId\\n    ) external view returns (uint128);\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8;\\n\\n// Minimal ERC20 interface.\\ninterface IERC20 {\\n    event Transfer(address indexed owner, address indexed to, uint256 amount);\\n    event Approval(address indexed owner, address indexed spender, uint256 allowance);\\n\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    function approve(address spender, uint256 allowance) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/ERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8;\\n\\nimport \\\"../vendor/solmate/ERC1155.sol\\\";\\nimport \\\"../utils/EIP165.sol\\\";\\n\\nabstract contract ERC1155Receiver is EIP165, ERC1155TokenReceiverBase {\\n    /// @inheritdoc EIP165\\n    function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\\n        return\\n            super.supportsInterface(interfaceId) ||\\n            interfaceId == type(ERC1155TokenReceiverBase).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/LibERC20Compat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../tokens/IERC20.sol\\\";\\n\\n// Compatibility helpers for ERC20s.\\nlibrary LibERC20Compat {\\n    error NotATokenError(IERC20 token);\\n    error TokenTransferFailedError(IERC20 token, address to, uint256 amount);\\n    error TokenApprovalFailed(IERC20 token, address spender, uint256 amount);\\n\\n    // Perform an `IERC20.transfer()` handling non-compliant implementations.\\n    function compatTransfer(IERC20 token, address to, uint256 amount) internal {\\n        (bool s, bytes memory r) = address(token).call(\\n            abi.encodeCall(IERC20.transfer, (to, amount))\\n        );\\n        if (s) {\\n            if (r.length == 0) {\\n                uint256 cs;\\n                assembly {\\n                    cs := extcodesize(token)\\n                }\\n                if (cs == 0) {\\n                    revert NotATokenError(token);\\n                }\\n                return;\\n            }\\n            if (abi.decode(r, (bool))) {\\n                return;\\n            }\\n        }\\n        revert TokenTransferFailedError(token, to, amount);\\n    }\\n\\n    // Perform an `IERC20.transferFrom()` handling non-compliant implementations.\\n    function compatTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\\n        (bool s, bytes memory r) = address(token).call(\\n            abi.encodeCall(IERC20.transferFrom, (from, to, amount))\\n        );\\n        if (s) {\\n            if (r.length == 0) {\\n                uint256 cs;\\n                assembly {\\n                    cs := extcodesize(token)\\n                }\\n                if (cs == 0) {\\n                    revert NotATokenError(token);\\n                }\\n                return;\\n            }\\n            if (abi.decode(r, (bool))) {\\n                return;\\n            }\\n        }\\n        revert TokenTransferFailedError(token, to, amount);\\n    }\\n\\n    function compatApprove(IERC20 token, address spender, uint256 amount) internal {\\n        (bool s, bytes memory r) = address(token).call(\\n            abi.encodeCall(IERC20.approve, (spender, amount))\\n        );\\n        if (s) {\\n            if (r.length == 0) {\\n                uint256 cs;\\n                assembly {\\n                    cs := extcodesize(token)\\n                }\\n                if (cs == 0) {\\n                    revert NotATokenError(token);\\n                }\\n                return;\\n            }\\n            if (abi.decode(r, (bool))) {\\n                return;\\n            }\\n        }\\n        revert TokenApprovalFailed(token, spender, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/proposals/LibProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../tokens/IERC721.sol\\\";\\n\\nlibrary LibProposal {\\n    uint256 internal constant PROPOSAL_FLAG_UNANIMOUS = 0x1;\\n\\n    function isTokenPrecious(\\n        IERC721 token,\\n        IERC721[] memory preciousTokens\\n    ) internal pure returns (bool) {\\n        for (uint256 i; i < preciousTokens.length; ++i) {\\n            if (token == preciousTokens[i]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function isTokenIdPrecious(\\n        IERC721 token,\\n        uint256 tokenId,\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds\\n    ) internal pure returns (bool) {\\n        for (uint256 i; i < preciousTokens.length; ++i) {\\n            if (token == preciousTokens[i] && tokenId == preciousTokenIds[i]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8;\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SSTORE2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Read and write to persistent storage at a fraction of the cost.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\\nlibrary SSTORE2 {\\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               WRITE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function write(bytes memory data) internal returns (address pointer) {\\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\\n        bytes memory runtimeCode = abi.encodePacked(hex\\\"00\\\", data);\\n\\n        bytes memory creationCode = abi.encodePacked(\\n            //---------------------------------------------------------------------------------------------------------------//\\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\\n            //---------------------------------------------------------------------------------------------------------------//\\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\\n            //---------------------------------------------------------------------------------------------------------------//\\n            hex\\\"60_0B_59_81_38_03_80_92_59_39_F3\\\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\\n        );\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Deploy a new contract with the generated creation code.\\n            // We start 32 bytes into the code to avoid copying the byte length.\\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\\n        }\\n\\n        require(pointer != address(0), \\\"DEPLOYMENT_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               READ LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function read(address pointer) internal view returns (bytes memory) {\\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\\n    }\\n\\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n\\n        return readBytecode(pointer, start, pointer.code.length - start);\\n    }\\n\\n    function read(address pointer, uint256 start, uint256 end) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n        end += DATA_OFFSET;\\n\\n        require(pointer.code.length >= end, \\\"OUT_OF_BOUNDS\\\");\\n\\n        return readBytecode(pointer, start, end - start);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function readBytecode(address pointer, uint256 start, uint256 size) private view returns (bytes memory data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            data := mload(0x40)\\n\\n            // Update the free memory pointer to prevent overriding our data.\\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\\n            // Adding 31 to size and running the result through the logic above ensures\\n            // the memory pointer remains word-aligned, following the Solidity convention.\\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\\n\\n            // Store the size of the data in the first 32 byte chunk of free memory.\\n            mstore(data, size)\\n\\n            // Copy the code into memory right after the 32 bytes we used to store the size.\\n            extcodecopy(pointer, add(data, 32), start, size)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/solmate/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n// Based on solmate commit 1681dc505f4897ef636f0435d01b1aa027fdafaf (v6.4.0)\\n//  @ https://github.com/Rari-Capital/solmate/blob/1681dc505f4897ef636f0435d01b1aa027fdafaf/src/tokens/ERC1155.sol\\n// Only modified to inherit IERC1155 and rename ERC1155TokenReceiver -> ERC1155TokenReceiverBase.\\npragma solidity ^0.8;\\n\\nimport \\\"../../tokens/IERC1155.sol\\\";\\n\\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155 is IERC1155 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             ERC1155 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             METADATA LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function uri(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC1155 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) public virtual {\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        balanceOf[from][id] -= amount;\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiverBase(to).onERC1155Received(\\n                    msg.sender,\\n                    from,\\n                    id,\\n                    amount,\\n                    data\\n                ) == ERC1155TokenReceiverBase.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) public virtual {\\n        require(ids.length == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        // Storing these outside the loop saves ~15 gas per iteration.\\n        uint256 id;\\n        uint256 amount;\\n\\n        for (uint256 i; i < ids.length; ) {\\n            id = ids[i];\\n            amount = amounts[i];\\n\\n            balanceOf[from][id] -= amount;\\n            balanceOf[to][id] += amount;\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiverBase(to).onERC1155BatchReceived(\\n                    msg.sender,\\n                    from,\\n                    ids,\\n                    amounts,\\n                    data\\n                ) == ERC1155TokenReceiverBase.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function balanceOfBatch(\\n        address[] calldata owners,\\n        uint256[] calldata ids\\n    ) public view virtual returns (uint256[] memory balances) {\\n        require(owners.length == ids.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        balances = new uint256[](owners.length);\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i; i < owners.length; ++i) {\\n                balances[i] = balanceOf[owners[i]][ids[i]];\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiverBase(to).onERC1155Received(\\n                    msg.sender,\\n                    address(0),\\n                    id,\\n                    amount,\\n                    data\\n                ) == ERC1155TokenReceiverBase.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchMint(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i; i < idsLength; ) {\\n            balanceOf[to][ids[i]] += amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiverBase(to).onERC1155BatchReceived(\\n                    msg.sender,\\n                    address(0),\\n                    ids,\\n                    amounts,\\n                    data\\n                ) == ERC1155TokenReceiverBase.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchBurn(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i; i < idsLength; ) {\\n            balanceOf[from][ids[i]] -= amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\\n    }\\n\\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\\n        balanceOf[from][id] -= amount;\\n\\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155TokenReceiverBase {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiverBase.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiverBase.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8;\\n\\n// Minimal ERC1155 interface.\\ninterface IERC1155 {\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 amount\\n    );\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] amounts\\n    );\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n\\n    function balanceOf(address owner, uint256 tokenId) external view returns (uint256);\\n\\n    function isApprovedForAll(address owner, address spender) external view returns (bool);\\n\\n    function balanceOfBatch(\\n        address[] calldata owners,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory balances);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"libraries\": {},\r\n    \"viaIR\": true\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract AuctionCrowdfund\",\"name\":\"crowdfund\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"customizationPresetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"contract IMarketWrapper\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"contract IERC721\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"duration\",\"type\":\"uint40\"},{\"internalType\":\"uint96\",\"name\":\"maximumBid\",\"type\":\"uint96\"},{\"internalType\":\"address payable\",\"name\":\"splitRecipient\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"splitBps\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"initialContributor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialDelegate\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"minContribution\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxContribution\",\"type\":\"uint96\"},{\"internalType\":\"contract IGateKeeper\",\"name\":\"gateKeeper\",\"type\":\"address\"},{\"internalType\":\"bytes12\",\"name\":\"gateKeeperId\",\"type\":\"bytes12\"},{\"internalType\":\"bool\",\"name\":\"onlyHostCanBid\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract Party\",\"name\":\"partyImpl\",\"type\":\"address\"},{\"internalType\":\"contract IPartyFactory\",\"name\":\"partyFactory\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"hosts\",\"type\":\"address[]\"},{\"internalType\":\"uint40\",\"name\":\"voteDuration\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"executionDelay\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"passThresholdBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"internalType\":\"struct Crowdfund.FixedGovernanceOpts\",\"name\":\"governanceOpts\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"enableAddAuthorityProposal\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowArbCallsToSpendPartyEth\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowOperators\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"distributionsRequireVote\",\"type\":\"bool\"}],\"internalType\":\"struct ProposalStorage.ProposalEngineOpts\",\"name\":\"proposalEngineOpts\",\"type\":\"tuple\"}],\"indexed\":false,\"internalType\":\"struct AuctionCrowdfundBase.AuctionCrowdfundOptions\",\"name\":\"opts\",\"type\":\"tuple\"}],\"name\":\"AuctionCrowdfundCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract BuyCrowdfund\",\"name\":\"crowdfund\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"customizationPresetId\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC721\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"duration\",\"type\":\"uint40\"},{\"internalType\":\"uint96\",\"name\":\"maximumPrice\",\"type\":\"uint96\"},{\"internalType\":\"address payable\",\"name\":\"splitRecipient\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"splitBps\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"initialContributor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialDelegate\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"minContribution\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxContribution\",\"type\":\"uint96\"},{\"internalType\":\"contract IGateKeeper\",\"name\":\"gateKeeper\",\"type\":\"address\"},{\"internalType\":\"bytes12\",\"name\":\"gateKeeperId\",\"type\":\"bytes12\"},{\"internalType\":\"bool\",\"name\":\"onlyHostCanBuy\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract Party\",\"name\":\"partyImpl\",\"type\":\"address\"},{\"internalType\":\"contract IPartyFactory\",\"name\":\"partyFactory\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"hosts\",\"type\":\"address[]\"},{\"internalType\":\"uint40\",\"name\":\"voteDuration\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"executionDelay\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"passThresholdBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"internalType\":\"struct Crowdfund.FixedGovernanceOpts\",\"name\":\"governanceOpts\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"enableAddAuthorityProposal\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowArbCallsToSpendPartyEth\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowOperators\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"distributionsRequireVote\",\"type\":\"bool\"}],\"internalType\":\"struct ProposalStorage.ProposalEngineOpts\",\"name\":\"proposalEngineOpts\",\"type\":\"tuple\"}],\"indexed\":false,\"internalType\":\"struct BuyCrowdfund.BuyCrowdfundOptions\",\"name\":\"opts\",\"type\":\"tuple\"}],\"name\":\"BuyCrowdfundCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract CollectionBatchBuyCrowdfund\",\"name\":\"crowdfund\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"customizationPresetId\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC721\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"nftTokenIdsMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint40\",\"name\":\"duration\",\"type\":\"uint40\"},{\"internalType\":\"uint96\",\"name\":\"maximumPrice\",\"type\":\"uint96\"},{\"internalType\":\"address payable\",\"name\":\"splitRecipient\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"splitBps\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"initialContributor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialDelegate\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"minContribution\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxContribution\",\"type\":\"uint96\"},{\"internalType\":\"contract IGateKeeper\",\"name\":\"gateKeeper\",\"type\":\"address\"},{\"internalType\":\"bytes12\",\"name\":\"gateKeeperId\",\"type\":\"bytes12\"},{\"components\":[{\"internalType\":\"contract Party\",\"name\":\"partyImpl\",\"type\":\"address\"},{\"internalType\":\"contract IPartyFactory\",\"name\":\"partyFactory\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"hosts\",\"type\":\"address[]\"},{\"internalType\":\"uint40\",\"name\":\"voteDuration\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"executionDelay\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"passThresholdBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"internalType\":\"struct Crowdfund.FixedGovernanceOpts\",\"name\":\"governanceOpts\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"enableAddAuthorityProposal\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowArbCallsToSpendPartyEth\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowOperators\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"distributionsRequireVote\",\"type\":\"bool\"}],\"internalType\":\"struct ProposalStorage.ProposalEngineOpts\",\"name\":\"proposalEngineOpts\",\"type\":\"tuple\"}],\"indexed\":false,\"internalType\":\"struct CollectionBatchBuyCrowdfund.CollectionBatchBuyCrowdfundOptions\",\"name\":\"opts\",\"type\":\"tuple\"}],\"name\":\"CollectionBatchBuyCrowdfundCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract CollectionBuyCrowdfund\",\"name\":\"crowdfund\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"customizationPresetId\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC721\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"duration\",\"type\":\"uint40\"},{\"internalType\":\"uint96\",\"name\":\"maximumPrice\",\"type\":\"uint96\"},{\"internalType\":\"address payable\",\"name\":\"splitRecipient\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"splitBps\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"initialContributor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialDelegate\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"minContribution\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxContribution\",\"type\":\"uint96\"},{\"internalType\":\"contract IGateKeeper\",\"name\":\"gateKeeper\",\"type\":\"address\"},{\"internalType\":\"bytes12\",\"name\":\"gateKeeperId\",\"type\":\"bytes12\"},{\"components\":[{\"internalType\":\"contract Party\",\"name\":\"partyImpl\",\"type\":\"address\"},{\"internalType\":\"contract IPartyFactory\",\"name\":\"partyFactory\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"hosts\",\"type\":\"address[]\"},{\"internalType\":\"uint40\",\"name\":\"voteDuration\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"executionDelay\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"passThresholdBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"internalType\":\"struct Crowdfund.FixedGovernanceOpts\",\"name\":\"governanceOpts\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"enableAddAuthorityProposal\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowArbCallsToSpendPartyEth\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowOperators\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"distributionsRequireVote\",\"type\":\"bool\"}],\"internalType\":\"struct ProposalStorage.ProposalEngineOpts\",\"name\":\"proposalEngineOpts\",\"type\":\"tuple\"}],\"indexed\":false,\"internalType\":\"struct CollectionBuyCrowdfund.CollectionBuyCrowdfundOptions\",\"name\":\"opts\",\"type\":\"tuple\"}],\"name\":\"CollectionBuyCrowdfundCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract InitialETHCrowdfund\",\"name\":\"crowdfund\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Party\",\"name\":\"party\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"initialContributor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialDelegate\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"minContribution\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxContribution\",\"type\":\"uint96\"},{\"internalType\":\"bool\",\"name\":\"disableContributingForExistingCard\",\"type\":\"bool\"},{\"internalType\":\"uint96\",\"name\":\"minTotalContributions\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxTotalContributions\",\"type\":\"uint96\"},{\"internalType\":\"uint16\",\"name\":\"exchangeRateBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"fundingSplitBps\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"fundingSplitRecipient\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"duration\",\"type\":\"uint40\"},{\"internalType\":\"contract IGateKeeper\",\"name\":\"gateKeeper\",\"type\":\"address\"},{\"internalType\":\"bytes12\",\"name\":\"gateKeeperId\",\"type\":\"bytes12\"}],\"indexed\":false,\"internalType\":\"struct InitialETHCrowdfund.InitialETHCrowdfundOptions\",\"name\":\"crowdfundOpts\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"customizationPresetId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract Party\",\"name\":\"partyImpl\",\"type\":\"address\"},{\"internalType\":\"contract IPartyFactory\",\"name\":\"partyFactory\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"hosts\",\"type\":\"address[]\"},{\"internalType\":\"uint40\",\"name\":\"voteDuration\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"executionDelay\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"passThresholdBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"internalType\":\"struct Crowdfund.FixedGovernanceOpts\",\"name\":\"governanceOpts\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"enableAddAuthorityProposal\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowArbCallsToSpendPartyEth\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowOperators\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"distributionsRequireVote\",\"type\":\"bool\"}],\"internalType\":\"struct ProposalStorage.ProposalEngineOpts\",\"name\":\"proposalEngineOpts\",\"type\":\"tuple\"},{\"internalType\":\"contract IERC721[]\",\"name\":\"preciousTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"preciousTokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint40\",\"name\":\"rageQuitTimestamp\",\"type\":\"uint40\"}],\"indexed\":false,\"internalType\":\"struct InitialETHCrowdfund.ETHPartyOptions\",\"name\":\"partyOpts\",\"type\":\"tuple\"}],\"name\":\"InitialETHCrowdfundCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract ReraiseETHCrowdfund\",\"name\":\"crowdfund\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract Party\",\"name\":\"party\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"initialContributor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialDelegate\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"minContribution\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxContribution\",\"type\":\"uint96\"},{\"internalType\":\"bool\",\"name\":\"disableContributingForExistingCard\",\"type\":\"bool\"},{\"internalType\":\"uint96\",\"name\":\"minTotalContributions\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxTotalContributions\",\"type\":\"uint96\"},{\"internalType\":\"uint16\",\"name\":\"exchangeRateBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"fundingSplitBps\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"fundingSplitRecipient\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"duration\",\"type\":\"uint40\"},{\"internalType\":\"contract IGateKeeper\",\"name\":\"gateKeeper\",\"type\":\"address\"},{\"internalType\":\"bytes12\",\"name\":\"gateKeeperId\",\"type\":\"bytes12\"}],\"indexed\":false,\"internalType\":\"struct ETHCrowdfundBase.ETHCrowdfundOptions\",\"name\":\"opts\",\"type\":\"tuple\"}],\"name\":\"ReraiseETHCrowdfundCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract RollingAuctionCrowdfund\",\"name\":\"crowdfund\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"customizationPresetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"contract IMarketWrapper\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"contract IERC721\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"duration\",\"type\":\"uint40\"},{\"internalType\":\"uint96\",\"name\":\"maximumBid\",\"type\":\"uint96\"},{\"internalType\":\"address payable\",\"name\":\"splitRecipient\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"splitBps\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"initialContributor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialDelegate\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"minContribution\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxContribution\",\"type\":\"uint96\"},{\"internalType\":\"contract IGateKeeper\",\"name\":\"gateKeeper\",\"type\":\"address\"},{\"internalType\":\"bytes12\",\"name\":\"gateKeeperId\",\"type\":\"bytes12\"},{\"internalType\":\"bool\",\"name\":\"onlyHostCanBid\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract Party\",\"name\":\"partyImpl\",\"type\":\"address\"},{\"internalType\":\"contract IPartyFactory\",\"name\":\"partyFactory\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"hosts\",\"type\":\"address[]\"},{\"internalType\":\"uint40\",\"name\":\"voteDuration\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"executionDelay\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"passThresholdBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"internalType\":\"struct Crowdfund.FixedGovernanceOpts\",\"name\":\"governanceOpts\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"enableAddAuthorityProposal\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowArbCallsToSpendPartyEth\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowOperators\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"distributionsRequireVote\",\"type\":\"bool\"}],\"internalType\":\"struct ProposalStorage.ProposalEngineOpts\",\"name\":\"proposalEngineOpts\",\"type\":\"tuple\"}],\"indexed\":false,\"internalType\":\"struct AuctionCrowdfundBase.AuctionCrowdfundOptions\",\"name\":\"opts\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"allowedAuctionsMerkleRoot\",\"type\":\"bytes32\"}],\"name\":\"RollingAuctionCrowdfundCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract AuctionCrowdfund\",\"name\":\"crowdfundImpl\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"customizationPresetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"contract IMarketWrapper\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"contract IERC721\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"duration\",\"type\":\"uint40\"},{\"internalType\":\"uint96\",\"name\":\"maximumBid\",\"type\":\"uint96\"},{\"internalType\":\"address payable\",\"name\":\"splitRecipient\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"splitBps\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"initialContributor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialDelegate\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"minContribution\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxContribution\",\"type\":\"uint96\"},{\"internalType\":\"contract IGateKeeper\",\"name\":\"gateKeeper\",\"type\":\"address\"},{\"internalType\":\"bytes12\",\"name\":\"gateKeeperId\",\"type\":\"bytes12\"},{\"internalType\":\"bool\",\"name\":\"onlyHostCanBid\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract Party\",\"name\":\"partyImpl\",\"type\":\"address\"},{\"internalType\":\"contract IPartyFactory\",\"name\":\"partyFactory\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"hosts\",\"type\":\"address[]\"},{\"internalType\":\"uint40\",\"name\":\"voteDuration\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"executionDelay\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"passThresholdBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"internalType\":\"struct Crowdfund.FixedGovernanceOpts\",\"name\":\"governanceOpts\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"enableAddAuthorityProposal\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowArbCallsToSpendPartyEth\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowOperators\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"distributionsRequireVote\",\"type\":\"bool\"}],\"internalType\":\"struct ProposalStorage.ProposalEngineOpts\",\"name\":\"proposalEngineOpts\",\"type\":\"tuple\"}],\"internalType\":\"struct AuctionCrowdfundBase.AuctionCrowdfundOptions\",\"name\":\"opts\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"createGateCallData\",\"type\":\"bytes\"}],\"name\":\"createAuctionCrowdfund\",\"outputs\":[{\"internalType\":\"contract AuctionCrowdfund\",\"name\":\"inst\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract BuyCrowdfund\",\"name\":\"crowdfundImpl\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"customizationPresetId\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC721\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"duration\",\"type\":\"uint40\"},{\"internalType\":\"uint96\",\"name\":\"maximumPrice\",\"type\":\"uint96\"},{\"internalType\":\"address payable\",\"name\":\"splitRecipient\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"splitBps\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"initialContributor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialDelegate\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"minContribution\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxContribution\",\"type\":\"uint96\"},{\"internalType\":\"contract IGateKeeper\",\"name\":\"gateKeeper\",\"type\":\"address\"},{\"internalType\":\"bytes12\",\"name\":\"gateKeeperId\",\"type\":\"bytes12\"},{\"internalType\":\"bool\",\"name\":\"onlyHostCanBuy\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract Party\",\"name\":\"partyImpl\",\"type\":\"address\"},{\"internalType\":\"contract IPartyFactory\",\"name\":\"partyFactory\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"hosts\",\"type\":\"address[]\"},{\"internalType\":\"uint40\",\"name\":\"voteDuration\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"executionDelay\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"passThresholdBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"internalType\":\"struct Crowdfund.FixedGovernanceOpts\",\"name\":\"governanceOpts\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"enableAddAuthorityProposal\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowArbCallsToSpendPartyEth\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowOperators\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"distributionsRequireVote\",\"type\":\"bool\"}],\"internalType\":\"struct ProposalStorage.ProposalEngineOpts\",\"name\":\"proposalEngineOpts\",\"type\":\"tuple\"}],\"internalType\":\"struct BuyCrowdfund.BuyCrowdfundOptions\",\"name\":\"opts\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"createGateCallData\",\"type\":\"bytes\"}],\"name\":\"createBuyCrowdfund\",\"outputs\":[{\"internalType\":\"contract BuyCrowdfund\",\"name\":\"inst\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract CollectionBatchBuyCrowdfund\",\"name\":\"crowdfundImpl\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"customizationPresetId\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC721\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"nftTokenIdsMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint40\",\"name\":\"duration\",\"type\":\"uint40\"},{\"internalType\":\"uint96\",\"name\":\"maximumPrice\",\"type\":\"uint96\"},{\"internalType\":\"address payable\",\"name\":\"splitRecipient\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"splitBps\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"initialContributor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialDelegate\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"minContribution\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxContribution\",\"type\":\"uint96\"},{\"internalType\":\"contract IGateKeeper\",\"name\":\"gateKeeper\",\"type\":\"address\"},{\"internalType\":\"bytes12\",\"name\":\"gateKeeperId\",\"type\":\"bytes12\"},{\"components\":[{\"internalType\":\"contract Party\",\"name\":\"partyImpl\",\"type\":\"address\"},{\"internalType\":\"contract IPartyFactory\",\"name\":\"partyFactory\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"hosts\",\"type\":\"address[]\"},{\"internalType\":\"uint40\",\"name\":\"voteDuration\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"executionDelay\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"passThresholdBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"internalType\":\"struct Crowdfund.FixedGovernanceOpts\",\"name\":\"governanceOpts\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"enableAddAuthorityProposal\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowArbCallsToSpendPartyEth\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowOperators\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"distributionsRequireVote\",\"type\":\"bool\"}],\"internalType\":\"struct ProposalStorage.ProposalEngineOpts\",\"name\":\"proposalEngineOpts\",\"type\":\"tuple\"}],\"internalType\":\"struct CollectionBatchBuyCrowdfund.CollectionBatchBuyCrowdfundOptions\",\"name\":\"opts\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"createGateCallData\",\"type\":\"bytes\"}],\"name\":\"createCollectionBatchBuyCrowdfund\",\"outputs\":[{\"internalType\":\"contract CollectionBatchBuyCrowdfund\",\"name\":\"inst\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract CollectionBuyCrowdfund\",\"name\":\"crowdfundImpl\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"customizationPresetId\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC721\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"duration\",\"type\":\"uint40\"},{\"internalType\":\"uint96\",\"name\":\"maximumPrice\",\"type\":\"uint96\"},{\"internalType\":\"address payable\",\"name\":\"splitRecipient\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"splitBps\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"initialContributor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialDelegate\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"minContribution\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxContribution\",\"type\":\"uint96\"},{\"internalType\":\"contract IGateKeeper\",\"name\":\"gateKeeper\",\"type\":\"address\"},{\"internalType\":\"bytes12\",\"name\":\"gateKeeperId\",\"type\":\"bytes12\"},{\"components\":[{\"internalType\":\"contract Party\",\"name\":\"partyImpl\",\"type\":\"address\"},{\"internalType\":\"contract IPartyFactory\",\"name\":\"partyFactory\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"hosts\",\"type\":\"address[]\"},{\"internalType\":\"uint40\",\"name\":\"voteDuration\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"executionDelay\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"passThresholdBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"internalType\":\"struct Crowdfund.FixedGovernanceOpts\",\"name\":\"governanceOpts\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"enableAddAuthorityProposal\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowArbCallsToSpendPartyEth\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowOperators\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"distributionsRequireVote\",\"type\":\"bool\"}],\"internalType\":\"struct ProposalStorage.ProposalEngineOpts\",\"name\":\"proposalEngineOpts\",\"type\":\"tuple\"}],\"internalType\":\"struct CollectionBuyCrowdfund.CollectionBuyCrowdfundOptions\",\"name\":\"opts\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"createGateCallData\",\"type\":\"bytes\"}],\"name\":\"createCollectionBuyCrowdfund\",\"outputs\":[{\"internalType\":\"contract CollectionBuyCrowdfund\",\"name\":\"inst\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract InitialETHCrowdfund\",\"name\":\"crowdfundImpl\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"initialContributor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialDelegate\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"minContribution\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxContribution\",\"type\":\"uint96\"},{\"internalType\":\"bool\",\"name\":\"disableContributingForExistingCard\",\"type\":\"bool\"},{\"internalType\":\"uint96\",\"name\":\"minTotalContributions\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxTotalContributions\",\"type\":\"uint96\"},{\"internalType\":\"uint16\",\"name\":\"exchangeRateBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"fundingSplitBps\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"fundingSplitRecipient\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"duration\",\"type\":\"uint40\"},{\"internalType\":\"contract IGateKeeper\",\"name\":\"gateKeeper\",\"type\":\"address\"},{\"internalType\":\"bytes12\",\"name\":\"gateKeeperId\",\"type\":\"bytes12\"}],\"internalType\":\"struct InitialETHCrowdfund.InitialETHCrowdfundOptions\",\"name\":\"crowdfundOpts\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"customizationPresetId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract Party\",\"name\":\"partyImpl\",\"type\":\"address\"},{\"internalType\":\"contract IPartyFactory\",\"name\":\"partyFactory\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"hosts\",\"type\":\"address[]\"},{\"internalType\":\"uint40\",\"name\":\"voteDuration\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"executionDelay\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"passThresholdBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"internalType\":\"struct Crowdfund.FixedGovernanceOpts\",\"name\":\"governanceOpts\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"enableAddAuthorityProposal\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowArbCallsToSpendPartyEth\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowOperators\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"distributionsRequireVote\",\"type\":\"bool\"}],\"internalType\":\"struct ProposalStorage.ProposalEngineOpts\",\"name\":\"proposalEngineOpts\",\"type\":\"tuple\"},{\"internalType\":\"contract IERC721[]\",\"name\":\"preciousTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"preciousTokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint40\",\"name\":\"rageQuitTimestamp\",\"type\":\"uint40\"}],\"internalType\":\"struct InitialETHCrowdfund.ETHPartyOptions\",\"name\":\"partyOpts\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"createGateCallData\",\"type\":\"bytes\"}],\"name\":\"createInitialETHCrowdfund\",\"outputs\":[{\"internalType\":\"contract InitialETHCrowdfund\",\"name\":\"inst\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract InitialETHCrowdfund\",\"name\":\"crowdfundImpl\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"initialContributor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialDelegate\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"minContribution\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxContribution\",\"type\":\"uint96\"},{\"internalType\":\"bool\",\"name\":\"disableContributingForExistingCard\",\"type\":\"bool\"},{\"internalType\":\"uint96\",\"name\":\"minTotalContributions\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxTotalContributions\",\"type\":\"uint96\"},{\"internalType\":\"uint16\",\"name\":\"exchangeRateBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"fundingSplitBps\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"fundingSplitRecipient\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"duration\",\"type\":\"uint40\"},{\"internalType\":\"contract IGateKeeper\",\"name\":\"gateKeeper\",\"type\":\"address\"},{\"internalType\":\"bytes12\",\"name\":\"gateKeeperId\",\"type\":\"bytes12\"}],\"internalType\":\"struct InitialETHCrowdfund.InitialETHCrowdfundOptions\",\"name\":\"crowdfundOpts\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"customizationPresetId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract Party\",\"name\":\"partyImpl\",\"type\":\"address\"},{\"internalType\":\"contract IPartyFactory\",\"name\":\"partyFactory\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"hosts\",\"type\":\"address[]\"},{\"internalType\":\"uint40\",\"name\":\"voteDuration\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"executionDelay\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"passThresholdBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"internalType\":\"struct Crowdfund.FixedGovernanceOpts\",\"name\":\"governanceOpts\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"enableAddAuthorityProposal\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowArbCallsToSpendPartyEth\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowOperators\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"distributionsRequireVote\",\"type\":\"bool\"}],\"internalType\":\"struct ProposalStorage.ProposalEngineOpts\",\"name\":\"proposalEngineOpts\",\"type\":\"tuple\"},{\"internalType\":\"contract IERC721[]\",\"name\":\"preciousTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"preciousTokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint40\",\"name\":\"rageQuitTimestamp\",\"type\":\"uint40\"}],\"internalType\":\"struct InitialETHCrowdfund.ETHPartyOptions\",\"name\":\"partyOpts\",\"type\":\"tuple\"},{\"internalType\":\"contract MetadataProvider\",\"name\":\"customMetadataProvider\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"customMetadata\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"createGateCallData\",\"type\":\"bytes\"}],\"name\":\"createInitialETHCrowdfundWithMetadata\",\"outputs\":[{\"internalType\":\"contract InitialETHCrowdfund\",\"name\":\"inst\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ReraiseETHCrowdfund\",\"name\":\"crowdfundImpl\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract Party\",\"name\":\"party\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"initialContributor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialDelegate\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"minContribution\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxContribution\",\"type\":\"uint96\"},{\"internalType\":\"bool\",\"name\":\"disableContributingForExistingCard\",\"type\":\"bool\"},{\"internalType\":\"uint96\",\"name\":\"minTotalContributions\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxTotalContributions\",\"type\":\"uint96\"},{\"internalType\":\"uint16\",\"name\":\"exchangeRateBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"fundingSplitBps\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"fundingSplitRecipient\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"duration\",\"type\":\"uint40\"},{\"internalType\":\"contract IGateKeeper\",\"name\":\"gateKeeper\",\"type\":\"address\"},{\"internalType\":\"bytes12\",\"name\":\"gateKeeperId\",\"type\":\"bytes12\"}],\"internalType\":\"struct ETHCrowdfundBase.ETHCrowdfundOptions\",\"name\":\"opts\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"createGateCallData\",\"type\":\"bytes\"}],\"name\":\"createReraiseETHCrowdfund\",\"outputs\":[{\"internalType\":\"contract ReraiseETHCrowdfund\",\"name\":\"inst\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract RollingAuctionCrowdfund\",\"name\":\"crowdfundImpl\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"customizationPresetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"contract IMarketWrapper\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"contract IERC721\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"duration\",\"type\":\"uint40\"},{\"internalType\":\"uint96\",\"name\":\"maximumBid\",\"type\":\"uint96\"},{\"internalType\":\"address payable\",\"name\":\"splitRecipient\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"splitBps\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"initialContributor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialDelegate\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"minContribution\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxContribution\",\"type\":\"uint96\"},{\"internalType\":\"contract IGateKeeper\",\"name\":\"gateKeeper\",\"type\":\"address\"},{\"internalType\":\"bytes12\",\"name\":\"gateKeeperId\",\"type\":\"bytes12\"},{\"internalType\":\"bool\",\"name\":\"onlyHostCanBid\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract Party\",\"name\":\"partyImpl\",\"type\":\"address\"},{\"internalType\":\"contract IPartyFactory\",\"name\":\"partyFactory\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"hosts\",\"type\":\"address[]\"},{\"internalType\":\"uint40\",\"name\":\"voteDuration\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"executionDelay\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"passThresholdBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"internalType\":\"struct Crowdfund.FixedGovernanceOpts\",\"name\":\"governanceOpts\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"enableAddAuthorityProposal\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowArbCallsToSpendPartyEth\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowOperators\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"distributionsRequireVote\",\"type\":\"bool\"}],\"internalType\":\"struct ProposalStorage.ProposalEngineOpts\",\"name\":\"proposalEngineOpts\",\"type\":\"tuple\"}],\"internalType\":\"struct AuctionCrowdfundBase.AuctionCrowdfundOptions\",\"name\":\"opts\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"allowedAuctionsMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"createGateCallData\",\"type\":\"bytes\"}],\"name\":\"createRollingAuctionCrowdfund\",\"outputs\":[{\"internalType\":\"contract RollingAuctionCrowdfund\",\"name\":\"inst\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "CrowdfundFactory", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}