{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/test/uniswap/core/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n\\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n\\tfunction feeTo() external view returns (address);\\n\\n\\tfunction feeToSetter() external view returns (address);\\n\\n\\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n\\tfunction allPairs(uint) external view returns (address pair);\\n\\n\\tfunction allPairsLength() external view returns (uint);\\n\\n\\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n\\tfunction setFeeTo(address) external;\\n\\n\\tfunction setFeeToSetter(address) external;\\n\\n\\tfunction getInitHash() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/test/uniswap/periphery/UniswapV2Router02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.12;\\n\\nimport \\\"./libraries/TransferHelper.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Router02.sol\\\";\\nimport \\\"./libraries/UniswapV2Library.sol\\\";\\nimport \\\"./libraries/SafeMath.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IWETH.sol\\\";\\n\\ncontract UniswapV2Router02 is IUniswapV2Router02 {\\n\\tusing SafeMath for uint;\\n\\n\\taddress public immutable factory;\\n\\taddress public immutable WETH;\\n\\n\\tmodifier ensure(uint deadline) {\\n\\t\\trequire(deadline >= block.timestamp, \\\"UniswapV2Router: EXPIRED\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\tconstructor(address _factory, address _WETH) {\\n\\t\\tfactory = _factory;\\n\\t\\tWETH = _WETH;\\n\\t}\\n\\n\\treceive() external payable {\\n\\t\\tassert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\\n\\t}\\n\\n\\t// **** ADD LIQUIDITY ****\\n\\tfunction _addLiquidity(\\n\\t\\taddress tokenA,\\n\\t\\taddress tokenB,\\n\\t\\tuint amountADesired,\\n\\t\\tuint amountBDesired,\\n\\t\\tuint amountAMin,\\n\\t\\tuint amountBMin\\n\\t) internal virtual returns (uint amountA, uint amountB) {\\n\\t\\t// create the pair if it doesn't exist yet\\n\\t\\tif (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\\n\\t\\t\\tIUniswapV2Factory(factory).createPair(tokenA, tokenB);\\n\\t\\t}\\n\\t\\t(uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\\n\\t\\tif (reserveA == 0 && reserveB == 0) {\\n\\t\\t\\t(amountA, amountB) = (amountADesired, amountBDesired);\\n\\t\\t} else {\\n\\t\\t\\tuint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\\n\\t\\t\\tif (amountBOptimal <= amountBDesired) {\\n\\t\\t\\t\\trequire(amountBOptimal >= amountBMin, \\\"UniswapV2Router: INSUFFICIENT_B_AMOUNT\\\");\\n\\t\\t\\t\\t(amountA, amountB) = (amountADesired, amountBOptimal);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tuint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\\n\\t\\t\\t\\tassert(amountAOptimal <= amountADesired);\\n\\t\\t\\t\\trequire(amountAOptimal >= amountAMin, \\\"UniswapV2Router: INSUFFICIENT_A_AMOUNT\\\");\\n\\t\\t\\t\\t(amountA, amountB) = (amountAOptimal, amountBDesired);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction addLiquidity(\\n\\t\\taddress tokenA,\\n\\t\\taddress tokenB,\\n\\t\\tuint amountADesired,\\n\\t\\tuint amountBDesired,\\n\\t\\tuint amountAMin,\\n\\t\\tuint amountBMin,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\\n\\t\\t(amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\\n\\t\\taddress pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\\n\\n\\t\\tTransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\\n\\t\\tTransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\\n\\n\\t\\tliquidity = IUniswapV2Pair(pair).mint(to);\\n\\t}\\n\\n\\tfunction addLiquidityETH(\\n\\t\\taddress token,\\n\\t\\tuint amountTokenDesired,\\n\\t\\tuint amountTokenMin,\\n\\t\\tuint amountETHMin,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external payable virtual override ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\\n\\t\\t(amountToken, amountETH) = _addLiquidity(\\n\\t\\t\\ttoken,\\n\\t\\t\\tWETH,\\n\\t\\t\\tamountTokenDesired,\\n\\t\\t\\tmsg.value,\\n\\t\\t\\tamountTokenMin,\\n\\t\\t\\tamountETHMin\\n\\t\\t);\\n\\t\\taddress pair = UniswapV2Library.pairFor(factory, token, WETH);\\n\\t\\tTransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\\n\\t\\tIWETH(WETH).deposit{value: amountETH}();\\n\\t\\tassert(IWETH(WETH).transfer(pair, amountETH));\\n\\t\\tliquidity = IUniswapV2Pair(pair).mint(to);\\n\\t\\t// refund dust eth, if any\\n\\t\\tif (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\\n\\t}\\n\\n\\t// **** REMOVE LIQUIDITY ****\\n\\tfunction removeLiquidity(\\n\\t\\taddress tokenA,\\n\\t\\taddress tokenB,\\n\\t\\tuint liquidity,\\n\\t\\tuint amountAMin,\\n\\t\\tuint amountBMin,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\\n\\t\\taddress pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\\n\\t\\tIUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\\n\\t\\t(uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);\\n\\t\\t(address token0, ) = UniswapV2Library.sortTokens(tokenA, tokenB);\\n\\t\\t(amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\\n\\t\\trequire(amountA >= amountAMin, \\\"UniswapV2Router: INSUFFICIENT_A_AMOUNT\\\");\\n\\t\\trequire(amountB >= amountBMin, \\\"UniswapV2Router: INSUFFICIENT_B_AMOUNT\\\");\\n\\t}\\n\\n\\tfunction removeLiquidityETH(\\n\\t\\taddress token,\\n\\t\\tuint liquidity,\\n\\t\\tuint amountTokenMin,\\n\\t\\tuint amountETHMin,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\\n\\t\\t(amountToken, amountETH) = removeLiquidity(\\n\\t\\t\\ttoken,\\n\\t\\t\\tWETH,\\n\\t\\t\\tliquidity,\\n\\t\\t\\tamountTokenMin,\\n\\t\\t\\tamountETHMin,\\n\\t\\t\\taddress(this),\\n\\t\\t\\tdeadline\\n\\t\\t);\\n\\t\\tTransferHelper.safeTransfer(token, to, amountToken);\\n\\t\\tIWETH(WETH).withdraw(amountETH);\\n\\t\\tTransferHelper.safeTransferETH(to, amountETH);\\n\\t}\\n\\n\\t// **** SWAP ****\\n\\t// requires the initial amount to have already been sent to the first pair\\n\\tfunction _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\\n\\t\\tuint256 length = path.length;\\n\\t\\tfor (uint i; i < length - 1; i++) {\\n\\t\\t\\t(address input, address output) = (path[i], path[i + 1]);\\n\\t\\t\\t(address token0, ) = UniswapV2Library.sortTokens(input, output);\\n\\t\\t\\tuint amountOut = amounts[i + 1];\\n\\t\\t\\t(uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\\n\\t\\t\\taddress to = i < length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\\n\\t\\t\\tIUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(\\n\\t\\t\\t\\tamount0Out,\\n\\t\\t\\t\\tamount1Out,\\n\\t\\t\\t\\tto,\\n\\t\\t\\t\\tnew bytes(0)\\n\\t\\t\\t);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction swapExactTokensForTokens(\\n\\t\\tuint amountIn,\\n\\t\\tuint amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external virtual override ensure(deadline) returns (uint[] memory amounts) {\\n\\t\\tamounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\\n\\t\\trequire(amounts[amounts.length - 1] >= amountOutMin, \\\"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\\\");\\n\\t\\tTransferHelper.safeTransferFrom(\\n\\t\\t\\tpath[0],\\n\\t\\t\\tmsg.sender,\\n\\t\\t\\tUniswapV2Library.pairFor(factory, path[0], path[1]),\\n\\t\\t\\tamounts[0]\\n\\t\\t);\\n\\t\\t_swap(amounts, path, to);\\n\\t}\\n\\n\\tfunction swapTokensForExactTokens(\\n\\t\\tuint amountOut,\\n\\t\\tuint amountInMax,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external virtual override ensure(deadline) returns (uint[] memory amounts) {\\n\\t\\tamounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\\n\\t\\trequire(amounts[0] <= amountInMax, \\\"UniswapV2Router: EXCESSIVE_INPUT_AMOUNT\\\");\\n\\t\\tTransferHelper.safeTransferFrom(\\n\\t\\t\\tpath[0],\\n\\t\\t\\tmsg.sender,\\n\\t\\t\\tUniswapV2Library.pairFor(factory, path[0], path[1]),\\n\\t\\t\\tamounts[0]\\n\\t\\t);\\n\\t\\t_swap(amounts, path, to);\\n\\t}\\n\\n\\tfunction swapExactETHForTokens(\\n\\t\\tuint amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external payable virtual override ensure(deadline) returns (uint[] memory amounts) {\\n\\t\\trequire(path[0] == WETH, \\\"UniswapV2Router: INVALID_PATH\\\");\\n\\t\\tamounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\\n\\t\\trequire(amounts[amounts.length - 1] >= amountOutMin, \\\"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\\\");\\n\\t\\tIWETH(WETH).deposit{value: amounts[0]}();\\n\\t\\tassert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\\n\\t\\t_swap(amounts, path, to);\\n\\t}\\n\\n\\tfunction swapTokensForExactETH(\\n\\t\\tuint amountOut,\\n\\t\\tuint amountInMax,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external virtual override ensure(deadline) returns (uint[] memory amounts) {\\n\\t\\trequire(path[path.length - 1] == WETH, \\\"UniswapV2Router: INVALID_PATH\\\");\\n\\t\\tamounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\\n\\t\\trequire(amounts[0] <= amountInMax, \\\"UniswapV2Router: EXCESSIVE_INPUT_AMOUNT\\\");\\n\\t\\tTransferHelper.safeTransferFrom(\\n\\t\\t\\tpath[0],\\n\\t\\t\\tmsg.sender,\\n\\t\\t\\tUniswapV2Library.pairFor(factory, path[0], path[1]),\\n\\t\\t\\tamounts[0]\\n\\t\\t);\\n\\t\\t_swap(amounts, path, address(this));\\n\\t\\tIWETH(WETH).withdraw(amounts[amounts.length - 1]);\\n\\t\\tTransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\n\\t}\\n\\n\\tfunction swapExactTokensForETH(\\n\\t\\tuint amountIn,\\n\\t\\tuint amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external virtual override ensure(deadline) returns (uint[] memory amounts) {\\n\\t\\trequire(path[path.length - 1] == WETH, \\\"UniswapV2Router: INVALID_PATH\\\");\\n\\t\\tamounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\\n\\t\\trequire(amounts[amounts.length - 1] >= amountOutMin, \\\"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\\\");\\n\\t\\tTransferHelper.safeTransferFrom(\\n\\t\\t\\tpath[0],\\n\\t\\t\\tmsg.sender,\\n\\t\\t\\tUniswapV2Library.pairFor(factory, path[0], path[1]),\\n\\t\\t\\tamounts[0]\\n\\t\\t);\\n\\t\\t_swap(amounts, path, address(this));\\n\\t\\tIWETH(WETH).withdraw(amounts[amounts.length - 1]);\\n\\t\\tTransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\n\\t}\\n\\n\\tfunction swapETHForExactTokens(\\n\\t\\tuint amountOut,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external payable virtual override ensure(deadline) returns (uint[] memory amounts) {\\n\\t\\trequire(path[0] == WETH, \\\"UniswapV2Router: INVALID_PATH\\\");\\n\\t\\tamounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\\n\\t\\trequire(amounts[0] <= msg.value, \\\"UniswapV2Router: EXCESSIVE_INPUT_AMOUNT\\\");\\n\\t\\tIWETH(WETH).deposit{value: amounts[0]}();\\n\\t\\tassert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\\n\\t\\t_swap(amounts, path, to);\\n\\t\\t// refund dust eth, if any\\n\\t\\tif (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\\n\\t}\\n\\n\\t// **** LIBRARY FUNCTIONS ****\\n\\tfunction quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {\\n\\t\\treturn UniswapV2Library.quote(amountA, reserveA, reserveB);\\n\\t}\\n\\n\\tfunction getAmountOut(\\n\\t\\tuint amountIn,\\n\\t\\tuint reserveIn,\\n\\t\\tuint reserveOut\\n\\t) public pure virtual override returns (uint amountOut) {\\n\\t\\treturn UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\\n\\t}\\n\\n\\tfunction getAmountIn(\\n\\t\\tuint amountOut,\\n\\t\\tuint reserveIn,\\n\\t\\tuint reserveOut\\n\\t) public pure virtual override returns (uint amountIn) {\\n\\t\\treturn UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\\n\\t}\\n\\n\\tfunction getAmountsOut(\\n\\t\\tuint amountIn,\\n\\t\\taddress[] memory path\\n\\t) public view virtual override returns (uint[] memory amounts) {\\n\\t\\treturn UniswapV2Library.getAmountsOut(factory, amountIn, path);\\n\\t}\\n\\n\\tfunction getAmountsIn(\\n\\t\\tuint amountOut,\\n\\t\\taddress[] memory path\\n\\t) public view virtual override returns (uint[] memory amounts) {\\n\\t\\treturn UniswapV2Library.getAmountsIn(factory, amountOut, path);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/test/uniswap/periphery/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity >=0.5.0;\\n\\ninterface IERC20 {\\n\\tevent Approval(address indexed owner, address indexed spender, uint value);\\n\\tevent Transfer(address indexed from, address indexed to, uint value);\\n\\n\\tfunction name() external view returns (string memory);\\n\\n\\tfunction symbol() external view returns (string memory);\\n\\n\\tfunction decimals() external view returns (uint8);\\n\\n\\tfunction totalSupply() external view returns (uint);\\n\\n\\tfunction balanceOf(address owner) external view returns (uint);\\n\\n\\tfunction allowance(address owner, address spender) external view returns (uint);\\n\\n\\tfunction approve(address spender, uint value) external returns (bool);\\n\\n\\tfunction transfer(address to, uint value) external returns (bool);\\n\\n\\tfunction transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/test/uniswap/periphery/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n\\tfunction factory() external view returns (address);\\n\\n\\tfunction WETH() external view returns (address);\\n\\n\\tfunction addLiquidity(\\n\\t\\taddress tokenA,\\n\\t\\taddress tokenB,\\n\\t\\tuint amountADesired,\\n\\t\\tuint amountBDesired,\\n\\t\\tuint amountAMin,\\n\\t\\tuint amountBMin,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n\\tfunction addLiquidityETH(\\n\\t\\taddress token,\\n\\t\\tuint amountTokenDesired,\\n\\t\\tuint amountTokenMin,\\n\\t\\tuint amountETHMin,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n\\tfunction removeLiquidity(\\n\\t\\taddress tokenA,\\n\\t\\taddress tokenB,\\n\\t\\tuint liquidity,\\n\\t\\tuint amountAMin,\\n\\t\\tuint amountBMin,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external returns (uint amountA, uint amountB);\\n\\n\\tfunction removeLiquidityETH(\\n\\t\\taddress token,\\n\\t\\tuint liquidity,\\n\\t\\tuint amountTokenMin,\\n\\t\\tuint amountETHMin,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external returns (uint amountToken, uint amountETH);\\n\\n\\tfunction swapExactTokensForTokens(\\n\\t\\tuint amountIn,\\n\\t\\tuint amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external returns (uint[] memory amounts);\\n\\n\\tfunction swapTokensForExactTokens(\\n\\t\\tuint amountOut,\\n\\t\\tuint amountInMax,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external returns (uint[] memory amounts);\\n\\n\\tfunction swapExactETHForTokens(\\n\\t\\tuint amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external payable returns (uint[] memory amounts);\\n\\n\\tfunction swapTokensForExactETH(\\n\\t\\tuint amountOut,\\n\\t\\tuint amountInMax,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external returns (uint[] memory amounts);\\n\\n\\tfunction swapExactTokensForETH(\\n\\t\\tuint amountIn,\\n\\t\\tuint amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external returns (uint[] memory amounts);\\n\\n\\tfunction swapETHForExactTokens(\\n\\t\\tuint amountOut,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external payable returns (uint[] memory amounts);\\n\\n\\tfunction quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n\\n\\tfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n\\n\\tfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n\\n\\tfunction getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n\\n\\tfunction getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/test/uniswap/periphery/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity >=0.6.2;\\n\\nimport \\\"./IUniswapV2Router01.sol\\\";\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {}\\n\"\r\n    },\r\n    \"contracts/test/uniswap/periphery/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity >=0.5.0;\\n\\ninterface IWETH {\\n\\tfunction deposit() external payable;\\n\\n\\tfunction transfer(address to, uint value) external returns (bool);\\n\\n\\tfunction withdraw(uint) external;\\n\\n\\tfunction balanceOf(address guy) external returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/test/uniswap/periphery/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.12;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n\\tfunction add(uint x, uint y) internal pure returns (uint z) {\\n\\t\\trequire((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n\\t}\\n\\n\\tfunction sub(uint x, uint y) internal pure returns (uint z) {\\n\\t\\trequire((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n\\t}\\n\\n\\tfunction mul(uint x, uint y) internal pure returns (uint z) {\\n\\t\\trequire(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/test/uniswap/periphery/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n\\tfunction safeTransfer(address token, address to, uint256 value) internal {\\n\\t\\t// bytes4(keccak256(bytes('transfer(address,uint256)')));\\n\\t\\t(bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n\\t\\trequire(\\n\\t\\t\\tsuccess && (data.length == 0 || abi.decode(data, (bool))),\\n\\t\\t\\t\\\"TransferHelper::safeTransfer: transfer failed\\\"\\n\\t\\t);\\n\\t}\\n\\n\\tfunction safeTransferFrom(address token, address from, address to, uint256 value) internal {\\n\\t\\t// bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n\\t\\t(bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n\\t\\trequire(\\n\\t\\t\\tsuccess && (data.length == 0 || abi.decode(data, (bool))),\\n\\t\\t\\t\\\"TransferHelper::transferFrom: transferFrom failed\\\"\\n\\t\\t);\\n\\t}\\n\\n\\tfunction safeTransferETH(address to, uint256 value) internal {\\n\\t\\t(bool success, ) = to.call{value: value}(new bytes(0));\\n\\t\\trequire(success, \\\"TransferHelper::safeTransferETH: ETH transfer failed\\\");\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/test/uniswap/periphery/libraries/UniswapV2Library.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.12;\\n\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\n// import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\\nimport \\\"../../core/interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary UniswapV2Library {\\n\\tusing SafeMath for uint;\\n\\n\\t// returns sorted token addresses, used to handle return values from pairs sorted in this order\\n\\tfunction sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n\\t\\trequire(tokenA != tokenB, \\\"UniswapV2Library: IDENTICAL_ADDRESSES\\\");\\n\\t\\t(token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n\\t\\trequire(token0 != address(0), \\\"UniswapV2Library: ZERO_ADDRESS\\\");\\n\\t}\\n\\n\\t// calculates the CREATE2 address for a pair without making any external calls\\n\\tfunction pairFor(address factory, address tokenA, address tokenB) internal view returns (address pair) {\\n\\t\\t(address token0, address token1) = sortTokens(tokenA, tokenB);\\n\\t\\tpair = address(\\n\\t\\t\\tuint160(\\n\\t\\t\\t\\tuint(\\n\\t\\t\\t\\t\\tkeccak256(\\n\\t\\t\\t\\t\\t\\tabi.encodePacked(\\n\\t\\t\\t\\t\\t\\t\\thex\\\"ff\\\",\\n\\t\\t\\t\\t\\t\\t\\tfactory,\\n\\t\\t\\t\\t\\t\\t\\tkeccak256(abi.encodePacked(token0, token1)),\\n\\t\\t\\t\\t\\t\\t\\tIUniswapV2Factory(factory).getInitHash()\\n\\t\\t\\t\\t\\t\\t\\t// hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\t\\t);\\n\\t}\\n\\n\\t// fetches and sorts the reserves for a pair\\n\\tfunction getReserves(\\n\\t\\taddress factory,\\n\\t\\taddress tokenA,\\n\\t\\taddress tokenB\\n\\t) internal view returns (uint reserveA, uint reserveB) {\\n\\t\\t(address token0, ) = sortTokens(tokenA, tokenB);\\n\\t\\t(uint reserve0, uint reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\\n\\n\\t\\t(reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n\\t}\\n\\n\\t// given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n\\tfunction quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\\n\\t\\trequire(amountA > 0, \\\"UniswapV2Library: INSUFFICIENT_AMOUNT\\\");\\n\\t\\trequire(reserveA > 0 && reserveB > 0, \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\");\\n\\t\\tamountB = amountA.mul(reserveB) / reserveA;\\n\\t}\\n\\n\\t// given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n\\tfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\\n\\t\\trequire(amountIn > 0, \\\"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\\\");\\n\\t\\trequire(reserveIn > 0 && reserveOut > 0, \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\");\\n\\t\\tuint amountInWithFee = amountIn.mul(997);\\n\\t\\tuint numerator = amountInWithFee.mul(reserveOut);\\n\\t\\tuint denominator = reserveIn.mul(1000).add(amountInWithFee);\\n\\t\\tamountOut = numerator / denominator;\\n\\t}\\n\\n\\t// given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n\\tfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\\n\\t\\trequire(amountOut > 0, \\\"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\\\");\\n\\t\\trequire(reserveIn > 0 && reserveOut > 0, \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\");\\n\\t\\tuint numerator = reserveIn.mul(amountOut).mul(1000);\\n\\t\\tuint denominator = reserveOut.sub(amountOut).mul(997);\\n\\t\\tamountIn = (numerator / denominator).add(1);\\n\\t}\\n\\n\\t// performs chained getAmountOut calculations on any number of pairs\\n\\tfunction getAmountsOut(\\n\\t\\taddress factory,\\n\\t\\tuint amountIn,\\n\\t\\taddress[] memory path\\n\\t) internal view returns (uint[] memory amounts) {\\n\\t\\trequire(path.length >= 2, \\\"UniswapV2Library: INVALID_PATH\\\");\\n\\t\\tamounts = new uint[](path.length);\\n\\t\\tamounts[0] = amountIn;\\n\\t\\tfor (uint i; i < path.length - 1; i++) {\\n\\t\\t\\t(uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\\n\\t\\t\\tamounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\n\\t\\t}\\n\\t}\\n\\n\\t// performs chained getAmountIn calculations on any number of pairs\\n\\tfunction getAmountsIn(\\n\\t\\taddress factory,\\n\\t\\tuint amountOut,\\n\\t\\taddress[] memory path\\n\\t) internal view returns (uint[] memory amounts) {\\n\\t\\trequire(path.length >= 2, \\\"UniswapV2Library: INVALID_PATH\\\");\\n\\t\\tamounts = new uint[](path.length);\\n\\t\\tamounts[amounts.length - 1] = amountOut;\\n\\t\\tfor (uint i = path.length - 1; i > 0; i--) {\\n\\t\\t\\t(uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\\n\\t\\t\\tamounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n\\t\\t}\\n\\t}\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountADesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveOut\",\"type\":\"uint256\"}],\"name\":\"getAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveOut\",\"type\":\"uint256\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"getAmountsIn\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"getAmountsOut\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveB\",\"type\":\"uint256\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapETHForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "UniswapV2Router02", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "000000000000000000000000b9104d590ba8ee02b7916d09414343cdbf83e759000000000000000000000000be666bb32a8e4b6b2f2d0fb053d965bdfa277223", "EVMVersion": "london", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": ""}