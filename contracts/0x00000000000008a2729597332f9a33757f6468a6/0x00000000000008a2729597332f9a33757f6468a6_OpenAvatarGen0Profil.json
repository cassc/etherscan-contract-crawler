{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/assets/OpenAvatarGen0AssetsCanvasIdStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title OpenAvatarGen0AssetsCanvasIdStore\\n * @dev This contracts stores a canvas ID.\\n */\\nabstract contract OpenAvatarGen0AssetsCanvasIdStore {\\n  /// @notice The canvas ID.\\n  uint8 public canvasId;\\n\\n  constructor(uint8 canvasId_) {\\n    canvasId = canvasId_;\\n  }\\n\\n  /**\\n   * @notice Get the canvas ID.\\n   * @return The canvas ID.\\n   */\\n  function getCanvasId() external view returns (uint8) {\\n    return canvasId;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/dependencies/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\n// Adapted from:\\n// https://github.com/Brechtpd/base64/blob/4d85607b18d981acff392d2e99ba654305552a97/base64.sol\\n\\n// solhint-disable no-empty-blocks\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides functions for encoding/decoding base64\\nlibrary Base64 {\\n  string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n  bytes internal constant TABLE_DECODE =\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'00000000000000000000003e0000003f3435363738393a3b3c3d000000000000'\\n    hex'00000102030405060708090a0b0c0d0e0f101112131415161718190000000000'\\n    hex'001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000';\\n\\n  function encode(bytes memory data) internal pure returns (bytes memory) {\\n    if (data.length == 0) return '';\\n\\n    // load the table into memory\\n    string memory table = TABLE_ENCODE;\\n\\n    // multiply by 4/3 rounded up\\n    uint encodedLen = 4 * ((data.length + 2) / 3);\\n\\n    // add some extra buffer at the end required for the writing\\n    bytes memory result = new bytes(encodedLen + 32);\\n\\n    assembly {\\n      // set the actual output length\\n      mstore(result, encodedLen)\\n\\n      // prepare the lookup table\\n      let tablePtr := add(table, 1)\\n\\n      // input ptr\\n      let dataPtr := data\\n      let endPtr := add(dataPtr, mload(data))\\n\\n      // result ptr, jump over length\\n      let resultPtr := add(result, 32)\\n\\n      // run over the input, 3 bytes at a time\\n      for {\\n\\n      } lt(dataPtr, endPtr) {\\n\\n      } {\\n        // read 3 bytes\\n        dataPtr := add(dataPtr, 3)\\n        let input := mload(dataPtr)\\n\\n        // write 4 characters\\n        mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n        resultPtr := add(resultPtr, 1)\\n        mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n        resultPtr := add(resultPtr, 1)\\n        mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n        resultPtr := add(resultPtr, 1)\\n        mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n        resultPtr := add(resultPtr, 1)\\n      }\\n\\n      // padding with '='\\n      switch mod(mload(data), 3)\\n      case 1 {\\n        mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n      }\\n      case 2 {\\n        mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n      }\\n    }\\n\\n    return result;\\n  }\\n\\n  function decode(string memory _data) internal pure returns (bytes memory) {\\n    bytes memory data = bytes(_data);\\n\\n    if (data.length == 0) return new bytes(0);\\n    require(data.length % 4 == 0, 'invalid base64 decoder input');\\n\\n    // load the table into memory\\n    bytes memory table = TABLE_DECODE;\\n\\n    // every 4 characters represent 3 bytes\\n    uint decodedLen = (data.length / 4) * 3;\\n\\n    // add some extra buffer at the end required for the writing\\n    bytes memory result = new bytes(decodedLen + 32);\\n\\n    assembly {\\n      // padding with '='\\n      let lastBytes := mload(add(data, mload(data)))\\n      if eq(and(lastBytes, 0xFF), 0x3d) {\\n        decodedLen := sub(decodedLen, 1)\\n        if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\\n          decodedLen := sub(decodedLen, 1)\\n        }\\n      }\\n\\n      // set the actual output length\\n      mstore(result, decodedLen)\\n\\n      // prepare the lookup table\\n      let tablePtr := add(table, 1)\\n\\n      // input ptr\\n      let dataPtr := data\\n      let endPtr := add(dataPtr, mload(data))\\n\\n      // result ptr, jump over length\\n      let resultPtr := add(result, 32)\\n\\n      // run over the input, 4 characters at a time\\n      for {\\n\\n      } lt(dataPtr, endPtr) {\\n\\n      } {\\n        // read 4 characters\\n        dataPtr := add(dataPtr, 4)\\n        let input := mload(dataPtr)\\n\\n        // write 3 bytes\\n        let output := add(\\n          add(\\n            shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\\n            shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))\\n          ),\\n          add(\\n            shl(6, and(mload(add(tablePtr, and(shr(8, input), 0xFF))), 0xFF)),\\n            and(mload(add(tablePtr, and(input, 0xFF))), 0xFF)\\n          )\\n        )\\n        mstore(resultPtr, shl(232, output))\\n        resultPtr := add(resultPtr, 3)\\n      }\\n    }\\n\\n    return result;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/dependencies/ens/registry/ENS.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.4;\\n\\ninterface ENS {\\n  /**\\n   * @dev Returns the address that owns the specified node.\\n   * @param node The specified node.\\n   * @return address of the owner.\\n   */\\n  function owner(bytes32 node) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/core/dependencies/ens/reverseRegistrar/IReverseRegistrar.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.4;\\n\\ninterface IReverseRegistrar {\\n  /**\\n   * @dev Transfers ownership of the reverse ENS record associated with the\\n   *      calling account.\\n   * @param owner The address to set as the owner of the reverse record in ENS.\\n   * @return The ENS node hash of the reverse record.\\n   */\\n  function claim(address owner) external returns (bytes32);\\n\\n  /**\\n   * @dev Sets the `name()` record for the reverse ENS record associated with\\n   * the calling account. First updates the resolver to the default reverse\\n   * resolver if necessary.\\n   * @param name The name to set for this address.\\n   * @return The ENS node hash of the reverse record.\\n   */\\n  function setName(string memory name) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/core/dependencies/IERC634.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title IERC634: Text Data Interface\\n * @dev This is the same as EIP-634 with different variable names\\n * - rename node -> dna\\n * - +calldata for key in text()\\n * - +external for text()\\n * - +memory for return value of text()\\n */\\ninterface IERC634 {\\n  /**\\n   * @notice Returns the text data associated with a DNA\\n   * @param dna A DNA to lookup text data for\\n   * @param key A key to lookup text data for\\n   * @return text The text data\\n   */\\n  function text(bytes32 dna, string calldata key) external view returns (string memory text);\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/assets/IOpenAvatarGen0AssetsCanvasStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nstruct CanvasHeader {\\n  uint8 id;\\n  uint8 width;\\n  uint8 height;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsCanvasStoreRead\\n * @dev This interface reads canvas headers.\\n */\\ninterface IOpenAvatarGen0AssetsCanvasStoreRead {\\n  function hasCanvas(uint8 id) external view returns (bool);\\n\\n  function getCanvasHeader(uint8 id) external view returns (CanvasHeader memory);\\n\\n  function getNumCanvasIds() external view returns (uint);\\n\\n  function getCanvasIds() external view returns (uint8[] memory);\\n\\n  function getCanvasHeight(uint8 id) external view returns (uint8);\\n\\n  function getCanvasWidth(uint8 id) external view returns (uint8);\\n\\n  function getCanvasNumBytes(uint8 id) external view returns (uint);\\n\\n  function getCanvasNumPixels(uint8 id) external view returns (uint);\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsCanvasStoreWrite\\n * @dev This interface writes canvas headers\\n */\\ninterface IOpenAvatarGen0AssetsCanvasStoreWrite {\\n  function addCanvas(CanvasHeader calldata header) external;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsCanvasStore\\n * @dev This interface reads and writes canvas headers\\n */\\ninterface IOpenAvatarGen0AssetsCanvasStore is\\n  IOpenAvatarGen0AssetsCanvasStoreRead,\\n  IOpenAvatarGen0AssetsCanvasStoreWrite\\n{\\n\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/assets/IOpenAvatarGen0AssetsPaletteStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title IOpenAvatarGen0AssetsPaletteStoreRead\\n * @dev This interface allows reading from the palette store.\\n */\\ninterface IOpenAvatarGen0AssetsPaletteStoreRead {\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Constants\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function hasAlphaChannel() external view returns (bool);\\n\\n  function getBytesPerPixel() external view returns (uint8);\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Palettes\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function getNumPaletteCodes() external view returns (uint);\\n\\n  function getNumPalettes(uint8 code) external view returns (uint);\\n\\n  function getPalette(uint8 code, uint8 index) external view returns (bytes4[] memory);\\n}\\n\\nstruct UploadPaletteInput {\\n  uint8 code;\\n  uint8 index;\\n  bytes4[] palette;\\n}\\n\\nstruct UploadPaletteBatchInput {\\n  uint8 code;\\n  uint8 fromIndex;\\n  bytes4[][] palettes;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsPaletteStoreWrite\\n * @dev This interface allows writing to the palette store.\\n */\\ninterface IOpenAvatarGen0AssetsPaletteStoreWrite {\\n  function uploadPalette(UploadPaletteInput calldata input) external;\\n\\n  function uploadPaletteBatch(UploadPaletteBatchInput calldata input) external;\\n\\n  function uploadPaletteBatches(UploadPaletteBatchInput[] calldata input) external;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsPaletteStore\\n * @dev This interface allows reading from and writing to the palette store.\\n */\\ninterface IOpenAvatarGen0AssetsPaletteStore is\\n  IOpenAvatarGen0AssetsPaletteStoreRead,\\n  IOpenAvatarGen0AssetsPaletteStoreWrite\\n{\\n\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/assets/IOpenAvatarGen0AssetsPatternStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {IOpenAvatarGen0AssetsCanvasStore, IOpenAvatarGen0AssetsCanvasStoreRead, IOpenAvatarGen0AssetsCanvasStoreWrite} from './IOpenAvatarGen0AssetsCanvasStore.sol';\\nimport {IOpenAvatarGen0AssetsPaletteStoreRead, IOpenAvatarGen0AssetsPaletteStoreWrite, IOpenAvatarGen0AssetsPaletteStore} from './IOpenAvatarGen0AssetsPaletteStore.sol';\\n\\nstruct PatternHeader {\\n  /// @dev width of the pattern\\n  uint8 width;\\n  /// @dev height of the pattern\\n  uint8 height;\\n  /// @dev x offset of the pattern within the canvas\\n  uint8 offsetX;\\n  /// @dev y offset of the pattern within the canvas\\n  uint8 offsetY;\\n  /// @dev the palette code for the pattern\\n  uint8 paletteCode;\\n}\\n\\nstruct OptionalPatternHeader {\\n  /// @dev true if the header exists\\n  bool exists;\\n  /// @dev the pattern header\\n  /// @dev all zeroes is valid header\\n  PatternHeader header;\\n}\\n\\nstruct PatternBlob {\\n  /// @dev the pattern header\\n  PatternHeader header;\\n  /// @dev the pattern data\\n  bytes data;\\n}\\n\\nstruct UploadPatternInput {\\n  /// @dev the canvas id\\n  uint8 canvasId;\\n  /// @dev index of the layer within the canvas\\n  uint8 layer;\\n  /// @dev index of the pattern within the layer\\n  uint8 index;\\n  /// @dev width of the pattern\\n  uint8 width;\\n  /// @dev height of the pattern\\n  uint8 height;\\n  /// @dev x offset of the pattern within the canvas\\n  uint8 offsetX;\\n  /// @dev y offset of the pattern within the canvas\\n  uint8 offsetY;\\n  /// @dev the palette code for the pattern\\n  uint8 paletteCode;\\n  /// @dev the pattern data\\n  bytes data;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsPatternStoreRead\\n * @dev This interface reads pattern data\\n */\\ninterface IOpenAvatarGen0AssetsPatternStoreRead is IOpenAvatarGen0AssetsCanvasStoreRead {\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Layers\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function getNumLayers(uint8 canvasId) external view returns (uint);\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Patterns\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function getNumPatterns(uint8 canvasId, uint8 layer) external view returns (uint);\\n\\n  function getPatternHeader(\\n    uint8 canvasId,\\n    uint8 layer,\\n    uint8 index\\n  ) external view returns (OptionalPatternHeader memory);\\n\\n  function getPatternData(uint8 canvasId, uint8 layer, uint8 index) external view returns (bytes memory);\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsPatternStoreWrite\\n * @dev This interface writes pattern data\\n */\\ninterface IOpenAvatarGen0AssetsPatternStoreWrite is IOpenAvatarGen0AssetsCanvasStoreWrite {\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Layers\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function addLayer(uint8 canvasId, uint8 layer) external;\\n\\n  function addLayers(uint8 canvasId, uint8[] calldata layers) external;\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Patterns\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function uploadPattern(UploadPatternInput calldata input) external;\\n\\n  function uploadPatterns(UploadPatternInput[] calldata inputs) external;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsPatternStore\\n * @dev This interface reads and writes pattern data\\n */\\ninterface IOpenAvatarGen0AssetsPatternStore is\\n  IOpenAvatarGen0AssetsPatternStoreRead,\\n  IOpenAvatarGen0AssetsPatternStoreWrite,\\n  IOpenAvatarGen0AssetsCanvasStore\\n{\\n\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/render/IOpenAvatarGen0AssetsCanvasLayerCompositor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {PatternHeader} from '../assets/IOpenAvatarGen0AssetsPatternStore.sol';\\n\\nstruct LayerPatternPalette {\\n  uint8 layer;\\n  uint8 pattern;\\n  uint8 palette;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsCanvasLayerCompositor\\n * @dev This contract composes palettized patterns into a single image.\\n */\\ninterface IOpenAvatarGen0AssetsCanvasLayerCompositor {\\n  function createLayerComposition(\\n    uint8 canvasId,\\n    // is view function, so not concerned about calldata being cheaper\\n    // need memory because this function is called by other functions that\\n    // may compute layers dynamically in memory\\n    LayerPatternPalette[] memory layerPatternPalette\\n  ) external view returns (bytes memory);\\n\\n  function drawLayerComposition(\\n    bytes memory out,\\n    uint8 canvasId,\\n    // is view function, so not concerned about calldata being cheaper\\n    // need memory because this function is called by other functions that\\n    // may compute layers dynamically in memory\\n    LayerPatternPalette[] memory layerPatternPalette\\n  ) external view returns (bytes memory);\\n\\n  function drawLayer(\\n    bytes memory image,\\n    uint8 canvasId,\\n    uint8 layer,\\n    uint8 pattern,\\n    uint8 palette\\n  ) external view returns (bytes memory);\\n\\n  function drawMaskedLayer(\\n    bytes memory image,\\n    bytes memory mask,\\n    uint8 canvasId,\\n    uint8 layer,\\n    uint8 pattern,\\n    uint8 palette\\n  ) external view returns (bytes memory);\\n\\n  function drawPattern(\\n    bytes memory image,\\n    uint8 canvasId,\\n    PatternHeader memory header,\\n    bytes memory pattern,\\n    bytes4[] memory palette\\n  ) external view returns (bytes memory);\\n\\n  function drawMaskedPattern(\\n    bytes memory image,\\n    bytes memory mask,\\n    uint8 canvasId,\\n    PatternHeader memory header,\\n    bytes memory pattern,\\n    bytes4[] memory palette\\n  ) external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/render/IOpenAvatarGen0CanvasRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\ninterface IOpenAvatarGen0CanvasRenderer {\\n  function drawOpenAvatar(uint8 canvasId, bytes32 dna) external view returns (bytes memory);\\n\\n  function drawOpenAvatarOverlay(bytes memory image, uint8 canvasId, bytes32 dna) external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/core/lib/Adler32.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title Adler32\\n * @notice This contract implements the Adler32 checksum algorithm.\\n */\\nlibrary Adler32 {\\n  function adler32(bytes memory self, uint offset, uint end) internal pure returns (uint32) {\\n    unchecked {\\n      uint32 a = 1;\\n      uint32 b = 0;\\n\\n      // Process each byte of the data in order\\n      for (uint i = offset; i < end; i++) {\\n        a = (a + uint32(uint8(self[i]))) % 65521;\\n        b = (b + a) % 65521;\\n      }\\n\\n      // The Adler-32 checksum is stored as a 4-byte value\\n      return (b << 16) | a;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/lib/CRC32.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title CRC32\\n * @notice This contract implements the CRC32 checksum algorithm.\\n */\\nlibrary CRC32 {\\n  // CRC32 algorithm: https://en.wikipedia.org/wiki/Cyclic_redundancy_check\\n  /**\\n   * @dev Calculates the CRC32 checksum of a chunk of data.\\n   * @param self The data to calculate the checksum of.\\n   * @param start The start index of the data.\\n   * @param end The end index of the data.\\n   * @return checksum The CRC32 checksum of the data.\\n   */\\n  function crc32(bytes memory self, uint start, uint end) internal pure returns (uint32 checksum) {\\n    // Initialize the checksum to 0xffffffff\\n    checksum = 0xffffffff;\\n\\n    // Loop through each byte of the chunk data\\n    for (uint i = start; i < end; i++) {\\n      // XOR the byte with the checksum\\n      checksum = checksum ^ uint8(self[i]);\\n      // Loop through each bit of the byte\\n      for (uint j = 0; j < 8; j++) {\\n        // If the LSB of the checksum is 1\\n        if ((checksum & 1) == 1) {\\n          // 0xEDB88320 is the CRC-32 polynomial in reversed bit order\\n          // this translates to the polynomial with equation\\n          // x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1\\n          // which is the same as the one used in the PNG specification\\n          checksum = (checksum >> 1) ^ 0xedb88320;\\n        }\\n        // If the LSB of the checksum is 0\\n        else {\\n          // Shift the checksum right by 1 bit\\n          checksum = (checksum >> 1);\\n        }\\n      }\\n    }\\n\\n    // Return the inverted checksum\\n    return ~checksum;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/lib/DNA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\n/**\\n *  @title DNA\\n *  @notice This library implements the DNA as defined by OpenAvatar.\\n *  @dev The DNA string is a 32-byte hex string. The DNA string is immutable.\\n *  The bytes represent the following:\\n *  ZZZZ YYYY XXXX WWWW VVVV UUUU TTTT SSSS\\n *  0000 0000 0000 0000 0000 0000 0000 0000\\n *\\n *    Bytes  |  Chars  | Description\\n *  ---------|---------|-------------\\n *   [0:1]   | [0:3]   |  body\\n *   [2:3]   | [4:7]   |  tattoos\\n *   [4:5]   | [8:11]  |  makeup\\n *   [6:7]   | [12:15] |  left eye\\n *   [8:9]   | [16:19] |  right eye\\n *   [10:11] | [20:23] |  bottomwear\\n *   [12:13] | [24:27] |  footwear\\n *   [14:15] | [28:31] |  topwear\\n *   [16:17] | [32:35] |  handwear\\n *   [18:19] | [36:39] |  outerwear\\n *   [20:21] | [40:43] |  jewelry\\n *   [22:23] | [44:47] |  facial hair\\n *   [24:25] | [48:51] |  facewear\\n *   [26:27] | [52:55] |  eyewear\\n *   [28:29] | [56:59] |  hair\\n *   [30:31] | [60:63] |  reserved\\n *\\n *  Each 2-byte section is a struct of the following:\\n *    [0] | [0:1] |  pattern\\n *    [1] | [2:3] |  palette\\n *\\n * The pattern is an index into the pattern array.\\n * The palette is an index into the palette array.\\n */\\nlibrary DNA {\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Body\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [0:1]\\n\\n  /// @notice Returns the body pattern index from the DNA.\\n  function bodyPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[0]);\\n  }\\n\\n  /// @notice Returns the body palette index from the DNA.\\n  function bodyPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[1]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Tattoos\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [2:3]\\n\\n  /// @notice Returns the tattoos pattern index from the DNA.\\n  function tattoosPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[2]);\\n  }\\n\\n  /// @notice Returns the tattoos palette index from the DNA.\\n  function tattoosPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[3]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Makeup\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [4:5]\\n\\n  /// @notice Returns the makeup pattern index from the DNA.\\n  function makeupPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[4]);\\n  }\\n\\n  /// @notice Returns the makeup palette index from the DNA.\\n  function makeupPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[5]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Left Eye\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [6:7]\\n\\n  /// @notice Returns the left eye pattern index from the DNA.\\n  function leftEyePattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[6]);\\n  }\\n\\n  /// @notice Returns the left eye palette index from the DNA.\\n  function leftEyePalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[7]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Right Eye\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [8:9]\\n\\n  /// @notice Returns the right eye pattern index from the DNA.\\n  function rightEyePattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[8]);\\n  }\\n\\n  /// @notice Returns the right eye palette index from the DNA.\\n  function rightEyePalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[9]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Bottomwear\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [10:11]\\n\\n  /// @notice Returns the bottomwear pattern index from the DNA.\\n  function bottomwearPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[10]);\\n  }\\n\\n  /// @notice Returns the bottomwear palette index from the DNA.\\n  function bottomwearPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[11]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Footwear\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [12:13]\\n\\n  /// @notice Returns the footwear pattern index from the DNA.\\n  function footwearPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[12]);\\n  }\\n\\n  /// @notice Returns the footwear palette index from the DNA.\\n  function footwearPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[13]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Topwear\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [14:15]\\n\\n  /// @notice Returns the topwear pattern index from the DNA.\\n  function topwearPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[14]);\\n  }\\n\\n  /// @notice Returns the topwear palette index from the DNA.\\n  function topwearPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[15]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Handwear\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [16:17]\\n\\n  /// @notice Returns the handwear pattern index from the DNA.\\n  function handwearPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[16]);\\n  }\\n\\n  /// @notice Returns the handwear palette index from the DNA.\\n  function handwearPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[17]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Outerwear\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [18:19]\\n\\n  /// @notice Returns the outerwear pattern index from the DNA.\\n  function outerwearPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[18]);\\n  }\\n\\n  /// @notice Returns the outerwear palette index from the DNA.\\n  function outerwearPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[19]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Jewelry\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [20:21]\\n\\n  /// @notice Returns the jewelry pattern index from the DNA.\\n  function jewelryPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[20]);\\n  }\\n\\n  /// @notice Returns the jewelry palette index from the DNA.\\n  function jewelryPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[21]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Facial Hair\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [22:23]\\n\\n  /// @notice Returns the facial hair pattern index from the DNA.\\n  function facialHairPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[22]);\\n  }\\n\\n  /// @notice Returns the facial hair palette index from the DNA.\\n  function facialHairPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[23]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Facewear\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [24:25]\\n\\n  /// @notice Returns the facewear pattern index from the DNA.\\n  function facewearPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[24]);\\n  }\\n\\n  /// @notice Returns the facewear palette index from the DNA.\\n  function facewearPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[25]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Eyewear\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [26:27]\\n\\n  /// @notice Returns the eyewear pattern index from the DNA.\\n  function eyewearPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[26]);\\n  }\\n\\n  /// @notice Returns the eyewear palette index from the DNA.\\n  function eyewearPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[27]);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// Hair\\n  /////////////////////////////////////////////////////////////////////////////\\n  /// bytes [28:29]\\n\\n  /// @notice Returns the hair pattern index from the DNA.\\n  function hairPattern(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[28]);\\n  }\\n\\n  /// @notice Returns the hair palette index from the DNA.\\n  function hairPalette(bytes32 self) internal pure returns (uint8) {\\n    return uint8(self[29]);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/lib/ENSReverseClaimer.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\nimport {ENS} from '../dependencies/ens/registry/ENS.sol';\\nimport {IReverseRegistrar} from '../dependencies/ens/reverseRegistrar/IReverseRegistrar.sol';\\n\\n/**\\n * @title ENSReverseClaimer\\n * @dev This contract is used to claim reverse ENS records.\\n */\\nabstract contract ENSReverseClaimer is Ownable {\\n  /// @dev The namehash of 'addr.reverse', the domain at which reverse records\\n  ///      are stored in ENS.\\n  bytes32 constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\\n\\n  /**\\n   * @dev Transfers ownership of the reverse ENS record associated with the\\n   *      contract.\\n   * @param ens The ENS registry.\\n   * @param claimant The address to set as the owner of the reverse record in\\n   *                 ENS.\\n   * @return The ENS node hash of the reverse record.\\n   */\\n  function claimReverseENS(ENS ens, address claimant) external onlyOwner returns (bytes32) {\\n    return IReverseRegistrar(ens.owner(ADDR_REVERSE_NODE)).claim(claimant);\\n  }\\n\\n  /**\\n   * @dev Sets the reverse ENS record associated with the contract.\\n   * @param ens The ENS registry.\\n   * @param name The name to set as the reverse record in ENS.\\n   * @return The ENS node hash of the reverse record.\\n   */\\n  function setReverseENS(ENS ens, string calldata name) external onlyOwner returns (bytes32) {\\n    return IReverseRegistrar(ens.owner(ADDR_REVERSE_NODE)).setName(name);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/lib/ImageEncoder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\\nimport {Base64} from '../dependencies/Base64.sol';\\nimport {PNG} from './PNG.sol';\\n\\n/**\\n * @title ImageEncoder\\n * @dev A library for encoding images as PNG or SVG.\\n */\\ncontract ImageEncoder is PNG {\\n  /**\\n   * @notice Encodes the image as a Base64-encoded PNG.\\n   * @param data The raw image data.\\n   * @param width Width of the image data, in pixels.\\n   * @param height Height of the image data, in pixels.\\n   * @param alpha Whether the image has an alpha channel.\\n   * @return The encoded Base64-encoded PNG.\\n   */\\n  function encodeBase64PNG(bytes memory data, uint width, uint height, bool alpha) public pure returns (bytes memory) {\\n    bytes memory png = encodePNG(data, width, height, alpha);\\n    return Base64.encode(png);\\n  }\\n\\n  /**\\n   * @notice Encodes the image as an SVG.\\n   * @param data The raw image data.\\n   * @param width Width of the image data, in pixels.\\n   * @param height Height of the image, in pixels.\\n   * @param alpha Whether the image has an alpha channel.\\n   * @param svgWidth Width of the scaled SVG, in pixels.\\n   * @param svgHeight Height of the scaled SVG, in pixels.\\n   * @return The encoded SVG.\\n   */\\n  function encodeSVG(\\n    bytes memory data,\\n    uint width,\\n    uint height,\\n    bool alpha,\\n    uint svgWidth,\\n    uint svgHeight\\n  ) public pure returns (bytes memory) {\\n    bytes memory base64PNG = encodeBase64PNG(data, width, height, alpha);\\n    string memory svgWidthStr = Strings.toString(svgWidth);\\n    string memory svgHeightStr = Strings.toString(svgHeight);\\n    return\\n      abi.encodePacked(\\n        '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 ',\\n        svgWidthStr,\\n        ' ',\\n        svgHeightStr,\\n        '\\\">\\\\n\\\\t<foreignObject width=\\\"',\\n        svgWidthStr,\\n        '\\\" height=\\\"',\\n        svgHeightStr,\\n        '\\\">\\\\n\\\\t\\\\t<img xmlns=\\\"http://www.w3.org/1999/xhtml\\\" width=\\\"',\\n        svgWidthStr,\\n        '\\\" height=\\\"',\\n        svgHeightStr,\\n        '\\\" style=\\\"image-rendering: pixelated;\\\" src=\\\"data:image/png;base64,',\\n        base64PNG,\\n        '\\\"/>\\\\n\\\\t</foreignObject>\\\\n</svg>'\\n      );\\n  }\\n\\n  /**\\n   * @notice Encodes the image as a Base64-encoded SVG.\\n   * @param data The raw image data.\\n   * @param width Width of the image data, in pixels.\\n   * @param height Height of the image, in pixels.\\n   * @param alpha Whether the image has an alpha channel.\\n   * @param svgWidth Width of the scaled SVG, in pixels.\\n   * @param svgHeight Height of the scaled SVG, in pixels.\\n   * @return The encoded Base64-encoded SVG.\\n   */\\n  function encodeBase64SVG(\\n    bytes memory data,\\n    uint width,\\n    uint height,\\n    bool alpha,\\n    uint svgWidth,\\n    uint svgHeight\\n  ) public pure returns (bytes memory) {\\n    bytes memory svg = encodeSVG(data, width, height, alpha, svgWidth, svgHeight);\\n    return Base64.encode(svg);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/lib/KeepAlive.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\n\\n/**\\n * @title KeepAlive\\n * @dev KeepAlive is a contract designed to maintain its onchain presence in\\n * case of state expiration by using payable receive() and fallback() functions,\\n * while allow the owner to still withdraw funds.\\n * fallback():\\n *   - Default function that gets executed when no other function in the contract\\n *     matches the provided function signature, or when the contract receives\\n *     Ether along with data\\n *   - Can be payable or non-payable\\n *   - Must be marked external\\n * receive():\\n *   - Introduced in Solidity 0.6.0\\n *   - Special function that is executed when a contract receives Ether without\\n *     any data\\n *   - Must be payable\\n *   - Must be marked external\\n *   - Makes it easier to differentiate between intended Ether transfers and\\n *     other function calls\\n */\\ncontract KeepAlive is Ownable {\\n  /**\\n   * @notice Fallback function.\\n   * @dev fallback():\\n   *  - Default function that gets executed when no other function in the contract\\n   *    matches the provided function signature, or when the contract receives\\n   *    Ether along with data\\n   *  - Can be payable or non-payable\\n   *  - Must be marked external\\n   */\\n  // solhint-disable-next-line no-empty-blocks\\n  fallback() external payable {}\\n\\n  /**\\n   * @notice Receive funds.\\n   * @dev receive():\\n   *   - Introduced in Solidity 0.6.0\\n   *   - Special function that is executed when a contract receives Ether without\\n   *     any data\\n   *   - Must be payable\\n   *   - Must be marked external\\n   *   - Makes it easier to differentiate between intended Ether transfers and\\n   *     other function calls\\n   */\\n  // solhint-disable-next-line no-empty-blocks\\n  receive() external payable {}\\n\\n  /**\\n   * @notice Withdraw funds from the contract.\\n   */\\n  function withdraw(uint amount) external onlyOwner {\\n    payable(msg.sender).transfer(amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/lib/PNG.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Adler32} from './Adler32.sol';\\nimport {CRC32} from './CRC32.sol';\\n\\n/**\\n * @title PNG\\n * @dev PNG is a contract for generating PNG images from raw image data in Solidity.\\n * It includes functions for encoding and decoding PNG images, as well as for\\n * calculating Adler32 and CRC32 checksums.\\n *\\n * This contract is based on the PNG specification:\\n *\\n * http://www.libpng.org/pub/png/spec/1.2/PNG-Contents.html\\n *\\n * It supports only 8 bit images and supports RGB or RGBA color formats.\\n * It uses compression method 0, filter method 0, and interlace method 0.\\n */\\ncontract PNG {\\n  using Adler32 for bytes;\\n  using CRC32 for bytes;\\n\\n  /**\\n   * The PNG signature is a fixed eight-byte sequence:\\n   * 89 50 4e 47 0d 0a 1a 0a\\n   */\\n  bytes public constant PNG_SIGNATURE = hex'89504e470d0a1a0a';\\n\\n  /**\\n   * The IEND chunk marks the end of the PNG datastream.\\n   * It contains no data.\\n   *\\n   * The IEND chunk must appear last.\\n   * It is an error to place any data after the IEND chunk.\\n   *\\n   * The IEND chunk is always equal to 12 bytes\\n   * 00 00 00 00 49 45 4e 44 ae 42 60 82\\n   */\\n  bytes public constant IEND = hex'0000000049454e44ae426082';\\n\\n  /**\\n   * @notice Encodes a PNG image from raw image data\\n   * @param data Raw image data\\n   * @param width  The width of the image, in pixels\\n   * @param height The height of the image, in pixels\\n   * @param alpha  Whether the image has an alpha channel\\n   * @return PNG image\\n   */\\n  function encodePNG(bytes memory data, uint width, uint height, bool alpha) public pure returns (bytes memory) {\\n    unchecked {\\n      // Determine the width of each pixel\\n      uint pixelWidth = (alpha) ? 4 : 3;\\n\\n      // Check that the length of the data is correct\\n      require(data.length == pixelWidth * width * height, 'Invalid image data length');\\n\\n      // Create the IHDR chunk\\n      bytes memory chunkIHDR = encodeIHDR(width, height, alpha);\\n\\n      // Create the IDAT chunk\\n      bytes memory chunkIDAT = encodeIDAT(data, width, height, alpha);\\n\\n      // Concatenate the chunks into a single bytes array.\\n      return abi.encodePacked(PNG_SIGNATURE, chunkIHDR, chunkIDAT, IEND);\\n    }\\n  }\\n\\n  /**\\n   * @dev Generates an IHDR chunk for a PNG image with the given width and height.\\n   * This function generates an IHDR chunk according to the PNG specification\\n   * (http://libpng.org/pub/png/spec/1.2/PNG-Chunks.html#C.IHDR).\\n   *\\n   * @param width The width of the image.\\n   * @param height The height of the image.\\n   * @param alpha Whether the image has alpha transparency.\\n   * @return A bytes memory array containing the IDAT chunk data.\\n   */\\n  function encodeIHDR(uint width, uint height, bool alpha) public pure returns (bytes memory) {\\n    // Create the IHDR chunk\\n    // The IHDR chunk length is 13 bytes (0x0000000d in hex)\\n    // The IHDR type 49 48 44 52 (IHDR)\\n    //\\n    // The IHDR chunk data consists of the following fields:\\n    // 4 bytes: width\\n    // 4 bytes: height\\n    // 1 byte: bit depth (8)\\n    // 1 byte: color type (2 for RGB, 6 for RGBA)\\n    // 1 byte: compression method (0)\\n    // 1 byte: filter method (0)\\n    // 1 byte: interlace method (0)\\n    //\\n    // 4 bytes: CRC32 checksum\\n    bytes memory chunkIHDR = hex'0000000d494844520000000000000000080200000000000000';\\n    // Set the width and height of the image in the chunk data\\n    chunkIHDR[8] = bytes1(uint8(width >> 24));\\n    chunkIHDR[9] = bytes1(uint8(width >> 16));\\n    chunkIHDR[10] = bytes1(uint8(width >> 8));\\n    chunkIHDR[11] = bytes1(uint8(width));\\n    chunkIHDR[12] = bytes1(uint8(height >> 24));\\n    chunkIHDR[13] = bytes1(uint8(height >> 16));\\n    chunkIHDR[14] = bytes1(uint8(height >> 8));\\n    chunkIHDR[15] = bytes1(uint8(height));\\n\\n    // Set the color type of the image in the chunk data\\n    if (alpha) {\\n      // truecolor image with alpha channel\\n      chunkIHDR[17] = hex'06';\\n    } else {\\n      // truecolor image without alpha channel\\n      chunkIHDR[17] = hex'02';\\n    }\\n\\n    // Calculate and set the CRC32 checksum of the chunk\\n    uint32 checksum = chunkIHDR.crc32(4, 21);\\n    chunkIHDR[21] = bytes1(uint8(checksum >> 24));\\n    chunkIHDR[22] = bytes1(uint8(checksum >> 16));\\n    chunkIHDR[23] = bytes1(uint8(checksum >> 8));\\n    chunkIHDR[24] = bytes1(uint8(checksum));\\n\\n    return chunkIHDR;\\n  }\\n\\n  /**\\n   * @dev Interlaces a given bytes array of image data.\\n   * @param data The bytes array of image data.\\n   * @param width The width of the image, in pixels.\\n   * @param height The height of the image, in pixels.\\n   * @param alpha Whether the image has an alpha channel.\\n   * @return The interlaced bytes array.\\n   */\\n  function interlace(bytes memory data, uint width, uint height, bool alpha) internal pure returns (bytes memory) {\\n    unchecked {\\n      uint pixelWidth = alpha ? 4 : 3;\\n\\n      // IDAT chunk\\n      // The IDAT chunk contains the actual image data.\\n      // The layout and total size of this raw data are determined by the fields of IHDR.\\n      // The filtered data is then compressed using the method specified by the IHDR chunk.\\n\\n      // Since our image has no filtering,\\n      // the filter type byte for each scanline would be 0x00 (no filtering).\\n      // Interlacing method 0 is used, so pixels are stored sequentially from left to right,\\n      // and scanlines sequentially from top to bottom (no interlacing).\\n      uint rowWidth = pixelWidth * width;\\n      uint rowWidthPadded = rowWidth + 1;\\n      // Declare a bytes array to hold the interlaced data.\\n      bytes memory interlacedData = new bytes(rowWidthPadded * height);\\n\\n      // Loop over the scanlines.\\n      for (uint row = 0; row < height; row++) {\\n        // Calculate the starting index for the current scanline.\\n        uint startIndex = rowWidthPadded * row;\\n\\n        // Set the filter type byte for the current scanline.\\n        interlacedData[startIndex] = 0x00; // Filter type 0 (no filtering)\\n\\n        // Copy the scanline data into the interlaced data array.\\n        // No filtering is used, so the scanline data starts at index 1.\\n        for (uint j = 0; j < rowWidth; j++) {\\n          interlacedData[startIndex + 1 + j] = data[row * rowWidth + j];\\n        }\\n      }\\n      return interlacedData;\\n    }\\n  }\\n\\n  /**\\n   * @dev Generates a zlib-compressed version of the given image data using the Deflate algorithm.\\n   * This function generates a zlib-compressed version of the given image data using the Deflate algorithm,\\n   * as specified in the PNG specification (http://www.libpng.org/pub/png/spec/1.2/PNG-Compression.html).\\n   * The resulting data is suitable for storage in an IDAT chunk of a PNG file.\\n   *\\n   * @param data The image data to be compressed.\\n   * @param width The width of the image, in pixels.\\n   * @param height The height of the image, in pixels.\\n   * @param alpha Whether the image has alpha transparency.\\n   * @return A bytes array containing the zlib-compressed image data.\\n   */\\n  function zlibCompressDeflate(\\n    bytes memory data,\\n    uint width,\\n    uint height,\\n    bool alpha\\n  ) internal pure returns (bytes memory) {\\n    unchecked {\\n      // Generate Deflate-compressed data\\n      bytes memory deflateCompressedData = interlace(data, width, height, alpha);\\n\\n      // Calculate Adler-32 checksum of Deflate-compressed data\\n      uint32 blockAdler32 = deflateCompressedData.adler32(0, deflateCompressedData.length);\\n\\n      // zlib block header (BFINAL = 1, BTYPE = 0)\\n      bytes memory zlibBlockHeader = hex'01';\\n\\n      // LEN is the length of the data\\n      bytes32 len = bytes32(deflateCompressedData.length);\\n\\n      // Generate zlib-compressed data\\n      bytes memory result = abi.encodePacked(\\n        // zlib header\\n        // CM = 8 (deflate), CINFO = 7 (32K window size)\\n        hex'78',\\n        // FCHECK = 0 (no check)\\n        // FDICT = 0 (no preset dictionary)\\n        // FLEVEL = 0 (fastest compression)\\n        hex'01',\\n        // block header (BFINAL = 1, BTYPE = 0)\\n        zlibBlockHeader,\\n        // LEN (2 bytes) (length of the data)\\n        len[31],\\n        len[30],\\n        // NLEN (2 bytes) (one's complement of LEN)\\n        ~len[31],\\n        ~len[30],\\n        // Deflate-compressed data\\n        deflateCompressedData,\\n        // block footer (adler32 checksum)\\n        blockAdler32\\n      );\\n\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * @dev Generates an IDAT chunk for a PNG image with the given width and height.\\n   * This function generates an IDAT chunk according to the PNG specification\\n   * (http://www.libpng.org/pub/png/spec/1.2/PNG-Filters.html).\\n   *\\n   * @param data The filtered image data.\\n   * @param width The width of the image.\\n   * @param height The height of the image.\\n   * @param alpha Whether the image has alpha transparency.\\n   * @return A bytes memory array containing the IDAT chunk data.\\n   */\\n  function encodeIDAT(bytes memory data, uint width, uint height, bool alpha) internal pure returns (bytes memory) {\\n    unchecked {\\n      // The IDAT data is compressed using the deflate algorithm.\\n      bytes memory compressed = zlibCompressDeflate(data, width, height, alpha);\\n      // The compressed data stream is then stored in the IDAT chunk.\\n      bytes memory typedata = abi.encodePacked(\\n        hex'49444154', // Chunk type: \\\"IDAT\\\" in ASCII\\n        compressed\\n      );\\n\\n      // CRC calculated from the chunk type and chunk data\\n      uint32 crc = typedata.crc32(0, typedata.length);\\n\\n      // Append the CRC32 checksum to the end of the chunk\\n      return abi.encodePacked(uint32(compressed.length), typedata, crc);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/extensions/OpenAvatarGen0ProfilePictureRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\nimport {IERC165} from '@openzeppelin/contracts/utils/introspection/IERC165.sol';\\nimport {OpenAvatarGen0AssetsCanvasIdStore} from '../core/assets/OpenAvatarGen0AssetsCanvasIdStore.sol';\\nimport {IOpenAvatarGen0CanvasRenderer} from '../core/interfaces/render/IOpenAvatarGen0CanvasRenderer.sol';\\nimport {ENSReverseClaimer} from '../core/lib/ENSReverseClaimer.sol';\\nimport {ImageEncoder} from '../core/lib/ImageEncoder.sol';\\nimport {KeepAlive} from '../core/lib/KeepAlive.sol';\\nimport {IOpenAvatarGen0AssetsRead} from '../IOpenAvatarGen0Assets.sol';\\nimport {IOpenAvatarGen0Renderer} from '../IOpenAvatarGen0Renderer.sol';\\nimport {IOpenAvatarGen0TextRecords} from '../IOpenAvatarGen0TextRecords.sol';\\nimport {IOpenAvatarGen0TokenDNA} from '../IOpenAvatarGen0Token.sol';\\nimport {OpenAvatarGenerationZero} from '../OpenAvatarGenerationZero.sol';\\nimport {DNA} from '../core/lib/DNA.sol';\\nimport {IOpenAvatarGen0AssetsCanvasLayerCompositor, LayerPatternPalette} from '../core/interfaces/render/IOpenAvatarGen0AssetsCanvasLayerCompositor.sol';\\n\\nstruct OpenAvatarProfilePictureSettings {\\n  /// @dev Whether or not to use a solid background color.\\n  bool overrideBackground;\\n  /// @dev The background color.\\n  bytes3 backgroundColor;\\n  /// @dev Whether or not to mask below the neck for a \\\"floating head\\\" effect.\\n  bool maskBelowTheNeck;\\n}\\n\\n/**\\n * @title OpenAvatarGen0ProfilePictureRenderer\\n * @author Cory Gabrielsen (cory.eth)\\n *\\n * @notice A contract for rendering OpenAvatar Gen0 profile pictures.\\n * @dev This contract renders an Avatar against a background image.\\n *\\n * ----------------------------------------------------------------------------\\n * 'pfp' Renderer\\n * ----------------------------------------------------------------------------\\n * A Profile Picture Renderer is provided with the key \\\"pfp\\\".\\n *\\n * The 'pfp' Renderer renders the Avatar with a configurable background color\\n * determined by the 'gen0.renderer.pfp.background-color' text record, which\\n * should be a valid RGB hex color code (e.g. \\\"#ff0000\\\" for red).\\n *\\n * Further, the 'pfp' Renderer provides the option of masking the Avatar\\n * below the neck to create a \\\"floating head\\\" effect. This can be configured\\n * by setting the `gen0.renderer.pfp.mask` text record to \\\"below-the-neck\\\".\\n *\\n * The Profile Picture Renderer is a demonstration of combining the OpenAvatar\\n * building blocks together to create dynamic, owner-customizable behavior. It\\n * utilizes onchain assets, onchain rendering, and onchain text records to\\n * render a customizable Avatar pfp.\\n *\\n * This pattern is permissionless.\\n *\\n *\\n * ----------------------------------------------------------------------------\\n * Background Image\\n * ----------------------------------------------------------------------------\\n * The background image is by default a white/light gray checkerboard of 8x8\\n * squares arranged in a 4x4 grid.\\n *\\n * The background image can be changed by the token owner by setting the\\n * 'gen0.renderer.pfp.background-image' text record to a valid RGB hex color\\n * code (e.g. \\\"#ff0000\\\" for red).\\n */\\ncontract OpenAvatarGen0ProfilePictureRenderer is\\n  IOpenAvatarGen0Renderer,\\n  OpenAvatarGenerationZero,\\n  OpenAvatarGen0AssetsCanvasIdStore,\\n  ImageEncoder,\\n  ENSReverseClaimer,\\n  KeepAlive\\n{\\n  using DNA for bytes32;\\n\\n  /// @dev Emitted when the fuse is burned to make the background image immutable.\\n  event FuseBurnedChangeBackgroundImage();\\n\\n  /// @dev Error when a component is already initialized.\\n  error AlreadyInitialized();\\n  /// @dev Error when the fuse is already burned.\\n  error FuseBurned();\\n  /// @dev Error when the required ERC-165 interfaces are not supported.\\n  error InterfaceUnsupported(address contractAddress, bytes4 interfaceId);\\n  /// @dev Error when the provided canvas has an invalid number of bytes per pixel.\\n  error InvalidCanvasBytesPerPixel();\\n  /// @dev Error when calling write-protection function on a non-owned DNA.\\n  error NotOwner(bytes32 dna);\\n\\n  /// @dev The ERC-165 interface id for the OpenAvatarGen0Renderer (for clients).\\n  bytes4 private constant INTERFACE_ID_OPENAVATAR_GEN0_RENDERER = 0xb93e4881;\\n  /// @dev The ERC-165 interface id for the OpenAvatarGen0AssetsRead (dependency).\\n  bytes4 private constant INTERFACE_ID_OPENAVATAR_GEN0_ASSETS_READ = 0x67bf31d1;\\n  /// @dev The ERC-165 interface id for the OpenAvatarGen0AssetsCanvasLayerCompositor (dependency).\\n  bytes4 private constant INTERFACE_ID_OPENAVATAR_GEN0_ASSETS_CANVAS_LAYER_COMPOSITOR = 0x2638c94b;\\n  /// @dev The ERC-165 interface id for the OpenAvatarGen0TokenDNA (dependency).\\n  bytes4 private constant INTERFACE_ID_OPENAVATAR_GEN0_TOKEN_DNA = 0x2717336f;\\n  /// @dev The ERC-165 interface id for the OpenAvatarGen0TextRecords ERC-634 text() (dependency).\\n  bytes4 private constant INTERFACE_ID_OPENAVATAR_GEN0_TEXT = 0x59d1d43c;\\n\\n  /// @dev The canvas id.\\n  uint8 public constant CANVAS_ID = 0;\\n  /// @dev The pixel width of the canvas.\\n  uint8 public constant CANVAS_WIDTH = 32;\\n  /// @dev The pixel height of the canvas.\\n  uint8 public constant CANVAS_HEIGHT = 32;\\n  /// @dev The number of bytes in the canvas - 32 * 32 * 4.\\n  uint16 public constant CANVAS_NUM_BYTES = 4096;\\n\\n  /// @dev The layer index for the body layer.\\n  uint8 public constant LAYER_INDEX_BODY = 10;\\n  /// @dev The layer index for the tattoos layer.\\n  uint8 public constant LAYER_INDEX_TATTOOS = 20;\\n  /// @dev The layer index for the makeup layer.\\n  uint8 public constant LAYER_INDEX_MAKEUP = 30;\\n  /// @dev The layer index for the left eye layer.\\n  uint8 public constant LAYER_INDEX_LEFT_EYE = 40;\\n  /// @dev The layer index for the right eye layer.\\n  uint8 public constant LAYER_INDEX_RIGHT_EYE = 50;\\n  /// @dev The layer index for the bottomwear layer.\\n  uint8 public constant LAYER_INDEX_BOTTOMWEAR = 60;\\n  /// @dev The layer index for the footwear layer.\\n  uint8 public constant LAYER_INDEX_FOOTWEAR = 70;\\n  /// @dev The layer index for the topwear layer.\\n  uint8 public constant LAYER_INDEX_TOPWEAR = 80;\\n  /// @dev The layer index for the handwear layer.\\n  uint8 public constant LAYER_INDEX_HANDWEAR = 90;\\n  /// @dev The layer index for the outerwear layer.\\n  uint8 public constant LAYER_INDEX_OUTERWEAR = 100;\\n  /// @dev The layer index for the jewelry layer.\\n  uint8 public constant LAYER_INDEX_JEWELRY = 110;\\n  /// @dev The layer index for the facial hair layer.\\n  uint8 public constant LAYER_INDEX_FACIAL_HAIR = 120;\\n  /// @dev The layer index for the facewear layer.\\n  uint8 public constant LAYER_INDEX_FACEWEAR = 130;\\n  /// @dev The layer index for the eyewear layer.\\n  uint8 public constant LAYER_INDEX_EYEWEAR = 140;\\n  /// @dev The layer index for the hair layer.\\n  uint8 public constant LAYER_INDEX_HAIR = 150;\\n\\n  /// @dev Scale the SVG by this amount.\\n  uint public constant SVG_SCALE = 10;\\n\\n  /// @dev The \\\"only head\\\" mask which masks below the neck.\\n  bytes public constant BELOW_THE_NECK_MASK =\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0000000000000000000000000000000000000000000000000000000000000000'\\n    hex'0101010101010101010101010000000000000000010101010101010101010101'\\n    hex'0101010101010101010101010101010101010101010101010101010101010101'\\n    hex'0101010101010101010101010101010101010101010101010101010101010101'\\n    hex'0101010101010101010101010101010101010101010101010101010101010101'\\n    hex'0101010101010101010101010101010101010101010101010101010101010101'\\n    hex'0101010101010101010101010101010101010101010101010101010101010101'\\n    hex'0101010101010101010101010101010101010101010101010101010101010101'\\n    hex'0101010101010101010101010101010101010101010101010101010101010101'\\n    hex'0101010101010101010101010101010101010101010101010101010101010101'\\n    hex'0101010101010101010101010101010101010101010101010101010101010101';\\n\\n  /// @dev The background image, an 4x4 grid of 8x8 checkerboard squares.\\n  ///      Every four lines is one row of the image.\\n  ///      The pattern switches every 8 rows, or 32 lines\\n  ///\\n  ///      This value is constant even though it isn't declared constant,\\n  ///      because declaring it as a constant makes renderURI fail\\n  ///      with out-of-gas?\\n  bytes public backgroundImage =\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff'\\n    hex'EEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEffEEEEEEff'\\n    hex'DDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDffDDDDDDff';\\n\\n  /// @dev The text key for the background color of the avatar pfp.\\n  string public constant TEXT_KEY_PFP_BACKGROUND_COLOR = 'gen0.renderer.pfp.background-color';\\n  /// @dev The text key for the mask of the avatar pfp.\\n  string public constant TEXT_KEY_PFP_MASK = 'gen0.renderer.pfp.mask';\\n  /// @dev The text value for a pfp rendering that only displays the head.\\n  string public constant TEXT_KEY_PFP_MASK_VALUE_BELOW_THE_NECK = 'below-the-neck';\\n  /// @dev The keccak26 hash 'below-the-neck', for use in the contract.\\n  bytes32 private constant TEXT_KEY_PFP_MASK_VALUE_BELOW_THE_NECK_HASH =\\n    keccak256(abi.encodePacked(TEXT_KEY_PFP_MASK_VALUE_BELOW_THE_NECK));\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // State variables\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev fuse can be burned to make the background image immutable\\n  bool public fuseBurnedChangeBackgroundImage = false;\\n\\n  /// @dev The OpenAvatarGen0AssetsRead dependency.\\n  IOpenAvatarGen0AssetsRead public openAvatarGen0AssetsRead;\\n  /// @dev The OpenAvatarGen0AssetsCanvasLayerCompositor dependency.\\n  IOpenAvatarGen0AssetsCanvasLayerCompositor public openAvatarGen0AssetsCanvasLayerCompositor;\\n  /// @dev The OpenAvatarDNA dependency.\\n  IOpenAvatarGen0TokenDNA public openAvatarGen0Token;\\n  /// @dev The OpenAvatarGen0TextRecords dependency.\\n  IOpenAvatarGen0TextRecords public openAvatarGen0TextRecords;\\n\\n  // solhint-disable-next-line no-empty-blocks\\n  constructor(address ownerProxy) OpenAvatarGen0AssetsCanvasIdStore(CANVAS_ID) {\\n    // will be deployed by ImmutableCreate2Factory and then transferred to the configured owner\\n    // using a proxy allows for using same bytecode in test and prod\\n\\n    address wantOwner = Ownable(ownerProxy).owner();\\n    if (owner() != wantOwner) {\\n      transferOwnership(wantOwner);\\n    }\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // ERC-165: Standard Interface Detection\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Checks if the contract supports an interface.\\n   * @param interfaceId The interface identifier, as specified in ERC-165.\\n   * @return True if the contract supports interfaceID, false otherwise.\\n   */\\n  function supportsInterface(bytes4 interfaceId) public pure override(OpenAvatarGenerationZero) returns (bool) {\\n    return\\n      interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n      // IOpenAvatar\\n      interfaceId == 0xfdf02ac8 || // ERC165 interface ID for IOpenAvatarGeneration.\\n      interfaceId == 0x7b65147c || // ERC165 interface ID for IOpenAvatarSentinel.\\n      interfaceId == 0x86953eb4 || // ERC165 interface ID for IOpenAvatar.\\n      // renderer\\n      interfaceId == INTERFACE_ID_OPENAVATAR_GEN0_RENDERER;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Initialize Dependencies\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Initialize the contract.\\n   * @param openAvatarGen0Assets_ The address of the asset store read interface contract.\\n   * @param openAvatarAssesCanvasLayerCompositor_ The address of the canvas layer compositor contract.\\n   * @param openAvatarGen0Token_ The address of the OpenAvatar token contract.\\n   * @param openAvatarGen0TextRecords_ The address of the text records contract.\\n   */\\n  function initialize(\\n    address openAvatarGen0Assets_,\\n    address openAvatarAssesCanvasLayerCompositor_,\\n    address openAvatarGen0Token_,\\n    address openAvatarGen0TextRecords_\\n  ) external onlyOwner {\\n    // helpers enforce only-once invariant and check ERC-165 supportsInterface()\\n    setOpenAvatarGen0Assets(openAvatarGen0Assets_);\\n    setOpenAvatarGen0AssetsCanvasLayerCompositor(openAvatarAssesCanvasLayerCompositor_);\\n    setOpenAvatarGen0Token(openAvatarGen0Token_);\\n    setOpenAvatarGen0TextRecords(openAvatarGen0TextRecords_);\\n  }\\n\\n  /**\\n   * @notice Check if the contract has been initialized.\\n   * @return True if the contract has been initialized, false otherwise.\\n   */\\n  function isInitialized() external view returns (bool) {\\n    return address(openAvatarGen0AssetsRead) != address(0);\\n  }\\n\\n  /**\\n   * @notice Get the asset store.\\n   * @return The address of the asset store read interface contract.\\n   */\\n  function getOpenAvatarGen0Assets() external view returns (address) {\\n    return address(openAvatarGen0AssetsRead);\\n  }\\n\\n  /**\\n   * @notice Set the asset store.\\n   * @param openAvatarGen0Assets_ The address of the asset store read interface contract.\\n   */\\n  function setOpenAvatarGen0Assets(address openAvatarGen0Assets_) internal {\\n    // only set once\\n    if (address(openAvatarGen0AssetsRead) != address(0)) revert AlreadyInitialized();\\n\\n    // check ERC-165 support\\n    // only read interface is required\\n    if (!IERC165(openAvatarGen0Assets_).supportsInterface(INTERFACE_ID_OPENAVATAR_GEN0_ASSETS_READ)) {\\n      revert InterfaceUnsupported(openAvatarGen0Assets_, INTERFACE_ID_OPENAVATAR_GEN0_ASSETS_READ);\\n    }\\n\\n    // set\\n    openAvatarGen0AssetsRead = IOpenAvatarGen0AssetsRead(openAvatarGen0Assets_);\\n\\n    // sanity check\\n    if (openAvatarGen0AssetsRead.getBytesPerPixel() != 4) revert InvalidCanvasBytesPerPixel();\\n  }\\n\\n  /**\\n   * @notice Get the IOpenAvatarGen0AssetsCanvasLayerCompositor.\\n   * @return The address of the IOpenAvatarGen0AssetsCanvasLayerCompositor interface contract.\\n   */\\n  function getOpenAvatarGen0AssetsCanvasLayerCompositor() external view returns (address) {\\n    return address(openAvatarGen0AssetsCanvasLayerCompositor);\\n  }\\n\\n  /**\\n   * @notice Set the IOpenAvatarGen0AssetsCanvasLayerCompositor.\\n   * @param openAvatarAssesCanvasLayerCompositor_ The address of the\\n   * IOpenAvatarGen0AssetsCanvasLayerCompositor interface contract.\\n   */\\n  function setOpenAvatarGen0AssetsCanvasLayerCompositor(address openAvatarAssesCanvasLayerCompositor_) internal {\\n    // only set once\\n    if (address(openAvatarGen0AssetsCanvasLayerCompositor) != address(0)) revert AlreadyInitialized();\\n\\n    // check ERC-165 support\\n    //\\n    // we don't need use renderURI from OpenAvatarGen0Renderer, which is too high level here\\n    //\\n    // instead we use the compositor interface to manually layer assets on top of each other\\n    // allowing us to modify the image layers before encoding as a PNG/SVG\\n    if (\\n      !IERC165(openAvatarAssesCanvasLayerCompositor_).supportsInterface(\\n        INTERFACE_ID_OPENAVATAR_GEN0_ASSETS_CANVAS_LAYER_COMPOSITOR\\n      )\\n    ) {\\n      revert InterfaceUnsupported(\\n        openAvatarAssesCanvasLayerCompositor_,\\n        INTERFACE_ID_OPENAVATAR_GEN0_ASSETS_CANVAS_LAYER_COMPOSITOR\\n      );\\n    }\\n\\n    // set\\n    openAvatarGen0AssetsCanvasLayerCompositor = IOpenAvatarGen0AssetsCanvasLayerCompositor(\\n      openAvatarAssesCanvasLayerCompositor_\\n    );\\n  }\\n\\n  /**\\n   * @notice Get the OpenAvatar token.\\n   * @return The address of the OpenAvatar token read interface contract.\\n   */\\n  function getOpenAvatarGen0Token() external view returns (address) {\\n    return address(openAvatarGen0Token);\\n  }\\n\\n  /**\\n   * @notice Set the OpenAvatar token address.\\n   * @param openAvatarGen0Token_ The address of the OpenAvatar token contract.\\n   */\\n  function setOpenAvatarGen0Token(address openAvatarGen0Token_) internal {\\n    // only set once\\n    if (address(openAvatarGen0Token) != address(0)) revert AlreadyInitialized();\\n\\n    // check ERC-165 support\\n    // only DNA interface is required\\n    if (!IERC165(openAvatarGen0Token_).supportsInterface(INTERFACE_ID_OPENAVATAR_GEN0_TOKEN_DNA)) {\\n      revert InterfaceUnsupported(openAvatarGen0Token_, INTERFACE_ID_OPENAVATAR_GEN0_TOKEN_DNA);\\n    }\\n\\n    // set\\n    openAvatarGen0Token = IOpenAvatarGen0TokenDNA(openAvatarGen0Token_);\\n  }\\n\\n  /**\\n   * @notice Get the OpenAvatarGen0TextRecords.\\n   * @return The address of the OpenAvatarGen0TextRecords.\\n   */\\n  function getOpenAvatarGen0TextRecords() external view returns (address) {\\n    return address(openAvatarGen0TextRecords);\\n  }\\n\\n  /**\\n   * @notice Set the OpenAvatarGen0TextRecords address.\\n   * @param openAvatarGen0TextRecords_ The address of the OpenAvatarGen0TextRecords contract.\\n   */\\n  function setOpenAvatarGen0TextRecords(address openAvatarGen0TextRecords_) internal {\\n    // only set once\\n    if (address(openAvatarGen0TextRecords) != address(0)) revert AlreadyInitialized();\\n\\n    // check ERC-165 support\\n    // only text() interface is required\\n    if (!IERC165(openAvatarGen0TextRecords_).supportsInterface(INTERFACE_ID_OPENAVATAR_GEN0_TEXT)) {\\n      revert InterfaceUnsupported(openAvatarGen0TextRecords_, INTERFACE_ID_OPENAVATAR_GEN0_TEXT);\\n    }\\n\\n    // set\\n    openAvatarGen0TextRecords = IOpenAvatarGen0TextRecords(openAvatarGen0TextRecords_);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Modifiers\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Modifier to check that the caller is the owner of the token.\\n   */\\n  modifier onlyTokenOwner(bytes32 dna) {\\n    if (msg.sender != openAvatarGen0Token.ownerOfDNA(dna)) {\\n      revert NotOwner(dna);\\n    }\\n    _;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Fuses\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Get the fuse burned status for changing the background image.\\n   */\\n  function getFuseBurnedChangeBackgroundImage() external view returns (bool) {\\n    return fuseBurnedChangeBackgroundImage;\\n  }\\n\\n  /**\\n   * @dev Burn the fuse to prevent changing the background image.\\n   */\\n  function burnFuseChangeBackgroundImage() external onlyOwner {\\n    if (!fuseBurnedChangeBackgroundImage) {\\n      fuseBurnedChangeBackgroundImage = true;\\n      emit FuseBurnedChangeBackgroundImage();\\n    }\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Background Image\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Get the default background image.\\n   */\\n  function getBackgroundImage() external view returns (bytes memory) {\\n    return backgroundImage;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Profile Picture Settings\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Return the background settings for the given DNA.\\n   * @param dna The DNA to set the background color for.\\n   * @return The background settings.\\n   */\\n  function getProfilePictureSettings(bytes32 dna) external view returns (OpenAvatarProfilePictureSettings memory) {\\n    string memory pfpBackground = openAvatarGen0TextRecords.text(dna, TEXT_KEY_PFP_BACKGROUND_COLOR);\\n\\n    // pfpBackground is a RGB hexstring like #AABBCC\\n    // we need to decompose into a bytes3 0xAABBCC\\n    bool overrideBackground = bytes(pfpBackground).length == 7;\\n    bytes3 backgroundColor = _hexStrToBytes3(pfpBackground);\\n\\n    // pfpMask is a string like 'below-the-neck' or ''\\n    string memory pfpMask = openAvatarGen0TextRecords.text(dna, TEXT_KEY_PFP_MASK);\\n    // security (gas) - don't compute hash if incorrect length\\n    bool validLength = bytes(pfpMask).length == 14; // 'below-the-neck' is 14 bytes\\n    bool maskBelowTheNeck = false;\\n    if (validLength) {\\n      maskBelowTheNeck = keccak256(abi.encodePacked(pfpMask)) == TEXT_KEY_PFP_MASK_VALUE_BELOW_THE_NECK_HASH;\\n    }\\n\\n    return OpenAvatarProfilePictureSettings(overrideBackground, backgroundColor, maskBelowTheNeck);\\n  }\\n\\n  /**\\n   * @notice Convert an RGB hextring #AABBCC to a bytes3 0xAABBCC.\\n   * @param _str The string to convert.\\n   * @return The bytes3 value\\n   * @dev if the string is not length-7 or leading # is missing, return 0x000000\\n   * @dev if a pair of characters is not a valid hex string, return 0x00 for that byte\\n   */\\n  function _hexStrToBytes3(string memory _str) internal pure returns (bytes3) {\\n    bytes memory b = bytes(_str);\\n    if (b.length != 7) return 0x000000;\\n\\n    // the first character should be '#'\\n    if (b[0] != 0x23) return 0x000000;\\n\\n    bytes3 rgb;\\n    for (uint i = 0; i < 3; i++) {\\n      rgb |= bytes3(_safeParseByte(_str, 2 * i + 1)) >> (8 * i);\\n    }\\n    return rgb;\\n  }\\n\\n  /**\\n   * @notice Safely parse a byte.\\n   * @param _str The string to parse.\\n   * @param _start The start index.\\n   * @return The parsed byte, or 0x00 if the byte is invalid.\\n   */\\n  function _safeParseByte(string memory _str, uint _start) private pure returns (bytes1) {\\n    bytes1 b1 = _safeParseHexDigit(bytes(_str)[_start]);\\n    bytes1 b2 = _safeParseHexDigit(bytes(_str)[_start + 1]);\\n    return (b1 << 4) | b2;\\n  }\\n\\n  /**\\n   * @dev Safely parse a hex digit.\\n   * @param _hex The hex digit to parse.\\n   * @return The parsed digit, or 0x00 if the digit is invalid.\\n   */\\n  function _safeParseHexDigit(bytes1 _hex) private pure returns (bytes1) {\\n    if (_hex >= '0' && _hex <= '9') {\\n      return bytes1(uint8(_hex) - 48);\\n    }\\n    if (_hex >= 'a' && _hex <= 'f') {\\n      return bytes1(uint8(_hex) - 97 + 10);\\n    }\\n    if (_hex >= 'A' && _hex <= 'F') {\\n      return bytes1(uint8(_hex) - 65 + 10);\\n    }\\n    return 0;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Rendering - external\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Render the given DNA as a base64-encoded SVG URI.\\n   * @param dna The DNA to render.\\n   * @return The SVG URI.\\n   */\\n  function renderURI(bytes32 dna) external view override returns (string memory) {\\n    return string(abi.encodePacked('data:image/svg+xml;base64,', renderBase64SVG(dna)));\\n  }\\n\\n  /**\\n   * @notice Render the given DNA as a base64-encoded SVG URI with the provided settings.\\n   * @param dna The DNA to render.\\n   * @param pfpSettings The background settings to use.\\n   * @return The SVG URI.\\n   */\\n  function renderURIWithSettings(\\n    bytes32 dna,\\n    OpenAvatarProfilePictureSettings memory pfpSettings\\n  ) external view returns (string memory) {\\n    return string(abi.encodePacked('data:image/svg+xml;base64,', renderBase64SVGWithSettings(dna, pfpSettings)));\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Rendering - helpers\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function createBackgroundImage(\\n    OpenAvatarProfilePictureSettings memory pfpSettings\\n  ) internal view returns (bytes memory, uint8, uint8) {\\n    bytes memory image = new bytes(openAvatarGen0AssetsRead.getCanvasNumBytes(canvasId));\\n\\n    uint8 width = openAvatarGen0AssetsRead.getCanvasWidth(canvasId);\\n    uint8 height = openAvatarGen0AssetsRead.getCanvasHeight(canvasId);\\n\\n    if (pfpSettings.overrideBackground) {\\n      uint numPixels = uint(width) * uint(height);\\n      // override default background with solid color\\n      for (uint i = 0; i < numPixels; ) {\\n        uint offset = i * 4;\\n        image[offset] = pfpSettings.backgroundColor[0];\\n        image[offset + 1] = pfpSettings.backgroundColor[1];\\n        image[offset + 2] = pfpSettings.backgroundColor[2];\\n        image[offset + 3] = 0xff;\\n        unchecked {\\n          ++i;\\n        }\\n      }\\n    } else {\\n      // copy default background\\n      for (uint i = 0; i < image.length; ) {\\n        image[i] = backgroundImage[i];\\n        unchecked {\\n          ++i;\\n        }\\n      }\\n    }\\n    return (image, width, height);\\n  }\\n\\n  /// @dev kind of a hack but doesn't matter. seems like a one-off so just put it here\\n  function _drawNeckLine(bytes memory image) internal pure returns (bytes memory) {\\n    // the bottom of the head is an 8-pixel line representing the chinline/neck\\n    // by default, this is will be the \\\"dark\\\" color for that body color palette,\\n    // which is not black but rather a dark skin tone color.\\n    //\\n    // but if we are drawing just the head without the body, we actually want to have\\n    // the head outlined in black because that's the boundary shape.\\n    //\\n    // so we draw 8 black pixels over top of the \\\"dark\\\" pixels\\n    //\\n    // another design considered was uploading the \\\"head\\\" pattern separately to\\n    // the assets contract, for the same canvas, but on a \\\"off\\\" layer (11?) (body=10)\\n    // which fits with the intended design of how to use the assets contract\\n    //\\n    // but\\n    //\\n    // this was a one-off for now, so we are just doing the 8 pixel difference here\\n\\n    // 8 pixels across\\n\\n    // 1st pixel\\n    image[2864] = 0x00;\\n    image[2865] = 0x00;\\n    image[2866] = 0x00;\\n    image[2867] = 0xff;\\n    // 2nd pixel\\n    image[2868] = 0x00;\\n    image[2869] = 0x00;\\n    image[2870] = 0x00;\\n    image[2871] = 0xff;\\n    // 3rd pixel\\n    image[2872] = 0x00;\\n    image[2873] = 0x00;\\n    image[2874] = 0x00;\\n    image[2875] = 0xff;\\n    // 4th pixel\\n    image[2876] = 0x00;\\n    image[2877] = 0x00;\\n    image[2878] = 0x00;\\n    image[2879] = 0xff;\\n    // 5th pixel\\n    image[2880] = 0x00;\\n    image[2881] = 0x00;\\n    image[2882] = 0x00;\\n    image[2883] = 0xff;\\n    // 6th pixel\\n    image[2884] = 0x00;\\n    image[2885] = 0x00;\\n    image[2886] = 0x00;\\n    image[2887] = 0xff;\\n    // 7th pixel\\n    image[2888] = 0x00;\\n    image[2889] = 0x00;\\n    image[2890] = 0x00;\\n    // 8th pixel\\n    image[2891] = 0xff;\\n    image[2892] = 0x00;\\n    image[2893] = 0x00;\\n    image[2894] = 0x00;\\n    image[2895] = 0xff;\\n    return image;\\n  }\\n\\n  /**\\n   * @dev Draw the layers of the avatar.\\n   * @param image The image to draw on.\\n   * @param mask The mask to apply before drawing.\\n   * @param canvasId The canvas ID to draw on.\\n   * @param dna The DNA to use.\\n   * @param pfpSettings The background settings to use.\\n   * @return The image with the layers drawn.\\n   */\\n  function _drawLayers(\\n    bytes memory image,\\n    bytes memory mask,\\n    uint8 canvasId,\\n    bytes32 dna,\\n    OpenAvatarProfilePictureSettings memory pfpSettings\\n  ) internal view returns (bytes memory) {\\n    // body\\n    uint8 bodyPattern = dna.bodyPattern();\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_BODY,\\n      bodyPattern,\\n      dna.bodyPalette()\\n    );\\n\\n    // the neck is normally drawn on top of the body with a skin tone \\\"neck\\\"\\n    // but for this we want black border around the head not the body\\n    //\\n    // transparent bodies don't have a neck line\\n    if (pfpSettings.maskBelowTheNeck && bodyPattern != 0) {\\n      image = _drawNeckLine(image);\\n    }\\n\\n    // tattoos\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_TATTOOS,\\n      dna.tattoosPattern(),\\n      dna.tattoosPalette()\\n    );\\n    // makeup\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_MAKEUP,\\n      dna.makeupPattern(),\\n      dna.makeupPalette()\\n    );\\n    // eyes\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_LEFT_EYE,\\n      dna.leftEyePattern(),\\n      dna.leftEyePalette()\\n    );\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_RIGHT_EYE,\\n      dna.rightEyePattern(),\\n      dna.rightEyePalette()\\n    );\\n    // clothes\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_BOTTOMWEAR,\\n      dna.bottomwearPattern(),\\n      dna.bottomwearPalette()\\n    );\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_FOOTWEAR,\\n      dna.footwearPattern(),\\n      dna.footwearPalette()\\n    );\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_TOPWEAR,\\n      dna.topwearPattern(),\\n      dna.topwearPalette()\\n    );\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_HANDWEAR,\\n      dna.handwearPattern(),\\n      dna.handwearPalette()\\n    );\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_OUTERWEAR,\\n      dna.outerwearPattern(),\\n      dna.outerwearPalette()\\n    );\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_JEWELRY,\\n      dna.jewelryPattern(),\\n      dna.jewelryPalette()\\n    );\\n    // facial hair - no mask\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawLayer(\\n      image,\\n      canvasId,\\n      LAYER_INDEX_FACIAL_HAIR,\\n      dna.facialHairPattern(),\\n      dna.facialHairPalette()\\n    );\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_FACEWEAR,\\n      dna.facewearPattern(),\\n      dna.facewearPalette()\\n    );\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawMaskedLayer(\\n      image,\\n      mask,\\n      canvasId,\\n      LAYER_INDEX_EYEWEAR,\\n      dna.eyewearPattern(),\\n      dna.eyewearPalette()\\n    );\\n    // hair - no mask\\n    image = openAvatarGen0AssetsCanvasLayerCompositor.drawLayer(\\n      image,\\n      canvasId,\\n      LAYER_INDEX_HAIR,\\n      dna.hairPattern(),\\n      dna.hairPalette()\\n    );\\n    return image;\\n  }\\n\\n  /**\\n   * @notice Render the given DNA as a base64-encoded SVG.\\n   * @param dna The DNA to render.\\n   * @return The base64-encoded SVG.\\n   */\\n  function renderBase64SVG(bytes32 dna) public view returns (bytes memory) {\\n    return renderBase64SVGWithSettings(dna, this.getProfilePictureSettings(dna));\\n  }\\n\\n  /**\\n   * @notice Render the given DNA as a base64-encoded SVG.\\n   * @param dna The DNA to render.\\n   * @param pfpSettings The settings to use for the profile picture.\\n   * @return The base64-encoded SVG.\\n   */\\n  function renderBase64SVGWithSettings(\\n    bytes32 dna,\\n    OpenAvatarProfilePictureSettings memory pfpSettings\\n  ) public view returns (bytes memory) {\\n    (bytes memory image, uint8 width, uint8 height) = createBackgroundImage(pfpSettings);\\n\\n    // copy mask into memory\\n    bytes memory mask = new bytes(openAvatarGen0AssetsRead.getCanvasNumPixels(canvasId));\\n    if (pfpSettings.maskBelowTheNeck) {\\n      uint length = mask.length;\\n      for (uint i = 0; i < length; ) {\\n        mask[i] = BELOW_THE_NECK_MASK[i];\\n        unchecked {\\n          ++i;\\n        }\\n      }\\n    }\\n    image = _drawLayers(image, mask, canvasId, dna, pfpSettings);\\n    return\\n      encodeBase64SVG(\\n        image,\\n        width,\\n        height,\\n        openAvatarGen0AssetsRead.hasAlphaChannel(),\\n        SVG_SCALE * width,\\n        SVG_SCALE * height\\n      );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/IOpenAvatar.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title IOpenAvatarSentinel\\n * @dev An interface for the OpenAvatar sentinel.\\n */\\ninterface IOpenAvatarSentinel {\\n  /// @dev Returns true\\n  function openAvatar() external view returns (bool);\\n}\\n\\n/**\\n * @title IOpenAvatarGeneration\\n * @dev An interface for the OpenAvatar generation.\\n */\\ninterface IOpenAvatarGeneration {\\n  /// @dev Returns the generation of the OpenAvatar\\n  function openAvatarGeneration() external view returns (uint);\\n}\\n\\n/**\\n * @title IOpenAvatar\\n * @dev The OpenAvatar interface.\\n */\\ninterface IOpenAvatar is IOpenAvatarSentinel, IOpenAvatarGeneration {\\n\\n}\\n\"\r\n    },\r\n    \"contracts/IOpenAvatarGen0Assets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {IOpenAvatarGen0AssetsCanvasStore, IOpenAvatarGen0AssetsCanvasStoreRead, IOpenAvatarGen0AssetsCanvasStoreWrite} from './core/interfaces/assets/IOpenAvatarGen0AssetsCanvasStore.sol';\\nimport {IOpenAvatarGen0AssetsPaletteStoreRead, IOpenAvatarGen0AssetsPaletteStoreWrite, IOpenAvatarGen0AssetsPaletteStore} from './core/interfaces/assets/IOpenAvatarGen0AssetsPaletteStore.sol';\\nimport {IOpenAvatarGen0AssetsPatternStoreRead, IOpenAvatarGen0AssetsPatternStoreWrite, IOpenAvatarGen0AssetsPatternStore} from './core/interfaces/assets/IOpenAvatarGen0AssetsPatternStore.sol';\\n\\n/**\\n * @title IOpenAvatarGen0AssetsRead\\n * @dev This interface reads asset data\\n */\\ninterface IOpenAvatarGen0AssetsRead is\\n  IOpenAvatarGen0AssetsCanvasStoreRead,\\n  IOpenAvatarGen0AssetsPatternStoreRead,\\n  IOpenAvatarGen0AssetsPaletteStoreRead\\n{\\n\\n}\\n\\n/**\\n * @title IOpenAvatarGen0AssetsWrite\\n * @dev This interface writes asset data\\n */\\ninterface IOpenAvatarGen0AssetsWrite is\\n  IOpenAvatarGen0AssetsCanvasStoreWrite,\\n  IOpenAvatarGen0AssetsPatternStoreWrite,\\n  IOpenAvatarGen0AssetsPaletteStoreWrite\\n{\\n\\n}\\n\\n/**\\n * @title IOpenAvatarGen0Assets\\n * @dev This interface reads and writes asset data\\n */\\ninterface IOpenAvatarGen0Assets is IOpenAvatarGen0AssetsRead, IOpenAvatarGen0AssetsWrite {\\n\\n}\\n\"\r\n    },\r\n    \"contracts/IOpenAvatarGen0Renderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title IOpenAvatarGen0Renderer\\n * @dev The primary interface for rendering an Avatar.\\n */\\ninterface IOpenAvatarGen0Renderer {\\n  function renderURI(bytes32 dna) external view returns (string memory);\\n}\\n\\n/**\\n * @title IOpenAvatarGen0RendererDecorator\\n * @dev The IOpenAvatarGen0RendererDecorator interface.\\n */\\ninterface IOpenAvatarGen0RendererDecorator is IOpenAvatarGen0Renderer {\\n  function renderHex(bytes32 dna) external view returns (bytes memory);\\n\\n  function renderPNG(bytes32 dna) external view returns (bytes memory);\\n\\n  function renderBase64PNG(bytes32 dna) external view returns (bytes memory);\\n\\n  function renderSVG(bytes32 dna) external view returns (bytes memory);\\n\\n  function renderBase64SVG(bytes32 dna) external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/IOpenAvatarGen0TextRecords.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\nimport {IERC634} from './core/dependencies/IERC634.sol';\\n\\n/**\\n * @title Text Record\\n * @notice A key-value string pair.\\n */\\nstruct TextRecord {\\n  string key;\\n  string value;\\n}\\n\\n/**\\n * @title DNA Text Record\\n * @notice A DNA and a key-value string pair.\\n */\\nstruct DNATextRecord {\\n  bytes32 dna;\\n  string key;\\n  string value;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0TextRecords\\n * @dev The TextStore contract stores text data by 32-byte OpenAvatar DNA.\\n *\\n * This contract is based on ERC-634 originally developed for ENS.\\n */\\ninterface IOpenAvatarGen0TextRecords is IERC634 {\\n  function setText(bytes32 dna, string calldata key, string calldata value) external;\\n\\n  function setText2(\\n    bytes32 dna,\\n    string calldata key,\\n    string calldata value,\\n    string calldata key2,\\n    string calldata value2\\n  ) external;\\n\\n  function setText3(\\n    bytes32 dna,\\n    string calldata key,\\n    string calldata value,\\n    string calldata key2,\\n    string calldata value2,\\n    string calldata key3,\\n    string calldata value3\\n  ) external;\\n\\n  function setText4(\\n    bytes32 dna,\\n    string calldata key,\\n    string calldata value,\\n    string calldata key2,\\n    string calldata value2,\\n    string calldata key3,\\n    string calldata value3,\\n    string calldata key4,\\n    string calldata value4\\n  ) external;\\n\\n  function setTexts(bytes32 dna, TextRecord[] calldata records) external;\\n\\n  function setTextBatch(DNATextRecord[] calldata records) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IOpenAvatarGen0Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {IOpenAvatar} from './IOpenAvatar.sol';\\n\\n/**\\n * @title OpenAvatarGen0TokenMetadata\\n * @dev The OpenAvatar metadata.\\n */\\nstruct OpenAvatarGen0TokenMetadata {\\n  uint generation;\\n  uint tokenId;\\n  bytes32 dna;\\n  address creator;\\n  address renderer;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0TokenMetadata\\n * @dev An interface for the OpenAvatar metadata.\\n */\\ninterface IOpenAvatarGen0TokenMetadata {\\n  function getOpenAvatarGen0TokenMetadataByDNA(bytes32 dna) external view returns (OpenAvatarGen0TokenMetadata memory);\\n\\n  function getOpenAvatarGen0TokenMetadataByTokenId(\\n    uint tokenId\\n  ) external view returns (OpenAvatarGen0TokenMetadata memory);\\n\\n  function openAvatarURI(bytes32 dna) external view returns (string memory);\\n}\\n\\n/**\\n * @title IOpenAvatarGen0TokenDNA\\n * @dev An interface for the OpenAvatar DNA.\\n */\\ninterface IOpenAvatarGen0TokenDNA {\\n  function getDNAByTokenId(uint tokenId) external view returns (bytes32);\\n\\n  function getDNAsByTokenIds(uint[] calldata tokenIds) external view returns (bytes32[] memory);\\n\\n  function getTokenIdByDNA(bytes32 dna) external view returns (uint);\\n\\n  function getTokenIdsByDNAs(bytes32[] calldata dnas) external view returns (uint[] memory);\\n\\n  function creatorOf(uint tokenId) external view returns (address);\\n\\n  function creatorOfDNA(bytes32 dna) external view returns (address);\\n\\n  function ownerOfDNA(bytes32 dna) external view returns (address);\\n\\n  function ownerOfDNAs(bytes32[] calldata dnas) external view returns (address[] memory);\\n}\\n\\n/*\\n| Function                  | Mint State | Payment       | Batch  | Specify Recipient |\\n|---------------------------|------------|---------------|--------|-------------------|\\n| mint(dna)                 | Public     | mintPrice     | No     | No                |\\n| mintTo(to, dna)           | Public     | mintPrice     | No     | Yes               |\\n| mintBatch(dnas)           | Public     | mintPrice * N | Yes    | No                |\\n| mintBatchTo(to, dnas)     | Public     | mintPrice * N | Yes    | Yes               |\\n*/\\n\\n/**\\n * @title IOpenAvatarGen0TokenMintRead\\n * @notice An interface for reading OpenAvatar minting state.\\n */\\ninterface IOpenAvatarGen0TokenMintRead {\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Supply\\n  /////////////////////////////////////////////////////////////////////////////\\n  function supplySoftCap() external view returns (uint16);\\n\\n  function supplyHardCap() external view returns (uint16);\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Mint Price\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function getMintPrice() external view returns (uint);\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Mint State\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  function isMinted(bytes32 dna) external view returns (bool);\\n\\n  function isMintedEach(bytes32[] calldata dnas) external view returns (bool[] memory);\\n}\\n\\n/**\\n * @title IOpenAvatarGen0TokenMintWrite\\n * @notice An interface for minting OpenAvatars.\\n */\\ninterface IOpenAvatarGen0TokenMintWrite {\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Mint\\n  /////////////////////////////////////////////////////////////////////////////\\n  function mint(bytes32 dna) external payable;\\n\\n  function mintTo(address to, bytes32 dna) external payable;\\n\\n  function mintBatch(bytes32[] calldata dnas) external payable;\\n\\n  function mintBatchTo(address to, bytes32[] calldata dnas) external payable;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0TokenMintAdmin\\n * @notice An interface allowing the public mint price to be updated.\\n */\\ninterface IOpenAvatarGen0TokenMintAdmin {\\n  /////////////////////////////////////////////////////////////////////////////\\n  // Mint Price\\n  /////////////////////////////////////////////////////////////////////////////\\n  function setMintPrice(uint val) external;\\n}\\n\\n/**\\n * @title IOpenAvatarGen0TokenMint\\n * @notice The mint interfaces for OpenAvatarGen0Token.\\n */\\ninterface IOpenAvatarGen0TokenMint is\\n  IOpenAvatarGen0TokenMintRead,\\n  IOpenAvatarGen0TokenMintWrite,\\n  IOpenAvatarGen0TokenMintAdmin\\n{\\n\\n}\\n\\n/**\\n * @title IOpenAvatar\\n * @dev The OpenAvatar interface.\\n */\\ninterface IOpenAvatarGen0Token is\\n  IOpenAvatar,\\n  IOpenAvatarGen0TokenMetadata,\\n  IOpenAvatarGen0TokenDNA,\\n  IOpenAvatarGen0TokenMint\\n{\\n\\n}\\n\"\r\n    },\r\n    \"contracts/OpenAvatarGenerationZero.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {IOpenAvatar} from './IOpenAvatar.sol';\\n\\n/**\\n * @title IOpenAvatarGeneration\\n * @dev OpenAvatar Generation 0 common definitions.\\n */\\nabstract contract OpenAvatarGenerationZero is IOpenAvatar {\\n  /// @dev OpenAvatar Generation 0.\\n  uint public constant OPENAVATAR_GENERATION_ZERO = 0;\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // IOpenAvatarGeneration\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Returns 0, in reference to Open Avatar Generation 0.\\n   * @return 0 (zero).\\n   */\\n  function openAvatarGeneration() external pure returns (uint) {\\n    return OPENAVATAR_GENERATION_ZERO;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // IOpenAvatarSentinel\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Returns true.\\n   * @dev This is a sentinel function to indicate that this contract is an\\n   * OpenAvatar contract.\\n   * @return True.\\n   */\\n  function openAvatar() public pure returns (bool) {\\n    return true;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////////////\\n  // ERC-165: Standard Interface Detection\\n  /////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Checks if the contract supports an interface.\\n   * @param interfaceId The interface identifier, as specified in ERC-165.\\n   * @return True if the contract supports interfaceID, false otherwise.\\n   */\\n  function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\\n    return\\n      interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n      // IOpenAvatar\\n      interfaceId == 0xfdf02ac8 || // ERC165 interface ID for IOpenAvatarGeneration.\\n      interfaceId == 0x7b65147c || // ERC165 interface ID for IOpenAvatarSentinel.\\n      interfaceId == 0x86953eb4; // ERC165 interface ID for IOpenAvatar.\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"shanghai\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000,\r\n      \"details\": {\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"stackAllocation\": true\r\n        }\r\n      }\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ownerProxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FuseBurned\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"InterfaceUnsupported\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCanvasBytesPerPixel\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dna\",\"type\":\"bytes32\"}],\"name\":\"NotOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FuseBurnedChangeBackgroundImage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"BELOW_THE_NECK_MASK\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CANVAS_HEIGHT\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CANVAS_ID\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CANVAS_NUM_BYTES\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CANVAS_WIDTH\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IEND\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAYER_INDEX_BODY\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAYER_INDEX_BOTTOMWEAR\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAYER_INDEX_EYEWEAR\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAYER_INDEX_FACEWEAR\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAYER_INDEX_FACIAL_HAIR\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAYER_INDEX_FOOTWEAR\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAYER_INDEX_HAIR\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAYER_INDEX_HANDWEAR\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAYER_INDEX_JEWELRY\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAYER_INDEX_LEFT_EYE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAYER_INDEX_MAKEUP\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAYER_INDEX_OUTERWEAR\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAYER_INDEX_RIGHT_EYE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAYER_INDEX_TATTOOS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAYER_INDEX_TOPWEAR\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OPENAVATAR_GENERATION_ZERO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PNG_SIGNATURE\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SVG_SCALE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TEXT_KEY_PFP_BACKGROUND_COLOR\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TEXT_KEY_PFP_MASK\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TEXT_KEY_PFP_MASK_VALUE_BELOW_THE_NECK\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"backgroundImage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFuseChangeBackgroundImage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canvasId\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ENS\",\"name\":\"ens\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"}],\"name\":\"claimReverseENS\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"width\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"height\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"alpha\",\"type\":\"bool\"}],\"name\":\"encodeBase64PNG\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"width\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"height\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"alpha\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"svgWidth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"svgHeight\",\"type\":\"uint256\"}],\"name\":\"encodeBase64SVG\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"width\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"height\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"alpha\",\"type\":\"bool\"}],\"name\":\"encodeIHDR\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"width\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"height\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"alpha\",\"type\":\"bool\"}],\"name\":\"encodePNG\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"width\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"height\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"alpha\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"svgWidth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"svgHeight\",\"type\":\"uint256\"}],\"name\":\"encodeSVG\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fuseBurnedChangeBackgroundImage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBackgroundImage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCanvasId\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFuseBurnedChangeBackgroundImage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOpenAvatarGen0Assets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOpenAvatarGen0AssetsCanvasLayerCompositor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOpenAvatarGen0TextRecords\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOpenAvatarGen0Token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dna\",\"type\":\"bytes32\"}],\"name\":\"getProfilePictureSettings\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"overrideBackground\",\"type\":\"bool\"},{\"internalType\":\"bytes3\",\"name\":\"backgroundColor\",\"type\":\"bytes3\"},{\"internalType\":\"bool\",\"name\":\"maskBelowTheNeck\",\"type\":\"bool\"}],\"internalType\":\"struct OpenAvatarProfilePictureSettings\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"openAvatarGen0Assets_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"openAvatarAssesCanvasLayerCompositor_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"openAvatarGen0Token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"openAvatarGen0TextRecords_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openAvatar\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openAvatarGen0AssetsCanvasLayerCompositor\",\"outputs\":[{\"internalType\":\"contract IOpenAvatarGen0AssetsCanvasLayerCompositor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openAvatarGen0AssetsRead\",\"outputs\":[{\"internalType\":\"contract IOpenAvatarGen0AssetsRead\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openAvatarGen0TextRecords\",\"outputs\":[{\"internalType\":\"contract IOpenAvatarGen0TextRecords\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openAvatarGen0Token\",\"outputs\":[{\"internalType\":\"contract IOpenAvatarGen0TokenDNA\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openAvatarGeneration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dna\",\"type\":\"bytes32\"}],\"name\":\"renderBase64SVG\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dna\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"overrideBackground\",\"type\":\"bool\"},{\"internalType\":\"bytes3\",\"name\":\"backgroundColor\",\"type\":\"bytes3\"},{\"internalType\":\"bool\",\"name\":\"maskBelowTheNeck\",\"type\":\"bool\"}],\"internalType\":\"struct OpenAvatarProfilePictureSettings\",\"name\":\"pfpSettings\",\"type\":\"tuple\"}],\"name\":\"renderBase64SVGWithSettings\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dna\",\"type\":\"bytes32\"}],\"name\":\"renderURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dna\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"overrideBackground\",\"type\":\"bool\"},{\"internalType\":\"bytes3\",\"name\":\"backgroundColor\",\"type\":\"bytes3\"},{\"internalType\":\"bool\",\"name\":\"maskBelowTheNeck\",\"type\":\"bool\"}],\"internalType\":\"struct OpenAvatarProfilePictureSettings\",\"name\":\"pfpSettings\",\"type\":\"tuple\"}],\"name\":\"renderURIWithSettings\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ENS\",\"name\":\"ens\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setReverseENS\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "OpenAvatarGen0ProfilePictureRenderer", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "00000000000000000000000000000000000027390b412440c58100929acfeae2", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}