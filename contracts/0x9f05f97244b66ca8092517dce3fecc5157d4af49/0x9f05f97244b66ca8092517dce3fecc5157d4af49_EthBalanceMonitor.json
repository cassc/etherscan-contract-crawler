{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/EthBalanceMonitor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.7;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/ConfirmedOwner.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\n\\n/**\\n * @title The EthBalanceMonitor contract\\n * @notice A keeper-compatible contract that monitors and funds eth addresses\\n */\\ncontract EthBalanceMonitor is\\n    ConfirmedOwner,\\n    Pausable,\\n    KeeperCompatibleInterface\\n{\\n    // observed limit of 45K + 10k buffer\\n    uint256 private constant MIN_GAS_FOR_TRANSFER = 55_000;\\n\\n    event FundsAdded(uint256 amountAdded, uint256 newBalance, address sender);\\n    event FundsWithdrawn(uint256 amountWithdrawn, address payee);\\n    event TopUpSucceeded(address indexed recipient);\\n    event TopUpFailed(address indexed recipient);\\n    event KeeperRegistryAddressUpdated(address oldAddress, address newAddress);\\n    event MinWaitPeriodUpdated(\\n        uint256 oldMinWaitPeriod,\\n        uint256 newMinWaitPeriod\\n    );\\n\\n    error InvalidWatchList();\\n    error OnlyKeeperRegistry();\\n    error DuplicateAddress(address duplicate);\\n\\n    struct Target {\\n        bool isActive;\\n        uint96 minBalanceWei;\\n        uint96 topUpAmountWei;\\n        uint56 lastTopUpTimestamp; // enough space for 2 trillion years\\n    }\\n\\n    address private s_keeperRegistryAddress;\\n    uint256 private s_minWaitPeriodSeconds;\\n    address[] private s_watchList;\\n    mapping(address => Target) internal s_targets;\\n\\n    /**\\n     * @param keeperRegistryAddress The address of the keeper registry contract\\n     * @param minWaitPeriodSeconds The minimum wait period for addresses between funding\\n     */\\n    constructor(address keeperRegistryAddress, uint256 minWaitPeriodSeconds)\\n        ConfirmedOwner(msg.sender)\\n    {\\n        setKeeperRegistryAddress(keeperRegistryAddress);\\n        setMinWaitPeriodSeconds(minWaitPeriodSeconds);\\n    }\\n\\n    /**\\n     * @notice Sets the list of addresses to watch and their funding parameters\\n     * @param addresses the list of addresses to watch\\n     * @param minBalancesWei the minimum balances for each address\\n     * @param topUpAmountsWei the amount to top up each address\\n     */\\n    function setWatchList(\\n        address[] calldata addresses,\\n        uint96[] calldata minBalancesWei,\\n        uint96[] calldata topUpAmountsWei\\n    ) external onlyOwner {\\n        if (\\n            addresses.length != minBalancesWei.length ||\\n            addresses.length != topUpAmountsWei.length\\n        ) {\\n            revert InvalidWatchList();\\n        }\\n        address[] memory oldWatchList = s_watchList;\\n        for (uint256 idx = 0; idx < oldWatchList.length; idx++) {\\n            s_targets[oldWatchList[idx]].isActive = false;\\n        }\\n        for (uint256 idx = 0; idx < addresses.length; idx++) {\\n            if (s_targets[addresses[idx]].isActive) {\\n                revert DuplicateAddress(addresses[idx]);\\n            }\\n            if (addresses[idx] == address(0)) {\\n                revert InvalidWatchList();\\n            }\\n            if (topUpAmountsWei[idx] == 0) {\\n                revert InvalidWatchList();\\n            }\\n            s_targets[addresses[idx]] = Target({\\n                isActive: true,\\n                minBalanceWei: minBalancesWei[idx],\\n                topUpAmountWei: topUpAmountsWei[idx],\\n                lastTopUpTimestamp: 0\\n            });\\n        }\\n        s_watchList = addresses;\\n    }\\n\\n    /**\\n     * @notice Gets a list of addresses that are under funded\\n     * @return list of addresses that are underfunded\\n     */\\n    function getUnderfundedAddresses() public view returns (address[] memory) {\\n        address[] memory watchList = s_watchList;\\n        address[] memory needsFunding = new address[](watchList.length);\\n        uint256 count = 0;\\n        uint256 minWaitPeriod = s_minWaitPeriodSeconds;\\n        uint256 balance = address(this).balance;\\n        Target memory target;\\n        for (uint256 idx = 0; idx < watchList.length; idx++) {\\n            target = s_targets[watchList[idx]];\\n            if (\\n                target.lastTopUpTimestamp + minWaitPeriod <= block.timestamp &&\\n                balance >= target.topUpAmountWei &&\\n                watchList[idx].balance < target.minBalanceWei\\n            ) {\\n                needsFunding[count] = watchList[idx];\\n                count++;\\n                balance -= target.topUpAmountWei;\\n            }\\n        }\\n        if (count != watchList.length) {\\n            assembly {\\n                mstore(needsFunding, count)\\n            }\\n        }\\n        return needsFunding;\\n    }\\n\\n    /**\\n     * @notice Send funds to the addresses provided\\n     * @param needsFunding the list of addresses to fund (addresses must be pre-approved)\\n     */\\n    function topUp(address[] memory needsFunding) public whenNotPaused {\\n        uint256 minWaitPeriodSeconds = s_minWaitPeriodSeconds;\\n        Target memory target;\\n        for (uint256 idx = 0; idx < needsFunding.length; idx++) {\\n            target = s_targets[needsFunding[idx]];\\n            if (\\n                target.isActive &&\\n                target.lastTopUpTimestamp + minWaitPeriodSeconds <=\\n                block.timestamp &&\\n                needsFunding[idx].balance < target.minBalanceWei\\n            ) {\\n                bool success = payable(needsFunding[idx]).send(\\n                    target.topUpAmountWei\\n                );\\n                if (success) {\\n                    s_targets[needsFunding[idx]].lastTopUpTimestamp = uint56(\\n                        block.timestamp\\n                    );\\n                    emit TopUpSucceeded(needsFunding[idx]);\\n                } else {\\n                    emit TopUpFailed(needsFunding[idx]);\\n                }\\n            }\\n            if (gasleft() < MIN_GAS_FOR_TRANSFER) {\\n                return;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Get list of addresses that are underfunded and return keeper-compatible payload\\n     * @return upkeepNeeded signals if upkeep is needed, performData is an abi encoded list of addresses that need funds\\n     */\\n    function checkUpkeep(bytes calldata)\\n        external\\n        view\\n        override\\n        whenNotPaused\\n        returns (bool upkeepNeeded, bytes memory performData)\\n    {\\n        address[] memory needsFunding = getUnderfundedAddresses();\\n        upkeepNeeded = needsFunding.length > 0;\\n        performData = abi.encode(needsFunding);\\n        return (upkeepNeeded, performData);\\n    }\\n\\n    /**\\n     * @notice Called by keeper to send funds to underfunded addresses\\n     * @param performData The abi encoded list of addresses to fund\\n     */\\n    function performUpkeep(bytes calldata performData)\\n        external\\n        override\\n        onlyKeeperRegistry\\n        whenNotPaused\\n    {\\n        address[] memory needsFunding = abi.decode(performData, (address[]));\\n        topUp(needsFunding);\\n    }\\n\\n    /**\\n     * @notice Withdraws the contract balance\\n     * @param amount The amount of eth (in wei) to withdraw\\n     * @param payee The address to pay\\n     */\\n    function withdraw(uint256 amount, address payable payee)\\n        external\\n        onlyOwner\\n    {\\n        require(payee != address(0));\\n        emit FundsWithdrawn(amount, payee);\\n        payee.transfer(amount);\\n    }\\n\\n    /**\\n     * @notice Receive funds\\n     */\\n    receive() external payable {\\n        emit FundsAdded(msg.value, address(this).balance, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Sets the keeper registry address\\n     */\\n    function setKeeperRegistryAddress(address keeperRegistryAddress)\\n        public\\n        onlyOwner\\n    {\\n        require(keeperRegistryAddress != address(0));\\n        emit KeeperRegistryAddressUpdated(\\n            s_keeperRegistryAddress,\\n            keeperRegistryAddress\\n        );\\n        s_keeperRegistryAddress = keeperRegistryAddress;\\n    }\\n\\n    /**\\n     * @notice Sets the minimum wait period (in seconds) for addresses between funding\\n     */\\n    function setMinWaitPeriodSeconds(uint256 period) public onlyOwner {\\n        emit MinWaitPeriodUpdated(s_minWaitPeriodSeconds, period);\\n        s_minWaitPeriodSeconds = period;\\n    }\\n\\n    /**\\n     * @notice Gets the keeper registry address\\n     */\\n    function getKeeperRegistryAddress()\\n        external\\n        view\\n        returns (address keeperRegistryAddress)\\n    {\\n        return s_keeperRegistryAddress;\\n    }\\n\\n    /**\\n     * @notice Gets the minimum wait period\\n     */\\n    function getMinWaitPeriodSeconds() external view returns (uint256) {\\n        return s_minWaitPeriodSeconds;\\n    }\\n\\n    /**\\n     * @notice Gets the list of addresses being watched\\n     */\\n    function getWatchList() external view returns (address[] memory) {\\n        return s_watchList;\\n    }\\n\\n    /**\\n     * @notice Gets configuration information for an address on the watchlist\\n     */\\n    function getAccountInfo(address targetAddress)\\n        external\\n        view\\n        returns (\\n            bool isActive,\\n            uint96 minBalanceWei,\\n            uint96 topUpAmountWei,\\n            uint56 lastTopUpTimestamp\\n        )\\n    {\\n        Target memory target = s_targets[targetAddress];\\n        return (\\n            target.isActive,\\n            target.minBalanceWei,\\n            target.topUpAmountWei,\\n            target.lastTopUpTimestamp\\n        );\\n    }\\n\\n    /**\\n     * @notice Pauses the contract, which prevents executing performUpkeep\\n     */\\n    function pause() external onlyOwner {\\n        _pause();\\n    }\\n\\n    /**\\n     * @notice Unpauses the contract\\n     */\\n    function unpause() external onlyOwner {\\n        _unpause();\\n    }\\n\\n    modifier onlyKeeperRegistry() {\\n        if (msg.sender != s_keeperRegistryAddress) {\\n            revert OnlyKeeperRegistry();\\n        }\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/ConfirmedOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwnerWithProposal.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface KeeperCompatibleInterface {\\n  /**\\n   * @notice method that is simulated by the keepers to see if any work actually\\n   * needs to be performed. This method does does not actually need to be\\n   * executable, and since it is only ever simulated it can consume lots of gas.\\n   * @dev To ensure that it is never called, you may want to add the\\n   * cannotExecute modifier from KeeperBase to your implementation of this\\n   * method.\\n   * @param checkData specified in the upkeep registration so it is always the\\n   * same for a registered upkeep. This can easily be broken down into specific\\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\\n   * same contract and easily differentiated by the contract.\\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\\n   * performUpkeep or not.\\n   * @return performData bytes that the keeper should call performUpkeep with, if\\n   * upkeep is needed. If you would like to encode data to decode later, try\\n   * `abi.encode`.\\n   */\\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\\n\\n  /**\\n   * @notice method that is actually executed by the keepers, via the registry.\\n   * The data returned by the checkUpkeep simulation will be passed into\\n   * this method to actually be executed.\\n   * @dev The input to this method should not be trusted, and the caller of the\\n   * method should not even be restricted to any single registry. Anyone should\\n   * be able call it, and the input should be validated, there is no guarantee\\n   * that the data passed in is the performData returned from checkUpkeep. This\\n   * could happen due to malicious keepers, racing keepers, or simply a state\\n   * change while the performUpkeep transaction is waiting for confirmation.\\n   * Always validate the data passed in.\\n   * @param performData is the data which was passed back from the checkData\\n   * simulation. If it is encoded, it can easily be decoded into other types by\\n   * calling `abi.decode`. This data should not be trusted, and should be\\n   * validated against the contract's current state.\\n   */\\n  function performUpkeep(bytes calldata performData) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/ConfirmedOwnerWithProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/OwnableInterface.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\\n  address private s_owner;\\n  address private s_pendingOwner;\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    require(newOwner != address(0), \\\"Cannot set owner to zero\\\");\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows an owner to begin transferring ownership to a new address,\\n   * pending.\\n   */\\n  function transferOwnership(address to) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /**\\n   * @notice Allows an ownership transfer to be completed by the recipient.\\n   */\\n  function acceptOwnership() external override {\\n    require(msg.sender == s_pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Get the current owner\\n   */\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /**\\n   * @notice validate, transfer ownership, and emit relevant events\\n   */\\n  function _transferOwnership(address to) private {\\n    require(to != msg.sender, \\\"Cannot transfer to self\\\");\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /**\\n   * @notice validate access\\n   */\\n  function _validateOwnership() internal view {\\n    require(msg.sender == s_owner, \\\"Only callable by owner\\\");\\n  }\\n\\n  /**\\n   * @notice Reverts if called by anyone other than the contract owner.\\n   */\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/OwnableInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface OwnableInterface {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(address recipient) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"keeperRegistryAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minWaitPeriodSeconds\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"duplicate\",\"type\":\"address\"}],\"name\":\"DuplicateAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidWatchList\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyKeeperRegistry\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountAdded\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"FundsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"FundsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"KeeperRegistryAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMinWaitPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMinWaitPeriod\",\"type\":\"uint256\"}],\"name\":\"MinWaitPeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"TopUpFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"TopUpSucceeded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"upkeepNeeded\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"}],\"name\":\"getAccountInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint96\",\"name\":\"minBalanceWei\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"topUpAmountWei\",\"type\":\"uint96\"},{\"internalType\":\"uint56\",\"name\":\"lastTopUpTimestamp\",\"type\":\"uint56\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getKeeperRegistryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"keeperRegistryAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinWaitPeriodSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnderfundedAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWatchList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"name\":\"performUpkeep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"keeperRegistryAddress\",\"type\":\"address\"}],\"name\":\"setKeeperRegistryAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"setMinWaitPeriodSeconds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint96[]\",\"name\":\"minBalancesWei\",\"type\":\"uint96[]\"},{\"internalType\":\"uint96[]\",\"name\":\"topUpAmountsWei\",\"type\":\"uint96[]\"}],\"name\":\"setWatchList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"needsFunding\",\"type\":\"address[]\"}],\"name\":\"topUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "EthBalanceMonitor", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000002777053d6764996e594c3e88af1d58d5363a2e6000000000000000000000000000000000000000000000000000000000000003c", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}