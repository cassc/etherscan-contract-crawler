{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/pool/impl/app/DittoPoolApp.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nimport { Fee } from \\\"../../../struct/Fee.sol\\\";\\nimport { NftCostData } from \\\"../../../struct/NftCostData.sol\\\";\\nimport { IDittoPool } from \\\"../../../interface/IDittoPool.sol\\\";\\nimport { DittoPool } from \\\"../../DittoPool.sol\\\";\\nimport { CurveErrorCode } from \\\"../../../utils/CurveErrorCode.sol\\\";\\nimport { FixedPointMathLib } from \\\"../../../../lib/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport { IUpshotOracle, PriceData } from \\\"../../../../lib/upshot-oracle/contracts/IUpshotOracle.sol\\\";\\nimport { DittoPoolTrade } from \\\"../../DittoPoolTrade.sol\\\";\\n\\n\\n/**\\n * @title Ditto Pool Appraisal Curve\\n */\\ncontract DittoPoolApp is DittoPool {\\n    using FixedPointMathLib for uint256;\\n\\n    // ***************************************************************\\n    // * ========================= EVENTS ========================== *\\n    // ***************************************************************\\n\\n    event DittoPoolAppUpdatePriceMaxBuy(uint256 priceMaxBuy);\\n    event DittoPoolAppUpdatePriceMinSell(uint256 priceMinSell);\\n    event DittoPoolAppraisalInitializedWithOracle(address oracle);\\n\\n    // ***************************************************************\\n    // * ========================= ERRORS ========================== *\\n    // ***************************************************************\\n\\n    error DittoPoolAppInvalidTokenPrice();\\n    error DittoPoolAppraisalIncorrectToken();\\n    error DittoPoolAppraisalIncorrectCollection();\\n\\n    // ***************************************************************\\n    // * ========================= ORACLE ========================== *\\n    // ***************************************************************\\n    IUpshotOracle internal _oracle;\\n\\n    /**\\n     * View function for the oracle\\n     * \\n     * @return oracle The oracle address\\n     */\\n    function oracle() public view returns (IUpshotOracle) {\\n        return _oracle;\\n    }\\n    \\n    ///@dev Minimum price to sell a token out of the pool\\n    uint256 internal _priceMinSell;\\n\\n    ///@dev Maximum price to buy a token for the pool, a given LP position\\n    uint256 internal _priceMaxBuy;\\n\\n    /**\\n     * @param priceMaxBuy_ The maximum price to buy a token for the pool, a given LP position\\n     */\\n    function changePriceMaxBuy(uint256 priceMaxBuy_) external onlyOwner {\\n        _changePriceMaxBuy(priceMaxBuy_);\\n    }\\n\\n    /**\\n     * @param priceMinSell_ The minimum price to sell a token out of the pool\\n     */\\n    function changePriceMinSell(uint256 priceMinSell_) external onlyOwner {\\n        _changePriceMinSell(priceMinSell_);\\n    }\\n\\n    ///@notice Internal helper function to change the priceMaxBuy\\n    function _changePriceMaxBuy(uint256 priceMaxBuy_) private {\\n        _priceMaxBuy = priceMaxBuy_;\\n        emit DittoPoolAppUpdatePriceMaxBuy(_priceMaxBuy);\\n    }\\n\\n    ///@notice Internal helper function to change the priceMinSell\\n    function _changePriceMinSell(uint256 priceMinSell_) private {\\n        _priceMinSell = priceMinSell_;\\n        emit DittoPoolAppUpdatePriceMinSell(_priceMinSell);\\n    }\\n\\n    /**\\n     * @dev View function for the priceMaxBuy\\n     */\\n    function priceMaxBuy() external view returns (uint256 priceMaxBuy_) {\\n        priceMaxBuy_ = _priceMaxBuy;\\n    }\\n\\n    /**\\n     * @dev View function for the priceMinSell\\n     */\\n    function priceMinSell() external view returns (uint256 priceMinSell_) {\\n        priceMinSell_ = _priceMinSell;\\n    }\\n\\n    /**\\n     * @dev Custom initialization function for the Ditto Pool Appraisal Curve to initialize the \\n     *   appraisal oracle address\\n     * \\n     * @param templateInitData_ The oracle address encoded in bytes\\n     */\\n    function _initializeCustomPoolData(bytes calldata templateInitData_) internal override {\\n        (\\n            address oracle_, \\n            uint256 priceMinSell_,\\n            uint256 priceMaxBuy_\\n        ) = abi.decode(templateInitData_, (address, uint256, uint256));\\n        _oracle = IUpshotOracle(oracle_);\\n        _changePriceMinSell(priceMinSell_);\\n        _changePriceMaxBuy(priceMaxBuy_);\\n\\n        emit DittoPoolAppraisalInitializedWithOracle(address(_oracle));\\n    }\\n\\n    // ***************************************************************\\n    // * ================== CURVE IMPLEMENTATION =================== *\\n    // ***************************************************************\\n\\n    ///@inheritdoc IDittoPool\\n    function bondingCurve() public pure virtual override (IDittoPool) returns (string memory curve) {\\n        return \\\"Curve: APP\\\";\\n    }\\n\\n    /**\\n     * @dev See {DittPool-_validateDelta}\\n     */\\n    function _invalidDelta(uint128 /*delta*/) internal pure override returns (bool valid) {\\n        return false;\\n    }\\n\\n    /**\\n     * @dev See {DittPool-_validateBasePrice}\\n     */\\n    function _invalidBasePrice(uint128 /*newBasePrice*/) internal pure override returns (bool) {\\n        return false;\\n    }\\n\\n\\n    function _decodeTokenPrices(\\n        PriceData[] memory tokenPriceData_\\n    ) internal returns (uint256[] memory tokenPrices) {\\n\\n        uint256 tokenPriceDataCount = tokenPriceData_.length;\\n\\n        tokenPrices = new uint256[](tokenPriceDataCount);\\n\\n        if (tokenPriceDataCount == 0) {\\n            return tokenPrices;\\n        }\\n\\n        for(uint256 i = 0; i < tokenPriceDataCount;) {\\n            if (tokenPriceData_[i].nft != address(_nft)) {\\n                revert DittoPoolAppraisalIncorrectCollection();\\n            }\\n\\n            if (tokenPriceData_[i].token != address(_token)) {\\n                revert DittoPoolAppraisalIncorrectToken();\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        tokenPrices = _oracle.decodeTokenPrices(tokenPriceData_);\\n    }\\n\\n    /**\\n     * @dev See {DittPool-_getBuyInfo}\\n     */\\n    function _getBuyInfo(\\n        uint128 /*basePrice*/,\\n        uint128 /*delta*/,\\n        uint256 numItems,\\n        bytes calldata swapData_,\\n        Fee memory fee_\\n    )\\n        internal\\n        virtual\\n        override\\n        returns (\\n            CurveErrorCode error,\\n            uint128 newBasePrice,\\n            uint128 newDelta,\\n            uint256 inputValue,\\n            NftCostData[] memory nftCostData\\n        )\\n    {\\n        if (numItems == 0) {\\n            return (CurveErrorCode.INVALID_NUMITEMS, 0, 0, 0, nftCostData);\\n        }\\n\\n        if (swapData_.length == 0) {\\n            return (CurveErrorCode.MISSING_SWAP_DATA, 0, 0, 0, nftCostData);\\n        }\\n\\n        PriceData[] memory tokenPriceData = abi.decode(swapData_, (PriceData[]));\\n\\n        if (tokenPriceData.length != numItems) {\\n            return (CurveErrorCode.INVALID_NUMITEMS, 0, 0, 0, nftCostData);\\n        }\\n\\n        uint256[] memory tokenPrices = _decodeTokenPrices(tokenPriceData);\\n\\n        nftCostData = new NftCostData[](numItems);\\n        uint256 tokenPrice;\\n        Fee memory calculatedFees;\\n\\n        for (uint256 i = 0; i < numItems;) {\\n            tokenPrice = tokenPrices[i];\\n\\n            ///@notice appraised price is less than that at which the admin \\n            /// has specified the pool will sell out an nft\\n            if(tokenPrice < _priceMinSell) {\\n                revert DittoPoolAppInvalidTokenPrice();\\n            }\\n\\n            calculatedFees = Fee({\\n                lp: _mul(tokenPrice, fee_.lp),\\n                protocol: _mul(tokenPrice, fee_.protocol),\\n                admin: _mul(tokenPrice, fee_.admin)\\n            });\\n\\n            nftCostData[i] = NftCostData({\\n                specificNftId: true,\\n                nftId: tokenPriceData[i].nftId,\\n                price: tokenPrice,\\n                fee: calculatedFees\\n            });\\n            \\n            inputValue += \\n                tokenPrice + \\n                calculatedFees.lp +\\n                calculatedFees.protocol +\\n                calculatedFees.admin;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // If we got all the way here, no math error happened\\n        error = CurveErrorCode.OK;\\n    }\\n\\n    /**\\n     *  @dev See {DittPool-_getSellInfo}\\n     */\\n    function _getSellInfo(\\n        uint128 /*basePrice*/,\\n        uint128 /*delta*/,\\n        uint256 numItems,\\n        bytes calldata swapData_,\\n        Fee memory fee_\\n    )\\n        internal\\n        virtual\\n        override\\n        returns (\\n            CurveErrorCode error,\\n            uint128 newBasePrice,\\n            uint128 newDelta,\\n            uint256 outputValue,\\n            NftCostData[] memory nftCostData\\n        )\\n    {\\n        // NOTE: we assume delta is > 1, as checked by validateDelta()\\n        // We only calculate changes for buying 1 or more NFTs\\n        if (numItems == 0) {\\n            return (CurveErrorCode.INVALID_NUMITEMS, 0, 0, 0, nftCostData);\\n        }\\n\\n        if (swapData_.length == 0) {\\n            return (CurveErrorCode.MISSING_SWAP_DATA, 0, 0, 0, nftCostData);\\n        }\\n\\n        PriceData[] memory tokenPriceData = abi.decode(swapData_, (PriceData[]));\\n\\n        if (tokenPriceData.length != numItems) {\\n            return (CurveErrorCode.INVALID_NUMITEMS, 0, 0, 0, nftCostData);\\n        }\\n\\n        uint256[] memory tokenPrices = _decodeTokenPrices(tokenPriceData);\\n\\n        nftCostData = new NftCostData[](numItems);\\n\\n        Fee memory calculatedFees;\\n        uint256 tokenPrice;\\n\\n        for (uint256 i = 0; i < numItems;) {\\n            tokenPrice = tokenPrices[i];\\n\\n            ///@notice appraised value is greater than that at which the admin \\n            ///has specified the pool will buy an nft\\n            if(tokenPrice > _priceMaxBuy) {\\n                revert DittoPoolAppInvalidTokenPrice();\\n            }\\n\\n            calculatedFees = Fee({\\n                lp: _mul(tokenPrice, fee_.lp),\\n                protocol: _mul(tokenPrice, fee_.protocol),\\n                admin: _mul(tokenPrice, fee_.admin)\\n            });\\n\\n            nftCostData[i] = NftCostData({\\n                specificNftId: true,\\n                nftId: tokenPriceData[i].nftId,\\n                price: tokenPrice,\\n                fee: calculatedFees\\n            }); \\n\\n            outputValue += \\n                tokenPrice - \\n                (\\n                    calculatedFees.lp +\\n                    calculatedFees.protocol +\\n                    calculatedFees.admin\\n                );\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // If we got all the way here, no math error happened\\n        error = CurveErrorCode.OK;\\n    }\\n\\n    function getBuyNftQuote(uint256 /* numNfts_ */, bytes calldata /* swapData_ */)\\n        external\\n        pure\\n        override(IDittoPool, DittoPoolTrade)\\n        returns (\\n            CurveErrorCode error,\\n            uint256 newBasePrice,\\n            uint256 newDelta,\\n            uint256 inputAmount,\\n            NftCostData[] memory nftCostData\\n        )\\n    {\\n        NftCostData[] memory nftCostData_;\\n        return (CurveErrorCode.NOOP, 0, 0, 0, nftCostData_);\\n    }\\n\\n\\n    function getSellNftQuote(uint256 /* numNfts_ */, bytes calldata /* swapData_ */)\\n        external\\n        pure\\n        override(IDittoPool, DittoPoolTrade)\\n        returns (\\n            CurveErrorCode error,\\n            uint256 newBasePrice,\\n            uint256 newDelta,\\n            uint256 outputAmount,\\n            NftCostData[] memory nftCostData\\n        )\\n    {\\n        NftCostData[] memory nftCostData_;\\n        return (CurveErrorCode.NOOP, 0, 0, 0, nftCostData_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/struct/Fee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\n/**\\n * @title Fee\\n * @notice Struct to hold the fee amounts for LP, admin and protocol. Is used in the protocol to \\n *   pass the fee percentages and the total fee amount depending on the context.\\n */\\nstruct Fee {\\n    uint256 lp;\\n    uint256 admin;\\n    uint256 protocol;\\n}\\n\"\r\n    },\r\n    \"contracts/struct/NftCostData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity 0.8.19;\\n\\nimport { Fee } from \\\"./Fee.sol\\\";\\n\\nstruct NftCostData {\\n    bool specificNftId;\\n    uint256 nftId;\\n    uint256 price;\\n    Fee fee;\\n}\"\r\n    },\r\n    \"contracts/interface/IDittoPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\nimport { Fee } from \\\"../struct/Fee.sol\\\";\\nimport { SwapNftsForTokensArgs, SwapTokensForNftsArgs } from \\\"../struct/SwapArgs.sol\\\";\\nimport { LpNft } from \\\"../pool/lpNft/LpNft.sol\\\";\\nimport { PoolTemplate } from \\\"../struct/FactoryTemplates.sol\\\";\\nimport { LpIdToTokenBalance } from \\\"../struct/LpIdToTokenBalance.sol\\\";\\nimport { NftCostData } from \\\"../struct/NftCostData.sol\\\";\\nimport { IPermitter } from \\\"../interface/IPermitter.sol\\\";\\n\\nimport { IERC721 } from \\\"../../lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\\\";\\nimport { CurveErrorCode } from \\\"../utils/CurveErrorCode.sol\\\";\\n\\nimport { IOwnerTwoStep } from \\\"./IOwnerTwoStep.sol\\\";\\n\\ninterface IDittoPool is IOwnerTwoStep {\\n    // ***************************************************************\\n    // * =============== ADMINISTRATIVE FUNCTIONS ================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice For use in tokenURI function metadata\\n     * @return curve type of curve\\n     */\\n    function bondingCurve() external pure returns (string memory curve);\\n\\n    /**\\n     * @notice Used by the Contract Factory to set the initial state & parameters of the pool.\\n     * @dev Necessarily separate from constructor due to [ERC-1167](https://eips.ethereum.org/EIPS/eip-1167) factory clone paradigm.\\n     * @param params_ A struct that contains various initialization parameters for the pool. See `PoolTemplate.sol` for details.\\n     * @param template_ which address was used to clone business logic for this pool.\\n     * @param lpNft_ The Liquidity Provider Positions NFT contract that tokenizes liquidity provisions in the protocol\\n     * @param permitter_ Contract to authorize which tokenIds from the underlying nft collection are allowed to be traded in this pool.\\n     * @dev Set permitter to address(0) to allow any tokenIds from the underlying NFT collection.\\n     */\\n    function initPool(\\n        PoolTemplate calldata params_,\\n        address template_,\\n        LpNft lpNft_,\\n        IPermitter permitter_\\n    ) external;\\n\\n    /**\\n     * @notice Admin function to change the base price charged to buy an NFT from the pair. Each bonding curve uses this differently.\\n     * @param newBasePrice_ The updated base price\\n     */\\n    function changeBasePrice(uint128 newBasePrice_) external;\\n\\n    /**\\n     * @notice Admin function to change the delta parameter associated with the bonding curve. Each bonding curve uses this differently. \\n     * @param newDelta_ The updated delta\\n     */\\n    function changeDelta(uint128 newDelta_) external;\\n\\n    /**\\n     * @notice Admin function to change the pool lp fee, set by owner, paid to LPers only when they are the counterparty in a trade\\n     * @param newFeeLp_ New fee, in wei / 1e18, charged by the pool for trades with it (i.e. 1% = 0.01e18)\\n     */\\n    function changeLpFee(uint96 newFeeLp_) external;\\n\\n    /**\\n     * @notice Change the pool admin fee, set by owner, paid to an address of the owner's choosing\\n     * @param newFeeAdmin_ New fee, in wei / 1e18, charged by the pool for trades with it (i.e. 1% = 0.01e18)\\n     */\\n    function changeAdminFee(uint96 newFeeAdmin_) external;\\n\\n    /**\\n     * @notice Change who the pool admin fee for this pool is sent to.\\n     * @param newAdminFeeRecipient_ New address to send admin fees to\\n     */\\n    function changeAdminFeeRecipient(address newAdminFeeRecipient_) external;\\n\\n    // ***************************************************************\\n    // * ================== LIQUIDITY FUNCTIONS ==================== *\\n    // ***************************************************************\\n    /**\\n     * @notice Function for liquidity providers to create new Liquidity Positions within the pool by depositing liquidity.\\n     * @dev Provides the liquidity provider with a new liquidity position tracking NFT every time. \\n     * @dev This function assumes that msg.sender is the owner of the NFTs and Tokens.\\n     * @dev This function expects that this contract has permission to move NFTs and tokens to itself from the owner.\\n     * @dev The **lpRecipient_** parameter to this function is intended to allow creating positions on behalf of\\n     * another party. msg.sender can send nfts and tokens to the pool and then have the pool create the liquidity position\\n     * for someone who is not msg.sender. The `DittoPoolFactory` uses this feature to create a new DittoPool and deposit\\n     * liquidity into it in one step. NFTs flow from user -> factory -> pool and then lpRecipient_ is set to the user.\\n     * @dev `lpRecipient_` can steal liquidity deposited by msg.sender if lpRecipient_ is not set to msg.sender.\\n     * @param lpRecipient_ The address that will receive the LP position ownership NFT.\\n     * @param nftIdList_ The list of NFT tokenIds msg.sender wishes to deposit into the pool.\\n     * @param tokenDepositAmount_ The amount of ERC20 tokens msg.sender wishes to deposit into the pool.\\n     * @param permitterData_ Data to check that the NFT Token IDs are permitted to deposited into this pool if a permitter is set.\\n     * @return lpId The tokenId of the LP position NFT that was minted as a result of this liquidity deposit.\\n     */\\n    function createLiquidity(\\n        address lpRecipient_,\\n        uint256[] calldata nftIdList_,\\n        uint256 tokenDepositAmount_,\\n        bytes calldata permitterData_,\\n        bytes calldata referrer_\\n    ) external returns (uint256 lpId);\\n\\n    /**\\n     * @notice Function for market makers / liquidity providers to deposit NFTs and ERC20s into existing LP Positions.\\n     * @dev Anybody may add liquidity to existing LP Positions, regardless of whether they own the position or not.\\n     * @dev This function expects that this contract has permission to move NFTs and tokens to itself from the msg.sender.\\n     * @param lpId_ TokenId of existing LP position to add liquidity to. Does not have to be owned by msg.sender!\\n     * @param nftIdList_ The list of NFT tokenIds msg.sender wishes to deposit into the pool.\\n     * @param tokenDepositAmount_ The amount of ERC20 tokens msg.sender wishes to deposit into the pool.\\n     * @param permitterData_ Data to check that the NFT Token IDs are permitted to deposited into this pool if a permitter is set.\\n     */\\n    function addLiquidity(\\n        uint256 lpId_,\\n        uint256[] calldata nftIdList_,\\n        uint256 tokenDepositAmount_,\\n        bytes calldata permitterData_,\\n        bytes calldata referrer_\\n    ) external;\\n\\n    /**\\n     * @notice Function for liquidity providers to withdraw NFTs and ERC20 tokens from their LP positions.\\n     * @dev Can be called to change an existing liquidity position, or remove an LP position by withdrawing all liquidity.\\n     * @dev May be called by an authorized party (approved on the LP NFT) to withdraw liquidity on behalf of the LP Position owner.\\n     * @param withdrawalAddress_ the address that will receive the ERC20 tokens and NFTs withdrawn from the pool.\\n     * @param lpId_ LP Position TokenID that liquidity is being removed from. Does not have to be owned by msg.sender if the msg.sender is authorized.\\n     * @param nftIdList_ The list of NFT tokenIds msg.sender wishes to withdraw from the pool.\\n     * @param tokenWithdrawAmount_ The amount of ERC20 tokens the msg.sender wishes to withdraw from the pool.\\n     */\\n    function pullLiquidity(\\n        address withdrawalAddress_,\\n        uint256 lpId_,\\n        uint256[] calldata nftIdList_,\\n        uint256 tokenWithdrawAmount_\\n    ) external;\\n\\n    // ***************************************************************\\n    // * =================== TRADE FUNCTIONS ======================= *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice Trade ERC20s for a specific list of NFT token ids.\\n     * @dev To compute the amount of token to send, call bondingCurve.getBuyInfo\\n     * This swap is meant for users who want specific IDs. \\n     * \\n     * @param args_ The arguments for the swap. See SwapArgs.sol for parameters\\n     * @return inputAmount The actual amount of tokens spent to purchase the NFTs.\\n     */\\n    function swapTokensForNfts(\\n        SwapTokensForNftsArgs calldata args_\\n    ) external returns (uint256 inputAmount);\\n\\n    /**\\n     * @notice Trade a list of allowed nft ids for ERC20s.\\n     * @dev To compute the amount of token to that will be received, call bondingCurve.getSellInfo.\\n     * @dev Key difference with sudoswap here:\\n     * In sudoswap, each market maker has a separate smart contract with their liquidity.\\n     * To sell to a market maker, you just check if their specific `LSSVMPair` contract has enough money.\\n     * In DittoSwap, we share different market makers' liquidity in the same pool contract.\\n     * So this function has an additional parameter `lpIds` forcing the buyer to check\\n     * off-chain which market maker's LP position that they want to trade with, for each specific NFT\\n     * that they are selling into the pool. The lpIds array should correspond with the nftIds\\n     * array in the same order & indexes. e.g. to sell NFT with tokenId 1337 to the market maker who's\\n     * LP position has id 42, the buyer would call this function with\\n     * nftIds = [1337] and lpIds = [42].\\n     *\\n     * @param args_ The arguments for the swap. See SwapArgs.sol for parameters\\n     * @return outputAmount The amount of token received\\n     */\\n    function swapNftsForTokens(\\n        SwapNftsForTokensArgs calldata args_\\n    ) external returns (uint256 outputAmount);\\n\\n    /**\\n     * @notice Read-only function used to query the bonding curve for buy pricing info.\\n     * @param numNfts The number of NFTs to buy out of the pair\\n     * @param swapData_ Extra data to pass to the curve\\n     * @return error any errors that would be throw if trying to buy that many NFTs\\n     * @return newBasePrice the new base price after the trade\\n     * @return newDelta the new delta after the trade\\n     * @return inputAmount the amount of token to send to the pool to purchase that many NFTs\\n     * @return nftCostData the cost data for each NFT purchased\\n     */\\n    function getBuyNftQuote(uint256 numNfts, bytes calldata swapData_)\\n        external\\n        view\\n        returns (\\n            CurveErrorCode error,\\n            uint256 newBasePrice,\\n            uint256 newDelta,\\n            uint256 inputAmount,\\n            NftCostData[] memory nftCostData\\n        );\\n\\n    /**\\n     * @notice Read-only function used to query the bonding curve for sell pricing info\\n     * @param numNfts The number of NFTs to sell into the pair\\n     * @param swapData_ Extra data to pass to the curve\\n     * @return error any errors that would be throw if trying to sell that many NFTs\\n     * @return newBasePrice the new base price after the trade\\n     * @return newDelta the new delta after the trade\\n     * @return outputAmount the amount of tokens the pool will send out for selling that many NFTs\\n     * @return nftCostData the cost data for each NFT sold\\n     */\\n    function getSellNftQuote(uint256 numNfts, bytes calldata swapData_)\\n        external\\n        view\\n        returns (\\n            CurveErrorCode error,\\n            uint256 newBasePrice,\\n            uint256 newDelta,\\n            uint256 outputAmount,\\n            NftCostData[] memory nftCostData\\n        );\\n\\n    // ***************************************************************\\n    // * ===================== VIEW FUNCTIONS ====================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice returns the status of whether this contract has been initialized\\n     * @dev see [ERC-1167](https://eips.ethereum.org/EIPS/eip-1167) factory clone paradigm\\n     * and also `DittoPoolFactory.sol`\\n     *\\n     * @return initialized whether the contract has been initialized\\n     */\\n    function initialized() external view returns (bool);\\n\\n    /**\\n     * @notice returns which DittoPool Template this pool was created with.\\n     * @dev see [ERC-1167](https://eips.ethereum.org/EIPS/eip-1167) factory clone paradigm\\n     * @return template the address of the DittoPool template used to create this pool.\\n     */\\n    function template() external view returns (address);\\n\\n    /**\\n     * @notice Function to determine if a given DittoPool can support muliple LP providers or not.\\n     * @return isPrivatePool_ boolean value indicating if the pool is private or not\\n     */\\n    function isPrivatePool() external view returns (bool isPrivatePool_);\\n\\n    /**\\n     * @notice Returns the cumulative fee associated with trading with this pool as a 1e18 based percentage.\\n     * @return fee_ the total fee(s) associated with this pool, for display purposes.\\n     */\\n    function fee() external view returns (uint256 fee_);\\n\\n    /**\\n     * @notice Returns the protocol fee associated with trading with this pool as a 1e18 based percentage.\\n     * @return feeProtocol_ the protocol fee associated with trading with this pool\\n     */\\n    function protocolFee() external view returns (uint256 feeProtocol_);\\n\\n    /**\\n     * @notice Returns the admin fee given to the pool admin as a 1e18 based percentage.\\n     * @return adminFee_ the fee associated with trading with any pair of this pool\\n     */\\n    function adminFee() external view returns (uint96 adminFee_);\\n\\n    /**\\n     * @notice Returns the fee given to liquidity providers for trading with this pool.\\n     * @return lpFee_ the fee associated with trading with a particular pair of this pool.\\n     */\\n    function lpFee() external view returns (uint96 lpFee_);\\n\\n    /**\\n     * @notice Returns the delta parameter for the bonding curve associated this pool\\n     * Each bonding curve uses delta differently, but in general it is used as an input\\n     *   to determine the next price on the bonding curve.\\n     * @return delta_ The delta parameter for the bonding curve of this pool\\n     */\\n    function delta() external view returns (uint128 delta_);\\n\\n    /**\\n     * @notice Returns the base price to sell the next NFT into this pool, base+delta to buy\\n     * Each bonding curve uses base price differently, but in general it is used as the current price of the pool.\\n     * @return basePrice_ this pool's current base price\\n     */\\n    function basePrice() external view returns (uint128 basePrice_);\\n\\n    /**\\n     * @notice Returns the factory that created this pool.\\n     * @return dittoPoolFactory the ditto pool factory for the contract\\n     */\\n    function dittoPoolFactory() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address that recieves admin fees from trades with this pool\\n     * @return adminFeeRecipient The admin fee recipient of this pool\\n     */\\n    function adminFeeRecipient() external view returns (address);\\n\\n    /**\\n     * @notice Returns the NFT collection that represents liquidity positions in this pool\\n     * @return lpNft The LP Position NFT collection for this pool\\n     */\\n    function getLpNft() external view returns (address);\\n\\n    /**\\n     * @notice Returns the nft collection that this pool trades \\n     * @return nft_ the address of the underlying nft collection contract\\n     */\\n    function nft() external view returns (IERC721 nft_);\\n\\n    /**\\n     * @notice Returns the address of the ERC20 token that this pool is trading NFTs against.\\n     * @return token_ The address of the ERC20 token that this pool is trading NFTs against.\\n     */\\n    function token() external view returns (address token_);\\n\\n    /**\\n     * @notice Returns the permitter contract that allows or denies specific NFT tokenIds to be traded in this pool\\n     * @dev if this address is zero, then all NFTs from the underlying collection are allowed to be traded in this pool\\n     * @return permitter the address of this pool's permitter contract, or zero if no permitter is set\\n     */\\n    function permitter() external view returns (IPermitter);\\n\\n    /**\\n     * @notice Returns how many ERC20 tokens a liquidity provider has in the pool\\n     * @dev this function mimics mappings: an invalid lpId_ will return 0 rather than throwing for being invalid\\n     * @param lpId_ LP Position NFT token ID to query for\\n     * @return lpTokenBalance the amount of ERC20 tokens the liquidity provider has in the pool\\n     */\\n    function getTokenBalanceForLpId(uint256 lpId_) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the full list of NFT tokenIds that are owned by a specific liquidity provider in this pool\\n     * @dev This function is not gas efficient and not-meant to be used on chain, only as a convenience for off-chain.\\n     * @dev worst-case is O(n) over the length of all the NFTs owned by the pool\\n     * @param lpId_ an LP position NFT token Id for a user providing liquidity to this pool\\n     * @return nftIds the list of NFT tokenIds in this pool that are owned by the specific liquidity provider\\n     */\\n    function getNftIdsForLpId(uint256 lpId_) external view returns (uint256[] memory nftIds);\\n\\n    /**\\n     * @notice returns the number of NFTs owned by a specific liquidity provider in this pool\\n     * @param lpId_ a user providing liquidity to this pool for trading with\\n     * @return userNftCount the number of NFTs in this pool owned by the liquidity provider\\n     */\\n    function getNftCountForLpId(uint256 lpId_) external view returns (uint256);\\n\\n    /**\\n     * @notice returns the number of NFTs and number of ERC20s owned by a specific liquidity provider in this pool\\n     * pretty much equivalent to the user's liquidity position in non-nft form.\\n     * @dev this function mimics mappings: an invalid lpId_ will return (0,0) rather than throwing for being invalid\\n     * @param lpId_ a user providing liquidity to this pool for trading with\\n     * @return tokenBalance the amount of ERC20 tokens the liquidity provider has in the pool\\n     * @return nftBalance the number of NFTs in this pool owned by the liquidity provider\\n     */\\n    function getTotalBalanceForLpId(uint256 lpId_)\\n        external\\n        view\\n        returns (uint256 tokenBalance, uint256 nftBalance);\\n\\n    /**\\n     * @notice returns the Lp Position NFT token Id that owns a specific NFT token Id in this pool\\n     * @dev this function mimics mappings: an invalid NFT token Id will return 0 rather than throwing for being invalid\\n     * @param nftId_ an NFT token Id that is owned by a liquidity provider in this pool\\n     * @return lpId the Lp Position NFT token Id that owns the NFT token Id\\n     */\\n    function getLpIdForNftId(uint256 nftId_) external view returns (uint256);\\n\\n    /**\\n     * @notice returns the full list of all NFT tokenIds that are owned by this pool\\n     * @dev does not have to match what the underlying NFT contract balanceOf(dittoPool)\\n     * thinks is owned by this pool: this is only valid liquidity tradeable in this pool\\n     * NFTs can be lost by unsafe transferring them to a dittoPool\\n     * also this function is O(n) gas efficient, only really meant to be used off-chain\\n     * @return nftIds the list of all NFT Token Ids in this pool, across all liquidity positions\\n     */\\n    function getAllPoolHeldNftIds() external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Returns the number of NFTs owned by the pool\\n     * @return nftBalance_ The number of NFTs owned by the pool\\n     */\\n    function getPoolTotalNftBalance() external view returns (uint256);\\n\\n    /**\\n     * @notice returns the full list of all LP Position NFT tokenIds that represent liquidity in this pool\\n     * @return lpIds the list of all LP Position NFT Token Ids corresponding to liquidity in this pool\\n     */\\n    function getAllPoolLpIds() external view returns (uint256[] memory);\\n\\n    /**\\n     * @notice returns the full amount of all ERC20 tokens that the pool thinks it owns\\n     * @dev may not match the underlying ERC20 contract balanceOf() because of unsafe transfers\\n     * this is only accounting for valid liquidity tradeable in the pool\\n     * @dev this function is not gas efficient and almost certainly should never actually be used on chain\\n     * @return totalPoolTokenBalance the amount of ERC20 tokens the pool thinks it owns\\n     */\\n    function getPoolTotalTokenBalance() external view returns (uint256);\\n\\n    /**\\n     * @notice returns the enumerated list of all token balances for all LP positions in this pool\\n     * @dev this function is not gas efficient and almost certainly should never actually be used on chain\\n     * @return balances the list of all LP Position NFT Token Ids and the amount of ERC20 tokens they are apportioned in the pool\\n     */\\n    function getAllLpIdTokenBalances()\\n        external\\n        view\\n        returns (LpIdToTokenBalance[] memory balances);\\n\\n    /**\\n     * @notice function called on SafeTransferFrom of NFTs to this contract\\n     * @dev see [ERC-721](https://eips.ethereum.org/EIPS/eip-721) for details\\n     */\\n    function onERC721Received(address, address, uint256, bytes memory) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/pool/DittoPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\nimport { IDittoPool } from \\\"../interface/IDittoPool.sol\\\";\\n\\nimport { DittoPoolMain } from \\\"./DittoPoolMain.sol\\\";\\nimport { DittoPoolMarketMake } from \\\"./DittoPoolMarketMake.sol\\\";\\nimport { DittoPoolTrade } from \\\"./DittoPoolTrade.sol\\\";\\n\\n/**\\n * @title DittoPool\\n * @notice DittoPool AMM shared liquidity trading pools. See DittoPoolMain, MarketMake and Trade for implementation.\\n */\\nabstract contract DittoPool is IDittoPool, DittoPoolMain, DittoPoolMarketMake, DittoPoolTrade { }\\n\"\r\n    },\r\n    \"contracts/utils/CurveErrorCode.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nenum CurveErrorCode {\\n    OK, // No error\\n    INVALID_NUMITEMS, // The numItem value is 0 or too large\\n    BASE_PRICE_OVERFLOW, // The updated base price doesn't fit into 128 bits\\n    SELL_NOT_SUPPORTED, // The pool doesn't support sell\\n    BUY_NOT_SUPPORTED, // The pool doesn't support buy\\n    MISSING_SWAP_DATA, // No swap data provided for a pool that requires it\\n    NOOP // No operation was performed\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/FixedPointMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\nlibrary FixedPointMathLib {\\n    /*///////////////////////////////////////////////////////////////\\n                            COMMON BASE UNITS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant YAD = 1e8;\\n    uint256 internal constant WAD = 1e18;\\n    uint256 internal constant RAY = 1e27;\\n    uint256 internal constant RAD = 1e45;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function fmul(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(x == 0 || (x * y) / x == y)\\n            if iszero(or(iszero(x), eq(div(z, x), y))) {\\n                revert(0, 0)\\n            }\\n\\n            // If baseUnit is zero this will return zero instead of reverting.\\n            z := div(z, baseUnit)\\n        }\\n    }\\n\\n    function fdiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * baseUnit in z for now.\\n            z := mul(x, baseUnit)\\n\\n            // Equivalent to require(y != 0 && (x == 0 || (x * baseUnit) / x == baseUnit))\\n            if iszero(and(iszero(iszero(y)), or(iszero(x), eq(div(z, x), baseUnit)))) {\\n                revert(0, 0)\\n            }\\n\\n            // We ensure y is not zero above, so there is never division by zero here.\\n            z := div(z, y)\\n        }\\n    }\\n\\n    function fpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := baseUnit\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store baseUnit in z for now.\\n                    z := baseUnit\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, baseUnit)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, baseUnit)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, baseUnit)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            // Start off with z at 1.\\n            z := 1\\n\\n            // Used below to help find a nearby power of 2.\\n            let y := x\\n\\n            // Find the lowest power of 2 that is at least sqrt(x).\\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n                y := shr(128, y) // Like dividing by 2 ** 128.\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x10000000000000000)) {\\n                y := shr(64, y) // Like dividing by 2 ** 64.\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x100000000)) {\\n                y := shr(32, y) // Like dividing by 2 ** 32.\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x10000)) {\\n                y := shr(16, y) // Like dividing by 2 ** 16.\\n                z := shl(8, z)\\n            }\\n            if iszero(lt(y, 0x100)) {\\n                y := shr(8, y) // Like dividing by 2 ** 8.\\n                z := shl(4, z)\\n            }\\n            if iszero(lt(y, 0x10)) {\\n                y := shr(4, y) // Like dividing by 2 ** 4.\\n                z := shl(2, z)\\n            }\\n            if iszero(lt(y, 0x8)) {\\n                // Equivalent to 2 ** z.\\n                z := shl(1, z)\\n            }\\n\\n            // Shifting right by 1 is like dividing by 2.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // Compute a rounded down version of z.\\n            let zRoundDown := div(x, z)\\n\\n            // If zRoundDown is smaller, use it.\\n            if lt(zRoundDown, z) {\\n                z := zRoundDown\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/upshot-oracle/contracts/IUpshotOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\n// ***************************************************************\\n// * ========================= STRUCTS ========================= *\\n// ***************************************************************\\nstruct PriceData { \\n    bytes signature;\\n    uint256 nonce;\\n    address nft; \\n    uint96 timestamp;\\n    address token; \\n    uint96 expiration;\\n    uint256 nftId;\\n    uint256 price; \\n    bytes extraData;\\n}\\n\\n/**\\n * @title Upshot Oracle Interface\\n */\\ninterface IUpshotOracle {\\n    // ***************************************************************\\n    // * ========================= EVENTS ========================== *\\n    // ***************************************************************\\n    event UpshotOracleAdminSetAuthenticator(address authenticator);\\n\\n    // ***************************************************************\\n    // * ========================= ERRORS ========================== *\\n    // ***************************************************************\\n    error UpshotOracleInvalidPriceTime();\\n    error UpshotOracleInvalidSigner();\\n\\n    // ***************************************************************\\n    // * ========================== VIEW =========================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice Get the address of the authenticator\\n     */\\n    function authenticator() external view returns (address);\\n\\n    /**\\n     * @notice Decode the token prices from the encoded upshot price data\\n     */\\n    function decodeTokenPrices(\\n        PriceData[] calldata priceData\\n    ) external returns (uint256[] memory tokenPrices);\\n}\\n\"\r\n    },\r\n    \"contracts/pool/DittoPoolTrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\nimport { CurveErrorCode } from \\\"../utils/CurveErrorCode.sol\\\";\\n\\nimport { EnumerableSet } from\\n    \\\"../../lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport { EnumerableMap } from\\n    \\\"../../lib/openzeppelin-contracts/contracts/utils/structs/EnumerableMap.sol\\\";\\nimport { SafeTransferLib } from \\\"../../lib/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport { ERC20 } from \\\"../../lib/solmate/src/tokens/ERC20.sol\\\";\\n\\nimport { Fee } from \\\"../struct/Fee.sol\\\";\\nimport { SwapNftsForTokensArgs, SwapTokensForNftsArgs } from \\\"../struct/SwapArgs.sol\\\";\\nimport { NftCostData } from \\\"../struct/NftCostData.sol\\\";\\nimport { IDittoPool } from \\\"../interface/IDittoPool.sol\\\";\\nimport { IDittoRouter } from \\\"../interface/IDittoRouter.sol\\\";\\nimport { DittoPoolMain } from \\\"./DittoPoolMain.sol\\\";\\n\\n\\n/**\\n * @title DittoPool\\n * @notice Parent contract defines common functions for DittoPool AMM shared liquidity trading pools.\\n */\\nabstract contract DittoPoolTrade is DittoPoolMain {\\n    using SafeTransferLib for ERC20;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using EnumerableMap for EnumerableMap.UintToUintMap;\\n\\n    // ***************************************************************\\n    // * ========================= EVENTS ========================== *\\n    // ***************************************************************\\n\\n    event DittoPoolTradeSwappedTokensForNfts(\\n        address caller,\\n        SwapTokensForNftsArgs args,\\n        uint128 newBasePrice,\\n        uint128 newDelta\\n    );\\n    event DittoPoolTradeSwappedTokensForNft(\\n        uint256 sellerLpId,\\n        uint256 nftId,\\n        uint256 price,\\n        Fee fee\\n    );\\n\\n    event DittoPoolTradeSwappedNftsForTokens(\\n        address caller,\\n        SwapNftsForTokensArgs args,\\n        uint128 newBasePrice,\\n        uint128 newDelta\\n    );\\n    event DittoPoolTradeSwappedNftForTokens(\\n        uint256 buyerLpId,\\n        uint256 nftId,\\n        uint256 price,\\n        Fee fee\\n    );\\n\\n    // ***************************************************************\\n    // * ========================= ERRORS ========================== *\\n    // ***************************************************************\\n\\n    error DittoPoolTradeBondingCurveError(CurveErrorCode error);\\n    error DittoPoolTradeNoNftsProvided();\\n    error DittoPoolTradeNftAndLpIdsMustBeSameLength();\\n    error DittoPoolTradeInvalidTokenRecipient();\\n    error DittoPoolTradeInsufficientBalanceToBuyNft();\\n    error DittoPoolTradeInsufficientBalanceToPayFees();\\n    error DittoPoolTradeInTooManyTokens();\\n    error DittoPoolTradeOutTooFewTokens();\\n    error DittoPoolTradeNftNotOwnedByPool(uint256 nftId);\\n    error DittoPoolTradeInvalidTokenSender();\\n    error DittoPoolTradeNftIdDoesNotMatchSwapData();\\n    error DittoPoolTradeNftAndCostDataLengthMismatch();\\n\\n    // ***************************************************************\\n    // * =========== FUNCTIONS TO TRADE WITH THE POOL ============== *\\n    // ***************************************************************\\n\\n    ///@inheritdoc IDittoPool\\n    function swapTokensForNfts(\\n        SwapTokensForNftsArgs calldata args_\\n    ) external nonReentrant returns (uint256 inputAmount) {\\n        uint256 countNfts = args_.nftIds.length;\\n\\n        // STEP 1: Input validation\\n        if (countNfts == 0) {\\n            revert DittoPoolTradeNoNftsProvided();\\n        }\\n\\n        // STEP 2: Get price information from bonding curve\\n        NftCostData[] memory nftCostData;\\n        uint128 newBasePrice;\\n        uint128 newDelta;\\n        (inputAmount, nftCostData, newBasePrice, newDelta) =\\n            _calculateBuyInfoAndUpdatePoolParams(countNfts, args_.swapData, args_.maxExpectedTokenInput);\\n        \\n        _checkNftIdsMatch(args_.nftIds, nftCostData);\\n        \\n        // STEP 3: Take in tokens for sellers (doesn't include fees)\\n        if (_dittoPoolFactory.isWhitelistedRouter(msg.sender)) {\\n            IDittoRouter(msg.sender).poolTransferErc20From(\\n                _token, args_.tokenSender, address(this), inputAmount\\n            );\\n        } else {\\n            if (args_.tokenSender != msg.sender){\\n                revert DittoPoolTradeInvalidTokenSender();\\n            }\\n            _token.transferFrom(args_.tokenSender, address(this), inputAmount);\\n        }\\n\\n        // STEP 4: Transfer nfts to buyer and adjust nft balance of seller accounts\\n        uint256[] memory sellersLpIds = _sendNftsToBuyer(args_.nftRecipient, args_.nftIds);\\n\\n        // STEP 5: Increase the token balance of the positions selling the nfts\\n        _increaseTokenBalanceOfSellers(nftCostData, sellersLpIds, args_.nftIds);\\n\\n        // STEP 6: Pay protocol and admin fees\\n        _payProtocolAndAdminFees(nftCostData);\\n\\n        emit DittoPoolTradeSwappedTokensForNfts(msg.sender, args_, newBasePrice, newDelta);\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function swapNftsForTokens(\\n        SwapNftsForTokensArgs calldata args_\\n    ) external nonReentrant returns (uint256 outputAmount) {\\n        uint256 countNfts = args_.nftIds.length;\\n        bool isWhitelistedRouter = _dittoPoolFactory.isWhitelistedRouter(msg.sender);\\n\\n        // STEP 1: Input validation\\n        if (countNfts == 0) {\\n            revert DittoPoolTradeNoNftsProvided();\\n        }\\n        if (countNfts != args_.lpIds.length) {\\n            revert DittoPoolTradeNftAndLpIdsMustBeSameLength();\\n        }\\n        if (args_.tokenRecipient == address(0)) {\\n            revert DittoPoolTradeInvalidTokenRecipient();\\n        }\\n        if(!isWhitelistedRouter && args_.nftSender != msg.sender){\\n            revert DittoPoolTradeInvalidTokenSender();\\n        }\\n\\n        _checkPermittedTokens(args_.nftIds, args_.permitterData);\\n\\n        // STEP 2: Get price information from bonding curve\\n        NftCostData[] memory nftCostData;\\n        uint128 newBasePrice;\\n        uint128 newDelta;\\n        (outputAmount, nftCostData, newBasePrice, newDelta) =\\n            _calculateSellInfoAndUpdatePoolParams(countNfts, args_.swapData, args_.minExpectedTokenOutput);\\n\\n        _checkNftIdsMatch(args_.nftIds, nftCostData);\\n\\n        // STEP 3: Charge the buyers for the Nfts by reducing their token balance\\n        _decreaseTokenBalanceOfBuyers(nftCostData, args_.nftIds, args_.lpIds);\\n\\n        // STEP 4: Transfer Nfts from seller to buyer accounts\\n        _takeSpecificNftsFromSeller(isWhitelistedRouter, args_.nftSender, args_.nftIds, args_.lpIds);\\n\\n        // STEP 5: Transfer the token proceeds to the seller and pay fees\\n        _token.safeTransfer(args_.tokenRecipient, outputAmount);\\n\\n        // STEP 6: Pay protocol and admin fees\\n        _payProtocolAndAdminFees(nftCostData);\\n\\n        emit DittoPoolTradeSwappedNftsForTokens(msg.sender, args_, newBasePrice, newDelta);\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function getBuyNftQuote(uint256 numNfts_, bytes calldata swapData_)\\n        external\\n        view\\n        virtual\\n        returns (\\n            CurveErrorCode error,\\n            uint256 newBasePrice,\\n            uint256 newDelta,\\n            uint256 inputAmount,\\n            NftCostData[] memory nftCostData\\n        );\\n\\n    ///@inheritdoc IDittoPool\\n    function getSellNftQuote(uint256 numNfts_, bytes calldata swapData_)\\n        external\\n        view\\n        virtual\\n        returns (\\n            CurveErrorCode error,\\n            uint256 newBasePrice,\\n            uint256 newDelta,\\n            uint256 outputAmount,\\n            NftCostData[] memory nftCostData\\n        );\\n\\n    // ***************************************************************\\n    // * ============= INTERNAL HELPER FUNCTIONS =================== *\\n    // ***************************************************************\\n    /**\\n     * Check that the cost data matches the nft ids if that is important for the curve type \\n     *   giving the cost data\\n     * @param nftIds_ The nft ids\\n     * @param nftCostData_ The cost data that may or may not require specific nft ids\\n     */\\n    function _checkNftIdsMatch(\\n        uint256[] memory nftIds_, \\n        NftCostData[] memory nftCostData_\\n    ) internal pure {\\n        uint256 countNfts = nftIds_.length;\\n        if (countNfts != nftCostData_.length) {\\n            revert DittoPoolTradeNftAndCostDataLengthMismatch();\\n        }\\n        for (uint256 i = 0; i < countNfts;) {\\n            if (nftCostData_[i].specificNftId && nftIds_[i] != nftCostData_[i].nftId) {\\n                revert DittoPoolTradeNftIdDoesNotMatchSwapData();\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Pays protocol and admin fees to the appropriate recipients\\n     * \\n     * @param nftCostData_ the cost data including the fees\\n     */\\n    function _payProtocolAndAdminFees(NftCostData[] memory nftCostData_) internal {\\n        uint256 totalProtocolFee;\\n        uint256 totalAdminFee;\\n        uint256 numItems = nftCostData_.length;\\n\\n        for (uint256 i = 0; i < numItems;) {\\n            totalProtocolFee += nftCostData_[i].fee.protocol;\\n            totalAdminFee += nftCostData_[i].fee.admin;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n\\n        ERC20 token = _token;\\n        uint256 balance = token.balanceOf(address(this));\\n        if (balance < totalProtocolFee + totalAdminFee) {\\n            revert DittoPoolTradeInsufficientBalanceToPayFees();\\n        }\\n        token.safeTransfer(_dittoPoolFactory.protocolFeeRecipient(), totalProtocolFee);\\n        token.safeTransfer(_adminFeeRecipient, totalAdminFee);\\n    }\\n\\n    /**\\n     * @notice In purchases of NFTs leaving the pool, increase token balance accounting of the NFT seller in the pool.\\n     * @param nftCostData array of NFT buy cost data\\n     * @param sellersLpIds_ list of addresses of NFT selling counterparties (LP providers within the pool) in this trade\\n     */\\n    function _increaseTokenBalanceOfSellers(\\n        NftCostData[] memory nftCostData,\\n        uint256[] memory sellersLpIds_,\\n        uint256[] memory nftIds_\\n    ) private {\\n        uint256 sellerLpId;\\n        uint256 sellerCurrentBalance;\\n        uint256 countSellerPositions = sellersLpIds_.length;\\n\\n        for (uint256 i = 0; i < countSellerPositions;) {\\n            sellerLpId = sellersLpIds_[i];\\n            (, sellerCurrentBalance) = _lpIdToTokenBalance.tryGet(sellerLpId);\\n            _lpIdToTokenBalance.set(\\n                sellerLpId, \\n                sellerCurrentBalance + nftCostData[i].price + nftCostData[i].fee.lp\\n            );\\n\\n            emit DittoPoolTradeSwappedTokensForNft(\\n                sellerLpId,\\n                nftIds_[i],\\n                nftCostData[i].price,\\n                nftCostData[i].fee\\n            );\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice In sales of NFTs into the pool for tokens, decrease the NFT seller's tokens balance accounting in the pool.\\n     * @dev this function throws if the liquidity provider does not have enough tokens to buy the NFTs\\n     * @param nftCostData_ array of NFT sell cost data\\n     * @param buyerLpIds_ the NFT buying counterparties, LP providers within the pool's Lp Position Token Ids\\n     */\\n    function _decreaseTokenBalanceOfBuyers(\\n        NftCostData[] memory nftCostData_,\\n        uint256[] memory nftIds_,\\n        uint256[] memory buyerLpIds_\\n    ) private {\\n        uint256 buyerLpId;\\n        uint256 buyerCurrentBalance;\\n        uint256 countBuyerPositions = buyerLpIds_.length;\\n        uint256 sellPriceIgnoreLpFee;\\n        for (uint256 i = 0; i < countBuyerPositions;) {\\n            buyerLpId = buyerLpIds_[i];\\n            sellPriceIgnoreLpFee = nftCostData_[i].price - nftCostData_[i].fee.lp;\\n            buyerCurrentBalance = _lpIdToTokenBalance.get(buyerLpId);\\n            if (buyerCurrentBalance < sellPriceIgnoreLpFee) {\\n                revert DittoPoolTradeInsufficientBalanceToBuyNft();\\n            }\\n\\n            emit DittoPoolTradeSwappedNftForTokens(\\n                buyerLpId,\\n                nftIds_[i],\\n                nftCostData_[i].price,\\n                nftCostData_[i].fee\\n            );\\n\\n            unchecked {\\n                _lpIdToTokenBalance.set(buyerLpId, buyerCurrentBalance - sellPriceIgnoreLpFee);\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Updates LP position NFT metadata on trades, as LP's LP information changes due to the trade\\n     * @dev see [EIP-4906](https://eips.ethereum.org/EIPS/eip-4906) EIP-721 Metadata Update Extension\\n     * @param lpId_ LP position NFT token id whose metadata needs updating\\n     */\\n    function _updateLpNftMetadataOnTrade(uint256 lpId_) internal {\\n        _lpNft.emitMetadataUpdate(lpId_);\\n    }\\n\\n    /**\\n     * @notice In a purchase of NFTs leaving the pool (`swapTokenForNfts`), sends NFTs to buyer, and\\n     * updates the pool's internal accounting of NFTs in the pool\\n     * @param nftRecipient_ the address to send the NFTs to\\n     * @param nftIds_ the list of specific NFT token Ids being purchased out of the pool in this transaction\\n     * @return sellersLpIds position ids of the lp positions selling within the pool\\n     */\\n    function _sendNftsToBuyer(\\n        address nftRecipient_,\\n        uint256[] calldata nftIds_\\n    ) internal returns (uint256[] memory sellersLpIds) {\\n        uint256 countNftIds = nftIds_.length;\\n\\n        uint256 nftId;\\n        sellersLpIds = new uint256[](countNftIds);\\n\\n        for (uint256 i = 0; i < countNftIds;) {\\n            nftId = nftIds_[i];\\n\\n            if (_poolOwnedNftIds.contains(nftId) == false) {\\n                revert DittoPoolTradeNftNotOwnedByPool(nftId);\\n            }\\n\\n            _nft.safeTransferFrom(address(this), nftRecipient_, nftId);\\n\\n            _poolOwnedNftIds.remove(nftId);\\n            uint256 prevOwnerLpId = _nftIdToLpId[nftId];\\n            delete _nftIdToLpId[nftId];\\n            _lpIdToNftBalance[prevOwnerLpId]--;\\n\\n            _updateLpNftMetadataOnTrade(prevOwnerLpId);\\n            sellersLpIds[i] = prevOwnerLpId;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice In a sale of NFTs into the pool, transfers the NFTs from the seller to the pool, and\\n     * updates the pool's internal accounting of NFTs in the pool\\n     * @dev Sends NFTs to recipients\\n     * @dev This adds the ids to to the global id set and increments the nft count for each buyer.\\n     * @param from_ the address to take the NFTs from, only used if msg.sender is an approved IDittoRouter\\n     * @param nftIds_ the list of specific NFT token Ids being purchased into the pool in this transaction\\n     * @param buyerLpIds_ the list of addresses of NFT buying counterparties (LP providers within the pool) buying NFTs in this trade\\n     */\\n    function _takeSpecificNftsFromSeller(\\n        bool isWhitelistedRouter_,\\n        address from_,\\n        uint256[] calldata nftIds_,\\n        uint256[] memory buyerLpIds_\\n    ) internal {\\n        uint256 countNftIds = nftIds_.length;\\n        uint256 nftId;\\n        for (uint256 i = 0; i < countNftIds;) {\\n            nftId = nftIds_[i];\\n            if (isWhitelistedRouter_) {\\n                IDittoRouter(msg.sender).poolTransferNftFrom(_nft, from_, address(this), nftId);\\n            } else {\\n                _nft.transferFrom(msg.sender, address(this), nftId);\\n            }\\n            _poolOwnedNftIds.add(nftId);\\n            _nftIdToLpId[nftId] = buyerLpIds_[i];\\n            _lpIdToNftBalance[buyerLpIds_[i]]++;\\n\\n            _updateLpNftMetadataOnTrade(buyerLpIds_[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice In purchase of NFTs out of the pool, call bonding curve to find out how much erc20 is required, and\\n     * update new prices for the next NFT in the pool after this trade completes\\n     * @param numNFTs_ the number of NFTs being purchased\\n     * @param swapData_ extra data to be passed to the curve\\n     * @param maxExpectedTokenInput_ the maximum amount of tokens the user is willing to pay for the NFTs\\n     * @return inputAmount the amount of tokens the user needs to send to pay for the NFTsgetProtocolFee\\n     * @return nftCostData the data returned from the bonding curve\\n     */\\n    function _calculateBuyInfoAndUpdatePoolParams(\\n        uint256 numNFTs_,\\n        bytes calldata swapData_,\\n        uint256 maxExpectedTokenInput_\\n    ) internal returns (\\n        uint256 inputAmount, \\n        NftCostData[] memory nftCostData,\\n        uint128 newBasePrice,\\n        uint128 newDelta\\n    ) {\\n        CurveErrorCode error;\\n        // Save on 2 SLOADs by caching\\n        uint128 currentBasePrice = _basePrice;\\n        uint128 currentDelta = _delta;\\n        (error, newBasePrice, newDelta, inputAmount, nftCostData) = _getBuyInfo(\\n            currentBasePrice,\\n            currentDelta,\\n            numNFTs_,\\n            swapData_,\\n            Fee({lp: _feeLp, admin: _feeAdmin, protocol: _dittoPoolFactory.getProtocolFee()})\\n        );\\n\\n        // Revert if bonding curve had an error\\n        if (error != CurveErrorCode.OK) {\\n            revert DittoPoolTradeBondingCurveError(error);\\n        }\\n\\n        // Revert if input is more than expected\\n        if (inputAmount > maxExpectedTokenInput_) {\\n            revert DittoPoolTradeInTooManyTokens();\\n        }\\n\\n        if (currentBasePrice != newBasePrice) {\\n            _changeBasePrice(newBasePrice);\\n        }\\n\\n        if (currentDelta != newDelta) {\\n            _changeDelta(newDelta);\\n        }\\n    }\\n\\n    /**\\n     * @notice In sales of NFTs into the pool, call bonding curve to find out\\n     *   how much money the seller will receive, and update new prices for the\\n     *   next NFT in the pool after this trade completes\\n     * @param numNFTs_ the number of NFTs being purchased\\n     * @param swapData_ extra data to be passed to the curve\\n     * @param minExpectedTokenOutput_ minimium amount of ERC20 msg.sender is willing\\n     *   to recieve for the sale of their NFTs\\n     * @return outputAmount the amount of tokens the msg.sender will recieve\\n     *   from the sale of their NFTs into the pool\\n     * @return nftCostData the data returned from the bonding curve\\n     */\\n    function _calculateSellInfoAndUpdatePoolParams(\\n        uint256 numNFTs_,\\n        bytes calldata swapData_,\\n        uint256 minExpectedTokenOutput_\\n    ) internal returns (\\n        uint256 outputAmount, \\n        NftCostData[] memory nftCostData,\\n        uint128 newBasePrice,\\n        uint128 newDelta\\n    ) {\\n        // Save on 2 SLOADs by caching\\n        uint128 currentBasePrice = _basePrice;\\n        uint128 currentDelta = _delta;\\n\\n        CurveErrorCode error;\\n        (error, newBasePrice, newDelta, outputAmount, nftCostData) =\\n            _getSellInfo(\\n                currentBasePrice,\\n                currentDelta,\\n                numNFTs_,\\n                swapData_,\\n                Fee({lp: _feeLp, admin: _feeAdmin, protocol: _dittoPoolFactory.getProtocolFee()})\\n            );\\n\\n        // Revert if bonding curve had an error\\n        if (error != CurveErrorCode.OK) {\\n            revert DittoPoolTradeBondingCurveError(error);\\n        }\\n\\n        // Revert if output is too little\\n        if (outputAmount < minExpectedTokenOutput_) {\\n            revert DittoPoolTradeOutTooFewTokens();\\n        }\\n\\n        if (currentBasePrice != newBasePrice) {\\n            _changeBasePrice(newBasePrice);\\n        }\\n\\n        if (currentDelta != newDelta) {\\n            _changeDelta(newDelta);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculate the total fees and price per NFT for a uniform trade, meaning all nfts \\n     *   involved in the trade have the same price\\n     * \\n     * @param totalCost_ The total cost across all nfts in the trade\\n     * @param numItems_ The number of nfts in the trade. Assumed not to be zero\\n     * @param feeRates_ The fees to be applied to the trade\\n     * @return totalFees_ The total fees to be paid for the trade\\n     * @return nftCostData_ The price and fees per nft in the trade\\n     */\\n    function _calculateUniformNftCostData(\\n        uint256 totalCost_,\\n        uint256 numItems_,\\n        Fee memory feeRates_\\n    ) internal pure returns (\\n        uint256 totalFees_,\\n        NftCostData[] memory nftCostData_\\n    ) {\\n        uint256 pricePerNft = totalCost_ / numItems_;\\n\\n        Fee memory calculatedFees = Fee({\\n            protocol: _mul(totalCost_, feeRates_.protocol),\\n            admin: _mul(totalCost_, feeRates_.admin),\\n            lp: _mul(totalCost_, feeRates_.lp)\\n        });\\n\\n        totalFees_ = calculatedFees.protocol + calculatedFees.admin + calculatedFees.lp;\\n\\n        Fee memory calculatedFeesPerNft = Fee({\\n            protocol: calculatedFees.protocol / numItems_,\\n            admin: calculatedFees.admin / numItems_,\\n            lp: calculatedFees.lp / numItems_\\n        });\\n\\n        nftCostData_ = new NftCostData[](numItems_);\\n\\n        for (uint256 i = 0; i < numItems_;) {\\n            nftCostData_[i].price = pricePerNft;\\n            nftCostData_[i].fee = calculatedFeesPerNft;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    // ***********************************************************************\\n    // * ============= INTERNAL HELPER FUNCTIONS (Curve) =================== *\\n    // ***********************************************************************\\n\\n    /**\\n     * @notice Given the current state of the pair and the trade, computes how much the user\\n     * should pay to purchase an NFT from the pair, the new base price, and other values.\\n     * @param basePrice_ The current selling base price of the pair, in tokens\\n     * @param delta_ The delta parameter of the pair, what it means depends on the curve\\n     * @param numItems_ The number of NFTs the user is buying from the pair\\n     * @param fee_ The fee Lp, Admin, and Protocol fee multipliers\\n     * @return error Any math calculation errors, only Error.OK means the returned values are valid\\n     * @return newBasePrice The updated selling base price, in tokens\\n     * @return newDelta The updated delta, used to parameterize the bonding curve\\n     * @return inputValue The amount that the user should pay, in tokens\\n     * @return nftCostData The fees and buyPriceAndLpFeePerNft for each NFT being purchased\\n     */\\n    function _getBuyInfo(\\n        uint128 basePrice_,\\n        uint128 delta_,\\n        uint256 numItems_,\\n        bytes calldata swapData_,\\n        Fee memory fee_\\n    )\\n        internal\\n        virtual\\n        returns (\\n            CurveErrorCode error,\\n            uint128 newBasePrice,\\n            uint128 newDelta,\\n            uint256 inputValue,\\n            NftCostData[] memory nftCostData\\n        );\\n\\n    /**\\n     * @notice Given the current state of the pair and the trade, computes how much the user\\n     * should receive when selling NFTs to the pair, the new base price, and other values.\\n     * @param basePrice_ The current selling base price of the pair, in tokens\\n     * @param delta_ The delta parameter of the pair, what it means depends on the curve\\n     * @param numItems_ The number of NFTs the user is selling to the pair\\n     * @param fee_ The Lp, Admin, and Protocol fees multipliers\\n     * @return error Any math calculation errors, only Error.OK means the returned values are valid\\n     * @return newBasePrice The updated selling base price, in tokens\\n     * @return newDelta The updated delta, used to parameterize the bonding curve\\n     * @return outputValue The amount that the user should receive, in tokens\\n     * @return nftCostData The fees and sellPricePerNftWithoutFees for each NFT being sold\\n     */\\n    function _getSellInfo(\\n        uint128 basePrice_,\\n        uint128 delta_,\\n        uint256 numItems_,\\n        bytes calldata swapData_,\\n        Fee memory fee_\\n    )\\n        internal\\n        virtual\\n        returns (\\n            CurveErrorCode error,\\n            uint128 newBasePrice,\\n            uint128 newDelta,\\n            uint256 outputValue,\\n            NftCostData[] memory nftCostData\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/struct/SwapArgs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @param nftIds The list of IDs of the NFTs to purchase\\n * @param maxExpectedTokenInput The maximum acceptable cost from the sender (in wei or base units of ERC20).\\n *   If the actual amount is greater than this value, the transaction will be reverted.\\n * @param tokenSender ERC20 sender. Only used if msg.sender is an approved IDittoRouter, else msg.sender is used.\\n * @param nftRecipient Address to send the purchased NFTs to.\\n */\\nstruct SwapTokensForNftsArgs {\\n    uint256[] nftIds;\\n    uint256 maxExpectedTokenInput;\\n    address tokenSender;\\n    address nftRecipient;\\n    bytes swapData;\\n}\\n\\n/**\\n * @param nftIds The list of IDs of the NFTs to sell to the pair\\n * @param lpIds The list of IDs of the LP positions sell the NFTs to\\n * @param minExpectedTokenOutput The minimum acceptable token count received by the sender. \\n *   If the actual amount is less than this value, the transaction will be reverted.\\n * @param nftSender NFT sender. Only used if msg.sender is an approved IDittoRouter, else msg.sender is used.\\n * @param tokenRecipient The recipient of the ERC20 proceeds.\\n * @param permitterData Data to profe that the NFT Token IDs are permitted to be sold to this pool if a permitter is set.\\n * @param swapData Extra data to pass to the curve\\n */\\nstruct SwapNftsForTokensArgs {\\n    uint256[] nftIds;\\n    uint256[] lpIds;\\n    uint256 minExpectedTokenOutput;\\n    address nftSender;\\n    address tokenRecipient;\\n    bytes permitterData;\\n    bytes swapData;\\n}\\n\\n\"\r\n    },\r\n    \"contracts/pool/lpNft/LpNft.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\nimport { ILpNft } from \\\"../../interface/ILpNft.sol\\\";\\nimport { IMetadataGenerator } from \\\"../../interface/IMetadataGenerator.sol\\\";\\nimport { MetadataGeneratorError } from \\\"../metadata/MetadataGeneratorError.sol\\\";\\nimport { IDittoPool } from \\\"../../interface/IDittoPool.sol\\\";\\nimport { IDittoPoolFactory } from \\\"../../interface/IDittoPoolFactory.sol\\\";\\nimport { OwnerTwoStep } from \\\"../../utils/OwnerTwoStep.sol\\\";\\n\\nimport { IERC721 } from \\\"../../../lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\\\";\\nimport { ERC721 } from \\\"../../../lib/solmate/src/tokens/ERC721.sol\\\";\\n\\n/**\\n * @title LpNft\\n * @notice LpNft is an ERC721 NFT collection that tokenizes market makers' liquidity positions in the Ditto protocol.\\n */\\ncontract LpNft is ILpNft, ERC721, OwnerTwoStep {\\n    IDittoPoolFactory internal _dittoPoolFactory;\\n\\n    ///@dev stores which pool each lpId corresponds to\\n    mapping(uint256 => IDittoPool) internal _lpIdToPool;\\n\\n    /// @dev dittoPool address is the key of the mapping, underlying NFT address traded by that pool is the value\\n    mapping(address => IERC721) internal _approvedDittoPoolToNft;\\n\\n    IMetadataGenerator internal _metadataGenerator;\\n\\n    ///@dev NFTs are minted sequentially, starting at tokenId 1\\n    uint96 internal _nextId = 1;\\n\\n    // ***************************************************************\\n    // * ========================= EVENTS ========================== *\\n    // ***************************************************************\\n\\n    event LpNftAdminUpdatedMetadataGenerator(address metadataGenerator);\\n    event LpNftAdminUpdatedDittoPoolFactory(address dittoPoolFactory);\\n\\n    // ***************************************************************\\n    // * ========================= ERRORS ========================== *\\n    // ***************************************************************\\n    error LpNftDittoFactoryOnly();\\n    error LpNftDittoPoolOnly();\\n\\n    // ***************************************************************\\n    // * ==================== ADMIN FUNCTIONS ====================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice Constructor. Records the DittoPoolFactory address. Sets the owner of this contract. \\n     *   Assigns the metadataGenerator address.\\n     */\\n    constructor(\\n        address initialOwner_,\\n        address metadataGenerator_\\n    ) ERC721(\\\"Ditto V1 LP Positions\\\", \\\"DITTO-V1-POS\\\") {\\n        _transferOwnership(initialOwner_);\\n        _metadataGenerator = IMetadataGenerator(metadataGenerator_);\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function setDittoPoolFactory(IDittoPoolFactory dittoPoolFactory_) external onlyOwner {\\n        _dittoPoolFactory = dittoPoolFactory_;\\n        emit LpNftAdminUpdatedDittoPoolFactory(address(dittoPoolFactory_));\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function setMetadataGenerator(IMetadataGenerator metadataGenerator_) external onlyOwner {\\n        _metadataGenerator = metadataGenerator_;\\n\\n        emit LpNftAdminUpdatedMetadataGenerator(address(metadataGenerator_));\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function setApprovedDittoPool(address dittoPool_, IERC721 nft_) external onlyDittoPoolFactory {\\n        _approvedDittoPoolToNft[dittoPool_] = nft_;\\n    }\\n\\n    // ***************************************************************\\n    // * =============== PROTECTED POOL FUNCTIONS ================== *\\n    // ***************************************************************\\n\\n    ///@inheritdoc ILpNft\\n    function mint(address to_) public onlyApprovedDittoPools returns (uint256 lpId) {\\n        lpId = _nextId;\\n\\n        _lpIdToPool[lpId] = IDittoPool(msg.sender);\\n\\n        _safeMint(to_, lpId);\\n        unchecked {\\n            ++_nextId;\\n        }\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function burn(uint256 lpId_) external onlyApprovedDittoPools {\\n        delete _lpIdToPool[lpId_];\\n\\n        _burn(lpId_);\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function emitMetadataUpdate(uint256 lpId_) external onlyApprovedDittoPools {\\n        emit MetadataUpdate(lpId_);\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function emitMetadataUpdateForAll() external onlyApprovedDittoPools {\\n        if (totalSupply > 0) {\\n            emit BatchMetadataUpdate(1, totalSupply);\\n        }\\n    }\\n\\n    // ***************************************************************\\n    // * ==================== AUTH MODIFIERS ======================= *\\n    // ***************************************************************\\n    /**\\n     * @notice Modifier that restricts access to the DittoPoolFactory contract \\n     *   that created this NFT collection.\\n     */\\n    modifier onlyDittoPoolFactory() {\\n        if (msg.sender != address(_dittoPoolFactory)) {\\n            revert LpNftDittoFactoryOnly();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @notice Modifier that restricts access to DittoPool contracts that have been \\n     *   approved to mint and burn liquidity position NFTs by the DittoPoolFactory.\\n     */\\n    modifier onlyApprovedDittoPools() {\\n        if (address(_approvedDittoPoolToNft[msg.sender]) == address(0)) {\\n            revert LpNftDittoPoolOnly();\\n        }\\n        _;\\n    }\\n\\n    // ***************************************************************\\n    // * ====================== VIEW FUNCTIONS ===================== *\\n    // ***************************************************************\\n\\n    ///@inheritdoc ILpNft\\n    function isApproved(address spender_, uint256 lpId_) external view returns (bool) {\\n        address ownerOf = ownerOf[lpId_];\\n        return (\\n            spender_ == ownerOf || isApprovedForAll[ownerOf][spender_]\\n                || spender_ == getApproved[lpId_]\\n        );\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function isApprovedDittoPool(address pool_) external view returns (bool) {\\n        return address(_approvedDittoPoolToNft[pool_]) != address(0);\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function getPoolForLpId(uint256 lpId_) external view returns (IDittoPool) {\\n        return _lpIdToPool[lpId_];\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function getPoolAndOwnerForLpId(uint256 lpId_)\\n        external\\n        view\\n        returns (IDittoPool pool, address owner)\\n    {\\n        pool = _lpIdToPool[lpId_];\\n        owner = ownerOf[lpId_];\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function getNftForLpId(uint256 lpId_) external view returns (IERC721) {\\n        return _approvedDittoPoolToNft[address(_lpIdToPool[lpId_])];\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function getLpValueToken(uint256 lpId_) public view returns (uint256) {\\n        return _lpIdToPool[lpId_].getTokenBalanceForLpId(lpId_);\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function getAllHeldNftIds(uint256 lpId_) external view returns (uint256[] memory) {\\n        return _lpIdToPool[lpId_].getNftIdsForLpId(lpId_);\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function getNumNftsHeld(uint256 lpId_) public view returns (uint256) {\\n        return _lpIdToPool[lpId_].getNftCountForLpId(lpId_);\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function getLpValueNft(uint256 lpId_) public view returns (uint256) {\\n        return getNumNftsHeld(lpId_) * _lpIdToPool[lpId_].basePrice();\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function getLpValue(uint256 lpId_) external view returns (uint256) {\\n        return getLpValueToken(lpId_) + getLpValueNft(lpId_);\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function dittoPoolFactory() external view returns (IDittoPoolFactory) {\\n        return _dittoPoolFactory;\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function nextId() external view returns (uint256) {\\n        return _nextId;\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function metadataGenerator() external view returns (IMetadataGenerator) {\\n        return _metadataGenerator;\\n    }\\n\\n    // ***************************************************************\\n    // * ================== ERC721 INTERFACE ======================= *\\n    // ***************************************************************\\n\\n    /**\\n     *  @notice returns storefront-level metadata to be viewed on marketplaces.\\n     */\\n    function contractURI() external view returns (string memory) {\\n        return _metadataGenerator.payloadContractUri();\\n    }\\n\\n    /**\\n     * @notice returns the metadata for a given token, to be viewed on marketplaces and off-chain\\n     * @dev see [EIP-721](https://eips.ethereum.org/EIPS/eip-721) EIP-721 Metadata Extension\\n     * @param lpId_ the tokenId of the NFT to get metadata for\\n     */\\n    function tokenURI(uint256 lpId_) public view override returns (string memory) {\\n        IDittoPool pool = IDittoPool(_lpIdToPool[lpId_]);\\n        uint256 tokenCount = getLpValueToken(lpId_);\\n        uint256 nftCount = getNumNftsHeld(lpId_);\\n        try _metadataGenerator.payloadTokenUri(lpId_, pool, tokenCount, nftCount) returns (string memory tokenUri) {\\n            return tokenUri;\\n        } catch (bytes memory reason) {\\n            return MetadataGeneratorError.errorTokenUri(lpId_, address(pool), tokenCount, nftCount, reason);\\n        }\\n    }\\n\\n    /**\\n     * @notice Whether or not this contract supports the given interface. \\n     *   See [EIP-165](https://eips.ethereum.org/EIPS/eip-165)\\n     */\\n    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\\n        return interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165\\n            || interfaceId == 0x80ac58cd // ERC165 Interface ID for ERC721\\n            || interfaceId == 0x49064906 // ERC165 Interface ID for ERC4906\\n            || interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/struct/FactoryTemplates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\n/**\\n * @notice A struct for creating a DittoSwap pool.\\n */\\nstruct PoolTemplate {\\n    bool isPrivatePool; // whether the pool is private or not\\n    uint256 templateIndex; // which DittoSwap template to use. Must be less than the number of available templates\\n    address token; // ERC20 token address\\n    address nft; // the address of the NFT collection that we are creating a pool for\\n    uint96 feeLp; // set by owner, paid to LPers only when they are the counterparty in a trade\\n    address owner; // owner creating the pool\\n    uint96 feeAdmin; // set by owner, paid to admin fee recipient\\n    uint128 delta; // the delta of the pool, see bonding curve documentation\\n    uint128 basePrice; // the base price of the pool, see bonding curve documentation\\n    uint256[] nftIdList; // the token IDs of NFTs to deposit into the pool\\n    uint256 initialTokenBalance; // the number of ERC20 tokens to transfer to the pool\\n    bytes templateInitData; // initial data to pass to the pool contract in its initializer\\n    bytes referrer; // the address of the referrer\\n}\\n\\n/**\\n * @notice A struct for containing Pool Manager template data.\\n *  \\n * @dev **templateIndex** Which DittoSwap template to use. If templateIndex is set to a value \\n *   larger than the number of templates, no pool manager is created\\n * @dev **templateInitData** initial data to pass to the poolManager contract in its initializer.\\n */\\nstruct PoolManagerTemplate {\\n    uint256 templateIndex;\\n    bytes templateInitData;\\n}\\n\\n/**\\n * @notice A struct for containing Permitter template data.\\n * @dev **templateIndex** Which DittoSwap template to use. If templateIndex is set to a value \\n *   larger than the number of templates, no permitter is created.\\n * @dev **templateInitData** initial data to pass to the permitter contract in its initializer.\\n * @dev **liquidityDepositPermissionData** Deposit data to pass in an all-in-one step to create a pool and deposit liquidity at the same time\\n */\\nstruct PermitterTemplate {\\n    uint256 templateIndex;\\n    bytes templateInitData;\\n    bytes liquidityDepositPermissionData;\\n}\\n\"\r\n    },\r\n    \"contracts/struct/LpIdToTokenBalance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\n/**\\n * @notice Tuple struct to encapsulate a LP Position NFT token Id and the amount of ERC20 tokens it owns in the pool\\n * @dev **lpId** the LP Position NFT token Id of a liquidity provider\\n * @dev **tokenBalance** the amount of ERC20 tokens the liquidity provider has in the pool attributed to them\\n */\\nstruct LpIdToTokenBalance {\\n    uint256 lpId;\\n    uint256 tokenBalance;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IPermitter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\n/**\\n * @title IPermitter\\n * @notice Interface for the Permitter contracts. They are used to check whether a set of tokenIds\\n *   are are allowed in a pool.\\n */\\ninterface IPermitter {\\n    /**\\n     * @notice Initializes the permitter contract with initial state.\\n     * @param data_ Any data necessary for initializing the permitter implementation.\\n     */\\n    function initialize(bytes memory data_) external returns (bytes memory);\\n\\n    /**\\n     * @notice Returns whether or not the contract has been initialized.\\n     * @return initialized Whether or not the contract has been initialized.\\n     */\\n    function initialized() external view returns (bool);\\n\\n    /**\\n     * @notice Checks that the provided permission data are valid for the provided tokenIds.\\n     * @param tokenIds_ The token ids to check.\\n     * @param permitterData_ data used by the permitter to perform checking.\\n     * @return permitted Whether or not the tokenIds are permitted to be added to the pool.\\n     */\\n    function checkPermitterData(uint256[] calldata tokenIds_, bytes memory permitterData_)\\n        external\\n        view\\n        returns (bool permitted);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IOwnerTwoStep.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\n/**\\n * @title IOwnerTwoStep\\n * @notice Interface for the OwnerTwoStep contract\\n */\\ninterface IOwnerTwoStep {\\n\\n    // ***************************************************************\\n    // * =================== USER INTERFACE ======================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice Starts the ownership transfer of the contract to a new account. Replaces the \\n     *   pending transfer if there is one. \\n     * @dev Can only be called by the current owner.\\n     * @param newOwner_ The address of the new owner\\n     */\\n    function transferOwnership(address newOwner_) external;\\n\\n    /**\\n     * @notice Completes the transfer process to a new owner.\\n     * @dev only callable by the pending owner that is accepting the new ownership.\\n     */\\n    function acceptOwnership() external;\\n\\n    /**\\n     * @notice Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     */\\n    function renounceOwnership() external;\\n\\n    // ***************************************************************\\n    // * =================== VIEW FUNCTIONS ======================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice Getter function to find out the current owner address\\n     * @return owner The current owner address\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice Getter function to find out the pending owner address\\n     * @dev The pending address is 0 when there is no transfer of owner in progress\\n     * @return pendingOwner The pending owner address, if any\\n     */\\n    function pendingOwner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/pool/DittoPoolMain.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\nimport { Math } from \\\"../../lib/openzeppelin-contracts/contracts/utils/math/Math.sol\\\";\\nimport { OwnerTwoStep } from \\\"../utils/OwnerTwoStep.sol\\\";\\nimport { LpNft } from \\\"./lpNft/LpNft.sol\\\";\\nimport { IOwnerTwoStep } from \\\"../interface/IOwnerTwoStep.sol\\\";\\nimport { IDittoPool } from \\\"../interface/IDittoPool.sol\\\";\\nimport { IDittoPoolFactory } from \\\"../interface/IDittoPoolFactory.sol\\\";\\nimport { IPermitter } from \\\"../interface/IPermitter.sol\\\";\\nimport { PoolTemplate } from \\\"../struct/FactoryTemplates.sol\\\";\\nimport { LpIdToTokenBalance } from \\\"../struct/LpIdToTokenBalance.sol\\\";\\nimport { ERC20 } from \\\"../../lib/solmate/src/tokens/ERC20.sol\\\";\\nimport { ReentrancyGuard } from\\n    \\\"../../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\\\";\\nimport { IERC721 } from \\\"../../lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\\\";\\nimport { EnumerableSet } from\\n    \\\"../../lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport { EnumerableMap } from\\n    \\\"../../lib/openzeppelin-contracts/contracts/utils/structs/EnumerableMap.sol\\\";\\n\\n/**\\n * @title DittoPool\\n * @notice Contract that defines basic pool functionality used in DittoPoolMarketMake and DittoPoolTrade contracts\\n * @notice Also defines admin functions for changing pool variables\\n */\\nabstract contract DittoPoolMain is OwnerTwoStep, IDittoPool, ReentrancyGuard {\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using EnumerableMap for EnumerableMap.UintToUintMap;\\n\\n    ///@dev Indication of whether or not this pool has more than one possible liquidity provider\\n    bool internal _isPrivatePool;\\n    ///@dev The ID of the LP Position that owns the pool if it is a private pool\\n    uint256 public _privatePoolOwnerLpId;\\n\\n    ///@dev The full list of NFT ids owned by this pool that the pool is tracking. \\n    EnumerableSet.UintSet internal _poolOwnedNftIds;\\n\\n    ///@dev Stores which Lp Position owns which NFT in the pool\\n    mapping(uint256 => uint256) internal _nftIdToLpId;\\n\\n    ///@dev Stores how many NFTs each Lp Position owns in the pool\\n    mapping(uint256 => uint256) internal _lpIdToNftBalance;\\n\\n    ///@dev Stores how much erc20 liquidity that a given Lp Position owns within the pool.\\n    ///@dev Also stores list of all LP Position Token IDs representing liquidity in this specific DittoPool:\\n    ///   a position that has 0 tokens will return 0 but still will be included in .tryGet, .contains() and .length()\\n    EnumerableMap.UintToUintMap internal _lpIdToTokenBalance;\\n\\n    ///@dev LP Position NFT contract that tokenizes liquidity provisions in the protocol\\n    LpNft internal _lpNft;\\n    ///@dev Permitter contract that decides which NFT tokenIds are permitted in this pool. If not set, all ids allowed\\n    IPermitter internal _permitter;\\n\\n    ///@dev flag to prevent pool variables from being set multiple times. Pack with previous address.\\n    bool internal _initialized;\\n\\n    ///@dev The ERC721 collection stored in this pool\\n    IERC721 internal _nft;\\n    ///@dev The ERC20 collection stored in this pool\\n    ERC20 internal _token;\\n    ///@dev The DittoPoolFactory contract that created this pool. Used to fetch up to date protocol fee values\\n    IDittoPoolFactory internal _dittoPoolFactory;\\n\\n    ///@dev The fee charged by and paid to the administrator of this pool on each trade. Packed with previous address.\\n    uint96 internal _feeAdmin;\\n\\n    ///@dev The recipient address of admin fee.\\n    address internal _adminFeeRecipient;\\n\\n    ///@dev The lp fee charged on trades and provided to the liquidit provider. Packed with previous address.\\n    uint96 internal _feeLp;\\n\\n    ///@dev A variable used differently by each bonding curve type to update the price after each trade\\n    uint128 internal _delta;\\n    ///@dev The current price of the pool, used differently by each bonding curve type\\n    uint128 internal _basePrice;\\n\\n    ///@dev the maximum permissible admin fee and Lp value (both capped at 10%)\\n    uint96 internal constant MAX_FEE = 0.10e18;\\n\\n    ///@dev which DittoPoolTemplate address was used when creating this pool\\n    address internal _template;\\n\\n    // ***************************************************************\\n    // * ========================= EVENTS ========================== *\\n    // ***************************************************************\\n    event DittoPoolMainPoolInitialized(address template, address lpNft, address permitter);\\n    event DittoPoolMainAdminChangedBasePrice(uint128 newBasePrice);\\n    event DittoPoolMainAdminChangedDelta(uint128 newDelta);\\n    event DittoPoolMainAdminChangedAdminFeeRecipient(address adminFeeRecipient);\\n    event DittoPoolMainAdminChangedAdminFee(uint256 newAdminFee);\\n    event DittoPoolMainAdminChangedLpFee(uint256 newLpFee);\\n\\n    // ***************************************************************\\n    // * ========================= ERRORS ========================== *\\n    // ***************************************************************\\n\\n    error DittoPoolMainInvalidAdminFeeRecipient();\\n    error DittoPoolMainInvalidPermitterData();\\n    error DittoPoolMainAlreadyInitialized();\\n    error DittoPoolMainInvalidBasePrice(uint128 basePrice);\\n    error DittoPoolMainInvalidDelta(uint128 delta);\\n    error DittoPoolMainInvalidOwnerOperation();\\n    error DittoPoolMainNoDirectNftTransfers();\\n    error DittoPoolMainInvalidMsgSender();\\n    error DittoPoolMainInvalidFee();\\n\\n    // ***************************************************************\\n    // * ================ OWNERSHIP FUNCTIONS ====================== *\\n    // ***************************************************************\\n\\n    ///@inheritdoc OwnerTwoStep\\n    function owner() public view virtual override(IOwnerTwoStep, OwnerTwoStep) returns (address) {\\n        if(_isPrivatePool) {\\n            return _lpNft.ownerOf(_privatePoolOwnerLpId);\\n        }\\n        return OwnerTwoStep.owner();\\n    }\\n\\n    ///@inheritdoc OwnerTwoStep\\n    function _onlyOwner() internal view override(OwnerTwoStep) {\\n        if(msg.sender != owner()) {\\n            revert DittoPoolMainInvalidMsgSender();\\n        }\\n    }\\n\\n    ///@inheritdoc OwnerTwoStep\\n    function acceptOwnership() public override (IOwnerTwoStep, OwnerTwoStep) nonReentrant onlyPendingOwner {\\n        if(_isPrivatePool) {\\n            revert DittoPoolMainInvalidOwnerOperation();\\n        }\\n        super.acceptOwnership();\\n        _lpNft.emitMetadataUpdateForAll();\\n    }\\n\\n    // ***************************************************************\\n    // * ============= CONSTRUCTOR AND MODIFIERS =================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @inheritdoc IDittoPool\\n     */\\n    function initPool(\\n        PoolTemplate calldata params_,\\n        address template_,\\n        LpNft lpNft_,\\n        IPermitter permitter_\\n    ) external {\\n        // CHECK PRECONDITIONS\\n        if (_initialized) {\\n            revert DittoPoolMainAlreadyInitialized();\\n        }\\n        _initialized = true;\\n\\n        // SET STATE\\n        _isPrivatePool = params_.isPrivatePool;\\n        _nft = IERC721(params_.nft);\\n        _token = ERC20(params_.token);\\n        _lpNft = lpNft_;\\n        _permitter = permitter_;\\n        _changeFeeLp(params_.feeLp);\\n        _changeFeeAdmin(params_.feeAdmin);\\n        _adminChangeDelta(params_.delta);\\n        _adminChangeBasePrice(params_.basePrice);\\n        _transferOwnership(params_.owner);\\n        _adminFeeRecipient = params_.owner;\\n        _dittoPoolFactory = IDittoPoolFactory(msg.sender);\\n        _template = template_;\\n\\n        _initializeCustomPoolData(params_.templateInitData);\\n\\n        emit DittoPoolMainPoolInitialized(template_, address(lpNft_), address(permitter_));\\n    }\\n\\n    // ***************************************************************\\n    // * =============== ADMINISTRATIVE FUNCTIONS ================== *\\n    // ***************************************************************\\n\\n    ///@inheritdoc IDittoPool\\n    function changeBasePrice(uint128 newBasePrice_) external virtual onlyOwner {\\n        _adminChangeBasePrice(newBasePrice_);\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function changeDelta(uint128 newDelta_) external virtual onlyOwner {\\n        _adminChangeDelta(newDelta_);\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function changeLpFee(uint96 newFeeLp_) external onlyOwner {\\n        _changeFeeLp(newFeeLp_);\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function changeAdminFee(uint96 newFeeAdmin_) external onlyOwner {\\n        _changeFeeAdmin(newFeeAdmin_);\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function changeAdminFeeRecipient(address newAdminFeeRecipient_) external onlyOwner {\\n        if (newAdminFeeRecipient_ == address(0)) {\\n            revert DittoPoolMainInvalidAdminFeeRecipient();\\n        }\\n\\n        _adminFeeRecipient = newAdminFeeRecipient_;\\n\\n        emit DittoPoolMainAdminChangedAdminFeeRecipient(newAdminFeeRecipient_);\\n    }\\n\\n    // ***************************************************************\\n    // * ======= EXTERNALLY CALLABLE READ-ONLY VIEW FUNCTIONS ====== *\\n    // ***************************************************************\\n\\n    ///@inheritdoc IDittoPool\\n    function isPrivatePool() external view returns (bool isPrivatePool_) {\\n        isPrivatePool_ = _isPrivatePool;\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function initialized() external view returns (bool) {\\n        return _initialized;\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function template() external view returns (address) {\\n        return _template;\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function adminFee() external view returns (uint96 feeAdmin_) {\\n        feeAdmin_ = _feeAdmin;\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function lpFee() external view returns (uint96 feeLp_) {\\n        feeLp_ = _feeLp;\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function protocolFee() external view returns (uint256 feeProtocol_) {\\n        feeProtocol_ = _dittoPoolFactory.getProtocolFee();\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function fee() public view returns (uint256 fee_) {\\n        fee_ = _feeLp + _feeAdmin + _dittoPoolFactory.getProtocolFee();\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function delta() external view returns (uint128) {\\n        return _delta;\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function basePrice() external view returns (uint128) {\\n        return _basePrice;\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function dittoPoolFactory() external view returns (address) {\\n        return address(_dittoPoolFactory);\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function adminFeeRecipient() external view returns (address) {\\n        return _adminFeeRecipient;\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function getLpNft() external view returns (address) {\\n        return address(_lpNft);\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function nft() external view returns (IERC721) {\\n        return _nft;\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function token() external view returns (address) {\\n        return address(_token);\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function permitter() public view returns (IPermitter) {\\n        return _permitter;\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function getTokenBalanceForLpId(uint256 lpId_) public view returns (uint256 tokenBalance) {\\n        (, tokenBalance) = _lpIdToTokenBalance.tryGet(lpId_);\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function getNftIdsForLpId(uint256 lpId_) public view returns (uint256[] memory nftIds) {\\n        nftIds = new uint256[](_lpIdToNftBalance[lpId_]);\\n\\n        uint256 nftId;\\n        uint256 nftIdIndex;\\n        uint256 countOwnedNftIds = _poolOwnedNftIds.length();\\n\\n        for (uint256 i = 0; i < countOwnedNftIds;) {\\n            nftId = _poolOwnedNftIds.at(i);\\n            if (lpId_ == _nftIdToLpId[nftId]) {\\n                nftIds[nftIdIndex] = nftId;\\n                unchecked {\\n                    ++nftIdIndex;\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function getNftCountForLpId(uint256 lpId_) public view returns (uint256) {\\n        return _lpIdToNftBalance[lpId_];\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function getTotalBalanceForLpId(uint256 lpId_)\\n        public\\n        view\\n        returns (uint256 tokenBalance, uint256 nftBalance)\\n    {\\n        (, tokenBalance) = _lpIdToTokenBalance.tryGet(lpId_);\\n        nftBalance = _lpIdToNftBalance[lpId_];\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function getLpIdForNftId(uint256 nftId_) public view returns (uint256 lpId) {\\n        lpId = _nftIdToLpId[nftId_];\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function getAllPoolHeldNftIds() external view returns (uint256[] memory) {\\n        return _poolOwnedNftIds.values();\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function getPoolTotalNftBalance() external view returns (uint256) {\\n        return _poolOwnedNftIds.length();\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function getAllPoolLpIds() external view returns (uint256[] memory lpIds) {\\n        uint256 countLpIds = _lpIdToTokenBalance.length();\\n        lpIds = new uint256[](countLpIds);\\n\\n        for (uint256 i = 0; i < countLpIds;) {\\n            (lpIds[i],) = _lpIdToTokenBalance.at(i);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function getPoolTotalTokenBalance() external view returns (uint256 totalTokenBalance) {\\n        uint256 countLpIds = _lpIdToTokenBalance.length();\\n        uint256 tokenBalance;\\n        for (uint256 i = 0; i < countLpIds;) {\\n            (, tokenBalance) = _lpIdToTokenBalance.at(i);\\n            totalTokenBalance += tokenBalance;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function getAllLpIdTokenBalances()\\n        external\\n        view\\n        returns (LpIdToTokenBalance[] memory balances)\\n    {\\n        uint256 countLpIds = _lpIdToTokenBalance.length();\\n        balances = new LpIdToTokenBalance[](countLpIds);\\n\\n        for (uint256 i = 0; i < countLpIds;) {\\n            (balances[i].lpId, balances[i].tokenBalance) = _lpIdToTokenBalance.at(i);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    // ***************************************************************\\n    // * ============= INTERNAL HELPER FUNCTIONS =================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @dev multiply two values that are scaled by 1e18\\n     */\\n    function _mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return Math.mulDiv(a, b, 1e18);\\n    }\\n\\n    /**\\n     * @notice check if the tokens being added to the pool are permitted to be added \\n     * @param tokenIds_ the token ids to check\\n     * @param permitterData_ data to pass to permitter for determining validity (e.g. merkle proofs)\\n     */\\n    function _checkPermittedTokens(\\n        uint256[] calldata tokenIds_,\\n        bytes calldata permitterData_\\n    ) internal view {\\n        if (\\n            address(_permitter) != address(0)\\n            && !_permitter.checkPermitterData(tokenIds_, permitterData_)\\n        ) {\\n            revert DittoPoolMainInvalidPermitterData();\\n        }\\n    }\\n\\n    /**\\n     * @notice A function to be called to change the _feeAdmin state variable\\n     * @param newFeeAdmin_ The proposedvalue.\\n     */\\n    function _changeFeeAdmin(uint96 newFeeAdmin_) internal virtual {\\n        _requireValidFee(newFeeAdmin_);\\n        _feeAdmin = newFeeAdmin_;\\n        emit DittoPoolMainAdminChangedAdminFee(newFeeAdmin_);\\n    }\\n\\n    /**\\n     * @notice A function to be called to change the _feeLp state variable\\n     * @param newFeeLp_ The proposed value.\\n     */\\n    function _changeFeeLp(uint96 newFeeLp_) internal virtual {\\n        _requireValidFee(newFeeLp_);\\n        _feeLp = newFeeLp_;\\n        emit DittoPoolMainAdminChangedLpFee(newFeeLp_);\\n    }\\n\\n    /**\\n     * @dev Ensure the proosed admin fee is below the max threshold (0.10e18)\\n     */\\n    function _requireValidFee(uint96 fee_) internal pure {\\n        if (fee_ > MAX_FEE) {\\n            revert DittoPoolMainInvalidFee();\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function to change the base price of the pool used by extending contracts\\n     * @param newBasePrice_ The new base price to set\\n     */\\n    function _changeBasePrice(uint128 newBasePrice_) internal {\\n        if (_invalidBasePrice(newBasePrice_)) {\\n            revert DittoPoolMainInvalidBasePrice(newBasePrice_);\\n        }\\n        _basePrice = newBasePrice_;\\n    }\\n\\n    /**\\n     * @notice Helper function to update the pool's basePrice and log\\n     * \\n     * @param newBasePrice_ The new base price to set\\n     */\\n    function _adminChangeBasePrice(uint128 newBasePrice_) internal {\\n        _changeBasePrice(newBasePrice_);\\n\\n        emit DittoPoolMainAdminChangedBasePrice(newBasePrice_);\\n    }\\n\\n    /**\\n     * @notice Helper function to change the delta of the pool used by extending contracts\\n     * @param newDelta_ The new delta to set\\n     */\\n    function _changeDelta(uint128 newDelta_) internal {\\n        if (_invalidDelta(newDelta_)) {\\n            revert DittoPoolMainInvalidDelta(newDelta_);\\n        }\\n        _delta = newDelta_;\\n    }\\n\\n    /**\\n     * @notice Helper function to update the pool's delta and log\\n     * \\n     * @param newDelta_ The new delta to set\\n     */\\n    function _adminChangeDelta(uint128 newDelta_) internal {\\n        _changeDelta(newDelta_);\\n\\n        emit DittoPoolMainAdminChangedDelta(newDelta_);\\n    }\\n\\n    // ***************************************************************\\n    // * ================== CURVE CUSTOM HOOKS ===================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice A function to be called when the pool is initialized. Each curve type\\n     *   can choose to override this function to introduce custom behavior. \\n     */\\n    function _initializeCustomPoolData(bytes calldata /*templateInitData*/) internal virtual { }\\n\\n    /**\\n     * @notice A function to be called when nft liquidity is added. Each curve type\\n     *   can choose to override this function to introduce custom behavior.\\n     * @param count_ The count of nft liquidity added.\\n     */\\n    function _nftLiquidityAdded(uint256 count_) internal virtual { }\\n\\n    /**\\n     * @notice A function to be called when nft liquidity is removed. Each curve type\\n     *   can choose to override this function to introduce custom behavior.\\n     * @param count_ The count of nft liquidity removed.\\n     */\\n    function _nftLiquidityRemoved(uint256 count_) internal virtual { }\\n\\n    /**\\n     * @notice A function to be called when token liquidity is added. Each curve type\\n     *   can choose to override this function to introduce custom behavior.\\n     * @param count_ The count of token liquidity added.\\n     */\\n    function _tokenLiquidityAdded(uint256 count_) internal virtual { }\\n\\n    /**\\n     * @notice A function to be called when token liquidity is removed. Each curve type\\n     *   can choose to override this function to introduce custom behavior.\\n     * @param count_ The count of token liquidity removed.\\n     */\\n    function _tokenLiquidityRemoved(uint256 count_) internal virtual { }\\n\\n    /**\\n     * @notice Validates if a delta value is valid for the curve. The criteria for\\n     * validity can be different for each type of curve, for instance ExponentialCurve\\n     * requires delta to be greater than 1.\\n     * @param delta_ The delta value to be validated\\n     * @return valid True if delta is invalid, false otherwise\\n     */\\n    function _invalidDelta(uint128 delta_) internal pure virtual returns (bool valid);\\n\\n    /**\\n     * @notice Validates if a new base price is valid for the curve.\\n     *   Spot price is generally assumed to be the immediate sell price of 1 NFT to the pool,\\n     *   in units of the pool's paired token.\\n     * @param newBasePrice_ The new base price to be set\\n     * @return valid True if the new base price is invalid, false otherwise\\n     */\\n    function _invalidBasePrice(uint128 newBasePrice_) internal pure virtual returns (bool valid);\\n\\n    // ***************************************************************\\n    // * ================== ON ERC721 RECEIVED ===================== *\\n    // ***************************************************************\\n    ///@inheritdoc IDittoPool\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual returns (bytes4) {\\n        revert DittoPoolMainNoDirectNftTransfers();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pool/DittoPoolMarketMake.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\nimport { IDittoPool } from \\\"../interface/IDittoPool.sol\\\";\\nimport { DittoPoolMain } from \\\"./DittoPoolMain.sol\\\";\\nimport { ERC20 } from \\\"../../lib/solmate/src/tokens/ERC20.sol\\\";\\nimport { SafeTransferLib } from \\\"../../lib/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport { ReentrancyGuard } from\\n    \\\"../../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\\\";\\nimport { EnumerableSet } from\\n    \\\"../../lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport { EnumerableMap } from\\n    \\\"../../lib/openzeppelin-contracts/contracts/utils/structs/EnumerableMap.sol\\\";\\n\\n/**\\n * @title DittoPool\\n * @notice Parent contract defines common functions for DittoPool AMM shared liquidity trading pools.\\n */\\nabstract contract DittoPoolMarketMake is DittoPoolMain {\\n    using SafeTransferLib for ERC20;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using EnumerableMap for EnumerableMap.UintToUintMap;\\n\\n    // ***************************************************************\\n    // * ========================= EVENTS ========================== *\\n    // ***************************************************************\\n\\n    event DittoPoolMarketMakeLiquidityAdded(\\n        address liquidityProvider, \\n        uint256 lpId, \\n        uint256[] tokenIds, \\n        uint256 tokenDepositAmount,\\n        bytes referrer\\n    );\\n    event DittoPoolMarketMakeLiquidityCreated(\\n        address liquidityProvider, \\n        uint256 lpId, \\n        uint256[] tokenIds, \\n        uint256 tokenDepositAmount,\\n        address initialPositionTokenOwner,\\n        bytes referrer\\n    );\\n    event DittoPoolMarketMakeLiquidityRemoved(\\n        uint256 lpId, \\n        uint256[] nftIds, \\n        uint256 tokenWithdrawAmount\\n    );\\n\\n    // ***************************************************************\\n    // * ========================= ERRORS ========================== *\\n    // ***************************************************************\\n    error DittoPoolMarketMakeMustDepositLiquidity();\\n    error DittoPoolMarketMakeWrongPoolForLpId();\\n    error DittoPoolMarketMakeNotAuthorizedForLpId();\\n    error DittoPoolMarketMakeInsufficientBalance();\\n    error DittoPoolMarketMakeInvalidNftTokenId();\\n    error DittoPoolMarketMakeOneLpPerPrivatePool();\\n\\n    // ***************************************************************\\n    // * ======= FUNCTIONS TO MARKET MAKE: ADD LIQUIDITY =========== *\\n    // ***************************************************************\\n\\n    ///@inheritdoc IDittoPool\\n    function createLiquidity(\\n        address lpRecipient_,\\n        uint256[] calldata nftIdList_,\\n        uint256 tokenDepositAmount_,\\n        bytes calldata permitterData_,\\n        bytes calldata referrer_\\n    ) external nonReentrant returns (uint256 lpId) {\\n        if (tokenDepositAmount_ == 0 && nftIdList_.length == 0) {\\n            revert DittoPoolMarketMakeMustDepositLiquidity();\\n        }\\n        lpId = _lpNft.mint(lpRecipient_);\\n        if(_isPrivatePool) {\\n            if(_privatePoolOwnerLpId != 0) {\\n                revert DittoPoolMarketMakeOneLpPerPrivatePool();\\n            } else {\\n                _privatePoolOwnerLpId = lpId;\\n            }\\n        }\\n        _lpIdToTokenBalance.set(lpId, 0); // tracking full set of lpIds for this pool\\n        _transferInLiquidity(lpId, nftIdList_, tokenDepositAmount_, permitterData_);\\n\\n        emit DittoPoolMarketMakeLiquidityCreated(msg.sender, lpId, nftIdList_, tokenDepositAmount_, lpRecipient_, referrer_);\\n    }\\n\\n    ///@inheritdoc IDittoPool\\n    function addLiquidity(\\n        uint256 lpId_,\\n        uint256[] calldata nftIdList_,\\n        uint256 tokenDepositAmount_,\\n        bytes calldata permitterData_,\\n        bytes calldata referrer_\\n    ) external nonReentrant {\\n        if(_isPrivatePool){\\n            _onlyOwner();\\n            if(_privatePoolOwnerLpId != lpId_){\\n                revert DittoPoolMarketMakeOneLpPerPrivatePool();\\n            }\\n        }\\n        if (tokenDepositAmount_ == 0 && nftIdList_.length == 0) {\\n            revert DittoPoolMarketMakeMustDepositLiquidity();\\n        }\\n        if (address(_lpNft.getPoolForLpId(lpId_)) != address(this)) {\\n            revert DittoPoolMarketMakeWrongPoolForLpId();\\n        }\\n        _transferInLiquidity(lpId_, nftIdList_, tokenDepositAmount_, permitterData_);\\n\\n        emit DittoPoolMarketMakeLiquidityAdded(msg.sender, lpId_, nftIdList_, tokenDepositAmount_, referrer_);\\n    }\\n\\n    /**\\n     * @notice Helper function to deposits NFTS+ERC20 liquidity into the pool. See the external function documentation.\\n     * @dev If the msg.sender has not set approvals for this contract then the transaction will fail.\\n     */\\n    function _transferInLiquidity(\\n        uint256 lpId_,\\n        uint256[] calldata nftIdList_,\\n        uint256 tokenDepositAmount_,\\n        bytes calldata permitterData_\\n    ) internal {\\n        uint256 nftId;\\n        uint256 countNftIds = nftIdList_.length;\\n\\n        // TRANSFER IN NFT LIQUIDITY\\n        if (countNftIds > 0) {\\n            _checkPermittedTokens(nftIdList_, permitterData_);\\n\\n            for (uint256 i = 0; i < countNftIds;) {\\n                nftId = nftIdList_[i];\\n                _nft.transferFrom(msg.sender, address(this), nftId);\\n                _poolOwnedNftIds.add(nftId);\\n                _nftIdToLpId[nftId] = lpId_;\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n\\n            _lpIdToNftBalance[lpId_] += countNftIds;\\n            _nftLiquidityAdded(countNftIds);\\n        }\\n\\n        // TRANSFER IN TOKEN LIQUIDITY\\n        if (tokenDepositAmount_ > 0) {\\n            _token.transferFrom(msg.sender, address(this), tokenDepositAmount_);\\n\\n            (, uint256 currentTokenBalance) = _lpIdToTokenBalance.tryGet(lpId_);\\n            _lpIdToTokenBalance.set(lpId_, currentTokenBalance + tokenDepositAmount_);\\n            _tokenLiquidityAdded(tokenDepositAmount_);\\n        }\\n    }\\n\\n    // ***************************************************************\\n    // * ===== FUNCTIONS TO MARKET MAKE: REMOVE LIQUIDITY ========== *\\n    // ***************************************************************\\n\\n    ///@inheritdoc IDittoPool\\n    function pullLiquidity(\\n        address withdrawalAddress_,\\n        uint256 lpId_,\\n        uint256[] calldata nftIdList_,\\n        uint256 tokenWithdrawAmount_\\n    ) external nonReentrant {\\n        // CHECK INPUTS\\n        (IDittoPool pool, address lpNftOwner) = _lpNft.getPoolAndOwnerForLpId(lpId_);\\n        if (address(pool) != address(this)) {\\n            revert DittoPoolMarketMakeWrongPoolForLpId();\\n        }\\n        if (lpNftOwner != msg.sender && !_lpNft.isApproved(msg.sender, lpId_)) {\\n            revert DittoPoolMarketMakeNotAuthorizedForLpId();\\n        }\\n\\n        // TRANSFER OUT NFT LIQUIDITY\\n        {\\n            uint256 countNftIds = nftIdList_.length;\\n            for (uint256 i = 0; i < countNftIds;) {\\n                uint256 nftId = nftIdList_[i];\\n                if (_nftIdToLpId[nftId] != lpId_) {\\n                    revert DittoPoolMarketMakeInvalidNftTokenId();\\n                }\\n\\n                _nft.safeTransferFrom(address(this), withdrawalAddress_, nftId);\\n\\n                _poolOwnedNftIds.remove(nftId);\\n                delete _nftIdToLpId[nftId];\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n\\n            _lpIdToNftBalance[lpId_] -= countNftIds;\\n            _nftLiquidityRemoved(countNftIds);\\n        }\\n\\n        // TRANSFER OUT TOKEN LIQUIDITY\\n        (, uint256 currentTokenBalance) = _lpIdToTokenBalance.tryGet(lpId_);\\n        if (tokenWithdrawAmount_ > 0) {\\n            if (tokenWithdrawAmount_ > currentTokenBalance) {\\n                revert DittoPoolMarketMakeInsufficientBalance();\\n            }\\n\\n            _token.safeTransfer(withdrawalAddress_, tokenWithdrawAmount_);\\n\\n            currentTokenBalance -= tokenWithdrawAmount_;\\n            _lpIdToTokenBalance.set(lpId_, currentTokenBalance);\\n\\n            _tokenLiquidityRemoved(tokenWithdrawAmount_);\\n        }\\n\\n        // HANDLE LP POSITION BURNING\\n        if (_lpIdToNftBalance[lpId_] == 0 && currentTokenBalance == 0) {\\n            _lpNft.burn(lpId_);\\n            _lpIdToTokenBalance.remove(lpId_); // tracking full set of lpIds for this pool\\n        }\\n\\n        emit DittoPoolMarketMakeLiquidityRemoved(lpId_, nftIdList_, tokenWithdrawAmount_);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableMap.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"./EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * The following map types are supported:\\n *\\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableMap.\\n * ====\\n */\\nlibrary EnumerableMap {\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Map type with\\n    // bytes32 keys and values.\\n    // The Map implementation uses private functions, and user-facing\\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\\n    // the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit\\n    // in bytes32.\\n\\n    /**\\n     * @dev Query for a nonexistent map key.\\n     */\\n    error EnumerableMapNonexistentKey(bytes32 key);\\n\\n    struct Bytes32ToBytes32Map {\\n        // Storage of keys\\n        EnumerableSet.Bytes32Set _keys;\\n        mapping(bytes32 => bytes32) _values;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\\n        map._values[key] = value;\\n        return map._keys.add(key);\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\\n        delete map._values[key];\\n        return map._keys.remove(key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\\n        return map._keys.contains(key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\\n        return map._keys.length();\\n    }\\n\\n    /**\\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\\n        bytes32 key = map._keys.at(index);\\n        return (key, map._values[key]);\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\\n        bytes32 value = map._values[key];\\n        if (value == bytes32(0)) {\\n            return (contains(map, key), bytes32(0));\\n        } else {\\n            return (true, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        if (value == 0 && !contains(map, key)) {\\n            revert EnumerableMapNonexistentKey(key);\\n        }\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\\n        return map._keys.values();\\n    }\\n\\n    // UintToUintMap\\n\\n    struct UintToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\\n        return set(map._inner, bytes32(key), bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\\n        return remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (uint256(key), uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(key)));\\n    }\\n\\n    /**\\n     * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = keys(map._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintToAddressMap\\n\\n    struct UintToAddressMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (uint256(key), address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n        return (success, address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\\n    }\\n\\n    /**\\n     * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = keys(map._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressToUintMap\\n\\n    struct AddressToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\\n        return remove(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (address(uint160(uint256(key))), uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\\n    }\\n\\n    /**\\n     * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\\n        bytes32[] memory store = keys(map._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // Bytes32ToUintMap\\n\\n    struct Bytes32ToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\\n        return set(map._inner, key, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\\n        return remove(map._inner, key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\\n        return contains(map._inner, key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (key, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, key);\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\\n        return uint256(get(map._inner, key));\\n    }\\n\\n    /**\\n     * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = keys(map._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\nlibrary SafeTransferLib {\\n    /*///////////////////////////////////////////////////////////////\\n                            ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(callStatus, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 100 because the calldata length is 4 + 32 * 3.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\\n        assembly {\\n            // Get how many bytes the call returned.\\n            let returnDataSize := returndatasize()\\n\\n            // If the call reverted:\\n            if iszero(callStatus) {\\n                // Copy the revert message into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Revert with the same message.\\n                revert(0, returnDataSize)\\n            }\\n\\n            switch returnDataSize\\n            case 32 {\\n                // Copy the return data into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Set success to whether it returned true.\\n                success := iszero(iszero(mload(0)))\\n            }\\n            case 0 {\\n                // There was no return data.\\n                success := 1\\n            }\\n            default {\\n                // It returned some malformed input.\\n                success := 0\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IDittoRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\nimport {\\n    Swap,\\n    NftInSwap,\\n    RobustSwap,\\n    RobustNftInSwap,\\n    ComplexSwap,\\n    RobustComplexSwap\\n} from \\\"../struct/RouterStructs.sol\\\";\\nimport { IERC721 } from \\\"../../lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\\\";\\nimport { ERC20 } from \\\"../../lib/solmate/src/tokens/ERC20.sol\\\";\\n\\n/**\\n * @title Ditto Swap Router Interface\\n * @notice Performs swaps between Nfts and ERC20 tokens, across multiple pools, or more complicated multi-swap paths\\n * @dev All swaps assume that a single ERC20 token is used for all the pools involved.\\n * Swapping using multiple tokens in the same transaction is possible, but the slippage checks and the return values\\n * will be meaningless, and may lead to undefined behavior.\\n * @dev UX: The sender should grant infinite token approvals to the router in order for Nft-to-Nft swaps to work smoothly.\\n * @dev This router has a notion of robust, and non-robust swaps. \\\"Robust\\\" versions of a swap will never revert due to\\n * slippage. Instead, users specify a per-swap max cost. If the price changes more than the user specifies, no swap is\\n * attempted. This allows users to specify a batch of swaps, and execute as many of them as possible.\\n * On non-robust swaps, if any slippage check per trade fails in the chain, the entire transaction reverts.\\n */\\ninterface IDittoRouter {\\n    // ***************************************************************\\n    // * ============ TRADING ERC20 TOKENS FOR STUFF =============== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice Swaps ERC20 tokens into specific Nfts using multiple pools.\\n     * @param swapList The list of pools to trade with and the IDs of the Nfts to buy from each.\\n     * @param inputAmount The amount of ERC20 tokens to add to the ERC20-to-Nft swaps\\n     * @param nftRecipient The address that will receive the Nft output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return remainingValue The unspent token amount\\n     */\\n    function swapTokensForNfts(\\n        Swap[] calldata swapList,\\n        uint256 inputAmount,\\n        address nftRecipient,\\n        uint256 deadline\\n    ) external returns (uint256 remainingValue);\\n\\n    /**\\n     * @notice Swaps as many ERC20 tokens for specific Nfts as possible, respecting the per-swap max cost.\\n     * @param swapList The list of pools to trade with and the IDs of the Nfts to buy from each.\\n     * @param inputAmount The amount of ERC20 tokens to add to the ERC20-to-Nft swaps\\n     *\\n     * @param nftRecipient The address that will receive the Nft output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return remainingValue The unspent token amount\\n     */\\n    function robustSwapTokensForNfts(\\n        RobustSwap[] calldata swapList,\\n        uint256 inputAmount,\\n        address nftRecipient,\\n        uint256 deadline\\n    ) external returns (uint256 remainingValue);\\n\\n    /**\\n     * @notice Buys Nfts with ERC20, and sells them for tokens in one transaction\\n     * @param params All the parameters for the swap (packed in struct to avoid stack too deep), containing:\\n     * - ethToNftSwapList The list of Nfts to buy\\n     * - nftToTokenSwapList The list of Nfts to sell\\n     * - inputAmount The max amount of tokens to send (if ERC20)\\n     * - tokenRecipient The address that receives tokens from the Nfts sold\\n     * - nftRecipient The address that receives Nfts\\n     * - deadline UNIX timestamp deadline for the swap\\n     */\\n    function robustSwapTokensForNftsAndNftsForTokens(RobustComplexSwap calldata params)\\n        external\\n        returns (uint256 remainingValue, uint256 outputAmount);\\n\\n    // ***************************************************************\\n    // * ================= TRADING NFTs FOR STUFF ================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice Swaps Nfts into ETH/ERC20 using multiple pools.\\n     * @param swapList The list of pools to trade with and the IDs of the Nfts to sell to each.\\n     * @param minOutput The minimum acceptable total tokens received\\n     * @param tokenRecipient The address that will receive the token output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return outputAmount The total tokens received\\n     */\\n    function swapNftsForTokens(\\n        NftInSwap[] calldata swapList,\\n        uint256 minOutput,\\n        address tokenRecipient,\\n        uint256 deadline\\n    ) external returns (uint256 outputAmount);\\n\\n    /**\\n     * @notice Swaps as many Nfts for tokens as possible, respecting the per-swap min output\\n     * @param swapList The list of pools to trade with and the IDs of the Nfts to sell to each.\\n     * @param tokenRecipient The address that will receive the token output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return outputAmount The total ETH/ERC20 received\\n     */\\n    function robustSwapNftsForTokens(\\n        RobustNftInSwap[] calldata swapList,\\n        address tokenRecipient,\\n        uint256 deadline\\n    ) external returns (uint256 outputAmount);\\n\\n    /**\\n     * @notice Swaps one set of Nfts into another set of specific Nfts using multiple pools, using\\n     * an ERC20 token as the intermediary.\\n     * @param trade The struct containing all Nft-to-ERC20 swaps and ERC20-to-Nft swaps.\\n     * @param inputAmount The amount of ERC20 tokens to add to the ERC20-to-Nft swaps\\n     * @param minOutput The minimum acceptable total excess tokens received\\n     * @param nftRecipient The address that will receive the Nft output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return outputAmount The total ERC20 tokens received\\n     */\\n    function swapNftsForSpecificNftsThroughTokens(\\n        ComplexSwap calldata trade,\\n        uint256 inputAmount,\\n        uint256 minOutput,\\n        address nftRecipient,\\n        uint256 deadline\\n    ) external returns (uint256 outputAmount);\\n\\n    // ***************************************************************\\n    // * ================= RESTRICTED FUNCTIONS ==================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice Allows pool contracts to transfer ERC20 tokens directly from\\n     * the sender, in order to minimize the number of token transfers.\\n     * @dev Only callable by valid IDittoPools.\\n     * @param token The ERC20 token to transfer\\n     * @param from The address to transfer tokens from\\n     * @param to The address to transfer tokens to\\n     * @param amount The amount of tokens to transfer\\n     */\\n    function poolTransferErc20From(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n     * @notice Allows pool contracts to transfer ERC721 NFTs directly from\\n     * the sender, in order to minimize the number of token transfers.\\n     * @dev Only callable by valid IDittoPools.\\n     * @param nft The ERC721 NFT to transfer\\n     * @param from The address to transfer tokens from\\n     * @param to The address to transfer tokens to\\n     * @param id The ID of the NFT to transfer\\n     */\\n    function poolTransferNftFrom(IERC721 nft, address from, address to, uint256 id) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ILpNft.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\nimport { IERC4906 } from \\\"./IERC4906.sol\\\";\\nimport { IDittoPool } from \\\"./IDittoPool.sol\\\";\\nimport { IDittoPoolFactory } from \\\"./IDittoPoolFactory.sol\\\";\\nimport { IMetadataGenerator } from \\\"./IMetadataGenerator.sol\\\";\\nimport { IERC721 } from \\\"../../lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface ILpNft is IERC4906 {\\n    // * =============== State Changing Functions ================== *\\n\\n    /**\\n     * @notice Allows an administrator to change the DittoPoolFactory contract that interacts with this LP NFT.\\n     * @param dittoPoolFactory_ The address of a Ditto Pool Factory contract.\\n     */\\n    function setDittoPoolFactory(IDittoPoolFactory dittoPoolFactory_) external;\\n\\n    /**\\n     * @notice Allows an admin to update the metadata generator through the pool factory.\\n     * @dev only the Ditto Pool Factory is allowed to call this function\\n     * @param metadataGenerator_ The address of the metadata generator contract.\\n     */\\n    function setMetadataGenerator(IMetadataGenerator metadataGenerator_) external;\\n\\n    /**\\n     * @notice Allows the factory to whitelist DittoPool contracts as allowed to mint and burn liquidity position NFTs.\\n     * @dev only the Ditto Pool Factory is allowed to call this function\\n     * @param dittoPool_ The address of the DittoPool contract to whitelist.\\n     * @param nft_ The address of the NFT contract that the DittoPool trades.\\n     */\\n    function setApprovedDittoPool(address dittoPool_, IERC721 nft_) external;\\n\\n    /**\\n     * @notice mint function used to create new LP Position NFTs \\n     * @dev only callable by approved DittoPool contracts\\n     * @param to_ The address of the user who will own the new NFT.\\n     * @return lpId The tokenId of the newly minted NFT.\\n     */\\n    function mint(address to_) external returns (uint256 lpId);\\n\\n    /**\\n     * @notice burn function used to destroy LP Position NFTs\\n     * @dev only callable approved DittoPool contracts\\n     * @param lpId_ The tokenId of the NFT to burn.\\n     */\\n    function burn(uint256 lpId_) external;\\n\\n    /**\\n     * @notice Updates LP position NFT metadata on trades, as LP's LP information changes due to the trade\\n     * @dev see [EIP-4906](https://eips.ethereum.org/EIPS/eip-4906) EIP-721 Metadata Update Extension\\n     * @dev only callable by approved DittoPool contracts\\n     * @param lpId_ the tokenId of the NFT who's metadata needs to be updated\\n     */\\n    function emitMetadataUpdate(uint256 lpId_) external;\\n\\n    /**\\n     * @notice Tells off-chain actors to update LP position NFT metadata for all tokens in the collection\\n     * @dev see [EIP-4906](https://eips.ethereum.org/EIPS/eip-4906) EIP-721 Metadata Update Extension\\n     * @dev only callable by approved DittoPool contracts\\n     */\\n    function emitMetadataUpdateForAll() external;\\n\\n    // * ======= EXTERNALLY CALLABLE READ-ONLY VIEW FUNCTIONS ====== *\\n\\n    /**\\n     * @notice Tells you whether a given tokenId is allowed to be spent/used by a given spender on behalf of its owner.\\n     * @dev see EIP-721 approve() and setApprovalForAll() functions\\n     * @param spender_ The address of the operator/spender to check.\\n     * @param lpId_ The tokenId of the NFT to check.\\n     * @return approved Whether the spender is allowed to send or manipulate the NFT.\\n     */\\n    function isApproved(address spender_, uint256 lpId_) external view returns (bool);\\n\\n    /**\\n     * @notice Check if an address has been approved as a DittoPool on the LpNft contract\\n     * @param dittoPool_ The address of the DittoPool contract to check.\\n     * @return approved Whether the DittoPool is approved to mint and burn liquidity position NFTs.\\n     */\\n    function isApprovedDittoPool(address dittoPool_) external view returns (bool);\\n\\n    /**\\n     * @notice Returns which DittoPool applies to a given LP Position NFT tokenId.\\n     * @param lpId_ The LP Position tokenId to get info for.\\n     * @return pool The DittoPool contract that the LP Position NFT is tied to.\\n     */\\n    function getPoolForLpId(uint256 lpId_) external view returns (IDittoPool pool);\\n\\n    /**\\n     * @notice Returns the DittoPool and liquidity provider's address for a given LP Position NFT tokenId.\\n     * @param lpId_ The LP Position tokenId to get info for.\\n     * @return pool The DittoPool contract that the LP Position NFT is tied to.\\n     * @return owner The owner of the lpId.\\n     */\\n    function getPoolAndOwnerForLpId(uint256 lpId_)\\n        external\\n        view\\n        returns (IDittoPool pool, address owner);\\n\\n    /**\\n     * @notice Returns the address of the underlying NFT collection traded by the DittoPool corresponding to an LP Position NFT tokenId.\\n     * @param lpId_ The LP Position tokenId to get info for.\\n     * @return nft The address of the underlying NFT collection for that LP position\\n     */\\n    function getNftForLpId(uint256 lpId_) external view returns (IERC721);\\n\\n    /**\\n     * @notice Returns the amount of ERC20 tokens held by a liquidity provider in a given LP Position.\\n     * @param lpId_ The LP Position tokenId to get info for.\\n     * @return value the amount of ERC20 tokens held by the liquidity provider in the given LP Position.\\n     */\\n    function getLpValueToken(uint256 lpId_) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the list of NFT Ids (of the underlying NFT collection) held by a liquidity provider in a given LP Position.\\n     * @param lpId_ The LP Position tokenId to get info for.\\n     * @return nftIds the list of NFT Ids held by the liquidity provider in the given LP Position.\\n     */\\n    function getAllHeldNftIds(uint256 lpId_) external view returns (uint256[] memory);\\n\\n    /**\\n     * @notice Returns the count of NFTs held by a liquidity provider in a given LP Position.\\n     * @param lpId_ The LP Position tokenId to get info for.\\n     * @return nftCount the count of NFTs held by the liquidity provider in the given LP Position.\\n     */\\n    function getNumNftsHeld(uint256 lpId_) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the \\\"value\\\" of an LP positions NFT holdings in ERC20 Tokens,\\n     *   if it were to be sold at the current base price.\\n     * @param lpId_ The LP Position tokenId to get info for.\\n     * @return value the \\\"value\\\" of an LP positions NFT holdings in ERC20 Tokens.\\n     */\\n    function getLpValueNft(uint256 lpId_) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the \\\"value\\\" of an LP positions total holdings in ERC20s + NFTs,\\n     *   if all the Nfts in the holdings were sold at the current base price.\\n     * @param lpId_ The LP Position tokenId to get info for.\\n     * @return value the \\\"value\\\" of an LP positions sum total holdings in ERC20s + NFTs.\\n     */\\n    function getLpValue(uint256 lpId_) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the address of the DittoPoolFactory contract\\n     * @return factory the address of the DittoPoolFactory contract\\n     */\\n    function dittoPoolFactory() external view returns (IDittoPoolFactory);\\n\\n    /**\\n     * @notice returns the next tokenId to be minted\\n     * @dev NFTs are minted sequentially, starting at tokenId 1\\n     * @return nextId the next tokenId to be minted\\n     */\\n    function nextId() external view returns (uint256);\\n\\n    /**\\n     * @notice returns the address of the contract that generates the metadata for LP Position NFTs\\n     * @return metadataGenerator the address of the contract that generates the metadata for LP Position NFTs\\n     */\\n    function metadataGenerator() external view returns (IMetadataGenerator);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IMetadataGenerator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\nimport { IDittoPool } from \\\"./IDittoPool.sol\\\";\\n\\n/**\\n * @title IMetadataGenerator\\n * @notice Provides a standard interface for interacting with the MetadataGenerator contract \\n *   to return a base64 encoded tokenURI for a given tokenId.\\n */\\ninterface IMetadataGenerator {\\n    /**\\n     * @notice Called in the tokenURI() function of the LpNft contract.\\n     * @param lpId_ The identifier for a liquidity position NFT\\n     * @param pool_ The DittoPool address associated with this liquidity position NFT\\n     * @param countToken_ Count of all ERC20 tokens assigned to the owner of the liquidity position NFT in the DittoPool\\n     * @param countNft_ Count of all NFTs assigned to the owner of the liquidity position NFT in the DittoPool\\n     * @return tokenUri A distinct Uniform Resource Identifier (URI) for a given asset.\\n     */\\n    function payloadTokenUri(\\n        uint256 lpId_,\\n        IDittoPool pool_,\\n        uint256 countToken_,\\n        uint256 countNft_\\n    ) external view returns (string memory tokenUri);\\n\\n    /**\\n     * @notice Called in the contractURI() function of the LpNft contract.\\n     * @return contractUri A distinct Uniform Resource Identifier (URI) for a given asset.\\n     */\\n    function payloadContractUri() external view returns (string memory contractUri);\\n}\\n\"\r\n    },\r\n    \"contracts/pool/metadata/MetadataGeneratorError.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\nimport {Base64} from \\\"./library/Base64.sol\\\";\\nimport {Strings} from \\\"../../../lib/openzeppelin-contracts/contracts/utils/Strings.sol\\\";\\n\\nlibrary MetadataGeneratorError {\\n    string internal constant SVG_PREFIX = \\\"<?xml version=\\\\\\\"1.0\\\\\\\" encoding=\\\\\\\"UTF-8\\\\\\\"?>\\\"\\n        \\\"<svg xmlns=\\\\\\\"http://www.w3.org/2000/svg\\\\\\\" viewBox=\\\\\\\"0 0 768 768\\\\\\\">\\\"\\n        \\\"<style>.t{font:bold 13px monospace}</style>\\\"\\n        \\\"<rect width=\\\\\\\"768\\\\\\\" height=\\\\\\\"768\\\\\\\" style=\\\\\\\"fill:#e5e5e5;stroke:#000;stroke-width:1.5px;\\\\\\\"/>\\\"\\n        \\\"<text class=\\\\\\\"t\\\\\\\" x=\\\\\\\"1\\\\\\\" y=\\\\\\\"300\\\\\\\">Unable to make LP NFT Image. Funds are unaffected by this error.</text>\\\";\\n    string internal constant SVG_POSTFIX = \\\"</svg>\\\";\\n\\n    ///@notice A human readable description of the item.\\n    string internal constant DESCRIPTION =\\n        \\\"Ditto is a gas-efficient, DeFi-optimized automated market maker (AMM) that enables efficient and seamless trading between NFTs and ERC-20 tokens. \\\"\\n        \\\"Users can effortlessly create on-chain pools for trading NFTs, allowing for more composable NFT liquidity provision. \\\"\\n        \\\"Ditto streamlines the process of exchanging digital assets in the ever-growing NFT market and makes them more compatible with the growing vertical at the intersection of DeFi and NFTs.\\\";\\n\\n    function uint8ToHexChar(uint8 raw) internal pure returns (uint8) {\\n        return (raw > 9)\\n            ? (raw + (0x61 - 0xa)) // ascii lowercase a\\n            : (raw + 0x30); // ascii 0\\n    }\\n\\n    function bytesToHexString(bytes memory buffer) internal pure returns (string memory) {\\n        bytes memory hexBuffer = new bytes(buffer.length * 2);\\n        for (uint256 i = 0; i < buffer.length; i++) {\\n            uint8 raw = uint8(buffer[i]);\\n            uint8 highNibble = raw >> 4;\\n            uint8 lowNibble = raw & 0x0f;\\n            hexBuffer[i * 2] = bytes1(uint8ToHexChar(highNibble));\\n            hexBuffer[i * 2 + 1] = bytes1(uint8ToHexChar(lowNibble));\\n        }\\n        return string(abi.encodePacked(\\\"0x\\\", hexBuffer));\\n    }\\n\\n    function generateLpIdString(uint256 lpId_) internal pure returns (string memory) {\\n        return string.concat(\\\"<text class=\\\\\\\"t\\\\\\\" x=\\\\\\\"1\\\\\\\" y=\\\\\\\"350\\\\\\\">LpId: \\\", Strings.toString(lpId_), \\\"</text>\\\");\\n    }\\n\\n    function generatePoolString(address pool_) internal pure returns (string memory) {\\n        return\\n            string.concat(\\\"<text class=\\\\\\\"t\\\\\\\" x=\\\\\\\"1\\\\\\\" y=\\\\\\\"375\\\\\\\">Pool: \\\", Strings.toHexString(uint160(pool_)), \\\"</text>\\\");\\n    }\\n\\n    function generateTokenCount(uint256 tokenCount_) internal pure returns (string memory) {\\n        return\\n            string.concat(\\\"<text class=\\\\\\\"t\\\\\\\" x=\\\\\\\"1\\\\\\\" y=\\\\\\\"400\\\\\\\">Token Count: \\\", Strings.toString(tokenCount_), \\\"</text>\\\");\\n    }\\n\\n    function generateNftCount(uint256 nftCount_) internal pure returns (string memory) {\\n        return string.concat(\\\"<text class=\\\\\\\"t\\\\\\\" x=\\\\\\\"1\\\\\\\" y=\\\\\\\"425\\\\\\\">NFT Count: \\\", Strings.toString(nftCount_), \\\"</text>\\\");\\n    }\\n\\n    function generateErrorComment(bytes memory reasonCode_) internal pure returns (string memory) {\\n        return string.concat(\\\"<!-- Error Reason Code: \\\", bytesToHexString(reasonCode_), \\\"-->\\\");\\n    }\\n\\n    function _generateImage(\\n        uint256 lpId_,\\n        address pool_,\\n        uint256 tokenCount_,\\n        uint256 nftCount_,\\n        bytes memory reasonCode_\\n    ) internal pure returns (string memory) {\\n        return string.concat(\\n            SVG_PREFIX,\\n            generateLpIdString(lpId_),\\n            generatePoolString(pool_),\\n            generateTokenCount(tokenCount_),\\n            generateNftCount(nftCount_),\\n            generateErrorComment(reasonCode_),\\n            SVG_POSTFIX\\n        );\\n    }\\n\\n    function errorTokenUri(\\n        uint256 lpId_,\\n        address pool_,\\n        uint256 tokenCount_,\\n        uint256 nftCount_,\\n        bytes memory reasonCode_\\n    ) internal pure returns (string memory) {\\n        string memory image = Base64.encode(bytes(_generateImage(lpId_, pool_, tokenCount_, nftCount_, reasonCode_)));\\n        return string(\\n            abi.encodePacked(\\n                \\\"data:application/json;base64,\\\",\\n                Base64.encode(\\n                    bytes(\\n                        abi.encodePacked(\\n                            '{\\\"name\\\":\\\"',\\n                            string(abi.encodePacked(\\\"Ditto V1 LP Position #\\\", Strings.toString(lpId_))),\\n                            '\\\", \\\"description\\\":\\\"',\\n                            DESCRIPTION,\\n                            '\\\", \\\"image\\\": \\\"',\\n                            \\\"data:image/svg+xml;base64,\\\",\\n                            image,\\n                            '\\\"}'\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IDittoPoolFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\nimport { PoolTemplate } from \\\"../struct/FactoryTemplates.sol\\\";\\nimport { LpNft } from \\\"../pool/lpNft/LpNft.sol\\\";\\nimport { IOwnerTwoStep } from \\\"./IOwnerTwoStep.sol\\\";\\nimport { IDittoPool } from \\\"./IDittoPool.sol\\\";\\nimport { IDittoRouter } from \\\"./IDittoRouter.sol\\\";\\nimport { IPermitter } from \\\"./IPermitter.sol\\\";\\nimport { IMetadataGenerator } from \\\"./IMetadataGenerator.sol\\\";\\nimport { IPoolManager } from \\\"./IPoolManager.sol\\\";\\nimport { PoolManagerTemplate, PermitterTemplate } from \\\"../struct/FactoryTemplates.sol\\\";\\n\\ninterface IDittoPoolFactory is IOwnerTwoStep {\\n    // ***************************************************************\\n    // * ====================== MAIN INTERFACE ===================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice Create a ditto pool along with a permitter and pool manager if requested. \\n     *\\n     * @param params_ The pool creation parameters including initial liquidity and fee settings\\n     *   **uint256 templateIndex** The index of the pool template to clone\\n     *   **address token** ERC20 token address trading against the nft collection\\n     *   **address nft** the address of the NFT collection that we are creating a pool for\\n     *   **uint96 feeLp** the fee percentage paid to LPers when they are the counterparty in a trade\\n     *   **address owner** The liquidity initial provider and owner of the pool, overwritten by pool manager if present\\n     *   **uint96 feeAdmin** the fee percentage paid to the pool admin \\n     *   **uint128 delta** the delta of the pool, see bonding curve documentation\\n     *   **uint128 basePrice** the base price of the pool, see bonding curve documentation\\n     *   **uint256[] nftIdList** the token IDs of NFTs to deposit into the pool as it is created. Empty arrays are allowed\\n     *   **uint256 initialTokenBalance** the number of ERC20 tokens to transfer to the pool as you create it. Zero is allowed\\n     *   **bytes initialTemplateData** initial data to pass to the pool contract in its initializer\\n     * @param poolManagerTemplate_ The template for the pool manager to manage the pool. Provide type(uint256).max to opt out\\n     * @param permitterTemplate_  The template for the permitter to manage the pool. Provide type(uint256).max to opt out\\n     * @return dittoPool The newly created DittoPool\\n     * @return lpId The ID of the LP position NFT representing the initial liquidity deposited, or zero, if none deposited\\n     * @return poolManager The pool manager or the zero address if none was created\\n     * @return permitter The permitter or the zero address if none was created\\n     */\\n    function createDittoPool(\\n        PoolTemplate memory params_,\\n        PoolManagerTemplate calldata poolManagerTemplate_,\\n        PermitterTemplate calldata permitterTemplate_\\n    )\\n        external\\n        returns (IDittoPool dittoPool, uint256 lpId, IPoolManager poolManager, IPermitter permitter);\\n\\n    // ***************************************************************\\n    // * ============== EXTERNAL VIEW FUNCTIONS ==================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice Get the list of pool templates that can be used to create new pools\\n     * @return poolTemplates_ The list of pool templates that can be used to create new pools\\n     */\\n    function poolTemplates() external view returns (address[] memory);\\n\\n    /**\\n     * @notice Get the list of pool manager templates that can be used to manage a new pool\\n     * @return poolManagerTemplates_ The list of pool manager templates that can be used to manage a new pool\\n     */\\n    function poolManagerTemplates() external view returns (IPoolManager[] memory);\\n\\n    /**\\n     * @notice Get the list of permitter templates that can be used to restrict nft ids in a pool\\n     * @return permitterTemplates_ The list of permitter templates that can be used to restrict nft ids in a pool\\n     */\\n    function permitterTemplates() external view returns (IPermitter[] memory);\\n\\n    /**\\n     * @notice Check if an address is an approved whitelisted router that can trade with the pools\\n     * @param potentialRouter_ The address to check if it is a whitelisted router\\n     * @return isWhitelistedRouter True if the address is a whitelisted router\\n     */\\n    function isWhitelistedRouter(address potentialRouter_) external view returns (bool);\\n\\n    /**\\n     * @notice Get the protocol fee recipient address\\n     * @return poolFeeRecipient of the protocol fee recipient\\n     */\\n    function protocolFeeRecipient() external view returns (address);\\n\\n    /**\\n     * @notice Get the protocol fee multiplier used to calculate fees on all trades \\n     * @return protocolFeeMultiplier the multiplier for global protocol fees on all trades\\n     */\\n    function getProtocolFee() external view returns (uint96);\\n\\n    /**\\n     * @notice The nft used to represent liquidity positions\\n     */\\n    function lpNft() external view returns (LpNft lpNft_);\\n\\n    // ***************************************************************\\n    // * ==================== ADMIN FUNCTIONS ====================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice Admin function to add additional pool templates \\n     * @param poolTemplates_ addresses of the new pool templates\\n     */\\n    function addPoolTemplates(address[] calldata poolTemplates_) external;\\n\\n    /**\\n     * @notice Admin function to add additional pool manager templates\\n     * @param poolManagerTemplates_ addresses of the new pool manager templates\\n     */\\n    function addPoolManagerTemplates(IPoolManager[] calldata poolManagerTemplates_) external;\\n\\n    /**\\n     * @notice Admin function to add additional permitter templates\\n     * @param permitterTemplates_ addresses of the new permitter templates\\n     */\\n    function addPermitterTemplates(IPermitter[] calldata permitterTemplates_) external;\\n\\n    /**\\n     * @notice Admin function to add additional whitelisted routers\\n     * @param routers_ addresses of the new routers to whitelist\\n     */\\n    function addRouters(IDittoRouter[] calldata routers_) external;\\n\\n    /**\\n     * @notice Admin function to set the protocol fee recipient\\n     * @param feeProtocolRecipient_ address of the new protocol fee recipient\\n     */\\n    function setProtocolFeeRecipient(address feeProtocolRecipient_) external;\\n\\n    /**\\n     * @notice Admin function to set the protocol fee multiplier used to calculate fees on all trades, base 1e18\\n     * @param feeProtocol_ the new protocol fee multiplier\\n     */\\n    function setProtocolFee(uint96 feeProtocol_) external;\\n\\n    /**\\n     * @notice Admin function to change the LP position NFT collection used by this Ditto Pool Factory\\n     * @param lpNft_ address of the new LpNft\\n     */\\n    function setLpNft(LpNft lpNft_) external;\\n}\\n\"\r\n    },\r\n    \"contracts/utils/OwnerTwoStep.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nimport { IOwnerTwoStep } from \\\"../interface/IOwnerTwoStep.sol\\\";\\n\\nabstract contract OwnerTwoStep is IOwnerTwoStep {\\n\\n    /// @dev The owner of the contract\\n    address private _owner;\\n\\n    /// @dev The pending owner of the contract\\n    address private _pendingOwner;\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(msg.sender);\\n    }\\n\\n    // ***************************************************************\\n    // * ========================= EVENTS ========================== *\\n    // ***************************************************************\\n\\n    event OwnerTwoStepOwnerStartedTransfer(address currentOwner, address newPendingOwner);\\n    event OwnerTwoStepPendingOwnerAcceptedTransfer(address newOwner);\\n    event OwnerTwoStepOwnershipTransferred(address previousOwner, address newOwner);\\n    event OwnerTwoStepOwnerRenouncedOwnership(address previousOwner);\\n\\n    // ***************************************************************\\n    // * ========================= ERRORS ========================== *\\n    // ***************************************************************\\n\\n    error OwnerTwoStepNotOwner();\\n    error OwnerTwoStepNotPendingOwner();\\n\\n    // ***************************************************************\\n    // * =================== USER INTERFACE ======================== *\\n    // ***************************************************************\\n\\n    ///@inheritdoc IOwnerTwoStep\\n    function transferOwnership(address newPendingOwner_) public virtual override onlyOwner {\\n        _pendingOwner = newPendingOwner_;\\n\\n        emit OwnerTwoStepOwnerStartedTransfer(_owner, newPendingOwner_);\\n    }\\n\\n    ///@inheritdoc IOwnerTwoStep\\n    function acceptOwnership() public virtual override onlyPendingOwner {\\n        emit OwnerTwoStepPendingOwnerAcceptedTransfer(msg.sender);\\n\\n        _transferOwnership(msg.sender);\\n    }\\n\\n    ///@inheritdoc IOwnerTwoStep\\n    function renounceOwnership() public virtual onlyOwner {\\n\\n        emit OwnerTwoStepOwnerRenouncedOwnership(msg.sender);\\n\\n        _transferOwnership(address(0));\\n    }\\n\\n    // ***************************************************************\\n    // * =================== VIEW FUNCTIONS ======================== *\\n    // ***************************************************************\\n\\n    ///@inheritdoc IOwnerTwoStep\\n    function owner() public view virtual override returns (address) {\\n        return _owner;\\n    }\\n\\n    ///@inheritdoc IOwnerTwoStep\\n    function pendingOwner() external view override returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    // ***************************************************************\\n    // * ===================== MODIFIERS =========================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _onlyOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the pending owner.\\n     */\\n    modifier onlyPendingOwner {\\n        if (msg.sender != _pendingOwner) {\\n            revert OwnerTwoStepNotPendingOwner();\\n        }\\n        _;\\n    }\\n\\n    // ***************************************************************\\n    // * ================== INTERNAL HELPERS ======================= *\\n    // ***************************************************************\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner. Saves contract size over copying \\n     *   implementation into every function that uses the modifier.\\n     */\\n    function _onlyOwner() internal view virtual {\\n        if (msg.sender != _owner) {\\n            revert OwnerTwoStepNotOwner();\\n        }\\n    }\\n\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * @param newOwner_ New owner to transfer to\\n     */\\n    function _transferOwnership(address newOwner_) internal {\\n        delete _pendingOwner;\\n\\n        emit OwnerTwoStepOwnershipTransferred(_owner, newOwner_);\\n\\n        _owner = newOwner_;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\\nabstract contract ERC721 {\\n    /*///////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ERC721 STORAGE                        \\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(uint256 => address) public ownerOf;\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || msg.sender == getApproved[id] || isApprovedForAll[from][msg.sender],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            balanceOf[from]--;\\n\\n            balanceOf[to]++;\\n        }\\n\\n        delete getApproved[id];\\n\\n        ownerOf[id] = to;\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            totalSupply++;\\n\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = ownerOf[id];\\n\\n        require(ownerOf[id] != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            totalSupply--;\\n\\n            balanceOf[owner]--;\\n        }\\n\\n        delete ownerOf[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\ninterface ERC721TokenReceiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v5.0._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v5.0._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v5.0._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v5.0._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v5.0._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        if (_status == _ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/struct/RouterStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\nimport { IDittoPool } from \\\"../interface/IDittoPool.sol\\\";\\n\\n/**\\n * @notice Basic Struct used by DittoRouter For Specifying trades\\n * @dev **pool** the pool to trade with\\n * @dev **nftIds** which Nfts you wish to buy out of or sell into the pool\\n */\\nstruct Swap {\\n    IDittoPool pool;\\n    uint256[] nftIds;\\n    bytes swapData;\\n}\\n\\n/**\\n * @notice Struct used by DittoRouter when selling Nfts into a pool.\\n * @dev **swapInfo** Swap info with pool and and Nfts being traded\\n * @dev **lpIds** The LP Position TokenIds of the counterparties you wish to sell to in the pool\\n * @dev **permitterData** Optional: data to pass to the pool for permission checks that the tokenIds are allowed in the pool\\n */\\nstruct NftInSwap {\\n    IDittoPool pool;\\n    uint256[] nftIds;\\n    uint256[] lpIds;\\n    bytes permitterData;\\n    bytes swapData;\\n}\\n\\n/**\\n * @notice Struct used for \\\"robust\\\" swaps that may have partial fills buying NFTs out of a pool\\n * @dev **swapInfo** Swap info with pool and and Nfts being traded\\n * @dev **maxCost** The maximum amount of tokens you are willing to pay for the Nfts total\\n */\\nstruct RobustSwap {\\n    IDittoPool pool;\\n    uint256[] nftIds;\\n    uint256 maxCost;\\n    bytes swapData;\\n}\\n\\n/**\\n * @notice Struct used for \\\"robust\\\" swaps that may have partial fills selling NFTs into a pool\\n * @dev **nftSwapInfo** Swap info with pool, Nfts being traded, lp counterparties, and permitter data\\n * @dev **minOutput** The total minimum amount of tokens you are willing to receive for the Nfts you sell, or abort\\n */\\nstruct RobustNftInSwap {\\n    IDittoPool pool;\\n    uint256[] nftIds;\\n    uint256[] lpIds;\\n    bytes permitterData;\\n    uint256 minOutput;\\n    bytes swapData;\\n}\\n\\n/**\\n * @notice DittoRouter struct for complex swaps with tokens bought and sold in one transaction\\n * @dev **nftToTokenTrades** array of trade info where you are selling Nfts into pools\\n * @dev **tokenToNftTrades** array of trade info where you are buying Nfts out of pools\\n */\\nstruct ComplexSwap {\\n    NftInSwap[] nftToTokenTrades;\\n    Swap[] tokenToNftTrades;\\n}\\n\\n/**\\n * @notice DittoRouter struct for robust partially-fillable complex swaps with tokens bought and sold in one transaction\\n * @dev **nftToTokenTrades** array of trade info where you are selling Nfts into pools\\n * @dev **tokenToNftTrades** array of trade info where you are buying Nfts out of pools\\n * @dev **inputAmount** The total amount of tokens you are willing to spend on the Nfts you buy\\n * @dev **tokenRecipient** The address to send the tokens to after the swap\\n * @dev **nftRecipient** The address to send the Nfts to after the swap\\n */\\nstruct RobustComplexSwap {\\n    RobustSwap[] tokenToNftTrades;\\n    RobustNftInSwap[] nftToTokenTrades;\\n    uint256 inputAmount;\\n    address tokenRecipient;\\n    address nftRecipient;\\n    uint256 deadline;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IERC4906.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity 0.8.19;\\n\\n/**\\n * @title IERC4906\\n * @notice Copied from https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4906.md\\n */\\ninterface IERC4906 {\\n    /// @dev This event emits when the metadata of a token is changed.\\n    /// So that the third-party platforms such as NFT market could\\n    /// timely update the images and related attributes of the NFT.\\n    event MetadataUpdate(uint256 _tokenId);\\n\\n    /// @dev This event emits when the metadata of a range of tokens is changed.\\n    /// So that the third-party platforms such as NFT market could\\n    /// timely update the images and related attributes of the NFTs.\\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\\n}\\n\"\r\n    },\r\n    \"contracts/pool/metadata/library/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.6.0;\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides functions for encoding/decoding base64\\nlibrary Base64 {\\n    string internal constant TABLE_ENCODE =\\n        \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n    bytes internal constant TABLE_DECODE =\\n        hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\"\\n        hex\\\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\\\"\\n        hex\\\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\\\"\\n        hex\\\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\\\";\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // load the table into memory\\n        string memory table = TABLE_ENCODE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 3 bytes at a time\\n            for { } lt(dataPtr, endPtr) { } {\\n                // read 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // write 4 characters\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n\\n        return result;\\n    }\\n\\n    function decode(string memory _data) internal pure returns (bytes memory) {\\n        bytes memory data = bytes(_data);\\n\\n        if (data.length == 0) return new bytes(0);\\n        require(data.length % 4 == 0, \\\"invalid base64 decoder input\\\");\\n\\n        // load the table into memory\\n        bytes memory table = TABLE_DECODE;\\n\\n        // every 4 characters represent 3 bytes\\n        uint256 decodedLen = (data.length / 4) * 3;\\n\\n        // add some extra buffer at the end required for the writing\\n        bytes memory result = new bytes(decodedLen + 32);\\n\\n        assembly {\\n            // padding with '='\\n            let lastBytes := mload(add(data, mload(data)))\\n            if eq(and(lastBytes, 0xFF), 0x3d) {\\n                decodedLen := sub(decodedLen, 1)\\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) { decodedLen := sub(decodedLen, 1) }\\n            }\\n\\n            // set the actual output length\\n            mstore(result, decodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 4 characters at a time\\n            for { } lt(dataPtr, endPtr) { } {\\n                // read 4 characters\\n                dataPtr := add(dataPtr, 4)\\n                let input := mload(dataPtr)\\n\\n                // write 3 bytes\\n                let output :=\\n                    add(\\n                        add(\\n                            shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\\n                            shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))\\n                        ),\\n                        add(\\n                            shl(6, and(mload(add(tablePtr, and(shr(8, input), 0xFF))), 0xFF)),\\n                            and(mload(add(tablePtr, and(input, 0xFF))), 0xFF)\\n                        )\\n                    )\\n                mstore(resultPtr, shl(232, output))\\n                resultPtr := add(resultPtr, 3)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IPoolManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\n/**\\n * @title IPoolManager\\n * @notice Interface for the PoolManager contract\\n */\\ninterface IPoolManager {\\n    /**\\n     * @notice Initializes the permitter contract with some initial state.\\n     * @param dittoPool_ the address of the DittoPool that this manager is managing.\\n     * @param data_ any data necessary for initializing the permitter.\\n     */\\n    function initialize(address dittoPool_, bytes memory data_) external;\\n\\n    /**\\n     * @notice Returns whether or not the contract has been initialized.\\n     * @return initialized Whether or not the contract has been initialized.\\n     */\\n    function initialized() external view returns (bool);\\n\\n    /**\\n     * @notice Change the base price charged to buy an NFT from the pair\\n     * @param newBasePrice_ New base price: now NFTs purchased at this price, sold at `newBasePrice_ + Delta`\\n     */\\n    function changeBasePrice(uint128 newBasePrice_) external;\\n\\n    /**\\n     * @notice Change the delta parameter associated with the bonding curve\\n     * @dev see the bonding curve documentation on bonding curves for additional information\\n     * Each bonding curve uses delta differently, but in general it is used as an input\\n     * to determine the next price on the bonding curve\\n     * @param newDelta_ New delta parameter\\n     */\\n    function changeDelta(uint128 newDelta_) external;\\n\\n    /**\\n     * @notice Change the pool lp fee, set by owner, paid to LPers only when they are the counterparty in a trade\\n     * @param newFeeLp_ New fee, in wei / 1e18, charged by the pool for trades with it (i.e. 1% = 0.01e18)\\n     */\\n    function changeLpFee(uint96 newFeeLp_) external;\\n\\n    /**\\n     * @notice Change the pool admin fee, set by owner, paid to admin (or whoever they want)\\n     * @param newFeeAdmin_ New fee, in wei / 1e18, charged by the pool for trades with it (i.e. 1% = 0.01e18)\\n     */\\n    function changeAdminFee(uint96 newFeeAdmin_) external;\\n\\n    /**\\n     * @notice Change who the pool admin fee for this pool is sent to.\\n     * @param newAdminFeeRecipient_ New address to send admin fees to.\\n     */\\n    function changeAdminFeeRecipient(address newAdminFeeRecipient_) external;\\n\\n    /**\\n     * @notice Change the owner of the underlying DittoPool, functions independently of PoolManager\\n     *   ownership transfer.\\n     * @param newOwner_ The new owner of the underlying DittoPool\\n     */\\n    function transferPoolOwnership(address newOwner_) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"manifoldxyz/=lib/manifoldxyz/contracts/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"@manifoldxyz/libraries-solidity/=lib/manifold-libraries-solidity/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"manifold-libraries-solidity/=lib/manifold-libraries-solidity/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"upshot-oracle/=lib/upshot-oracle/contracts/\",\r\n      \"weird-erc20/=lib/solmate/lib/weird-erc20/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"DittoPoolAppInvalidTokenPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolAppraisalIncorrectCollection\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolAppraisalIncorrectToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolMainAlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolMainInvalidAdminFeeRecipient\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"basePrice\",\"type\":\"uint128\"}],\"name\":\"DittoPoolMainInvalidBasePrice\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"delta\",\"type\":\"uint128\"}],\"name\":\"DittoPoolMainInvalidDelta\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolMainInvalidFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolMainInvalidMsgSender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolMainInvalidOwnerOperation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolMainInvalidPermitterData\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolMainNoDirectNftTransfers\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolMarketMakeInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolMarketMakeInvalidNftTokenId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolMarketMakeMustDepositLiquidity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolMarketMakeNotAuthorizedForLpId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolMarketMakeOneLpPerPrivatePool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolMarketMakeWrongPoolForLpId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum CurveErrorCode\",\"name\":\"error\",\"type\":\"uint8\"}],\"name\":\"DittoPoolTradeBondingCurveError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolTradeInTooManyTokens\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolTradeInsufficientBalanceToBuyNft\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolTradeInsufficientBalanceToPayFees\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolTradeInvalidTokenRecipient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolTradeInvalidTokenSender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolTradeNftAndCostDataLengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolTradeNftAndLpIdsMustBeSameLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolTradeNftIdDoesNotMatchSwapData\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"DittoPoolTradeNftNotOwnedByPool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolTradeNoNftsProvided\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DittoPoolTradeOutTooFewTokens\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"EnumerableMapNonexistentKey\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MathOverflowedMulDiv\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerTwoStepNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerTwoStepNotPendingOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceMaxBuy\",\"type\":\"uint256\"}],\"name\":\"DittoPoolAppUpdatePriceMaxBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceMinSell\",\"type\":\"uint256\"}],\"name\":\"DittoPoolAppUpdatePriceMinSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"DittoPoolAppraisalInitializedWithOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAdminFee\",\"type\":\"uint256\"}],\"name\":\"DittoPoolMainAdminChangedAdminFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adminFeeRecipient\",\"type\":\"address\"}],\"name\":\"DittoPoolMainAdminChangedAdminFeeRecipient\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"newBasePrice\",\"type\":\"uint128\"}],\"name\":\"DittoPoolMainAdminChangedBasePrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"newDelta\",\"type\":\"uint128\"}],\"name\":\"DittoPoolMainAdminChangedDelta\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLpFee\",\"type\":\"uint256\"}],\"name\":\"DittoPoolMainAdminChangedLpFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"template\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lpNft\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"permitter\",\"type\":\"address\"}],\"name\":\"DittoPoolMainPoolInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenDepositAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"referrer\",\"type\":\"bytes\"}],\"name\":\"DittoPoolMarketMakeLiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenDepositAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"initialPositionTokenOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"referrer\",\"type\":\"bytes\"}],\"name\":\"DittoPoolMarketMakeLiquidityCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenWithdrawAmount\",\"type\":\"uint256\"}],\"name\":\"DittoPoolMarketMakeLiquidityRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyerLpId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"admin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocol\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct Fee\",\"name\":\"fee\",\"type\":\"tuple\"}],\"name\":\"DittoPoolTradeSwappedNftForTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"lpIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"minExpectedTokenOutput\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftSender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenRecipient\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"permitterData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"swapData\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct SwapNftsForTokensArgs\",\"name\":\"args\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"newBasePrice\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"newDelta\",\"type\":\"uint128\"}],\"name\":\"DittoPoolTradeSwappedNftsForTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellerLpId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"admin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocol\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct Fee\",\"name\":\"fee\",\"type\":\"tuple\"}],\"name\":\"DittoPoolTradeSwappedTokensForNft\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"maxExpectedTokenInput\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenSender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftRecipient\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapData\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct SwapTokensForNftsArgs\",\"name\":\"args\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"newBasePrice\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"newDelta\",\"type\":\"uint128\"}],\"name\":\"DittoPoolTradeSwappedTokensForNfts\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnerTwoStepOwnerRenouncedOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingOwner\",\"type\":\"address\"}],\"name\":\"OwnerTwoStepOwnerStartedTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerTwoStepOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerTwoStepPendingOwnerAcceptedTransfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_privatePoolOwnerLpId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lpId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIdList_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"tokenDepositAmount_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"permitterData_\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"referrer_\",\"type\":\"bytes\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminFee\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"feeAdmin_\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminFeeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bondingCurve\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"curve\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"newFeeAdmin_\",\"type\":\"uint96\"}],\"name\":\"changeAdminFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdminFeeRecipient_\",\"type\":\"address\"}],\"name\":\"changeAdminFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"newBasePrice_\",\"type\":\"uint128\"}],\"name\":\"changeBasePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"newDelta_\",\"type\":\"uint128\"}],\"name\":\"changeDelta\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"newFeeLp_\",\"type\":\"uint96\"}],\"name\":\"changeLpFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"priceMaxBuy_\",\"type\":\"uint256\"}],\"name\":\"changePriceMaxBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"priceMinSell_\",\"type\":\"uint256\"}],\"name\":\"changePriceMinSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpRecipient_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIdList_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"tokenDepositAmount_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"permitterData_\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"referrer_\",\"type\":\"bytes\"}],\"name\":\"createLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lpId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delta\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dittoPoolFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllLpIdTokenBalances\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lpId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct LpIdToTokenBalance[]\",\"name\":\"balances\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllPoolHeldNftIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllPoolLpIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"lpIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"getBuyNftQuote\",\"outputs\":[{\"internalType\":\"enum CurveErrorCode\",\"name\":\"error\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"newBasePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newDelta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"specificNftId\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"admin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocol\",\"type\":\"uint256\"}],\"internalType\":\"struct Fee\",\"name\":\"fee\",\"type\":\"tuple\"}],\"internalType\":\"struct NftCostData[]\",\"name\":\"nftCostData\",\"type\":\"tuple[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"}],\"name\":\"getLpIdForNftId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lpId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLpNft\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lpId_\",\"type\":\"uint256\"}],\"name\":\"getNftCountForLpId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lpId_\",\"type\":\"uint256\"}],\"name\":\"getNftIdsForLpId\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolTotalNftBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolTotalTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalTokenBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"getSellNftQuote\",\"outputs\":[{\"internalType\":\"enum CurveErrorCode\",\"name\":\"error\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"newBasePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newDelta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"specificNftId\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"admin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocol\",\"type\":\"uint256\"}],\"internalType\":\"struct Fee\",\"name\":\"fee\",\"type\":\"tuple\"}],\"internalType\":\"struct NftCostData[]\",\"name\":\"nftCostData\",\"type\":\"tuple[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lpId_\",\"type\":\"uint256\"}],\"name\":\"getTokenBalanceForLpId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lpId_\",\"type\":\"uint256\"}],\"name\":\"getTotalBalanceForLpId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isPrivatePool\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"templateIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"feeLp\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"feeAdmin\",\"type\":\"uint96\"},{\"internalType\":\"uint128\",\"name\":\"delta\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"basePrice\",\"type\":\"uint128\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIdList\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"initialTokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"templateInitData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"referrer\",\"type\":\"bytes\"}],\"internalType\":\"struct PoolTemplate\",\"name\":\"params_\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"template_\",\"type\":\"address\"},{\"internalType\":\"contract LpNft\",\"name\":\"lpNft_\",\"type\":\"address\"},{\"internalType\":\"contract IPermitter\",\"name\":\"permitter_\",\"type\":\"address\"}],\"name\":\"initPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPrivatePool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isPrivatePool_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpFee\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"feeLp_\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nft\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"contract IUpshotOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permitter\",\"outputs\":[{\"internalType\":\"contract IPermitter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceMaxBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"priceMaxBuy_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceMinSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"priceMinSell_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feeProtocol_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"withdrawalAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lpId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIdList_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"tokenWithdrawAmount_\",\"type\":\"uint256\"}],\"name\":\"pullLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"lpIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"minExpectedTokenOutput\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftSender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenRecipient\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"permitterData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"swapData\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapNftsForTokensArgs\",\"name\":\"args_\",\"type\":\"tuple\"}],\"name\":\"swapNftsForTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"maxExpectedTokenInput\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenSender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftRecipient\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapData\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapTokensForNftsArgs\",\"name\":\"args_\",\"type\":\"tuple\"}],\"name\":\"swapTokensForNfts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"template\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DittoPoolApp", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}