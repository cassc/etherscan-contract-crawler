{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity 0.8.16;\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n/**\r\n * @dev copied and condensed from @openzeppelin/contracts/proxy/utils/Initializable.sol\r\n **/\r\n\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     * @custom:oz-retyped-from bool\r\n     */\r\n    uint8 private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Triggered when the contract has been initialized or reinitialized.\r\n     */\r\n    event Initialized(uint8 version);\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\r\n     * `onlyInitializing` functions can be used to initialize parent contracts.\r\n     *\r\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\r\n     * constructor.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier initializer() {\r\n        bool isTopLevelCall = !_initializing;\r\n        require(\r\n            /* changed from: (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\r\n            to: */(isTopLevelCall && _initialized < 1) || ((address(this).code.length == 0) && _initialized == 1),\r\n            \"Initializable: contract is already initialized\"\r\n        );\r\n        _initialized = 1;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n        }\r\n        _;\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n            emit Initialized(1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\r\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\r\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\r\n     * through proxies.\r\n     *\r\n     * Emits an {Initialized} event the first time it is successfully executed.\r\n     */\r\n    function _disableInitializers() internal virtual {\r\n        require(!_initializing, \"Initializable: contract is initializing\");\r\n        if (_initialized < type(uint8).max) {\r\n            _initialized = type(uint8).max;\r\n            emit Initialized(type(uint8).max);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\r\n     * @dev added by TPM\r\n     */\r\n    function isInitialized() public view returns (bool) {\r\n        return _initialized == 1;\r\n    }\r\n}\r\nlibrary Strings {\r\n    \r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // from @openzeppelin String.sol\r\n        unchecked {\r\n            ////\r\n            // uint256 length = Math.log10(value) + 1; =>\r\n            // from @openzeppelin Math.sol\r\n            uint256 length = 0;\r\n            if (value >= 10**64) { value /= 10**64; length += 64; }\r\n            if (value >= 10**32) { value /= 10**32; length += 32; }\r\n            if (value >= 10**16) { value /= 10**16; length += 16; }\r\n            if (value >= 10**8) { value /= 10**8; length += 8; }\r\n            if (value >= 10**4) { value /= 10**4; length += 4; }\r\n            if (value >= 10**2) { value /= 10**2; length += 2; }\r\n            if (value >= 10**1) { length += 1; }\r\n            length++;\r\n            ////\r\n\r\n            string memory buffer = new string(length);\r\n            uint256 ptr;\r\n            assembly {\r\n                ptr := add(buffer, add(32, length))\r\n            }\r\n            while (true) {\r\n                ptr--;\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    mstore8(ptr, byte(mod(value, 10), \"0123456789abcdef\"))\r\n                }\r\n                value /= 10;\r\n                if (value == 0) break;\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n}\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface ITimeCapsuleFactory {\r\n\r\n    struct OwnerCapsuleRecord {\r\n        address capsuleAddress;\r\n        bytes32 recoveryAddressHash;\r\n        bool validated;\r\n    }\r\n\r\n    function predictedCapsuleAddress(address ownerAddress) external view returns (address predictedAddress);\r\n\r\n    function createTimeCapsule() external;\r\n\r\n    function createTimeCapsule(bytes32 _recoveryAddressHash) external;\r\n\r\n    function capsuleAddressOf(address _owner) external view returns (address capsuleAddress);\r\n\r\n    function validateRecoveryAddressHash(\r\n        address _owner,\r\n        bytes32 _recoveryAddressHash,\r\n        bytes memory _signature\r\n    ) external;\r\n\r\n    function checkRecoveryAddress(address _owner, bytes32 _addressHash) external view returns (bool confirmed);\r\n\r\n    function isRecoveryHashValidated(address _owner) external view returns (bool);\r\n\r\n    function getRecoveryRecord(address _owner) external view  returns (OwnerCapsuleRecord memory);\r\n\r\n    function recoverOwnership( address _oldOwner, address _newOwner ) external;\r\n\r\n}\r\n/// @dev SYNONYMS: vault, capsule, timecapsule\r\n\r\n/// @dev _feeSplitter (feeSplitter.sol) is our own, trusted contract (context: reentrance attacks)\r\ninterface IFeeSplitter {\r\n    function splitERC20(address tokenAddress) external returns (bool);\r\n}\r\n\r\n/**\r\n * @dev A place for TimeCapsule Constants to live\r\n */\r\nabstract contract TimeCapsuleContext is Initializable {\r\n    uint256         constant    internal    FEE_DIVISOR = 1000; // 0.1%\r\n    uint64          constant    internal    ONE_HOUR =  60 * 60;\r\n    uint64          constant    internal    ONE_DAY =  24 * 60 * 60;\r\n    uint64          constant    internal    SEVEN_DAYS = 7 * ONE_DAY;\r\n    uint64          constant    internal    ONE_YEAR = 365 * ONE_DAY;\r\n    uint64          constant    internal    MAX_LOCK_SECONDS = 20089 * ONE_DAY; // ~55 years (365.25 days each)\r\n    uint64          constant    internal    TIMELOCK_SECONDS = SEVEN_DAYS;\r\n    uint64          constant    internal    BEHAVIORLOCK_SECONDS = ONE_YEAR;\r\n    address         constant    internal    NATIVE_COIN = address(0);\r\n    address         constant    internal    INVALID_SIGNER_ADDRESS = address(0);\r\n    string          constant    internal    VAULT_RECOVERY_AUTHORIZATION=\"VAULT RECOVERY AUTHORIZATION\";\r\n    string          constant    internal    CONFIRMING_RECOVERY_ADDRESS=\"CONFIRMING RECOVERY ADDRESS\";\r\n\r\n    enum VaultStatus {\r\n        NOMINAL,    // all is well\r\n        PANIC,      // 'panic switch' activated (lockout for recovery)\r\n        RECOVERED   // (read-only)\r\n    }\r\n\r\n    enum LockState {\r\n        INERT,\r\n        WITHDRAWAL_PENDING\r\n    }\r\n\r\n    enum LockType {\r\n        DRIP,\r\n        HARD,\r\n        BEHAVIORAL\r\n    }\r\n\r\n    struct Lock {\r\n        LockState state;            // uint8\r\n        bytes32 tag;                // <= 31 character descriptor string\r\n        uint64 lockTime;            // UTC\r\n        uint64 unlockTime;          // UTC\r\n        uint64 releaseTime;         // UTC timestamp when time-locked funds release for sending\r\n        LockType lockType;          // uint8\r\n        bytes6 unlockHash;          // first 6 bytes of keccak256 hash\r\n        // 256 bit boundary\r\n        uint256 lockedAmount;       // in ERC20 token's base units\r\n        uint256 withdrawnToDate;    // in ERC20 token's base units\r\n        uint256 timelockedAmount;   // amount of any pending, time-locked withdrawal\r\n    }\r\n}\r\n\r\n/**\r\n * @title TimeCapsule\r\n */\r\ncontract TimeCapsule is TimeCapsuleContext{\r\n\r\n    address public owner;\r\n    ITimeCapsuleFactory private _capsuleFactory;\r\n\r\n    mapping(address => Lock[])  private _locks; // address is 'rc20 token contract address or address(0)\r\n    mapping(address => uint256) private _totalLockedAmount;\r\n\r\n    uint64 private _deadmanTime;\r\n\r\n    VaultStatus private _vaultStatus;\r\n\r\n    IFeeSplitter private _feeSplitter;\r\n\r\n    constructor() {\r\n        // Contructor not used by factory. We use it here only to prevent master copy hijacks\r\n        // the factory will call this.initialize() for one-off setup tasks.\r\n        _disableInitializers();\r\n    }\r\n\r\n    /**\r\n     * @dev Because this contract is a proxied clone (oppenzep'Clone.sol)\r\n     *      functions herein get called **twice**. The first call has `msg.sender`\r\n     *      set as the address of the caller, as usual. The second _proxy_ call\r\n     *      has `msg.sender` set to this contract's own address. Hence, we roll\r\n     *      our own 'Ownable' (minus transferability) and with a different name\r\n     *      than 'onlyOwner' to avoid confusion.\r\n     */\r\n    modifier _onlyCapsuleOwner() {\r\n        if (address(this) != msg.sender) {\r\n            require(owner == msg.sender, \"Not owner\");\r\n            _;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev This modifier blocks calls to functions when the vault is in the 'panic' state.\r\n     */\r\n    modifier _notPanicState() {\r\n        if (address(this) != msg.sender) {\r\n            require(_vaultStatus != VaultStatus.PANIC, \"Forbidden\");\r\n            _;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called once by factory directly after cloning to initialize vault.\r\n     * @param _newOwner the vaults's owner address\r\n     * @param _factoryAddress used to manage recovery from panic state aka \"undo a hack\"\r\n     * @param _feeSplitterContract the [contract] address to send fees\r\n     */\r\n    function initialize(\r\n        address _newOwner,\r\n        address _factoryAddress,\r\n        IFeeSplitter _feeSplitterContract\r\n    )\r\n        initializer\r\n        public\r\n    {\r\n        owner = _newOwner;\r\n        _capsuleFactory = ITimeCapsuleFactory(_factoryAddress);\r\n        _deadmanTime = (uint64)(block.timestamp);\r\n        _vaultStatus = VaultStatus.NOMINAL;\r\n        _feeSplitter = _feeSplitterContract;\r\n    }\r\n\r\n    /**\r\n     * When native coin is sent directly to this vault (as if it were a standard wallet)\r\n     * the funds are auto-locked for seven days (and the fee is paid accordingly.) This is\r\n     * intended as a safety feature and not to be advertized as good practice.\r\n     */\r\n    receive() external payable { }\r\n\r\n    event Locked(\r\n        bytes32 tag,\r\n        address tokenAddress,\r\n        uint256 lockIndex,\r\n        uint256 amount,\r\n        uint256 fee,\r\n        uint256 lockTime,\r\n        uint256 unlockTime,\r\n        LockType lockType\r\n    );\r\n\r\n    event WithdrawalInitiated(\r\n        address tokenAddress,\r\n        uint256 lockIndex,\r\n        uint256 amount\r\n    );\r\n\r\n    event WithdrawalCancelled(\r\n        address tokenAddress,\r\n        uint256 lockIndex\r\n    );\r\n\r\n    event Withdrawal(\r\n        address tokenAddress,\r\n        uint256 lockIndex,\r\n        uint256 amount\r\n    );\r\n\r\n    event LockReleased(\r\n        address tokenAddress,\r\n        uint256 lockIndex\r\n    );\r\n\r\n    event RecoveryInitiated();\r\n\r\n    event Recovered();\r\n\r\n    error HardLocked(\r\n        uint64 unlockTime\r\n    );\r\n\r\n    error InsufficientFunds(\r\n        uint256 grossBalance,\r\n        uint256 alreadyLocked,\r\n        uint256 availableToLock\r\n    );\r\n\r\n    /**\r\n     * Transfers nativer coin from the vault to a recipient.\r\n     * @notice Do not use simple trasfer(<maxgas: 2300!>) \u2014 Gnosis safe (for example) infamously incompatible\r\n     * @param _to recipient address\r\n     * @param _value base unit amount to transfer\r\n     */\r\n    function _transferNative(\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        (success, ) = _to.call{ value: _value }(\"\");\r\n    }\r\n\r\n    /**\r\n     * Transfers 'RC20 tokens from the vault to a recipient.\r\n     * @notice internal function\r\n     * @param _tokenAddress 'RC20 token contract address\r\n     * @param _to recipient address\r\n     * @param _value base unit amount to transfer\r\n     * @return bool\r\n     */\r\n    function _transferToken(\r\n        address _tokenAddress,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return IERC20(_tokenAddress).transfer(\r\n            _to,\r\n            _value\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns the current \"state\" of the vault. See `enum VaultStatus {...}`\r\n     * @return status enum VaultStatus.<NOMINAL|PANIC|RECOVERED>\r\n     */\r\n    function vaultStatus()\r\n        public\r\n        view\r\n        returns (VaultStatus status)\r\n    {\r\n        status = _vaultStatus;\r\n    }\r\n\r\n    /**\r\n     * Validates recovery address. Validation is required as a separate step to account for possibily\r\n     * of mistake or bad actor using the same recovery address as an attempt to 'block' geniune use.\r\n     * @param _recoveryAddressHash keccak256 (sha3) hash of recovery address (so as not to 'dox' the address)\r\n     * @param _signature personal_sign of the string: \"CONFIRMING RECOVERY ADDRESS\"\r\n     */\r\n    function validateRecoveryAddressHash(\r\n        bytes32 _recoveryAddressHash,\r\n        bytes memory _signature\r\n    )\r\n        public\r\n        _onlyCapsuleOwner\r\n        _notPanicState\r\n    {\r\n        _capsuleFactory.validateRecoveryAddressHash(\r\n            owner,\r\n            _recoveryAddressHash,\r\n            _signature\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Used to test if a given recovery address hash is valid for (matches) the hash stored for this vault.\r\n     * @param _recoveryAddressHash keccak256 hash of the recovery address / public key\r\n     * @return confirmed bool\r\n     */\r\n    function checkRecoveryAddress(bytes32 _recoveryAddressHash)\r\n        public\r\n        view\r\n        returns (bool confirmed)\r\n    {\r\n        confirmed = _capsuleFactory.checkRecoveryAddress(owner, _recoveryAddressHash);\r\n    }\r\n\r\n    /**\r\n     * Returns true if tha vault's recovery address hash has been validated \u2014 see validateRecoveryAddressHash(...).\r\n     * @return validated bool\r\n     */\r\n    function isRecoveryHashValidated()\r\n        public view\r\n        returns (bool validated)\r\n    {\r\n        return _capsuleFactory.isRecoveryHashValidated(owner);\r\n    }\r\n\r\n    /**\r\n     * Returns the number of active locks for a given token contract address (or address(0) for\r\n     * native coin.) Used in conjunction with lockData() to retrieve list of locks for a spcific token.\r\n     * @param _tokenAddress 'RC2- contract address\r\n     * @return count number of active locks for the specified token\r\n     */\r\n    function lockCount(address _tokenAddress)\r\n        public\r\n        view\r\n        returns (uint256 count)\r\n    {\r\n        count = _locks[_tokenAddress].length;\r\n    }\r\n\r\n    /**\r\n     * Returns Lock record for an existing lock.\r\n     * @param _tokenAddress 'RC20 token contract address\r\n     * @param _index lock index\r\n     * @return lock Lock record\r\n     */\r\n    function lockData(\r\n        address _tokenAddress,\r\n        uint256 _index\r\n    )\r\n        public\r\n        view\r\n        returns (Lock memory lock)\r\n    {\r\n        Lock[] memory locks = _locks[_tokenAddress];\r\n        require(locks.length > 0,\r\n            \"No locks for given token address\"\r\n        );\r\n        require(locks.length > _index,\r\n            \"Invalid lock index\"\r\n        );\r\n\r\n        lock = locks[_index];\r\n    }\r\n\r\n    /**\r\n     * Returns available/lockable balance (owned by this vault and not tied up in locks)\r\n     * @param _tokenAddress token contract address or address(0) for native coin\r\n     */\r\n    function availableBalance(\r\n        address _tokenAddress   // use address(0) for native coin\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 available)\r\n    {\r\n        available = 0;\r\n        uint256 _grossBalance;\r\n        if (_tokenAddress == NATIVE_COIN) {\r\n            _grossBalance = address(this).balance;\r\n        } else {\r\n            require(\r\n                _tokenAddress.code.length > 0,\r\n                \"not a token\"\r\n            );\r\n            _grossBalance = IERC20(_tokenAddress).balanceOf(address(this));\r\n        }\r\n        if (_grossBalance > _totalLockedAmount[_tokenAddress]) {\r\n            available = _grossBalance - _totalLockedAmount[_tokenAddress];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice internal function\r\n     * @param _tag bytes32String: up to 31 characters of user input as a label for the lock\r\n     * @param _tokenAddress token contract address or address(0) for native coin\r\n     * @param _lockAmount unit value of amount to be locked\r\n     * @param _lockTime UTC unix timestamp (seconds)\r\n     * @param _unlockTime UTC unix timestamp (seconds)\r\n     * @param _lockType enum LockType.<DRIP|HARD|BEHAVIORAL>\r\n     * @return lockIndex array index of created lock\r\n     */\r\n    function _storeNewLock(\r\n        bytes32 _tag,\r\n        address _tokenAddress,\r\n        uint256 _lockAmount,\r\n        uint64 _lockTime,\r\n        uint64 _unlockTime,\r\n        LockType _lockType\r\n    )\r\n        internal\r\n        returns (uint256 lockIndex)\r\n    {\r\n        Lock[] storage locksRef = _locks[_tokenAddress];\r\n        Lock memory lock = Lock({\r\n            state: LockState.INERT,\r\n            tag: _tag,\r\n            lockTime: _lockTime,\r\n            unlockTime: _unlockTime,\r\n            lockType: _lockType,\r\n            unlockHash: 0,\r\n            lockedAmount: _lockAmount,\r\n            withdrawnToDate: 0,\r\n            timelockedAmount: 0,\r\n            releaseTime: 0\r\n        });\r\n        locksRef.push(lock);\r\n        lockIndex = locksRef.length - 1;\r\n    }\r\n\r\n    /**\r\n     * @notice internal function\r\n     * @param _tag bytes32String: up to 31 characters of user input as a label for the lock (may be \"\")\r\n     * @param _tokenAddress token contract address or address(0) for native coin\r\n     * @param _lockAmount unit value of amount to be locked\r\n     * @param _lockTime UTC unix timestamp (seconds)\r\n     * @param _unlockTime UTC unix timestamp (seconds)\r\n     * @param _lockType LockType.<DRIP|HARD|BEHAVIORAL>\r\n     * @return lockIndex array index of created lock\r\n     */\r\n    function _createLock(\r\n        bytes32 _tag,\r\n        address _tokenAddress,\r\n        uint256 _lockAmount,\r\n        uint256 _fee,\r\n        uint64 _lockTime,   // UTC unix timestamp (seconds)\r\n        uint64 _unlockTime, // UTC unix timestamp (seconds)\r\n        LockType _lockType\r\n    )\r\n        internal\r\n        returns (uint256 lockIndex)\r\n    {\r\n        require(_lockTime >= (uint64)(block.timestamp) - (6 * ONE_HOUR),\r\n            \"Lock time must not be more than six hours in the past\"\r\n        );\r\n        require(_unlockTime > _lockTime,\r\n            \"Unlock time must be greater than lock time\"\r\n        );\r\n        require((_unlockTime - _lockTime) < MAX_LOCK_SECONDS, // built-in \"safe math\" solidity@>0.8.0\r\n            \"Unlock time must be within 55 years of lock time\"\r\n        );\r\n\r\n        unchecked { // division underflow acceptable (decimal truncation)\r\n            uint256 _feeCheck = _lockAmount / FEE_DIVISOR;\r\n            require(_feeCheck == _fee,\r\n                \"Fee calc audit failed\"\r\n            );\r\n        }\r\n\r\n        if (_tokenAddress == NATIVE_COIN) { // native coin\r\n\r\n            uint256 _availableToLock = availableBalance(_tokenAddress); // any msg.value is already included in balance\r\n\r\n            if (_availableToLock < (_lockAmount + _fee)) {\r\n                revert InsufficientFunds(\r\n                    address(this).balance - msg.value, // grossBalance (before msg.value, being 'refunded' by this revert)\r\n                    _totalLockedAmount[_tokenAddress], // alreadyLocked\r\n                    _availableToLock                   // availableToLock (includes any incoming msg.value (now being reverted))\r\n                );\r\n            }\r\n\r\n            if (_fee > 0) {\r\n                (bool feeTransferred, ) = address(_feeSplitter).call{value: _fee}(\"\");\r\n                require(\r\n                    feeTransferred,\r\n                    \"Fee transfer rejected by external contract\"\r\n                );\r\n            }\r\n\r\n        } else { // 'RC20\r\n\r\n            IERC20 tokenContract = IERC20(_tokenAddress);\r\n\r\n            uint256 _availableToLock = availableBalance(_tokenAddress);\r\n\r\n            if (_availableToLock < (_lockAmount + _fee)) {\r\n                uint256 _tokenBalance = IERC20(tokenContract).balanceOf(address(this));\r\n                revert InsufficientFunds(\r\n                    _tokenBalance,                      // grossBalance\r\n                    _totalLockedAmount[_tokenAddress],  // alreadyLocked\r\n                    _availableToLock                    // availableToLock)\r\n                );\r\n            }\r\n\r\n            if (_fee > 0) {\r\n                bool feeTransferred = IERC20(tokenContract).transfer(\r\n                    address(_feeSplitter),\r\n                    _fee\r\n                );\r\n                require(\r\n                    feeTransferred,\r\n                    \"Fee transfer rejected by external contract\"\r\n                );\r\n                require(\r\n                    // @dev splitERC20 splits and sends on the _feeSplitter's entire current balance\r\n                    _feeSplitter.splitERC20(address(tokenContract)),\r\n                    \"Fee split callout failed\"\r\n                );\r\n            }\r\n        }\r\n\r\n        lockIndex = _storeNewLock(\r\n            _tag,\r\n            _tokenAddress,\r\n            _lockAmount,\r\n            _lockTime,\r\n            _unlockTime,\r\n            _lockType\r\n        );\r\n\r\n        _totalLockedAmount[_tokenAddress] += _lockAmount;\r\n\r\n        // update 'watchdog' deadman timer\r\n        if (_deadmanTime < _unlockTime) _deadmanTime = _unlockTime;\r\n\r\n        emit Locked(\r\n            _tag,\r\n            _tokenAddress,\r\n            lockIndex,\r\n            _lockAmount,\r\n            _fee,\r\n            _lockTime,\r\n            _unlockTime,\r\n            _lockType\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a new standard (LockType.DRIP) time lock.\r\n     * @param _tag bytes32String: up to 31 characters of user input as a label for the lock (may be \"\")\r\n     * @param _tokenAddress token contract address or address(0) for native coin\r\n     * @param _lockAmount unit value of amount to be locked\r\n     * @param _lockTime UTC unix timestamp (seconds)\r\n     * @param _unlockTime UTC unix timestamp (seconds)\r\n     * @return lockIndex array index of created lock\r\n     */\r\n    function createLock(\r\n        bytes32 _tag,\r\n        address _tokenAddress,\r\n        uint256 _lockAmount,\r\n        uint256 _fee,\r\n        uint64 _lockTime,\r\n        uint64 _unlockTime\r\n    )\r\n        public\r\n        payable\r\n        _onlyCapsuleOwner\r\n        _notPanicState\r\n        returns (uint256 lockIndex)\r\n    {\r\n        lockIndex = _createLock(\r\n            _tag,\r\n            _tokenAddress,\r\n            _lockAmount,\r\n            _fee,\r\n            _lockTime,\r\n            _unlockTime,\r\n            LockType.DRIP\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a new hard lock (LockType.HARD) \u2014 a lock that does not drip and must complete full term before withdrawal.\r\n     * @param _tag bytes32String: up to 31 characters of user input as a label for the lock (may be \"\")\r\n     * @param _tokenAddress token contract address or address(0) for native coin\r\n     * @param _lockAmount unit value of amount to be locked\r\n     * @param _lockTime UTC unix timestamp (seconds)\r\n     * @param _unlockTime UTC unix timestamp (seconds)\r\n     * @return lockIndex array index of created lock\r\n     */\r\n    function createHardLock(\r\n        bytes32 _tag,\r\n        address _tokenAddress,\r\n        uint256 _lockAmount,\r\n        uint256 _fee,\r\n        uint64 _lockTime,\r\n        uint64 _unlockTime\r\n    )\r\n        public\r\n        payable\r\n        _onlyCapsuleOwner\r\n        _notPanicState\r\n        returns (uint256 lockIndex)\r\n    {\r\n        lockIndex = _createLock(\r\n            _tag,\r\n            _tokenAddress,\r\n            _lockAmount,\r\n            _fee,\r\n            _lockTime,\r\n            _unlockTime,\r\n            LockType.HARD\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a behavioral lock (LockType.BAHVIORAL) which lasts up to a maximum of ONE YEAR from _lockStart\r\n     * or immediately released when the correct unlock code is passed to releaseBehaviorLock().\r\n     * @notice UI implementations should limit the unlock code to a simple six digit number.\r\n     * @param _tag bytes32String: up to 31 characters of user input as a label for the lock (may be \"\")\r\n     * @param _tokenAddress token contract address or address(0) for native coin\r\n     * @param _lockAmount unit value of amount to be locked\r\n     * @param _lockTime UTC unix timestamp (seconds)\r\n     * @param _unlockHash first six bytes of a keccak256 (sha3) of a 'secret' unlock text (ideally UI limited to simple 6 digits)\r\n     * @return lockIndex array index of created lock\r\n     */\r\n    /// @dev we consider it unsafe to trust a miner's clock for lock/unlock times\r\n    function createBehaviorLock(\r\n        bytes32 _tag,\r\n        address _tokenAddress,\r\n        uint256 _lockAmount,\r\n        uint256 _fee,\r\n        uint64  _lockTime,\r\n        bytes6 _unlockHash\r\n    )\r\n        public\r\n        payable\r\n        _onlyCapsuleOwner\r\n        _notPanicState\r\n        returns (uint256 lockIndex)\r\n    {\r\n        lockIndex = _createLock(\r\n            _tag,\r\n            _tokenAddress,\r\n            _lockAmount,\r\n            _fee,\r\n            _lockTime,\r\n            _lockTime + BEHAVIORLOCK_SECONDS,\r\n            LockType.BEHAVIORAL\r\n        );\r\n        _locks[_tokenAddress][lockIndex].unlockHash = _unlockHash;\r\n    }\r\n\r\n    /**\r\n     * Intended for a bahioral lock 'friend' to check that the code they have is valid for a given lock.\r\n     * @notice Behavioral locks are only minimally secure *intentionally*. The user who created\r\n     * the lock may 'cheat' or 'fail to achieve their goal'. Thus for example, potential use\r\n     * of this function to brute force the inlock code, while discouraged, is an acceptable\r\n     * trade-off. After all, it is the vault owner's money and only their own self worth at stake.\r\n     * @param _tokenAddress token contract address or address(0) for native coin\r\n     * @param _lockIndex lock index\r\n     * @param _unlockCode clear text unlock code\r\n     * @return correct bool\r\n     */\r\n    function checkBehaviorLockCode(\r\n        address _tokenAddress,\r\n        uint256 _lockIndex,\r\n        string memory _unlockCode\r\n    )\r\n        public\r\n        view\r\n        returns (bool correct)\r\n    {\r\n        bytes32 hashedUnlockCode = keccak256(abi.encodePacked(_unlockCode));\r\n        correct = bytes6(hashedUnlockCode) == _locks[_tokenAddress][_lockIndex].unlockHash;\r\n    }\r\n\r\n    /**\r\n     * Releases funds from a behavior lock if; a) given correct code OR b) a year has passed since the lock was cretaed.\r\n     * @notice Funds are return to the vault's lockable balance. Withdrawal from the vault requires a new lock be created\r\n     * @param _tokenAddress token contract address or address(0) for native coin\r\n     * @param _lockIndex lock index (for this token)\r\n     * @param _unlockCode clear text 'secret' unlock code (cAse senstitve)\r\n     */\r\n    function claimBehaviorLock(\r\n        address _tokenAddress,\r\n        uint256 _lockIndex,\r\n        string memory _unlockCode\r\n    )\r\n        public\r\n        payable\r\n        _onlyCapsuleOwner\r\n        _notPanicState\r\n    {\r\n        if (_locks[_tokenAddress][_lockIndex].lockTime > uint64(block.timestamp) - BEHAVIORLOCK_SECONDS) {\r\n            require(\r\n                checkBehaviorLockCode(_tokenAddress, _lockIndex, _unlockCode) == true,\r\n                \"Invalid code\"\r\n            );\r\n        }\r\n        _totalLockedAmount[_tokenAddress] -= _locks[_tokenAddress][_lockIndex].lockedAmount;\r\n        _locks[_tokenAddress][_lockIndex].unlockTime = uint64(block.timestamp);\r\n        releaseLock(_tokenAddress, _lockIndex);\r\n    }\r\n\r\n    /**\r\n     * Returns value of token or coin realeasable NOW \u2014 aka the current DRIP amount.\r\n     * @notice The actual value released by initiateWithdrawal() may differ \u2014 slightly higher.\r\n     * However, making this a public function allows users to get an idea of current drip\r\n     * amounts.\r\n     * @param _tokenAddress token contract address or address(0) for native coin\r\n     * @param _index lock index\r\n     * @return withdrawalAllowance currently available withdrawable balance (drip amount)\r\n     */\r\n    function calculateAllowance(\r\n        address _tokenAddress,\r\n        uint256 _index\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 withdrawalAllowance)\r\n    {\r\n        Lock memory lock = lockData(_tokenAddress, _index);\r\n\r\n        if (lock.withdrawnToDate >= lock.lockedAmount) {\r\n            withdrawalAllowance = 0;\r\n        } else if (block.timestamp < (lock.lockTime - ONE_HOUR) || block.timestamp >= lock.unlockTime) {\r\n            if (lock.withdrawnToDate >= lock.lockedAmount) {\r\n                withdrawalAllowance = 0;\r\n            } else {\r\n                withdrawalAllowance = lock.lockedAmount - lock.withdrawnToDate;\r\n            }\r\n        } else {\r\n            uint256 lockTerm = lock.unlockTime - lock.lockTime;\r\n            uint256 termServed = ((block.timestamp - lock.lockTime) * 10000 ) / lockTerm ; // 10000 => 100.00% of term\r\n\r\n            uint256 totalPortionFromStart = lock.lockedAmount * termServed;\r\n            unchecked { // division undeflow acceptable (discard remainer)\r\n                totalPortionFromStart /= 10000;\r\n            }\r\n\r\n            if (lock.withdrawnToDate >= totalPortionFromStart) withdrawalAllowance = 0;\r\n            else withdrawalAllowance = totalPortionFromStart - lock.withdrawnToDate;\r\n\r\n            // Web UI uses this function to display currently available \"drip\" amounts. So, we\r\n            // account for a pending withdrawal by not including that amount in the returned allowance.\r\n            if (lock.timelockedAmount >= withdrawalAllowance) withdrawalAllowance = 0;\r\n            else withdrawalAllowance -= lock.timelockedAmount;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Releases any remaining balance in a lock without need of withdrawal.\r\n     * Reverts if unlock time not yet reached.\r\n     * @param _tokenAddress token contract address or address(0) for native coin\r\n     * @param _lockIndex lock index (for this token)\r\n     * @custom:emits LockReleased(tokenAddress, lockIndex)\r\n     */\r\n    function releaseLock(\r\n        address _tokenAddress,\r\n        uint256 _lockIndex\r\n    )\r\n        internal\r\n    {\r\n        Lock[] storage locksRef = _locks[_tokenAddress];\r\n        Lock storage lock = locksRef[_lockIndex];\r\n\r\n        require (\r\n            block.timestamp >= lock.unlockTime,\r\n            \"Before unlock time\"\r\n        );\r\n\r\n        // gas efficient removal of array element\r\n        uint256 lastIndex = locksRef.length - 1;\r\n        if (_lockIndex != lastIndex) locksRef[_lockIndex] = locksRef[lastIndex];\r\n        locksRef.pop();\r\n\r\n        emit LockReleased(\r\n            _tokenAddress,\r\n            _lockIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Initiates a seven day withdrawal timelock, after which sendWithdrawal() can be\r\n     * called to retrieve the funds.\r\n     * @notice Only ONE withdrawl may be active at a time for each token lock. (See `cancelWithdrawal()`, bellow.)\r\n     * @param _tokenAddress token contract address or address(0) for native coin\r\n     * @param _lockIndex lock index (for this token)\r\n     * @custom:emits WithdrawalInitiated(tokenAddress, lockIndex, withdrawalAllowance)\r\n     */\r\n    function initiateWithdrawal(\r\n        address _tokenAddress,\r\n        uint256 _lockIndex\r\n    )\r\n        public\r\n        _onlyCapsuleOwner\r\n        _notPanicState\r\n        returns (uint256 amount)\r\n    {\r\n        Lock[] storage locksRef = _locks[_tokenAddress];\r\n\r\n        require(locksRef.length > 0,\r\n            \"Lock not found\"\r\n        );\r\n        require(locksRef.length > _lockIndex,\r\n            \"Invalid lock index\"\r\n        );\r\n        require(locksRef[_lockIndex].state != LockState.WITHDRAWAL_PENDING,\r\n            \"Withdrawal already pending\"\r\n        );\r\n\r\n        Lock storage lock = locksRef[_lockIndex];\r\n\r\n        require(\r\n            lock.lockType != LockType.BEHAVIORAL,\r\n            \"Behavioral lock\"\r\n        );\r\n\r\n        if (lock.lockType == LockType.HARD && uint64(block.timestamp) < lock.unlockTime) {\r\n            revert HardLocked({\r\n                unlockTime: lock.unlockTime\r\n            });\r\n        }\r\n\r\n        uint256 withdrawalAllowance = calculateAllowance(\r\n            _tokenAddress,\r\n            _lockIndex\r\n        );\r\n        require(withdrawalAllowance > 0,\r\n            \"None available\"\r\n        );\r\n\r\n        lock.state = LockState.WITHDRAWAL_PENDING;\r\n        lock.timelockedAmount = withdrawalAllowance;\r\n        lock.releaseTime = uint64(block.timestamp) + TIMELOCK_SECONDS;\r\n\r\n        emit WithdrawalInitiated(\r\n            _tokenAddress,\r\n            _lockIndex,\r\n            withdrawalAllowance\r\n        );\r\n\r\n        amount = withdrawalAllowance;\r\n    }\r\n\r\n    /**\r\n     * Cancels a pending withdrawal\r\n     * @param _tokenAddress token contract address or address(0) for native coin\r\n     * @param _lockIndex lock index (for this token)\r\n     * @custom:emits WithdrawalCancelled(tokenAddress, lockIndex)\r\n     */\r\n    function cancelWithdrawal(\r\n        address _tokenAddress,\r\n        uint256 _lockIndex\r\n    )\r\n        public\r\n        _onlyCapsuleOwner\r\n    {\r\n        Lock[] storage locks = _locks[_tokenAddress];\r\n        require(locks.length > 0,\r\n            \"No matching lock found\"\r\n        );\r\n        require(locks.length > _lockIndex,\r\n            \"Invalid lock index\"\r\n        );\r\n        Lock storage lock = locks[_lockIndex];\r\n        require(lock.state == LockState.WITHDRAWAL_PENDING,\r\n            \"No withdrawal pending\"\r\n        );\r\n        lock.timelockedAmount = 0;\r\n        lock.state = LockState.INERT;\r\n\r\n        emit WithdrawalCancelled(\r\n            _tokenAddress,\r\n            _lockIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Sends a pending seven day timelocked withdrawal to the vault's owner (reverts if not yet time)\r\n     * @param _tokenAddress token contract address or address(0) for native coin\r\n     * @param _lockIndex lock index (for this token)\r\n     * @custom:emits Withdrawal(tokenAddress, lockIndex, withdrawalAmount)\r\n     */\r\n    function sendWithdrawal(\r\n        address _tokenAddress,\r\n        uint256 _lockIndex\r\n    )\r\n        public\r\n        _onlyCapsuleOwner\r\n        _notPanicState\r\n    {\r\n        Lock[] storage locksRef = _locks[_tokenAddress];\r\n        Lock storage lock = locksRef[_lockIndex];\r\n\r\n        require(\r\n            lock.state == LockState.WITHDRAWAL_PENDING,\r\n            \"No withdrawal pending\"\r\n        );\r\n        require(\r\n            lock.timelockedAmount > 0,\r\n            \"No withdrawal pending\"\r\n        );\r\n\r\n        require(\r\n            block.timestamp >= lock.releaseTime,\r\n            \"Timelocked\"\r\n        );\r\n\r\n        /**\r\n         * @dev !IMPORTANT!: Clear the balance owed BEFORE calling sender's\r\n         * potential contract address to avoid ye olde DAO dance (reentrance hack)\r\n         */\r\n        uint256 withdrawalAmount = lock.timelockedAmount;\r\n        lock.timelockedAmount = 0;\r\n\r\n        lock.withdrawnToDate += withdrawalAmount;\r\n\r\n        bool withdrawalTransferred = (_tokenAddress == NATIVE_COIN)\r\n            ?  _transferNative( owner, withdrawalAmount )\r\n            :  _transferToken( _tokenAddress, owner, withdrawalAmount )\r\n        ;\r\n        require (\r\n            withdrawalTransferred,\r\n            \"Withdrawal transfer failed\"\r\n        );\r\n\r\n        _totalLockedAmount[_tokenAddress] -= withdrawalAmount;\r\n\r\n        // check for last (emptying) withdrawal\r\n        if (lock.withdrawnToDate >= lock.lockedAmount) {\r\n            releaseLock(_tokenAddress, _lockIndex);\r\n        } else {\r\n            lock.releaseTime = 0; // gas discount\r\n            lock.state = LockState.INERT;\r\n        }\r\n\r\n        emit Withdrawal(\r\n            _tokenAddress,\r\n            _lockIndex,\r\n            withdrawalAmount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Splits a 65 byte (130 nibble) 'raw' signature into R, S, V components\r\n     * @param _signature 65 byte (130 nibble) 'raw' signature\r\n     * @return r signature R component\r\n     * @return s signature S component\r\n     * @return v signature V component\r\n     */\r\n    function _splitSignature(bytes memory _signature) private pure returns (bytes32 r, bytes32 s, uint8 v) {\r\n        assembly {\r\n            r := mload(add(_signature, 32))\r\n            s := mload(add(_signature, 64))\r\n            v := byte(0, mload(add(_signature, 96)))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recovers the address of the signer of a message hash\r\n     * @param _messageHash keccak256 (sha3) hash of the message signed\r\n     * @param _signature  65 byte (130 nibble) signature\r\n     */\r\n    function __recoverSignerAddress(\r\n        bytes32 _messageHash,\r\n        bytes memory _signature\r\n    )\r\n        private\r\n        pure\r\n        returns (address signerAddress)\r\n    {\r\n        (bytes32 r,bytes32 s, uint8 v) = _splitSignature(_signature);\r\n        signerAddress = ecrecover(_messageHash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * Recovers the address of the signer of a arbitrary length message\r\n     * @param _message the signed message\r\n     * @param _signature signature\r\n     */\r\n    function _recoverSignerAddress(\r\n        string memory _message,\r\n        bytes memory _signature\r\n    )\r\n        private\r\n        pure\r\n        returns (address signerAddress)\r\n    {\r\n        if (_signature.length != 65) return INVALID_SIGNER_ADDRESS;\r\n\r\n        bytes32 _messageHash = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19Ethereum Signed Message:\\n\",\r\n                Strings.toString(bytes(_message).length),\r\n                bytes(_message)\r\n            )\r\n        );\r\n\r\n        signerAddress = __recoverSignerAddress(_messageHash, _signature);\r\n    }\r\n\r\n    /**\r\n     * @notice internal function\r\n     */\r\n    function _panic() internal {\r\n        require(\r\n            _vaultStatus == VaultStatus.NOMINAL,\r\n            \"Panic is once only. Good luck!\"\r\n        );\r\n        require(\r\n            _capsuleFactory.isRecoveryHashValidated(owner) == true,\r\n            \"No recovery address\"\r\n        );\r\n\r\n        _vaultStatus = VaultStatus.PANIC;\r\n\r\n        emit RecoveryInitiated();\r\n    }\r\n\r\n    /**\r\n     * Places the vault into PANIC state. NON-REVERSIBLE \u2014 vault must be recovered to.\r\n     * NON-REVERSIBLE \u2014 vault must be \"recovered\" to regain functional access \u2014 see recoverVault()\r\n     * @notice Two versions \u2014 see also panic(bytes memory _signature)\r\n     */\r\n    function panic() public _onlyCapsuleOwner {\r\n         _panic();\r\n    }\r\n\r\n    /**\r\n     * Allows anyone with an off-chain signed message from the original owner to place\r\n     * the vault into PANIC state. NON-REVERSIBLE \u2014 vault must be \"recovered\" to regain\r\n     * functional access \u2014 see recoverVault()\r\n     * @notice Two versions \u2014 see also panic()\r\n     */\r\n    function panic(\r\n        bytes memory _signature\r\n    )\r\n        public\r\n    {\r\n        address signerAddress = _recoverSignerAddress(VAULT_RECOVERY_AUTHORIZATION, _signature);\r\n        require(signerAddress == owner, \"Invalid signature\");\r\n        _panic();\r\n    }\r\n\r\n    /**\r\n     * Recovers a vault from PANIC state \u2014 see panic() & panic(bytes memory _signature. (Also known as \"undo a hack\".)\r\n     * Recovery can only be executed by the recovery address, which will become the vault's effective new owner.\r\n     * The PANIC / RECOVERY process can only be executed ONCE. Don't get hacked again!\r\n     * @notice internal function\r\n     * @param _originalOwner address of original owner\r\n     */\r\n    function _recoverVault(\r\n        address _originalOwner\r\n    )\r\n        internal\r\n    {\r\n        address _newOwner = msg.sender; // set local owner variable to new owner\r\n\r\n        // update the factory contract's recovery and owner address mappings\r\n        // reverts if vault's recoveryAddressHash does not match keccak256(_newOwner)\r\n        _capsuleFactory.recoverOwnership(\r\n            _originalOwner,\r\n            _newOwner\r\n        );\r\n        owner = _newOwner;\r\n\r\n        _vaultStatus = VaultStatus.RECOVERED;\r\n        emit Recovered();\r\n    }\r\n\r\n    /**\r\n     * Recovers an EXPIRED vault \u2014 one that has not had any lock/unlock activity for\r\n     * a full year after the latest (most future) lock end time ever created.\r\n     * @notice Only the recovery account can do this.\r\n     * @param _originalOwner original owner's address\r\n     */\r\n    function recoverExpiredVault(\r\n        address _originalOwner\r\n    )\r\n        public\r\n    {\r\n        uint64 deadmanRecoveryTime = _deadmanTime + ONE_YEAR;  // latest ever unlockTime plus one year\r\n        uint64 blockTime = (uint64)(block.timestamp);\r\n        require(blockTime >= deadmanRecoveryTime, \"Vault not expired\");\r\n         _recoverVault(_originalOwner);\r\n    }\r\n\r\n    /**\r\n     * Recovers a vault from PANIC state, passing ownership to the caller.\r\n     * The vault must be in PANIC state and caller must be the recovery address\r\n     * itself (according to stored recoveryAddressHash.)\r\n     **/\r\n    function recoverVault(\r\n        address _originalOwner\r\n    )\r\n        public\r\n    {\r\n        require(_vaultStatus == VaultStatus.PANIC, \"Forbidden\");\r\n        _recoverVault(_originalOwner);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"unlockTime\",\"type\":\"uint64\"}],\"name\":\"HardLocked\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"grossBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"alreadyLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableToLock\",\"type\":\"uint256\"}],\"name\":\"InsufficientFunds\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockIndex\",\"type\":\"uint256\"}],\"name\":\"LockReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"tag\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum TimeCapsuleContext.LockType\",\"name\":\"lockType\",\"type\":\"uint8\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Recovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RecoveryInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockIndex\",\"type\":\"uint256\"}],\"name\":\"WithdrawalCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawalInitiated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"availableBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"calculateAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawalAllowance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockIndex\",\"type\":\"uint256\"}],\"name\":\"cancelWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockIndex\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_unlockCode\",\"type\":\"string\"}],\"name\":\"checkBehaviorLockCode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"correct\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_recoveryAddressHash\",\"type\":\"bytes32\"}],\"name\":\"checkRecoveryAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"confirmed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockIndex\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_unlockCode\",\"type\":\"string\"}],\"name\":\"claimBehaviorLock\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_tag\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_lockTime\",\"type\":\"uint64\"},{\"internalType\":\"bytes6\",\"name\":\"_unlockHash\",\"type\":\"bytes6\"}],\"name\":\"createBehaviorLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lockIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_tag\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_lockTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_unlockTime\",\"type\":\"uint64\"}],\"name\":\"createHardLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lockIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_tag\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_lockTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_unlockTime\",\"type\":\"uint64\"}],\"name\":\"createLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lockIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factoryAddress\",\"type\":\"address\"},{\"internalType\":\"contract IFeeSplitter\",\"name\":\"_feeSplitterContract\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockIndex\",\"type\":\"uint256\"}],\"name\":\"initiateWithdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRecoveryHashValidated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"validated\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"lockCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"lockData\",\"outputs\":[{\"components\":[{\"internalType\":\"enum TimeCapsuleContext.LockState\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"tag\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"lockTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"unlockTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"releaseTime\",\"type\":\"uint64\"},{\"internalType\":\"enum TimeCapsuleContext.LockType\",\"name\":\"lockType\",\"type\":\"uint8\"},{\"internalType\":\"bytes6\",\"name\":\"unlockHash\",\"type\":\"bytes6\"},{\"internalType\":\"uint256\",\"name\":\"lockedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnToDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timelockedAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct TimeCapsuleContext.Lock\",\"name\":\"lock\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"panic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"panic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_originalOwner\",\"type\":\"address\"}],\"name\":\"recoverExpiredVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_originalOwner\",\"type\":\"address\"}],\"name\":\"recoverVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockIndex\",\"type\":\"uint256\"}],\"name\":\"sendWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_recoveryAddressHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"validateRecoveryAddressHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultStatus\",\"outputs\":[{\"internalType\":\"enum TimeCapsuleContext.VaultStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TimeCapsule", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9d2e749606359036805ac3472864a42b00d9c030766a775ad01e15b6a9d1a40a"}