{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\nlibrary Math {\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        z = x > y ? x : y;\r\n    }\r\n}\r\n\r\ninterface ve {\r\n    struct Point {\r\n        int128 bias;\r\n        int128 slope;\r\n        uint ts;\r\n        uint blk;\r\n    }\r\n    \r\n    function user_point_epoch(address) external view returns (uint);\r\n    function user_point_history(address, uint) external view returns (Point memory);\r\n}\r\n\r\ninterface fee {\r\n    function last_token_time() external view returns (uint);\r\n    function start_time() external view returns (uint);\r\n    function time_cursor_of(address) external view returns (uint);\r\n    function user_epoch_of(address) external view returns (uint);\r\n    function tokens_per_week(uint) external view returns (uint);\r\n    function ve_supply(uint) external view returns (uint);\r\n}\r\n\r\ncontract FeeDistributionLookup {\r\n    address constant _fee = 0x27761EfEb0C7b411e71d0fd0AeE5DDe35c810CC2;\r\n    address constant _veibff = 0x4D0518C9136025903751209dDDdf6C67067357b1;\r\n    uint constant WEEK = 7 * 86400;\r\n    \r\n    function claimable(address addr) external view returns (uint _to_distribute) {\r\n        uint _last_token_time = fee(_fee).last_token_time() / WEEK * WEEK;\r\n        uint _user_epoch = 0;\r\n        uint _max_user_epoch = ve(_veibff).user_point_epoch(addr);\r\n        uint _start_time = fee(_fee).start_time();\r\n        if (_max_user_epoch == 0) {\r\n            return 0;\r\n        }\r\n        uint _week_cursor = fee(_fee).time_cursor_of(addr);\r\n        if (_week_cursor == 0) {\r\n            _user_epoch = _find_timestamp_user_epoch(addr, _start_time, _max_user_epoch);\r\n        } else {\r\n            _user_epoch = fee(_fee).user_epoch_of(addr);\r\n        }\r\n        \r\n        if (_user_epoch == 0) {\r\n            _user_epoch = 1;\r\n        }\r\n        \r\n        ve.Point memory _user_point = ve(_veibff).user_point_history(addr, _user_epoch);\r\n        if (_week_cursor == 0) {\r\n            _week_cursor = (_user_point.ts + WEEK - 1) / WEEK * WEEK;\r\n        }\r\n        \r\n        if (_week_cursor >= _last_token_time) {\r\n            return 0;\r\n        }\r\n        if (_week_cursor < _start_time) {\r\n            _week_cursor = _start_time;\r\n        }\r\n        ve.Point memory _old_user_point;\r\n        \r\n        for (uint i = 0; i < 50; i++) {\r\n            if (_week_cursor >= _last_token_time) {\r\n                break;\r\n            }\r\n            if (_week_cursor >= _user_point.ts && _user_epoch <= _max_user_epoch) {\r\n                _user_epoch += 1;\r\n                _old_user_point = _user_point;\r\n                if (_user_epoch <= _max_user_epoch) {\r\n                    _user_point = ve(_veibff).user_point_history(addr, _user_epoch);\r\n                }\r\n            } else {\r\n                int _dt = int(_week_cursor) - int(_old_user_point.ts);\r\n                uint _balance_of = Math.max(uint(_old_user_point.bias - _dt * _old_user_point.slope), 0);\r\n                if (_balance_of == 0 && _user_epoch > _max_user_epoch) {\r\n                    break;\r\n                }\r\n                if (_balance_of > 0) {\r\n                    _to_distribute += _balance_of * fee(_fee).tokens_per_week(_week_cursor) / fee(_fee).ve_supply(_week_cursor);\r\n                }\r\n                _week_cursor += WEEK;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function _find_timestamp_user_epoch(address user, uint _timestamp, uint _max_user_epoch) internal view returns (uint) {\r\n        uint _min = 0;\r\n        uint _max = _max_user_epoch;\r\n        for (uint i = 0; i < 128; i++) {\r\n            if (_min >= _max) {\r\n                break;\r\n            }\r\n            uint _mid = (_min + _max + 2) / 2;\r\n            ve.Point memory _pt = ve(_veibff).user_point_history(user, _mid);\r\n            if (_pt.ts <= _timestamp) {\r\n                _min = _mid;\r\n            } else {\r\n                _max = _mid - 1;\r\n            }\r\n        }\r\n        return _min;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_to_distribute\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FeeDistributionLookup", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8b548ec81313070548d748a492a82b269ebff09730daa842fd27cc2deebf2107"}