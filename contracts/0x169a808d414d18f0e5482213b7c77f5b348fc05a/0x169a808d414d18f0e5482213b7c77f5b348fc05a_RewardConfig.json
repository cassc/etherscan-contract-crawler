{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity 0.8.21;\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ncontract RewardConfig is Ownable {\r\n    struct RewardInfo {\r\n        address rewardToken;\r\n        uint256 epochStart;\r\n        uint256 epochEnd;\r\n        uint256 amount;\r\n        uint256 decimal;\r\n    }\r\n\r\n    struct AggregatorData {\r\n        address aggregator;\r\n        RewardInfo[] rewardInfo;\r\n    }\r\n\r\n    address[] private _aggregators;\r\n    // aggregator -> reward token array\r\n    mapping(address => address[]) private _aggregatorToRewardTokens;\r\n    // aggregator -> reward token -> reawrd info\r\n    mapping(address => mapping(address => RewardInfo)) private _aggregatorToRewardInfos;\r\n\r\n    event SetRewardInfo(\r\n        address aggregator,\r\n        address rewardToken,\r\n        uint256 epochStart,\r\n        uint256 epochEnd,\r\n        uint256 amount,\r\n        uint256 decimals\r\n    );\r\n    event RemoveAggregator(address aggregator);\r\n    event RemoveRewardToken(address aggregator, address rewardToken);\r\n\r\n    /**\r\n     * @dev Set reward info to aggregator\r\n     * - Caller is Admin\r\n     * @param _aggregator The aggregator address.\r\n     * @param _rewardToken The reward token address.\r\n     * @param _epochStart The reward epoch start block number.\r\n     * @param _epochEnd The reward epoch end block number.\r\n     * @param _amount The reward token count amount.\r\n     */\r\n    function setRewardInfo(\r\n        address _aggregator,\r\n        address _rewardToken,\r\n        uint256 _epochStart,\r\n        uint256 _epochEnd,\r\n        uint256 _amount\r\n    ) external payable onlyOwner {\r\n        uint256 decimals = IERC20Metadata(_rewardToken).decimals();\r\n        uint256 count = _aggregators.length;\r\n        bool isExist;\r\n\r\n        // check and register aggregator\r\n        for (uint256 i; i < count; ++i) {\r\n            if (_aggregators[i] == _aggregator) {\r\n                isExist = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!isExist) {\r\n            _aggregators.push(_aggregator);\r\n        }\r\n\r\n        // check and register reward token\r\n        address[] memory aggregatorRewardTokens = _aggregatorToRewardTokens[_aggregator];\r\n        count = aggregatorRewardTokens.length;\r\n        isExist = false;\r\n\r\n        for (uint256 i; i < count; ++i) {\r\n            if (aggregatorRewardTokens[i] == _rewardToken) {\r\n                isExist = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!isExist) {\r\n            _aggregatorToRewardTokens[_aggregator].push(_rewardToken);\r\n        }\r\n\r\n        // set reard info\r\n        _aggregatorToRewardInfos[_aggregator][_rewardToken] = RewardInfo(\r\n            _rewardToken,\r\n            _epochStart,\r\n            _epochEnd,\r\n            _amount,\r\n            decimals\r\n        );\r\n\r\n        emit SetRewardInfo(_aggregator, _rewardToken, _epochStart, _epochEnd, _amount, decimals);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove the aggregator reward info\r\n     * - Caller is Admin\r\n     * @param _aggregator The aggregator address.\r\n     */\r\n    function removeAggregator(address _aggregator) external payable onlyOwner {\r\n        uint256 count = _aggregators.length;\r\n\r\n        for (uint256 i; i < count; ++i) {\r\n            if (_aggregators[i] == _aggregator) {\r\n                if (i < count - 1) {\r\n                    _aggregators[i] = _aggregators[count - 1];\r\n                }\r\n                _aggregators.pop();\r\n                break;\r\n            }\r\n        }\r\n\r\n        delete _aggregatorToRewardTokens[_aggregator];\r\n\r\n        emit RemoveAggregator(_aggregator);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove the reward token from aggregator\r\n     * - Caller is Admin\r\n     * @param _aggregator The aggregator address.\r\n     * @param _rewardToken The aggregator address.\r\n     */\r\n    function removeRewardToken(address _aggregator, address _rewardToken) external payable onlyOwner {\r\n        uint256 count = _aggregatorToRewardTokens[_aggregator].length;\r\n\r\n        for (uint256 i; i < count; ++i) {\r\n            if (_aggregatorToRewardTokens[_aggregator][i] == _rewardToken) {\r\n                if (i < count - 1) {\r\n                    _aggregatorToRewardTokens[_aggregator][i] = _aggregatorToRewardTokens[_aggregator][count - 1];\r\n                }\r\n                _aggregatorToRewardTokens[_aggregator].pop();\r\n                break;\r\n            }\r\n        }\r\n\r\n        delete _aggregatorToRewardInfos[_aggregator][_rewardToken];\r\n\r\n        emit RemoveRewardToken(_aggregator, _rewardToken);\r\n    }\r\n\r\n    /**\r\n     * @dev Get all reward config\r\n     */\r\n    function getAllRewardInfo() external view returns (AggregatorData[] memory) {\r\n        uint256 aggregatorCount = _aggregators.length;\r\n        AggregatorData[] memory result = new AggregatorData[](aggregatorCount);\r\n\r\n        for (uint256 i; i < aggregatorCount; ++i) {\r\n            address aggregator = _aggregators[i];\r\n            uint256 rewardTokenCount = _aggregatorToRewardTokens[aggregator].length;\r\n            RewardInfo[] memory rewardInfo = new RewardInfo[](rewardTokenCount);\r\n            \r\n            for (uint256 j; j < rewardTokenCount; ++j) {\r\n                address rewardToken = _aggregatorToRewardTokens[aggregator][j];\r\n\r\n                rewardInfo[j] = _aggregatorToRewardInfos[aggregator][rewardToken];\r\n            }\r\n\r\n            result[i] = AggregatorData(\r\n                aggregator,\r\n                rewardInfo\r\n            );\r\n        }\r\n\r\n        return result;\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"}],\"name\":\"RemoveAggregator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"}],\"name\":\"RemoveRewardToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochEnd\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"SetRewardInfo\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"getAllRewardInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epochStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epochEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decimal\",\"type\":\"uint256\"}],\"internalType\":\"struct RewardConfig.RewardInfo[]\",\"name\":\"rewardInfo\",\"type\":\"tuple[]\"}],\"internalType\":\"struct RewardConfig.AggregatorData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_aggregator\",\"type\":\"address\"}],\"name\":\"removeAggregator\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_aggregator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"}],\"name\":\"removeRewardToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_aggregator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_epochStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_epochEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setRewardInfo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RewardConfig", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://47b66b751a61e9307ce05d5dfbb77d52be4de20660fec98a1b9fa76aebce1823"}