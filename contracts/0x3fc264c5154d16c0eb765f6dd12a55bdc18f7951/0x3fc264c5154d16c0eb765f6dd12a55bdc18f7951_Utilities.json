{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/Utilities.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.19;\\r\\n\\r\\nimport \\\"./interfaces/IRewards.sol\\\";\\r\\nimport \\\"./interfaces/ITokenLocker.sol\\\";\\r\\n\\r\\n/*\\r\\nThis is a utility library which is mainly used for off chain calculations\\r\\n*/\\r\\ncontract Utilities{\\r\\n\\r\\n    address public immutable cvxprismaStaking;\\r\\n    address public immutable prismaLocker;\\r\\n    address public immutable voteproxy;\\r\\n\\r\\n    constructor(address _voteproxy, address _prismaLocker, address _staking) {\\r\\n        voteproxy = _voteproxy;\\r\\n        prismaLocker = _prismaLocker;\\r\\n        cvxprismaStaking = _staking;\\r\\n    }\\r\\n\\r\\n    function lockedPrisma() external view returns(uint256){\\r\\n        (uint256 lockedAmount,) = ITokenLocker(prismaLocker).getAccountBalances(voteproxy);\\r\\n        return lockedAmount * ITokenLocker(prismaLocker).lockToTokenRatio();\\r\\n    }\\r\\n\\r\\n\\r\\n    //get apr with given rates and prices\\r\\n    function apr(uint256 _rate, uint256 _priceOfReward, uint256 _priceOfDeposit) external pure returns(uint256 _apr){\\r\\n        return _rate * 365 days * _priceOfReward / _priceOfDeposit; \\r\\n    }\\r\\n\\r\\n    //get reward rates for each token based on weighted reward group supply and wrapper's boosted cvxcrv rates\\r\\n    //%return = rate * timeFrame * price of reward / price of LP / 1e18\\r\\n    function stakingRewardRates() external view returns (address[] memory tokens, uint256[] memory rates) {\\r\\n\\r\\n        //get staked supply\\r\\n        uint256 stakedSupply = IRewards(cvxprismaStaking).totalSupply();\\r\\n\\r\\n        uint256 rewardTokens = IRewards(cvxprismaStaking).rewardTokenLength();\\r\\n\\r\\n        tokens = new address[](rewardTokens);\\r\\n        rates = new uint256[](rewardTokens);\\r\\n\\r\\n        //loop through all reward contracts\\r\\n        for (uint256 i = 0; i < rewardTokens; i++) {\\r\\n            //get token\\r\\n            tokens[i] = IRewards(cvxprismaStaking).rewardTokens(i);\\r\\n\\r\\n            //get rate\\r\\n            (uint256 periodFinish , uint256 rate, , ) = IRewards(cvxprismaStaking).rewardData(tokens[i]);\\r\\n            \\r\\n            if(block.timestamp > periodFinish){\\r\\n                rate = 0;\\r\\n            }\\r\\n\\r\\n            //rate per 1 staked lp\\r\\n            if(stakedSupply > 0){\\r\\n                rate = rate * 1e18 / stakedSupply;\\r\\n            }\\r\\n            \\r\\n            rates[i] = rate;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/interfaces/ITokenLocker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.19;\\r\\n\\r\\ninterface ITokenLocker {\\r\\n    struct LockData {\\r\\n        uint amount;\\r\\n        uint weeksToUnlock;\\r\\n    }\\r\\n\\r\\n    function lock(address _account, uint256 _amount, uint256 _weeks) external returns (bool);\\r\\n    function withdrawExpiredLocks(uint256 _weeks) external returns (bool);\\r\\n    function withdrawWithPenalty(uint amountToWithdraw) external returns (uint);\\r\\n\\r\\n    function getAccountBalances(address account) external view returns (uint256 locked, uint256 unlocked);\\r\\n    function getAccountActiveLocks(\\r\\n        address account,\\r\\n        uint minWeeks\\r\\n    ) external view returns (LockData[] memory lockData, uint frozenAmount);\\r\\n\\r\\n    function getAccountWeightAt(address account, uint week) external view returns (uint256);\\r\\n\\r\\n    function getTotalWeightAt(uint week) external view returns (uint256);\\r\\n\\r\\n    function getWithdrawWithPenaltyAmounts(address account, uint amountToWithdraw) external view returns (uint amountWithdrawn, uint penaltyAmountPaid);\\r\\n\\r\\n    function lockToTokenRatio() external view returns (uint256);\\r\\n\\r\\n    function freeze() external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/interfaces/IRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.19;\\r\\n\\r\\ninterface IRewards{\\r\\n\\r\\n    struct EarnedData {\\r\\n        address token;\\r\\n        uint256 amount;\\r\\n    }\\r\\n    \\r\\n    function initialize(uint256 _pid, bool _startActive) external;\\r\\n    function addReward(address _rewardsToken, address _distributor) external;\\r\\n    function approveRewardDistributor(\\r\\n        address _rewardsToken,\\r\\n        address _distributor,\\r\\n        bool _approved\\r\\n    ) external;\\r\\n    function deposit(address _owner, uint256 _amount) external;\\r\\n    function withdraw(address _owner, uint256 _amount) external;\\r\\n    function getReward(address _forward) external;\\r\\n    function notifyRewardAmount(address _rewardsToken, uint256 _reward) external;\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function claimableRewards(address _account) external view returns(EarnedData[] memory userRewards);\\r\\n    function rewardTokens(uint256 _rid) external view returns (address);\\r\\n    function rewardTokenLength() external view returns(uint256);\\r\\n    function rewardData(address _token) external view returns(uint256 periodFinish, uint256 rewardRate, uint256 lastUpdate, uint256 rewardPerTokenStored);\\r\\n    function totalSupply() external view returns(uint256);\\r\\n    function active() external view returns(bool);\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_voteproxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_prismaLocker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_staking\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceOfReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceOfDeposit\",\"type\":\"uint256\"}],\"name\":\"apr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_apr\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cvxprismaStaking\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedPrisma\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prismaLocker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingRewardRates\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rates\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteproxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Utilities", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008ad7a9e2b3cd9214f36cb871336d8ab34ddfdd5b0000000000000000000000003f78544364c3eccdce4d9c89a630aea26122829d0000000000000000000000000c73f1cfd5c9dfc150c8707aa47acbd14f0be108", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}