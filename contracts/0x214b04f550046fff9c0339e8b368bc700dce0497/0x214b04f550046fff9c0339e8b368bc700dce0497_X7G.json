{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/X7G.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/*\\n  __  __     ____   _   _      _      _   _     ____  U _____ u\\n  \\\\ \\\\/\\\"/  U /\\\"___| |'| |'| U  /\\\"\\\\  u | \\\\ |\\\"| U /\\\"___|u\\\\| ___\\\"|/\\n  /\\\\  /\\\\  \\\\| | u  /| |_| |\\\\ \\\\/ _ \\\\/ <|  \\\\| |>\\\\| |  _ / |  _|\\\"\\n U /  \\\\ u  | |/__ U|  _  |u / ___ \\\\ U| |\\\\  |u | |_| |  | |___\\n  /_/\\\\_\\\\    \\\\____| |_| |_| /_/   \\\\_\\\\ |_| \\\\_|   \\\\____|  |_____|\\n,-,>> \\\\\\\\_  _// \\\\\\\\  //   \\\\\\\\  \\\\\\\\    >> ||   \\\\\\\\,-._)(|_   <<   >>\\n \\\\_)  (__)(__)(__)(_\\\") (\\\"_)(__)  (__)(_\\\")  (_/(__)__) (__) (__)\\n           ____      _      __  __  U _____ u ____\\n        U /\\\"___|uU  /\\\"\\\\  uU|' \\\\/ '|u\\\\| ___\\\"|// __\\\"| u\\n        \\\\| |  _ / \\\\/ _ \\\\/ \\\\| |\\\\/| |/ |  _|\\\" <\\\\___ \\\\/\\n         | |_| |  / ___ \\\\  | |  | |  | |___  u___) |\\n          \\\\____| /_/   \\\\_\\\\ |_|  |_|  |_____| |____/>>\\n          _)(|_   \\\\\\\\    >><<,-,,-.   <<   >>  )(  (__)\\n         (__)__) (__)  (__)(./  \\\\.) (__) (__)(__)\\n\\n Contract: X7G token\\n Created by: https://t.me/smart_bart\\n*/\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\\ninterface IERC20Metadata is IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\\ninterface IRouter {\\n    function factory() external view returns (address);\\n\\n    function WETH() external view returns (address);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n    external\\n    payable\\n    returns (\\n        uint256 amountToken,\\n        uint256 amountETH,\\n        uint256 liquidity\\n    );\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\\ninterface IFactory {\\n    event PairCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        address pair,\\n        uint\\n    );\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n}\\n\\ninterface IWETH is IERC20 {\\n    function withdraw(uint256) external;\\n}\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n    unchecked {\\n        _approve(owner, spender, currentAllowance - subtractedValue);\\n    }\\n\\n        return true;\\n    }\\n\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n    unchecked {\\n        _balances[from] = fromBalance - amount;\\n        _balances[to] += amount;\\n    }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n    unchecked {\\n        _balances[account] += amount;\\n    }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n    unchecked {\\n        _balances[account] = accountBalance - amount;\\n        _totalSupply -= amount;\\n    }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - amount);\\n        }\\n        }\\n    }\\n\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\ncontract X7G is ERC20, Ownable {\\n    modifier lockTheSwap() {\\n        processingFees = true;\\n        _;\\n        processingFees = false;\\n    }\\n\\n    bool private processingFees = false;\\n\\n    IRouter public router;\\n    address public automatedMarketMakerAddress;\\n    mapping(address => bool) public automatedMarketMakerPair;\\n\\n    uint256 private _maxFee = 7000;\\n    uint256 public fee;\\n    uint256 public burnAndLiquidityShare;\\n    uint256 public treasuryShare;\\n    uint256 public operationsShare;\\n\\n    uint256 public maxWallet;\\n    uint256 public thresholdToProcessFees;\\n\\n    address public treasury;\\n    address public operations;\\n    address public x7rContract;\\n\\n    mapping(address => bool) excludedAddresses;\\n\\n    bool public tradingEnabled = false;\\n\\n    event AMMSet(address indexed pairAddress, bool isAMM);\\n    event TradingEnabled();\\n    event NewTreasurySet(address newTreasury);\\n    event NewOperationsWalletSet(address newOperationsWallet);\\n    event ThresholdToProcessFeesSet(uint256 oldThreshold, uint256 newThreshold);\\n    event MaxWalletSet(uint256 oldMaxWallet, uint256 newMaxWallet);\\n    event FeeSet(uint256 oldFee, uint256 newFee);\\n    event FeeSharesSet(\\n        uint256 newBurnAndLiquidityShare,\\n        uint256 newTreasuryShare,\\n        uint256 newOpsShare\\n    );\\n    event FeesProcessed();\\n    event ExcludedAddressSet(address indexed excludedAddress, bool isExcluded);\\n    event Launched();\\n\\n    constructor()\\n    ERC20(\\\"Xchange Games\\\", \\\"X7G\\\")\\n    {\\n        _mint(_msgSender(), 100000000 * 1e18);\\n\\n        excludedAddresses[address(_msgSender())] = true;\\n        excludedAddresses[address(0x740015c39da5D148fcA25A467399D00bcE10c001)] = true;\\n        x7rContract = address(0x70008F18Fc58928dcE982b0A69C2c21ff80Dca54);\\n    }\\n\\n    receive() external payable {}\\n\\n    function launch() public onlyOwner {\\n        // Create Xchange pair and set AMM in contract\\n        router = IRouter(0x7DE8063E9fB43321d2100e8Ddae5167F56A50060);\\n        address _pair = IFactory(router.factory()).createPair(address(this), router.WETH());\\n        setAMM(address(_pair), true);\\n\\n        // Set wallet addresses\\n        treasury = address(0x47689fbAE45816Ea67c3C29BC46D2ff0961cb513);\\n        operations = address(0x87b49D6A6910547493f841A95b4Ed94d2A5942DD);\\n\\n        // exclude router, lending pool, treasury and operations addresses\\n        excludedAddresses[address(router)] = true;\\n        excludedAddresses[address(treasury)] = true;\\n        excludedAddresses[address(operations)] = true;\\n\\n        // set fee and fee shares\\n        fee = 3000;\\n        burnAndLiquidityShare = 33333;\\n        treasuryShare = 33333;\\n        operationsShare = 33334;\\n\\n        // set maxWallet and thresholdToProcessFees\\n        maxWallet = 1000000 * 1e18;\\n        thresholdToProcessFees = 50000 * 1e18;\\n\\n        emit Launched();\\n    }\\n\\n    function setExcludedAddress(address excludedAddress, bool isExcluded) public onlyOwner {\\n        require(excludedAddress != address(0), \\\"X7G: (New) excluded address can not be address 0x\\\");\\n        excludedAddresses[excludedAddress] = isExcluded;\\n        emit ExcludedAddressSet(excludedAddress, isExcluded);\\n    }\\n\\n    function setAMM(address ammAddress, bool isAMM) public onlyOwner {\\n        require(ammAddress != address(0), \\\"X7G: (New) AMM address can not be address 0x\\\");\\n        automatedMarketMakerPair[ammAddress] = isAMM;\\n        automatedMarketMakerAddress = ammAddress;\\n        emit AMMSet(ammAddress, isAMM);\\n    }\\n\\n    function setThresholdToProcessFees(uint256 newThreshold) external onlyOwner {\\n        require(newThreshold >= 1000 * 1e18, \\\"X7G: 1000 X7G is the minmum\\\");\\n        uint256 _oldThreshold = thresholdToProcessFees;\\n        thresholdToProcessFees = newThreshold;\\n        emit ThresholdToProcessFeesSet(_oldThreshold, newThreshold);\\n    }\\n\\n    function setMaxWallet(uint256 _newMaxWallet) external onlyOwner {\\n        require(_newMaxWallet >= 500000 * 1e18, \\\"X7G: Max wallet is less the minimum then 0,5% of totalSupply\\\");\\n        require(_newMaxWallet <= 25000000 * 1e18, \\\"X7G: Max wallet is more the maximum than 25% of totalSupply\\\");\\n\\n        uint256 oldMaxWallet = maxWallet;\\n        maxWallet = _newMaxWallet;\\n        emit MaxWalletSet(oldMaxWallet, _newMaxWallet);\\n    }\\n\\n    function setFee(uint256 newFee) external onlyOwner {\\n        require(newFee <= _maxFee, \\\"X7G: Fee can not be set higher then the maximum of 7%\\\");\\n        require(newFee >= 0, \\\"X7G: Fee is less than 0\\\");\\n        require(newFee != fee, \\\"X7G: Fee is already that percentage\\\");\\n\\n        uint256 _oldFee = fee;\\n        fee = newFee;\\n        emit FeeSet(_oldFee, fee);\\n    }\\n\\n    function setFeeShares(uint256 _newBurnAndLiquidityShare, uint256 _newTreasuryShare, uint256 _newOperationsShare) external onlyOwner {\\n        require(_newBurnAndLiquidityShare + _newTreasuryShare + _newOperationsShare == 100000,\\n            \\\"X7G: Summed fee shares are not 100% (100000)!\\\"\\n        );\\n\\n        burnAndLiquidityShare = _newBurnAndLiquidityShare;\\n        treasuryShare = _newTreasuryShare;\\n        operationsShare = _newOperationsShare;\\n\\n        emit FeeSharesSet(\\n            _newBurnAndLiquidityShare,\\n            _newTreasuryShare,\\n            _newOperationsShare\\n        );\\n    }\\n\\n    function setTreasuryWallet(address _newTreasury) public onlyOwner {\\n        require(_newTreasury != address(0), \\\"X7G: New treasury can not be address 0x\\\");\\n        excludedAddresses[address(treasury)] = false;\\n        treasury = _newTreasury;\\n        excludedAddresses[address(_newTreasury)] = true;\\n        emit NewTreasurySet(_newTreasury);\\n    }\\n\\n    function setOperationsWallet(address _newOperationsWallet) public onlyOwner {\\n        require(_newOperationsWallet != address(0), \\\"X7G: New operations wallet can not be address 0x\\\");\\n        excludedAddresses[address(treasury)] = false;\\n        operations = _newOperationsWallet;\\n        excludedAddresses[address(_newOperationsWallet)] = true;\\n        emit NewOperationsWalletSet(_newOperationsWallet);\\n    }\\n\\n    function enableTrading() external onlyOwner {\\n        require(!tradingEnabled, \\\"X7G: Trading is already enabled\\\");\\n        tradingEnabled = true;\\n        emit TradingEnabled();\\n    }\\n\\n    function _transfer(address from, address to, uint256 amount) internal override {\\n        require(tradingEnabled || from == owner(), \\\"X7G: Trading will be enabled when the amm pair is set.\\\");\\n\\n        if (excludedAddresses[from] || excludedAddresses[to]) {\\n            super._transfer(from, to, amount);\\n            return;\\n        }\\n\\n        uint256 _transferAmount = amount;\\n\\n        if (automatedMarketMakerPair[from] || automatedMarketMakerPair[to]) {\\n            uint256 txnFee = (_transferAmount * fee) / 100000;\\n\\n            _transferAmount = _transferAmount - txnFee;\\n\\n            if (automatedMarketMakerPair[from]) {\\n                require(balanceOf(automatedMarketMakerPair[from] ? to : from) + _transferAmount <= maxWallet,\\n                    \\\"X7G: transaction exceeds max wallet\\\");\\n            }\\n\\n            super._transfer(from, address(this), txnFee);\\n        }\\n\\n        if (automatedMarketMakerPair[to] && !processingFees && balanceOf(address(this)) >= thresholdToProcessFees) {\\n            processFees();\\n        }\\n\\n        super._transfer(from, to, _transferAmount);\\n    }\\n\\n    function processFees() public lockTheSwap {\\n        uint256 _contractBalance = balanceOf(address(this));\\n\\n        require(_contractBalance != 0, \\\"X7G: cannot process fees if X7G balance is 0\\\");\\n\\n        // Calculate number of tokens\\n        uint256 _X7GLiquidityTokens = (_contractBalance * (((burnAndLiquidityShare / 2) / 2))) / 100000;\\n\\n        // Swap for ETH\\n        _swapTokensForEth(_contractBalance - _X7GLiquidityTokens);\\n\\n        // Calculate ETH balances\\n        uint256 _balance = address(this).balance;\\n\\n        require(_balance != 0, \\\"X7G: cannot process fees if ETH balance is 0\\\");\\n\\n        uint256 _ethForTreasury = (_balance * (treasuryShare / 4)) / 100000;\\n        uint256 _ethForOperations = (_balance * operationsShare) / 100000;\\n        uint256 _ethForX7GLiquidity = (_balance * (burnAndLiquidityShare / 2)) / 100000;\\n        uint256 _ethForX7RBurn = (_balance * (burnAndLiquidityShare / 2)) / 100000;\\n        uint256 _ethForX7RBuy = (_balance * (treasuryShare / 4) * 3) / 100000;\\n\\n        // Add liquidity\\n        _addLiquidityETH(\\n            address(this),\\n            _X7GLiquidityTokens,\\n            _ethForX7GLiquidity\\n        );\\n\\n        // Swap ETH for X7R and burn some and send some to the treasury\\n        _swapEthForTokens(\\n            _ethForX7RBurn + _ethForX7RBuy,\\n            address(x7rContract)\\n        );\\n\\n        uint256 _x7rBalance = IERC20(x7rContract).balanceOf(address(this));\\n        uint256 _total = _ethForX7RBurn + _ethForX7RBuy;\\n        uint256 _burnRatio;\\n        uint256 _treasuryRatio;\\n\\n        if (_total > 0) {\\n            _burnRatio = (_ethForX7RBurn * 1e18 / _total);\\n            _treasuryRatio = (_ethForX7RBuy * 1e18 / _total);\\n        }\\n\\n        uint256 _x7rForBurn = (_x7rBalance * _burnRatio) / 1e18;\\n        uint256 _x7rForTreasury = (_x7rBalance * _treasuryRatio) / 1e18;\\n\\n        IERC20(x7rContract).transfer(address(0x000000000000000000000000000000000000dEaD), _x7rForBurn);\\n        IERC20(x7rContract).transfer(address(treasury), _x7rForTreasury);\\n\\n        // Send ETH to treasury, dev and marketing\\n        (bool treasurySendSuccess,) = treasury.call{value : _ethForTreasury}(\\\"\\\");\\n        require(treasurySendSuccess, \\\"X7G: Transfer to treasury wallet failed.\\\");\\n        (bool operationsWalletSendSuccess,) = operations.call{value : _ethForOperations}(\\\"\\\");\\n        require(operationsWalletSendSuccess, \\\"X7G: Transfer to dev wallet failed.\\\");\\n\\n        emit FeesProcessed();\\n    }\\n\\n    function _swapTokensForEth(uint256 tokenAmount) internal {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = router.WETH();\\n\\n        _approve(address(this), address(router), tokenAmount);\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    function _swapEthForTokens(uint256 ethAmount, address tokenAddress) internal {\\n        address[] memory path = new address[](2);\\n        path[0] = router.WETH();\\n        path[1] = tokenAddress;\\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value : ethAmount}(\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    function _addLiquidityETH(address token, uint256 tokenAmount, uint256 ethAmount) internal {\\n        IERC20(token).approve(address(router), tokenAmount);\\n        router.addLiquidityETH{value : ethAmount}(\\n            token,\\n            tokenAmount,\\n            0,\\n            0,\\n            address(0),\\n            block.timestamp\\n        );\\n    }\\n\\n    function rescueWETH() external {\\n        address _weth = router.WETH();\\n        IWETH(_weth).withdraw(\\n            IERC20(_weth).balanceOf(address(this))\\n        );\\n    }\\n\\n    function rescueETH() external {\\n        uint256 _balance = address(this).balance;\\n        require(_balance > 0, \\\"X7G: No ETH to withdraw\\\");\\n\\n        (bool success,) = msg.sender.call{value : _balance}(\\\"\\\");\\n        require(success, \\\"X7G: ETH transfer failed\\\");\\n    }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pairAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAMM\",\"type\":\"bool\"}],\"name\":\"AMMSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"excludedAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludedAddressSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"FeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBurnAndLiquidityShare\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTreasuryShare\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newOpsShare\",\"type\":\"uint256\"}],\"name\":\"FeeSharesSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FeesProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Launched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMaxWallet\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxWallet\",\"type\":\"uint256\"}],\"name\":\"MaxWalletSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperationsWallet\",\"type\":\"address\"}],\"name\":\"NewOperationsWalletSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"NewTreasurySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"}],\"name\":\"ThresholdToProcessFeesSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TradingEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"automatedMarketMakerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnAndLiquidityShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operations\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operationsShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueWETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ammAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isAMM\",\"type\":\"bool\"}],\"name\":\"setAMM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"excludedAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"setExcludedAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newBurnAndLiquidityShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newTreasuryShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newOperationsShare\",\"type\":\"uint256\"}],\"name\":\"setFeeShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMaxWallet\",\"type\":\"uint256\"}],\"name\":\"setMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOperationsWallet\",\"type\":\"address\"}],\"name\":\"setOperationsWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"}],\"name\":\"setThresholdToProcessFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newTreasury\",\"type\":\"address\"}],\"name\":\"setTreasuryWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"thresholdToProcessFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"x7rContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "X7G", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}