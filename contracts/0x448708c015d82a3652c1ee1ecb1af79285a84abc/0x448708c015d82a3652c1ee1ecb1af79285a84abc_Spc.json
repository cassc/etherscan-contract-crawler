{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.19;\\r\\n\\r\\nimport { EIP712 } from \\\"./external/openzeppelin/draft-EIP712.sol\\\";\\r\\nimport { ECDSA } from \\\"./external/openzeppelin/ECDSA.sol\\\";\\r\\n\\r\\nimport { IERC20 } from \\\"./interfaces/IERC20.sol\\\";\\r\\n\\r\\ncontract ERC20 is IERC20, EIP712 {\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                            METADATA STORAGE\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    string public name;\\r\\n    string public symbol;\\r\\n    uint8 public immutable decimals;\\r\\n\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                            ERC20 STORAGE\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    uint256 public totalSupply;\\r\\n    mapping(address => uint256) public balanceOf;\\r\\n    mapping(address => mapping(address => uint256)) public allowance;\\r\\n\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                            EIP-2612 STORAGE\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\r\\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\r\\n    // keccak256(\\\"Transfer(address owner,address to,uint256 value,uint256 nonce,uint256 deadline)\\\");\\r\\n    bytes32 public constant TRANSFER_TYPEHASH = 0x42ce63790c28229c123925d83266e77c04d28784552ab68b350a9003226cbd59;\\r\\n    mapping(address => uint256) public override nonces;\\r\\n\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                            CONSTRUCTOR\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    constructor(\\r\\n        string memory _name,\\r\\n        string memory _symbol,\\r\\n        uint8 _decimals\\r\\n    ) EIP712(_name, \\\"1\\\") {\\r\\n        name = _name;\\r\\n        symbol = _symbol;\\r\\n        decimals = _decimals;\\r\\n    }\\r\\n\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                            ERC20 LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external override returns (bool) {\\r\\n        uint256 currentAllowance = allowance[sender][msg.sender];\\r\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\r\\n        if (currentAllowance < type(uint256).max) {\\r\\n            _approve(sender, msg.sender, currentAllowance - amount);\\r\\n        }\\r\\n        _transfer(sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\\r\\n        _approve(msg.sender, spender, allowance[msg.sender][spender] + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\\r\\n        uint256 currentAllowance = allowance[msg.sender][spender];\\r\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\r\\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        uint256 senderBalance = balanceOf[sender];\\r\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            balanceOf[sender] = senderBalance - amount;\\r\\n        }\\r\\n        balanceOf[recipient] += amount;\\r\\n\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    function _approve(\\r\\n        address _owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) private {\\r\\n        require(_owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        allowance[_owner][spender] = amount;\\r\\n        emit Approval(_owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                            BURN LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function burn(uint256 amount) external override returns (bool) {\\r\\n        _burn(msg.sender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function burnFrom(address account, uint256 amount) external override returns (bool) {\\r\\n        uint256 currentAllowance = allowance[account][msg.sender];\\r\\n        require(currentAllowance >= amount, \\\"ERC20: burn amount exceeds allowance\\\");\\r\\n        unchecked {\\r\\n            _approve(account, msg.sender, currentAllowance - amount);\\r\\n        }\\r\\n        _burn(account, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                       INTERNAL MINT/BURN LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function _mint(address account, uint256 amount) internal {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        totalSupply += amount;\\r\\n        balanceOf[account] += amount;\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    function _burn(address account, uint256 amount) internal {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        uint256 accountBalance = balanceOf[account];\\r\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            balanceOf[account] = accountBalance - amount;\\r\\n        }\\r\\n        totalSupply -= amount;\\r\\n\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                            EIP-2612 LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\\r\\n        return _domainSeparatorV4();\\r\\n    }\\r\\n\\r\\n    function permit(\\r\\n        address _owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external override {\\r\\n        require(_owner != address(0), \\\"ERC20Permit: zero address\\\");\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, _owner, spender, value, nonces[_owner]++, deadline));\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == _owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(_owner, spender, value);\\r\\n    }\\r\\n\\r\\n    function transferWithPermit(\\r\\n        address _owner,\\r\\n        address to,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external override returns (bool) {\\r\\n        require(_owner != address(0) && to != address(0), \\\"ERC20Permit: zero address\\\");\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(TRANSFER_TYPEHASH, _owner, to, value, nonces[_owner]++, deadline));\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == _owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _transfer(_owner, to, value);\\r\\n        return true;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/ERC20Fee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.19;\\r\\n\\r\\nimport { ERC20 } from \\\"./ERC20.sol\\\";\\r\\nimport { Ownable } from \\\"./helpers/Ownable.sol\\\";\\r\\nimport { IFeeManager } from \\\"./interfaces/IFeeManager.sol\\\";\\r\\n\\r\\ncontract ERC20Fee is ERC20, Ownable {\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                            FEE-ON-TRANSFER STORAGE\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    uint256 private constant TOTAL_FEE = 400;\\r\\n    uint256 private constant BPS_MULTIPLIER = 10000;\\r\\n\\r\\n    uint256 private constant MAX_WALLET_BALANCE = 300_000 * 10**18;\\r\\n\\r\\n    mapping(address => bool) public isExcludedFee;\\r\\n    mapping(address => bool) public isForcedFee;\\r\\n\\r\\n    uint256 private _feeSell;\\r\\n    uint256 private _feeBuy;\\r\\n    uint256 private _feeTransfer;\\r\\n\\r\\n    address public feeRecipient;\\r\\n    bool public isFeeManager;\\r\\n\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                            FEE-ON-TRANSFER EVENTS\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    event ExcludeFee(address account, bool excluded);\\r\\n    event ForcedFee(address account, bool forced);\\r\\n    event FeeRecipientChanged(address feeRecipient, bool isFeeManager);\\r\\n\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                            CONSTRUCTOR\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    constructor(\\r\\n        string memory _name,\\r\\n        string memory _symbol,\\r\\n        uint8 _decimals\\r\\n    ) ERC20(_name, _symbol, _decimals) {\\r\\n        _feeSell = TOTAL_FEE;\\r\\n        _feeBuy = TOTAL_FEE;\\r\\n    }\\r\\n\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                            FEE-ON-TRANSFER LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal virtual override {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        uint256 senderBalance = balanceOf[sender];\\r\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            balanceOf[sender] = senderBalance - amount;\\r\\n        }\\r\\n\\r\\n        uint256 fee = feeRecipient != address(0) ? _calcFee(sender, recipient, amount) : 0;\\r\\n\\r\\n        require(balanceOf[recipient] + amount - fee <= MAX_WALLET_BALANCE, \\\"ERC20: allowed balance per wallet exceeds max balance!\\\");\\r\\n\\r\\n        if (fee > 0) {\\r\\n            balanceOf[recipient] += (amount - fee);\\r\\n            balanceOf[feeRecipient] += fee;\\r\\n            emit Transfer(sender, recipient, (amount - fee));\\r\\n            emit Transfer(sender, feeRecipient, fee);\\r\\n\\r\\n            if (isFeeManager && IFeeManager(feeRecipient).canSyncFee(sender, recipient)) {\\r\\n                IFeeManager(feeRecipient).syncFee();\\r\\n            }\\r\\n        } else {\\r\\n            balanceOf[recipient] += amount;\\r\\n            emit Transfer(sender, recipient, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setExcludedFee(address account, bool excluded) external onlyOwner {\\r\\n        isExcludedFee[account] = excluded;\\r\\n        emit ExcludeFee(account, excluded);\\r\\n    }\\r\\n\\r\\n    function setForcedFee(address account, bool forced) external onlyOwner {\\r\\n        isForcedFee[account] = forced;\\r\\n        emit ForcedFee(account, forced);\\r\\n    }\\r\\n\\r\\n    function getFees()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 feeSell,\\r\\n            uint256 feeBuy,\\r\\n            uint256 feeTransfer\\r\\n        )\\r\\n    {\\r\\n        return (_feeSell, _feeBuy, _feeTransfer);\\r\\n    }\\r\\n\\r\\n    function changeFeeRecipient(address _feeRecipient, bool _isFeeManager) external onlyOwner {\\r\\n        feeRecipient = _feeRecipient;\\r\\n        isFeeManager = _isFeeManager;\\r\\n        emit FeeRecipientChanged(feeRecipient, isFeeManager);\\r\\n    }\\r\\n\\r\\n    function _calcFee(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) private view returns (uint256 fee) {\\r\\n        if (from != address(0) && to != address(0) && !isExcludedFee[from] && !isExcludedFee[to]) {\\r\\n            if (isForcedFee[to]) {\\r\\n                fee = _calcBPS(amount, _feeSell);\\r\\n            } else if (isForcedFee[from]) {\\r\\n                fee = _calcBPS(amount, _feeBuy);\\r\\n            } else {\\r\\n                fee = _calcBPS(amount, _feeTransfer);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _calcBPS(uint256 amount, uint256 feeBPS) private pure returns (uint256) {\\r\\n        return (amount * feeBPS) / BPS_MULTIPLIER;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/external/openzeppelin/draft-EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.19;\\r\\n\\r\\nimport \\\"./ECDSA.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\r\\n *\\r\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\r\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\r\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\r\\n *\\r\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\r\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\r\\n * ({_hashTypedDataV4}).\\r\\n *\\r\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\r\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\r\\n *\\r\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\r\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\r\\n *\\r\\n * _Available since v3.4._\\r\\n */\\r\\nabstract contract EIP712 {\\r\\n    /* solhint-disable var-name-mixedcase */\\r\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\r\\n    // invalidate the cached domain separator if the chain id changes.\\r\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\r\\n    uint256 private immutable _CACHED_CHAIN_ID;\\r\\n\\r\\n    bytes32 private immutable _HASHED_NAME;\\r\\n    bytes32 private immutable _HASHED_VERSION;\\r\\n    bytes32 private immutable _TYPE_HASH;\\r\\n\\r\\n    /* solhint-enable var-name-mixedcase */\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the domain separator and parameter caches.\\r\\n     *\\r\\n     * The meaning of `name` and `version` is specified in\\r\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\r\\n     *\\r\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\r\\n     * - `version`: the current major version of the signing domain.\\r\\n     *\\r\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\r\\n     * contract upgrade].\\r\\n     */\\r\\n    constructor(string memory name, string memory version) {\\r\\n        bytes32 hashedName = keccak256(bytes(name));\\r\\n        bytes32 hashedVersion = keccak256(bytes(version));\\r\\n        bytes32 typeHash = keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\r\\n        _HASHED_NAME = hashedName;\\r\\n        _HASHED_VERSION = hashedVersion;\\r\\n        _CACHED_CHAIN_ID = block.chainid;\\r\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\\r\\n        _TYPE_HASH = typeHash;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the domain separator for the current chain.\\r\\n     */\\r\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\r\\n        if (block.chainid == _CACHED_CHAIN_ID) {\\r\\n            return _CACHED_DOMAIN_SEPARATOR;\\r\\n        } else {\\r\\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _buildDomainSeparator(\\r\\n        bytes32 typeHash,\\r\\n        bytes32 name,\\r\\n        bytes32 version\\r\\n    ) private view returns (bytes32) {\\r\\n        return keccak256(abi.encode(typeHash, name, version, block.chainid, address(this)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\r\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\r\\n     *\\r\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\r\\n     *\\r\\n     * ```solidity\\r\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\r\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\r\\n     *     mailTo,\\r\\n     *     keccak256(bytes(mailContents))\\r\\n     * )));\\r\\n     * address signer = ECDSA.recover(digest, signature);\\r\\n     * ```\\r\\n     */\\r\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\r\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/external/openzeppelin/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.19;\\r\\n\\r\\n/**\\r\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\r\\n *\\r\\n * These functions can be used to verify that a message was signed by the holder\\r\\n * of the private keys of a given address.\\r\\n */\\r\\nlibrary ECDSA {\\r\\n    /**\\r\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\r\\n     * `signature`. This address can then be used for verification purposes.\\r\\n     *\\r\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\r\\n     * this function rejects them by requiring the `s` value to be in the lower\\r\\n     * half order, and the `v` value to be either 27 or 28.\\r\\n     *\\r\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\r\\n     * verification to be secure: it is possible to craft signatures that\\r\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\r\\n     * this is by receiving a hash of the original message (which may otherwise\\r\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\r\\n     */\\r\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\r\\n        // Divide the signature in r, s and v variables\\r\\n        bytes32 r;\\r\\n        bytes32 s;\\r\\n        uint8 v;\\r\\n\\r\\n        // Check the signature length\\r\\n        // - case 65: r,s,v signature (standard)\\r\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\r\\n        if (signature.length == 65) {\\r\\n            // ecrecover takes the signature parameters, and the only way to get them\\r\\n            // currently is to use assembly.\\r\\n            // solhint-disable-next-line no-inline-assembly\\r\\n            assembly {\\r\\n                r := mload(add(signature, 0x20))\\r\\n                s := mload(add(signature, 0x40))\\r\\n                v := byte(0, mload(add(signature, 0x60)))\\r\\n            }\\r\\n        } else if (signature.length == 64) {\\r\\n            // ecrecover takes the signature parameters, and the only way to get them\\r\\n            // currently is to use assembly.\\r\\n            // solhint-disable-next-line no-inline-assembly\\r\\n            assembly {\\r\\n                let vs := mload(add(signature, 0x40))\\r\\n                r := mload(add(signature, 0x20))\\r\\n                s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\r\\n                v := add(shr(255, vs), 27)\\r\\n            }\\r\\n        } else {\\r\\n            revert(\\\"ECDSA: invalid signature length\\\");\\r\\n        }\\r\\n\\r\\n        return recover(hash, v, r, s);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\r\\n     * `r` and `s` signature fields separately.\\r\\n     */\\r\\n    function recover(\\r\\n        bytes32 hash,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) internal pure returns (address) {\\r\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\r\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\r\\n        // the valid range for s in (281): 0 < s < secp256k1n \ufffd 2 + 1, and for v in (282): v ? {27, 28}. Most\\r\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\r\\n        //\\r\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\r\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\r\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\r\\n        // these malleable signatures as well.\\r\\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\\"ECDSA: invalid signature 's' value\\\");\\r\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\r\\n\\r\\n        // If the signature is valid (and not malleable), return the signer address\\r\\n        address signer = ecrecover(hash, v, r, s);\\r\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\r\\n\\r\\n        return signer;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\r\\n     * produces hash corresponding to the one signed with the\\r\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\r\\n     * JSON-RPC method as part of EIP-191.\\r\\n     *\\r\\n     * See {recover}.\\r\\n     */\\r\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\r\\n        // 32 is the length in bytes of hash,\\r\\n        // enforced by the type signature above\\r\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\r\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\r\\n     * to the one signed with the\\r\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\r\\n     * JSON-RPC method as part of EIP-712.\\r\\n     *\\r\\n     * See {recover}.\\r\\n     */\\r\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\r\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/helpers/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.19;\\r\\n\\r\\ncontract OwnableData {\\r\\n    address public owner;\\r\\n    address public pendingOwner;\\r\\n}\\r\\n\\r\\ncontract Ownable is OwnableData {\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev `owner` defaults to msg.sender on construction.\\r\\n     */\\r\\n    constructor() {\\r\\n        _setOwner(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\\r\\n     *      Can only be invoked by the current `owner`.\\r\\n     * @param _newOwner Address of the new owner.\\r\\n     * @param _direct True if `_newOwner` should be set immediately. False if `_newOwner` needs to use `claimOwnership`.\\r\\n     * @param _renounce Allows the `_newOwner` to be `address(0)` if `_direct` and `_renounce` is True. Has no effect otherwise\\r\\n     */\\r\\n    function transferOwnership(\\r\\n        address _newOwner,\\r\\n        bool _direct,\\r\\n        bool _renounce\\r\\n    ) external onlyOwner {\\r\\n        if (_direct) {\\r\\n            require(_newOwner != address(0) || _renounce, \\\"zero address\\\");\\r\\n\\r\\n            emit OwnershipTransferred(owner, _newOwner);\\r\\n            owner = _newOwner;\\r\\n            pendingOwner = address(0);\\r\\n        } else {\\r\\n            pendingOwner = _newOwner;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Needs to be called by `pendingOwner` to claim ownership.\\r\\n     */\\r\\n    function claimOwnership() external {\\r\\n        address _pendingOwner = pendingOwner;\\r\\n        require(msg.sender == _pendingOwner, \\\"caller != pending owner\\\");\\r\\n\\r\\n        emit OwnershipTransferred(owner, _pendingOwner);\\r\\n        owner = _pendingOwner;\\r\\n        pendingOwner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the Owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, \\\"caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function _setOwner(address newOwner) internal {\\r\\n        address oldOwner = owner;\\r\\n        owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/helpers/TransactionThrottler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.19;\\r\\n\\r\\nimport { Ownable } from \\\"./Ownable.sol\\\";\\r\\n\\r\\ncontract TransactionThrottler is Ownable {\\r\\n    bool private _initialized;\\r\\n    bool private _restrictionActive;\\r\\n    uint256 private _tradingStart;\\r\\n    uint256 private _maxTransferAmount;\\r\\n    uint256 private constant _delayBetweenTx = 120;\\r\\n    mapping(address => uint256) private _previousTx;\\r\\n\\r\\n    event RestrictionActiveChanged(bool active);\\r\\n    event MaxTransferAmountChanged(uint256 maxTransferAmount);\\r\\n    \\r\\n    function initAntibot() external onlyOwner {\\r\\n        require(!_initialized, \\\"Protection: Already initialized\\\");\\r\\n        _initialized = true;\\r\\n        _restrictionActive = true;\\r\\n        _maxTransferAmount = 25_000 * 10**18;\\r\\n\\r\\n        emit RestrictionActiveChanged(_restrictionActive);\\r\\n        emit MaxTransferAmountChanged(_maxTransferAmount);\\r\\n    }\\r\\n\\r\\n    function setMaxTransferAmount(uint256 amount) external onlyOwner {\\r\\n        _maxTransferAmount = amount;\\r\\n        emit MaxTransferAmountChanged(_maxTransferAmount);\\r\\n    }\\r\\n\\r\\n    function setRestrictionActive(bool active) external onlyOwner {\\r\\n        require(active == false, \\\"Protection: operation is prohibited!\\\");\\r\\n        _restrictionActive = active;\\r\\n        emit RestrictionActiveChanged(_restrictionActive);\\r\\n    }\\r\\n\\r\\n    modifier transactionThrottler(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) {\\r\\n        if (_restrictionActive) {         \\r\\n            if (_maxTransferAmount > 0) {\\r\\n                require(amount <= _maxTransferAmount, \\\"Protection: Limit exceeded\\\");\\r\\n            }                 \\r\\n            require(_previousTx[recipient] + _delayBetweenTx <= block.timestamp, \\\"Protection: 120 sec/tx allowed\\\");\\r\\n            _previousTx[recipient] = block.timestamp;                \\r\\n            require(_previousTx[sender] + _delayBetweenTx <= block.timestamp, \\\"Protection: 120 sec/tx allowed\\\");\\r\\n            _previousTx[sender] = block.timestamp;        \\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.19;\\r\\n\\r\\ninterface IERC20 {\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function decimals() external view returns (uint8);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\r\\n\\r\\n    function burn(uint256 amount) external returns (bool);\\r\\n    function burnFrom(address account, uint256 amount) external returns (bool);\\r\\n\\r\\n    // EIP 2612\\r\\n    // solhint-disable-next-line func-name-mixedcase\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint256);\\r\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n    function transferWithPermit(address target, address to, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IFeeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.19;\\r\\n\\r\\ninterface IFeeManager {\\r\\n    function canSyncFee(address sender, address recipient) external view returns (bool);\\r\\n    function syncFee() external;\\r\\n}\"\r\n    },\r\n    \"contracts/Spc.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.19;\\r\\n\\r\\nimport { ERC20Fee } from \\\"./ERC20Fee.sol\\\";\\r\\nimport { Ownable } from \\\"./helpers/Ownable.sol\\\";\\r\\nimport { TransactionThrottler } from \\\"./helpers/TransactionThrottler.sol\\\";\\r\\n\\r\\ncontract Spc is Ownable, ERC20Fee, TransactionThrottler {\\r\\n    constructor(address _owner) ERC20Fee(\\\"SPC\\\", \\\"SPC\\\", 18) {\\r\\n        _setOwner(_owner);\\r\\n        _mint(_owner, 10_000_000 * 10**18);\\r\\n    }\\r\\n\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal override transactionThrottler(sender, recipient, amount) {\\r\\n        super._transfer(sender, recipient, amount);\\r\\n    }    \\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isFeeManager\",\"type\":\"bool\"}],\"name\":\"FeeRecipientChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"forced\",\"type\":\"bool\"}],\"name\":\"ForcedFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxTransferAmount\",\"type\":\"uint256\"}],\"name\":\"MaxTransferAmountChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"RestrictionActiveChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSFER_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isFeeManager\",\"type\":\"bool\"}],\"name\":\"changeFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feeSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeTransfer\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initAntibot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcludedFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFeeManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isForcedFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"setExcludedFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"forced\",\"type\":\"bool\"}],\"name\":\"setForcedFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxTransferAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"setRestrictionActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_direct\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_renounce\",\"type\":\"bool\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"transferWithPermit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Spc", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000009e0959190b2edd3baafebc5c4c9984ef6165a56c", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}