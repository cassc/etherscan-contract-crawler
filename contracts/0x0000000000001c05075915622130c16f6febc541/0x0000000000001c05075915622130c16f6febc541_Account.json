{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Account.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport {ERC4337} from \\\"@solady/src/accounts/ERC4337.sol\\\";\\n\\n/// @notice Simple extendable smart account implementation.\\n/// @author nani.eth (https://github.com/NaniDAO/accounts/blob/main/src/Account.sol)\\ncontract Account is ERC4337 {\\n    /// @dev Constructs\\n    /// this implementation.\\n    constructor() payable {}\\n\\n    /// @dev Returns domain name\\n    /// & version of implementation.\\n    function _domainNameAndVersion()\\n        internal\\n        pure\\n        virtual\\n        override\\n        returns (string memory, string memory)\\n    {\\n        return (\\\"NANI\\\", \\\"0.0.0\\\");\\n    }\\n\\n    /// @dev Validates userOp\\n    /// with nonce handling.\\n    function validateUserOp(\\n        UserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 missingAccountFunds\\n    )\\n        external\\n        payable\\n        virtual\\n        override\\n        onlyEntryPoint\\n        payPrefund(missingAccountFunds)\\n        returns (uint256)\\n    {\\n        return userOp.nonce < type(uint64).max\\n            ? _validateSignature(userOp, userOpHash)\\n            : _validateUserOp();\\n    }\\n\\n    /// @dev Extends validation by forwarding calldata to validator.\\n    function _validateUserOp() internal virtual returns (uint256) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            calldatacopy(0x00, 0x00, calldatasize())\\n            if iszero(\\n                call(\\n                    gas(),\\n                    /*validator*/\\n                    shr(96, sload(shl(64, /*key*/ shr(64, /*nonce*/ calldataload(0x84))))),\\n                    0,\\n                    0x00,\\n                    calldatasize(),\\n                    0x00,\\n                    0x20\\n                )\\n            ) {\\n                // Bubble up the revert if the call reverts.\\n                returndatacopy(0x00, 0x00, returndatasize())\\n                revert(0x00, returndatasize())\\n            }\\n            return(0x00, 0x20) // `validationData`.\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/accounts/ERC4337.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {Receiver} from \\\"./Receiver.sol\\\";\\nimport {LibZip} from \\\"../utils/LibZip.sol\\\";\\nimport {Ownable} from \\\"../auth/Ownable.sol\\\";\\nimport {UUPSUpgradeable} from \\\"../utils/UUPSUpgradeable.sol\\\";\\nimport {SignatureCheckerLib, ERC1271} from \\\"../accounts/ERC1271.sol\\\";\\n\\n/// @notice Simple ERC4337 account implementation.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/ERC4337.sol)\\n/// @author Infinitism (https://github.com/eth-infinitism/account-abstraction/blob/develop/contracts/samples/SimpleAccount.sol)\\n///\\n/// Recommended usage:\\n/// 1. Deploy the ERC4337 as an implementation contract, and verify it on Etherscan.\\n/// 2. Create a factory that uses `LibClone.deployERC1967` or\\n///    `LibClone.deployDeterministicERC1967` to clone the implementation.\\n///    See: `ERC4337Factory.sol`.\\nabstract contract ERC4337 is Ownable, UUPSUpgradeable, Receiver, ERC1271 {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ERC4337 user operation (userOp) struct.\\n    struct UserOperation {\\n        address sender;\\n        uint256 nonce;\\n        bytes initCode;\\n        bytes callData;\\n        uint256 callGasLimit;\\n        uint256 verificationGasLimit;\\n        uint256 preVerificationGas;\\n        uint256 maxFeePerGas;\\n        uint256 maxPriorityFeePerGas;\\n        bytes paymasterAndData;\\n        bytes signature;\\n    }\\n\\n    /// @dev Call struct for the `executeBatch` function.\\n    struct Call {\\n        address target;\\n        uint256 value;\\n        bytes data;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        INITIALIZER                         */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Initializes the account with the owner. Can only be called once.\\n    function initialize(address newOwner) public payable virtual {\\n        _initializeOwner(newOwner);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        ENTRY POINT                         */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the canonical ERC4337 EntryPoint contract.\\n    /// Override this function to return a different EntryPoint.\\n    function entryPoint() public view virtual returns (address) {\\n        return 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   VALIDATION OPERATIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Validates the signature and nonce.\\n    /// The EntryPoint will make the call to the recipient only if\\n    /// this validation call returns successfully.\\n    ///\\n    /// Signature failure should be reported by returning 1 (see: `_validateSignature`).\\n    /// This allows making a \\\"simulation call\\\" without a valid signature.\\n    /// Other failures (e.g. nonce mismatch, or invalid signature format)\\n    /// should still revert to signal failure.\\n    function validateUserOp(\\n        UserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 missingAccountFunds\\n    )\\n        external\\n        payable\\n        virtual\\n        onlyEntryPoint\\n        payPrefund(missingAccountFunds)\\n        returns (uint256 validationData)\\n    {\\n        validationData = _validateSignature(userOp, userOpHash);\\n        _validateNonce(userOp.nonce);\\n    }\\n\\n    /// @dev Validate `userOp.signature` for the `userOpHash`.\\n    function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash)\\n        internal\\n        virtual\\n        returns (uint256 validationData)\\n    {\\n        bool success = SignatureCheckerLib.isValidSignatureNowCalldata(\\n            owner(), SignatureCheckerLib.toEthSignedMessageHash(userOpHash), userOp.signature\\n        );\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Returns 0 if the recovered address matches the owner.\\n            // Else returns 1, which is equivalent to:\\n            // `(success ? 0 : 1) | (uint256(validUntil) << 160) | (uint256(validAfter) << (160 + 48))`\\n            // where `validUntil` is 0 (indefinite) and `validAfter` is 0.\\n            validationData := iszero(success)\\n        }\\n    }\\n\\n    /// @dev Override to validate the nonce of the userOp.\\n    /// This method may validate the nonce requirement of this account.\\n    /// e.g.\\n    /// To limit the nonce to use sequenced userOps only (no \\\"out of order\\\" userOps):\\n    ///      `require(nonce < type(uint64).max)`\\n    /// For a hypothetical account that *requires* the nonce to be out-of-order:\\n    ///      `require(nonce & type(uint64).max == 0)`\\n    ///\\n    /// The actual nonce uniqueness is managed by the EntryPoint, and thus no other\\n    /// action is needed by the account itself.\\n    function _validateNonce(uint256 nonce) internal virtual {\\n        nonce = nonce; // Silence unused variable warning.\\n    }\\n\\n    /// @dev Sends to the EntryPoint (i.e. `msg.sender`) the missing funds for this transaction.\\n    /// Subclass MAY override this modifier for better funds management.\\n    /// (e.g. send to the EntryPoint more than the minimum required, so that in future transactions\\n    /// it will not be required to send again)\\n    ///\\n    /// `missingAccountFunds` is the minimum value this modifier should send the EntryPoint,\\n    /// which MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\\n    modifier payPrefund(uint256 missingAccountFunds) virtual {\\n        _;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if missingAccountFunds {\\n                // Ignore failure (it's EntryPoint's job to verify, not the account's).\\n                pop(call(gas(), caller(), missingAccountFunds, codesize(), 0x00, codesize(), 0x00))\\n            }\\n        }\\n    }\\n\\n    /// @dev Requires that the caller is the EntryPoint.\\n    modifier onlyEntryPoint() virtual {\\n        if (msg.sender != entryPoint()) revert Unauthorized();\\n        _;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                    EXECUTION OPERATIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Execute a call from this account.\\n    function execute(address target, uint256 value, bytes calldata data)\\n        public\\n        payable\\n        virtual\\n        onlyEntryPointOrOwner\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, data.offset, data.length)\\n            if iszero(call(gas(), target, value, result, data.length, codesize(), 0x00)) {\\n                // Bubble up the revert if the call reverts.\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Execute a sequence of calls from this account.\\n    function executeBatch(Call[] calldata calls)\\n        public\\n        payable\\n        virtual\\n        onlyEntryPointOrOwner\\n        returns (bytes[] memory results)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            results := mload(0x40)\\n            mstore(results, calls.length)\\n            let r := add(0x20, results)\\n            let m := add(r, shl(5, calls.length))\\n            calldatacopy(r, calls.offset, shl(5, calls.length))\\n            for { let end := m } iszero(eq(r, end)) { r := add(r, 0x20) } {\\n                let e := add(calls.offset, mload(r))\\n                let o := add(e, calldataload(add(e, 0x40)))\\n                calldatacopy(m, add(o, 0x20), calldataload(o))\\n                // forgefmt: disable-next-item\\n                if iszero(call(gas(), calldataload(e), calldataload(add(e, 0x20)),\\n                    m, calldataload(o), codesize(), 0x00)) {\\n                    // Bubble up the revert if the call reverts.\\n                    returndatacopy(m, 0x00, returndatasize())\\n                    revert(m, returndatasize())\\n                }\\n                mstore(r, m) // Append `m` into `results`.\\n                mstore(m, returndatasize()) // Store the length,\\n                let p := add(m, 0x20)\\n                returndatacopy(p, 0x00, returndatasize()) // and copy the returndata.\\n                m := add(p, returndatasize()) // Advance `m`.\\n            }\\n            mstore(0x40, m) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Execute a delegatecall with `delegate` on this account.\\n    function delegateExecute(address delegate, bytes calldata data)\\n        public\\n        payable\\n        virtual\\n        onlyEntryPointOrOwner\\n        delegateExecuteGuard\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, data.offset, data.length)\\n            // Forwards the `data` to `delegate` via delegatecall.\\n            if iszero(delegatecall(gas(), delegate, result, data.length, codesize(), 0x00)) {\\n                // Bubble up the revert if the call reverts.\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Ensures that the owner and implementation slots' values aren't changed.\\n    /// You can override this modifier to ensure the sanctity of other storage slots too.\\n    modifier delegateExecuteGuard() virtual {\\n        bytes32 ownerSlotValue;\\n        bytes32 implementationSlotValue;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            implementationSlotValue := sload(_ERC1967_IMPLEMENTATION_SLOT)\\n            ownerSlotValue := sload(_OWNER_SLOT)\\n        }\\n        _;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(\\n                and(\\n                    eq(implementationSlotValue, sload(_ERC1967_IMPLEMENTATION_SLOT)),\\n                    eq(ownerSlotValue, sload(_OWNER_SLOT))\\n                )\\n            ) { revert(codesize(), 0x00) }\\n        }\\n    }\\n\\n    /// @dev Requires that the caller is the EntryPoint, the owner, or the account itself.\\n    modifier onlyEntryPointOrOwner() virtual {\\n        if (msg.sender != entryPoint()) _checkOwner();\\n        _;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                 DIRECT STORAGE OPERATIONS                  */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the raw storage value at `storageSlot`.\\n    function storageLoad(bytes32 storageSlot) public view virtual returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(storageSlot)\\n        }\\n    }\\n\\n    /// @dev Writes the raw storage value at `storageSlot`.\\n    function storageStore(bytes32 storageSlot, bytes32 storageValue)\\n        public\\n        payable\\n        virtual\\n        onlyEntryPointOrOwner\\n        storageStoreGuard(storageSlot)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            sstore(storageSlot, storageValue)\\n        }\\n    }\\n\\n    /// @dev Ensures that the `storageSlot` is not prohibited for direct storage writes.\\n    /// You can override this modifier to ensure the sanctity of other storage slots too.\\n    modifier storageStoreGuard(bytes32 storageSlot) virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if or(eq(storageSlot, _OWNER_SLOT), eq(storageSlot, _ERC1967_IMPLEMENTATION_SLOT)) {\\n                revert(codesize(), 0x00)\\n            }\\n        }\\n        _;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     DEPOSIT OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the account's balance on the EntryPoint.\\n    function getDeposit() public view virtual returns (uint256 result) {\\n        address ep = entryPoint();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, address()) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231) // `balanceOf(address)`.\\n            result :=\\n                mul( // Returns 0 if the EntryPoint does not exist.\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), ep, 0x1c, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n\\n    /// @dev Deposit more funds for this account in the EntryPoint.\\n    function addDeposit() public payable virtual {\\n        address ep = entryPoint();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The EntryPoint has balance accounting logic in the `receive()` function.\\n            // forgefmt: disable-next-item\\n            if iszero(mul(extcodesize(ep), call(gas(), ep, callvalue(), codesize(), 0x00, codesize(), 0x00))) {\\n                revert(codesize(), 0x00) // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Withdraw ETH from the account's deposit on the EntryPoint.\\n    function withdrawDepositTo(address to, uint256 amount) public payable virtual onlyOwner {\\n        address ep = entryPoint();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x205c2878000000000000000000000000) // `withdrawTo(address,uint256)`.\\n            if iszero(mul(extcodesize(ep), call(gas(), ep, 0, 0x10, 0x44, codesize(), 0x00))) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         OVERRIDES                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Requires that the caller is the owner or the account itself.\\n    /// This override affects the `onlyOwner` modifier.\\n    function _checkOwner() internal view virtual override(Ownable) {\\n        if (msg.sender != owner()) if (msg.sender != address(this)) revert Unauthorized();\\n    }\\n\\n    /// @dev To prevent double-initialization (reuses the owner storage slot for efficiency).\\n    function _guardInitializeOwner() internal pure virtual override(Ownable) returns (bool) {\\n        return true;\\n    }\\n\\n    /// @dev Uses the `owner` as the ERC1271 signer.\\n    function _erc1271Signer() internal view virtual override(ERC1271) returns (address) {\\n        return owner();\\n    }\\n\\n    /// @dev To ensure that only the owner or the account itself can upgrade the implementation.\\n    function _authorizeUpgrade(address) internal virtual override(UUPSUpgradeable) onlyOwner {}\\n\\n    /// @dev Handle token callbacks. If no token callback is triggered,\\n    /// use `LibZip.cdFallback` for generalized calldata decompression.\\n    /// If you don't need either, re-override this function.\\n    fallback() external payable virtual override(Receiver) receiverFallback {\\n        LibZip.cdFallback();\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/accounts/Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Receiver mixin for ETH and safe-transferred ERC721 and ERC1155 tokens.\\n/// @author Solady (https://github.com/Vectorized/solady/blob/main/src/accounts/Receiver.sol)\\n///\\n/// @dev Note:\\n/// - Handles all ERC721 and ERC1155 token safety callbacks.\\n/// - Collapses function table gas overhead and code size.\\n/// - Utilizes fallback so unknown calldata will pass on.\\nabstract contract Receiver {\\n    /// @dev For receiving ETH.\\n    receive() external payable virtual {}\\n\\n    /// @dev Fallback function with the `receiverFallback` modifier.\\n    fallback() external payable virtual receiverFallback {}\\n\\n    /// @dev Modifier for the fallback function to handle token callbacks.\\n    modifier receiverFallback() virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := shr(224, calldataload(0))\\n            // 0x150b7a02: `onERC721Received(address,address,uint256,bytes)`.\\n            // 0xf23a6e61: `onERC1155Received(address,address,uint256,uint256,bytes)`.\\n            // 0xbc197c81: `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\\n            if or(eq(s, 0x150b7a02), or(eq(s, 0xf23a6e61), eq(s, 0xbc197c81))) {\\n                mstore(0x20, s) // Store `msg.sig`.\\n                return(0x3c, 0x20) // Return `msg.sig`.\\n            }\\n        }\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/LibZip.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for compressing and decompressing bytes.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibZip.sol)\\n/// @author Calldata compression by clabby (https://github.com/clabby/op-kompressor)\\n/// @author FastLZ by ariya (https://github.com/ariya/FastLZ)\\n///\\n/// @dev Note:\\n/// The accompanying solady.js library includes implementations of\\n/// FastLZ and calldata operations for convenience.\\nlibrary LibZip {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     FAST LZ OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // LZ77 implementation based on FastLZ.\\n    // Equivalent to level 1 compression and decompression at the following commit:\\n    // https://github.com/ariya/FastLZ/commit/344eb4025f9ae866ebf7a2ec48850f7113a97a42\\n    // Decompression is backwards compatible.\\n\\n    /// @dev Returns the compressed `data`.\\n    function flzCompress(bytes memory data) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function ms8(d_, v_) -> _d {\\n                mstore8(d_, v_)\\n                _d := add(d_, 1)\\n            }\\n            function u24(p_) -> _u {\\n                let w := mload(p_)\\n                _u := or(shl(16, byte(2, w)), or(shl(8, byte(1, w)), byte(0, w)))\\n            }\\n            function cmp(p_, q_, e_) -> _l {\\n                for { e_ := sub(e_, q_) } lt(_l, e_) { _l := add(_l, 1) } {\\n                    e_ := mul(iszero(byte(0, xor(mload(add(p_, _l)), mload(add(q_, _l))))), e_)\\n                }\\n            }\\n            function literals(runs_, src_, dest_) -> _o {\\n                for { _o := dest_ } iszero(lt(runs_, 0x20)) { runs_ := sub(runs_, 0x20) } {\\n                    mstore(ms8(_o, 31), mload(src_))\\n                    _o := add(_o, 0x21)\\n                    src_ := add(src_, 0x20)\\n                }\\n                if iszero(runs_) { leave }\\n                mstore(ms8(_o, sub(runs_, 1)), mload(src_))\\n                _o := add(1, add(_o, runs_))\\n            }\\n            function match(l_, d_, o_) -> _o {\\n                for { d_ := sub(d_, 1) } iszero(lt(l_, 263)) { l_ := sub(l_, 262) } {\\n                    o_ := ms8(ms8(ms8(o_, add(224, shr(8, d_))), 253), and(0xff, d_))\\n                }\\n                if iszero(lt(l_, 7)) {\\n                    _o := ms8(ms8(ms8(o_, add(224, shr(8, d_))), sub(l_, 7)), and(0xff, d_))\\n                    leave\\n                }\\n                _o := ms8(ms8(o_, add(shl(5, l_), shr(8, d_))), and(0xff, d_))\\n            }\\n            function setHash(i_, v_) {\\n                let p := add(mload(0x40), shl(2, i_))\\n                mstore(p, xor(mload(p), shl(224, xor(shr(224, mload(p)), v_))))\\n            }\\n            function getHash(i_) -> _h {\\n                _h := shr(224, mload(add(mload(0x40), shl(2, i_))))\\n            }\\n            function hash(v_) -> _r {\\n                _r := and(shr(19, mul(2654435769, v_)), 0x1fff)\\n            }\\n            function setNextHash(ip_, ipStart_) -> _ip {\\n                setHash(hash(u24(ip_)), sub(ip_, ipStart_))\\n                _ip := add(ip_, 1)\\n            }\\n            codecopy(mload(0x40), codesize(), 0x8000) // Zeroize the hashmap.\\n            let op := add(mload(0x40), 0x8000)\\n            let a := add(data, 0x20)\\n            let ipStart := a\\n            let ipLimit := sub(add(ipStart, mload(data)), 13)\\n            for { let ip := add(2, a) } lt(ip, ipLimit) {} {\\n                let r := 0\\n                let d := 0\\n                for {} 1 {} {\\n                    let s := u24(ip)\\n                    let h := hash(s)\\n                    r := add(ipStart, getHash(h))\\n                    setHash(h, sub(ip, ipStart))\\n                    d := sub(ip, r)\\n                    if iszero(lt(ip, ipLimit)) { break }\\n                    ip := add(ip, 1)\\n                    if iszero(gt(d, 0x1fff)) { if eq(s, u24(r)) { break } }\\n                }\\n                if iszero(lt(ip, ipLimit)) { break }\\n                ip := sub(ip, 1)\\n                if gt(ip, a) { op := literals(sub(ip, a), a, op) }\\n                let l := cmp(add(r, 3), add(ip, 3), add(ipLimit, 9))\\n                op := match(l, d, op)\\n                ip := setNextHash(setNextHash(add(ip, l), ipStart), ipStart)\\n                a := ip\\n            }\\n            op := literals(sub(add(ipStart, mload(data)), a), a, op)\\n            result := mload(0x40)\\n            let t := add(result, 0x8000)\\n            let n := sub(op, t)\\n            mstore(result, n) // Store the length.\\n            // Copy the result to compact the memory, overwriting the hashmap.\\n            let o := add(result, 0x20)\\n            for { let i } lt(i, n) { i := add(i, 0x20) } { mstore(add(o, i), mload(add(t, i))) }\\n            mstore(add(o, n), 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(add(o, n), 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Returns the decompressed `data`.\\n    function flzDecompress(bytes memory data) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := 0\\n            let end := add(add(data, 0x20), mload(data))\\n            result := mload(0x40)\\n            let op := add(result, 0x20)\\n            for { data := add(data, 0x20) } lt(data, end) {} {\\n                let w := mload(data)\\n                let c := byte(0, w)\\n                let t := shr(5, c)\\n                if iszero(t) {\\n                    mstore(add(op, n), mload(add(data, 1)))\\n                    data := add(data, add(2, c))\\n                    n := add(n, add(1, c))\\n                    continue\\n                }\\n                let g := eq(t, 7)\\n                let l := add(2, xor(t, mul(g, xor(t, add(7, byte(1, w))))))\\n                for {\\n                    let s := add(add(shl(8, and(0x1f, c)), byte(add(1, g), w)), 1)\\n                    let r := add(op, sub(n, s))\\n                    let o := add(op, n)\\n                    let f := xor(s, mul(gt(s, 0x20), xor(s, 0x20)))\\n                    let j := 0\\n                } 1 {} {\\n                    mstore(add(o, j), mload(add(r, j)))\\n                    j := add(j, f)\\n                    if iszero(lt(j, l)) { break }\\n                }\\n                data := add(data, add(2, g))\\n                n := add(n, l)\\n            }\\n            mstore(result, n) // Store the length.\\n            let o := add(add(result, 0x20), n)\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                    CALLDATA OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // Calldata compression and decompression using selective run length encoding:\\n    // - Sequences of 0x00 (up to 128 consecutive).\\n    // - Sequences of 0xff (up to 32 consecutive).\\n    //\\n    // A run length encoded block consists of two bytes:\\n    // (0) 0x00\\n    // (1) A control byte with the following bit layout:\\n    //     - [7]     `0: 0x00, 1: 0xff`.\\n    //     - [0..6]  `runLength - 1`.\\n    //\\n    // The first 4 bytes are bitwise negated so that the compressed calldata\\n    // can be dispatched into the `fallback` and `receive` functions.\\n\\n    /// @dev Returns the compressed `data`.\\n    function cdCompress(bytes memory data) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function rle(v_, o_, d_) -> _o, _d {\\n                mstore(o_, shl(240, or(and(0xff, add(d_, 0xff)), and(0x80, v_))))\\n                _o := add(o_, 2)\\n            }\\n            result := mload(0x40)\\n            let o := add(result, 0x20)\\n            let z := 0 // Number of consecutive 0x00.\\n            let y := 0 // Number of consecutive 0xff.\\n            for { let end := add(data, mload(data)) } iszero(eq(data, end)) {} {\\n                data := add(data, 1)\\n                let c := byte(31, mload(data))\\n                if iszero(c) {\\n                    if y { o, y := rle(0xff, o, y) }\\n                    z := add(z, 1)\\n                    if eq(z, 0x80) { o, z := rle(0x00, o, 0x80) }\\n                    continue\\n                }\\n                if eq(c, 0xff) {\\n                    if z { o, z := rle(0x00, o, z) }\\n                    y := add(y, 1)\\n                    if eq(y, 0x20) { o, y := rle(0xff, o, 0x20) }\\n                    continue\\n                }\\n                if y { o, y := rle(0xff, o, y) }\\n                if z { o, z := rle(0x00, o, z) }\\n                mstore8(o, c)\\n                o := add(o, 1)\\n            }\\n            if y { o, y := rle(0xff, o, y) }\\n            if z { o, z := rle(0x00, o, z) }\\n            // Bitwise negate the first 4 bytes.\\n            mstore(add(result, 4), not(mload(add(result, 4))))\\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Returns the decompressed `data`.\\n    function cdDecompress(bytes memory data) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(data) {\\n                result := mload(0x40)\\n                let o := add(result, 0x20)\\n                let s := add(data, 4)\\n                let v := mload(s)\\n                let end := add(data, mload(data))\\n                mstore(s, not(v)) // Bitwise negate the first 4 bytes.\\n                for {} lt(data, end) {} {\\n                    data := add(data, 1)\\n                    let c := byte(31, mload(data))\\n                    if iszero(c) {\\n                        data := add(data, 1)\\n                        let d := byte(31, mload(data))\\n                        // Fill with either 0xff or 0x00.\\n                        mstore(o, not(0))\\n                        if iszero(gt(d, 0x7f)) { codecopy(o, codesize(), add(d, 1)) }\\n                        o := add(o, add(and(d, 0x7f), 1))\\n                        continue\\n                    }\\n                    mstore8(o, c)\\n                    o := add(o, 1)\\n                }\\n                mstore(s, v) // Restore the first 4 bytes.\\n                mstore(result, sub(o, add(result, 0x20))) // Store the length.\\n                mstore(o, 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev To be called in the `receive` and `fallback` functions.\\n    /// ```\\n    ///     receive() external payable { LibZip.cdFallback(); }\\n    ///     fallback() external payable { LibZip.cdFallback(); }\\n    /// ```\\n    /// For efficiency, this function will directly return the results, terminating the context.\\n    /// If called internally, it must be called at the end of the function.\\n    function cdFallback() internal {\\n        assembly {\\n            if iszero(calldatasize()) { return(calldatasize(), calldatasize()) }\\n            let o := 0\\n            let f := not(3) // For negating the first 4 bytes.\\n            for { let i := 0 } lt(i, calldatasize()) {} {\\n                let c := byte(0, xor(add(i, f), calldataload(i)))\\n                i := add(i, 1)\\n                if iszero(c) {\\n                    let d := byte(0, xor(add(i, f), calldataload(i)))\\n                    i := add(i, 1)\\n                    // Fill with either 0xff or 0x00.\\n                    mstore(o, not(0))\\n                    if iszero(gt(d, 0x7f)) { codecopy(o, codesize(), add(d, 1)) }\\n                    o := add(o, add(and(d, 0x7f), 1))\\n                    continue\\n                }\\n                mstore8(o, c)\\n                o := add(o, 1)\\n            }\\n            let success := delegatecall(gas(), address(), 0x00, o, codesize(), 0x00)\\n            returndatacopy(0x00, 0x00, returndatasize())\\n            if iszero(success) { revert(0x00, returndatasize()) }\\n            return(0x00, returndatasize())\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/auth/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n///\\n/// @dev Note:\\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\\n///\\n/// While the ownable portion follows\\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\\nabstract contract Ownable {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The caller is not authorized to call the function.\\n    error Unauthorized();\\n\\n    /// @dev The `newOwner` cannot be the zero address.\\n    error NewOwnerIsZeroAddress();\\n\\n    /// @dev The `pendingOwner` does not have a valid handover request.\\n    error NoHandoverRequest();\\n\\n    /// @dev Cannot double-initialize.\\n    error AlreadyInitialized();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\n    /// despite it not being as lightweight as a single argument event.\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @dev An ownership handover to `pendingOwner` has been requested.\\n    event OwnershipHandoverRequested(address indexed pendingOwner);\\n\\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The owner slot is given by:\\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\\\"_OWNER_SLOT_NOT\\\")))))`.\\n    /// It is intentionally chosen to be a high value\\n    /// to avoid collision with lower slots.\\n    /// The choice of manual storage layout is to enable compatibility\\n    /// with both regular and upgradeable contracts.\\n    bytes32 internal constant _OWNER_SLOT =\\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\\n\\n    /// The ownership handover slot of `newOwner` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\n    ///     let handoverSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// It stores the expiry timestamp of the two-step ownership handover.\\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\\n\\n    /// @dev Initializes the owner directly without authorization guard.\\n    /// This function must be called upon initialization,\\n    /// regardless of whether the contract is upgradeable or not.\\n    /// This is to enable generalization to both regular and upgradeable contracts,\\n    /// and to save gas in case the initial owner is not the caller.\\n    /// For performance reasons, this function will not check if there\\n    /// is an existing owner.\\n    function _initializeOwner(address newOwner) internal virtual {\\n        if (_guardInitializeOwner()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                if sload(ownerSlot) {\\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Store the new value.\\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n            }\\n        } else {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Store the new value.\\n                sstore(_OWNER_SLOT, newOwner)\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sets the owner directly without authorization guard.\\n    function _setOwner(address newOwner) internal virtual {\\n        if (_guardInitializeOwner()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n                // Store the new value.\\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\\n            }\\n        } else {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n                // Store the new value.\\n                sstore(ownerSlot, newOwner)\\n            }\\n        }\\n    }\\n\\n    /// @dev Throws if the sender is not the owner.\\n    function _checkOwner() internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the caller is not the stored owner, revert.\\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\\n    /// Override to return a different value if needed.\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\\n        return 48 * 3600;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(shl(96, newOwner)) {\\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @dev Allows the owner to renounce their ownership.\\n    function renounceOwnership() public payable virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /// @dev Request a two-step ownership handover to the caller.\\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\\n    function requestOwnershipHandover() public payable virtual {\\n        unchecked {\\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Compute and set the handover slot to `expires`.\\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\\n                mstore(0x00, caller())\\n                sstore(keccak256(0x0c, 0x20), expires)\\n                // Emit the {OwnershipHandoverRequested} event.\\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\n            }\\n        }\\n    }\\n\\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\\n    function cancelOwnershipHandover() public payable virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x20), 0)\\n            // Emit the {OwnershipHandoverCanceled} event.\\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\n        }\\n    }\\n\\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            let handoverSlot := keccak256(0x0c, 0x20)\\n            // If the handover does not exist, or has expired.\\n            if gt(timestamp(), sload(handoverSlot)) {\\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Set the handover slot to 0.\\n            sstore(handoverSlot, 0)\\n        }\\n        _setOwner(pendingOwner);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the owner of the contract.\\n    function owner() public view virtual returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(_OWNER_SLOT)\\n        }\\n    }\\n\\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\n    function ownershipHandoverExpiresAt(address pendingOwner)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the handover slot.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            // Load the handover slot.\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Marks a function as only callable by the owner.\\n    modifier onlyOwner() virtual {\\n        _checkOwner();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice UUPS proxy mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/UUPSUpgradeable.sol)\\n/// @author Modified from OpenZeppelin\\n/// (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/utils/UUPSUpgradeable.sol)\\n///\\n/// Note:\\n/// - This implementation is intended to be used with ERC1967 proxies.\\n/// See: `LibClone.deployERC1967` and related functions.\\n/// - This implementation is NOT compatible with legacy OpenZeppelin proxies\\n/// which do not store the implementation at `_ERC1967_IMPLEMENTATION_SLOT`.\\nabstract contract UUPSUpgradeable {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The upgrade failed.\\n    error UpgradeFailed();\\n\\n    /// @dev The call is from an unauthorized call context.\\n    error UnauthorizedCallContext();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         IMMUTABLES                         */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev For checking if the context is a delegate call.\\n    uint256 private immutable __self = uint256(uint160(address(this)));\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Emitted when the proxy's implementation is upgraded.\\n    event Upgraded(address indexed implementation);\\n\\n    /// @dev `keccak256(bytes(\\\"Upgraded(address)\\\"))`.\\n    uint256 private constant _UPGRADED_EVENT_SIGNATURE =\\n        0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ERC-1967 storage slot for the implementation in the proxy.\\n    /// `uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1`.\\n    bytes32 internal constant _ERC1967_IMPLEMENTATION_SLOT =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      UUPS OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Please override this function to check if `msg.sender` is authorized\\n    /// to upgrade the proxy to `newImplementation`, reverting if not.\\n    /// ```\\n    ///     function _authorizeUpgrade(address) internal override onlyOwner {}\\n    /// ```\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /// @dev Returns the storage slot used by the implementation,\\n    /// as specified in [ERC1822](https://eips.ethereum.org/EIPS/eip-1822).\\n    ///\\n    /// Note: The `notDelegated` modifier prevents accidental upgrades to\\n    /// an implementation that is a proxy contract.\\n    function proxiableUUID() public view virtual notDelegated returns (bytes32) {\\n        // This function must always return `_ERC1967_IMPLEMENTATION_SLOT` to comply with ERC1967.\\n        return _ERC1967_IMPLEMENTATION_SLOT;\\n    }\\n\\n    /// @dev Upgrades the proxy's implementation to `newImplementation`.\\n    /// Emits a {Upgraded} event.\\n    ///\\n    /// Note: The `onlyProxy` modifier prevents accidental calling on the implementation.\\n    function upgradeTo(address newImplementation) public payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            newImplementation := shr(96, shl(96, newImplementation)) // Clears upper 96 bits.\\n            mstore(0x01, 0x52d1902d) // `proxiableUUID()`.\\n            let s := _ERC1967_IMPLEMENTATION_SLOT\\n            // Check if `newImplementation` implements `proxiableUUID` correctly.\\n            if iszero(eq(mload(staticcall(gas(), newImplementation, 0x1d, 0x04, 0x01, 0x20)), s)) {\\n                mstore(0x01, 0x55299b49) // `UpgradeFailed()`.\\n                revert(0x1d, 0x04)\\n            }\\n            // Emit the {Upgraded} event.\\n            log2(codesize(), 0x00, _UPGRADED_EVENT_SIGNATURE, newImplementation)\\n            sstore(s, newImplementation) // Updates the implementation.\\n        }\\n    }\\n\\n    /// @dev Upgrades the proxy's implementation to `newImplementation`.\\n    /// Emits a {Upgraded} event.\\n    ///\\n    /// Note: This function calls `upgradeTo` internally,\\n    /// followed by a delegatecall to `newImplementation`.\\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\\n        public\\n        payable\\n        virtual\\n    {\\n        upgradeTo(newImplementation);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Forwards the `data` to `newImplementation` via delegatecall.\\n            let m := mload(0x40)\\n            calldatacopy(m, data.offset, data.length)\\n            if iszero(delegatecall(gas(), newImplementation, m, data.length, codesize(), 0x00)) {\\n                // Bubble up the revert if the call reverts.\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /// @dev Requires that the execution is performed through a proxy.\\n    modifier onlyProxy() {\\n        uint256 s = __self;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // To enable use cases with an immutable default implementation in the bytecode,\\n            // (see: ERC6551Proxy), we don't require that the proxy address must match the\\n            // value stored in the implementation slot, which may not be initialized.\\n            if eq(s, address()) {\\n                mstore(0x00, 0x9f03a026) // `UnauthorizedCallContext()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _;\\n    }\\n\\n    /// @dev Requires that the execution is NOT performed via delegatecall.\\n    /// This is the opposite of `onlyProxy`.\\n    modifier notDelegated() {\\n        uint256 s = __self;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(eq(s, address())) {\\n                mstore(0x00, 0x9f03a026) // `UnauthorizedCallContext()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/accounts/ERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {EIP712} from \\\"../utils/EIP712.sol\\\";\\nimport {SignatureCheckerLib} from \\\"../utils/SignatureCheckerLib.sol\\\";\\n\\n/// @notice ERC1271 mixin with nested EIP-712 approach.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/ERC1271.sol)\\nabstract contract ERC1271 is EIP712 {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     ERC1271 OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the ERC1271 signer.\\n    /// Override to return the signer `isValidSignature` checks against.\\n    function _erc1271Signer() internal view virtual returns (address);\\n\\n    /// @dev Validates the signature with ERC1271 return,\\n    /// so that this account can also be used as a signer.\\n    ///\\n    /// This implementation uses ECDSA recovery. It also uses a nested EIP-712 approach to\\n    /// prevent signature replays when a single EOA owns multiple smart contract accounts,\\n    /// while still enabling wallet UIs (e.g. Metamask) to show the EIP-712 values.\\n    ///\\n    /// For the nested EIP-712 workflow, the final hash will be:\\n    /// ```\\n    ///     keccak256(\\\\x19\\\\x01 || DOMAIN_SEP_A ||\\n    ///         hashStruct(Parent({\\n    ///             childHash: keccak256(\\\\x19\\\\x01 || DOMAIN_SEP_B || hashStruct(originalStruct)),\\n    ///             child: hashStruct(originalStruct)\\n    ///         }))\\n    ///     )\\n    /// ```\\n    /// where `||` denotes the concatenation operator for bytes.\\n    /// The signature will be `r || s || v || PARENT_TYPEHASH || DOMAIN_SEP_B || child`.\\n    ///\\n    /// The `DOMAIN_SEP_B` and `child` will be used to verify if `childHash` is indeed correct.\\n    ///\\n    /// For the `personal_sign` workflow, the final hash will be:\\n    /// ```\\n    ///     keccak256(\\\\x19\\\\x01 || DOMAIN_SEP_A ||\\n    ///         hashStruct(Parent({\\n    ///             childHash: personalSign(someBytes)\\n    ///         }))\\n    ///     )\\n    /// ```\\n    /// where `||` denotes the concatenation operator for bytes.\\n    /// The signature will be `r || s || v || PARENT_TYPEHASH`.\\n    ///\\n    /// For demo and typescript code, see:\\n    /// - https://github.com/junomonster/nested-eip-712\\n    /// - https://github.com/frangio/eip712-wrapper-for-eip1271\\n    ///\\n    /// Of course, if you are a wallet app maker and can update your app's UI at will,\\n    /// you can choose a more minimalistic signature scheme like\\n    /// `keccak256(abi.encode(address(this), hash))` instead of all these acrobatics.\\n    /// All these are just for widespead out-of-the-box compatibility with other wallet apps.\\n    ///\\n    /// The `hash` parameter is the `childHash`.\\n    function isValidSignature(bytes32 hash, bytes calldata signature)\\n        public\\n        view\\n        virtual\\n        returns (bytes4 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            let o := add(signature.offset, sub(signature.length, 0x60))\\n            calldatacopy(0x00, o, 0x60) // Copy the `DOMAIN_SEP_B` and child's structHash.\\n            mstore(0x00, 0x1901) // Store the \\\"\\\\x19\\\\x01\\\" prefix, overwriting 0x00.\\n            for {} 1 {} {\\n                // Use the nested EIP-712 workflow if the reconstructed childHash matches,\\n                // and the signature is at least 96 bytes long.\\n                if iszero(or(xor(keccak256(0x1e, 0x42), hash), lt(signature.length, 0x60))) {\\n                    // Truncate the `signature.length` by 3 words (96 bytes).\\n                    signature.length := sub(signature.length, 0x60)\\n                    mstore(0x00, calldataload(o)) // Store the `PARENT_TYPEHASH`.\\n                    mstore(0x20, hash) // Store the `childHash`.\\n                    // The child's structHash is already at 0x40.\\n                    hash := keccak256(0x00, 0x60) // Compute the parent's structHash.\\n                    break\\n                }\\n                // Else, use the `personal_sign` workflow.\\n                // Truncate the `signature.length` by 1 word (32 bytes), until zero.\\n                signature.length := mul(gt(signature.length, 0x20), sub(signature.length, 0x20))\\n                // The `PARENT_TYPEHASH` is already at 0x40.\\n                mstore(0x60, hash) // Store the `childHash`.\\n                hash := keccak256(0x40, 0x40) // Compute the parent's structHash.\\n                mstore(0x60, 0) // Restore the zero pointer.\\n                break\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n        bool success = SignatureCheckerLib.isValidSignatureNowCalldata(\\n            _erc1271Signer(), _hashTypedData(hash), signature\\n        );\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `success ? bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\")) : 0xffffffff`.\\n            result := shl(224, or(0x1626ba7e, sub(0, iszero(success))))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Contract for EIP-712 typed structured data hashing and signing.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EIP712.sol)\\n/// @author Modified from Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/EIP712.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol)\\n///\\n/// @dev Note, this implementation:\\n/// - Uses `address(this)` for the `verifyingContract` field.\\n/// - Does NOT use the optional EIP-712 salt.\\n/// - Does NOT use any EIP-712 extensions.\\n/// This is for simplicity and to save gas.\\n/// If you need to customize, please fork / modify accordingly.\\nabstract contract EIP712 {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  CONSTANTS AND IMMUTABLES                  */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev `keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")`.\\n    bytes32 internal constant _DOMAIN_TYPEHASH =\\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\n    uint256 private immutable _cachedThis;\\n    uint256 private immutable _cachedChainId;\\n    bytes32 private immutable _cachedNameHash;\\n    bytes32 private immutable _cachedVersionHash;\\n    bytes32 private immutable _cachedDomainSeparator;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        CONSTRUCTOR                         */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Cache the hashes for cheaper runtime gas costs.\\n    /// In the case of upgradeable contracts (i.e. proxies),\\n    /// or if the chain id changes due to a hard fork,\\n    /// the domain separator will be seamlessly calculated on-the-fly.\\n    constructor() {\\n        _cachedThis = uint256(uint160(address(this)));\\n        _cachedChainId = block.chainid;\\n\\n        string memory name;\\n        string memory version;\\n        if (!_domainNameAndVersionMayChange()) (name, version) = _domainNameAndVersion();\\n        bytes32 nameHash = _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(name));\\n        bytes32 versionHash =\\n            _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(version));\\n        _cachedNameHash = nameHash;\\n        _cachedVersionHash = versionHash;\\n\\n        bytes32 separator;\\n        if (!_domainNameAndVersionMayChange()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let m := mload(0x40) // Load the free memory pointer.\\n                mstore(m, _DOMAIN_TYPEHASH)\\n                mstore(add(m, 0x20), nameHash)\\n                mstore(add(m, 0x40), versionHash)\\n                mstore(add(m, 0x60), chainid())\\n                mstore(add(m, 0x80), address())\\n                separator := keccak256(m, 0xa0)\\n            }\\n        }\\n        _cachedDomainSeparator = separator;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   FUNCTIONS TO OVERRIDE                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Please override this function to return the domain name and version.\\n    /// ```\\n    ///     function _domainNameAndVersion()\\n    ///         internal\\n    ///         pure\\n    ///         virtual\\n    ///         returns (string memory name, string memory version)\\n    ///     {\\n    ///         name = \\\"Solady\\\";\\n    ///         version = \\\"1\\\";\\n    ///     }\\n    /// ```\\n    ///\\n    /// Note: If the returned result may change after the contract has been deployed,\\n    /// you must override `_domainNameAndVersionMayChange()` to return true.\\n    function _domainNameAndVersion()\\n        internal\\n        view\\n        virtual\\n        returns (string memory name, string memory version);\\n\\n    /// @dev Returns if `_domainNameAndVersion()` may change\\n    /// after the contract has been deployed (i.e. after the constructor).\\n    /// Default: false.\\n    function _domainNameAndVersionMayChange() internal pure virtual returns (bool result) {}\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     HASHING OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the EIP-712 domain separator.\\n    function _domainSeparator() internal view virtual returns (bytes32 separator) {\\n        if (_domainNameAndVersionMayChange()) {\\n            separator = _buildDomainSeparator();\\n        } else {\\n            separator = _cachedDomainSeparator;\\n            if (_cachedDomainSeparatorInvalidated()) separator = _buildDomainSeparator();\\n        }\\n    }\\n\\n    /// @dev Returns the hash of the fully encoded EIP-712 message for this domain,\\n    /// given `structHash`, as defined in\\n    /// https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\\n    ///\\n    /// The hash can be used together with {ECDSA-recover} to obtain the signer of a message:\\n    /// ```\\n    ///     bytes32 digest = _hashTypedData(keccak256(abi.encode(\\n    ///         keccak256(\\\"Mail(address to,string contents)\\\"),\\n    ///         mailTo,\\n    ///         keccak256(bytes(mailContents))\\n    ///     )));\\n    ///     address signer = ECDSA.recover(digest, signature);\\n    /// ```\\n    function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {\\n        // We will use `digest` to store the domain separator to save a bit of gas.\\n        if (_domainNameAndVersionMayChange()) {\\n            digest = _buildDomainSeparator();\\n        } else {\\n            digest = _cachedDomainSeparator;\\n            if (_cachedDomainSeparatorInvalidated()) digest = _buildDomainSeparator();\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the digest.\\n            mstore(0x00, 0x1901000000000000) // Store \\\"\\\\x19\\\\x01\\\".\\n            mstore(0x1a, digest) // Store the domain separator.\\n            mstore(0x3a, structHash) // Store the struct hash.\\n            digest := keccak256(0x18, 0x42)\\n            // Restore the part of the free memory slot that was overwritten.\\n            mstore(0x3a, 0)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                    EIP-5267 OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev See: https://eips.ethereum.org/EIPS/eip-5267\\n    function eip712Domain()\\n        public\\n        view\\n        virtual\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        )\\n    {\\n        fields = hex\\\"0f\\\"; // `0b01111`.\\n        (name, version) = _domainNameAndVersion();\\n        chainId = block.chainid;\\n        verifyingContract = address(this);\\n        salt = salt; // `bytes32(0)`.\\n        extensions = extensions; // `new uint256[](0)`.\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the EIP-712 domain separator.\\n    function _buildDomainSeparator() private view returns (bytes32 separator) {\\n        // We will use `separator` to store the name hash to save a bit of gas.\\n        bytes32 versionHash;\\n        if (_domainNameAndVersionMayChange()) {\\n            (string memory name, string memory version) = _domainNameAndVersion();\\n            separator = keccak256(bytes(name));\\n            versionHash = keccak256(bytes(version));\\n        } else {\\n            separator = _cachedNameHash;\\n            versionHash = _cachedVersionHash;\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Load the free memory pointer.\\n            mstore(m, _DOMAIN_TYPEHASH)\\n            mstore(add(m, 0x20), separator) // Name hash.\\n            mstore(add(m, 0x40), versionHash)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            separator := keccak256(m, 0xa0)\\n        }\\n    }\\n\\n    /// @dev Returns if the cached domain separator has been invalidated.\\n    function _cachedDomainSeparatorInvalidated() private view returns (bool result) {\\n        uint256 cachedChainId = _cachedChainId;\\n        uint256 cachedThis = _cachedThis;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/SignatureCheckerLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Signature verification helper that supports both ECDSA signatures from EOAs\\n/// and ERC1271 signatures from smart contract wallets like Argent and Gnosis safe.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SignatureCheckerLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/SignatureChecker.sol)\\n///\\n/// @dev Note:\\n/// - The signature checking functions use the ecrecover precompile (0x1).\\n/// - The `bytes memory signature` variants use the identity precompile (0x4)\\n///   to copy memory internally.\\n/// - Unlike ECDSA signatures, contract signatures are revocable.\\n/// - As of Solady version 0.0.134, all `bytes signature` variants accept both\\n///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.\\n///   See: https://eips.ethereum.org/EIPS/eip-2098\\n///   This is for calldata efficiency on smart accounts prevalent on L2s.\\n///\\n/// WARNING! Do NOT use signatures as unique identifiers:\\n/// - Use a nonce in the digest to prevent replay attacks on the same contract.\\n/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.\\n///   EIP-712 also enables readable signing of typed data for better user safety.\\n/// This implementation does NOT check if a signature is non-malleable.\\nlibrary SignatureCheckerLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*               SIGNATURE CHECKING OPERATIONS                */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits of `signer` in case they are dirty.\\n            for { signer := shr(96, shl(96, signer)) } signer {} {\\n                let m := mload(0x40)\\n                mstore(0x00, hash)\\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\\n                if eq(mload(signature), 64) {\\n                    let vs := mload(add(signature, 0x40))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                    let t :=\\n                        staticcall(\\n                            gas(), // Amount of gas left for the transaction.\\n                            1, // Address of `ecrecover`.\\n                            0x00, // Start of input.\\n                            0x80, // Size of input.\\n                            0x01, // Start of output.\\n                            0x20 // Size of output.\\n                        )\\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                        isValid := 1\\n                        mstore(0x60, 0) // Restore the zero slot.\\n                        mstore(0x40, m) // Restore the free memory pointer.\\n                        break\\n                    }\\n                }\\n                if eq(mload(signature), 65) {\\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\\n                    let t :=\\n                        staticcall(\\n                            gas(), // Amount of gas left for the transaction.\\n                            1, // Address of `ecrecover`.\\n                            0x00, // Start of input.\\n                            0x80, // Size of input.\\n                            0x01, // Start of output.\\n                            0x20 // Size of output.\\n                        )\\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                        isValid := 1\\n                        mstore(0x60, 0) // Restore the zero slot.\\n                        mstore(0x40, m) // Restore the free memory pointer.\\n                        break\\n                    }\\n                }\\n                mstore(0x60, 0) // Restore the zero slot.\\n                mstore(0x40, m) // Restore the free memory pointer.\\n\\n                let f := shl(224, 0x1626ba7e)\\n                mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m, 0x04), hash)\\n                let d := add(m, 0x24)\\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n                // Copy the `signature` over.\\n                let n := add(0x20, mload(signature))\\n                pop(staticcall(gas(), 4, signature, n, add(m, 0x44), n))\\n                // forgefmt: disable-next-item\\n                isValid := and(\\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                    eq(mload(d), f),\\n                    // Whether the staticcall does not revert.\\n                    // This must be placed at the end of the `and` clause,\\n                    // as the arguments are evaluated from right to left.\\n                    staticcall(\\n                        gas(), // Remaining gas.\\n                        signer, // The `signer` address.\\n                        m, // Offset of calldata in memory.\\n                        add(returndatasize(), 0x44), // Length of calldata in memory.\\n                        d, // Offset of returndata.\\n                        0x20 // Length of returndata to write.\\n                    )\\n                )\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\\n    function isValidSignatureNowCalldata(address signer, bytes32 hash, bytes calldata signature)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits of `signer` in case they are dirty.\\n            for { signer := shr(96, shl(96, signer)) } signer {} {\\n                let m := mload(0x40)\\n                mstore(0x00, hash)\\n                if eq(signature.length, 64) {\\n                    let vs := calldataload(add(signature.offset, 0x20))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                    let t :=\\n                        staticcall(\\n                            gas(), // Amount of gas left for the transaction.\\n                            1, // Address of `ecrecover`.\\n                            0x00, // Start of input.\\n                            0x80, // Size of input.\\n                            0x01, // Start of output.\\n                            0x20 // Size of output.\\n                        )\\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                        isValid := 1\\n                        mstore(0x60, 0) // Restore the zero slot.\\n                        mstore(0x40, m) // Restore the free memory pointer.\\n                        break\\n                    }\\n                }\\n                if eq(signature.length, 65) {\\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\n                    calldatacopy(0x40, signature.offset, 0x40) // `r`, `s`.\\n                    let t :=\\n                        staticcall(\\n                            gas(), // Amount of gas left for the transaction.\\n                            1, // Address of `ecrecover`.\\n                            0x00, // Start of input.\\n                            0x80, // Size of input.\\n                            0x01, // Start of output.\\n                            0x20 // Size of output.\\n                        )\\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                        isValid := 1\\n                        mstore(0x60, 0) // Restore the zero slot.\\n                        mstore(0x40, m) // Restore the free memory pointer.\\n                        break\\n                    }\\n                }\\n                mstore(0x60, 0) // Restore the zero slot.\\n                mstore(0x40, m) // Restore the free memory pointer.\\n\\n                let f := shl(224, 0x1626ba7e)\\n                mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m, 0x04), hash)\\n                let d := add(m, 0x24)\\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n                mstore(add(m, 0x44), signature.length)\\n                // Copy the `signature` over.\\n                calldatacopy(add(m, 0x64), signature.offset, signature.length)\\n                // forgefmt: disable-next-item\\n                isValid := and(\\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                    eq(mload(d), f),\\n                    // Whether the staticcall does not revert.\\n                    // This must be placed at the end of the `and` clause,\\n                    // as the arguments are evaluated from right to left.\\n                    staticcall(\\n                        gas(), // Remaining gas.\\n                        signer, // The `signer` address.\\n                        m, // Offset of calldata in memory.\\n                        add(signature.length, 0x64), // Length of calldata in memory.\\n                        d, // Offset of returndata.\\n                        0x20 // Length of returndata to write.\\n                    )\\n                )\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `signer` and `hash`.\\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\\n    function isValidSignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits of `signer` in case they are dirty.\\n            for { signer := shr(96, shl(96, signer)) } signer {} {\\n                let m := mload(0x40)\\n                mstore(0x00, hash)\\n                mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                mstore(0x40, r) // `r`.\\n                mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                let t :=\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        1, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                    isValid := 1\\n                    mstore(0x60, 0) // Restore the zero slot.\\n                    mstore(0x40, m) // Restore the free memory pointer.\\n                    break\\n                }\\n\\n                let f := shl(224, 0x1626ba7e)\\n                mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m, 0x04), hash)\\n                let d := add(m, 0x24)\\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n                mstore(add(m, 0x44), 65) // Length of the signature.\\n                mstore(add(m, 0x64), r) // `r`.\\n                mstore(add(m, 0x84), mload(0x60)) // `s`.\\n                mstore8(add(m, 0xa4), mload(0x20)) // `v`.\\n                // forgefmt: disable-next-item\\n                isValid := and(\\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                    eq(mload(d), f),\\n                    // Whether the staticcall does not revert.\\n                    // This must be placed at the end of the `and` clause,\\n                    // as the arguments are evaluated from right to left.\\n                    staticcall(\\n                        gas(), // Remaining gas.\\n                        signer, // The `signer` address.\\n                        m, // Offset of calldata in memory.\\n                        0xa5, // Length of calldata in memory.\\n                        d, // Offset of returndata.\\n                        0x20 // Length of returndata to write.\\n                    )\\n                )\\n                mstore(0x60, 0) // Restore the zero slot.\\n                mstore(0x40, m) // Restore the free memory pointer.\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `signer` and `hash`.\\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\\n    function isValidSignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits of `signer` in case they are dirty.\\n            for { signer := shr(96, shl(96, signer)) } signer {} {\\n                let m := mload(0x40)\\n                mstore(0x00, hash)\\n                mstore(0x20, and(v, 0xff)) // `v`.\\n                mstore(0x40, r) // `r`.\\n                mstore(0x60, s) // `s`.\\n                let t :=\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        1, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                    isValid := 1\\n                    mstore(0x60, 0) // Restore the zero slot.\\n                    mstore(0x40, m) // Restore the free memory pointer.\\n                    break\\n                }\\n\\n                let f := shl(224, 0x1626ba7e)\\n                mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m, 0x04), hash)\\n                let d := add(m, 0x24)\\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n                mstore(add(m, 0x44), 65) // Length of the signature.\\n                mstore(add(m, 0x64), r) // `r`.\\n                mstore(add(m, 0x84), s) // `s`.\\n                mstore8(add(m, 0xa4), v) // `v`.\\n                // forgefmt: disable-next-item\\n                isValid := and(\\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                    eq(mload(d), f),\\n                    // Whether the staticcall does not revert.\\n                    // This must be placed at the end of the `and` clause,\\n                    // as the arguments are evaluated from right to left.\\n                    staticcall(\\n                        gas(), // Remaining gas.\\n                        signer, // The `signer` address.\\n                        m, // Offset of calldata in memory.\\n                        0xa5, // Length of calldata in memory.\\n                        d, // Offset of returndata.\\n                        0x20 // Length of returndata to write.\\n                    )\\n                )\\n                mstore(0x60, 0) // Restore the zero slot.\\n                mstore(0x40, m) // Restore the free memory pointer.\\n                break\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     ERC1271 OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes memory signature)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            let f := shl(224, 0x1626ba7e)\\n            mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n            mstore(add(m, 0x04), hash)\\n            let d := add(m, 0x24)\\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n            // Copy the `signature` over.\\n            let n := add(0x20, mload(signature))\\n            pop(staticcall(gas(), 4, signature, n, add(m, 0x44), n))\\n            // forgefmt: disable-next-item\\n            isValid := and(\\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                eq(mload(d), f),\\n                // Whether the staticcall does not revert.\\n                // This must be placed at the end of the `and` clause,\\n                // as the arguments are evaluated from right to left.\\n                staticcall(\\n                    gas(), // Remaining gas.\\n                    signer, // The `signer` address.\\n                    m, // Offset of calldata in memory.\\n                    add(returndatasize(), 0x44), // Length of calldata in memory.\\n                    d, // Offset of returndata.\\n                    0x20 // Length of returndata to write.\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\\n    function isValidERC1271SignatureNowCalldata(\\n        address signer,\\n        bytes32 hash,\\n        bytes calldata signature\\n    ) internal view returns (bool isValid) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            let f := shl(224, 0x1626ba7e)\\n            mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n            mstore(add(m, 0x04), hash)\\n            let d := add(m, 0x24)\\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n            mstore(add(m, 0x44), signature.length)\\n            // Copy the `signature` over.\\n            calldatacopy(add(m, 0x64), signature.offset, signature.length)\\n            // forgefmt: disable-next-item\\n            isValid := and(\\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                eq(mload(d), f),\\n                // Whether the staticcall does not revert.\\n                // This must be placed at the end of the `and` clause,\\n                // as the arguments are evaluated from right to left.\\n                staticcall(\\n                    gas(), // Remaining gas.\\n                    signer, // The `signer` address.\\n                    m, // Offset of calldata in memory.\\n                    add(signature.length, 0x64), // Length of calldata in memory.\\n                    d, // Offset of returndata.\\n                    0x20 // Length of returndata to write.\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `hash`\\n    /// for an ERC1271 `signer` contract.\\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            let f := shl(224, 0x1626ba7e)\\n            mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n            mstore(add(m, 0x04), hash)\\n            let d := add(m, 0x24)\\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n            mstore(add(m, 0x44), 65) // Length of the signature.\\n            mstore(add(m, 0x64), r) // `r`.\\n            mstore(add(m, 0x84), shr(1, shl(1, vs))) // `s`.\\n            mstore8(add(m, 0xa4), add(shr(255, vs), 27)) // `v`.\\n            // forgefmt: disable-next-item\\n            isValid := and(\\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                eq(mload(d), f),\\n                // Whether the staticcall does not revert.\\n                // This must be placed at the end of the `and` clause,\\n                // as the arguments are evaluated from right to left.\\n                staticcall(\\n                    gas(), // Remaining gas.\\n                    signer, // The `signer` address.\\n                    m, // Offset of calldata in memory.\\n                    0xa5, // Length of calldata in memory.\\n                    d, // Offset of returndata.\\n                    0x20 // Length of returndata to write.\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `hash`\\n    /// for an ERC1271 `signer` contract.\\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            let f := shl(224, 0x1626ba7e)\\n            mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n            mstore(add(m, 0x04), hash)\\n            let d := add(m, 0x24)\\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n            mstore(add(m, 0x44), 65) // Length of the signature.\\n            mstore(add(m, 0x64), r) // `r`.\\n            mstore(add(m, 0x84), s) // `s`.\\n            mstore8(add(m, 0xa4), v) // `v`.\\n            // forgefmt: disable-next-item\\n            isValid := and(\\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                eq(mload(d), f),\\n                // Whether the staticcall does not revert.\\n                // This must be placed at the end of the `and` clause,\\n                // as the arguments are evaluated from right to left.\\n                staticcall(\\n                    gas(), // Remaining gas.\\n                    signer, // The `signer` address.\\n                    m, // Offset of calldata in memory.\\n                    0xa5, // Length of calldata in memory.\\n                    d, // Offset of returndata.\\n                    0x20 // Length of returndata to write.\\n                )\\n            )\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     HASHING OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, hash) // Store into scratch space for keccak256.\\n            mstore(0x00, \\\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19Ethereum Signed Message:\\\\n32\\\") // 28 bytes.\\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\\n        }\\n    }\\n\\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    /// Note: Supports lengths of `s` up to 999999 bytes.\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let sLength := mload(s)\\n            let o := 0x20\\n            mstore(o, \\\"\\\\x19Ethereum Signed Message:\\\\n\\\") // 26 bytes, zero-right-padded.\\n            mstore(0x00, 0x00)\\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\\n            for { let temp := sLength } 1 {} {\\n                o := sub(o, 1)\\n                mstore8(o, add(48, mod(temp, 10)))\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\\n            mstore(s, sLength) // Restore the length.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   EMPTY CALLDATA HELPERS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns an empty calldata bytes.\\n    function emptySignature() internal pure returns (bytes calldata signature) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            signature.length := 0\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@solady/=lib/solady/\",\r\n      \"@forge/=lib/forge-std/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solady/=lib/solady/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999999\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnauthorizedCallContext\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UpgradeFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"addDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"delegateExecute\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eip712Domain\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"fields\",\"type\":\"bytes1\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifyingContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"extensions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entryPoint\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct ERC4337.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"executeBatch\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"result\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"storageSlot\",\"type\":\"bytes32\"}],\"name\":\"storageLoad\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"result\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"storageSlot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"storageValue\",\"type\":\"bytes32\"}],\"name\":\"storageStore\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct ERC4337.UserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"userOpHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"missingAccountFunds\",\"type\":\"uint256\"}],\"name\":\"validateUserOp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawDepositTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Account", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "9999999", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}