{"SourceCode": "pragma solidity ^0.4.24;\r\n\r\ncontract SimpleMultiSig {\r\n\r\n// EIP712 Precomputed hashes:\r\n// keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\")\r\nbytes32 constant EIP712DOMAINTYPE_HASH = 0xd87cd6ef79d4e2b95e15ce8abf732db51ec771f1ca2edccf22a46c729ac56472;\r\n\r\n// keccak256(\"Simple MultiSig\")\r\nbytes32 constant NAME_HASH = 0xb7a0bfa1b79f2443f4d73ebb9259cddbcd510b18be6fc4da7d1aa7b1786e73e6;\r\n\r\n// keccak256(\"1\")\r\nbytes32 constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\r\n\r\n// keccak256(\"MultiSigTransaction(address destination,uint256 value,bytes data,uint256 nonce,address executor,uint256 gasLimit)\")\r\nbytes32 constant TXTYPE_HASH = 0x3ee892349ae4bbe61dce18f95115b5dc02daf49204cc602458cd4c1f540d56d7;\r\n\r\nbytes32 constant SALT = 0x251543af6a222378665a76fe38dbceae4871a070b7fdaf5c6c30cf758dc33cc0;\r\n\r\n  uint public nonce;                 // (only) mutable state\r\n  uint public threshold;             // immutable state\r\n  mapping (address => bool) isOwner; // immutable state\r\n  address[] public ownersArr;        // immutable state\r\n\r\n  bytes32 DOMAIN_SEPARATOR;          // hash for EIP712, computed from contract address\r\n\r\n  function owners() public view returns (address[]) {\r\n    return ownersArr;\r\n  }\r\n\r\n  // Note that owners_ must be strictly increasing, in order to prevent duplicates\r\n  function setOwners_(uint threshold_, address[] owners_) private {\r\n    require(owners_.length <= 20 && threshold_ <= owners_.length && threshold_ > 0);\r\n\r\n    // remove old owners from map\r\n    for (uint i = 0; i < ownersArr.length; i++) {\r\n      isOwner[ownersArr[i]] = false;\r\n    }\r\n\r\n    // add new owners to map\r\n    address lastAdd = address(0);\r\n    for (i = 0; i < owners_.length; i++) {\r\n      require(owners_[i] > lastAdd);\r\n      isOwner[owners_[i]] = true;\r\n      lastAdd = owners_[i];\r\n    }\r\n\r\n    // set owners array and threshold\r\n    ownersArr = owners_;\r\n    threshold = threshold_;\r\n  }\r\n\r\n  constructor(uint threshold_, address[] owners_, uint chainId) public {\r\n    setOwners_(threshold_, owners_);\r\n\r\n    DOMAIN_SEPARATOR = keccak256(abi.encode(EIP712DOMAINTYPE_HASH,\r\n                                            NAME_HASH,\r\n                                            VERSION_HASH,\r\n                                            chainId,\r\n                                            this,\r\n                                            SALT));\r\n  }\r\n\r\n  // Requires a quorum of owners to call from this contract using execute\r\n  function setOwners(uint threshold_, address[] owners_) external {\r\n    require(msg.sender == address(this));\r\n    setOwners_(threshold_, owners_);\r\n  }\r\n\r\n  // Note that address recovered from signatures must be strictly increasing, in order to prevent duplicates\r\n  function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data, address executor, uint gasLimit) public {\r\n    require(sigR.length == threshold);\r\n    require(sigR.length == sigS.length && sigR.length == sigV.length);\r\n    require(executor == msg.sender || executor == address(0));\r\n\r\n    // EIP712 scheme: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md\r\n    bytes32 txInputHash = keccak256(abi.encode(TXTYPE_HASH, destination, value, keccak256(data), nonce, executor, gasLimit));\r\n    bytes32 totalHash = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, txInputHash));\r\n\r\n    address lastAdd = address(0); // cannot have address(0) as an owner\r\n    for (uint i = 0; i < threshold; i++) {\r\n      address recovered = ecrecover(totalHash, sigV[i], sigR[i], sigS[i]);\r\n      require(recovered > lastAdd && isOwner[recovered]);\r\n      lastAdd = recovered;\r\n    }\r\n\r\n    // If we make it here all signatures are accounted for.\r\n    // The address.call() syntax is no longer recommended, see:\r\n    // https://github.com/ethereum/solidity/issues/2884\r\n    nonce = nonce + 1;\r\n    bool success = false;\r\n    assembly { success := call(gasLimit, destination, value, add(data, 0x20), mload(data), 0, 0) }\r\n    require(success);\r\n  }\r\n\r\n  function () payable external {}\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"threshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sigV\",\"type\":\"uint8[]\"},{\"name\":\"sigR\",\"type\":\"bytes32[]\"},{\"name\":\"sigS\",\"type\":\"bytes32[]\"},{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"executor\",\"type\":\"address\"},{\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownersArr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"threshold_\",\"type\":\"uint256\"},{\"name\":\"owners_\",\"type\":\"address[]\"}],\"name\":\"setOwners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"threshold_\",\"type\":\"uint256\"},{\"name\":\"owners_\",\"type\":\"address[]\"},{\"name\":\"chainId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]", "ContractName": "SimpleMultiSig", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000070000000000000000000000005d21c8c9dd0692bdeb7ac1a3fb24dfc3500e4c3e00000000000000000000000061efb23a6868a74a8dfe32651361a6165f6f173e000000000000000000000000687ba16f70c7f026c2a91aa12ec08e1be99dae920000000000000000000000006dc212f6610a34cdb4099e6e50b3178f0c7c980a000000000000000000000000868fb9d7618ab17ec5d023a8300031ac534ecf3a000000000000000000000000bc06f62766800da36e2a1331b55189d47d50e36c000000000000000000000000cd6907c159b375aa5c40196ba4d39d31895909c3", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://b64a6b48b8cf5ba778e8633b37621b5c5635bf66a15ba6263d89da684b3105a2"}