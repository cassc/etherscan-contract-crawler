{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"User.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport \\\"../SafeCast.sol\\\";\\r\\n\\r\\nimport \\\"../Constants.sol\\\";\\r\\nimport \\\"../Errors.sol\\\";\\r\\nimport {UserFloorAccount, CollectionAccount, SafeBoxKey} from \\\"./Structs.sol\\\";\\r\\n\\r\\nlibrary UserLib {\\r\\n    using SafeCast for uint256;\\r\\n\\r\\n    /// @notice update the account maintain credit on behalfOf `onBehalfOf`\\r\\n    event UpdateMaintainCredit(address indexed onBehalfOf, uint256 minMaintCredit);\\r\\n\\r\\n    address internal constant LIST_GUARD = address(1);\\r\\n\\r\\n    function ensureVipCredit(UserFloorAccount storage account, uint8 requireVipLevel, address creditToken)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 totalCredit = tokenBalance(account, creditToken);\\r\\n        if (Constants.getVipBalanceRequirements(requireVipLevel) > totalCredit) {\\r\\n            revert Errors.InsufficientBalanceForVipLevel();\\r\\n        }\\r\\n        return totalCredit;\\r\\n    }\\r\\n\\r\\n    function getMinMaintVipLevel(UserFloorAccount storage account) internal view returns (uint8) {\\r\\n        unchecked {\\r\\n            return uint8(account.vipInfo >> 240);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getMinLevelAndVipKeyCounts(uint256 vipInfo)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint8 minLevel, uint256[] memory counts)\\r\\n    {\\r\\n        unchecked {\\r\\n            counts = new uint256[](Constants.VIP_LEVEL_COUNT);\\r\\n            minLevel = uint8(vipInfo >> 240);\\r\\n            for (uint256 i; i < Constants.VIP_LEVEL_COUNT; ++i) {\\r\\n                counts[i] = (vipInfo >> (i * 24)) & 0xFFFFFF;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function storeMinLevelAndVipKeyCounts(\\r\\n        UserFloorAccount storage account,\\r\\n        uint8 minMaintVipLevel,\\r\\n        uint256[] memory keyCounts\\r\\n    ) internal {\\r\\n        unchecked {\\r\\n            uint256 _data = (uint256(minMaintVipLevel) << 240);\\r\\n            for (uint256 i; i < Constants.VIP_LEVEL_COUNT; ++i) {\\r\\n                _data |= ((keyCounts[i] & 0xFFFFFF) << (i * 24));\\r\\n            }\\r\\n            account.vipInfo = _data;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getOrAddCollection(UserFloorAccount storage user, address collection)\\r\\n        internal\\r\\n        returns (CollectionAccount storage)\\r\\n    {\\r\\n        CollectionAccount storage entry = user.accounts[collection];\\r\\n        if (entry.next == address(0)) {\\r\\n            if (user.firstCollection == address(0)) {\\r\\n                user.firstCollection = collection;\\r\\n                entry.next = LIST_GUARD;\\r\\n            } else {\\r\\n                entry.next = user.firstCollection;\\r\\n                user.firstCollection = collection;\\r\\n            }\\r\\n        }\\r\\n        return entry;\\r\\n    }\\r\\n\\r\\n    function removeCollection(UserFloorAccount storage userAccount, address collection, address prev) internal {\\r\\n        CollectionAccount storage cur = userAccount.accounts[collection];\\r\\n        if (cur.next == address(0)) revert Errors.InvalidParam();\\r\\n\\r\\n        if (collection == userAccount.firstCollection) {\\r\\n            if (cur.next == LIST_GUARD) {\\r\\n                userAccount.firstCollection = address(0);\\r\\n            } else {\\r\\n                userAccount.firstCollection = cur.next;\\r\\n            }\\r\\n        } else {\\r\\n            CollectionAccount storage prevAccount = userAccount.accounts[prev];\\r\\n            if (prevAccount.next != collection) revert Errors.InvalidParam();\\r\\n            prevAccount.next = cur.next;\\r\\n        }\\r\\n\\r\\n        delete userAccount.accounts[collection];\\r\\n    }\\r\\n\\r\\n    function getByKey(UserFloorAccount storage userAccount, address collection)\\r\\n        internal\\r\\n        view\\r\\n        returns (CollectionAccount storage)\\r\\n    {\\r\\n        return userAccount.accounts[collection];\\r\\n    }\\r\\n\\r\\n    function addSafeboxKey(CollectionAccount storage account, uint256 nftId, SafeBoxKey memory key) internal {\\r\\n        if (account.keys[nftId].keyId > 0) {\\r\\n            revert Errors.SafeBoxKeyAlreadyExist();\\r\\n        }\\r\\n\\r\\n        account.keys[nftId] = key;\\r\\n    }\\r\\n\\r\\n    function removeSafeboxKey(CollectionAccount storage account, uint256 nftId) internal {\\r\\n        delete account.keys[nftId];\\r\\n    }\\r\\n\\r\\n    function getByKey(CollectionAccount storage account, uint256 nftId) internal view returns (SafeBoxKey storage) {\\r\\n        return account.keys[nftId];\\r\\n    }\\r\\n\\r\\n    function tokenBalance(UserFloorAccount storage account, address token) internal view returns (uint256) {\\r\\n        return account.tokenAmounts[token];\\r\\n    }\\r\\n\\r\\n    function lockCredit(UserFloorAccount storage account, uint256 amount) internal {\\r\\n        unchecked {\\r\\n            account.lockedCredit += amount;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function unlockCredit(UserFloorAccount storage account, uint256 amount) internal {\\r\\n        unchecked {\\r\\n            account.lockedCredit -= amount;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function depositToken(UserFloorAccount storage account, address token, uint256 amount) internal {\\r\\n        account.tokenAmounts[token] += amount;\\r\\n    }\\r\\n\\r\\n    function withdrawToken(UserFloorAccount storage account, address token, uint256 amount, bool isCreditToken)\\r\\n        internal\\r\\n    {\\r\\n        uint256 balance = account.tokenAmounts[token];\\r\\n        if (balance < amount) {\\r\\n            revert Errors.InsufficientCredit();\\r\\n        }\\r\\n\\r\\n        if (isCreditToken) {\\r\\n            uint256 avaiableBuf;\\r\\n            unchecked {\\r\\n                avaiableBuf = balance - amount;\\r\\n            }\\r\\n            if (\\r\\n                avaiableBuf < Constants.getVipBalanceRequirements(getMinMaintVipLevel(account))\\r\\n                    || avaiableBuf < account.minMaintCredit || avaiableBuf < account.lockedCredit\\r\\n            ) {\\r\\n                revert Errors.InsufficientCredit();\\r\\n            }\\r\\n\\r\\n            account.tokenAmounts[token] = avaiableBuf;\\r\\n        } else {\\r\\n            unchecked {\\r\\n                account.tokenAmounts[token] = balance - amount;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function transferToken(\\r\\n        UserFloorAccount storage from,\\r\\n        UserFloorAccount storage to,\\r\\n        address token,\\r\\n        uint256 amount,\\r\\n        bool isCreditToken\\r\\n    ) internal {\\r\\n        withdrawToken(from, token, amount, isCreditToken);\\r\\n        depositToken(to, token, amount);\\r\\n    }\\r\\n\\r\\n    function updateVipKeyCount(UserFloorAccount storage account, uint8 vipLevel, int256 diff) internal {\\r\\n        if (vipLevel > 0 && diff != 0) {\\r\\n            (uint8 minMaintVipLevel, uint256[] memory keyCounts) = getMinLevelAndVipKeyCounts(account.vipInfo);\\r\\n\\r\\n            if (diff < 0) {\\r\\n                keyCounts[vipLevel] -= uint256(-diff);\\r\\n                if (vipLevel == minMaintVipLevel && keyCounts[vipLevel] == 0) {\\r\\n                    uint8 newVipLevel = vipLevel;\\r\\n                    do {\\r\\n                        unchecked {\\r\\n                            --newVipLevel;\\r\\n                        }\\r\\n                    } while (newVipLevel > 0 && keyCounts[newVipLevel] == 0);\\r\\n\\r\\n                    minMaintVipLevel = newVipLevel;\\r\\n                }\\r\\n            } else {\\r\\n                keyCounts[vipLevel] += uint256(diff);\\r\\n                if (vipLevel > minMaintVipLevel) {\\r\\n                    minMaintVipLevel = vipLevel;\\r\\n                }\\r\\n            }\\r\\n            storeMinLevelAndVipKeyCounts(account, minMaintVipLevel, keyCounts);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function recalculateMinMaintCredit(UserFloorAccount storage account, address onBehalfOf)\\r\\n        public\\r\\n        returns (uint256 maxLocking)\\r\\n    {\\r\\n        address prev = account.firstCollection;\\r\\n        for (address collection = account.firstCollection; collection != LIST_GUARD && collection != address(0);) {\\r\\n            (uint256 locking, address next) =\\r\\n                (getByKey(account, collection).totalLockingCredit, getByKey(account, collection).next);\\r\\n            if (locking == 0) {\\r\\n                removeCollection(account, collection, prev);\\r\\n                collection = next;\\r\\n            } else {\\r\\n                if (locking > maxLocking) {\\r\\n                    maxLocking = locking;\\r\\n                }\\r\\n                prev = collection;\\r\\n                collection = next;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        account.minMaintCredit = uint96(maxLocking);\\r\\n\\r\\n        emit UpdateMaintainCredit(onBehalfOf, maxLocking);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"Structs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport \\\"../interface/IFragmentToken.sol\\\";\\r\\n\\r\\nstruct SafeBox {\\r\\n    /// Either matching a key OR Constants.SAFEBOX_KEY_NOTATION meaning temporarily\\r\\n    /// held by a bidder in auction.\\r\\n    uint64 keyId;\\r\\n    /// The timestamp that the safe box expires.\\r\\n    uint32 expiryTs;\\r\\n    /// The owner of the safebox. It maybe outdated due to expiry\\r\\n    address owner;\\r\\n}\\r\\n\\r\\nstruct PrivateOffer {\\r\\n    /// private offer end time\\r\\n    uint96 endTime;\\r\\n    /// which token used to accpet the offer\\r\\n    address token;\\r\\n    /// price of the offer\\r\\n    uint96 price;\\r\\n    address owner;\\r\\n    /// who should receive the offer\\r\\n    address buyer;\\r\\n    uint64 activityId;\\r\\n}\\r\\n\\r\\nstruct AuctionInfo {\\r\\n    /// The end time for the auction.\\r\\n    uint96 endTime;\\r\\n    /// Bid token address.\\r\\n    address bidTokenAddress;\\r\\n    /// Minimum Bid.\\r\\n    uint96 minimumBid;\\r\\n    /// The person who trigger the auction at the beginning.\\r\\n    address triggerAddress;\\r\\n    uint96 lastBidAmount;\\r\\n    address lastBidder;\\r\\n    /// Whether the auction is triggered by the NFT owner itself\uff1f\\r\\n    bool isSelfTriggered;\\r\\n    uint64 activityId;\\r\\n    uint32 feeRateBips;\\r\\n}\\r\\n\\r\\nstruct TicketRecord {\\r\\n    /// who buy the tickets\\r\\n    address buyer;\\r\\n    /// Start index of tickets\\r\\n    /// [startIdx, endIdx)\\r\\n    uint48 startIdx;\\r\\n    /// End index of tickets\\r\\n    uint48 endIdx;\\r\\n}\\r\\n\\r\\nstruct RaffleInfo {\\r\\n    /// raffle end time\\r\\n    uint48 endTime;\\r\\n    /// max tickets amount the raffle can sell\\r\\n    uint48 maxTickets;\\r\\n    /// which token used to buy the raffle tickets\\r\\n    address token;\\r\\n    /// price per ticket\\r\\n    uint96 ticketPrice;\\r\\n    /// total funds collected by selling tickets\\r\\n    uint96 collectedFund;\\r\\n    uint64 activityId;\\r\\n    address owner;\\r\\n    /// total sold tickets amount\\r\\n    uint48 ticketSold;\\r\\n    uint32 feeRateBips;\\r\\n    /// whether the raffle is being settling\\r\\n    bool isSettling;\\r\\n    /// tickets sold records\\r\\n    TicketRecord[] tickets;\\r\\n}\\r\\n\\r\\nstruct CollectionState {\\r\\n    /// The address of the Floor Token cooresponding to the NFTs.\\r\\n    IFragmentToken floorToken;\\r\\n    /// Records the active safe box in each time bucket.\\r\\n    mapping(uint256 => uint256) countingBuckets;\\r\\n    /// Stores all of the NFTs that has been fragmented but *without* locked up limit.\\r\\n    uint256[] freeTokenIds;\\r\\n    /// Huge map for all the `SafeBox`es in one collection.\\r\\n    mapping(uint256 => SafeBox) safeBoxes;\\r\\n    /// Stores all the ongoing auctions: nftId => `AuctionInfo`.\\r\\n    mapping(uint256 => AuctionInfo) activeAuctions;\\r\\n    /// Stores all the ongoing raffles: nftId => `RaffleInfo`.\\r\\n    mapping(uint256 => RaffleInfo) activeRaffles;\\r\\n    /// Stores all the ongoing private offers: nftId => `PrivateOffer`.\\r\\n    mapping(uint256 => PrivateOffer) activePrivateOffers;\\r\\n    /// The last bucket time the `countingBuckets` is updated.\\r\\n    uint64 lastUpdatedBucket;\\r\\n    /// Next Key Id. This should start from 1, we treat key id `SafeboxLib.SAFEBOX_KEY_NOTATION` as temporarily\\r\\n    /// being used for activities(auction/raffle).\\r\\n    uint64 nextKeyId;\\r\\n    /// Active Safe Box Count.\\r\\n    uint64 activeSafeBoxCnt;\\r\\n    /// The number of infinite lock count.\\r\\n    uint64 infiniteCnt;\\r\\n    /// Next Activity Id. This should start from 1\\r\\n    uint64 nextActivityId;\\r\\n}\\r\\n\\r\\nstruct UserFloorAccount {\\r\\n    /// @notice it should be maximum of the `totalLockingCredit` across all collections\\r\\n    uint96 minMaintCredit;\\r\\n    /// @notice used to iterate collection accounts\\r\\n    /// packed with `minMaintCredit` to reduce storage slot access\\r\\n    address firstCollection;\\r\\n    /// @notice user vip level related info\\r\\n    /// 0 - 239 bits: store SafeBoxKey Count per vip level, per level using 24 bits\\r\\n    /// 240 - 247 bits: store minMaintVipLevel\\r\\n    /// 248 - 255 bits: remaining\\r\\n    uint256 vipInfo;\\r\\n    /// @notice Locked Credit amount which cannot be withdrawn and will be released as time goes.\\r\\n    uint256 lockedCredit;\\r\\n    mapping(address => CollectionAccount) accounts;\\r\\n    mapping(address => uint256) tokenAmounts;\\r\\n}\\r\\n\\r\\nstruct SafeBoxKey {\\r\\n    /// locked credit amount of this safebox\\r\\n    uint96 lockingCredit;\\r\\n    /// corresponding key id of the safebox\\r\\n    uint64 keyId;\\r\\n    /// which vip level the safebox locked\\r\\n    uint8 vipLevel;\\r\\n}\\r\\n\\r\\nstruct CollectionAccount {\\r\\n    mapping(uint256 => SafeBoxKey) keys;\\r\\n    /// total locking credit of all `keys` in this collection\\r\\n    uint96 totalLockingCredit;\\r\\n    /// track next collection as linked list\\r\\n    address next;\\r\\n}\\r\\n\\r\\n/// Internal Structure\\r\\nstruct LockParam {\\r\\n    address proxyCollection;\\r\\n    address collection;\\r\\n    uint256[] nftIds;\\r\\n    uint256 expiryTs;\\r\\n    uint256 vipLevel;\\r\\n    uint256 maxCreditCost;\\r\\n    address creditToken;\\r\\n}\"\r\n    },\r\n    \"Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nlibrary Errors {\\r\\n    /// @notice Safe Box error\\r\\n    error SafeBoxHasExpire();\\r\\n    error SafeBoxNotExist();\\r\\n    error SafeBoxHasNotExpire();\\r\\n    error SafeBoxAlreadyExist();\\r\\n    error NoMatchingSafeBoxKey();\\r\\n    error SafeBoxKeyAlreadyExist();\\r\\n\\r\\n    /// @notice Auction error\\r\\n    error AuctionHasNotCompleted();\\r\\n    error AuctionHasExpire();\\r\\n    error AuctionBidIsNotHighEnough();\\r\\n    error AuctionBidTokenMismatch();\\r\\n    error AuctionSelfBid();\\r\\n    error AuctionInvalidBidAmount();\\r\\n    error AuctionNotExist();\\r\\n    error SafeBoxAuctionWindowHasPassed();\\r\\n\\r\\n    /// @notice Activity common error\\r\\n    error NftHasActiveActivities();\\r\\n    error ActivityHasNotCompleted();\\r\\n    error ActivityHasExpired();\\r\\n    error ActivityNotExist();\\r\\n\\r\\n    /// @notice User account error\\r\\n    error InsufficientCredit();\\r\\n    error InsufficientBalanceForVipLevel();\\r\\n    error NoPrivilege();\\r\\n\\r\\n    /// @notice Parameter error\\r\\n    error InvalidParam();\\r\\n    error NftCollectionNotSupported();\\r\\n    error NftCollectionAlreadySupported();\\r\\n    error ClaimableNftInsufficient();\\r\\n    error TokenNotSupported();\\r\\n}\"\r\n    },\r\n    \"Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nlibrary Constants {\\r\\n    /// @notice Flooring protocol\\r\\n    /// @dev floor token amount of 1 NFT (with 18 decimals)\\r\\n    uint256 public constant FLOOR_TOKEN_AMOUNT = 1_000_000 ether;\\r\\n    /// @dev The minimum vip level required to use `proxy collection`\\r\\n    uint8 public constant PROXY_COLLECTION_VIP_THRESHOLD = 3;\\r\\n\\r\\n    /// @notice Rolling Bucket Constant Conf\\r\\n    uint256 public constant BUCKET_SPAN_1 = 259199 seconds; // BUCKET_SPAN minus 1, used for rounding up\\r\\n    uint256 public constant BUCKET_SPAN = 3 days;\\r\\n    uint256 public constant MAX_LOCKING_BUCKET = 240;\\r\\n    uint256 public constant MAX_LOCKING_PERIOD = 720 days; // MAX LOCKING BUCKET * BUCKET_SPAN\\r\\n\\r\\n    /// @notice Auction Config\\r\\n    uint256 public constant FREE_AUCTION_PERIOD = 24 hours;\\r\\n    uint256 public constant AUCTION_INITIAL_PERIODS = 24 hours;\\r\\n    uint256 public constant AUCTION_COMPLETE_GRACE_PERIODS = 2 days;\\r\\n    /// @dev minimum bid per NFT when someone starts aution on expired safebox\\r\\n    uint256 public constant AUCTION_ON_EXPIRED_MINIMUM_BID = 1000 ether;\\r\\n    /// @dev admin fee charged per NFT when someone starts aution on expired safebox\\r\\n    uint256 public constant AUCTION_ON_EXPIRED_SAFEBOX_COST = 2000 ether;\\r\\n    /// @dev admin fee charged per NFT when owner starts aution on himself safebox\\r\\n    uint256 public constant AUCTION_COST = 2000 ether;\\r\\n\\r\\n    /// @notice Raffle Config\\r\\n    uint256 public constant RAFFLE_COST = 5000 ether;\\r\\n    uint256 public constant RAFFLE_COMPLETE_GRACE_PERIODS = 2 days;\\r\\n\\r\\n    /// @notice Private offer Config\\r\\n    uint256 public constant PRIVATE_OFFER_DURATION = 24 hours;\\r\\n    uint256 public constant PRIVATE_OFFER_COMPLETE_GRACE_DURATION = 2 days;\\r\\n    uint256 public constant PRIVATE_OFFER_COST = 0;\\r\\n\\r\\n    uint256 public constant ADD_FREE_NFT_REWARD = 0;\\r\\n\\r\\n    /// @notice Lock/Unlock config\\r\\n    uint256 public constant LOCKING_RAMP_UP_THRESHOLD = 20;\\r\\n\\r\\n    uint256 public constant LOCKING_PCT_TO_SAFEBOX_MAINT_MIN = 6000 ether;\\r\\n    uint256 public constant LOCKING_PCT_TO_SAFEBOX_MAINT_MAX = 1728000 ether;\\r\\n\\r\\n    /// @notice Activities Fee Rate\\r\\n\\r\\n    /// @notice Fee rate used to distribute funds that collected from Auctions on expired safeboxes.\\r\\n    /// these auction would be settled using credit token\\r\\n    uint256 public constant FREE_AUCTION_FEE_RATE_BIPS = 2000; // 20%\\r\\n    /// @notice Fee rate settled with credit token\\r\\n    uint256 public constant CREDIT_FEE_RATE_BIPS = 150; // 2%\\r\\n    /// @notice Fee rate settled with specified token\\r\\n    uint256 public constant SPEC_FEE_RATE_BIPS = 300; // 3%\\r\\n    /// @notice Fee rate settled with all other tokens\\r\\n    uint256 public constant COMMON_FEE_RATE_BIPS = 500; // 5%\\r\\n\\r\\n    uint256 public constant VIP_LEVEL_COUNT = 8;\\r\\n\\r\\n    struct AuctionBidOption {\\r\\n        uint256 extendDurationSecs;\\r\\n        uint256 minimumRaisePct;\\r\\n        uint256 vipLevel;\\r\\n    }\\r\\n\\r\\n    function getVipLockingBuckets(uint256 vipLevel) internal pure returns (uint256 buckets) {\\r\\n        require(vipLevel < VIP_LEVEL_COUNT);\\r\\n        assembly {\\r\\n            switch vipLevel\\r\\n            case 1 { buckets := 1 }\\r\\n            case 2 { buckets := 5 }\\r\\n            case 3 { buckets := 20 }\\r\\n            case 4 { buckets := 60 }\\r\\n            case 5 { buckets := 120 }\\r\\n            case 6 { buckets := 240 }\\r\\n            case 7 { buckets := MAX_LOCKING_BUCKET }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getVipLevel(uint256 totalCredit) internal pure returns (uint8) {\\r\\n        if (totalCredit < 50_000 ether) {\\r\\n            return 0;\\r\\n        } else if (totalCredit < 200_000 ether) {\\r\\n            return 1;\\r\\n        } else if (totalCredit < 500_000 ether) {\\r\\n            return 2;\\r\\n        } else if (totalCredit < 2_000_000 ether) {\\r\\n            return 3;\\r\\n        } else if (totalCredit < 5_000_000 ether) {\\r\\n            return 4;\\r\\n        } else if (totalCredit < 20_000_000 ether) {\\r\\n            return 5;\\r\\n        } else if (totalCredit < 50_000_000 ether) {\\r\\n            return 6;\\r\\n        } else {\\r\\n            return 7;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getVipBalanceRequirements(uint256 vipLevel) internal pure returns (uint256 required) {\\r\\n        require(vipLevel < VIP_LEVEL_COUNT);\\r\\n\\r\\n        assembly {\\r\\n            switch vipLevel\\r\\n            case 1 { required := 50000 }\\r\\n            case 2 { required := 200000 }\\r\\n            case 3 { required := 500000 }\\r\\n            case 4 { required := 2000000 }\\r\\n            case 5 { required := 5000000 }\\r\\n            case 6 { required := 20000000 }\\r\\n            case 7 { required := 50000000 }\\r\\n        }\\r\\n\\r\\n        /// credit token should be scaled with 18 decimals(1 ether == 10**18)\\r\\n        unchecked {\\r\\n            return required * 1 ether;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getBidOption(uint256 idx) internal pure returns (AuctionBidOption memory) {\\r\\n        require(idx < 4);\\r\\n        AuctionBidOption[4] memory bidOptions = [\\r\\n            AuctionBidOption({extendDurationSecs: 5 minutes, minimumRaisePct: 1, vipLevel: 0}),\\r\\n            AuctionBidOption({extendDurationSecs: 8 hours, minimumRaisePct: 10, vipLevel: 3}),\\r\\n            AuctionBidOption({extendDurationSecs: 16 hours, minimumRaisePct: 20, vipLevel: 5}),\\r\\n            AuctionBidOption({extendDurationSecs: 24 hours, minimumRaisePct: 40, vipLevel: 7})\\r\\n        ];\\r\\n        return bidOptions[idx];\\r\\n    }\\r\\n\\r\\n    function raffleDurations(uint256 idx) internal pure returns (uint256 vipLevel, uint256 duration) {\\r\\n        require(idx < 6);\\r\\n\\r\\n        vipLevel = idx;\\r\\n        assembly {\\r\\n            switch idx\\r\\n            case 1 { duration := 1 }\\r\\n            case 2 { duration := 2 }\\r\\n            case 3 { duration := 3 }\\r\\n            case 4 { duration := 5 }\\r\\n            case 5 { duration := 7 }\\r\\n        }\\r\\n        unchecked {\\r\\n            duration *= 1 days;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getVipRequiredStakingWithDiscount(uint256 requiredStaking, uint8 vipLevel)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        if (vipLevel < 3) {\\r\\n            return requiredStaking;\\r\\n        }\\r\\n        unchecked {\\r\\n            /// the higher vip level, more discount for staking\\r\\n            ///  discount range: 10% - 50%\\r\\n            return requiredStaking * (100 - (vipLevel - 2) * 10) / 100;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getRequiredStakingForLockRatio(uint256 locked, uint256 totalManaged) internal pure returns (uint256) {\\r\\n        if (totalManaged < Constants.LOCKING_RAMP_UP_THRESHOLD) {\\r\\n            return 6000 ether;\\r\\n        }\\r\\n\\r\\n        unchecked {\\r\\n            uint256 lockingRatioPct = locked * 100 / totalManaged;\\r\\n            if (lockingRatioPct <= 40) {\\r\\n                return 6000 ether;\\r\\n            } else if (lockingRatioPct < 60) {\\r\\n                return 6600 ether + ((lockingRatioPct - 40) >> 1) * 600 ether;\\r\\n            } else if (lockingRatioPct < 70) {\\r\\n                return 13200 ether + ((lockingRatioPct - 60) >> 1) * 1200 ether;\\r\\n            } else if (lockingRatioPct < 80) {\\r\\n                return 20400 ether + ((lockingRatioPct - 70) >> 1) * 2400 ether;\\r\\n            } else if (lockingRatioPct < 90) {\\r\\n                return 34800 ether + ((lockingRatioPct - 80) >> 1) * 4800 ether;\\r\\n            } else if (lockingRatioPct < 100) {\\r\\n                /// 108000 * 2^x\\r\\n                return 108000 ether << ((lockingRatioPct - 90) >> 1);\\r\\n            } else {\\r\\n                return 1728000 ether;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getVipClaimCostWithDiscount(uint256 cost, uint8 vipLevel) internal pure returns (uint256) {\\r\\n        if (vipLevel < 3) {\\r\\n            return cost;\\r\\n        }\\r\\n\\r\\n        unchecked {\\r\\n            uint256 discount = 4000 ether << (vipLevel - 3);\\r\\n            if (cost < discount) {\\r\\n                return 0;\\r\\n            } else {\\r\\n                return cost - discount;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getClaimExpiredCost(uint256 locked, uint256 totalManaged, uint8 vipLevel)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 realCost = getClaimCost(locked, totalManaged);\\r\\n        return getVipClaimCostWithDiscount(realCost, vipLevel);\\r\\n    }\\r\\n\\r\\n    function getClaimRandomCost(uint256 locked, uint256 totalManaged, uint8 vipLevel) internal pure returns (uint256) {\\r\\n        uint256 realCost = getClaimCost(locked, totalManaged);\\r\\n        return getVipClaimCostWithDiscount(realCost, vipLevel);\\r\\n    }\\r\\n\\r\\n    function getClaimCost(uint256 locked, uint256 totalManaged) private pure returns (uint256) {\\r\\n        if (totalManaged < Constants.LOCKING_RAMP_UP_THRESHOLD) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        unchecked {\\r\\n            uint256 lockingRatioPct = locked * 100 / totalManaged;\\r\\n\\r\\n            if (lockingRatioPct <= 60) {\\r\\n                return 0;\\r\\n            } else if (lockingRatioPct < 100) {\\r\\n                uint256 cost = 1 ether;\\r\\n                assembly {\\r\\n                    switch shr(1, sub(lockingRatioPct, 60))\\r\\n                    case 0 { cost := mul(cost, 400) }\\r\\n                    case 1 { cost := mul(cost, 600) }\\r\\n                    case 2 { cost := mul(cost, 800) }\\r\\n                    case 3 { cost := mul(cost, 1200) }\\r\\n                    case 4 { cost := mul(cost, 1600) }\\r\\n                    case 5 { cost := mul(cost, 2400) }\\r\\n                    case 6 { cost := mul(cost, 3200) }\\r\\n                    case 7 { cost := mul(cost, 4800) }\\r\\n                    case 8 { cost := mul(cost, 6400) }\\r\\n                    case 9 { cost := mul(cost, 9600) }\\r\\n                    case 10 { cost := mul(cost, 12800) }\\r\\n                    case 11 { cost := mul(cost, 19200) }\\r\\n                    case 12 { cost := mul(cost, 25600) }\\r\\n                    case 13 { cost := mul(cost, 38400) }\\r\\n                    case 14 { cost := mul(cost, 51200) }\\r\\n                    case 15 { cost := mul(cost, 76800) }\\r\\n                    case 16 { cost := mul(cost, 102400) }\\r\\n                    case 17 { cost := mul(cost, 153600) }\\r\\n                    case 18 { cost := mul(cost, 204800) }\\r\\n                    case 19 { cost := mul(cost, 307200) }\\r\\n                }\\r\\n                return cost;\\r\\n            } else {\\r\\n                return 307200 ether;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\\r\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\r\\n * easily result in undesired exploitation or bugs, since developers usually\\r\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\r\\n * reverting the transaction when such an operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeCast {\\r\\n    /**\\r\\n     * @dev Value doesn't fit in an uint of `bits` size.\\r\\n     */\\r\\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev An int value doesn't fit in an uint of `bits` size.\\r\\n     */\\r\\n    error SafeCastOverflowedIntToUint(int256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Value doesn't fit in an int of `bits` size.\\r\\n     */\\r\\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev An uint value doesn't fit in an int of `bits` size.\\r\\n     */\\r\\n    error SafeCastOverflowedUintToInt(uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint248).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint248` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 248 bits\\r\\n     */\\r\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\r\\n        if (value > type(uint248).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(248, value);\\r\\n        }\\r\\n        return uint248(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint240).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint240` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 240 bits\\r\\n     */\\r\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\r\\n        if (value > type(uint240).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(240, value);\\r\\n        }\\r\\n        return uint240(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint232).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint232` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 232 bits\\r\\n     */\\r\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\r\\n        if (value > type(uint232).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(232, value);\\r\\n        }\\r\\n        return uint232(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint224).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint224` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 224 bits\\r\\n     */\\r\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\r\\n        if (value > type(uint224).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(224, value);\\r\\n        }\\r\\n        return uint224(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint216).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint216` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 216 bits\\r\\n     */\\r\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\r\\n        if (value > type(uint216).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(216, value);\\r\\n        }\\r\\n        return uint216(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint208).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint208` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 208 bits\\r\\n     */\\r\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\r\\n        if (value > type(uint208).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(208, value);\\r\\n        }\\r\\n        return uint208(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint200).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint200` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 200 bits\\r\\n     */\\r\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\r\\n        if (value > type(uint200).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(200, value);\\r\\n        }\\r\\n        return uint200(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint192).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint192` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 192 bits\\r\\n     */\\r\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\r\\n        if (value > type(uint192).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(192, value);\\r\\n        }\\r\\n        return uint192(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint184).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint184` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 184 bits\\r\\n     */\\r\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\r\\n        if (value > type(uint184).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(184, value);\\r\\n        }\\r\\n        return uint184(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint176).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint176` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 176 bits\\r\\n     */\\r\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\r\\n        if (value > type(uint176).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(176, value);\\r\\n        }\\r\\n        return uint176(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint168).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint168` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 168 bits\\r\\n     */\\r\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\r\\n        if (value > type(uint168).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(168, value);\\r\\n        }\\r\\n        return uint168(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint160).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint160` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 160 bits\\r\\n     */\\r\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\r\\n        if (value > type(uint160).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(160, value);\\r\\n        }\\r\\n        return uint160(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint152).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint152` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 152 bits\\r\\n     */\\r\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\r\\n        if (value > type(uint152).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(152, value);\\r\\n        }\\r\\n        return uint152(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint144).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint144` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 144 bits\\r\\n     */\\r\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\r\\n        if (value > type(uint144).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(144, value);\\r\\n        }\\r\\n        return uint144(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint136).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint136` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 136 bits\\r\\n     */\\r\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\r\\n        if (value > type(uint136).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(136, value);\\r\\n        }\\r\\n        return uint136(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint128).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint128` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 128 bits\\r\\n     */\\r\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\r\\n        if (value > type(uint128).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(128, value);\\r\\n        }\\r\\n        return uint128(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint120).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint120` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 120 bits\\r\\n     */\\r\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\r\\n        if (value > type(uint120).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(120, value);\\r\\n        }\\r\\n        return uint120(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint112).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint112` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 112 bits\\r\\n     */\\r\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\r\\n        if (value > type(uint112).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(112, value);\\r\\n        }\\r\\n        return uint112(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint104).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint104` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 104 bits\\r\\n     */\\r\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\r\\n        if (value > type(uint104).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(104, value);\\r\\n        }\\r\\n        return uint104(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint96).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint96` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 96 bits\\r\\n     */\\r\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\r\\n        if (value > type(uint96).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(96, value);\\r\\n        }\\r\\n        return uint96(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint88).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint88` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 88 bits\\r\\n     */\\r\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\r\\n        if (value > type(uint88).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(88, value);\\r\\n        }\\r\\n        return uint88(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint80).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint80` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 80 bits\\r\\n     */\\r\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\r\\n        if (value > type(uint80).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(80, value);\\r\\n        }\\r\\n        return uint80(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint72).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint72` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 72 bits\\r\\n     */\\r\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\r\\n        if (value > type(uint72).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(72, value);\\r\\n        }\\r\\n        return uint72(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint64).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint64` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 64 bits\\r\\n     */\\r\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\r\\n        if (value > type(uint64).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(64, value);\\r\\n        }\\r\\n        return uint64(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint56).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint56` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 56 bits\\r\\n     */\\r\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\r\\n        if (value > type(uint56).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(56, value);\\r\\n        }\\r\\n        return uint56(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint48).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint48` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 48 bits\\r\\n     */\\r\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\r\\n        if (value > type(uint48).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(48, value);\\r\\n        }\\r\\n        return uint48(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint40).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint40` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 40 bits\\r\\n     */\\r\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\r\\n        if (value > type(uint40).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(40, value);\\r\\n        }\\r\\n        return uint40(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint32).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint32` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 32 bits\\r\\n     */\\r\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\r\\n        if (value > type(uint32).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(32, value);\\r\\n        }\\r\\n        return uint32(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint24).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint24` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 24 bits\\r\\n     */\\r\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\r\\n        if (value > type(uint24).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(24, value);\\r\\n        }\\r\\n        return uint24(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint16).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint16` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 16 bits\\r\\n     */\\r\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\r\\n        if (value > type(uint16).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(16, value);\\r\\n        }\\r\\n        return uint16(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint8).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint8` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 8 bits\\r\\n     */\\r\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\r\\n        if (value > type(uint8).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(8, value);\\r\\n        }\\r\\n        return uint8(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a signed int256 into an unsigned uint256.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must be greater than or equal to 0.\\r\\n     */\\r\\n    function toUint256(int256 value) internal pure returns (uint256) {\\r\\n        if (value < 0) {\\r\\n            revert SafeCastOverflowedIntToUint(value);\\r\\n        }\\r\\n        return uint256(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int248 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int248 or\\r\\n     * greater than largest int248).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int248` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 248 bits\\r\\n     */\\r\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\r\\n        downcasted = int248(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(248, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int240 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int240 or\\r\\n     * greater than largest int240).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int240` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 240 bits\\r\\n     */\\r\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\r\\n        downcasted = int240(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(240, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int232 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int232 or\\r\\n     * greater than largest int232).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int232` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 232 bits\\r\\n     */\\r\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\r\\n        downcasted = int232(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(232, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int224 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int224 or\\r\\n     * greater than largest int224).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int224` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 224 bits\\r\\n     */\\r\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\r\\n        downcasted = int224(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(224, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int216 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int216 or\\r\\n     * greater than largest int216).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int216` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 216 bits\\r\\n     */\\r\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\r\\n        downcasted = int216(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(216, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int208 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int208 or\\r\\n     * greater than largest int208).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int208` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 208 bits\\r\\n     */\\r\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\r\\n        downcasted = int208(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(208, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int200 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int200 or\\r\\n     * greater than largest int200).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int200` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 200 bits\\r\\n     */\\r\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\r\\n        downcasted = int200(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(200, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int192 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int192 or\\r\\n     * greater than largest int192).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int192` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 192 bits\\r\\n     */\\r\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\r\\n        downcasted = int192(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(192, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int184 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int184 or\\r\\n     * greater than largest int184).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int184` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 184 bits\\r\\n     */\\r\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\r\\n        downcasted = int184(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(184, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int176 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int176 or\\r\\n     * greater than largest int176).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int176` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 176 bits\\r\\n     */\\r\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\r\\n        downcasted = int176(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(176, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int168 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int168 or\\r\\n     * greater than largest int168).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int168` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 168 bits\\r\\n     */\\r\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\r\\n        downcasted = int168(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(168, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int160 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int160 or\\r\\n     * greater than largest int160).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int160` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 160 bits\\r\\n     */\\r\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\r\\n        downcasted = int160(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(160, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int152 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int152 or\\r\\n     * greater than largest int152).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int152` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 152 bits\\r\\n     */\\r\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\r\\n        downcasted = int152(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(152, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int144 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int144 or\\r\\n     * greater than largest int144).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int144` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 144 bits\\r\\n     */\\r\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\r\\n        downcasted = int144(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(144, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int136 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int136 or\\r\\n     * greater than largest int136).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int136` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 136 bits\\r\\n     */\\r\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\r\\n        downcasted = int136(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(136, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int128 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int128 or\\r\\n     * greater than largest int128).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int128` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 128 bits\\r\\n     */\\r\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\r\\n        downcasted = int128(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(128, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int120 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int120 or\\r\\n     * greater than largest int120).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int120` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 120 bits\\r\\n     */\\r\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\r\\n        downcasted = int120(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(120, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int112 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int112 or\\r\\n     * greater than largest int112).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int112` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 112 bits\\r\\n     */\\r\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\r\\n        downcasted = int112(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(112, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int104 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int104 or\\r\\n     * greater than largest int104).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int104` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 104 bits\\r\\n     */\\r\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\r\\n        downcasted = int104(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(104, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int96 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int96 or\\r\\n     * greater than largest int96).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int96` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 96 bits\\r\\n     */\\r\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\r\\n        downcasted = int96(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(96, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int88 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int88 or\\r\\n     * greater than largest int88).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int88` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 88 bits\\r\\n     */\\r\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\r\\n        downcasted = int88(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(88, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int80 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int80 or\\r\\n     * greater than largest int80).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int80` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 80 bits\\r\\n     */\\r\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\r\\n        downcasted = int80(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(80, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int72 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int72 or\\r\\n     * greater than largest int72).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int72` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 72 bits\\r\\n     */\\r\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\r\\n        downcasted = int72(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(72, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int64 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int64 or\\r\\n     * greater than largest int64).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int64` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 64 bits\\r\\n     */\\r\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\r\\n        downcasted = int64(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(64, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int56 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int56 or\\r\\n     * greater than largest int56).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int56` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 56 bits\\r\\n     */\\r\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\r\\n        downcasted = int56(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(56, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int48 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int48 or\\r\\n     * greater than largest int48).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int48` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 48 bits\\r\\n     */\\r\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\r\\n        downcasted = int48(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(48, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int40 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int40 or\\r\\n     * greater than largest int40).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int40` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 40 bits\\r\\n     */\\r\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\r\\n        downcasted = int40(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(40, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int32 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int32 or\\r\\n     * greater than largest int32).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int32` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 32 bits\\r\\n     */\\r\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\r\\n        downcasted = int32(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(32, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int24 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int24 or\\r\\n     * greater than largest int24).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int24` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 24 bits\\r\\n     */\\r\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\r\\n        downcasted = int24(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(24, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int16 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int16 or\\r\\n     * greater than largest int16).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int16` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 16 bits\\r\\n     */\\r\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\r\\n        downcasted = int16(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(16, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int8 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int8 or\\r\\n     * greater than largest int8).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int8` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 8 bits\\r\\n     */\\r\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\r\\n        downcasted = int8(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(8, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an unsigned uint256 into a signed int256.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must be less than or equal to maxInt256.\\r\\n     */\\r\\n    function toInt256(uint256 value) internal pure returns (int256) {\\r\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\r\\n        if (value > uint256(type(int256).max)) {\\r\\n            revert SafeCastOverflowedUintToInt(value);\\r\\n        }\\r\\n        return int256(value);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"interface/IFragmentToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\ninterface IFragmentToken {\\r\\n    error CallerIsNotTrustedContract();\\r\\n\\r\\n    function mint(address account, uint256 amount) external;\\r\\n\\r\\n    function burn(address account, uint256 amount) external;\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"InvalidParam\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minMaintCredit\",\"type\":\"uint256\"}],\"name\":\"UpdateMaintainCredit\",\"type\":\"event\"}]", "ContractName": "UserLib", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}