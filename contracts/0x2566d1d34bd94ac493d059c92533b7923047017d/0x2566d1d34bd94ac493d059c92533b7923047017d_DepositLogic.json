{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(account),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC1967.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n *\\n * _Available since v4.8.3._\\n */\\ninterface IERC1967 {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/extensions/IERC721Metadata.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IBeacon.sol\\\";\\nimport \\\"../Proxy.sol\\\";\\nimport \\\"../ERC1967/ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\\n *\\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\\n * conflict with the storage layout of the implementation behind the proxy.\\n *\\n * _Available since v3.4._\\n */\\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\\n    /**\\n     * @dev Initializes the proxy with `beacon`.\\n     *\\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\\n     * constructor.\\n     *\\n     * Requirements:\\n     *\\n     * - `beacon` must be a contract with the interface {IBeacon}.\\n     */\\n    constructor(address beacon, bytes memory data) payable {\\n        _upgradeBeaconToAndCall(beacon, data, false);\\n    }\\n\\n    /**\\n     * @dev Returns the current beacon address.\\n     */\\n    function _beacon() internal view virtual returns (address) {\\n        return _getBeacon();\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address of the associated beacon.\\n     */\\n    function _implementation() internal view virtual override returns (address) {\\n        return IBeacon(_getBeacon()).implementation();\\n    }\\n\\n    /**\\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\\n     *\\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\\n     *\\n     * Requirements:\\n     *\\n     * - `beacon` must be a contract.\\n     * - The implementation returned by `beacon` must be a contract.\\n     */\\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\\n        _upgradeBeaconToAndCall(beacon, data, false);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/UpgradeableBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IBeacon.sol\\\";\\nimport \\\"../../access/Ownable.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\\n * implementation contract, which is where they will delegate all function calls.\\n *\\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\\n */\\ncontract UpgradeableBeacon is IBeacon, Ownable {\\n    address private _implementation;\\n\\n    /**\\n     * @dev Emitted when the implementation returned by the beacon is changed.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\\n     * beacon.\\n     */\\n    constructor(address implementation_) {\\n        _setImplementation(implementation_);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function implementation() public view virtual override returns (address) {\\n        return _implementation;\\n    }\\n\\n    /**\\n     * @dev Upgrades the beacon to a new implementation.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * Requirements:\\n     *\\n     * - msg.sender must be the owner of the contract.\\n     * - `newImplementation` must be a contract.\\n     */\\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Sets the implementation contract address for this beacon\\n     *\\n     * Requirements:\\n     *\\n     * - `newImplementation` must be a contract.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"UpgradeableBeacon: implementation is not a contract\\\");\\n        _implementation = newImplementation;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt\\n    ) internal view returns (address predicted) {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Proxy.sol\\\";\\nimport \\\"./ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n */\\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) payable {\\n        _upgradeToAndCall(_logic, _data, false);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal view virtual override returns (address impl) {\\n        return ERC1967Upgrade._getImplementation();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../interfaces/IERC1967.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract ERC1967Upgrade is IERC1967 {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overridden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC1967/ERC1967Proxy.sol\\\";\\n\\n/**\\n * @dev Interface for {TransparentUpgradeableProxy}. In order to implement transparency, {TransparentUpgradeableProxy}\\n * does not implement this interface directly, and some of its functions are implemented by an internal dispatch\\n * mechanism. The compiler is unaware that these functions are implemented by {TransparentUpgradeableProxy} and will not\\n * include them in the ABI so this interface must be used to interact with it.\\n */\\ninterface ITransparentUpgradeableProxy is IERC1967 {\\n    function admin() external view returns (address);\\n\\n    function implementation() external view returns (address);\\n\\n    function changeAdmin(address) external;\\n\\n    function upgradeTo(address) external;\\n\\n    function upgradeToAndCall(address, bytes memory) external payable;\\n}\\n\\n/**\\n * @dev This contract implements a proxy that is upgradeable by an admin.\\n *\\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\\n * clashing], which can potentially be used in an attack, this contract uses the\\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\\n * things that go hand in hand:\\n *\\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\\n * that call matches one of the admin functions exposed by the proxy itself.\\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\\n * \\\"admin cannot fallback to proxy target\\\".\\n *\\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\\n * to sudden errors when trying to call a function from the proxy implementation.\\n *\\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\\n *\\n * NOTE: The real interface of this proxy is that defined in `ITransparentUpgradeableProxy`. This contract does not\\n * inherit from that interface, and instead the admin functions are implicitly implemented using a custom dispatch\\n * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to\\n * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the\\n * implementation.\\n *\\n * WARNING: It is not recommended to extend this contract to add additional external functions. If you do so, the compiler\\n * will not check that there are no selector conflicts, due to the note above. A selector clash between any new function\\n * and the functions declared in {ITransparentUpgradeableProxy} will be resolved in favor of the new one. This could\\n * render the admin operations inaccessible, which could prevent upgradeability. Transparency may also be compromised.\\n */\\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\\n    /**\\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\\n     */\\n    constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\\n        _changeAdmin(admin_);\\n    }\\n\\n    /**\\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\\n     *\\n     * CAUTION: This modifier is deprecated, as it could cause issues if the modified function has arguments, and the\\n     * implementation provides a function with the same selector.\\n     */\\n    modifier ifAdmin() {\\n        if (msg.sender == _getAdmin()) {\\n            _;\\n        } else {\\n            _fallback();\\n        }\\n    }\\n\\n    /**\\n     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior\\n     */\\n    function _fallback() internal virtual override {\\n        if (msg.sender == _getAdmin()) {\\n            bytes memory ret;\\n            bytes4 selector = msg.sig;\\n            if (selector == ITransparentUpgradeableProxy.upgradeTo.selector) {\\n                ret = _dispatchUpgradeTo();\\n            } else if (selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {\\n                ret = _dispatchUpgradeToAndCall();\\n            } else if (selector == ITransparentUpgradeableProxy.changeAdmin.selector) {\\n                ret = _dispatchChangeAdmin();\\n            } else if (selector == ITransparentUpgradeableProxy.admin.selector) {\\n                ret = _dispatchAdmin();\\n            } else if (selector == ITransparentUpgradeableProxy.implementation.selector) {\\n                ret = _dispatchImplementation();\\n            } else {\\n                revert(\\\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\\\");\\n            }\\n            assembly {\\n                return(add(ret, 0x20), mload(ret))\\n            }\\n        } else {\\n            super._fallback();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function _dispatchAdmin() private returns (bytes memory) {\\n        _requireZeroValue();\\n\\n        address admin = _getAdmin();\\n        return abi.encode(admin);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\\n     */\\n    function _dispatchImplementation() private returns (bytes memory) {\\n        _requireZeroValue();\\n\\n        address implementation = _implementation();\\n        return abi.encode(implementation);\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _dispatchChangeAdmin() private returns (bytes memory) {\\n        _requireZeroValue();\\n\\n        address newAdmin = abi.decode(msg.data[4:], (address));\\n        _changeAdmin(newAdmin);\\n\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy.\\n     */\\n    function _dispatchUpgradeTo() private returns (bytes memory) {\\n        _requireZeroValue();\\n\\n        address newImplementation = abi.decode(msg.data[4:], (address));\\n        _upgradeToAndCall(newImplementation, bytes(\\\"\\\"), false);\\n\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\\n     * proxied contract.\\n     */\\n    function _dispatchUpgradeToAndCall() private returns (bytes memory) {\\n        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\\n        _upgradeToAndCall(newImplementation, data, true);\\n\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * CAUTION: This function is deprecated. Use {ERC1967Upgrade-_getAdmin} instead.\\n     */\\n    function _admin() internal view virtual returns (address) {\\n        return _getAdmin();\\n    }\\n\\n    /**\\n     * @dev To keep this contract fully transparent, all `ifAdmin` functions must be payable. This helper is here to\\n     * emulate some proxy functions being non-payable while still allowing value to pass through.\\n     */\\n    function _requireZeroValue() private {\\n        require(msg.value == 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/ERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"./extensions/IERC1155MetadataURI.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\n    using Address for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping(uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    constructor(string memory uri_) {\\n        _setURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) public view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: address zero is not a valid owner\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] memory accounts,\\n        uint256[] memory ids\\n    ) public view virtual override returns (uint256[] memory) {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not token owner or approved\\\"\\n        );\\n        _safeTransferFrom(from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not token owner or approved\\\"\\n        );\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n        _balances[id][to] += amount;\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n            _balances[id][to] += amount;\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _balances[id][to] += amount;\\n        emit TransferSingle(operator, address(0), to, id, amount);\\n\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] += amounts[i];\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `from`\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `from` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n\\n        emit TransferSingle(operator, from, address(0), id, amount);\\n\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory amounts) internal virtual {\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n        }\\n\\n        emit TransferBatch(operator, from, address(0), ids, amounts);\\n\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\\n        require(owner != operator, \\\"ERC1155: setting approval status for self\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non-ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\n                bytes4 response\\n            ) {\\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non-ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC1155Receiver.sol\\\";\\n\\n/**\\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\\n *\\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\\n * stuck.\\n *\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155Holder is ERC1155Receiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Receiver.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20.sol\\\";\\nimport \\\"../../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        _spendAllowance(account, _msgSender(), amount);\\n        _burn(account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/presets/ERC20PresetFixedSupply.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/presets/ERC20PresetFixedSupply.sol)\\npragma solidity ^0.8.0;\\n\\nimport \\\"../extensions/ERC20Burnable.sol\\\";\\n\\n/**\\n * @dev {ERC20} token, including:\\n *\\n *  - Preminted initial supply\\n *  - Ability for holders to burn (destroy) their tokens\\n *  - No access control mechanism (for minting/pausing) and hence no governance\\n *\\n * This contract uses {ERC20Burnable} to include burn capabilities - head to\\n * its documentation for details.\\n *\\n * _Available since v3.4._\\n *\\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\\n */\\ncontract ERC20PresetFixedSupply is ERC20Burnable {\\n    /**\\n     * @dev Mints `initialSupply` amount of token and transfers them to `owner`.\\n     *\\n     * See {ERC20-constructor}.\\n     */\\n    constructor(string memory name, string memory symbol, uint256 initialSupply, address owner) ERC20(name, symbol) {\\n        _mint(owner, initialSupply);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: address zero is not a valid owner\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _ownerOf(tokenId);\\n        require(owner != address(0), \\\"ERC721: invalid token ID\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        _requireMinted(tokenId);\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not token owner or approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        _requireMinted(tokenId);\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner or approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner or approved\\\");\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\\n     */\\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\\n        return _owners[tokenId];\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _ownerOf(tokenId) != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\\n\\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        unchecked {\\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\\n            // Given that tokens are minted one by one, it is impossible in practice that\\n            // this ever happens. Might change if we allow batch minting.\\n            // The ERC fails to describe this case.\\n            _balances[to] += 1;\\n        }\\n\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\\n\\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\\n        owner = ERC721.ownerOf(tokenId);\\n\\n        // Clear approvals\\n        delete _tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // Cannot overflow, as that would require more tokens to be burned/transferred\\n            // out than the owner initially received through minting and transferring in.\\n            _balances[owner] -= 1;\\n        }\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId, 1);\\n\\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n\\n        // Clear approvals from the previous owner\\n        delete _tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\\n            // `from`'s balance is the number of token held, which is at least one before the current\\n            // transfer.\\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\\n            // all 2**256 token ids to be minted, which in practice is impossible.\\n            _balances[from] -= 1;\\n            _balances[to] += 1;\\n        }\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` has not been minted yet.\\n     */\\n    function _requireMinted(uint256 tokenId) internal view virtual {\\n        require(_exists(tokenId), \\\"ERC721: invalid token ID\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\\n     * - When `from` is zero, the tokens will be minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\\n     * - When `from` is zero, the tokens were minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens were burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\\n\\n    /**\\n     * @dev Unsafe write access to the balances, used by extensions that \\\"mint\\\" tokens using an {ownerOf} override.\\n     *\\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\\n     * that `ownerOf(tokenId)` is `a`.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\\n        _balances[account] += amount;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/utils/ERC721Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721Holder is IERC721Receiver {\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Create2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Create2.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\\n        require(address(this).balance >= amount, \\\"Create2: insufficient balance\\\");\\n        require(bytecode.length != 0, \\\"Create2: bytecode length is zero\\\");\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40) // Get free memory pointer\\n\\n            // |                   | \u2193 ptr ...  \u2193 ptr + 0x0B (start) ...  \u2193 ptr + 0x20 ...  \u2193 ptr + 0x40 ...   |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\\n            // | 0xFF              |            FF                                                             |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\\n            // | keccak(start, 85) |            \u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191 |\\n\\n            mstore(add(ptr, 0x40), bytecodeHash)\\n            mstore(add(ptr, 0x20), salt)\\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\\n            mstore8(start, 0xff)\\n            addr := keccak256(start, 85)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proofLen - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            require(proofPos == proofLen, \\\"MerkleProof: invalid multiproof\\\");\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proofLen - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            require(proofPos == proofLen, \\\"MerkleProof: invalid multiproof\\\");\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface.\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(\\n        address account,\\n        bytes4[] memory interfaceIds\\n    ) internal view returns (bool[] memory) {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     *\\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\\n     * should be exercised when using this function.\\n     *\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success && returnSize >= 0x20 && returnValue > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Multicall.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @dev Provides a function to batch together multiple calls in a single external call.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract Multicall {\\n    /**\\n     * @dev Receives and executes a batch of function calls on this contract.\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\\n        }\\n        return results;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\n * _Available since v4.9 for `string`, `bytes`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BorrowLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport \\\"./Pool.sol\\\";\\nimport \\\"./LoanReceipt.sol\\\";\\nimport \\\"./LiquidityLogic.sol\\\";\\n\\nimport \\\"./interfaces/IPool.sol\\\";\\n\\n/**\\n * @title Borrow Logic\\n * @author MetaStreet Labs\\n */\\nlibrary BorrowLogic {\\n    using SafeCast for uint256;\\n    using LiquidityLogic for LiquidityLogic.Liquidity;\\n\\n    /**************************************************************************/\\n    /* Constants */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Borrower's split of liquidation proceed surplus in basis points\\n     */\\n    uint256 internal constant BORROWER_SURPLUS_SPLIT_BASIS_POINTS = 9_500;\\n\\n    /**\\n     * @notice Borrow options tag size in bytes\\n     */\\n    uint256 internal constant BORROW_OPTIONS_TAG_SIZE = 2;\\n\\n    /**\\n     * @notice Borrow options length size in bytes\\n     */\\n    uint256 internal constant BORROW_OPTIONS_LENGTH_SIZE = 2;\\n\\n    /**************************************************************************/\\n    /* Helpers */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Helper function to extract specified option tag from options\\n     * data\\n     *\\n     * @dev Options are encoded as:\\n     *   2 byte uint16 tag\\n     *   2 byte uint16 length\\n     *   n byte bytes  data\\n     * The first matching tag is returned.\\n     *\\n     * @param options Encoded options\\n     * @param tag Tag to find\\n     * @return Options data\\n     */\\n    function _getOptionsData(bytes calldata options, Pool.BorrowOptions tag) internal pure returns (bytes calldata) {\\n        /* Scan the options for the tag */\\n        for (uint256 offsetTag; offsetTag < options.length; ) {\\n            /* Compute offsets with for tag length and data */\\n            uint256 offsetLength = offsetTag + BORROW_OPTIONS_TAG_SIZE;\\n            uint256 offsetData = offsetTag + BORROW_OPTIONS_TAG_SIZE + BORROW_OPTIONS_LENGTH_SIZE;\\n\\n            /* The tag is in the first 2 bytes of each options item */\\n            uint256 currentTag = uint16(bytes2(options[offsetTag:offsetLength]));\\n\\n            /* The length of the options data is in the second 2 bytes of each options item, after the tag */\\n            uint256 dataLength = uint16(bytes2(options[offsetLength:offsetData]));\\n\\n            /* Return the offset and length if the tag is found */\\n            if (currentTag == uint256(tag)) {\\n                return options[offsetData:offsetData + dataLength];\\n            }\\n\\n            /* Increment to next options item */\\n            offsetTag = offsetData + dataLength;\\n        }\\n\\n        /* Return empty slice if no tag is found */\\n        return options[0:0];\\n    }\\n\\n    /**\\n     * @dev Helper function to calculated prorated repayment\\n     * @param loanReceipt Decoded loan receipt\\n     * @return repayment amount in currency tokens\\n     * @return proration based on elapsed duration\\n     */\\n    function _prorateRepayment(\\n        LoanReceipt.LoanReceiptV2 memory loanReceipt\\n    ) internal view returns (uint256 repayment, uint256 proration) {\\n        /* Minimum of proration and 1.0 */\\n        proration = Math.min(\\n            ((block.timestamp - (loanReceipt.maturity - loanReceipt.duration)) * LiquidityLogic.FIXED_POINT_SCALE) /\\n                loanReceipt.duration,\\n            LiquidityLogic.FIXED_POINT_SCALE\\n        );\\n\\n        /* Compute repayment using prorated interest */\\n        repayment =\\n            loanReceipt.principal +\\n            (((loanReceipt.repayment - loanReceipt.principal) * proration) / LiquidityLogic.FIXED_POINT_SCALE);\\n    }\\n\\n    /**\\n     * @dev Helper function to handle borrow accounting\\n     * @param self Pool storage\\n     * @param principal Principal amount in currency tokens\\n     * @param duration Duration in seconds\\n     * @param collateralToken Collateral token address\\n     * @param collateralTokenId Collateral token ID\\n     * @param repayment Repayment amount in currency tokens\\n     * @param maxRepayment Maximum repayment amount in currency tokens\\n     * @param adminFee Admin fee\\n     * @param nodes Liquidity nodes\\n     * @param count Liquidity nodes count\\n     * @param collateralWrapperContext Collateral wrapper context data\\n     * @return Encoded loan receipt, loan receipt hash\\n     */\\n    function _borrow(\\n        Pool.PoolStorage storage self,\\n        uint256 principal,\\n        uint64 duration,\\n        address collateralToken,\\n        uint256 collateralTokenId,\\n        uint256 repayment,\\n        uint256 maxRepayment,\\n        uint256 adminFee,\\n        LiquidityLogic.NodeSource[] memory nodes,\\n        uint16 count,\\n        bytes memory collateralWrapperContext\\n    ) external returns (bytes memory, bytes32) {\\n        /* Validate duration is non-zero */\\n        if (duration == 0) revert IPool.UnsupportedLoanDuration();\\n\\n        /* Validate repayment */\\n        if (repayment > maxRepayment) revert IPool.RepaymentTooHigh();\\n\\n        /* Build the loan receipt */\\n        LoanReceipt.LoanReceiptV2 memory receipt = LoanReceipt.LoanReceiptV2({\\n            version: 2,\\n            principal: principal,\\n            repayment: repayment,\\n            adminFee: adminFee,\\n            borrower: msg.sender,\\n            maturity: uint64(block.timestamp + duration),\\n            duration: duration,\\n            collateralToken: collateralToken,\\n            collateralTokenId: collateralTokenId,\\n            collateralWrapperContextLen: collateralWrapperContext.length.toUint16(),\\n            collateralWrapperContext: collateralWrapperContext,\\n            nodeReceipts: new LoanReceipt.NodeReceipt[](count)\\n        });\\n\\n        /* Use liquidity nodes */\\n        for (uint256 i; i < count; i++) {\\n            /* Use node */\\n            self.liquidity.use(nodes[i].tick, nodes[i].used, nodes[i].pending, duration);\\n\\n            /* Construct node receipt */\\n            receipt.nodeReceipts[i] = LoanReceipt.NodeReceipt({\\n                tick: nodes[i].tick,\\n                used: nodes[i].used,\\n                pending: nodes[i].pending\\n            });\\n        }\\n\\n        /* Encode and hash the loan receipt */\\n        bytes memory encodedLoanReceipt = LoanReceipt.encode(receipt);\\n        bytes32 loanReceiptHash = LoanReceipt.hash(encodedLoanReceipt);\\n\\n        /* Validate no loan receipt hash collision */\\n        if (self.loans[loanReceiptHash] != Pool.LoanStatus.Uninitialized) revert IPool.InvalidLoanReceipt();\\n\\n        /* Store loan status */\\n        self.loans[loanReceiptHash] = Pool.LoanStatus.Active;\\n\\n        return (encodedLoanReceipt, loanReceiptHash);\\n    }\\n\\n    /**\\n     * @dev Helper function to handle repay accounting\\n     * @param self Pool storage\\n     * @param encodedLoanReceipt Encoded loan receipt\\n     * @return Repayment amount in currency tokens, decoded loan receipt, loan\\n     * receipt hash\\n     */\\n    function _repay(\\n        Pool.PoolStorage storage self,\\n        bytes calldata encodedLoanReceipt\\n    ) external returns (uint256, LoanReceipt.LoanReceiptV2 memory, bytes32) {\\n        /* Compute loan receipt hash */\\n        bytes32 loanReceiptHash = LoanReceipt.hash(encodedLoanReceipt);\\n\\n        /* Validate loan receipt */\\n        if (self.loans[loanReceiptHash] != Pool.LoanStatus.Active) revert IPool.InvalidLoanReceipt();\\n\\n        /* Decode loan receipt */\\n        LoanReceipt.LoanReceiptV2 memory loanReceipt = LoanReceipt.decode(encodedLoanReceipt);\\n\\n        /* Validate borrow and repay is not in same block */\\n        if (loanReceipt.maturity - loanReceipt.duration == block.timestamp) revert IPool.InvalidLoanReceipt();\\n\\n        /* Validate caller is borrower */\\n        if (msg.sender != loanReceipt.borrower) revert IPool.InvalidCaller();\\n\\n        /* Compute proration and repayment using prorated interest */\\n        (uint256 repayment, uint256 proration) = _prorateRepayment(loanReceipt);\\n\\n        /* Compute elapsed time since loan origination */\\n        uint64 elapsed = uint64(block.timestamp + loanReceipt.duration - loanReceipt.maturity);\\n\\n        /* Restore liquidity nodes */\\n        for (uint256 i; i < loanReceipt.nodeReceipts.length; i++) {\\n            /* Restore node */\\n            self.liquidity.restore(\\n                loanReceipt.nodeReceipts[i].tick,\\n                loanReceipt.nodeReceipts[i].used,\\n                loanReceipt.nodeReceipts[i].pending,\\n                loanReceipt.nodeReceipts[i].used +\\n                    uint128(\\n                        ((loanReceipt.nodeReceipts[i].pending - loanReceipt.nodeReceipts[i].used) * proration) /\\n                            LiquidityLogic.FIXED_POINT_SCALE\\n                    ),\\n                loanReceipt.duration,\\n                elapsed\\n            );\\n        }\\n\\n        /* Update admin fee total balance with prorated admin fee */\\n        self.adminFeeBalance += (loanReceipt.adminFee * proration) / LiquidityLogic.FIXED_POINT_SCALE;\\n\\n        /* Mark loan status repaid */\\n        self.loans[loanReceiptHash] = Pool.LoanStatus.Repaid;\\n\\n        return (repayment, loanReceipt, loanReceiptHash);\\n    }\\n\\n    /**\\n     * @dev Helper function to handle liquidate accounting\\n     * @param self Pool storage\\n     * @param encodedLoanReceipt Encoded loan receipt\\n     * @return Decoded loan receipt, loan receipt hash\\n     */\\n    function _liquidate(\\n        Pool.PoolStorage storage self,\\n        bytes calldata encodedLoanReceipt\\n    ) external returns (LoanReceipt.LoanReceiptV2 memory, bytes32) {\\n        /* Compute loan receipt hash */\\n        bytes32 loanReceiptHash = LoanReceipt.hash(encodedLoanReceipt);\\n\\n        /* Validate loan status is active */\\n        if (self.loans[loanReceiptHash] != Pool.LoanStatus.Active) revert IPool.InvalidLoanReceipt();\\n\\n        /* Decode loan receipt */\\n        LoanReceipt.LoanReceiptV2 memory loanReceipt = LoanReceipt.decode(encodedLoanReceipt);\\n\\n        /* Validate loan is expired */\\n        if (block.timestamp <= loanReceipt.maturity) revert IPool.LoanNotExpired();\\n\\n        /* Mark loan status liquidated */\\n        self.loans[loanReceiptHash] = Pool.LoanStatus.Liquidated;\\n\\n        return (loanReceipt, loanReceiptHash);\\n    }\\n\\n    /**\\n     * @dev Helper function to handle collateral liquidation accounting\\n     * @param self Pool storage\\n     * @param encodedLoanReceipt Encoded loan receipt\\n     * @param proceeds Proceeds amount in currency tokens\\n     * @return Borrower surplus, decoded loan receipt, loan receipt hash\\n     */\\n    function _onCollateralLiquidated(\\n        Pool.PoolStorage storage self,\\n        bytes calldata encodedLoanReceipt,\\n        uint256 proceeds\\n    ) external returns (uint256, LoanReceipt.LoanReceiptV2 memory, bytes32) {\\n        /* Compute loan receipt hash */\\n        bytes32 loanReceiptHash = LoanReceipt.hash(encodedLoanReceipt);\\n\\n        /* Validate loan status is liquidated */\\n        if (self.loans[loanReceiptHash] != Pool.LoanStatus.Liquidated) revert IPool.InvalidLoanReceipt();\\n\\n        /* Decode loan receipt */\\n        LoanReceipt.LoanReceiptV2 memory loanReceipt = LoanReceipt.decode(encodedLoanReceipt);\\n\\n        /* Check if the proceeds have a surplus */\\n        bool hasSurplus = proceeds > loanReceipt.repayment;\\n\\n        /* Compute borrower's share of liquidation surplus */\\n        uint256 borrowerSurplus = hasSurplus\\n            ? Math.mulDiv(\\n                proceeds - loanReceipt.repayment,\\n                BORROWER_SURPLUS_SPLIT_BASIS_POINTS,\\n                LiquidityLogic.BASIS_POINTS_SCALE\\n            )\\n            : 0;\\n\\n        /* Compute lenders' proceeds */\\n        uint256 lendersProceeds = proceeds - borrowerSurplus;\\n\\n        /* Compute total pending */\\n        uint256 totalPending = loanReceipt.repayment - loanReceipt.adminFee;\\n\\n        /* Compute elapsed time since loan origination */\\n        uint64 elapsed = uint64(block.timestamp + loanReceipt.duration - loanReceipt.maturity);\\n\\n        /* Restore liquidity nodes */\\n        uint256 proceedsRemaining = lendersProceeds;\\n        uint256 lastIndex = loanReceipt.nodeReceipts.length - 1;\\n        for (uint256 i; i < loanReceipt.nodeReceipts.length; i++) {\\n            /* Compute amount to restore depending on whether there is a surplus */\\n            uint256 restored = (i == lastIndex) ? proceedsRemaining : hasSurplus\\n                ? Math.mulDiv(lendersProceeds, loanReceipt.nodeReceipts[i].pending, totalPending)\\n                : Math.min(loanReceipt.nodeReceipts[i].pending, proceedsRemaining);\\n\\n            /* Restore node */\\n            self.liquidity.restore(\\n                loanReceipt.nodeReceipts[i].tick,\\n                loanReceipt.nodeReceipts[i].used,\\n                loanReceipt.nodeReceipts[i].pending,\\n                restored.toUint128(),\\n                loanReceipt.duration,\\n                elapsed\\n            );\\n\\n            /* Update proceeds remaining */\\n            proceedsRemaining -= restored;\\n        }\\n\\n        /* Mark loan status collateral liquidated */\\n        self.loans[loanReceiptHash] = Pool.LoanStatus.CollateralLiquidated;\\n\\n        return (borrowerSurplus, loanReceipt, loanReceiptHash);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/configurations/NoopPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\n\\nimport \\\"../interfaces/ICollateralLiquidationReceiver.sol\\\";\\n\\n/**\\n * @title No Operation Pool Configuration (for emergency pause on proxied\\n * pools)\\n * @author MetaStreet Labs\\n */\\ncontract NoopPool is ERC165 {\\n    /**\\n     * @notice Get implementation name\\n     * @return Implementation name\\n     */\\n    function IMPLEMENTATION_NAME() external pure virtual returns (string memory) {\\n        return \\\"NoopPool\\\";\\n    }\\n\\n    /**\\n     * @notice Get implementation version\\n     * @return Implementation version\\n     */\\n    function IMPLEMENTATION_VERSION() external pure returns (string memory) {\\n        return \\\"0.1\\\";\\n    }\\n\\n    /******************************************************/\\n    /* ERC165 interface */\\n    /******************************************************/\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\\n        return interfaceId == type(ICollateralLiquidationReceiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/configurations/WeightedRateCollectionPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../Pool.sol\\\";\\nimport \\\"../rates/WeightedInterestRateModel.sol\\\";\\nimport \\\"../filters/CollectionCollateralFilter.sol\\\";\\nimport \\\"../tokenization/ERC20DepositToken.sol\\\";\\n\\n/**\\n * @title Pool Configuration with a Weighted Interest Rate Model and Collection\\n * Collateral Filter\\n * @author MetaStreet Labs\\n */\\ncontract WeightedRateCollectionPool is Pool, WeightedInterestRateModel, CollectionCollateralFilter, ERC20DepositToken {\\n    /**************************************************************************/\\n    /* State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Initialized boolean\\n     */\\n    bool private _initialized;\\n\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Pool constructor\\n     * @param collateralLiquidator Collateral liquidator\\n     * @param delegationRegistry Delegation registry contract\\n     * @param erc20DepositTokenImplementation ERC20 Deposit Token implementation address\\n     * @param collateralWrappers Collateral wrappers\\n     * @param parameters WeightedInterestRateModel parameters\\n     */\\n    constructor(\\n        address collateralLiquidator,\\n        address delegationRegistry,\\n        address erc20DepositTokenImplementation,\\n        address[] memory collateralWrappers,\\n        WeightedInterestRateModel.Parameters memory parameters\\n    )\\n        Pool(collateralLiquidator, delegationRegistry, collateralWrappers)\\n        WeightedInterestRateModel(parameters)\\n        ERC20DepositToken(erc20DepositTokenImplementation)\\n    {\\n        /* Disable initialization of implementation contract */\\n        _initialized = true;\\n    }\\n\\n    /**************************************************************************/\\n    /* Initializer */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Initializer\\n     * @dev Fee-on-transfer currency tokens are not supported\\n     * @param params ABI-encoded parameters\\n     */\\n    function initialize(bytes memory params) external {\\n        require(!_initialized, \\\"Already initialized\\\");\\n\\n        _initialized = true;\\n\\n        /* Decode parameters */\\n        (address collateralToken_, address currencyToken_, uint64[] memory durations_, uint64[] memory rates_) = abi\\n            .decode(params, (address, address, uint64[], uint64[]));\\n\\n        /* Initialize Collateral Filter */\\n        CollectionCollateralFilter._initialize(collateralToken_);\\n\\n        /* Initialize Pool */\\n        Pool._initialize(currencyToken_, durations_, rates_);\\n    }\\n\\n    /**************************************************************************/\\n    /* Name */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc Pool\\n     */\\n    function IMPLEMENTATION_NAME() external pure override returns (string memory) {\\n        return \\\"WeightedRateCollectionPool\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/configurations/WeightedRateMerkleCollectionPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../Pool.sol\\\";\\nimport \\\"../rates/WeightedInterestRateModel.sol\\\";\\nimport \\\"../filters/MerkleCollectionCollateralFilter.sol\\\";\\nimport \\\"../tokenization/ERC20DepositToken.sol\\\";\\n\\n/**\\n * @title Pool Configuration with a Weighted Interest Rate Model and Ranged Collection\\n * Collateral Filter\\n * @author MetaStreet Labs\\n */\\ncontract WeightedRateMerkleCollectionPool is\\n    Pool,\\n    WeightedInterestRateModel,\\n    MerkleCollectionCollateralFilter,\\n    ERC20DepositToken\\n{\\n    /**************************************************************************/\\n    /* State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Initialized boolean\\n     */\\n    bool private _initialized;\\n\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Pool constructor\\n     * @param collateralLiquidator Collateral liquidator\\n     * @param delegationRegistry Delegation registry contract\\n     * @param erc20DepositTokenImplementation ERC20 Deposit Token implementation address\\n     * @param collateralWrappers Collateral wrappers\\n     * @param parameters WeightedInterestRateModel parameters\\n     */\\n    constructor(\\n        address collateralLiquidator,\\n        address delegationRegistry,\\n        address erc20DepositTokenImplementation,\\n        address[] memory collateralWrappers,\\n        WeightedInterestRateModel.Parameters memory parameters\\n    )\\n        Pool(collateralLiquidator, delegationRegistry, collateralWrappers)\\n        WeightedInterestRateModel(parameters)\\n        ERC20DepositToken(erc20DepositTokenImplementation)\\n    {\\n        /* Disable initialization of implementation contract */\\n        _initialized = true;\\n    }\\n\\n    /**************************************************************************/\\n    /* Initializer */\\n    /**************************************************************************/\\n\\n    function initialize(bytes memory params) external {\\n        require(!_initialized, \\\"Already initialized\\\");\\n\\n        _initialized = true;\\n\\n        /* Decode parameters */\\n        (\\n            address collateralToken_,\\n            bytes32 merkleRoot_,\\n            uint32 nodeCount_,\\n            string memory metadataURI_,\\n            address currencyToken_,\\n            uint64[] memory durations_,\\n            uint64[] memory rates_\\n        ) = abi.decode(params, (address, bytes32, uint32, string, address, uint64[], uint64[]));\\n\\n        /* Initialize Collateral Filter */\\n        MerkleCollectionCollateralFilter._initialize(collateralToken_, merkleRoot_, nodeCount_, metadataURI_);\\n\\n        /* Initialize Pool */\\n        Pool._initialize(currencyToken_, durations_, rates_);\\n    }\\n\\n    /**************************************************************************/\\n    /* Name */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc Pool\\n     */\\n    function IMPLEMENTATION_NAME() external pure override returns (string memory) {\\n        return \\\"WeightedRateMerkleCollectionPool\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/configurations/WeightedRateRangedCollectionPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../Pool.sol\\\";\\nimport \\\"../rates/WeightedInterestRateModel.sol\\\";\\nimport \\\"../filters/RangedCollectionCollateralFilter.sol\\\";\\nimport \\\"../tokenization/ERC20DepositToken.sol\\\";\\n\\n/**\\n * @title Pool Configuration with a Weighted Interest Rate Model and Ranged Collection\\n * Collateral Filter\\n * @author MetaStreet Labs\\n */\\ncontract WeightedRateRangedCollectionPool is\\n    Pool,\\n    WeightedInterestRateModel,\\n    RangedCollectionCollateralFilter,\\n    ERC20DepositToken\\n{\\n    /**************************************************************************/\\n    /* State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Initialized boolean\\n     */\\n    bool private _initialized;\\n\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Pool constructor\\n     * @param collateralLiquidator Collateral liquidator\\n     * @param delegationRegistry Delegation registry contract\\n     * @param erc20DepositTokenImplementation ERC20 Deposit Token implementation address\\n     * @param collateralWrappers Collateral wrappers\\n     * @param parameters WeightedInterestRateModel parameters\\n     */\\n    constructor(\\n        address collateralLiquidator,\\n        address delegationRegistry,\\n        address erc20DepositTokenImplementation,\\n        address[] memory collateralWrappers,\\n        WeightedInterestRateModel.Parameters memory parameters\\n    )\\n        Pool(collateralLiquidator, delegationRegistry, collateralWrappers)\\n        WeightedInterestRateModel(parameters)\\n        ERC20DepositToken(erc20DepositTokenImplementation)\\n    {\\n        /* Disable initialization of implementation contract */\\n        _initialized = true;\\n    }\\n\\n    /**************************************************************************/\\n    /* Initializer */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Initializer\\n     * @dev Fee-on-transfer currency tokens are not supported\\n     * @param params ABI-encoded parameters\\n     */\\n    function initialize(bytes memory params) external {\\n        require(!_initialized, \\\"Already initialized\\\");\\n\\n        _initialized = true;\\n\\n        /* Decode parameters */\\n        (\\n            address collateralToken_,\\n            uint256 startTokenId_,\\n            uint256 endTokenId_,\\n            address currencyToken_,\\n            uint64[] memory durations_,\\n            uint64[] memory rates_\\n        ) = abi.decode(params, (address, uint256, uint256, address, uint64[], uint64[]));\\n\\n        /* Initialize Collateral Filter */\\n        RangedCollectionCollateralFilter._initialize(collateralToken_, startTokenId_, endTokenId_);\\n\\n        /* Initialize Pool */\\n        Pool._initialize(currencyToken_, durations_, rates_);\\n    }\\n\\n    /**************************************************************************/\\n    /* Name */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc Pool\\n     */\\n    function IMPLEMENTATION_NAME() external pure override returns (string memory) {\\n        return \\\"WeightedRateRangedCollectionPool\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/configurations/WeightedRateSetCollectionPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../Pool.sol\\\";\\nimport \\\"../rates/WeightedInterestRateModel.sol\\\";\\nimport \\\"../filters/SetCollectionCollateralFilter.sol\\\";\\nimport \\\"../tokenization/ERC20DepositToken.sol\\\";\\n\\n/**\\n * @title Pool Configuration with a Weighted Interest Rate Model and Set Collection\\n * Collateral Filter\\n * @author MetaStreet Labs\\n */\\ncontract WeightedRateSetCollectionPool is\\n    Pool,\\n    WeightedInterestRateModel,\\n    SetCollectionCollateralFilter,\\n    ERC20DepositToken\\n{\\n    /**************************************************************************/\\n    /* State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Initialized boolean\\n     */\\n    bool private _initialized;\\n\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Pool constructor\\n     * @param collateralLiquidator Collateral liquidator\\n     * @param delegationRegistry Delegation registry contract\\n     * @param erc20DepositTokenImplementation ERC20 Deposit Token implementation address\\n     * @param collateralWrappers Collateral wrappers\\n     * @param parameters WeightedInterestRateModel parameters\\n     */\\n    constructor(\\n        address collateralLiquidator,\\n        address delegationRegistry,\\n        address erc20DepositTokenImplementation,\\n        address[] memory collateralWrappers,\\n        WeightedInterestRateModel.Parameters memory parameters\\n    )\\n        Pool(collateralLiquidator, delegationRegistry, collateralWrappers)\\n        WeightedInterestRateModel(parameters)\\n        ERC20DepositToken(erc20DepositTokenImplementation)\\n    {\\n        /* Disable initialization of implementation contract */\\n        _initialized = true;\\n    }\\n\\n    /**************************************************************************/\\n    /* Initializer */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Initializer\\n     * @dev Fee-on-transfer currency tokens are not supported\\n     * @param params ABI-encoded parameters\\n     */\\n    function initialize(bytes memory params) external {\\n        require(!_initialized, \\\"Already initialized\\\");\\n\\n        _initialized = true;\\n\\n        /* Decode parameters */\\n        (\\n            address collateralToken_,\\n            uint256[] memory tokenIds_,\\n            address currencyToken_,\\n            uint64[] memory durations_,\\n            uint64[] memory rates_\\n        ) = abi.decode(params, (address, uint256[], address, uint64[], uint64[]));\\n\\n        /* Initialize Collateral Filter */\\n        SetCollectionCollateralFilter._initialize(collateralToken_, tokenIds_);\\n\\n        /* Initialize Pool */\\n        Pool._initialize(currencyToken_, durations_, rates_);\\n    }\\n\\n    /**************************************************************************/\\n    /* Name */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc Pool\\n     */\\n    function IMPLEMENTATION_NAME() external pure override returns (string memory) {\\n        return \\\"WeightedRateSetCollectionPool\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DepositLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"./Pool.sol\\\";\\nimport \\\"./Tick.sol\\\";\\nimport \\\"./LiquidityLogic.sol\\\";\\n\\nimport \\\"./interfaces/IPool.sol\\\";\\n\\n/**\\n * @title Deposit Logic\\n * @author MetaStreet Labs\\n */\\nlibrary DepositLogic {\\n    using LiquidityLogic for LiquidityLogic.Liquidity;\\n\\n    /**\\n     * @dev Helper function to handle deposit accounting\\n     * @param self Pool storage\\n     * @param tick Tick\\n     * @param amount Amount\\n     * @param minShares Minimum shares\\n     * @return Deposit shares\\n     */\\n    function _deposit(\\n        Pool.PoolStorage storage self,\\n        uint128 tick,\\n        uint128 amount,\\n        uint128 minShares\\n    ) external returns (uint128) {\\n        /* Validate tick */\\n        Tick.validate(tick, 0, 0, self.durations.length - 1, 0, self.rates.length - 1);\\n\\n        /* Deposit into liquidity node */\\n        uint128 shares = self.liquidity.deposit(tick, amount);\\n\\n        /* Validate shares received is sufficient */\\n        if (shares == 0 || shares < minShares) revert IPool.InsufficientShares();\\n\\n        /* Add to deposit */\\n        self.deposits[msg.sender][tick].shares += shares;\\n\\n        return shares;\\n    }\\n\\n    /**\\n     * @dev Helper function to handle redeem accounting\\n     * @param self Pool storage\\n     * @param tick Tick\\n     * @param shares Shares\\n     * @return redemptionId Redemption ID\\n     */\\n    function _redeem(Pool.PoolStorage storage self, uint128 tick, uint128 shares) external returns (uint128) {\\n        /* Look up deposit */\\n        Pool.Deposit storage dep = self.deposits[msg.sender][tick];\\n\\n        /* Assign redemption ID */\\n        uint128 redemptionId = dep.redemptionId++;\\n\\n        /* Look up redemption */\\n        Pool.Redemption storage redemption = dep.redemptions[redemptionId];\\n\\n        /* Validate shares */\\n        if (shares == 0 || shares > dep.shares) revert IPool.InsufficientShares();\\n\\n        /* Redeem shares in tick with liquidity manager */\\n        (uint128 index, uint128 target) = self.liquidity.redeem(tick, shares);\\n\\n        /* Update deposit state */\\n        redemption.pending = shares;\\n        redemption.index = index;\\n        redemption.target = target;\\n\\n        /* Decrement deposit shares */\\n        dep.shares -= shares;\\n\\n        return redemptionId;\\n    }\\n\\n    /**\\n     * @dev Helper function to handle withdraw accounting\\n     * @param self Pool storage\\n     * @param tick Tick\\n     * @param redemptionId Redemption ID\\n     * @return Withdrawn shares and withdrawn amount\\n     */\\n    function _withdraw(\\n        Pool.PoolStorage storage self,\\n        uint128 tick,\\n        uint128 redemptionId\\n    ) external returns (uint128, uint128) {\\n        /* Look up redemption */\\n        Pool.Redemption storage redemption = self.deposits[msg.sender][tick].redemptions[redemptionId];\\n\\n        /* If no redemption is pending */\\n        if (redemption.pending == 0) revert IPool.InvalidRedemptionStatus();\\n\\n        /* Look up redemption available */\\n        (uint128 shares, uint128 amount, uint128 processedIndices, uint128 processedShares) = self\\n            .liquidity\\n            .redemptionAvailable(tick, redemption.pending, redemption.index, redemption.target);\\n\\n        /* If the entire redemption is ready */\\n        if (shares == redemption.pending) {\\n            delete self.deposits[msg.sender][tick].redemptions[redemptionId];\\n        } else {\\n            redemption.pending -= shares;\\n            redemption.index += processedIndices;\\n            redemption.target = (processedShares < redemption.target) ? redemption.target - processedShares : 0;\\n        }\\n\\n        return (shares, amount);\\n    }\\n\\n    /**\\n     * @dev Helper function to handle transfer accounting\\n     * @param self Pool storage\\n     * @param from From\\n     * @param to To\\n     * @param tick Tick\\n     * @param shares Shares\\n     */\\n    function _transfer(Pool.PoolStorage storage self, address from, address to, uint128 tick, uint128 shares) external {\\n        if (self.deposits[from][tick].shares < shares) revert IPool.InsufficientShares();\\n\\n        self.deposits[from][tick].shares -= shares;\\n        self.deposits[to][tick].shares += shares;\\n    }\\n\\n    /**\\n     * Helper function to look up redemption available\\n     * @param self Pool storage\\n     * @param account Account\\n     * @param tick Tick\\n     * @param redemptionId Redemption ID\\n     * @return shares Amount of deposit shares available for redemption\\n     * @return amount Amount of currency tokens available for withdrawal\\n     * @return sharesAhead Amount of pending shares ahead in queue\\n     */\\n    function _redemptionAvailable(\\n        Pool.PoolStorage storage self,\\n        address account,\\n        uint128 tick,\\n        uint128 redemptionId\\n    ) external view returns (uint256 shares, uint256 amount, uint256 sharesAhead) {\\n        /* Look up redemption */\\n        Pool.Redemption storage redemption = self.deposits[account][tick].redemptions[redemptionId];\\n\\n        /* If no redemption is pending */\\n        if (redemption.pending == 0) return (0, 0, 0);\\n\\n        uint128 processedShares;\\n        (shares, amount, , processedShares) = self.liquidity.redemptionAvailable(\\n            tick,\\n            redemption.pending,\\n            redemption.index,\\n            redemption.target\\n        );\\n\\n        /* Compute pending shares ahead in queue */\\n        sharesAhead = redemption.target > processedShares ? redemption.target - processedShares : 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/filters/CollateralFilter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Collateral Filter API\\n * @author MetaStreet Labs\\n */\\nabstract contract CollateralFilter {\\n    /**************************************************************************/\\n    /* Errors */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Invalid parameters\\n     */\\n    error InvalidCollateralFilterParameters();\\n\\n    /**************************************************************************/\\n    /* API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Get collateral filter name\\n     * @return Collateral filter name\\n     */\\n    function COLLATERAL_FILTER_NAME() external view virtual returns (string memory);\\n\\n    /**\\n     * @notice Get collateral filter version\\n     * @return Collateral filter version\\n     */\\n    function COLLATERAL_FILTER_VERSION() external view virtual returns (string memory);\\n\\n    /**\\n     * @notice Get collateral token\\n     * @return Collateral token contract\\n     */\\n    function collateralToken() external view virtual returns (address);\\n\\n    /**\\n     * Query if collateral token is supported\\n     * @param token Collateral token contract\\n     * @param tokenId Collateral Token ID\\n     * @param index Collateral Token ID index\\n     * @param context ABI-encoded context\\n     * @return True if supported, otherwise false\\n     */\\n    function _collateralSupported(\\n        address token,\\n        uint256 tokenId,\\n        uint256 index,\\n        bytes calldata context\\n    ) internal view virtual returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/filters/CollectionCollateralFilter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"./CollateralFilter.sol\\\";\\n\\n/**\\n * @title Collection Collateral Filter\\n * @author MetaStreet Labs\\n */\\ncontract CollectionCollateralFilter is CollateralFilter {\\n    /**************************************************************************/\\n    /* State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Supported token\\n     */\\n    address private _token;\\n\\n    /**************************************************************************/\\n    /* Initializer */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice CollectionCollateralFilter initializer\\n     */\\n    function _initialize(address token) internal {\\n        _token = token;\\n    }\\n\\n    /**************************************************************************/\\n    /* Implementation */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc CollateralFilter\\n     */\\n    function COLLATERAL_FILTER_NAME() external pure override returns (string memory) {\\n        return \\\"CollectionCollateralFilter\\\";\\n    }\\n\\n    /**\\n     * @inheritdoc CollateralFilter\\n     */\\n    function COLLATERAL_FILTER_VERSION() external pure override returns (string memory) {\\n        return \\\"1.0\\\";\\n    }\\n\\n    /**\\n     * @inheritdoc CollateralFilter\\n     */\\n    function collateralToken() external view override returns (address) {\\n        return _token;\\n    }\\n\\n    /**\\n     * @inheritdoc CollateralFilter\\n     */\\n    function _collateralSupported(\\n        address token,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) internal view override returns (bool) {\\n        return token == _token;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/filters/MerkleCollectionCollateralFilter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\n\\nimport \\\"./CollateralFilter.sol\\\";\\n\\n/**\\n * @title Merkle Collection Collateral Filter\\n * @author MetaStreet Labs\\n */\\ncontract MerkleCollectionCollateralFilter is CollateralFilter {\\n    /**************************************************************************/\\n    /* Errors */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Invalid context\\n     */\\n    error InvalidContext();\\n\\n    /**************************************************************************/\\n    /* State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Supported token\\n     */\\n    address private _token;\\n\\n    /**\\n     * @notice Length of proof (multiple of 32)\\n     */\\n    uint32 private _proofLength;\\n\\n    /**\\n     * @notice Merkle root\\n     */\\n    bytes32 private _root;\\n\\n    /**\\n     * @notice Metadata URI\\n     */\\n    string private _metadataURI;\\n\\n    /**************************************************************************/\\n    /* Initializer */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice MerkleCollectionCollateralFilter initializer\\n     */\\n    function _initialize(address token, bytes32 root, uint32 nodeCount, string memory metadataURI_) internal {\\n        /* Validate root */\\n        if (root == bytes32(0)) revert InvalidCollateralFilterParameters();\\n        /* Validate node count */\\n        if (nodeCount == 0) revert InvalidCollateralFilterParameters();\\n\\n        _token = token;\\n        _root = root;\\n        _proofLength = nodeCount * 32;\\n        _metadataURI = metadataURI_;\\n    }\\n\\n    /**************************************************************************/\\n    /* Helpers */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Helper function that returns merkle proof in bytes32[] shape\\n     * @param proofData Proof data\\n     * @return merkleProof Merkle proof\\n     */\\n    function _extractProof(bytes calldata proofData) internal pure returns (bytes32[] memory) {\\n        /* Compute node count */\\n        uint256 nodeCount = (bytes32(proofData[proofData.length - 32:]) == bytes32(0))\\n            ? proofData.length / 32 - 1\\n            : proofData.length / 32;\\n\\n        /* Instantiate merkle proof array */\\n        bytes32[] memory merkleProof = new bytes32[](nodeCount);\\n\\n        /* Populate merkle proof array */\\n        for (uint256 i; i < nodeCount; i++) {\\n            /* Set node */\\n            merkleProof[i] = bytes32(proofData[i * 32:]);\\n        }\\n\\n        return merkleProof;\\n    }\\n\\n    /**************************************************************************/\\n    /* Getters */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc CollateralFilter\\n     */\\n    function COLLATERAL_FILTER_NAME() external pure override returns (string memory) {\\n        return \\\"MerkleCollectionCollateralFilter\\\";\\n    }\\n\\n    /**\\n     * @inheritdoc CollateralFilter\\n     */\\n    function COLLATERAL_FILTER_VERSION() external pure override returns (string memory) {\\n        return \\\"1.0\\\";\\n    }\\n\\n    /**\\n     * @notice Get collateral token\\n     * @return Collateral token contract\\n     */\\n    function collateralToken() external view override returns (address) {\\n        return _token;\\n    }\\n\\n    /**\\n     * @notice Get merkle root\\n     * @return Merkle root\\n     */\\n    function merkleRoot() external view returns (bytes32) {\\n        return _root;\\n    }\\n\\n    /**\\n     * @notice Get metadata URI\\n     * @return Metadata URI\\n     */\\n    function metadataURI() external view returns (string memory) {\\n        return _metadataURI;\\n    }\\n\\n    /**************************************************************************/\\n    /* Implementation */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc CollateralFilter\\n     */\\n    function _collateralSupported(\\n        address token,\\n        uint256 tokenId,\\n        uint256 index,\\n        bytes calldata context\\n    ) internal view override returns (bool) {\\n        /* Validate token supported */\\n        if (token != _token) return false;\\n\\n        /* Compute proof offset */\\n        uint32 proofLength = _proofLength;\\n        uint256 proofOffset = index * proofLength;\\n\\n        /* Validate context length */\\n        if (context.length < proofOffset + proofLength) revert InvalidContext();\\n\\n        /* Compute leaf hash */\\n        bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(tokenId))));\\n\\n        return MerkleProof.verify(_extractProof(context[proofOffset:proofOffset + proofLength]), _root, leaf);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/filters/RangedCollectionCollateralFilter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"./CollateralFilter.sol\\\";\\n\\n/**\\n * @title Ranged Collection Collateral Filter\\n * @author MetaStreet Labs\\n */\\ncontract RangedCollectionCollateralFilter is CollateralFilter {\\n    /**************************************************************************/\\n    /* State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Supported token\\n     */\\n    address private _token;\\n\\n    /**\\n     * @notice Supported start token ID (inclusive)\\n     */\\n    uint256 private _startTokenId;\\n\\n    /**\\n     * @notice Supported end token ID (inclusive)\\n     */\\n    uint256 private _endTokenId;\\n\\n    /**************************************************************************/\\n    /* Initializer */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice RangedCollectionCollateralFilter initializer\\n     */\\n    function _initialize(address token, uint256 startTokenId, uint256 endTokenId) internal {\\n        if (endTokenId < startTokenId) revert InvalidCollateralFilterParameters();\\n\\n        _token = token;\\n        _startTokenId = startTokenId;\\n        _endTokenId = endTokenId;\\n    }\\n\\n    /**************************************************************************/\\n    /* Implementation */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc CollateralFilter\\n     */\\n    function COLLATERAL_FILTER_NAME() external pure override returns (string memory) {\\n        return \\\"RangedCollectionCollateralFilter\\\";\\n    }\\n\\n    /**\\n     * @inheritdoc CollateralFilter\\n     */\\n    function COLLATERAL_FILTER_VERSION() external pure override returns (string memory) {\\n        return \\\"1.0\\\";\\n    }\\n\\n    /**\\n     * @inheritdoc CollateralFilter\\n     */\\n    function collateralToken() external view override returns (address) {\\n        return _token;\\n    }\\n\\n    /**\\n     * @notice Get collateral token ID range\\n     * @return Start token ID (inclusive)\\n     * @return End token ID (inclusive)\\n     */\\n    function collateralTokenIdRange() external view returns (uint256, uint256) {\\n        return (_startTokenId, _endTokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc CollateralFilter\\n     */\\n    function _collateralSupported(\\n        address token,\\n        uint256 tokenId,\\n        uint256,\\n        bytes calldata\\n    ) internal view override returns (bool) {\\n        return token == _token && tokenId >= _startTokenId && tokenId <= _endTokenId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/filters/SetCollectionCollateralFilter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\nimport \\\"./CollateralFilter.sol\\\";\\n\\n/**\\n * @title Set Collection Collateral Filter\\n * @author MetaStreet Labs\\n */\\ncontract SetCollectionCollateralFilter is CollateralFilter {\\n    using EnumerableSet for EnumerableSet.UintSet;\\n\\n    /**************************************************************************/\\n    /* State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Supported token\\n     */\\n    address private _token;\\n\\n    /**\\n     * @notice Set of supported token IDs\\n     */\\n    EnumerableSet.UintSet private _tokenIds;\\n\\n    /**************************************************************************/\\n    /* Initializer */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice SetCollectionCollateralFilter initializer\\n     */\\n    function _initialize(address token, uint256[] memory tokenIds_) internal {\\n        /* Validate root and node count */\\n        if (tokenIds_.length == 0) revert InvalidCollateralFilterParameters();\\n\\n        /* Set supported token */\\n        _token = token;\\n\\n        /* Add each token ID to set of token IDs */\\n        for (uint256 i; i < tokenIds_.length; i++) {\\n            _tokenIds.add(tokenIds_[i]);\\n        }\\n    }\\n\\n    /**************************************************************************/\\n    /* Getters */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc CollateralFilter\\n     */\\n    function COLLATERAL_FILTER_NAME() external pure override returns (string memory) {\\n        return \\\"SetCollectionCollateralFilter\\\";\\n    }\\n\\n    /**\\n     * @inheritdoc CollateralFilter\\n     */\\n    function COLLATERAL_FILTER_VERSION() external pure override returns (string memory) {\\n        return \\\"1.0\\\";\\n    }\\n\\n    /**\\n     * @notice Get collateral token\\n     * @return Collateral token contract\\n     */\\n    function collateralToken() external view override returns (address) {\\n        return _token;\\n    }\\n\\n    /**\\n     * @notice Get collateral token IDs\\n     * @return Collateral token IDs\\n     */\\n    function collateralTokenIds() external view returns (uint256[] memory) {\\n        return _tokenIds.values();\\n    }\\n\\n    /**************************************************************************/\\n    /* Implementation */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc CollateralFilter\\n     */\\n    function _collateralSupported(\\n        address token,\\n        uint256 tokenId,\\n        uint256,\\n        bytes calldata\\n    ) internal view override returns (bool) {\\n        /* Validate token supported */\\n        if (token != _token) return false;\\n\\n        /* Validate token ID is in set of token IDs */\\n        return _tokenIds.contains(tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/integrations/CryptoPunks/ICryptoPunksMarket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ICryptoPunksMarket {\\n    function punkIndexToAddress(uint256 punkIndex) external view returns (address owner);\\n\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    function transferPunk(address to, uint256 punkIndex) external;\\n\\n    function buyPunk(uint256 punkIndex) external payable;\\n\\n    function offerPunkForSaleToAddress(uint256 punkIndex, uint256 minSalePriceInWei, address to) external;\\n}\\n\"\r\n    },\r\n    \"contracts/integrations/DelegateCash/IDelegationRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.19;\\n\\n/**\\n * @title An immutable registry contract to be deployed as a standalone primitive\\n * @dev See EIP-5639, new project launches can read previous cold wallet -> hot wallet delegations\\n * from here and integrate those permissions into their flow\\n */\\ninterface IDelegationRegistry {\\n    /// @notice Delegation type\\n    enum DelegationType {\\n        NONE,\\n        ALL,\\n        CONTRACT,\\n        TOKEN\\n    }\\n\\n    /// @notice Info about a single delegation, used for onchain enumeration\\n    struct DelegationInfo {\\n        DelegationType type_;\\n        address vault;\\n        address delegate;\\n        address contract_;\\n        uint256 tokenId;\\n    }\\n\\n    /// @notice Info about a single contract-level delegation\\n    struct ContractDelegation {\\n        address contract_;\\n        address delegate;\\n    }\\n\\n    /// @notice Info about a single token-level delegation\\n    struct TokenDelegation {\\n        address contract_;\\n        uint256 tokenId;\\n        address delegate;\\n    }\\n\\n    /// @notice Emitted when a user delegates their entire wallet\\n    event DelegateForAll(address vault, address delegate, bool value);\\n\\n    /// @notice Emitted when a user delegates a specific contract\\n    event DelegateForContract(address vault, address delegate, address contract_, bool value);\\n\\n    /// @notice Emitted when a user delegates a specific token\\n    event DelegateForToken(address vault, address delegate, address contract_, uint256 tokenId, bool value);\\n\\n    /// @notice Emitted when a user revokes all delegations\\n    event RevokeAllDelegates(address vault);\\n\\n    /// @notice Emitted when a user revoes all delegations for a given delegate\\n    event RevokeDelegate(address vault, address delegate);\\n\\n    /**\\n     * -----------  WRITE -----------\\n     */\\n\\n    /**\\n     * @notice Allow the delegate to act on your behalf for all contracts\\n     * @param delegate The hotwallet to act on your behalf\\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\\n     */\\n    function delegateForAll(address delegate, bool value) external;\\n\\n    /**\\n     * @notice Allow the delegate to act on your behalf for a specific contract\\n     * @param delegate The hotwallet to act on your behalf\\n     * @param contract_ The address for the contract you're delegating\\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\\n     */\\n    function delegateForContract(address delegate, address contract_, bool value) external;\\n\\n    /**\\n     * @notice Allow the delegate to act on your behalf for a specific token\\n     * @param delegate The hotwallet to act on your behalf\\n     * @param contract_ The address for the contract you're delegating\\n     * @param tokenId The token id for the token you're delegating\\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\\n     */\\n    function delegateForToken(address delegate, address contract_, uint256 tokenId, bool value) external;\\n\\n    /**\\n     * @notice Revoke all delegates\\n     */\\n    function revokeAllDelegates() external;\\n\\n    /**\\n     * @notice Revoke a specific delegate for all their permissions\\n     * @param delegate The hotwallet to revoke\\n     */\\n    function revokeDelegate(address delegate) external;\\n\\n    /**\\n     * @notice Remove yourself as a delegate for a specific vault\\n     * @param vault The vault which delegated to the msg.sender, and should be removed\\n     */\\n    function revokeSelf(address vault) external;\\n\\n    /**\\n     * -----------  READ -----------\\n     */\\n\\n    /**\\n     * @notice Returns all active delegations a given delegate is able to claim on behalf of\\n     * @param delegate The delegate that you would like to retrieve delegations for\\n     * @return info Array of DelegationInfo structs\\n     */\\n    function getDelegationsByDelegate(address delegate) external view returns (DelegationInfo[] memory);\\n\\n    /**\\n     * @notice Returns an array of wallet-level delegates for a given vault\\n     * @param vault The cold wallet who issued the delegation\\n     * @return addresses Array of wallet-level delegates for a given vault\\n     */\\n    function getDelegatesForAll(address vault) external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns an array of contract-level delegates for a given vault and contract\\n     * @param vault The cold wallet who issued the delegation\\n     * @param contract_ The address for the contract you're delegating\\n     * @return addresses Array of contract-level delegates for a given vault and contract\\n     */\\n    function getDelegatesForContract(address vault, address contract_) external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns an array of contract-level delegates for a given vault's token\\n     * @param vault The cold wallet who issued the delegation\\n     * @param contract_ The address for the contract holding the token\\n     * @param tokenId The token id for the token you're delegating\\n     * @return addresses Array of contract-level delegates for a given vault's token\\n     */\\n    function getDelegatesForToken(\\n        address vault,\\n        address contract_,\\n        uint256 tokenId\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns all contract-level delegations for a given vault\\n     * @param vault The cold wallet who issued the delegations\\n     * @return delegations Array of ContractDelegation structs\\n     */\\n    function getContractLevelDelegations(address vault) external view returns (ContractDelegation[] memory delegations);\\n\\n    /**\\n     * @notice Returns all token-level delegations for a given vault\\n     * @param vault The cold wallet who issued the delegations\\n     * @return delegations Array of TokenDelegation structs\\n     */\\n    function getTokenLevelDelegations(address vault) external view returns (TokenDelegation[] memory delegations);\\n\\n    /**\\n     * @notice Returns true if the address is delegated to act on the entire vault\\n     * @param delegate The hotwallet to act on your behalf\\n     * @param vault The cold wallet who issued the delegation\\n     */\\n    function checkDelegateForAll(address delegate, address vault) external view returns (bool);\\n\\n    /**\\n     * @notice Returns true if the address is delegated to act on your behalf for a token contract or an entire vault\\n     * @param delegate The hotwallet to act on your behalf\\n     * @param contract_ The address for the contract you're delegating\\n     * @param vault The cold wallet who issued the delegation\\n     */\\n    function checkDelegateForContract(address delegate, address vault, address contract_) external view returns (bool);\\n\\n    /**\\n     * @notice Returns true if the address is delegated to act on your behalf for a specific token, the token's contract or an entire vault\\n     * @param delegate The hotwallet to act on your behalf\\n     * @param contract_ The address for the contract you're delegating\\n     * @param tokenId The token id for the token you're delegating\\n     * @param vault The cold wallet who issued the delegation\\n     */\\n    function checkDelegateForToken(\\n        address delegate,\\n        address vault,\\n        address contract_,\\n        uint256 tokenId\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICollateralLiquidationReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Interface to a Collateral Liquidation Receiver\\n */\\ninterface ICollateralLiquidationReceiver {\\n    /**\\n     * @notice Callback on collateral liquidated\\n     * @dev Pre-conditions: 1) proceeds were transferred, and 2) transferred amount >= proceeds\\n     * @param liquidationContext Liquidation context\\n     * @param proceeds Liquidation proceeds in currency tokens\\n     */\\n    function onCollateralLiquidated(bytes calldata liquidationContext, uint256 proceeds) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICollateralLiquidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Interface to a Collateral Liquidator\\n */\\ninterface ICollateralLiquidator {\\n    /**\\n     * @notice Get collateral liquidator name\\n     * @return Collateral liquidator name\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @notice Liquidate collateral\\n     * @param currencyToken Currency token\\n     * @param collateralToken Collateral token, either underlying token or collateral wrapper\\n     * @param collateralTokenId Collateral token ID\\n     * @param collateralWrapperContext Collateral wrapper context\\n     * @param liquidationContext Liquidation callback context\\n     */\\n    function liquidate(\\n        address currencyToken,\\n        address collateralToken,\\n        uint256 collateralTokenId,\\n        bytes calldata collateralWrapperContext,\\n        bytes calldata liquidationContext\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICollateralWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Interface to a Collateral Wrapper\\n */\\ninterface ICollateralWrapper {\\n    /**************************************************************************/\\n    /* API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Get collateral wrapper name\\n     * @return Collateral wrapper name\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @notice Enumerate wrapped collateral\\n     * @param tokenId Collateral wrapper token ID\\n     * @param context Implementation-specific context\\n     * @return token Token address\\n     * @return tokenIds List of unique token ids\\n     */\\n    function enumerate(\\n        uint256 tokenId,\\n        bytes calldata context\\n    ) external view returns (address token, uint256[] memory tokenIds);\\n\\n    /**\\n     * @notice Enumerate wrapped collateral with quantities of each token id\\n     * @param tokenId Collateral wrapper token ID\\n     * @param context Implementation-specific context\\n     * @return token Token address\\n     * @return tokenIds List of unique token ids\\n     * @return quantities List of quantities of each token id\\n     */\\n    function enumerateWithQuantities(\\n        uint256 tokenId,\\n        bytes calldata context\\n    ) external view returns (address token, uint256[] memory tokenIds, uint256[] memory quantities);\\n\\n    /**\\n     * @notice Get total token count represented by wrapped collateral\\n     * @param tokenId Collateral wrapper token ID\\n     * @param context Implementation-specific context\\n     * @return tokenCount Total token count\\n     */\\n    function count(uint256 tokenId, bytes calldata context) external view returns (uint256 tokenCount);\\n\\n    /*\\n     * Transfer collateral calldata\\n     * @param token Collateral token\\n     * @param from From address\\n     * @param to To address\\n     * @param tokenId Collateral wrapper token ID\\n     * @param quantity Quantity of token ID\\n     * @return target Transfer target\\n     * @return data Transfer calldata\\n     */\\n    function transferCalldata(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        uint256 quantity\\n    ) external returns (address target, bytes memory data);\\n\\n    /*\\n     * Unwrap collateral\\n     * @param tokenId Collateral wrapper token ID\\n     * @param context Implementation-specific context\\n     */\\n    function unwrap(uint256 tokenId, bytes calldata context) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILiquidity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Interface to Liquidity state\\n */\\ninterface ILiquidity {\\n    /**************************************************************************/\\n    /* Errors */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Insufficient liquidity\\n     */\\n    error InsufficientLiquidity();\\n\\n    /**\\n     * @notice Inactive liquidity\\n     */\\n    error InactiveLiquidity();\\n\\n    /**\\n     * @notice Insufficient tick spacing\\n     */\\n    error InsufficientTickSpacing();\\n\\n    /**************************************************************************/\\n    /* Structures */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Flattened liquidity node returned by getter\\n     * @param tick Tick\\n     * @param value Liquidity value\\n     * @param shares Liquidity shares outstanding\\n     * @param available Liquidity available\\n     * @param pending Liquidity pending (with interest)\\n     * @param redemptions Total pending redemptions\\n     * @param prev Previous liquidity node\\n     * @param next Next liquidity node\\n     */\\n    struct NodeInfo {\\n        uint128 tick;\\n        uint128 value;\\n        uint128 shares;\\n        uint128 available;\\n        uint128 pending;\\n        uint128 redemptions;\\n        uint128 prev;\\n        uint128 next;\\n    }\\n\\n    /**\\n     * @notice Accrual info returned by getter\\n     * @param accrued Accrued interest\\n     * @param rate Accrual rate\\n     * @param timestamp Accrual timestamp\\n     */\\n    struct AccrualInfo {\\n        uint128 accrued;\\n        uint64 rate;\\n        uint64 timestamp;\\n    }\\n\\n    /**************************************************************************/\\n    /* API */\\n    /**************************************************************************/\\n\\n    /**\\n     * Get liquidity nodes spanning [startTick, endTick] range\\n     * @param startTick Start tick\\n     * @param endTick End tick\\n     * @return Liquidity nodes\\n     */\\n    function liquidityNodes(uint128 startTick, uint128 endTick) external view returns (NodeInfo[] memory);\\n\\n    /**\\n     * Get liquidity node at tick\\n     * @param tick Tick\\n     * @return Liquidity node\\n     */\\n    function liquidityNode(uint128 tick) external view returns (NodeInfo memory);\\n\\n    /**\\n     * Get liquidity node with accrual info at tick\\n     * @param tick Tick\\n     * @return Liquidity node, Accrual info\\n     */\\n    function liquidityNodeWithAccrual(uint128 tick) external view returns (NodeInfo memory, AccrualInfo memory);\\n\\n    /**\\n     * @notice Get deposit share price\\n     * @param tick Tick\\n     * @return Deposit share price\\n     */\\n    function depositSharePrice(uint128 tick) external view returns (uint256);\\n\\n    /**\\n     * @notice Get redemption share price\\n     * @param tick Tick\\n     * @return Redemption share price\\n     */\\n    function redemptionSharePrice(uint128 tick) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Interface to a Pool\\n */\\ninterface IPool {\\n    /**************************************************************************/\\n    /* Errors */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Invalid caller\\n     */\\n    error InvalidCaller();\\n\\n    /**\\n     * @notice Insufficient shares\\n     */\\n    error InsufficientShares();\\n\\n    /**\\n     * @notice Invalid redemption status\\n     */\\n    error InvalidRedemptionStatus();\\n\\n    /**\\n     * @notice Invalid loan receipt\\n     */\\n    error InvalidLoanReceipt();\\n\\n    /**\\n     * @notice Invalid borrow options\\n     */\\n    error InvalidBorrowOptions();\\n\\n    /**\\n     * @notice Unsupported collateral\\n     * @param index Index of unsupported asset\\n     */\\n    error UnsupportedCollateral(uint256 index);\\n\\n    /**\\n     * @notice Unsupported loan duration\\n     */\\n    error UnsupportedLoanDuration();\\n\\n    /**\\n     * @notice Repayment too high\\n     */\\n    error RepaymentTooHigh();\\n\\n    /**\\n     * @notice Loan not expired\\n     */\\n    error LoanNotExpired();\\n\\n    /**\\n     * @notice Invalid parameters\\n     */\\n    error InvalidParameters();\\n\\n    /**************************************************************************/\\n    /* Events */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Emitted when currency is deposited\\n     * @param account Account\\n     * @param tick Tick\\n     * @param amount Amount of currency tokens\\n     * @param shares Amount of shares allocated\\n     */\\n    event Deposited(address indexed account, uint128 indexed tick, uint256 amount, uint256 shares);\\n\\n    /**\\n     * @notice Emitted when deposit shares are redeemed\\n     * @param account Account\\n     * @param tick Tick\\n     * @param redemptionId Redemption ID\\n     * @param shares Amount of shares to be redeemed\\n     */\\n    event Redeemed(address indexed account, uint128 indexed tick, uint128 indexed redemptionId, uint256 shares);\\n\\n    /**\\n     * @notice Emitted when redeemed currency tokens are withdrawn\\n     * @param account Account\\n     * @param tick Tick\\n     * @param redemptionId Redemption ID\\n     * @param shares Amount of shares redeemed\\n     * @param amount Amount of currency tokens withdrawn\\n     */\\n    event Withdrawn(\\n        address indexed account,\\n        uint128 indexed tick,\\n        uint128 indexed redemptionId,\\n        uint256 shares,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @notice Emitted when deposit shares are transferred\\n     * @param from Source account\\n     * @param to Destination account\\n     * @param tick Tick\\n     * @param shares Amount of shares transferred\\n     */\\n    event Transferred(address indexed from, address indexed to, uint128 indexed tick, uint256 shares);\\n\\n    /**\\n     * @notice Emitted when a loan is originated\\n     * @param loanReceiptHash Loan receipt hash\\n     * @param loanReceipt Loan receipt\\n     */\\n    event LoanOriginated(bytes32 indexed loanReceiptHash, bytes loanReceipt);\\n\\n    /**\\n     * @notice Emitted when a loan is repaid\\n     * @param loanReceiptHash Loan receipt hash\\n     * @param repayment Repayment amount in currency tokens\\n     */\\n    event LoanRepaid(bytes32 indexed loanReceiptHash, uint256 repayment);\\n\\n    /**\\n     * @notice Emitted when a loan is liquidated\\n     * @param loanReceiptHash Loan receipt hash\\n     */\\n    event LoanLiquidated(bytes32 indexed loanReceiptHash);\\n\\n    /**\\n     * @notice Emitted when loan collateral is liquidated\\n     * @param loanReceiptHash Loan receipt hash\\n     * @param proceeds Total liquidation proceeds in currency tokens\\n     * @param borrowerProceeds Borrower's share of liquidation proceeds in\\n     * currency tokens\\n     */\\n    event CollateralLiquidated(bytes32 indexed loanReceiptHash, uint256 proceeds, uint256 borrowerProceeds);\\n\\n    /**\\n     * @notice Emitted when admin fee rate is updated\\n     * @param rate New admin fee rate in basis points\\n     */\\n    event AdminFeeRateUpdated(uint256 rate);\\n\\n    /**\\n     * @notice Emitted when admin fees are withdrawn\\n     * @param account Recipient account\\n     * @param amount Amount of currency tokens withdrawn\\n     */\\n    event AdminFeesWithdrawn(address indexed account, uint256 amount);\\n\\n    /**************************************************************************/\\n    /* Getters */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Get currency token\\n     * @return Currency token contract\\n     */\\n    function currencyToken() external view returns (address);\\n\\n    /**\\n     * @notice Get supported durations\\n     * @return List of loan durations in second\\n     */\\n    function durations() external view returns (uint64[] memory);\\n\\n    /**\\n     * @notice Get supported rates\\n     * @return List of rates in interest per second\\n     */\\n    function rates() external view returns (uint64[] memory);\\n\\n    /**\\n     * @notice Get admin\\n     * @return Admin\\n     */\\n    function admin() external view returns (address);\\n\\n    /**\\n     * @notice Get admin fee rate\\n     * @return Admin fee rate in basis points\\n     */\\n    function adminFeeRate() external view returns (uint32);\\n\\n    /**\\n     * @notice Get admin fee balance\\n     * @return Admin fee balance in currency tokens\\n     */\\n    function adminFeeBalance() external view returns (uint256);\\n\\n    /**\\n     * @notice Get list of supported collateral wrappers\\n     * @return Collateral wrappers\\n     */\\n    function collateralWrappers() external view returns (address[] memory);\\n\\n    /**\\n     * @notice Get collateral liquidator contract\\n     * @return Collateral liquidator contract\\n     */\\n    function collateralLiquidator() external view returns (address);\\n\\n    /**\\n     * @notice Get delegation registry contract\\n     * @return Delegation registry contract\\n     */\\n    function delegationRegistry() external view returns (address);\\n\\n    /**************************************************************************/\\n    /* Deposit API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Deposit amount at tick\\n     *\\n     * Emits a {Deposited} event.\\n     *\\n     * @param tick Tick\\n     * @param amount Amount of currency tokens\\n     * @param minShares Minimum amount of shares to receive\\n     * @return shares Amount of shares minted\\n     */\\n    function deposit(uint128 tick, uint256 amount, uint256 minShares) external returns (uint256 shares);\\n\\n    /**\\n     * @notice Redeem deposit shares for currency tokens. Currency tokens can\\n     * be withdrawn with the `withdraw()` method once the redemption is\\n     * processed.\\n     *\\n     * Emits a {Redeemed} event.\\n     *\\n     * @param tick Tick\\n     * @param shares Amount of deposit shares to redeem\\n     * @return redemptionId Redemption ID\\n     */\\n    function redeem(uint128 tick, uint256 shares) external returns (uint128 redemptionId);\\n\\n    /**\\n     * @notice Get redemption available\\n     *\\n     * @param account Account\\n     * @param tick Tick\\n     * @param redemptionId Redemption ID\\n     * @return shares Amount of deposit shares available for redemption\\n     * @return amount Amount of currency tokens available for withdrawal\\n     * @return sharesAhead Amount of pending shares ahead in queue\\n     */\\n    function redemptionAvailable(\\n        address account,\\n        uint128 tick,\\n        uint128 redemptionId\\n    ) external view returns (uint256 shares, uint256 amount, uint256 sharesAhead);\\n\\n    /**\\n     * @notice Withdraw a redemption that is available\\n     *\\n     * Emits a {Withdrawn} event.\\n     *\\n     * @param tick Tick\\n     * @param redemptionId Redemption ID\\n     * @return shares Amount of deposit shares burned\\n     * @return amount Amount of currency tokens withdrawn\\n     */\\n    function withdraw(uint128 tick, uint128 redemptionId) external returns (uint256 shares, uint256 amount);\\n\\n    /**\\n     * @notice Rebalance a redemption that is available to a new tick\\n     *\\n     * Emits {Withdrawn} and {Deposited} events.\\n     *\\n     * @param srcTick Source tick\\n     * @param dstTick Destination Tick\\n     * @param redemptionId Redemption ID\\n     * @param minShares Minimum amount of destination shares to receive\\n     * @return oldShares Amount of source deposit shares burned\\n     * @return newShares Amount of destination deposit shares minted\\n     * @return amount Amount of currency tokens redeposited\\n     */\\n    function rebalance(\\n        uint128 srcTick,\\n        uint128 dstTick,\\n        uint128 redemptionId,\\n        uint256 minShares\\n    ) external returns (uint256 oldShares, uint256 newShares, uint256 amount);\\n\\n    /**************************************************************************/\\n    /* Lend API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Quote repayment for a loan\\n     * @param principal Principal amount in currency tokens\\n     * @param duration Duration in seconds\\n     * @param collateralToken Collateral token address\\n     * @param collateralTokenId Collateral token ID\\n     * @param ticks Liquidity ticks\\n     * @param options Encoded options\\n     * @return repayment Repayment amount in currency tokens\\n     */\\n    function quote(\\n        uint256 principal,\\n        uint64 duration,\\n        address collateralToken,\\n        uint256 collateralTokenId,\\n        uint128[] calldata ticks,\\n        bytes calldata options\\n    ) external view returns (uint256 repayment);\\n\\n    /**\\n     * @notice Originate a loan\\n     *\\n     * Emits a {LoanOriginated} event.\\n     *\\n     * @param principal Principal amount in currency tokens\\n     * @param duration Duration in seconds\\n     * @param collateralToken Collateral token address\\n     * @param collateralTokenId Collateral token ID\\n     * @param maxRepayment Maximum repayment amount in currency tokens\\n     * @param ticks Liquidity ticks\\n     * @param options Encoded options\\n     * @return repayment Repayment amount in currency tokens\\n     */\\n    function borrow(\\n        uint256 principal,\\n        uint64 duration,\\n        address collateralToken,\\n        uint256 collateralTokenId,\\n        uint256 maxRepayment,\\n        uint128[] calldata ticks,\\n        bytes calldata options\\n    ) external returns (uint256 repayment);\\n\\n    /**\\n     * @notice Repay a loan\\n     *\\n     * Emits a {LoanRepaid} event.\\n     *\\n     * @param encodedLoanReceipt Encoded loan receipt\\n     * @return repayment Repayment amount in currency tokens\\n     */\\n    function repay(bytes calldata encodedLoanReceipt) external returns (uint256 repayment);\\n\\n    /**\\n     * @notice Refinance a loan\\n     *\\n     * Emits a {LoanRepaid} event and a {LoanOriginated} event.\\n     *\\n     * @param encodedLoanReceipt Encoded loan receipt\\n     * @param principal Principal amount in currency tokens\\n     * @param duration Duration in seconds\\n     * @param maxRepayment Maximum repayment amount in currency tokens\\n     * @param ticks Liquidity ticks\\n     * @return repayment Repayment amount in currency tokens\\n     */\\n    function refinance(\\n        bytes calldata encodedLoanReceipt,\\n        uint256 principal,\\n        uint64 duration,\\n        uint256 maxRepayment,\\n        uint128[] calldata ticks\\n    ) external returns (uint256 repayment);\\n\\n    /**\\n     * @notice Liquidate an expired loan\\n     *\\n     * Emits a {LoanLiquidated} event.\\n     *\\n     * @param loanReceipt Loan receipt\\n     */\\n    function liquidate(bytes calldata loanReceipt) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Interface to the Pool Factory\\n */\\ninterface IPoolFactory {\\n    /**************************************************************************/\\n    /* Errors */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Unsupported Pool implementation\\n     */\\n    error UnsupportedImplementation();\\n\\n    /**\\n     * @notice Invalid Pool\\n     */\\n    error InvalidPool();\\n\\n    /**************************************************************************/\\n    /* Events */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Emitted when a pool is created\\n     * @param pool Pool instance\\n     * @param implementation Implementation contract\\n     */\\n    event PoolCreated(address indexed pool, address indexed implementation);\\n\\n    /**\\n     * @notice Emitted when a pool implementation is added to allowlist\\n     * @param implementation Implementation contract\\n     */\\n    event PoolImplementationAdded(address indexed implementation);\\n\\n    /**\\n     * @notice Emitted when a pool implementation is removed from allowlist\\n     * @param implementation Implementation contract\\n     */\\n    event PoolImplementationRemoved(address indexed implementation);\\n\\n    /**************************************************************************/\\n    /* API */\\n    /**************************************************************************/\\n\\n    /**\\n     * Create a pool (immutable)\\n     * @param poolImplementation Pool implementation contract\\n     * @param params Pool parameters\\n     * @return Pool address\\n     */\\n    function create(address poolImplementation, bytes calldata params) external returns (address);\\n\\n    /**\\n     * Create a pool (proxied)\\n     * @param poolBeacon Pool beacon contract\\n     * @param params Pool parameters\\n     * @return Pool address\\n     */\\n    function createProxied(address poolBeacon, bytes calldata params) external returns (address);\\n\\n    /**\\n     * @notice Check if address is a pool\\n     * @param pool Pool address\\n     * @return True if address is a pool, otherwise false\\n     */\\n    function isPool(address pool) external view returns (bool);\\n\\n    /**\\n     * @notice Get list of pools\\n     * @return List of pool addresses\\n     */\\n    function getPools() external view returns (address[] memory);\\n\\n    /**\\n     * @notice Get count of pools\\n     * @return Count of pools\\n     */\\n    function getPoolCount() external view returns (uint256);\\n\\n    /**\\n     * @notice Get pool at index\\n     * @param index Index\\n     * @return Pool address\\n     */\\n    function getPoolAt(uint256 index) external view returns (address);\\n\\n    /**\\n     * @notice Get list of supported pool implementations\\n     * @return List of pool implementations\\n     */\\n    function getPoolImplementations() external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/liquidators/EnglishAuctionCollateralLiquidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\\\";\\n\\nimport \\\"../interfaces/ICollateralLiquidationReceiver.sol\\\";\\nimport \\\"../interfaces/ICollateralLiquidator.sol\\\";\\nimport \\\"../interfaces/ICollateralWrapper.sol\\\";\\n\\n/**\\n * @title English Auction Collateral Liquidator\\n * @author MetaStreet Labs\\n */\\ncontract EnglishAuctionCollateralLiquidator is ICollateralLiquidator, ReentrancyGuard, ERC1155Holder {\\n    using SafeERC20 for IERC20;\\n\\n    /**************************************************************************/\\n    /* Constants */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Implementation version\\n     */\\n    string public constant IMPLEMENTATION_VERSION = \\\"1.2\\\";\\n\\n    /**\\n     * @notice Basis points scale\\n     */\\n    uint256 internal constant BASIS_POINTS_SCALE = 10_000;\\n\\n    /**************************************************************************/\\n    /* Errors */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Invalid parameters\\n     */\\n    error InvalidParameters();\\n\\n    /**\\n     * @notice Invalid token\\n     */\\n    error InvalidToken();\\n\\n    /**\\n     * @notice Invalid auction\\n     */\\n    error InvalidAuction();\\n\\n    /**\\n     * @notice Invalid liquidation\\n     */\\n    error InvalidLiquidation();\\n\\n    /**\\n     * @notice Invalid bid\\n     */\\n    error InvalidBid();\\n\\n    /**\\n     * @notice Invalid collateral claim\\n     */\\n    error InvalidClaim();\\n\\n    /**************************************************************************/\\n    /* Structures */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Auction\\n     * @param quantity Quantity of token ID\\n     * @param endTime Auction end time\\n     * @param highestBidder Highest bidder\\n     * @param highestBid Highest bid\\n     */\\n    struct Auction {\\n        uint256 quantity;\\n        uint64 endTime;\\n        address highestBidder;\\n        uint256 highestBid;\\n    }\\n\\n    /**\\n     * @notice Liquidation\\n     * @param source Address the liquidation came from\\n     * @param currencyToken Currency token\\n     * @param collateralToken Collateral token\\n     * @param auctionCount Number of auctions that have not ended\\n     * @param liquidationContextHash Liquidation context hash\\n     * @param proceeds Proceeds from liquidations\\n     */\\n    struct Liquidation {\\n        address source;\\n        address currencyToken;\\n        address collateralToken;\\n        uint16 auctionCount;\\n        bytes32 liquidationContextHash;\\n        uint256 proceeds;\\n    }\\n\\n    /**************************************************************************/\\n    /* Events */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Emitted when a liquidation is started\\n     * @param liquidationHash Liquidation hash\\n     * @param source Liquidation source\\n     * @param liquidationContextHash Liquidation context hash\\n     * @param currencyToken Currency token\\n     * @param collateralToken Collateral token\\n     * @param auctionCount Auction count\\n     */\\n    event LiquidationStarted(\\n        bytes32 indexed liquidationHash,\\n        address indexed source,\\n        bytes32 indexed liquidationContextHash,\\n        address currencyToken,\\n        address collateralToken,\\n        uint16 auctionCount\\n    );\\n\\n    /**\\n     * @notice Emitted when an auction is created\\n     * @param liquidationHash Liquidation hash\\n     * @param collateralToken Collateral token\\n     * @param collateralTokenId Collateral token ID\\n     * @param quantity Quantity of collateral token\\n     */\\n    event AuctionCreated(\\n        bytes32 indexed liquidationHash,\\n        address indexed collateralToken,\\n        uint256 indexed collateralTokenId,\\n        uint256 quantity\\n    );\\n\\n    /**\\n     * @notice Emitted when an auction is started\\n     * @param liquidationHash Liquidation hash\\n     * @param collateralToken Collateral token\\n     * @param collateralTokenId Collateral token ID\\n     * @param endTime Auction end time\\n     */\\n    event AuctionStarted(\\n        bytes32 indexed liquidationHash,\\n        address indexed collateralToken,\\n        uint256 indexed collateralTokenId,\\n        uint64 endTime\\n    );\\n\\n    /**\\n     * @notice Emitted when an auction is extended\\n     * @param liquidationHash Liquidation hash\\n     * @param collateralToken Collateral token\\n     * @param collateralTokenId Collateral token ID\\n     * @param endTime Auction end time\\n     */\\n    event AuctionExtended(\\n        bytes32 indexed liquidationHash,\\n        address indexed collateralToken,\\n        uint256 indexed collateralTokenId,\\n        uint64 endTime\\n    );\\n\\n    /**\\n     * @notice Emitted when an auction receives a bid\\n     * @param liquidationHash Liquidation hash\\n     * @param collateralToken Collateral token\\n     * @param collateralTokenId Collateral token ID\\n     * @param bidder Bidder\\n     * @param amount Bid amount\\n     */\\n    event AuctionBid(\\n        bytes32 indexed liquidationHash,\\n        address indexed collateralToken,\\n        uint256 indexed collateralTokenId,\\n        address bidder,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @notice Emitted when an auction is ended and collateral is claimed by winner\\n     * @param liquidationHash Liquidation hash\\n     * @param collateralToken Collateral token\\n     * @param collateralTokenId Collateral token ID\\n     * @param winner Winner of auction\\n     * @param proceeds Proceeds in currency tokens\\n     */\\n    event AuctionEnded(\\n        bytes32 indexed liquidationHash,\\n        address indexed collateralToken,\\n        uint256 indexed collateralTokenId,\\n        address winner,\\n        uint256 proceeds\\n    );\\n\\n    /**\\n     * @notice Emitted when a liquidation is ended\\n     * @param liquidationHash Liquidation hash\\n     * @param proceeds Proceeds in currency tokens\\n     */\\n    event LiquidationEnded(bytes32 indexed liquidationHash, uint256 proceeds);\\n\\n    /**************************************************************************/\\n    /* State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Initialized boolean\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @notice Auction duration\\n     */\\n    uint64 private _auctionDuration;\\n\\n    /**\\n     * @notice Duration window before an auction's end time\\n     */\\n    uint64 private _timeExtensionWindow;\\n\\n    /**\\n     * @notice Time extension of auction when a new bid is made within _timeExtensionWindow\\n     */\\n    uint64 private _timeExtension;\\n\\n    /**\\n     * @notice Minimum bid increment from previous bid\\n     */\\n    uint64 private _minimumBidBasisPoints;\\n\\n    /**\\n     * @notice Collateral wrappers (max 5)\\n     */\\n    address internal immutable _collateralWrapper1;\\n    address internal immutable _collateralWrapper2;\\n    address internal immutable _collateralWrapper3;\\n    address internal immutable _collateralWrapper4;\\n    address internal immutable _collateralWrapper5;\\n\\n    /**\\n     * @dev Collateral auctions\\n     */\\n    mapping(bytes32 => mapping(address => mapping(uint256 => Auction))) private _auctions;\\n\\n    /**\\n     * @dev Liquidation tracker\\n     */\\n    mapping(bytes32 => Liquidation) private _liquidations;\\n\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice EnglishAuctionCollateralLiquidator constructor\\n     */\\n    constructor(address[] memory collateralWrappers_) {\\n        /* Validate number of collateral wrappers */\\n        if (collateralWrappers_.length > 5) revert InvalidParameters();\\n\\n        /* Assign collateral wrappers */\\n        _collateralWrapper1 = (collateralWrappers_.length > 0) ? collateralWrappers_[0] : address(0);\\n        _collateralWrapper2 = (collateralWrappers_.length > 1) ? collateralWrappers_[1] : address(0);\\n        _collateralWrapper3 = (collateralWrappers_.length > 2) ? collateralWrappers_[2] : address(0);\\n        _collateralWrapper4 = (collateralWrappers_.length > 3) ? collateralWrappers_[3] : address(0);\\n        _collateralWrapper5 = (collateralWrappers_.length > 4) ? collateralWrappers_[4] : address(0);\\n\\n        /* Disable initialization of implementation contract */\\n        _initialized = true;\\n    }\\n\\n    /**************************************************************************/\\n    /* Initializer */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Initializer\\n     * @dev Fee-on-transfer currency tokens are not supported\\n     */\\n    function initialize(\\n        uint64 auctionDuration_,\\n        uint64 timeExtensionWindow_,\\n        uint64 timeExtension_,\\n        uint64 minimumBidBasisPoints_\\n    ) external {\\n        require(!_initialized, \\\"Already initialized\\\");\\n        if (auctionDuration_ <= timeExtensionWindow_) revert InvalidParameters();\\n        if (timeExtension_ <= timeExtensionWindow_) revert InvalidParameters();\\n        if (auctionDuration_ == 0) revert InvalidParameters();\\n\\n        _initialized = true;\\n        _auctionDuration = auctionDuration_;\\n        _timeExtensionWindow = timeExtensionWindow_;\\n        _timeExtension = timeExtension_;\\n        _minimumBidBasisPoints = minimumBidBasisPoints_;\\n    }\\n\\n    /**************************************************************************/\\n    /* Getters */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Get auction duration\\n     * @return Auction duration\\n     */\\n    function auctionDuration() external view returns (uint64) {\\n        return _auctionDuration;\\n    }\\n\\n    /**\\n     * @notice Get time extension window\\n     * @return Time extension window\\n     */\\n    function timeExtensionWindow() external view returns (uint64) {\\n        return _timeExtensionWindow;\\n    }\\n\\n    /**\\n     * @notice Get time extension\\n     * @return Time extension\\n     */\\n    function timeExtension() external view returns (uint64) {\\n        return _timeExtension;\\n    }\\n\\n    /**\\n     * @notice Get minimum bid basis points\\n     * @return Minimum bid basis points\\n     */\\n    function minimumBidBasisPoints() external view returns (uint64) {\\n        return _minimumBidBasisPoints;\\n    }\\n\\n    /**\\n     * Get liquidation details\\n     * @param liquidationHash Liquidation hash\\n     * @return Liquidation Liquidation details\\n     */\\n    function liquidations(bytes32 liquidationHash) external view returns (Liquidation memory) {\\n        return _liquidations[liquidationHash];\\n    }\\n\\n    /**\\n     * Get auction details\\n     * @param liquidationHash Liquidation hash\\n     * @param collateralToken Collateral token\\n     * @param collateralTokenId Collateral token ID\\n     * @return Auction Auction details\\n     */\\n    function auctions(\\n        bytes32 liquidationHash,\\n        address collateralToken,\\n        uint256 collateralTokenId\\n    ) external view returns (Auction memory) {\\n        return _auctions[liquidationHash][collateralToken][collateralTokenId];\\n    }\\n\\n    /**************************************************************************/\\n    /* Helper Functions */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Helper function to check if collateral token is a collateral wrapper\\n     * @param collateralToken Collateral token\\n     */\\n    function _isCollateralWrapper(address collateralToken) internal view returns (bool) {\\n        return\\n            collateralToken == _collateralWrapper1 ||\\n            collateralToken == _collateralWrapper2 ||\\n            collateralToken == _collateralWrapper3 ||\\n            collateralToken == _collateralWrapper4 ||\\n            collateralToken == _collateralWrapper5;\\n    }\\n\\n    /**\\n     * @notice Helper function to compute liquidation hash\\n     * @param collateralToken Collateral token\\n     * @param collateralTokenId Collateral token ID\\n     */\\n    function _liquidationHash(address collateralToken, uint256 collateralTokenId) internal view returns (bytes32) {\\n        return keccak256(abi.encodePacked(block.chainid, collateralToken, collateralTokenId, block.timestamp));\\n    }\\n\\n    /**\\n     * @notice Helper function to compute liquidation context hash\\n     * @param liquidationContext Liquidation context\\n     */\\n    function _liquidationContextHash(bytes calldata liquidationContext) internal view returns (bytes32) {\\n        return keccak256(abi.encodePacked(block.chainid, liquidationContext));\\n    }\\n\\n    /**\\n     * @notice Helper function to create an auction\\n     *\\n     * Emits a {AuctionCreated} event.\\n     *\\n     * @param liquidationHash Liquidation hash\\n     * @param collateralToken Collateral token\\n     * @param collateralTokenId Collateral token ID\\n     * @param quantity Quantity\\n     */\\n    function _createAuction(\\n        bytes32 liquidationHash,\\n        address collateralToken,\\n        uint256 collateralTokenId,\\n        uint256 quantity\\n    ) internal {\\n        /* Create collateral auction */\\n        _auctions[liquidationHash][collateralToken][collateralTokenId] = Auction({\\n            quantity: quantity,\\n            endTime: 0,\\n            highestBidder: address(0),\\n            highestBid: 0\\n        });\\n\\n        /* Emit AuctionCreated */\\n        emit AuctionCreated(liquidationHash, collateralToken, collateralTokenId, quantity);\\n    }\\n\\n    /**\\n     * @notice Helper function to process a collateral liquidation\\n     *\\n     * Emits a {CollateralLiquidated} event.\\n     *\\n     * @param auction_ Auction\\n     * @param liquidationHash Liquidation hash\\n     * @param liquidationContext Liquidation context\\n     * @return Collateral token\\n     */\\n    function _processLiquidation(\\n        Auction memory auction_,\\n        bytes32 liquidationHash,\\n        bytes calldata liquidationContext\\n    ) internal returns (address) {\\n        /* Get liquidation */\\n        Liquidation memory liquidation_ = _liquidations[liquidationHash];\\n\\n        /* Validate liquidation exists */\\n        if (liquidation_.source == address(0)) revert InvalidClaim();\\n\\n        /* Validate liquidation context */\\n        if (liquidation_.liquidationContextHash != _liquidationContextHash(liquidationContext)) revert InvalidClaim();\\n\\n        /* Liquidate if all auctions for the liquidation are completed */\\n        if (liquidation_.auctionCount == 1) {\\n            /* Compute total proceeds */\\n            uint256 proceeds = liquidation_.proceeds + auction_.highestBid;\\n\\n            /* Transfer proceeds from this contract to source */\\n            IERC20(liquidation_.currencyToken).safeTransfer(liquidation_.source, proceeds);\\n\\n            /* If source is a contract that implements ICollateralLiquidationReceiver, make collateral liquidation callback */\\n            if (\\n                Address.isContract(liquidation_.source) &&\\n                ERC165Checker.supportsInterface(liquidation_.source, type(ICollateralLiquidationReceiver).interfaceId)\\n            ) ICollateralLiquidationReceiver(liquidation_.source).onCollateralLiquidated(liquidationContext, proceeds);\\n\\n            /* Delete liquidation since all auctions are completed */\\n            delete _liquidations[liquidationHash];\\n\\n            /* Emit LiquidationEnded */\\n            emit LiquidationEnded(liquidationHash, proceeds);\\n        } else {\\n            /* Update liquidation proceeds */\\n            _liquidations[liquidationHash].proceeds += auction_.highestBid;\\n\\n            /* Update liquidation active auctions */\\n            _liquidations[liquidationHash].auctionCount -= 1;\\n        }\\n\\n        return liquidation_.collateralToken;\\n    }\\n\\n    /**************************************************************************/\\n    /* Implementation */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc ICollateralLiquidator\\n     */\\n    function name() external pure returns (string memory) {\\n        return \\\"EnglishAuctionCollateralLiquidator\\\";\\n    }\\n\\n    /**\\n     * @inheritdoc ICollateralLiquidator\\n     */\\n    function liquidate(\\n        address currencyToken,\\n        address collateralToken,\\n        uint256 collateralTokenId,\\n        bytes calldata collateralWrapperContext,\\n        bytes calldata liquidationContext\\n    ) external nonReentrant {\\n        /* Check collateral token and currency token is not zero address */\\n        if (collateralToken == address(0) || currencyToken == address(0)) revert InvalidToken();\\n\\n        /* Compute liquidation hash */\\n        bytes32 liquidationHash = _liquidationHash(collateralToken, collateralTokenId);\\n\\n        /* Validate liquidation does not exist */\\n        if (_liquidations[liquidationHash].source != address(0)) revert InvalidLiquidation();\\n\\n        /* Declare underlying collateral token address and IDs */\\n        address underlyingCollateralToken;\\n        uint256[] memory underlyingCollateralTokenIds;\\n        uint256[] memory underlyingQuantities;\\n\\n        /* Cache check for collateral wrapper  */\\n        bool isCollateralWrapper = _isCollateralWrapper(collateralToken);\\n\\n        /* Determine if collateral token is a whitelisted collateral wrapper */\\n        if (isCollateralWrapper) {\\n            /* Get underlying collateral token, underlying collateral token IDs, and quantities of each token ID */\\n            (underlyingCollateralToken, underlyingCollateralTokenIds, underlyingQuantities) = ICollateralWrapper(\\n                collateralToken\\n            ).enumerateWithQuantities(collateralTokenId, collateralWrapperContext);\\n        } else {\\n            /* Assign collateral token address and ID */\\n            underlyingCollateralToken = collateralToken;\\n            underlyingCollateralTokenIds = new uint256[](1);\\n            underlyingCollateralTokenIds[0] = collateralTokenId;\\n            underlyingQuantities = new uint256[](1);\\n            underlyingQuantities[0] = 1;\\n        }\\n\\n        /* Compute liquidation context hash */\\n        bytes32 liquidationContextHash = _liquidationContextHash(liquidationContext);\\n\\n        /* Iterate through underlying collaterals to create an auction for each underlying collateral */\\n        for (uint16 i = 0; i < underlyingCollateralTokenIds.length; i++) {\\n            _createAuction(\\n                liquidationHash,\\n                underlyingCollateralToken,\\n                underlyingCollateralTokenIds[i],\\n                underlyingQuantities[i]\\n            );\\n        }\\n\\n        /* Create liquidation */\\n        _liquidations[liquidationHash] = Liquidation({\\n            source: msg.sender,\\n            currencyToken: currencyToken,\\n            collateralToken: collateralToken,\\n            auctionCount: uint16(underlyingCollateralTokenIds.length),\\n            liquidationContextHash: liquidationContextHash,\\n            proceeds: 0\\n        });\\n\\n        /* Emit LiquidationStarted */\\n        emit LiquidationStarted(\\n            liquidationHash,\\n            msg.sender,\\n            liquidationContextHash,\\n            currencyToken,\\n            collateralToken,\\n            uint16(underlyingCollateralTokenIds.length)\\n        );\\n\\n        /* Transfer collateral token from source to this contract */\\n        IERC721(collateralToken).transferFrom(msg.sender, address(this), collateralTokenId);\\n\\n        /* Unwrap if collateral token is a collateral wrapper */\\n        if (isCollateralWrapper)\\n            ICollateralWrapper(collateralToken).unwrap(collateralTokenId, collateralWrapperContext);\\n    }\\n\\n    /**\\n     * @notice Bid on an auction\\n     *\\n     * Emits a {AuctionBid} event.\\n     *\\n     * @param liquidationHash Liquidation hash\\n     * @param collateralToken Collateral token\\n     * @param collateralTokenId Collateral token ID\\n     * @param amount Bid amount\\n     */\\n    function bid(\\n        bytes32 liquidationHash,\\n        address collateralToken,\\n        uint256 collateralTokenId,\\n        uint256 amount\\n    ) external nonReentrant {\\n        /* Get auction */\\n        Auction memory auction_ = _auctions[liquidationHash][collateralToken][collateralTokenId];\\n\\n        /* Get liquidation */\\n        Liquidation memory liquidation_ = _liquidations[liquidationHash];\\n\\n        /* Validate liquidation exists */\\n        if (liquidation_.source == address(0)) revert InvalidAuction();\\n\\n        /* Validate that auction exists */\\n        if (auction_.quantity == 0) revert InvalidAuction();\\n\\n        /* Validate auction has not ended */\\n        if (auction_.endTime != 0 && auction_.endTime < uint64(block.timestamp)) revert InvalidBid();\\n\\n        /* Validate bid amount is bigger than the minimum bid amount */\\n        if (\\n            amount <= auction_.highestBid ||\\n            amount - auction_.highestBid < (auction_.highestBid * _minimumBidBasisPoints) / BASIS_POINTS_SCALE\\n        ) revert InvalidBid();\\n\\n        /* If auction has not started */\\n        if (auction_.endTime == 0) {\\n            /* Calculate end time */\\n            uint64 endTime = uint64(block.timestamp) + _auctionDuration;\\n\\n            /* Start auction */\\n            _auctions[liquidationHash][collateralToken][collateralTokenId].endTime = endTime;\\n\\n            /* Emit AuctionStarted */\\n            emit AuctionStarted(liquidationHash, collateralToken, collateralTokenId, endTime);\\n        } else if (auction_.endTime - uint64(block.timestamp) <= _timeExtensionWindow) {\\n            /* Calculate new end time */\\n            uint64 endTime = uint64(block.timestamp) + _timeExtension;\\n\\n            /* Update end time if auction is already in progress and within\\n             * time extension window */\\n            _auctions[liquidationHash][collateralToken][collateralTokenId].endTime = endTime;\\n\\n            /* Emit AuctionExtended */\\n            emit AuctionExtended(liquidationHash, collateralToken, collateralTokenId, endTime);\\n        }\\n\\n        /* Update auction with new bid */\\n        _auctions[liquidationHash][collateralToken][collateralTokenId].highestBidder = msg.sender;\\n        _auctions[liquidationHash][collateralToken][collateralTokenId].highestBid = amount;\\n\\n        /* If not first bidder */\\n        if (auction_.highestBidder != address(0)) {\\n            /* Transfer previous bid back from collateral liquidator to previous bidder */\\n            IERC20(liquidation_.currencyToken).safeTransfer(auction_.highestBidder, auction_.highestBid);\\n        }\\n\\n        /* Transfer bid amount from bidder to collateral liquidator */\\n        IERC20(liquidation_.currencyToken).safeTransferFrom(msg.sender, address(this), amount);\\n\\n        /* Emit AuctionBid */\\n        emit AuctionBid(liquidationHash, collateralToken, collateralTokenId, msg.sender, amount);\\n    }\\n\\n    /**\\n     * @notice Claim collateral and liquidate if possible\\n     *\\n     * Emits a {CollateralLiquidated} event.\\n     * Emits a {AuctionEnded} event.\\n     *\\n     * @param liquidationHash Liquidation hash\\n     * @param collateralToken Collateral token\\n     * @param collateralTokenId Collateral token ID\\n     * @param liquidationContext Liquidation context\\n     */\\n    function claim(\\n        bytes32 liquidationHash,\\n        address collateralToken,\\n        uint256 collateralTokenId,\\n        bytes calldata liquidationContext\\n    ) external nonReentrant {\\n        /* Get auction */\\n        Auction memory auction_ = _auctions[liquidationHash][collateralToken][collateralTokenId];\\n\\n        /* Validate that auction exists */\\n        if (auction_.quantity == 0) revert InvalidAuction();\\n\\n        /* Validate that auction was started */\\n        if (auction_.highestBidder == address(0)) revert InvalidClaim();\\n\\n        /* Validate that auction has ended */\\n        if (uint64(block.timestamp) <= auction_.endTime) revert InvalidClaim();\\n\\n        /* Process liquidation proceeds */\\n        address wrappedCollateralToken = _processLiquidation(auction_, liquidationHash, liquidationContext);\\n\\n        /* Delete auction */\\n        delete _auctions[liquidationHash][collateralToken][collateralTokenId];\\n\\n        /* Transfer collateral from contract to auction winner */\\n        if (_isCollateralWrapper(wrappedCollateralToken)) {\\n            /* Get transfer call target and calldata */\\n            (address target, bytes memory data) = ICollateralWrapper(wrappedCollateralToken).transferCalldata(\\n                collateralToken,\\n                address(this),\\n                auction_.highestBidder,\\n                collateralTokenId,\\n                auction_.quantity\\n            );\\n\\n            /* Transfer collateral */\\n            (bool success, ) = target.call(data);\\n\\n            /* Validate call success */\\n            if (!success) revert InvalidClaim();\\n        } else {\\n            IERC721(collateralToken).transferFrom(address(this), auction_.highestBidder, collateralTokenId);\\n        }\\n\\n        /* Emit AuctionEnded */\\n        emit AuctionEnded(\\n            liquidationHash,\\n            collateralToken,\\n            collateralTokenId,\\n            auction_.highestBidder,\\n            auction_.highestBid\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/LiquidityLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport \\\"./interfaces/ILiquidity.sol\\\";\\nimport \\\"./Tick.sol\\\";\\n\\n/**\\n * @title Liquidity Logic\\n * @author MetaStreet Labs\\n */\\nlibrary LiquidityLogic {\\n    using SafeCast for uint256;\\n\\n    /**************************************************************************/\\n    /* Constants */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Tick limit spacing basis points (10%)\\n     */\\n    uint256 internal constant TICK_LIMIT_SPACING_BASIS_POINTS = 1000;\\n\\n    /**\\n     * @notice Fixed point scale\\n     */\\n    uint256 internal constant FIXED_POINT_SCALE = 1e18;\\n\\n    /**\\n     * @notice Basis points scale\\n     */\\n    uint256 internal constant BASIS_POINTS_SCALE = 10_000;\\n\\n    /**\\n     * @notice Impaired price threshold (5%)\\n     */\\n    uint256 internal constant IMPAIRED_PRICE_THRESHOLD = 0.05 * 1e18;\\n\\n    /**\\n     * @notice Max redemption queue scan count\\n     */\\n    uint256 private constant MAX_REDEMPTION_QUEUE_SCAN_COUNT = 150;\\n\\n    /**************************************************************************/\\n    /* Structures */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Node source\\n     * @param tick Tick\\n     * @param used Amount used\\n     * @param pending Amount pending\\n     */\\n    struct NodeSource {\\n        uint128 tick;\\n        uint128 used;\\n        uint128 pending;\\n    }\\n\\n    /**\\n     * @notice Fulfilled redemption\\n     * @param shares Shares redeemed\\n     * @param amount Amount redeemed\\n     */\\n    struct FulfilledRedemption {\\n        uint128 shares;\\n        uint128 amount;\\n    }\\n\\n    /**\\n     * @notice Redemption state\\n     * @param pending Pending shares\\n     * @param index Current index\\n     * @param fulfilled Fulfilled redemptions\\n     */\\n    struct Redemptions {\\n        uint128 pending;\\n        uint128 index;\\n        mapping(uint128 => FulfilledRedemption) fulfilled;\\n    }\\n\\n    /**\\n     * @notice Accrual state\\n     * @param accrued Accrued interest\\n     * @param rate Accrual rate\\n     * @param timestamp Last accrual timestamp\\n     */\\n    struct Accrual {\\n        uint128 accrued;\\n        uint64 rate;\\n        uint64 timestamp;\\n    }\\n\\n    /**\\n     * @notice Liquidity node\\n     * @param value Liquidity value\\n     * @param shares Liquidity shares outstanding\\n     * @param available Liquidity available\\n     * @param pending Liquidity pending (with interest)\\n     * @param prev Previous liquidity node\\n     * @param next Next liquidity node\\n     * @param redemption Redemption state\\n     * @param accrual Accrual state\\n     */\\n    struct Node {\\n        uint128 value;\\n        uint128 shares;\\n        uint128 available;\\n        uint128 pending;\\n        uint128 prev;\\n        uint128 next;\\n        Redemptions redemptions;\\n        Accrual accrual;\\n    }\\n\\n    /**\\n     * @notice Liquidity state\\n     * @param nodes Liquidity nodes\\n     */\\n    struct Liquidity {\\n        mapping(uint256 => Node) nodes;\\n    }\\n\\n    /**************************************************************************/\\n    /* Getters */\\n    /**************************************************************************/\\n\\n    /**\\n     * Get liquidity node at tick\\n     * @param liquidity Liquidity state\\n     * @param tick Tick\\n     * @return Liquidity node\\n     */\\n    function liquidityNode(Liquidity storage liquidity, uint128 tick) public view returns (ILiquidity.NodeInfo memory) {\\n        Node storage node = liquidity.nodes[tick];\\n\\n        return\\n            ILiquidity.NodeInfo({\\n                tick: tick,\\n                value: node.value,\\n                shares: node.shares,\\n                available: node.available,\\n                pending: node.pending,\\n                redemptions: node.redemptions.pending,\\n                prev: node.prev,\\n                next: node.next\\n            });\\n    }\\n\\n    /**\\n     * @notice Count liquidity nodes spanning [startTick, endTick] range, where\\n     * startTick is 0 or an instantiated tick\\n     * @param liquidity Liquidity state\\n     * @param startTick Start tick\\n     * @param endTick End tick\\n     * @return count Liquidity nodes count\\n     */\\n    function liquidityNodesCount(\\n        Liquidity storage liquidity,\\n        uint128 startTick,\\n        uint128 endTick\\n    ) public view returns (uint256 count) {\\n        /* Validate start tick has active liquidity */\\n        if (liquidity.nodes[startTick].next == 0) revert ILiquidity.InactiveLiquidity();\\n\\n        /* Count nodes */\\n        uint256 t = startTick;\\n        while (t != type(uint128).max && t <= endTick) {\\n            t = liquidity.nodes[t].next;\\n            count++;\\n        }\\n    }\\n\\n    /**\\n     * @notice Get liquidity nodes spanning [startTick, endTick] range, where\\n     * startTick is 0 or an instantiated tick\\n     * @param liquidity Liquidity state\\n     * @param startTick Start tick\\n     * @param endTick End tick\\n     * @return Liquidity nodes\\n     */\\n    function liquidityNodes(\\n        Liquidity storage liquidity,\\n        uint128 startTick,\\n        uint128 endTick\\n    ) external view returns (ILiquidity.NodeInfo[] memory) {\\n        ILiquidity.NodeInfo[] memory nodes = new ILiquidity.NodeInfo[](\\n            liquidityNodesCount(liquidity, startTick, endTick)\\n        );\\n\\n        /* Populate nodes */\\n        uint256 i;\\n        uint128 t = startTick;\\n        while (t != type(uint128).max && t <= endTick) {\\n            nodes[i] = liquidityNode(liquidity, t);\\n            t = nodes[i++].next;\\n        }\\n\\n        return nodes;\\n    }\\n\\n    /**\\n     * @notice Get liquidity node with accrual info at tick\\n     * @param liquidity Liquidity state\\n     * @param tick Tick\\n     * @return Liquidity node, Accrual info\\n     */\\n    function liquidityNodeWithAccrual(\\n        Liquidity storage liquidity,\\n        uint128 tick\\n    ) external view returns (ILiquidity.NodeInfo memory, ILiquidity.AccrualInfo memory) {\\n        Node storage node = liquidity.nodes[tick];\\n\\n        return (\\n            ILiquidity.NodeInfo({\\n                tick: tick,\\n                value: node.value,\\n                shares: node.shares,\\n                available: node.available,\\n                pending: node.pending,\\n                redemptions: node.redemptions.pending,\\n                prev: node.prev,\\n                next: node.next\\n            }),\\n            ILiquidity.AccrualInfo({\\n                accrued: node.accrual.accrued,\\n                rate: node.accrual.rate,\\n                timestamp: node.accrual.timestamp\\n            })\\n        );\\n    }\\n\\n    /**\\n     * @notice Get redemption available amount\\n     * @param liquidity Liquidity state\\n     * @param tick Tick\\n     * @param pending Redemption pending\\n     * @param index Redemption index\\n     * @param target Redemption target\\n     * @return redeemedShares Redeemed shares\\n     * @return redeemedAmount Redeemed amount\\n     * @return processedIndices Processed indices\\n     * @return processedShares Processed shares\\n     */\\n    function redemptionAvailable(\\n        Liquidity storage liquidity,\\n        uint128 tick,\\n        uint128 pending,\\n        uint128 index,\\n        uint128 target\\n    )\\n        internal\\n        view\\n        returns (uint128 redeemedShares, uint128 redeemedAmount, uint128 processedIndices, uint128 processedShares)\\n    {\\n        Node storage node = liquidity.nodes[tick];\\n\\n        uint256 stopIndex = index + MAX_REDEMPTION_QUEUE_SCAN_COUNT;\\n\\n        for (; processedShares < target + pending && index < stopIndex; index++) {\\n            if (index == node.redemptions.index) {\\n                /* Reached pending unfulfilled redemption */\\n                break;\\n            }\\n\\n            /* Look up the next fulfilled redemption */\\n            FulfilledRedemption storage redemption = node.redemptions.fulfilled[index];\\n\\n            /* Update processed count */\\n            processedIndices += 1;\\n            processedShares += redemption.shares;\\n\\n            if (processedShares <= target) {\\n                /* Have not reached the redemption queue position yet */\\n                continue;\\n            } else {\\n                /* Compute number of shares to redeem in range of this\\n                 * redemption batch */\\n                uint128 shares = (((processedShares > target + pending) ? pending : (processedShares - target))) -\\n                    redeemedShares;\\n                /* Compute price of shares in this redemption batch */\\n                uint256 price = (redemption.amount * FIXED_POINT_SCALE) / redemption.shares;\\n\\n                /* Accumulate redeemed shares and corresponding amount */\\n                redeemedShares += shares;\\n                redeemedAmount += Math.mulDiv(shares, price, FIXED_POINT_SCALE).toUint128();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Get deposit share price\\n     * @param liquidity Liquidity state\\n     * @param tick Tick\\n     * @return Deposit share price\\n     */\\n    function depositSharePrice(Liquidity storage liquidity, uint128 tick) external view returns (uint256) {\\n        Node storage node = liquidity.nodes[tick];\\n\\n        /* Simulate accrual */\\n        uint128 accrued = node.accrual.accrued + node.accrual.rate * uint128(block.timestamp - node.accrual.timestamp);\\n\\n        /* Return deposit price */\\n        return\\n            node.shares == 0\\n                ? FIXED_POINT_SCALE\\n                : (Math.min(node.value + accrued, node.available + node.pending) * FIXED_POINT_SCALE) / node.shares;\\n    }\\n\\n    /**\\n     * @notice Get redemption share price\\n     * @param liquidity Liquidity state\\n     * @param tick Tick\\n     * @return Redemption share price\\n     */\\n    function redemptionSharePrice(Liquidity storage liquidity, uint128 tick) external view returns (uint256) {\\n        Node storage node = liquidity.nodes[tick];\\n\\n        /* Revert if node is empty */\\n        if (node.value == 0 || node.shares == 0) revert ILiquidity.InactiveLiquidity();\\n\\n        /* Return redemption price */\\n        return (node.value * FIXED_POINT_SCALE) / node.shares;\\n    }\\n\\n    /**************************************************************************/\\n    /* Internal Helpers */\\n    /**************************************************************************/\\n\\n    /**\\n     * @dev Check if tick is reserved\\n     * @param tick Tick\\n     * @return True if reserved, otherwise false\\n     */\\n    function _isReserved(uint128 tick) internal pure returns (bool) {\\n        return tick == 0 || tick == type(uint128).max;\\n    }\\n\\n    /**\\n     * @dev Check if liquidity node is empty\\n     * @param node Liquidity node\\n     * @return True if empty, otherwise false\\n     */\\n    function _isEmpty(Node storage node) internal view returns (bool) {\\n        return node.shares == 0 && node.pending == 0;\\n    }\\n\\n    /**\\n     * @dev Check if liquidity node is active\\n     * @param node Liquidity node\\n     * @return True if active, otherwise false\\n     */\\n    function _isActive(Node storage node) internal view returns (bool) {\\n        return node.prev != 0 || node.next != 0;\\n    }\\n\\n    /**\\n     * @dev Check if liquidity node is impaired\\n     * @param node Liquidity node\\n     * @return True if impaired, otherwise false\\n     */\\n    function _isImpaired(Node storage node) internal view returns (bool) {\\n        /* If there's shares, but insufficient value for a stable share price */\\n        return node.shares != 0 && node.value * FIXED_POINT_SCALE < node.shares * IMPAIRED_PRICE_THRESHOLD;\\n    }\\n\\n    /**\\n     * @notice Instantiate liquidity\\n     * @param liquidity Liquidity state\\n     * @param tick Tick\\n     */\\n    function _instantiate(Liquidity storage liquidity, Node storage node, uint128 tick) internal {\\n        /* If node is active, do nothing */\\n        if (_isActive(node)) return;\\n        /* If node is inactive and not empty, revert */\\n        if (!_isEmpty(node)) revert ILiquidity.InactiveLiquidity();\\n\\n        /* Find prior node to new tick */\\n        uint128 prevTick;\\n        Node storage prevNode = liquidity.nodes[prevTick];\\n        while (prevNode.next < tick) {\\n            prevTick = prevNode.next;\\n            prevNode = liquidity.nodes[prevTick];\\n        }\\n\\n        /* Decode limits from previous tick, new tick, and next tick */\\n        (uint256 prevLimit, , , ) = Tick.decode(prevTick);\\n        (uint256 newLimit, , , ) = Tick.decode(tick);\\n        (uint256 nextLimit, , , ) = Tick.decode(prevNode.next);\\n\\n        /* Validate tick limit spacing */\\n        if (\\n            newLimit != prevLimit &&\\n            newLimit < (prevLimit * (BASIS_POINTS_SCALE + TICK_LIMIT_SPACING_BASIS_POINTS)) / BASIS_POINTS_SCALE\\n        ) revert ILiquidity.InsufficientTickSpacing();\\n        if (\\n            newLimit != nextLimit &&\\n            nextLimit < (newLimit * (BASIS_POINTS_SCALE + TICK_LIMIT_SPACING_BASIS_POINTS)) / BASIS_POINTS_SCALE\\n        ) revert ILiquidity.InsufficientTickSpacing();\\n\\n        /* Link new node */\\n        node.prev = prevTick;\\n        node.next = prevNode.next;\\n        liquidity.nodes[prevNode.next].prev = tick;\\n        prevNode.next = tick;\\n    }\\n\\n    /**\\n     * @dev Garbage collect an impaired or empty node, unlinking it from active\\n     * liquidity\\n     * @param liquidity Liquidity state\\n     * @param node Liquidity node\\n     */\\n    function _garbageCollect(Liquidity storage liquidity, Node storage node) internal {\\n        /* If node is not impaired and not empty, or already inactive, do nothing */\\n        if ((!_isImpaired(node) && !_isEmpty(node)) || !_isActive(node)) return;\\n\\n        /* Make node inactive by unlinking it */\\n        liquidity.nodes[node.prev].next = node.next;\\n        liquidity.nodes[node.next].prev = node.prev;\\n        node.next = 0;\\n        node.prev = 0;\\n    }\\n\\n    /**\\n     * @notice Process redemptions from available liquidity\\n     * @param liquidity Liquidity state\\n     * @param node Liquidity node\\n     */\\n    function _processRedemptions(Liquidity storage liquidity, Node storage node) internal {\\n        /* If there's no pending shares to redeem */\\n        if (node.redemptions.pending == 0) return;\\n\\n        /* Compute redemption price */\\n        uint256 price = (node.value * FIXED_POINT_SCALE) / node.shares;\\n\\n        if (price == 0) {\\n            /* If node has pending interest */\\n            if (node.pending != 0) return;\\n\\n            /* If node is insolvent, redeem all shares for zero amount */\\n            uint128 shares = node.redemptions.pending;\\n\\n            /* Record fulfilled redemption */\\n            node.redemptions.fulfilled[node.redemptions.index++] = FulfilledRedemption({shares: shares, amount: 0});\\n\\n            /* Update node state */\\n            node.shares -= shares;\\n            node.value = 0;\\n            node.available = 0;\\n            node.redemptions.pending = 0;\\n\\n            return;\\n        } else {\\n            /* Node is solvent */\\n\\n            /* If there's no cash to redeem from */\\n            if (node.available == 0) return;\\n\\n            /* Redeem as many shares as possible and pending from available cash */\\n            uint128 shares = uint128(Math.min((node.available * FIXED_POINT_SCALE) / price, node.redemptions.pending));\\n            uint128 amount = Math.mulDiv(shares, price, FIXED_POINT_SCALE).toUint128();\\n\\n            /* If there's insufficient cash to redeem non-zero pending shares\\n             * at current price */\\n            if (shares == 0) return;\\n\\n            /* Record fulfilled redemption */\\n            node.redemptions.fulfilled[node.redemptions.index++] = FulfilledRedemption({\\n                shares: shares,\\n                amount: amount\\n            });\\n\\n            /* Update node state */\\n            node.shares -= shares;\\n            node.value -= amount;\\n            node.available -= amount;\\n            node.redemptions.pending -= shares;\\n\\n            /* Garbage collect node if it is now empty */\\n            _garbageCollect(liquidity, node);\\n\\n            return;\\n        }\\n    }\\n\\n    /**\\n     * @notice Process accrued value from accrual rate and timestamp\\n     * @param node Liquidity node\\n     */\\n    function _accrue(Node storage node) internal {\\n        node.accrual.accrued += node.accrual.rate * uint128(block.timestamp - node.accrual.timestamp);\\n        node.accrual.timestamp = uint64(block.timestamp);\\n    }\\n\\n    /**************************************************************************/\\n    /* Primary API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Initialize liquidity state\\n     * @param liquidity Liquidity state\\n     */\\n    function initialize(Liquidity storage liquidity) internal {\\n        /* Liquidity state defaults to zero, but need to make head and tail nodes */\\n        liquidity.nodes[0].next = type(uint128).max;\\n        /* liquidity.nodes[type(uint128).max].prev = 0 by default */\\n    }\\n\\n    /**\\n     * @notice Deposit liquidity\\n     * @param liquidity Liquidity state\\n     * @param tick Tick\\n     * @param amount Amount\\n     * @return Number of shares\\n     */\\n    function deposit(Liquidity storage liquidity, uint128 tick, uint128 amount) internal returns (uint128) {\\n        Node storage node = liquidity.nodes[tick];\\n\\n        /* If tick is reserved */\\n        if (_isReserved(tick)) revert ILiquidity.InactiveLiquidity();\\n\\n        /* Instantiate node, if necessary */\\n        _instantiate(liquidity, node, tick);\\n\\n        /* Process accrual */\\n        _accrue(node);\\n\\n        /* Compute deposit price */\\n        uint256 price = node.shares == 0\\n            ? FIXED_POINT_SCALE\\n            : (Math.min(node.value + node.accrual.accrued, node.available + node.pending) * FIXED_POINT_SCALE) /\\n                node.shares;\\n\\n        /* Compute shares */\\n        uint128 shares = ((amount * FIXED_POINT_SCALE) / price).toUint128();\\n\\n        node.value += amount;\\n        node.shares += shares;\\n        node.available += amount;\\n\\n        /* Process any pending redemptions from available cash */\\n        _processRedemptions(liquidity, node);\\n\\n        return shares;\\n    }\\n\\n    /**\\n     * @notice Use liquidity from node\\n     * @param liquidity Liquidity state\\n     * @param tick Tick\\n     * @param used Used amount\\n     * @param pending Pending amount\\n     * @param duration Duration\\n     */\\n    function use(Liquidity storage liquidity, uint128 tick, uint128 used, uint128 pending, uint64 duration) internal {\\n        Node storage node = liquidity.nodes[tick];\\n\\n        node.available -= used;\\n        node.pending += pending;\\n\\n        /* Process accrual */\\n        _accrue(node);\\n        /* Increment accrual rate */\\n        uint256 rate = uint256(pending - used) / duration;\\n        node.accrual.rate += rate.toUint64();\\n    }\\n\\n    /**\\n     * @notice Restore liquidity and process pending redemptions\\n     * @param liquidity Liquidity state\\n     * @param tick Tick\\n     * @param used Used amount\\n     * @param pending Pending amount\\n     * @param restored Restored amount\\n     * @param duration Duration\\n     * @param elapsed Elapsed time since loan origination\\n     */\\n    function restore(\\n        Liquidity storage liquidity,\\n        uint128 tick,\\n        uint128 used,\\n        uint128 pending,\\n        uint128 restored,\\n        uint64 duration,\\n        uint64 elapsed\\n    ) internal {\\n        Node storage node = liquidity.nodes[tick];\\n\\n        node.value = node.value - used + restored;\\n        node.available += restored;\\n        node.pending -= pending;\\n\\n        /* Garbage collect node if it is now impaired */\\n        _garbageCollect(liquidity, node);\\n\\n        /* Process any pending redemptions */\\n        _processRedemptions(liquidity, node);\\n\\n        /* Process accrual */\\n        _accrue(node);\\n        /* Decrement accrual rate and accrued */\\n        uint256 rate = uint256(pending - used) / duration;\\n        node.accrual.rate -= rate.toUint64();\\n        node.accrual.accrued -= uint128(rate * elapsed);\\n    }\\n\\n    /**\\n     * @notice Redeem liquidity\\n     * @param liquidity Liquidity state\\n     * @param tick Tick\\n     * @param shares Shares\\n     * @return Redemption index, Redemption target\\n     */\\n    function redeem(Liquidity storage liquidity, uint128 tick, uint128 shares) internal returns (uint128, uint128) {\\n        Node storage node = liquidity.nodes[tick];\\n\\n        /* Redemption from inactive liquidity nodes is allowed to facilitate\\n         * restoring garbage collected nodes */\\n\\n        /* Snapshot redemption target */\\n        uint128 redemptionIndex = node.redemptions.index;\\n        uint128 redemptionTarget = node.redemptions.pending;\\n\\n        /* Add shares to pending redemptions */\\n        node.redemptions.pending += shares;\\n\\n        /* Initialize redemption record to save gas in loan callbacks */\\n        if (node.redemptions.fulfilled[redemptionIndex].shares != type(uint128).max) {\\n            node.redemptions.fulfilled[redemptionIndex] = FulfilledRedemption({shares: type(uint128).max, amount: 0});\\n        }\\n\\n        /* Process any pending redemptions from available cash */\\n        _processRedemptions(liquidity, node);\\n\\n        return (redemptionIndex, redemptionTarget);\\n    }\\n\\n    /**\\n     * @notice Source liquidity from nodes\\n     * @param liquidity Liquidity state\\n     * @param amount Amount\\n     * @param ticks Ticks to source from\\n     * @param multiplier Multiplier for amount\\n     * @param durationIndex Duration index for amount\\n     * @return Sourced liquidity nodes, count of nodes\\n     */\\n    function source(\\n        Liquidity storage liquidity,\\n        uint256 amount,\\n        uint128[] calldata ticks,\\n        uint256 multiplier,\\n        uint256 durationIndex\\n    ) internal view returns (NodeSource[] memory, uint16) {\\n        NodeSource[] memory sources = new NodeSource[](ticks.length);\\n\\n        uint256 prevTick;\\n        uint256 taken;\\n        uint256 count;\\n        for (; count < ticks.length && taken != amount; count++) {\\n            uint128 tick = ticks[count];\\n\\n            /* Validate tick and decode limit */\\n            uint256 limit = Tick.validate(tick, prevTick, durationIndex);\\n\\n            /* Look up liquidity node */\\n            Node storage node = liquidity.nodes[tick];\\n\\n            /* Consume as much as possible up to the tick limit, amount available, and amount remaining */\\n            uint128 take = uint128(Math.min(Math.min(limit * multiplier - taken, node.available), amount - taken));\\n\\n            /* Record the liquidity allocation in our sources list */\\n            sources[count] = NodeSource({tick: tick, used: take, pending: 0});\\n\\n            taken += take;\\n            prevTick = tick;\\n        }\\n\\n        /* If unable to source required liquidity amount from provided ticks */\\n        if (taken < amount) revert ILiquidity.InsufficientLiquidity();\\n\\n        return (sources, count.toUint16());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/LoanReceipt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/**\\n * @title LoanReceipt\\n * @author MetaStreet Labs\\n */\\nlibrary LoanReceipt {\\n    /**************************************************************************/\\n    /* Errors */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Invalid receipt encoding\\n     */\\n    error InvalidReceiptEncoding();\\n\\n    /**************************************************************************/\\n    /* Constants */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Loan receipt version\\n     */\\n    uint8 internal constant LOAN_RECEIPT_VERSION = 2;\\n\\n    /**\\n     * @notice Loan receipt header size in bytes\\n     * @dev Header excludes borrow options byte array\\n     */\\n    uint256 internal constant LOAN_RECEIPT_HEADER_SIZE = 187;\\n\\n    /**\\n     * @notice Loan receipt node receipt size in bytes\\n     */\\n    uint256 internal constant LOAN_RECEIPT_NODE_RECEIPT_SIZE = 48;\\n\\n    /**************************************************************************/\\n    /* Structures */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice LoanReceiptV2\\n     * @param version Version (2)\\n     * @param principal Principal amount in currency tokens\\n     * @param repayment Repayment amount in currency tokens\\n     * @param adminFee Admin fee amount in currency tokens\\n     * @param borrower Borrower\\n     * @param maturity Loan maturity timestamp\\n     * @param duration Loan duration\\n     * @param collateralToken Collateral token\\n     * @param collateralTokenId Collateral token ID\\n     * @param collateralWrapperContextLen Collateral wrapper context length\\n     * @param collateralWrapperContext Collateral wrapper context data\\n     * @param nodeReceipts Node receipts\\n     */\\n    struct LoanReceiptV2 {\\n        uint8 version;\\n        uint256 principal;\\n        uint256 repayment;\\n        uint256 adminFee;\\n        address borrower;\\n        uint64 maturity;\\n        uint64 duration;\\n        address collateralToken;\\n        uint256 collateralTokenId;\\n        uint16 collateralWrapperContextLen;\\n        bytes collateralWrapperContext;\\n        NodeReceipt[] nodeReceipts;\\n    }\\n\\n    /**\\n     * @notice Node receipt\\n     * @param tick Tick\\n     * @param used Used amount\\n     * @param pending Pending amount\\n     */\\n    struct NodeReceipt {\\n        uint128 tick;\\n        uint128 used;\\n        uint128 pending;\\n    }\\n\\n    /**************************************************************************/\\n    /* Tightly packed format */\\n    /**************************************************************************/\\n\\n    /*\\n      Header (187 bytes)\\n          1   uint8   version                        0:1\\n          32  uint256 principal                      1:33\\n          32  uint256 repayment                      33:65\\n          32  uint256 adminFee                       65:97\\n          20  address borrower                       97:117\\n          8   uint64  maturity                       117:125\\n          8   uint64  duration                       125:133\\n          20  address collateralToken                133:153\\n          32  uint256 collateralTokenId              153:185\\n          2   uint16  collateralWrapperContextLen    185:187\\n\\n      Collateral Wrapper Context Data (M bytes)      187:---\\n\\n      Node Receipts (48 * N bytes)\\n          N   NodeReceipts[] nodeReceipts\\n              16  uint128 tick\\n              16  uint128 used\\n              16  uint128 pending\\n    */\\n\\n    /**************************************************************************/\\n    /* API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @dev Compute loan receipt hash\\n     * @param encodedReceipt Encoded loan receipt\\n     * @return Loan Receipt hash\\n     */\\n    function hash(bytes memory encodedReceipt) internal view returns (bytes32) {\\n        /* Take hash of chain ID (32 bytes) concatenated with encoded loan receipt */\\n        return keccak256(abi.encodePacked(block.chainid, encodedReceipt));\\n    }\\n\\n    /**\\n     * @dev Encode a loan receipt into bytes\\n     * @param receipt Loan Receipt\\n     * @return Encoded loan receipt\\n     */\\n    function encode(LoanReceiptV2 memory receipt) internal pure returns (bytes memory) {\\n        /* Encode header */\\n        bytes memory header = abi.encodePacked(\\n            receipt.version,\\n            receipt.principal,\\n            receipt.repayment,\\n            receipt.adminFee,\\n            receipt.borrower,\\n            receipt.maturity,\\n            receipt.duration,\\n            receipt.collateralToken,\\n            receipt.collateralTokenId,\\n            receipt.collateralWrapperContextLen,\\n            receipt.collateralWrapperContext\\n        );\\n\\n        /* Encode node receipts */\\n        bytes memory nodeReceipts;\\n        for (uint256 i; i < receipt.nodeReceipts.length; i++) {\\n            nodeReceipts = abi.encodePacked(\\n                nodeReceipts,\\n                receipt.nodeReceipts[i].tick,\\n                receipt.nodeReceipts[i].used,\\n                receipt.nodeReceipts[i].pending\\n            );\\n        }\\n\\n        return abi.encodePacked(header, nodeReceipts);\\n    }\\n\\n    /**\\n     * @dev Decode a loan receipt from bytes\\n     * @param encodedReceipt Encoded loan Receipt\\n     * @return Decoded loan receipt\\n     */\\n    function decode(bytes calldata encodedReceipt) internal pure returns (LoanReceiptV2 memory) {\\n        /* Validate encoded receipt length */\\n        if (encodedReceipt.length < LOAN_RECEIPT_HEADER_SIZE) revert InvalidReceiptEncoding();\\n\\n        uint256 collateralWrapperContextLen = uint16(bytes2(encodedReceipt[185:187]));\\n\\n        /* Validate length with collateral wrapper context */\\n        if (encodedReceipt.length < LOAN_RECEIPT_HEADER_SIZE + collateralWrapperContextLen)\\n            revert InvalidReceiptEncoding();\\n\\n        /* Validate length with node receipts */\\n        if (\\n            (encodedReceipt.length - LOAN_RECEIPT_HEADER_SIZE - collateralWrapperContextLen) %\\n                LOAN_RECEIPT_NODE_RECEIPT_SIZE !=\\n            0\\n        ) revert InvalidReceiptEncoding();\\n\\n        /* Validate encoded receipt version */\\n        if (uint8(encodedReceipt[0]) != LOAN_RECEIPT_VERSION) revert InvalidReceiptEncoding();\\n\\n        LoanReceiptV2 memory receipt;\\n\\n        /* Decode header */\\n        receipt.version = uint8(encodedReceipt[0]);\\n        receipt.principal = uint256(bytes32(encodedReceipt[1:33]));\\n        receipt.repayment = uint256(bytes32(encodedReceipt[33:65]));\\n        receipt.adminFee = uint256(bytes32(encodedReceipt[65:97]));\\n        receipt.borrower = address(uint160(bytes20(encodedReceipt[97:117])));\\n        receipt.maturity = uint64(bytes8(encodedReceipt[117:125]));\\n        receipt.duration = uint64(bytes8(encodedReceipt[125:133]));\\n        receipt.collateralToken = address(uint160(bytes20(encodedReceipt[133:153])));\\n        receipt.collateralTokenId = uint256(bytes32(encodedReceipt[153:185]));\\n        receipt.collateralWrapperContextLen = uint16(collateralWrapperContextLen);\\n        receipt.collateralWrapperContext = encodedReceipt[187:187 + collateralWrapperContextLen];\\n\\n        /* Decode node receipts */\\n        uint256 numNodeReceipts = (encodedReceipt.length - LOAN_RECEIPT_HEADER_SIZE - collateralWrapperContextLen) /\\n            LOAN_RECEIPT_NODE_RECEIPT_SIZE;\\n        receipt.nodeReceipts = new NodeReceipt[](numNodeReceipts);\\n        uint256 offset = LOAN_RECEIPT_HEADER_SIZE + collateralWrapperContextLen;\\n        for (uint256 i; i < numNodeReceipts; i++) {\\n            receipt.nodeReceipts[i].tick = uint128(bytes16(encodedReceipt[offset:offset + 16]));\\n            receipt.nodeReceipts[i].used = uint128(bytes16(encodedReceipt[offset + 16:offset + 32]));\\n            receipt.nodeReceipts[i].pending = uint128(bytes16(encodedReceipt[offset + 32:offset + 48]));\\n            offset += LOAN_RECEIPT_NODE_RECEIPT_SIZE;\\n        }\\n\\n        return receipt;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Pool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Multicall.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport \\\"./filters/CollateralFilter.sol\\\";\\nimport \\\"./rates/InterestRateModel.sol\\\";\\nimport \\\"./tokenization/DepositToken.sol\\\";\\n\\nimport \\\"./LoanReceipt.sol\\\";\\nimport \\\"./LiquidityLogic.sol\\\";\\nimport \\\"./DepositLogic.sol\\\";\\nimport \\\"./BorrowLogic.sol\\\";\\n\\nimport \\\"./interfaces/IPool.sol\\\";\\nimport \\\"./interfaces/ILiquidity.sol\\\";\\nimport \\\"./interfaces/ICollateralWrapper.sol\\\";\\nimport \\\"./interfaces/ICollateralLiquidator.sol\\\";\\nimport \\\"./interfaces/ICollateralLiquidationReceiver.sol\\\";\\n\\nimport \\\"./integrations/DelegateCash/IDelegationRegistry.sol\\\";\\n\\n/**\\n * @title Pool\\n * @author MetaStreet Labs\\n */\\nabstract contract Pool is\\n    ERC165,\\n    ReentrancyGuard,\\n    Multicall,\\n    CollateralFilter,\\n    InterestRateModel,\\n    DepositToken,\\n    IPool,\\n    ILiquidity,\\n    ICollateralLiquidationReceiver\\n{\\n    using SafeCast for uint256;\\n    using SafeERC20 for IERC20;\\n    using LiquidityLogic for LiquidityLogic.Liquidity;\\n\\n    /**************************************************************************/\\n    /* Constants */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Tick spacing basis points\\n     */\\n    uint256 public constant TICK_LIMIT_SPACING_BASIS_POINTS = LiquidityLogic.TICK_LIMIT_SPACING_BASIS_POINTS;\\n\\n    /**\\n     * @notice Borrower's split of liquidation proceed surplus in basis points\\n     */\\n    uint256 public constant BORROWER_SURPLUS_SPLIT_BASIS_POINTS = BorrowLogic.BORROWER_SURPLUS_SPLIT_BASIS_POINTS;\\n\\n    /**************************************************************************/\\n    /* Structures */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Redemption\\n     * @param pending Redemption shares pending\\n     * @param index Redemption queue index\\n     * @param target Redemption queue target\\n     */\\n    struct Redemption {\\n        uint128 pending;\\n        uint128 index;\\n        uint128 target;\\n    }\\n\\n    /**\\n     * @notice Deposit\\n     * @param shares Shares\\n     * @param redemptionId Next Redemption ID\\n     * @param redemptions Mapping of redemption ID to redemption\\n     */\\n    struct Deposit {\\n        uint128 shares;\\n        uint128 redemptionId;\\n        mapping(uint128 => Redemption) redemptions;\\n    }\\n\\n    /**\\n     * @notice Loan status\\n     */\\n    enum LoanStatus {\\n        Uninitialized,\\n        Active,\\n        Repaid,\\n        Liquidated,\\n        CollateralLiquidated\\n    }\\n\\n    /**\\n     * @notice Borrow function options\\n     */\\n    enum BorrowOptions {\\n        None,\\n        CollateralWrapperContext,\\n        CollateralFilterContext,\\n        DelegateCash\\n    }\\n\\n    /**************************************************************************/\\n    /* Immutable State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Collateral wrappers (max 3)\\n     */\\n    address internal immutable _collateralWrapper1;\\n    address internal immutable _collateralWrapper2;\\n    address internal immutable _collateralWrapper3;\\n\\n    /**\\n     * @notice Collateral liquidator\\n     */\\n    ICollateralLiquidator internal immutable _collateralLiquidator;\\n\\n    /**\\n     * @notice Delegation registry contract\\n     */\\n    IDelegationRegistry internal immutable _delegationRegistry;\\n\\n    /**************************************************************************/\\n    /* State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Pool Storage\\n     * @param currencyToken Currency token contract\\n     * @param adminFeeRate Admin free rate in basis points\\n     * @param durations Durations\\n     * @param rates Rates\\n     * @param admin Admin\\n     * @param adminFeeBalance Admin fee balance\\n     * @param liquidity Liquidity\\n     * @param deposits Mapping of account to tick to deposit\\n     * @param loans Mapping of loan receipt hash to loan status\\n     */\\n    struct PoolStorage {\\n        IERC20 currencyToken;\\n        uint32 adminFeeRate;\\n        uint64[] durations;\\n        uint64[] rates;\\n        address admin;\\n        uint256 adminFeeBalance;\\n        LiquidityLogic.Liquidity liquidity;\\n        mapping(address => mapping(uint128 => Deposit)) deposits;\\n        mapping(bytes32 => LoanStatus) loans;\\n    }\\n\\n    /**\\n     * @notice Pool state\\n     */\\n    PoolStorage internal _storage;\\n\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Pool constructor\\n     * @param collateralLiquidator_ Collateral liquidator\\n     * @param delegationRegistry_ Delegation registry contract\\n     * @param collateralWrappers_ Collateral wrappers\\n     */\\n    constructor(address collateralLiquidator_, address delegationRegistry_, address[] memory collateralWrappers_) {\\n        if (collateralWrappers_.length > 3) revert InvalidParameters();\\n\\n        _collateralLiquidator = ICollateralLiquidator(collateralLiquidator_);\\n        _delegationRegistry = IDelegationRegistry(delegationRegistry_);\\n        _collateralWrapper1 = (collateralWrappers_.length > 0) ? collateralWrappers_[0] : address(0);\\n        _collateralWrapper2 = (collateralWrappers_.length > 1) ? collateralWrappers_[1] : address(0);\\n        _collateralWrapper3 = (collateralWrappers_.length > 2) ? collateralWrappers_[2] : address(0);\\n    }\\n\\n    /**************************************************************************/\\n    /* Initializer */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Pool initializer\\n     * @dev Fee-on-transfer currency tokens are not supported\\n     * @param currencyToken_ Currency token contract\\n     * @param durations_ Duration tiers\\n     * @param rates_ Interest rate tiers\\n     */\\n    function _initialize(address currencyToken_, uint64[] memory durations_, uint64[] memory rates_) internal {\\n        if (IERC20Metadata(currencyToken_).decimals() != 18) revert InvalidParameters();\\n\\n        _storage.currencyToken = IERC20(currencyToken_);\\n        _storage.admin = msg.sender;\\n\\n        /* Assign durations */\\n        if (durations_.length > Tick.MAX_NUM_DURATIONS) revert InvalidParameters();\\n        for (uint256 i; i < durations_.length; i++) {\\n            /* Check duration is monotonic */\\n            if (i != 0 && durations_[i] >= durations_[i - 1]) revert InvalidParameters();\\n            _storage.durations.push(durations_[i]);\\n        }\\n\\n        /* Assign rates */\\n        if (rates_.length > Tick.MAX_NUM_RATES) revert InvalidParameters();\\n        for (uint256 i; i < rates_.length; i++) {\\n            /* Check rate is monotonic */\\n            if (i != 0 && rates_[i] <= rates_[i - 1]) revert InvalidParameters();\\n            _storage.rates.push(rates_[i]);\\n        }\\n\\n        /* Initialize liquidity */\\n        _storage.liquidity.initialize();\\n    }\\n\\n    /**************************************************************************/\\n    /* Getters */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Get implementation name\\n     * @return Implementation name\\n     */\\n    function IMPLEMENTATION_NAME() external pure virtual returns (string memory);\\n\\n    /**\\n     * @notice Get implementation version\\n     * @return Implementation version\\n     */\\n    function IMPLEMENTATION_VERSION() external pure returns (string memory) {\\n        return \\\"2.3\\\";\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function currencyToken() external view returns (address) {\\n        return address(_storage.currencyToken);\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function durations() external view returns (uint64[] memory) {\\n        return _storage.durations;\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function rates() external view returns (uint64[] memory) {\\n        return _storage.rates;\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function admin() external view returns (address) {\\n        return _storage.admin;\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function adminFeeRate() external view returns (uint32) {\\n        return _storage.adminFeeRate;\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function adminFeeBalance() external view returns (uint256) {\\n        return _storage.adminFeeBalance;\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function collateralWrappers() external view returns (address[] memory) {\\n        address[] memory collateralWrappers_ = new address[](3);\\n        collateralWrappers_[0] = _collateralWrapper1;\\n        collateralWrappers_[1] = _collateralWrapper2;\\n        collateralWrappers_[2] = _collateralWrapper3;\\n        return collateralWrappers_;\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function collateralLiquidator() external view returns (address) {\\n        return address(_collateralLiquidator);\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function delegationRegistry() external view returns (address) {\\n        return address(_delegationRegistry);\\n    }\\n\\n    /**\\n     * @notice Get deposit\\n     * @param account Account\\n     * @param tick Tick\\n     * @return shares Shares\\n     * @return redemptionId Redemption ID\\n     */\\n    function deposits(address account, uint128 tick) external view returns (uint128 shares, uint128 redemptionId) {\\n        shares = _storage.deposits[account][tick].shares;\\n        redemptionId = _storage.deposits[account][tick].redemptionId;\\n    }\\n\\n    /**\\n     * @notice Get redemption\\n     * @param account Account\\n     * @param tick Tick\\n     * @param redemptionId Redemption ID\\n     * @return Redemption\\n     */\\n    function redemptions(\\n        address account,\\n        uint128 tick,\\n        uint128 redemptionId\\n    ) external view returns (Redemption memory) {\\n        return _storage.deposits[account][tick].redemptions[redemptionId];\\n    }\\n\\n    /**\\n     * @notice Get loan status\\n     * @param receiptHash Loan receipt hash\\n     * @return Loan status\\n     */\\n    function loans(bytes32 receiptHash) external view returns (LoanStatus) {\\n        return _storage.loans[receiptHash];\\n    }\\n\\n    /**\\n     * @inheritdoc ILiquidity\\n     */\\n    function liquidityNodes(uint128 startTick, uint128 endTick) external view returns (NodeInfo[] memory) {\\n        return _storage.liquidity.liquidityNodes(startTick, endTick);\\n    }\\n\\n    /**\\n     * @inheritdoc ILiquidity\\n     */\\n    function liquidityNode(uint128 tick) external view returns (NodeInfo memory) {\\n        return _storage.liquidity.liquidityNode(tick);\\n    }\\n\\n    /**\\n     * @inheritdoc ILiquidity\\n     */\\n    function liquidityNodeWithAccrual(uint128 tick) external view returns (NodeInfo memory, AccrualInfo memory) {\\n        return _storage.liquidity.liquidityNodeWithAccrual(tick);\\n    }\\n\\n    /**\\n     * @inheritdoc ILiquidity\\n     */\\n    function depositSharePrice(uint128 tick) external view returns (uint256) {\\n        return _storage.liquidity.depositSharePrice(tick);\\n    }\\n\\n    /**\\n     * @inheritdoc ILiquidity\\n     */\\n    function redemptionSharePrice(uint128 tick) external view returns (uint256) {\\n        return _storage.liquidity.redemptionSharePrice(tick);\\n    }\\n\\n    /**************************************************************************/\\n    /* Loan Receipt External Helpers */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Decode loan receipt\\n     * @param loanReceipt Loan receipt\\n     * @return Decoded loan receipt\\n     */\\n    function decodeLoanReceipt(bytes calldata loanReceipt) external pure returns (LoanReceipt.LoanReceiptV2 memory) {\\n        return LoanReceipt.decode(loanReceipt);\\n    }\\n\\n    /**************************************************************************/\\n    /* Helper Functions */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Helper function that returns underlying collateral in (address,\\n     * uint256[], uint256) shape\\n     * @param collateralToken Collateral token, either underlying token or collateral wrapper\\n     * @param collateralTokenId Collateral token ID\\n     * @param collateralWrapperContext Collateral wrapper context\\n     * @return token Underlying collateral token\\n     * @return tokenIds Underlying collateral token IDs (unique)\\n     * @return tokenCount Underlying total token count\\n     */\\n    function _getUnderlyingCollateral(\\n        address collateralToken,\\n        uint256 collateralTokenId,\\n        bytes memory collateralWrapperContext\\n    ) internal view returns (address token, uint256[] memory tokenIds, uint256 tokenCount) {\\n        /* Enumerate if collateral token is a collateral wrapper */\\n        if (\\n            collateralToken == _collateralWrapper1 ||\\n            collateralToken == _collateralWrapper2 ||\\n            collateralToken == _collateralWrapper3\\n        ) {\\n            (token, tokenIds) = ICollateralWrapper(collateralToken).enumerate(\\n                collateralTokenId,\\n                collateralWrapperContext\\n            );\\n            tokenCount = ICollateralWrapper(collateralToken).count(collateralTokenId, collateralWrapperContext);\\n            return (token, tokenIds, tokenCount);\\n        }\\n\\n        /* If single asset, convert to length one token ID array */\\n        token = collateralToken;\\n        tokenIds = new uint256[](1);\\n        tokenIds[0] = collateralTokenId;\\n        tokenCount = 1;\\n    }\\n\\n    /**\\n     * @notice Helper function that calls delegate.cash registry to delegate\\n     * token\\n     * @param collateralToken Collateral token\\n     * @param collateralTokenId Collateral token ID\\n     * @param options Options data\\n     */\\n    function _optionDelegateCash(address collateralToken, uint256 collateralTokenId, bytes calldata options) internal {\\n        /* Find delegate.cash tagged data in options */\\n        bytes calldata delegateData = BorrowLogic._getOptionsData(options, BorrowOptions.DelegateCash);\\n\\n        if (delegateData.length != 0) {\\n            if (address(_delegationRegistry) == address(0)) revert InvalidBorrowOptions();\\n            if (delegateData.length != 20) revert InvalidBorrowOptions();\\n\\n            /* Delegate token */\\n            _delegationRegistry.delegateForToken(\\n                address(uint160(bytes20(delegateData))),\\n                collateralToken,\\n                collateralTokenId,\\n                true\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Helper function to revoke token delegate\\n     * @param collateralToken Contract address of token that delegation is being removed from\\n     * @param collateralTokenId Token id of token that delegation is being removed from\\n     */\\n    function _revokeDelegates(address collateralToken, uint256 collateralTokenId) internal {\\n        /* No operation if _delegationRegistry not set */\\n        if (address(_delegationRegistry) == address(0)) return;\\n\\n        /* Get delegates for collateral token and id */\\n        address[] memory delegates = _delegationRegistry.getDelegatesForToken(\\n            address(this),\\n            collateralToken,\\n            collateralTokenId\\n        );\\n\\n        for (uint256 i; i < delegates.length; i++) {\\n            /* Revoke by setting value to false */\\n            _delegationRegistry.delegateForToken(delegates[i], collateralToken, collateralTokenId, false);\\n        }\\n    }\\n\\n    /**\\n     * @dev Helper function to quote a loan\\n     * @param principal Principal amount in currency tokens\\n     * @param duration Duration in seconds\\n     * @param collateralToken Collateral token address\\n     * @param collateralTokenId Collateral token ID\\n     * @param ticks Liquidity node ticks\\n     * @param collateralWrapperContext Collateral wrapper context\\n     * @param collateralFilterContext Collateral filter context\\n     * @param isRefinance True if called by refinance()\\n     * @return Repayment amount in currency tokens, admin fee in currency\\n     * tokens, liquidity nodes, liquidity node count\\n     */\\n    function _quote(\\n        uint256 principal,\\n        uint64 duration,\\n        address collateralToken,\\n        uint256 collateralTokenId,\\n        uint128[] calldata ticks,\\n        bytes memory collateralWrapperContext,\\n        bytes calldata collateralFilterContext,\\n        bool isRefinance\\n    ) internal view returns (uint256, uint256, LiquidityLogic.NodeSource[] memory, uint16) {\\n        /* Get underlying collateral */\\n        (\\n            address underlyingCollateralToken,\\n            uint256[] memory underlyingCollateralTokenIds,\\n            uint256 underlyingCollateralTokenCount\\n        ) = _getUnderlyingCollateral(collateralToken, collateralTokenId, collateralWrapperContext);\\n\\n        /* Verify collateral is supported */\\n        if (!isRefinance) {\\n            for (uint256 i; i < underlyingCollateralTokenIds.length; i++) {\\n                if (\\n                    !_collateralSupported(\\n                        underlyingCollateralToken,\\n                        underlyingCollateralTokenIds[i],\\n                        i,\\n                        collateralFilterContext\\n                    )\\n                ) revert UnsupportedCollateral(i);\\n            }\\n        }\\n\\n        /* Cache durations */\\n        uint64[] memory durations_ = _storage.durations;\\n\\n        /* Validate duration */\\n        if (duration > durations_[0]) revert UnsupportedLoanDuration();\\n\\n        /* Lookup duration index */\\n        uint256 durationIndex = durations_.length - 1;\\n        for (; durationIndex > 0; durationIndex--) {\\n            if (duration <= durations_[durationIndex]) break;\\n        }\\n\\n        /* Source liquidity nodes */\\n        (LiquidityLogic.NodeSource[] memory nodes, uint16 count) = _storage.liquidity.source(\\n            principal,\\n            ticks,\\n            underlyingCollateralTokenCount,\\n            durationIndex\\n        );\\n\\n        /* Calculate repayment from principal, rate, and duration */\\n        uint256 repayment = (principal *\\n            (LiquidityLogic.FIXED_POINT_SCALE + (_rate(principal, _storage.rates, nodes, count) * duration))) /\\n            LiquidityLogic.FIXED_POINT_SCALE;\\n\\n        /* Compute total fee */\\n        uint256 totalFee = repayment - principal;\\n\\n        /* Compute admin fee */\\n        uint256 adminFee = (_storage.adminFeeRate * totalFee) / LiquidityLogic.BASIS_POINTS_SCALE;\\n\\n        /* Distribute interest */\\n        _distribute(principal, totalFee - adminFee, nodes, count);\\n\\n        return (repayment, adminFee, nodes, count);\\n    }\\n\\n    /**************************************************************************/\\n    /* Lend API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function quote(\\n        uint256 principal,\\n        uint64 duration,\\n        address collateralToken,\\n        uint256 collateralTokenId,\\n        uint128[] calldata ticks,\\n        bytes calldata options\\n    ) external view returns (uint256) {\\n        /* Quote repayment */\\n        (uint256 repayment, , , ) = _quote(\\n            principal,\\n            duration,\\n            collateralToken,\\n            collateralTokenId,\\n            ticks,\\n            BorrowLogic._getOptionsData(options, BorrowOptions.CollateralWrapperContext),\\n            BorrowLogic._getOptionsData(options, BorrowOptions.CollateralFilterContext),\\n            false\\n        );\\n\\n        return repayment;\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function borrow(\\n        uint256 principal,\\n        uint64 duration,\\n        address collateralToken,\\n        uint256 collateralTokenId,\\n        uint256 maxRepayment,\\n        uint128[] calldata ticks,\\n        bytes calldata options\\n    ) external nonReentrant returns (uint256) {\\n        /* Quote repayment, admin fee, and liquidity nodes */\\n        (uint256 repayment, uint256 adminFee, LiquidityLogic.NodeSource[] memory nodes, uint16 count) = _quote(\\n            principal,\\n            duration,\\n            collateralToken,\\n            collateralTokenId,\\n            ticks,\\n            BorrowLogic._getOptionsData(options, BorrowOptions.CollateralWrapperContext),\\n            BorrowLogic._getOptionsData(options, BorrowOptions.CollateralFilterContext),\\n            false\\n        );\\n\\n        /* Handle borrow accounting */\\n        (bytes memory encodedLoanReceipt, bytes32 loanReceiptHash) = BorrowLogic._borrow(\\n            _storage,\\n            principal,\\n            duration,\\n            collateralToken,\\n            collateralTokenId,\\n            repayment,\\n            maxRepayment,\\n            adminFee,\\n            nodes,\\n            count,\\n            BorrowLogic._getOptionsData(options, BorrowOptions.CollateralWrapperContext)\\n        );\\n\\n        /* Handle delegate.cash option */\\n        _optionDelegateCash(collateralToken, collateralTokenId, options);\\n\\n        /* Transfer collateral from borrower to pool */\\n        IERC721(collateralToken).transferFrom(msg.sender, address(this), collateralTokenId);\\n\\n        /* Transfer principal from pool to borrower */\\n        _storage.currencyToken.safeTransfer(msg.sender, principal);\\n\\n        /* Emit LoanOriginated */\\n        emit LoanOriginated(loanReceiptHash, encodedLoanReceipt);\\n\\n        return repayment;\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function repay(bytes calldata encodedLoanReceipt) external nonReentrant returns (uint256) {\\n        /* Handle repay accounting */\\n        (uint256 repayment, LoanReceipt.LoanReceiptV2 memory loanReceipt, bytes32 loanReceiptHash) = BorrowLogic._repay(\\n            _storage,\\n            encodedLoanReceipt\\n        );\\n\\n        /* Revoke delegates */\\n        _revokeDelegates(loanReceipt.collateralToken, loanReceipt.collateralTokenId);\\n\\n        /* Transfer repayment from borrower to pool */\\n        _storage.currencyToken.safeTransferFrom(loanReceipt.borrower, address(this), repayment);\\n\\n        /* Transfer collateral from pool to borrower */\\n        IERC721(loanReceipt.collateralToken).transferFrom(\\n            address(this),\\n            loanReceipt.borrower,\\n            loanReceipt.collateralTokenId\\n        );\\n\\n        /* Emit Loan Repaid */\\n        emit LoanRepaid(loanReceiptHash, repayment);\\n\\n        return repayment;\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function refinance(\\n        bytes calldata encodedLoanReceipt,\\n        uint256 principal,\\n        uint64 duration,\\n        uint256 maxRepayment,\\n        uint128[] calldata ticks\\n    ) external nonReentrant returns (uint256) {\\n        /* Handle repay accounting */\\n        (uint256 repayment, LoanReceipt.LoanReceiptV2 memory loanReceipt, bytes32 loanReceiptHash) = BorrowLogic._repay(\\n            _storage,\\n            encodedLoanReceipt\\n        );\\n\\n        /* Quote new repayment, admin fee, and liquidity nodes */\\n        (uint256 newRepayment, uint256 adminFee, LiquidityLogic.NodeSource[] memory nodes, uint16 count) = _quote(\\n            principal,\\n            duration,\\n            loanReceipt.collateralToken,\\n            loanReceipt.collateralTokenId,\\n            ticks,\\n            loanReceipt.collateralWrapperContext,\\n            encodedLoanReceipt[0:0],\\n            true\\n        );\\n\\n        /* Handle borrow accounting */\\n        (bytes memory newEncodedLoanReceipt, bytes32 newLoanReceiptHash) = BorrowLogic._borrow(\\n            _storage,\\n            principal,\\n            duration,\\n            loanReceipt.collateralToken,\\n            loanReceipt.collateralTokenId,\\n            newRepayment,\\n            maxRepayment,\\n            adminFee,\\n            nodes,\\n            count,\\n            loanReceipt.collateralWrapperContext\\n        );\\n\\n        /* Determine transfer direction */\\n        if (principal < repayment) {\\n            /* Transfer prorated repayment less principal from borrower to pool */\\n            _storage.currencyToken.safeTransferFrom(loanReceipt.borrower, address(this), repayment - principal);\\n        } else {\\n            /* Transfer principal less prorated repayment from pool to borrower */\\n            _storage.currencyToken.safeTransfer(msg.sender, principal - repayment);\\n        }\\n\\n        /* Emit Loan Repaid */\\n        emit LoanRepaid(loanReceiptHash, repayment);\\n\\n        /* Emit LoanOriginated */\\n        emit LoanOriginated(newLoanReceiptHash, newEncodedLoanReceipt);\\n\\n        return newRepayment;\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function liquidate(bytes calldata encodedLoanReceipt) external nonReentrant {\\n        /* Handle liquidate accounting */\\n        (LoanReceipt.LoanReceiptV2 memory loanReceipt, bytes32 loanReceiptHash) = BorrowLogic._liquidate(\\n            _storage,\\n            encodedLoanReceipt\\n        );\\n\\n        /* Revoke delegates */\\n        _revokeDelegates(loanReceipt.collateralToken, loanReceipt.collateralTokenId);\\n\\n        /* Approve collateral for transfer to _collateralLiquidator */\\n        IERC721(loanReceipt.collateralToken).approve(address(_collateralLiquidator), loanReceipt.collateralTokenId);\\n\\n        /* Start liquidation with collateral liquidator */\\n        _collateralLiquidator.liquidate(\\n            address(_storage.currencyToken),\\n            loanReceipt.collateralToken,\\n            loanReceipt.collateralTokenId,\\n            loanReceipt.collateralWrapperContext,\\n            encodedLoanReceipt\\n        );\\n\\n        /* Emit Loan Liquidated */\\n        emit LoanLiquidated(loanReceiptHash);\\n    }\\n\\n    /**************************************************************************/\\n    /* Callbacks */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc ICollateralLiquidationReceiver\\n     */\\n    function onCollateralLiquidated(bytes calldata encodedLoanReceipt, uint256 proceeds) external nonReentrant {\\n        /* Validate caller is collateral liquidator */\\n        if (msg.sender != address(_collateralLiquidator)) revert InvalidCaller();\\n\\n        /* Handle collateral liquidation accounting */\\n        (uint256 borrowerSurplus, LoanReceipt.LoanReceiptV2 memory loanReceipt, bytes32 loanReceiptHash) = BorrowLogic\\n            ._onCollateralLiquidated(_storage, encodedLoanReceipt, proceeds);\\n\\n        /* Transfer surplus to borrower */\\n        if (borrowerSurplus != 0) IERC20(_storage.currencyToken).safeTransfer(loanReceipt.borrower, borrowerSurplus);\\n\\n        /* Emit Collateral Liquidated */\\n        emit CollateralLiquidated(loanReceiptHash, proceeds, borrowerSurplus);\\n    }\\n\\n    /**************************************************************************/\\n    /* Deposit API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function deposit(uint128 tick, uint256 amount, uint256 minShares) external nonReentrant returns (uint256) {\\n        /* Handle deposit accounting and compute shares */\\n        uint128 shares = DepositLogic._deposit(_storage, tick, amount.toUint128(), minShares.toUint128());\\n\\n        /* Call token hook */\\n        onExternalTransfer(address(0), msg.sender, tick, shares);\\n\\n        /* Transfer deposit amount */\\n        _storage.currencyToken.safeTransferFrom(msg.sender, address(this), amount);\\n\\n        /* Emit Deposited */\\n        emit Deposited(msg.sender, tick, amount, shares);\\n\\n        return shares;\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function redeem(uint128 tick, uint256 shares) external nonReentrant returns (uint128) {\\n        /* Handle redeem accounting */\\n        uint128 redemptionId = DepositLogic._redeem(_storage, tick, shares.toUint128());\\n\\n        /* Call token hook */\\n        onExternalTransfer(msg.sender, address(0), tick, shares);\\n\\n        /* Emit Redeemed event */\\n        emit Redeemed(msg.sender, tick, redemptionId, shares);\\n\\n        return redemptionId;\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function redemptionAvailable(\\n        address account,\\n        uint128 tick,\\n        uint128 redemptionId\\n    ) external view returns (uint256 shares, uint256 amount, uint256 sharesAhead) {\\n        /* Handle redemption available accounting */\\n        return DepositLogic._redemptionAvailable(_storage, account, tick, redemptionId);\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function withdraw(uint128 tick, uint128 redemptionId) external nonReentrant returns (uint256, uint256) {\\n        /* Handle withdraw accounting and compute both shares and amount */\\n        (uint128 shares, uint128 amount) = DepositLogic._withdraw(_storage, tick, redemptionId);\\n\\n        /* Transfer withdrawal amount */\\n        if (amount != 0) _storage.currencyToken.safeTransfer(msg.sender, amount);\\n\\n        /* Emit Withdrawn */\\n        emit Withdrawn(msg.sender, tick, redemptionId, shares, amount);\\n\\n        return (shares, amount);\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function rebalance(\\n        uint128 srcTick,\\n        uint128 dstTick,\\n        uint128 redemptionId,\\n        uint256 minShares\\n    ) external nonReentrant returns (uint256, uint256, uint256) {\\n        /* Handle withdraw accounting and compute both shares and amount */\\n        (uint128 oldShares, uint128 amount) = DepositLogic._withdraw(_storage, srcTick, redemptionId);\\n\\n        /* Handle deposit accounting and compute new shares */\\n        uint128 newShares = DepositLogic._deposit(_storage, dstTick, amount, minShares.toUint128());\\n\\n        /* Call token hook */\\n        onExternalTransfer(address(0), msg.sender, dstTick, newShares);\\n\\n        /* Emit Withdrawn */\\n        emit Withdrawn(msg.sender, srcTick, redemptionId, oldShares, amount);\\n\\n        /* Emit Deposited */\\n        emit Deposited(msg.sender, dstTick, amount, newShares);\\n\\n        return (oldShares, newShares, amount);\\n    }\\n\\n    /**\\n     * @notice Transfer shares between accounts by operator\\n     *\\n     * @dev Only callable by deposit token contract\\n     *\\n     * @param from From\\n     * @param to To\\n     * @param tick Tick\\n     * @param shares Shares\\n     */\\n    function transfer(address from, address to, uint128 tick, uint256 shares) external nonReentrant {\\n        /* Validate caller is deposit token created by Pool */\\n        if (msg.sender != depositToken(tick)) revert InvalidCaller();\\n\\n        /* Handle transfer accounting */\\n        DepositLogic._transfer(_storage, from, to, tick, shares.toUint128());\\n\\n        /* Emit Transferred */\\n        emit Transferred(from, to, tick, shares);\\n    }\\n\\n    /**************************************************************************/\\n    /* Admin Fees API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Set the admin fee rate\\n     *\\n     * Emits a {AdminFeeRateUpdated} event.\\n     *\\n     * @param rate Rate is the admin fee in basis points\\n     */\\n    function setAdminFeeRate(uint32 rate) external {\\n        if (msg.sender != _storage.admin) revert InvalidCaller();\\n        if (rate >= LiquidityLogic.BASIS_POINTS_SCALE) revert InvalidParameters();\\n\\n        _storage.adminFeeRate = rate;\\n\\n        emit AdminFeeRateUpdated(rate);\\n    }\\n\\n    /**\\n     * @notice Withdraw admin fees\\n     *\\n     * Emits a {AdminFeesWithdrawn} event.\\n     *\\n     * @param recipient Recipient account\\n     * @param amount Amount to withdraw\\n     */\\n    function withdrawAdminFees(address recipient, uint256 amount) external nonReentrant {\\n        if (msg.sender != _storage.admin) revert InvalidCaller();\\n        if (recipient == address(0) || amount > _storage.adminFeeBalance) revert InvalidParameters();\\n\\n        /* Update admin fees balance */\\n        _storage.adminFeeBalance -= amount;\\n\\n        /* Transfer cash from Pool to recipient */\\n        _storage.currencyToken.safeTransfer(recipient, amount);\\n\\n        emit AdminFeesWithdrawn(recipient, amount);\\n    }\\n\\n    /******************************************************/\\n    /* ERC165 interface */\\n    /******************************************************/\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\\n        return interfaceId == type(ICollateralLiquidationReceiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PoolFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\\\";\\n\\nimport \\\"./interfaces/IPoolFactory.sol\\\";\\n\\n/**\\n * @title PoolFactory\\n * @author MetaStreet Labs\\n */\\ncontract PoolFactory is Ownable, ERC1967Upgrade, IPoolFactory {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    /**************************************************************************/\\n    /* Constants */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Implementation version\\n     */\\n    string public constant IMPLEMENTATION_VERSION = \\\"1.2\\\";\\n\\n    /**************************************************************************/\\n    /* State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Initialized boolean\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @notice Set of deployed pools\\n     */\\n    EnumerableSet.AddressSet private _pools;\\n\\n    /**\\n     * @notice Set of allowed pool implementations\\n     */\\n    EnumerableSet.AddressSet private _allowedImplementations;\\n\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice PoolFactory constructor\\n     */\\n    constructor() {\\n        /* Disable initialization of implementation contract */\\n        _initialized = true;\\n\\n        /* Disable owner of implementation contract */\\n        renounceOwnership();\\n    }\\n\\n    /**************************************************************************/\\n    /* Initializer */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice PoolFactory initializator\\n     */\\n    function initialize() external {\\n        require(!_initialized, \\\"Already initialized\\\");\\n\\n        _initialized = true;\\n        _transferOwnership(msg.sender);\\n    }\\n\\n    /**************************************************************************/\\n    /* Primary API */\\n    /**************************************************************************/\\n\\n    /*\\n     * @inheritdoc IPoolFactory\\n     */\\n    function create(address poolImplementation, bytes calldata params) external returns (address) {\\n        /* Validate pool implementation */\\n        if (!_allowedImplementations.contains(poolImplementation)) revert UnsupportedImplementation();\\n\\n        /* Create pool instance */\\n        address poolInstance = Clones.clone(poolImplementation);\\n        Address.functionCall(poolInstance, abi.encodeWithSignature(\\\"initialize(bytes)\\\", params));\\n\\n        /* Add pool to registry */\\n        _pools.add(poolInstance);\\n\\n        /* Emit Pool Created */\\n        emit PoolCreated(poolInstance, poolImplementation);\\n\\n        return poolInstance;\\n    }\\n\\n    /*\\n     * @inheritdoc IPoolFactory\\n     */\\n    function createProxied(address poolBeacon, bytes calldata params) external returns (address) {\\n        /* Validate pool implementation */\\n        if (!_allowedImplementations.contains(poolBeacon)) revert UnsupportedImplementation();\\n\\n        /* Create pool instance */\\n        address poolInstance = address(\\n            new BeaconProxy(poolBeacon, abi.encodeWithSignature(\\\"initialize(bytes)\\\", params))\\n        );\\n\\n        /* Add pool to registry */\\n        _pools.add(poolInstance);\\n\\n        /* Emit Pool Created */\\n        emit PoolCreated(poolInstance, poolBeacon);\\n\\n        return poolInstance;\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolFactory\\n     */\\n    function isPool(address pool) public view returns (bool) {\\n        return _pools.contains(pool);\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolFactory\\n     */\\n    function getPools() external view returns (address[] memory) {\\n        return _pools.values();\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolFactory\\n     */\\n    function getPoolCount() external view returns (uint256) {\\n        return _pools.length();\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolFactory\\n     */\\n    function getPoolAt(uint256 index) external view returns (address) {\\n        return _pools.at(index);\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolFactory\\n     */\\n    function getPoolImplementations() external view returns (address[] memory) {\\n        return _allowedImplementations.values();\\n    }\\n\\n    /**************************************************************************/\\n    /* Admin API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Set pool admin fee rate\\n     * @param pool Pool address\\n     * @param rate Rate is the admin fee in basis points\\n     */\\n    function setAdminFeeRate(address pool, uint32 rate) external onlyOwner {\\n        /* Validate pool */\\n        if (!isPool(pool)) revert InvalidPool();\\n\\n        Address.functionCall(pool, abi.encodeWithSignature(\\\"setAdminFeeRate(uint32)\\\", rate));\\n    }\\n\\n    /**\\n     * @notice Add pool implementation to allowlist\\n     * @param poolImplementation Pool implementation\\n     */\\n    function addPoolImplementation(address poolImplementation) external onlyOwner {\\n        if (_allowedImplementations.add(poolImplementation)) {\\n            emit PoolImplementationAdded(poolImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @notice Remove pool implementation from allowlist\\n     * @param poolImplementation Pool implementation\\n     */\\n    function removePoolImplementation(address poolImplementation) external onlyOwner {\\n        if (_allowedImplementations.remove(poolImplementation)) {\\n            emit PoolImplementationRemoved(poolImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @notice Get Proxy Implementation\\n     * @return Implementation address\\n     */\\n    function getImplementation() external view returns (address) {\\n        return _getImplementation();\\n    }\\n\\n    /**\\n     * @notice Upgrade Proxy\\n     * @param newImplementation New implementation contract\\n     * @param data Optional calldata\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external onlyOwner {\\n        _upgradeToAndCall(newImplementation, data, false);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rates/InterestRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../LiquidityLogic.sol\\\";\\n\\n/**\\n * @title Interest Rate Model API\\n * @author MetaStreet Labs\\n */\\nabstract contract InterestRateModel {\\n    /**************************************************************************/\\n    /* Errors */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Invalid parameters\\n     */\\n    error InvalidInterestRateModelParameters();\\n\\n    /**************************************************************************/\\n    /* API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Get interest rate model name\\n     * @return Interest rate model name\\n     */\\n    function INTEREST_RATE_MODEL_NAME() external view virtual returns (string memory);\\n\\n    /**\\n     * @notice Get interest rate model version\\n     * @return Interest rate model version\\n     */\\n    function INTEREST_RATE_MODEL_VERSION() external view virtual returns (string memory);\\n\\n    /**\\n     * Get interest rate for liquidity\\n     * @param amount Liquidity amount\\n     * @param rates Rates\\n     * @param nodes Liquidity nodes\\n     * @param count Liquidity node count\\n     * @return Interest per second\\n     */\\n    function _rate(\\n        uint256 amount,\\n        uint64[] memory rates,\\n        LiquidityLogic.NodeSource[] memory nodes,\\n        uint16 count\\n    ) internal view virtual returns (uint256);\\n\\n    /**\\n     * Distribute interest to liquidity\\n     * @param amount Liquidity amount\\n     * @param interest Interest to distribute\\n     * @param nodes Liquidity nodes\\n     * @param count Liquidity node count\\n     */\\n    function _distribute(\\n        uint256 amount,\\n        uint256 interest,\\n        LiquidityLogic.NodeSource[] memory nodes,\\n        uint16 count\\n    ) internal view virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/rates/WeightedInterestRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport \\\"./InterestRateModel.sol\\\";\\nimport \\\"../Tick.sol\\\";\\n\\n/**\\n * @title Weighted Interest Rate Model\\n * @author MetaStreet Labs\\n */\\ncontract WeightedInterestRateModel is InterestRateModel {\\n    using SafeCast for uint256;\\n\\n    /**************************************************************************/\\n    /* Constants */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Fixed point scale\\n     */\\n    uint256 internal constant FIXED_POINT_SCALE = 1e18;\\n\\n    /**\\n     * @notice Maximum tick threshold (0.5)\\n     */\\n    uint256 internal constant MAX_TICK_THRESHOLD = 0.5 * 1e18;\\n\\n    /**\\n     * @notice Minimum tick exponential (0.25)\\n     */\\n    uint256 internal constant MIN_TICK_EXPONENTIAL = 0.25 * 1e18;\\n\\n    /**\\n     * @notice Maximum tick exponential (4.0)\\n     */\\n    uint256 internal constant MAX_TICK_EXPONENTIAL = 4.0 * 1e18;\\n\\n    /**************************************************************************/\\n    /* Structures */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Parameters\\n     * @param tickThreshold Tick interest threshold\\n     * @param tickExponential Tick exponential base\\n     */\\n    struct Parameters {\\n        uint64 tickThreshold;\\n        uint64 tickExponential;\\n    }\\n\\n    /**************************************************************************/\\n    /* Errors */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Insufficient utilization\\n     */\\n    error InsufficientUtilization();\\n\\n    /**************************************************************************/\\n    /* Immutable State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Tick interest threshold\\n     */\\n    uint64 internal immutable _tickThreshold;\\n\\n    /**\\n     * @notice Tick exponential base\\n     */\\n    uint64 internal immutable _tickExponential;\\n\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice WeightedInterestRateModel constructor\\n     */\\n    constructor(Parameters memory parameters) {\\n        if (parameters.tickThreshold > MAX_TICK_THRESHOLD) revert InvalidInterestRateModelParameters();\\n        if (parameters.tickExponential < MIN_TICK_EXPONENTIAL) revert InvalidInterestRateModelParameters();\\n        if (parameters.tickExponential > MAX_TICK_EXPONENTIAL) revert InvalidInterestRateModelParameters();\\n\\n        _tickThreshold = parameters.tickThreshold;\\n        _tickExponential = parameters.tickExponential;\\n    }\\n\\n    /**************************************************************************/\\n    /* Implementation */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc InterestRateModel\\n     */\\n    function INTEREST_RATE_MODEL_NAME() external pure override returns (string memory) {\\n        return \\\"WeightedInterestRateModel\\\";\\n    }\\n\\n    /**\\n     * @inheritdoc InterestRateModel\\n     */\\n    function INTEREST_RATE_MODEL_VERSION() external pure override returns (string memory) {\\n        return \\\"1.0\\\";\\n    }\\n\\n    /**\\n     * @inheritdoc InterestRateModel\\n     */\\n    function _rate(\\n        uint256 amount,\\n        uint64[] memory rates,\\n        LiquidityLogic.NodeSource[] memory nodes,\\n        uint16 count\\n    ) internal pure override returns (uint256) {\\n        uint256 weightedRate;\\n\\n        /* Accumulate weighted rate */\\n        for (uint256 i; i < count; i++) {\\n            (, , uint256 rateIndex, ) = Tick.decode(nodes[i].tick);\\n            weightedRate += (uint256(nodes[i].used) * rates[rateIndex]) / FIXED_POINT_SCALE;\\n        }\\n\\n        /* Return normalized weighted rate */\\n        return Math.mulDiv(weightedRate, FIXED_POINT_SCALE, amount);\\n    }\\n\\n    /**\\n     * @inheritdoc InterestRateModel\\n     */\\n    function _distribute(\\n        uint256 amount,\\n        uint256 interest,\\n        LiquidityLogic.NodeSource[] memory nodes,\\n        uint16 count\\n    ) internal view override {\\n        /* Interest threshold for tick to receive interest */\\n        uint256 threshold = Math.mulDiv(_tickThreshold, amount, FIXED_POINT_SCALE);\\n\\n        /* Interest weight starting at final tick */\\n        uint256 base = _tickExponential;\\n        uint256 weight = (FIXED_POINT_SCALE * FIXED_POINT_SCALE) / base;\\n\\n        /* Assign weighted interest to ticks backwards */\\n        uint128[] memory interests = new uint128[](count);\\n        uint256 normalization;\\n        uint256 index = count;\\n        for (uint256 i; i < count; i++) {\\n            /* Skip tick if it's below threshold */\\n            if (nodes[--index].used <= threshold) continue;\\n\\n            /* Compute scaled weight */\\n            uint256 scaledWeight = Math.mulDiv(weight, nodes[index].used, amount);\\n\\n            /* Assign weighted interest */\\n            interests[index] = Math.mulDiv(scaledWeight, interest, FIXED_POINT_SCALE).toUint128();\\n\\n            /* Accumulate scaled weight for later normalization */\\n            normalization += scaledWeight;\\n\\n            /* Adjust interest weight for next tick */\\n            weight = Math.mulDiv(weight, FIXED_POINT_SCALE, base);\\n        }\\n\\n        /* Validate normalization is non-zero */\\n        if (normalization == 0) revert InsufficientUtilization();\\n\\n        /* Normalize weighted interest */\\n        for (uint256 i; i < count; i++) {\\n            /* Calculate normalized interest to tick */\\n            uint256 normalizedInterest = (interests[i] * FIXED_POINT_SCALE) / normalization;\\n\\n            /* Assign node pending amount */\\n            nodes[i].pending = nodes[i].used + normalizedInterest.toUint128();\\n\\n            /* Track remaining interest */\\n            interest -= normalizedInterest;\\n        }\\n\\n        /* Drop off remaining dust at lowest tick */\\n        nodes[0].pending += interest.toUint128();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/ExternalCollateralLiquidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\n\\nimport \\\"../interfaces/ICollateralLiquidationReceiver.sol\\\";\\nimport \\\"../interfaces/ICollateralLiquidator.sol\\\";\\nimport \\\"../interfaces/IPool.sol\\\";\\n\\n/**\\n * @title External Collateral Liquidator (trusted)\\n * @author MetaStreet Labs\\n */\\ncontract ExternalCollateralLiquidator is AccessControl, ICollateralLiquidator, ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n\\n    /**************************************************************************/\\n    /* Access Control Roles */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Collateral liquidator role\\n     */\\n    bytes32 public constant COLLATERAL_LIQUIDATOR_ROLE = keccak256(\\\"COLLATERAL_LIQUIDATOR\\\");\\n\\n    /**************************************************************************/\\n    /* Constants */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Implementation version\\n     */\\n    string public constant IMPLEMENTATION_VERSION = \\\"1.0\\\";\\n\\n    /**************************************************************************/\\n    /* Errors */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Invalid token\\n     */\\n    error InvalidToken();\\n\\n    /**\\n     * @notice Invalid caller\\n     */\\n    error InvalidCaller();\\n\\n    /**\\n     * @notice Invalid liquidation\\n     */\\n    error InvalidLiquidation();\\n\\n    /**\\n     * @notice Invalid collateral state\\n     */\\n    error InvalidCollateralState();\\n\\n    /**************************************************************************/\\n    /* Events */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Emitted when collateral is received\\n     * @param collateralHash Collateral hash\\n     * @param source Source that provided collateral\\n     * @param collateralToken Collateral token contract\\n     * @param collateralTokenId Collateral token ID\\n     */\\n    event CollateralReceived(\\n        bytes32 indexed collateralHash,\\n        address indexed source,\\n        address collateralToken,\\n        uint256 collateralTokenId\\n    );\\n\\n    /**\\n     * @notice Emitted when collateral is withdrawn\\n     * @param collateralHash Collateral hash\\n     * @param source Source that provided collateral\\n     * @param collateralToken Collateral token contract\\n     * @param collateralTokenId Collateral token ID\\n     */\\n    event CollateralWithdrawn(\\n        bytes32 indexed collateralHash,\\n        address indexed source,\\n        address collateralToken,\\n        uint256 collateralTokenId\\n    );\\n\\n    /**\\n     * @notice Emitted when collateral is liquidated\\n     * @param collateralHash Collateral hash\\n     * @param collateralToken Collateral token contract\\n     * @param collateralTokenId Collateral token ID\\n     * @param proceeds Proceeds in currency tokens\\n     */\\n    event CollateralLiquidated(\\n        bytes32 indexed collateralHash,\\n        address collateralToken,\\n        uint256 collateralTokenId,\\n        uint256 proceeds\\n    );\\n\\n    /**************************************************************************/\\n    /* Enums */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Collateral Status\\n     */\\n    enum CollateralStatus {\\n        Absent,\\n        Present,\\n        Withdrawn\\n    }\\n\\n    /**************************************************************************/\\n    /* State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Initialized boolean\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Collateral tracker\\n     */\\n    mapping(bytes32 => CollateralStatus) private _collateralTracker;\\n\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice ExternalCollateralLiquidator constructor\\n     */\\n    constructor() {\\n        /* Disable initialization of implementation contract */\\n        _initialized = true;\\n    }\\n\\n    /**************************************************************************/\\n    /* Initializer */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Initializer\\n     */\\n    function initialize() external {\\n        require(!_initialized, \\\"Already initialized\\\");\\n\\n        _initialized = true;\\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n    }\\n\\n    /**************************************************************************/\\n    /* Helper Functions */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Helper function to compute collateral hash\\n     * @param source Source that provided collateral\\n     * @param collateralToken Collateral token\\n     * @param collateralTokenId Collateral token ID\\n     * @param currencyToken Currency token\\n     * @param collateralWrapperContext Collateral wrapper context\\n     * @param liquidationContext Liquidation callback context\\n     */\\n    function _collateralHash(\\n        address source,\\n        address collateralToken,\\n        uint256 collateralTokenId,\\n        address currencyToken,\\n        bytes calldata collateralWrapperContext,\\n        bytes calldata liquidationContext\\n    ) internal view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    block.chainid,\\n                    source,\\n                    collateralToken,\\n                    collateralTokenId,\\n                    collateralWrapperContext,\\n                    currencyToken,\\n                    liquidationContext\\n                )\\n            );\\n    }\\n\\n    /**************************************************************************/\\n    /* Getters */\\n    /**************************************************************************/\\n    /**\\n     * Get collateral status\\n     * @param collateralHash Collateral hash\\n     * @return Collateral tracker\\n     */\\n    function collateralStatus(bytes32 collateralHash) external view returns (CollateralStatus) {\\n        return _collateralTracker[collateralHash];\\n    }\\n\\n    /**************************************************************************/\\n    /* Implementation */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc ICollateralLiquidator\\n     */\\n    function name() external pure returns (string memory) {\\n        return \\\"ExternalCollateralLiquidator\\\";\\n    }\\n\\n    /**\\n     * @inheritdoc ICollateralLiquidator\\n     */\\n    function liquidate(\\n        address currencyToken,\\n        address collateralToken,\\n        uint256 collateralTokenId,\\n        bytes calldata collateralWrapperContext,\\n        bytes calldata liquidationContext\\n    ) external nonReentrant {\\n        /* Check collateralToken and currencyToken is not zero address */\\n        if (collateralToken == address(0) || currencyToken == address(0)) revert InvalidToken();\\n\\n        /* Compute liquidation hash */\\n        bytes32 collateralHash = _collateralHash(\\n            msg.sender,\\n            collateralToken,\\n            collateralTokenId,\\n            currencyToken,\\n            collateralWrapperContext,\\n            liquidationContext\\n        );\\n\\n        /* Validate collateral is not already present */\\n        if (_collateralTracker[collateralHash] != CollateralStatus.Absent) revert InvalidLiquidation();\\n\\n        /* Transfer collateral token from source to this contract */\\n        IERC721(collateralToken).transferFrom(msg.sender, address(this), collateralTokenId);\\n\\n        /* Update collateral tracker */\\n        _collateralTracker[collateralHash] = CollateralStatus.Present;\\n\\n        /* Emit CollateralReceived */\\n        emit CollateralReceived(collateralHash, msg.sender, collateralToken, collateralTokenId);\\n    }\\n\\n    /**\\n     * @notice Withdraw collateral\\n     *\\n     * Emits a {CollateralWithdrawn} event.\\n     *\\n     * @param source Source that provided collateral\\n     * @param currencyToken Currency token\\n     * @param collateralToken Collateral token, either underlying token or collateral wrapper\\n     * @param collateralTokenId Collateral token ID\\n     * @param collateralWrapperContext Collateral wrapper context\\n     * @param liquidationContext Liquidation callback context\\n     */\\n    function withdrawCollateral(\\n        address source,\\n        address currencyToken,\\n        address collateralToken,\\n        uint256 collateralTokenId,\\n        bytes calldata collateralWrapperContext,\\n        bytes calldata liquidationContext\\n    ) external onlyRole(COLLATERAL_LIQUIDATOR_ROLE) {\\n        /* Compute collateral hash */\\n        bytes32 collateralHash = _collateralHash(\\n            source,\\n            collateralToken,\\n            collateralTokenId,\\n            currencyToken,\\n            collateralWrapperContext,\\n            liquidationContext\\n        );\\n\\n        /* Validate collateral is present */\\n        if (_collateralTracker[collateralHash] != CollateralStatus.Present) revert InvalidCollateralState();\\n\\n        /* Transfer collateral to caller */\\n        IERC721(collateralToken).safeTransferFrom(address(this), msg.sender, collateralTokenId);\\n\\n        /* Update collateral tracker */\\n        _collateralTracker[collateralHash] = CollateralStatus.Withdrawn;\\n\\n        emit CollateralWithdrawn(collateralHash, source, collateralToken, collateralTokenId);\\n    }\\n\\n    /**\\n     * @notice Liquidate collateral\\n     *\\n     * Emits a {CollateralLiquidated} event.\\n     *\\n     * @param source Source that provided collateral\\n     * @param collateralToken Collateral token from liquidate parameter earlier\\n     * @param collateralTokenId Collateral token ID from liquidate parameter earlier\\n     * @param collateralWrapperContext Collateral wrapper context\\n     * @param liquidationContext Liquidation context\\n     */\\n    function liquidateCollateral(\\n        address source,\\n        address currencyToken,\\n        address collateralToken,\\n        uint256 collateralTokenId,\\n        bytes calldata collateralWrapperContext,\\n        bytes calldata liquidationContext,\\n        uint256 proceeds\\n    ) external onlyRole(COLLATERAL_LIQUIDATOR_ROLE) {\\n        /* Compute collateral hash */\\n        bytes32 collateralHash = _collateralHash(\\n            source,\\n            collateralToken,\\n            collateralTokenId,\\n            currencyToken,\\n            collateralWrapperContext,\\n            liquidationContext\\n        );\\n\\n        /* Validate collateral is present */\\n        if (_collateralTracker[collateralHash] != CollateralStatus.Withdrawn) revert InvalidCollateralState();\\n\\n        /* Transfer proceeds from caller to this contract */\\n        IERC20(currencyToken).safeTransferFrom(msg.sender, address(this), proceeds);\\n\\n        /* Transfer collateral to caller */\\n        IERC20(currencyToken).transfer(source, proceeds);\\n\\n        /* If transfer is successful and source is a contract, try collateral liquidation callback */\\n        if (Address.isContract(source))\\n            try ICollateralLiquidationReceiver(source).onCollateralLiquidated(liquidationContext, proceeds) {} catch {}\\n\\n        /* Emit CollateralLiquidated() */\\n        emit CollateralLiquidated(collateralHash, collateralToken, collateralTokenId, proceeds);\\n\\n        /* Delete underlying collateral */\\n        delete _collateralTracker[collateralHash];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/filters/TestCollectionCollateralFilter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../../filters/CollectionCollateralFilter.sol\\\";\\n\\n/**\\n * @title Test Contract Wrapper for CollectionCollateralFilter\\n * @author MetaStreet Labs\\n */\\ncontract TestCollectionCollateralFilter is CollectionCollateralFilter {\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    constructor(address token) {\\n        _initialize(token);\\n    }\\n\\n    /**************************************************************************/\\n    /* Wrapper for Primary API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @dev External wrapper function for _collateralSupported\\n     */\\n    function collateralSupported(\\n        address token,\\n        uint256 tokenId,\\n        uint256 index,\\n        bytes calldata context\\n    ) external view returns (bool) {\\n        return _collateralSupported(token, tokenId, index, context);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/filters/TestMerkleCollectionCollateralFilter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../../filters/MerkleCollectionCollateralFilter.sol\\\";\\n\\n/**\\n * @title Test Contract Wrapper for MerkleCollectionCollateralFilter\\n * @author MetaStreet Labs\\n */\\ncontract TestMerkleCollectionCollateralFilter is MerkleCollectionCollateralFilter {\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    constructor(address token, bytes32 root, uint32 nodeCount, string memory metadataURI) {\\n        _initialize(token, root, nodeCount, metadataURI);\\n    }\\n\\n    /**************************************************************************/\\n    /* Wrapper for Primary API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @dev External wrapper function for _collateralSupported\\n     */\\n    function collateralSupported(\\n        address token,\\n        uint256 tokenId,\\n        uint256 index,\\n        bytes calldata context\\n    ) external view returns (bool) {\\n        return _collateralSupported(token, tokenId, index, context);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/filters/TestRangedCollectionCollateralFilter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../../filters/RangedCollectionCollateralFilter.sol\\\";\\n\\n/**\\n * @title Test Contract Wrapper for RangedCollectionCollateralFilter\\n * @author MetaStreet Labs\\n */\\ncontract TestRangedCollectionCollateralFilter is RangedCollectionCollateralFilter {\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    constructor(address token, uint256 startTokenId, uint256 endTokenId) {\\n        _initialize(token, startTokenId, endTokenId);\\n    }\\n\\n    /**************************************************************************/\\n    /* Wrapper for Primary API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @dev External wrapper function for _collateralSupported\\n     */\\n    function collateralSupported(\\n        address token,\\n        uint256 tokenId,\\n        uint256 index,\\n        bytes calldata context\\n    ) external view returns (bool) {\\n        return _collateralSupported(token, tokenId, index, context);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/filters/TestSetCollectionCollateralFilter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../../filters/SetCollectionCollateralFilter.sol\\\";\\n\\n/**\\n * @title Test Contract Wrapper for SetCollectionCollateralFilter\\n * @author MetaStreet Labs\\n */\\ncontract TestSetCollectionCollateralFilter is SetCollectionCollateralFilter {\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    constructor(address token, uint256[] memory tokenIds) {\\n        _initialize(token, tokenIds);\\n    }\\n\\n    /**************************************************************************/\\n    /* Wrapper for Primary API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @dev External wrapper function for _collateralSupported\\n     */\\n    function collateralSupported(\\n        address token,\\n        uint256 tokenId,\\n        uint256 index,\\n        bytes calldata context\\n    ) external view returns (bool) {\\n        return _collateralSupported(token, tokenId, index, context);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/integrations/DelegateCash/TestDelegationRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.19;\\n\\nimport \\\"../../../integrations/DelegateCash/IDelegationRegistry.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @title Test DelegationRegistry\\n */\\ncontract TestDelegationRegistry is IDelegationRegistry, ERC165 {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n    /// @notice The global mapping and single source of truth for delegations\\n    /// @dev vault -> vaultVersion -> delegationHash\\n    mapping(address => mapping(uint256 => EnumerableSet.Bytes32Set)) internal delegations;\\n\\n    /// @notice A mapping of wallets to versions (for cheap revocation)\\n    mapping(address => uint256) internal vaultVersion;\\n\\n    /// @notice A mapping of wallets to delegates to versions (for cheap revocation)\\n    mapping(address => mapping(address => uint256)) internal delegateVersion;\\n\\n    /// @notice A secondary mapping to return onchain enumerability of delegations that a given address can perform\\n    /// @dev delegate -> delegationHashes\\n    mapping(address => EnumerableSet.Bytes32Set) internal delegationHashes;\\n\\n    /// @notice A secondary mapping used to return delegation information about a delegation\\n    /// @dev delegationHash -> DelegateInfo\\n    mapping(bytes32 => IDelegationRegistry.DelegationInfo) internal delegationInfo;\\n\\n    /**\\n     * @inheritdoc ERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165) returns (bool) {\\n        return interfaceId == type(IDelegationRegistry).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * -----------  WRITE -----------\\n     */\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function delegateForAll(address delegate, bool value) external override {\\n        bytes32 delegationHash = _computeAllDelegationHash(msg.sender, delegate);\\n        _setDelegationValues(\\n            delegate,\\n            delegationHash,\\n            value,\\n            IDelegationRegistry.DelegationType.ALL,\\n            msg.sender,\\n            address(0),\\n            0\\n        );\\n        emit IDelegationRegistry.DelegateForAll(msg.sender, delegate, value);\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function delegateForContract(address delegate, address contract_, bool value) external override {\\n        bytes32 delegationHash = _computeContractDelegationHash(msg.sender, delegate, contract_);\\n        _setDelegationValues(\\n            delegate,\\n            delegationHash,\\n            value,\\n            IDelegationRegistry.DelegationType.CONTRACT,\\n            msg.sender,\\n            contract_,\\n            0\\n        );\\n        emit IDelegationRegistry.DelegateForContract(msg.sender, delegate, contract_, value);\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function delegateForToken(address delegate, address contract_, uint256 tokenId, bool value) external override {\\n        bytes32 delegationHash = _computeTokenDelegationHash(msg.sender, delegate, contract_, tokenId);\\n        _setDelegationValues(\\n            delegate,\\n            delegationHash,\\n            value,\\n            IDelegationRegistry.DelegationType.TOKEN,\\n            msg.sender,\\n            contract_,\\n            tokenId\\n        );\\n        emit IDelegationRegistry.DelegateForToken(msg.sender, delegate, contract_, tokenId, value);\\n    }\\n\\n    /**\\n     * @dev Helper function to set all delegation values and enumeration sets\\n     */\\n    function _setDelegationValues(\\n        address delegate,\\n        bytes32 delegateHash,\\n        bool value,\\n        IDelegationRegistry.DelegationType type_,\\n        address vault,\\n        address contract_,\\n        uint256 tokenId\\n    ) internal {\\n        if (value) {\\n            delegations[vault][vaultVersion[vault]].add(delegateHash);\\n            delegationHashes[delegate].add(delegateHash);\\n            delegationInfo[delegateHash] = DelegationInfo({\\n                vault: vault,\\n                delegate: delegate,\\n                type_: type_,\\n                contract_: contract_,\\n                tokenId: tokenId\\n            });\\n        } else {\\n            delegations[vault][vaultVersion[vault]].remove(delegateHash);\\n            delegationHashes[delegate].remove(delegateHash);\\n            delete delegationInfo[delegateHash];\\n        }\\n    }\\n\\n    /**\\n     * @dev Helper function to compute delegation hash for wallet delegation\\n     */\\n    function _computeAllDelegationHash(address vault, address delegate) internal view returns (bytes32) {\\n        uint256 vaultVersion_ = vaultVersion[vault];\\n        uint256 delegateVersion_ = delegateVersion[vault][delegate];\\n        return keccak256(abi.encode(delegate, vault, vaultVersion_, delegateVersion_));\\n    }\\n\\n    /**\\n     * @dev Helper function to compute delegation hash for contract delegation\\n     */\\n    function _computeContractDelegationHash(\\n        address vault,\\n        address delegate,\\n        address contract_\\n    ) internal view returns (bytes32) {\\n        uint256 vaultVersion_ = vaultVersion[vault];\\n        uint256 delegateVersion_ = delegateVersion[vault][delegate];\\n        return keccak256(abi.encode(delegate, vault, contract_, vaultVersion_, delegateVersion_));\\n    }\\n\\n    /**\\n     * @dev Helper function to compute delegation hash for token delegation\\n     */\\n    function _computeTokenDelegationHash(\\n        address vault,\\n        address delegate,\\n        address contract_,\\n        uint256 tokenId\\n    ) internal view returns (bytes32) {\\n        uint256 vaultVersion_ = vaultVersion[vault];\\n        uint256 delegateVersion_ = delegateVersion[vault][delegate];\\n        return keccak256(abi.encode(delegate, vault, contract_, tokenId, vaultVersion_, delegateVersion_));\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function revokeAllDelegates() external override {\\n        ++vaultVersion[msg.sender];\\n        emit IDelegationRegistry.RevokeAllDelegates(msg.sender);\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function revokeDelegate(address delegate) external override {\\n        _revokeDelegate(delegate, msg.sender);\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function revokeSelf(address vault) external override {\\n        _revokeDelegate(msg.sender, vault);\\n    }\\n\\n    /**\\n     * @dev Revoke the `delegate` hotwallet from the `vault` coldwallet.\\n     */\\n    function _revokeDelegate(address delegate, address vault) internal {\\n        ++delegateVersion[vault][delegate];\\n        // For enumerations, filter in the view functions\\n        emit IDelegationRegistry.RevokeDelegate(vault, msg.sender);\\n    }\\n\\n    /**\\n     * -----------  READ -----------\\n     */\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function getDelegationsByDelegate(\\n        address delegate\\n    ) external view returns (IDelegationRegistry.DelegationInfo[] memory info) {\\n        EnumerableSet.Bytes32Set storage potentialDelegationHashes = delegationHashes[delegate];\\n        uint256 potentialDelegationHashesLength = potentialDelegationHashes.length();\\n        uint256 delegationCount = 0;\\n        info = new IDelegationRegistry.DelegationInfo[](potentialDelegationHashesLength);\\n        for (uint256 i = 0; i < potentialDelegationHashesLength; ) {\\n            bytes32 delegateHash = potentialDelegationHashes.at(i);\\n            IDelegationRegistry.DelegationInfo memory delegationInfo_ = delegationInfo[delegateHash];\\n            address vault = delegationInfo_.vault;\\n            IDelegationRegistry.DelegationType type_ = delegationInfo_.type_;\\n            bool valid = false;\\n            if (type_ == IDelegationRegistry.DelegationType.ALL) {\\n                if (delegateHash == _computeAllDelegationHash(vault, delegate)) {\\n                    valid = true;\\n                }\\n            } else if (type_ == IDelegationRegistry.DelegationType.CONTRACT) {\\n                if (delegateHash == _computeContractDelegationHash(vault, delegate, delegationInfo_.contract_)) {\\n                    valid = true;\\n                }\\n            } else if (type_ == IDelegationRegistry.DelegationType.TOKEN) {\\n                if (\\n                    delegateHash ==\\n                    _computeTokenDelegationHash(vault, delegate, delegationInfo_.contract_, delegationInfo_.tokenId)\\n                ) {\\n                    valid = true;\\n                }\\n            }\\n            if (valid) {\\n                info[delegationCount++] = delegationInfo_;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        if (potentialDelegationHashesLength > delegationCount) {\\n            assembly {\\n                let decrease := sub(potentialDelegationHashesLength, delegationCount)\\n                mstore(info, sub(mload(info), decrease))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function getDelegatesForAll(address vault) external view returns (address[] memory delegates) {\\n        return _getDelegatesForLevel(vault, IDelegationRegistry.DelegationType.ALL, address(0), 0);\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function getDelegatesForContract(\\n        address vault,\\n        address contract_\\n    ) external view override returns (address[] memory delegates) {\\n        return _getDelegatesForLevel(vault, IDelegationRegistry.DelegationType.CONTRACT, contract_, 0);\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function getDelegatesForToken(\\n        address vault,\\n        address contract_,\\n        uint256 tokenId\\n    ) external view override returns (address[] memory delegates) {\\n        return _getDelegatesForLevel(vault, IDelegationRegistry.DelegationType.TOKEN, contract_, tokenId);\\n    }\\n\\n    function _getDelegatesForLevel(\\n        address vault,\\n        IDelegationRegistry.DelegationType delegationType,\\n        address contract_,\\n        uint256 tokenId\\n    ) internal view returns (address[] memory delegates) {\\n        EnumerableSet.Bytes32Set storage delegationHashes_ = delegations[vault][vaultVersion[vault]];\\n        uint256 potentialDelegatesLength = delegationHashes_.length();\\n        uint256 delegatesCount = 0;\\n        delegates = new address[](potentialDelegatesLength);\\n        for (uint256 i = 0; i < potentialDelegatesLength; ) {\\n            bytes32 delegationHash = delegationHashes_.at(i);\\n            DelegationInfo storage delegationInfo_ = delegationInfo[delegationHash];\\n            if (delegationInfo_.type_ == delegationType) {\\n                if (delegationType == IDelegationRegistry.DelegationType.ALL) {\\n                    // check delegate version by validating the hash\\n                    if (delegationHash == _computeAllDelegationHash(vault, delegationInfo_.delegate)) {\\n                        delegates[delegatesCount++] = delegationInfo_.delegate;\\n                    }\\n                } else if (delegationType == IDelegationRegistry.DelegationType.CONTRACT) {\\n                    if (delegationInfo_.contract_ == contract_) {\\n                        // check delegate version by validating the hash\\n                        if (\\n                            delegationHash == _computeContractDelegationHash(vault, delegationInfo_.delegate, contract_)\\n                        ) {\\n                            delegates[delegatesCount++] = delegationInfo_.delegate;\\n                        }\\n                    }\\n                } else if (delegationType == IDelegationRegistry.DelegationType.TOKEN) {\\n                    if (delegationInfo_.contract_ == contract_ && delegationInfo_.tokenId == tokenId) {\\n                        // check delegate version by validating the hash\\n                        if (\\n                            delegationHash ==\\n                            _computeTokenDelegationHash(vault, delegationInfo_.delegate, contract_, tokenId)\\n                        ) {\\n                            delegates[delegatesCount++] = delegationInfo_.delegate;\\n                        }\\n                    }\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        if (potentialDelegatesLength > delegatesCount) {\\n            assembly {\\n                let decrease := sub(potentialDelegatesLength, delegatesCount)\\n                mstore(delegates, sub(mload(delegates), decrease))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function getContractLevelDelegations(\\n        address vault\\n    ) external view returns (IDelegationRegistry.ContractDelegation[] memory contractDelegations) {\\n        EnumerableSet.Bytes32Set storage delegationHashes_ = delegations[vault][vaultVersion[vault]];\\n        uint256 potentialLength = delegationHashes_.length();\\n        uint256 delegationCount = 0;\\n        contractDelegations = new IDelegationRegistry.ContractDelegation[](potentialLength);\\n        for (uint256 i = 0; i < potentialLength; ) {\\n            bytes32 delegationHash = delegationHashes_.at(i);\\n            DelegationInfo storage delegationInfo_ = delegationInfo[delegationHash];\\n            if (delegationInfo_.type_ == IDelegationRegistry.DelegationType.CONTRACT) {\\n                // check delegate version by validating the hash\\n                if (\\n                    delegationHash ==\\n                    _computeContractDelegationHash(vault, delegationInfo_.delegate, delegationInfo_.contract_)\\n                ) {\\n                    contractDelegations[delegationCount++] = IDelegationRegistry.ContractDelegation({\\n                        contract_: delegationInfo_.contract_,\\n                        delegate: delegationInfo_.delegate\\n                    });\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        if (potentialLength > delegationCount) {\\n            assembly {\\n                let decrease := sub(potentialLength, delegationCount)\\n                mstore(contractDelegations, sub(mload(contractDelegations), decrease))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function getTokenLevelDelegations(\\n        address vault\\n    ) external view returns (IDelegationRegistry.TokenDelegation[] memory tokenDelegations) {\\n        EnumerableSet.Bytes32Set storage delegationHashes_ = delegations[vault][vaultVersion[vault]];\\n        uint256 potentialLength = delegationHashes_.length();\\n        uint256 delegationCount = 0;\\n        tokenDelegations = new IDelegationRegistry.TokenDelegation[](potentialLength);\\n        for (uint256 i = 0; i < potentialLength; ) {\\n            bytes32 delegationHash = delegationHashes_.at(i);\\n            DelegationInfo storage delegationInfo_ = delegationInfo[delegationHash];\\n            if (delegationInfo_.type_ == IDelegationRegistry.DelegationType.TOKEN) {\\n                // check delegate version by validating the hash\\n                if (\\n                    delegationHash ==\\n                    _computeTokenDelegationHash(\\n                        vault,\\n                        delegationInfo_.delegate,\\n                        delegationInfo_.contract_,\\n                        delegationInfo_.tokenId\\n                    )\\n                ) {\\n                    tokenDelegations[delegationCount++] = IDelegationRegistry.TokenDelegation({\\n                        contract_: delegationInfo_.contract_,\\n                        tokenId: delegationInfo_.tokenId,\\n                        delegate: delegationInfo_.delegate\\n                    });\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        if (potentialLength > delegationCount) {\\n            assembly {\\n                let decrease := sub(potentialLength, delegationCount)\\n                mstore(tokenDelegations, sub(mload(tokenDelegations), decrease))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function checkDelegateForAll(address delegate, address vault) public view override returns (bool) {\\n        bytes32 delegateHash = keccak256(\\n            abi.encode(delegate, vault, vaultVersion[vault], delegateVersion[vault][delegate])\\n        );\\n        return delegations[vault][vaultVersion[vault]].contains(delegateHash);\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function checkDelegateForContract(\\n        address delegate,\\n        address vault,\\n        address contract_\\n    ) public view override returns (bool) {\\n        bytes32 delegateHash = keccak256(\\n            abi.encode(delegate, vault, contract_, vaultVersion[vault], delegateVersion[vault][delegate])\\n        );\\n        return\\n            delegations[vault][vaultVersion[vault]].contains(delegateHash)\\n                ? true\\n                : checkDelegateForAll(delegate, vault);\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function checkDelegateForToken(\\n        address delegate,\\n        address vault,\\n        address contract_,\\n        uint256 tokenId\\n    ) public view override returns (bool) {\\n        bytes32 delegateHash = keccak256(\\n            abi.encode(delegate, vault, contract_, tokenId, vaultVersion[vault], delegateVersion[vault][delegate])\\n        );\\n        return\\n            delegations[vault][vaultVersion[vault]].contains(delegateHash)\\n                ? true\\n                : checkDelegateForContract(delegate, vault, contract_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/rates/TestWeightedInterestRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../../rates/WeightedInterestRateModel.sol\\\";\\n\\n/**\\n * @title Test Contract Wrapper for WeightedInterestRateModel\\n * @author MetaStreet Labs\\n */\\ncontract TestWeightedInterestRateModel is WeightedInterestRateModel {\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    constructor(WeightedInterestRateModel.Parameters memory parameters) WeightedInterestRateModel(parameters) {}\\n\\n    /**************************************************************************/\\n    /* Wrapper for Primary API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @dev External wrapper function for _rate()\\n     */\\n    function rate(\\n        uint256 amount,\\n        uint64[] memory rates,\\n        LiquidityLogic.NodeSource[] memory nodes,\\n        uint16 count\\n    ) external pure returns (uint256) {\\n        return _rate(amount, rates, nodes, count);\\n    }\\n\\n    /**\\n     * @dev External wrapper function for _distribute()\\n     */\\n    function distribute(\\n        uint256 amount,\\n        uint256 interest,\\n        LiquidityLogic.NodeSource[] memory nodes,\\n        uint16 count\\n    ) external view returns (uint128[] memory) {\\n        _distribute(amount, interest, nodes, count);\\n\\n        uint128[] memory pending = new uint128[](count);\\n        for (uint256 i; i < count; i++) {\\n            pending[i] = nodes[i].pending;\\n        }\\n        return pending;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/TestCollateralLiquidatorJig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\\\";\\n\\nimport \\\"../LoanReceipt.sol\\\";\\n\\nimport \\\"../interfaces/ICollateralLiquidator.sol\\\";\\nimport \\\"../interfaces/ICollateralLiquidationReceiver.sol\\\";\\n\\n/**\\n * @title Testing Jig for Collateral Liquidators\\n * @author MetaStreet Labs\\n */\\ncontract TestCollateralLiquidatorJig is ERC165, ERC721Holder, ICollateralLiquidationReceiver {\\n    using SafeERC20 for IERC20;\\n\\n    /**************************************************************************/\\n    /* Errors */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Force a revert\\n     */\\n    error ForceRevert();\\n\\n    /**************************************************************************/\\n    /* Events */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Emitted when loan collateral is liquidated\\n     * @param proceeds Liquidation proceeds in currency tokens\\n     */\\n    event CollateralLiquidated(uint256 proceeds);\\n\\n    /**************************************************************************/\\n    /* State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @dev Currency token\\n     */\\n    IERC20 private _currencyToken;\\n\\n    /**\\n     * @dev Collateral liquidator instance\\n     */\\n    address private _collateralLiquidator;\\n\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice TestLiquidator\\n     */\\n    constructor(IERC20 currencyToken_, address collateralLiquidator_) {\\n        _currencyToken = currencyToken_;\\n        _collateralLiquidator = collateralLiquidator_;\\n    }\\n\\n    /**************************************************************************/\\n    /* Getters */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Get currency token\\n     * @return Currency token contract\\n     */\\n    function currencyToken() external view returns (address) {\\n        return address(_currencyToken);\\n    }\\n\\n    /**\\n     * @notice Get collateral liquidator\\n     * @return Collateral liquidator contract\\n     */\\n    function collateralLiquidator() external view returns (address) {\\n        return address(_collateralLiquidator);\\n    }\\n\\n    /**************************************************************************/\\n    /* Methods */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Liquidate collateral with liquidator\\n     * @param encodedLoanReceipt Encoded loan receipt\\n     */\\n    function liquidate(bytes calldata encodedLoanReceipt) external {\\n        LoanReceipt.LoanReceiptV2 memory loanReceipt = LoanReceipt.decode(encodedLoanReceipt);\\n\\n        IERC721(loanReceipt.collateralToken).approve(_collateralLiquidator, loanReceipt.collateralTokenId);\\n\\n        /* Start liquidation with collateral liquidator */\\n        ICollateralLiquidator(_collateralLiquidator).liquidate(\\n            address(_currencyToken),\\n            loanReceipt.collateralToken,\\n            loanReceipt.collateralTokenId,\\n            loanReceipt.collateralWrapperContext,\\n            encodedLoanReceipt\\n        );\\n    }\\n\\n    /**\\n     * @notice Callback on loan collateral liquidated\\n     * @param loanReceipt Loan receipt\\n     * @param proceeds Liquidation proceeds in currency tokens\\n     */\\n    function onCollateralLiquidated(bytes calldata loanReceipt, uint256 proceeds) external {\\n        LoanReceipt.LoanReceiptV2 memory decodedLoanReceipt = LoanReceipt.decode(loanReceipt);\\n\\n        /* Force a revert to test try...catch in English Auction */\\n        if (decodedLoanReceipt.collateralTokenId == 130) {\\n            revert ForceRevert();\\n        }\\n\\n        emit CollateralLiquidated(proceeds);\\n    }\\n\\n    /******************************************************/\\n    /* ERC165 interface */\\n    /******************************************************/\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\\n        return interfaceId == type(ICollateralLiquidationReceiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/TestCollateralLiquidatorJigTruncated.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\\\";\\n\\nimport \\\"../LoanReceipt.sol\\\";\\n\\nimport \\\"../interfaces/ICollateralLiquidator.sol\\\";\\n\\n/**\\n * @title Truncated Testing Jig for Collateral Liquidators\\n * @author MetaStreet Labs\\n */\\ncontract TestCollateralLiquidatorJigTruncated is ERC721Holder {\\n    using SafeERC20 for IERC20;\\n\\n    /**************************************************************************/\\n    /* Events */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Emitted when loan collateral is liquidated\\n     * @param proceeds Liquidation proceeds in currency tokens\\n     */\\n    event CollateralLiquidated(uint256 proceeds);\\n\\n    /**************************************************************************/\\n    /* State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @dev Currency token\\n     */\\n    IERC20 private _currencyToken;\\n\\n    /**\\n     * @dev Collateral liquidator instance\\n     */\\n    address private _collateralLiquidator;\\n\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice TestLiquidator\\n     */\\n    constructor(IERC20 currencyToken_, address collateralLiquidator_) {\\n        _currencyToken = currencyToken_;\\n        _collateralLiquidator = collateralLiquidator_;\\n    }\\n\\n    /**************************************************************************/\\n    /* Getters */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Get currency token\\n     * @return Currency token contract\\n     */\\n    function currencyToken() external view returns (address) {\\n        return address(_currencyToken);\\n    }\\n\\n    /**\\n     * @notice Get collateral liquidator\\n     * @return Collateral liquidator contract\\n     */\\n    function collateralLiquidator() external view returns (address) {\\n        return address(_collateralLiquidator);\\n    }\\n\\n    /**************************************************************************/\\n    /* Methods */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Liquidate collateral with liquidator\\n     * @param encodedLoanReceipt Encoded loan receipt\\n     */\\n    function liquidate(bytes calldata encodedLoanReceipt) external {\\n        LoanReceipt.LoanReceiptV2 memory loanReceipt = LoanReceipt.decode(encodedLoanReceipt);\\n\\n        IERC721(loanReceipt.collateralToken).approve(_collateralLiquidator, loanReceipt.collateralTokenId);\\n\\n        /* Start liquidation with collateral liquidator */\\n        ICollateralLiquidator(_collateralLiquidator).liquidate(\\n            address(_currencyToken),\\n            loanReceipt.collateralToken,\\n            loanReceipt.collateralTokenId,\\n            loanReceipt.collateralWrapperContext,\\n            encodedLoanReceipt\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/TestLiquidityLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../interfaces/ILiquidity.sol\\\";\\nimport \\\"../LiquidityLogic.sol\\\";\\n\\n/**\\n * @title Test Contract Wrapper for LiquidityLogic\\n * @author MetaStreet Labs\\n */\\ncontract TestLiquidityLogic is ILiquidity {\\n    using LiquidityLogic for LiquidityLogic.Liquidity;\\n\\n    /**************************************************************************/\\n    /* Events */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Emitted with return value from deposit()\\n     * @param shares Shares created\\n     */\\n    event Deposited(uint128 shares);\\n\\n    /**\\n     * @notice Emitted with return values from redeem()\\n     * @param index Redemption index\\n     * @param target Redemption target\\n     */\\n    event RedemptionTarget(uint128 index, uint128 target);\\n\\n    /**************************************************************************/\\n    /* State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Liquidity\\n     */\\n    LiquidityLogic.Liquidity internal _liquidity;\\n\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    constructor() {\\n        _liquidity.initialize();\\n    }\\n\\n    /**************************************************************************/\\n    /* ILiquidity Getters */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc ILiquidity\\n     */\\n    function liquidityNodes(uint128 startTick, uint128 endTick) external view returns (ILiquidity.NodeInfo[] memory) {\\n        return _liquidity.liquidityNodes(startTick, endTick);\\n    }\\n\\n    /**\\n     * @inheritdoc ILiquidity\\n     */\\n    function liquidityNode(uint128 tick) external view returns (ILiquidity.NodeInfo memory) {\\n        return _liquidity.liquidityNode(tick);\\n    }\\n\\n    /**\\n     * @inheritdoc ILiquidity\\n     */\\n    function liquidityNodeWithAccrual(\\n        uint128 tick\\n    ) external view returns (ILiquidity.NodeInfo memory, ILiquidity.AccrualInfo memory) {\\n        return _liquidity.liquidityNodeWithAccrual(tick);\\n    }\\n\\n    /**\\n     * @inheritdoc ILiquidity\\n     */\\n    function depositSharePrice(uint128 tick) external view returns (uint256) {\\n        return _liquidity.depositSharePrice(tick);\\n    }\\n\\n    /**\\n     * @inheritdoc ILiquidity\\n     */\\n    function redemptionSharePrice(uint128 tick) external view returns (uint256) {\\n        return _liquidity.redemptionSharePrice(tick);\\n    }\\n\\n    /**************************************************************************/\\n    /* Wrapper for Primary API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @dev External wrapper function for LiquidityLogic.redemptionAvailable()\\n     */\\n    function redemptionAvailable(\\n        uint128 tick,\\n        uint128 pending,\\n        uint128 index,\\n        uint128 target\\n    ) external view returns (uint128 shares, uint128 amount) {\\n        (shares, amount, , ) = _liquidity.redemptionAvailable(tick, pending, index, target);\\n    }\\n\\n    /**\\n     * @dev External wrapper function for LiquidityLogic._instantiate()\\n     */\\n    function instantiate(uint128 tick) external {\\n        return _liquidity._instantiate(_liquidity.nodes[tick], tick);\\n    }\\n\\n    /**\\n     * @dev External wrapper function for LiquidityLogic.deposit()\\n     */\\n    function deposit(uint128 tick, uint128 amount) external returns (uint256) {\\n        uint128 shares = _liquidity.deposit(tick, amount);\\n        emit Deposited(shares);\\n        return shares;\\n    }\\n\\n    /**\\n     * @dev External wrapper function for LiquidityLogic.use()\\n     */\\n    function use(uint128 tick, uint128 amount, uint128 pending, uint64 duration) external {\\n        _liquidity.use(tick, amount, pending, duration);\\n    }\\n\\n    /**\\n     * @dev External wrapper function for LiquidityLogic.restore()\\n     */\\n    function restore(\\n        uint128 tick,\\n        uint128 used,\\n        uint128 pending,\\n        uint128 restored,\\n        uint64 duration,\\n        uint64 elapsed\\n    ) external {\\n        _liquidity.restore(tick, used, pending, restored, duration, elapsed);\\n    }\\n\\n    /**\\n     * @dev External wrapper function for LiquidityLogic.redeem()\\n     */\\n    function redeem(uint128 tick, uint128 shares) external returns (uint128, uint128) {\\n        (uint128 index, uint128 target) = _liquidity.redeem(tick, shares);\\n        emit RedemptionTarget(index, target);\\n        return (index, target);\\n    }\\n\\n    /**\\n     * @dev External wrapper function for LiquidityLogic.source()\\n     */\\n    function source(\\n        uint256 amount,\\n        uint128[] calldata ticks,\\n        uint256 multiplier,\\n        uint256 durationIndex\\n    ) external view returns (LiquidityLogic.NodeSource[] memory, uint16 count) {\\n        return _liquidity.source(amount, ticks, multiplier, durationIndex);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/TestLoanReceipt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../interfaces/ILiquidity.sol\\\";\\n\\nimport \\\"../LoanReceipt.sol\\\";\\n\\n/**\\n * @title Test Contract Wrapper for LoanReceipt Library\\n * @author MetaStreet Labs\\n */\\ncontract TestLoanReceipt {\\n    /**\\n     * @dev External wrapper function for LoanReceipt.hash()\\n     */\\n    function hash(bytes calldata encodedReceipt) external view returns (bytes32) {\\n        return LoanReceipt.hash(encodedReceipt);\\n    }\\n\\n    /**\\n     * @dev External wrapper function for LoanReceipt.encode()\\n     */\\n    function encode(LoanReceipt.LoanReceiptV2 memory receipt) external pure returns (bytes memory) {\\n        return LoanReceipt.encode(receipt);\\n    }\\n\\n    /**\\n     * @dev External wrapper function for LoanReceipt.decode()\\n     */\\n    function decode(bytes calldata encodedReceipt) external pure returns (LoanReceipt.LoanReceiptV2 memory) {\\n        return LoanReceipt.decode(encodedReceipt);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/TestProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/proxy/Proxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @title Test proxy for peripheral contracts\\n * @author MetaStreet Labs\\n */\\ncontract TestProxy is Proxy {\\n    /**\\n     * @dev Space for implementation storage\\n     */\\n    uint256[128] private __reserved;\\n\\n    /**\\n     * @dev Implementation contract\\n     */\\n    address private _impl;\\n\\n    /**\\n     * @notice TestProxy constructor\\n     * @param implementation Implementation contract\\n     * @param data Initialization calldata\\n     */\\n    constructor(address implementation, bytes memory data) {\\n        _impl = implementation;\\n        Address.functionDelegateCall(implementation, data);\\n    }\\n\\n    /*\\n     * @dev Proxy implementation address hook\\n     */\\n    function _implementation() internal view virtual override returns (address) {\\n        return _impl;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/TestTick.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../Tick.sol\\\";\\n\\n/**\\n * @title Test Contract Wrapper for Tick Library\\n * @author MetaStreet Labs\\n */\\ncontract TestTick {\\n    /**\\n     * @dev External wrapper function for Tick.decode()\\n     */\\n    function decode(\\n        uint128 tick\\n    ) external pure returns (uint256 limit, uint256 duration, uint256 rate, uint256 reserved) {\\n        return Tick.decode(tick);\\n    }\\n\\n    /**\\n     * @dev External wrapper function for Tick.validate()\\n     */\\n    function validate(uint128 tick, uint256 minLimit, uint256 minDurationIndex) external pure returns (uint256) {\\n        return Tick.validate(tick, minLimit, minDurationIndex);\\n    }\\n\\n    /**\\n     * @dev External wrapper function for Tick.validate()\\n     */\\n    function validate(\\n        uint128 tick,\\n        uint256 minLimit,\\n        uint256 minDurationIndex,\\n        uint256 maxDurationIndex,\\n        uint256 minRateIndex,\\n        uint256 maxRateIndex\\n    ) external pure {\\n        return Tick.validate(tick, minLimit, minDurationIndex, maxDurationIndex, minRateIndex, maxRateIndex);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/tokens/TestERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title Test ERC1155 Token\\n */\\ncontract TestERC1155 is ERC1155, Ownable {\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice TestERC1155 constructor\\n     * @notice name Token name\\n     * @notice symbol Token symbol\\n     * @notice baseURI Token base URI\\n     */\\n    constructor(string memory uri) ERC1155(uri) {}\\n\\n    /**************************************************************************/\\n    /* Privileged API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Set token URI\\n     * @param uri Token URI\\n     */\\n    function setURI(string memory uri) external onlyOwner {\\n        _setURI(uri);\\n    }\\n\\n    /**\\n     * @notice Mint tokens to account\\n     * @param to Recipient account\\n     * @param tokenId Token ID\\n     * @param amount Amount\\n     * @param data Data\\n     */\\n    function mint(address to, uint256 tokenId, uint256 amount, bytes memory data) external virtual onlyOwner {\\n        _mint(to, tokenId, amount, data);\\n    }\\n\\n    /**\\n     * @notice Batch mint tokens to account\\n     * @param to Recipient account\\n     * @param tokenIds Token IDs\\n     * @param amounts Amounts\\n     * @param data Data\\n     */\\n    function mintBatch(\\n        address to,\\n        uint256[] memory tokenIds,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) external virtual onlyOwner {\\n        _mintBatch(to, tokenIds, amounts, data);\\n    }\\n\\n    /**\\n     * @notice Burn tokens\\n     * @param tokenId Token ID\\n     * @param amount Amount\\n     */\\n    function burn(uint256 tokenId, uint256 amount) external onlyOwner {\\n        _burn(msg.sender, tokenId, amount);\\n    }\\n\\n    /**\\n     * @notice Batch burn tokens\\n     * @param tokenIds Token ID\\n     * @param amounts Amount\\n     */\\n    function burnBatch(uint256[] memory tokenIds, uint256[] memory amounts) external onlyOwner {\\n        _burnBatch(msg.sender, tokenIds, amounts);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/tokens/TestERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/presets/ERC20PresetFixedSupply.sol\\\";\\n\\n/**\\n * @title Test ERC20 Token\\n */\\ncontract TestERC20 is ERC20PresetFixedSupply {\\n    /**************************************************************************/\\n    /* Properties */\\n    /**************************************************************************/\\n\\n    uint8 private _decimals;\\n\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice TestERC20 constructor\\n     * @notice name Token name\\n     * @notice symbol Token symbol\\n     * @notice decimals Token decimals\\n     * @notice initialSupply Initial supply\\n     */\\n    constructor(\\n        string memory name,\\n        string memory symbol,\\n        uint8 decimals_,\\n        uint256 initialSupply\\n    ) ERC20PresetFixedSupply(name, symbol, initialSupply, msg.sender) {\\n        _decimals = decimals_;\\n    }\\n\\n    /**************************************************************************/\\n    /* Overrides */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc ERC20\\n     */\\n    function decimals() public view override returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/tokens/TestERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title Test ERC721 Token\\n */\\ncontract TestERC721 is ERC721, Ownable {\\n    /**************************************************************************/\\n    /* Properties */\\n    /**************************************************************************/\\n\\n    string private _baseTokenURI;\\n\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice TestERC721 constructor\\n     * @notice name Token name\\n     * @notice symbol Token symbol\\n     * @notice baseURI Token base URI\\n     */\\n    constructor(string memory name, string memory symbol, string memory baseURI) ERC721(name, symbol) {\\n        _baseTokenURI = baseURI;\\n    }\\n\\n    /**************************************************************************/\\n    /* Overrides */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc ERC721\\n     */\\n    function _baseURI() internal view virtual override returns (string memory) {\\n        return _baseTokenURI;\\n    }\\n\\n    /**************************************************************************/\\n    /* Privileged API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Set token base URI\\n     * @param baseURI Token base URI\\n     */\\n    function setBaseURI(string memory baseURI) external onlyOwner {\\n        _baseTokenURI = baseURI;\\n    }\\n\\n    /**\\n     * @notice Mint token to account\\n     * @param to Recipient account\\n     * @param tokenId Token ID\\n     */\\n    function mint(address to, uint256 tokenId) external virtual onlyOwner {\\n        _safeMint(to, tokenId);\\n    }\\n\\n    /**\\n     * @notice Burn token\\n     * @param tokenId Token ID\\n     */\\n    function burn(uint256 tokenId) external onlyOwner {\\n        _burn(tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/tokens/TestMaliciousERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\nimport \\\"../../Pool.sol\\\";\\n\\ncontract TestMaliciousERC20 {\\n    /**************************************************************************/\\n    /* Constants */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Fixed point scale\\n     */\\n    uint256 internal constant FIXED_POINT_SCALE = 1e18;\\n\\n    /**************************************************************************/\\n    /* State */\\n    /**************************************************************************/\\n    /**\\n     * @notice MetaStreet V2 Pool\\n     */\\n    Pool internal _pool;\\n\\n    /**\\n     * @notice Deposit tick\\n     */\\n    uint128 internal _tick;\\n\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    constructor(address pool_, uint128 tick_) {\\n        _pool = Pool(pool_);\\n        _tick = tick_;\\n    }\\n\\n    /**************************************************************************/\\n    /* IERC20 API */\\n    /**************************************************************************/\\n\\n    function transfer(address to, uint256 value) public returns (bool) {\\n        _pool.transfer(msg.sender, to, _tick, value);\\n\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Tick.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/**\\n * @title Tick\\n * @author MetaStreet Labs\\n */\\nlibrary Tick {\\n    /*\\n     * A tick encodes three conditions on liquidity: limit, duration, and rate.\\n     * Limit is the maximum depth that liquidity sourced from the node can be\\n     * used in. Duration is the maximum allowed duration for that liquidity.\\n     * Rate is the interest rate associated with that liquidity. Duration and\\n     * rates are encoded as indexes into predetermined, discrete tiers.\\n     *\\n     * +-----------------------------------------------------------------------+\\n     * |                                 128                                   |\\n     * +--------------------------------------|----------|----------|----------+\\n     * |                  120                 |    3     |     3    |     2    |\\n     * |                 Limit                | Dur. Idx | Rate Idx | Reserved |\\n     * +-----------------------------------------------------------------------+\\n     *\\n     * Duration Index is ordered from longest duration to shortest, e.g. 30\\n     * days, 14 days, 7 days.\\n     *\\n     * Rate Index is ordered from lowest rate to highest rate, e.g. 10%, 30%,\\n     * 50%.\\n     */\\n\\n    /**************************************************************************/\\n    /* Constants */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Tick limit mask\\n     */\\n    uint256 internal constant TICK_LIMIT_MASK = 0xffffffffffffffffffffffffffffff;\\n\\n    /**\\n     * @notice Tick limit shift\\n     */\\n    uint256 internal constant TICK_LIMIT_SHIFT = 8;\\n\\n    /**\\n     * @notice Tick duration index mask\\n     */\\n    uint256 internal constant TICK_DURATION_MASK = 0x7;\\n\\n    /**\\n     * @notice Tick duration index shift\\n     */\\n    uint256 internal constant TICK_DURATION_SHIFT = 5;\\n\\n    /**\\n     * @notice Tick rate index mask\\n     */\\n    uint256 internal constant TICK_RATE_MASK = 0x7;\\n\\n    /**\\n     * @notice Tick rate index shift\\n     */\\n    uint256 internal constant TICK_RATE_SHIFT = 2;\\n\\n    /**\\n     * @notice Tick reserved mask\\n     */\\n    uint256 internal constant TICK_RESERVED_MASK = 0x3;\\n\\n    /**\\n     * @notice Tick reserved shift\\n     */\\n    uint256 internal constant TICK_RESERVED_SHIFT = 0;\\n\\n    /**\\n     * @notice Maximum number of durations supported\\n     */\\n    uint256 internal constant MAX_NUM_DURATIONS = TICK_DURATION_MASK + 1;\\n\\n    /**\\n     * @notice Maximum number of rates supported\\n     */\\n    uint256 internal constant MAX_NUM_RATES = TICK_RATE_MASK + 1;\\n\\n    /**************************************************************************/\\n    /* Errors */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Invalid tick\\n     */\\n    error InvalidTick();\\n\\n    /**************************************************************************/\\n    /* Helper Functions */\\n    /**************************************************************************/\\n\\n    /**\\n     * @dev Decode a Tick\\n     * @param tick Tick\\n     * @return limit Limit field\\n     * @return duration Duration field\\n     * @return rate Rate field\\n     * @return reserved Reserved field\\n     */\\n    function decode(\\n        uint128 tick\\n    ) internal pure returns (uint256 limit, uint256 duration, uint256 rate, uint256 reserved) {\\n        limit = ((tick >> TICK_LIMIT_SHIFT) & TICK_LIMIT_MASK);\\n        duration = ((tick >> TICK_DURATION_SHIFT) & TICK_DURATION_MASK);\\n        rate = ((tick >> TICK_RATE_SHIFT) & TICK_RATE_MASK);\\n        reserved = ((tick >> TICK_RESERVED_SHIFT) & TICK_RESERVED_MASK);\\n    }\\n\\n    /**\\n     * @dev Validate a Tick (fast)\\n     * @param tick Tick\\n     * @param prevTick Previous tick\\n     * @param maxDurationIndex Maximum Duration Index (inclusive)\\n     * @return Limit field\\n     */\\n    function validate(uint128 tick, uint256 prevTick, uint256 maxDurationIndex) internal pure returns (uint256) {\\n        (uint256 limit, uint256 duration, , ) = decode(tick);\\n        if (tick <= prevTick) revert InvalidTick();\\n        if (duration > maxDurationIndex) revert InvalidTick();\\n        return limit;\\n    }\\n\\n    /**\\n     * @dev Validate a Tick (slow)\\n     * @param tick Tick\\n     * @param minLimit Minimum Limit (exclusive)\\n     * @param minDurationIndex Minimum Duration Index (inclusive)\\n     * @param maxDurationIndex Maximum Duration Index (inclusive)\\n     * @param minRateIndex Minimum Rate Index (inclusive)\\n     * @param maxRateIndex Maximum Rate Index (inclusive)\\n     */\\n    function validate(\\n        uint128 tick,\\n        uint256 minLimit,\\n        uint256 minDurationIndex,\\n        uint256 maxDurationIndex,\\n        uint256 minRateIndex,\\n        uint256 maxRateIndex\\n    ) internal pure {\\n        (uint256 limit, uint256 duration, uint256 rate, uint256 reserved) = decode(tick);\\n        if (limit <= minLimit) revert InvalidTick();\\n        if (duration < minDurationIndex) revert InvalidTick();\\n        if (duration > maxDurationIndex) revert InvalidTick();\\n        if (rate < minRateIndex) revert InvalidTick();\\n        if (rate > maxRateIndex) revert InvalidTick();\\n        if (reserved != 0) revert InvalidTick();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokenization/DepositToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Deposit Token API\\n * @author MetaStreet Labs\\n */\\nabstract contract DepositToken {\\n    /**************************************************************************/\\n    /* Events */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Emitted when deposit token created\\n     * @param instance Instance address\\n     * @param implementation Implementation address\\n     */\\n    event TokenCreated(address indexed instance, address indexed implementation);\\n\\n    /**************************************************************************/\\n    /* API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Get the deposit token address for tick\\n     *\\n     * @param tick Tick\\n     * @return Deposit token address\\n     */\\n    function depositToken(uint128 tick) public view virtual returns (address);\\n\\n    /**\\n     * @notice Hook called by Pool on token transfers\\n     *\\n     * @param from From\\n     * @param to To\\n     * @param tick Tick\\n     * @param shares Shares\\n     */\\n    function onExternalTransfer(address from, address to, uint128 tick, uint256 shares) internal virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/tokenization/ERC20DepositToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"./DepositToken.sol\\\";\\n\\nimport \\\"./ERC20DepositTokenFactory.sol\\\";\\nimport \\\"./ERC20DepositTokenImplementation.sol\\\";\\n\\n/**\\n * @title ERC20 Deposit Token\\n * @author MetaStreet Labs\\n */\\ncontract ERC20DepositToken is DepositToken {\\n    /**************************************************************************/\\n    /* Structures */\\n    /**************************************************************************/\\n\\n    /**\\n     * @custom:storage-location erc7201:erc20DepositToken.depositTokenStorage\\n     */\\n    struct DepositTokenStorage {\\n        /* Mapping of tick to token address */\\n        mapping(uint128 => address) tokens;\\n    }\\n\\n    /**************************************************************************/\\n    /* State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Current ERC20 deposit token implementation\\n     */\\n    address internal immutable _implementation;\\n\\n    /**\\n     * @notice Deposit token storage slot\\n     * @dev keccak256(abi.encode(uint256(keccak256(\\\"erc20DepositToken.depositTokenStorage\\\")) - 1)) & ~bytes32(uint256(0xff));\\n     */\\n    bytes32 private constant DEPOSIT_TOKEN_STORAGE_LOCATION =\\n        0xc61d9ab4916a5eab6b572dc8707662b99e55e17ecdc61af8ff79465ad64ded00;\\n\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice ERC20DepositToken constructor\\n     *\\n     * @param implementation_ ERC20 deposit token implementation address\\n     */\\n    constructor(address implementation_) {\\n        _implementation = implementation_;\\n    }\\n\\n    /**************************************************************************/\\n    /* Internal Helpers */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Get reference to ERC-7201 deposit token storage\\n     *\\n     * @return $ Reference to deposit token storage\\n     */\\n    function _getDepositTokenStorage() private pure returns (DepositTokenStorage storage $) {\\n        assembly {\\n            $.slot := DEPOSIT_TOKEN_STORAGE_LOCATION\\n        }\\n    }\\n\\n    /**************************************************************************/\\n    /* API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Get ERC20 Deposit Token implementation address\\n     *\\n     * @return ERC20 Deposit Token implementation address\\n     */\\n    function getERC20DepositTokenImplementation() external view returns (address) {\\n        return _implementation;\\n    }\\n\\n    /**\\n     * @notice Tokenize a tick\\n     *\\n     * @param tick Tick\\n     */\\n    function tokenize(uint128 tick) external returns (address) {\\n        /* Return token if it already exists */\\n        address tokenInstance = depositToken(tick);\\n        if (tokenInstance != address(0)) return tokenInstance;\\n\\n        /* Create proxied token */\\n        tokenInstance = ERC20DepositTokenFactory.deploy(tick);\\n\\n        /* Store token instance in mapping */\\n        _getDepositTokenStorage().tokens[tick] = tokenInstance;\\n\\n        emit TokenCreated(tokenInstance, _implementation);\\n\\n        return tokenInstance;\\n    }\\n\\n    /**\\n     * @inheritdoc DepositToken\\n     */\\n    function depositToken(uint128 tick) public view override returns (address) {\\n        return _getDepositTokenStorage().tokens[tick];\\n    }\\n\\n    /**\\n     * @inheritdoc DepositToken\\n     */\\n    function onExternalTransfer(address from, address to, uint128 tick, uint256 shares) internal override {\\n        /* No operation if token does not exist */\\n        if (depositToken(tick) == address(0)) return;\\n\\n        /* Call external transfer hook */\\n        ERC20DepositTokenImplementation(depositToken(tick)).onExternalTransfer(from, to, shares);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokenization/ERC20DepositTokenFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\n\\nimport \\\"./ERC20DepositTokenProxy.sol\\\";\\n\\n/**\\n * @title ERC20 Deposit Token Factory\\n * @author MetaStreet Labs\\n */\\nlibrary ERC20DepositTokenFactory {\\n    /**\\n     * @notice Deploy a proxied ERC20 deposit token\\n     * @param tick Tick\\n     * @return Proxy address\\n     */\\n    function deploy(uint128 tick) external returns (address) {\\n        /* Create init data */\\n        bytes memory initData = abi.encode(\\n            address(this),\\n            abi.encodeWithSignature(\\\"initialize(bytes)\\\", abi.encode(tick))\\n        );\\n\\n        /* Create token instance */\\n        return\\n            Create2.deploy(\\n                0,\\n                bytes32(uint256(tick)),\\n                abi.encodePacked(type(ERC20DepositTokenProxy).creationCode, initData)\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokenization/ERC20DepositTokenImplementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/IERC721Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\nimport \\\"../Pool.sol\\\";\\nimport \\\"../interfaces/ILiquidity.sol\\\";\\n\\n/**\\n * @title ERC20 Deposit Token Implementation\\n * @author MetaStreet Labs\\n */\\ncontract ERC20DepositTokenImplementation is IERC20Metadata {\\n    using Tick for uint128;\\n    using SafeCast for uint256;\\n\\n    /**************************************************************************/\\n    /* Errors */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice ERC20 Errors from OpenZeppelin implementation:\\n     *         https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.0.0/contracts/interfaces/draft-IERC6093.sol\\n     */\\n\\n    /**\\n     * @notice Insufficient balance\\n     *\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    /**\\n     * @notice Insufficient allowance\\n     *\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @notice Invalid spender\\n     *\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC20InvalidSpender(address sender);\\n\\n    /**\\n     * @notice Invalid Sender\\n     *\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC20InvalidSender(address sender);\\n\\n    /**\\n     * @notice Invalid Receiver\\n     *\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    /**\\n     * @notice Invalid caller\\n     */\\n    error InvalidCaller();\\n\\n    /**************************************************************************/\\n    /* Constants */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Implementation version\\n     */\\n    string public constant IMPLEMENTATION_VERSION = \\\"1.0\\\";\\n\\n    /**\\n     * @notice Fixed point scale\\n     */\\n    uint256 internal constant FIXED_POINT_SCALE = 1e18;\\n\\n    /**************************************************************************/\\n    /* State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Initialized boolean\\n     */\\n    bool internal _initialized;\\n\\n    /**\\n     * @notice MetaStreet V2 Pool\\n     */\\n    Pool internal _pool;\\n\\n    /**\\n     * @notice Deposit tick\\n     */\\n    uint128 internal _tick;\\n\\n    /**\\n     * @notice Owner => operator => allowance\\n     */\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice ERC20 Deposit Token Implementation constructor\\n     */\\n    constructor() {\\n        /* Disable initialization of implementation contract */\\n        _initialized = true;\\n    }\\n\\n    /**************************************************************************/\\n    /* Initializer */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Initializer\\n     * @param params ABI-encoded parameters\\n     */\\n    function initialize(bytes memory params) external {\\n        require(!_initialized, \\\"Already initialized\\\");\\n        _initialized = true;\\n\\n        /* Decode parameters */\\n        uint128 tick_ = abi.decode(params, (uint128));\\n\\n        _pool = Pool(msg.sender);\\n        _tick = tick_;\\n    }\\n\\n    /**************************************************************************/\\n    /* Internal Helpers */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Helper function to get rounded loan limit for name() and symbol()\\n     *\\n     * @dev Solely utilized to generate rounded number in name() and symbol() getters.\\n     *      Loan limits > 1 ETH are rounded to the nearest whole number. Under 1 ETH\\n     *      are rounded to the nearest hundredth place.\\n     *\\n     * @param loanLimit_ Loan limit as uint256\\n     *\\n     * @return Loan limit as string\\n     */\\n    function _getLoanLimit(uint256 loanLimit_) internal pure returns (string memory) {\\n        /* Handle loan limits > 1 ETH */\\n        if (loanLimit_ >= FIXED_POINT_SCALE) {\\n            return Strings.toString((loanLimit_ + (FIXED_POINT_SCALE / 2)) / FIXED_POINT_SCALE);\\n        } else {\\n            /* Handle loan limits < 1 ETH */\\n            uint256 scaledValue = loanLimit_ * 100;\\n            uint256 integer = scaledValue / FIXED_POINT_SCALE;\\n            if (scaledValue % FIXED_POINT_SCALE >= FIXED_POINT_SCALE / 2) {\\n                integer += 1;\\n            }\\n            uint256 hundredthPlaces = integer % 100;\\n            string memory decimalStr = hundredthPlaces < 10\\n                ? string.concat(\\\"0\\\", Strings.toString(hundredthPlaces))\\n                : Strings.toString(hundredthPlaces);\\n\\n            return string.concat(\\\"0.\\\", decimalStr);\\n        }\\n    }\\n\\n    /**************************************************************************/\\n    /* Getters */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc IERC20Metadata\\n     */\\n    function name() public view returns (string memory) {\\n        (uint256 limit_, , , ) = _tick.decode();\\n        return\\n            string.concat(\\n                \\\"MetaStreet V2 Deposit: \\\",\\n                IERC721Metadata(_pool.collateralToken()).symbol(),\\n                \\\"-\\\",\\n                IERC20Metadata(_pool.currencyToken()).symbol(),\\n                \\\":\\\",\\n                _getLoanLimit(limit_)\\n            );\\n    }\\n\\n    /**\\n     * @inheritdoc IERC20Metadata\\n     */\\n    function symbol() public view returns (string memory) {\\n        (uint256 limit_, , , ) = _tick.decode();\\n        return\\n            string.concat(\\n                \\\"m\\\",\\n                IERC20Metadata(_pool.currencyToken()).symbol(),\\n                \\\"-\\\",\\n                IERC721Metadata(_pool.collateralToken()).symbol(),\\n                \\\":\\\",\\n                _getLoanLimit(limit_)\\n            );\\n    }\\n\\n    /**\\n     * @inheritdoc IERC20Metadata\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @notice Pool\\n     * @return Pool address\\n     */\\n    function pool() external view returns (Pool) {\\n        return _pool;\\n    }\\n\\n    /**\\n     * @notice Tick\\n     * @return Encoded tick\\n     */\\n    function tick() external view returns (uint128) {\\n        return _tick;\\n    }\\n\\n    /**\\n     * @notice Tick loan limit\\n     * @return Loan limit in currency tokens\\n     */\\n    function limit() external view returns (uint128) {\\n        (uint256 limit_, , , ) = _tick.decode();\\n        return limit_.toUint128();\\n    }\\n\\n    /**\\n     * @notice Tick duration\\n     * @return Duration in seconds\\n     */\\n    function duration() external view returns (uint64) {\\n        (, uint256 durationIndex, , ) = _tick.decode();\\n        return _pool.durations()[durationIndex];\\n    }\\n\\n    /**\\n     * @notice Tick rate\\n     * @return Rate in interest per second\\n     */\\n    function rate() external view returns (uint64) {\\n        (, , uint256 rateIndex, ) = _tick.decode();\\n        return _pool.rates()[rateIndex];\\n    }\\n\\n    /**\\n     * @notice Currency token\\n     * @return Address of currency token\\n     */\\n    function currencyToken() external view returns (address) {\\n        return _pool.currencyToken();\\n    }\\n\\n    /**\\n     * @notice Deposit share price\\n     * @return Deposit share price\\n     */\\n    function depositSharePrice() external view returns (uint256) {\\n        return _pool.depositSharePrice(_tick);\\n    }\\n\\n    /**\\n     * @notice Redemption share price\\n     * @return Redemption share price\\n     */\\n    function redemptionSharePrice() external view returns (uint256) {\\n        return _pool.redemptionSharePrice(_tick);\\n    }\\n\\n    /**************************************************************************/\\n    /* Internal Helpers */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Helper function to transfer tokens\\n     *\\n     * @param from From\\n     * @param to To\\n     * @param value Value\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        /* No transfer to zero address */\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n\\n        /* Validate balance */\\n        uint256 fromBalance = balanceOf(from);\\n        if (fromBalance < value) {\\n            revert ERC20InsufficientBalance(from, fromBalance, value);\\n        }\\n\\n        /* Call transfer on pool */\\n        _pool.transfer(from, to, _tick, value);\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**************************************************************************/\\n    /* Hooks */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice External transfer hook\\n     *\\n     * @param from From\\n     * @param to To\\n     * @param value Value\\n     */\\n    function onExternalTransfer(address from, address to, uint256 value) external {\\n        if (msg.sender != address(_pool)) revert InvalidCaller();\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**************************************************************************/\\n    /* IERC20 API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc IERC20\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        /* Get Pool node */\\n        ILiquidity.NodeInfo memory node = _pool.liquidityNode(_tick);\\n\\n        /* Calculate total supply */\\n        return node.shares - node.redemptions;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC20\\n     */\\n    function balanceOf(address account) public view returns (uint256) {\\n        /* Get shares from deposits */\\n        (uint128 shares, ) = _pool.deposits(account, _tick);\\n\\n        return shares;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC20\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @inheritdoc IERC20\\n     */\\n    function approve(address spender, uint256 value) public returns (bool) {\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n\\n        _allowances[msg.sender][spender] = value;\\n\\n        emit Approval(msg.sender, spender, value);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC20\\n     */\\n    function transfer(address to, uint256 value) public returns (bool) {\\n        _transfer(msg.sender, to, value);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC20\\n     */\\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\\n        /* No transfer from zero address */\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n\\n        /* Check + update allowance */\\n        uint256 currentAllowance = allowance(from, msg.sender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(msg.sender, currentAllowance, value);\\n            }\\n            unchecked {\\n                _allowances[from][msg.sender] = currentAllowance - value;\\n            }\\n        }\\n\\n        _transfer(from, to, value);\\n\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokenization/ERC20DepositTokenProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/proxy/Proxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nimport \\\"./ERC20DepositToken.sol\\\";\\n\\n/**\\n * @title ERC20 Deposit Token Proxy\\n * @author MetaStreet Labs\\n */\\ncontract ERC20DepositTokenProxy is Proxy {\\n    /**************************************************************************/\\n    /* Constants */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Beacon address (ERC20DepositToken)\\n     */\\n    address internal immutable _beacon;\\n\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice ERC20DepositTokenProxy constructor\\n     *\\n     * @dev Set the ERC20DepositToken address as beacon\\n     *      and initializes the storage of the Proxy\\n     *\\n     * @param beacon Beacon address\\n     * @param data Initialization data\\n     */\\n    constructor(address beacon, bytes memory data) {\\n        _beacon = beacon;\\n        Address.functionDelegateCall(ERC20DepositToken(beacon).getERC20DepositTokenImplementation(), data);\\n    }\\n\\n    /**************************************************************************/\\n    /* Getters */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Get implementation address\\n     *\\n     * @dev Overrides Proxy._implementation()\\n     *\\n     * @return Implementation address\\n     */\\n    function _implementation() internal view virtual override returns (address) {\\n        return ERC20DepositToken(_beacon).getERC20DepositTokenImplementation();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/wrappers/BundleCollateralWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\nimport \\\"../interfaces/ICollateralWrapper.sol\\\";\\n\\n/**\\n * @title Bundle Collateral Wrapper\\n * @author MetaStreet Labs\\n */\\ncontract BundleCollateralWrapper is ICollateralWrapper, ERC721, ReentrancyGuard {\\n    /**************************************************************************/\\n    /* Constants */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Implementation version\\n     */\\n    string public constant IMPLEMENTATION_VERSION = \\\"2.1\\\";\\n\\n    /**\\n     * @notice Maximum bundle size\\n     */\\n    uint256 internal constant MAX_BUNDLE_SIZE = 32;\\n\\n    /**************************************************************************/\\n    /* Errors */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Invalid caller\\n     */\\n    error InvalidCaller();\\n\\n    /**\\n     * @notice Invalid context\\n     */\\n    error InvalidContext();\\n\\n    /**\\n     * @notice Invalid bundle size\\n     */\\n    error InvalidSize();\\n\\n    /**************************************************************************/\\n    /* Events */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Emitted when bundle is minted\\n     * @param tokenId Token ID of the new collateral wrapper token\\n     * @param account Address that created the bundle\\n     * @param encodedBundle Encoded bundle data\\n     */\\n    event BundleMinted(uint256 indexed tokenId, address indexed account, bytes encodedBundle);\\n\\n    /**\\n     * @notice Emitted when bundle is unwrapped\\n     * @param tokenId Token ID of the bundle collateral wrapper token\\n     * @param account Address that unwrapped the bundle\\n     */\\n    event BundleUnwrapped(uint256 indexed tokenId, address indexed account);\\n\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice BundleCollateralWrapper constructor\\n     */\\n    constructor() ERC721(\\\"MetaStreet Bundle Collateral Wrapper\\\", \\\"MSBCW\\\") {}\\n\\n    /**************************************************************************/\\n    /* Implementation */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc ICollateralWrapper\\n     */\\n    function name() public pure override(ERC721, ICollateralWrapper) returns (string memory) {\\n        return \\\"MetaStreet Bundle Collateral Wrapper\\\";\\n    }\\n\\n    /**\\n     * @inheritdoc ERC721\\n     */\\n    function symbol() public pure override returns (string memory) {\\n        return \\\"MSBCW\\\";\\n    }\\n\\n    /**\\n     * @notice Check if token ID exists\\n     * @param tokenId Token ID\\n     * @return True if token ID exists, otherwise false\\n     */\\n    function exists(uint256 tokenId) external view returns (bool) {\\n        return _exists(tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc ICollateralWrapper\\n     */\\n    function enumerate(\\n        uint256 tokenId,\\n        bytes calldata context\\n    ) external view returns (address token, uint256[] memory tokenIds) {\\n        if (tokenId != uint256(_hash(context))) revert InvalidContext();\\n\\n        /* Get token address from context */\\n        token = address(uint160(bytes20(context[0:20])));\\n\\n        /* Compute number of tokens in context */\\n        uint256 tokenCount = (context.length - 20) / 32;\\n\\n        /* Instantiate asset info array */\\n        tokenIds = new uint256[](tokenCount);\\n\\n        /* Populate asset info array */\\n        uint256 offset = 20;\\n        for (uint256 i; i < tokenCount; i++) {\\n            tokenIds[i] = uint256(bytes32(context[offset:offset + 32]));\\n            offset += 32;\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc ICollateralWrapper\\n     */\\n    function enumerateWithQuantities(\\n        uint256 tokenId,\\n        bytes calldata context\\n    ) external view returns (address token, uint256[] memory tokenIds, uint256[] memory quantities) {\\n        if (tokenId != uint256(_hash(context))) revert InvalidContext();\\n\\n        /* Get token address from context */\\n        token = address(uint160(bytes20(context[0:20])));\\n\\n        /* Compute number of tokens in context */\\n        uint256 tokenCount = (context.length - 20) / 32;\\n\\n        /* Instantiate asset info array */\\n        tokenIds = new uint256[](tokenCount);\\n\\n        /* Instantiate quantities array */\\n        quantities = new uint256[](tokenCount);\\n\\n        /* Populate arrays */\\n        uint256 offset = 20;\\n        for (uint256 i; i < tokenCount; i++) {\\n            tokenIds[i] = uint256(bytes32(context[offset:offset + 32]));\\n            quantities[i] = 1;\\n            offset += 32;\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc ICollateralWrapper\\n     */\\n    function count(uint256 tokenId, bytes calldata context) external view returns (uint256) {\\n        if (tokenId != uint256(_hash(context))) revert InvalidContext();\\n\\n        /* Compute number of tokens in context */\\n        return (context.length - 20) / 32;\\n    }\\n\\n    /**\\n     * @inheritdoc ICollateralWrapper\\n     */\\n    function transferCalldata(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        uint256\\n    ) external pure returns (address, bytes memory) {\\n        return (token, abi.encodeWithSelector(IERC721.transferFrom.selector, from, to, tokenId));\\n    }\\n\\n    /**************************************************************************/\\n    /* Internal Helpers */\\n    /**************************************************************************/\\n\\n    /**\\n     * @dev Compute hash of encoded bundle\\n     * @param encodedBundle Encoded bundle\\n     * @return bundleTokenId Hash\\n     */\\n    function _hash(bytes memory encodedBundle) internal view returns (bytes32) {\\n        /* Take hash of chain ID (32 bytes) concatenated with encoded bundle */\\n        return keccak256(abi.encodePacked(block.chainid, encodedBundle));\\n    }\\n\\n    /**************************************************************************/\\n    /* User API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Deposit NFT collateral into contract and mint a BundleCollateralWrapper token\\n     *\\n     * Emits a {BundleMinted} event\\n     *\\n     * @dev Collateral token and token ids are encoded, hashed and stored as\\n     * the BundleCollateralWrapper token ID.\\n     * @param token Collateral token address\\n     * @param tokenIds List of token IDs\\n     */\\n    function mint(address token, uint256[] calldata tokenIds) external nonReentrant returns (uint256) {\\n        /* Validate token IDs count */\\n        if (tokenIds.length == 0 || tokenIds.length > MAX_BUNDLE_SIZE) revert InvalidSize();\\n\\n        /* Create encodedBundle */\\n        bytes memory encodedBundle = abi.encodePacked(token);\\n\\n        /* For each ERC-721 asset, add to encoded bundle and transfer to this contract */\\n        for (uint256 i; i < tokenIds.length; i++) {\\n            encodedBundle = abi.encodePacked(encodedBundle, tokenIds[i]);\\n            IERC721(token).transferFrom(msg.sender, address(this), tokenIds[i]);\\n        }\\n\\n        /* Hash encodedBundle */\\n        uint256 tokenId = uint256(_hash(encodedBundle));\\n\\n        /* Mint BundleCollateralWrapper token */\\n        _mint(msg.sender, tokenId);\\n\\n        emit BundleMinted(tokenId, msg.sender, encodedBundle);\\n\\n        return tokenId;\\n    }\\n\\n    /**\\n     * Emits a {BundleUnwrapped} event\\n     *\\n     * @inheritdoc ICollateralWrapper\\n     */\\n    function unwrap(uint256 tokenId, bytes calldata context) external nonReentrant {\\n        if (tokenId != uint256(_hash(context))) revert InvalidContext();\\n        if (msg.sender != ownerOf(tokenId)) revert InvalidCaller();\\n\\n        /* Get token address from context */\\n        address token = address(uint160(bytes20(context[0:20])));\\n\\n        /* Compute number of token ids */\\n        uint256 tokenCount = (context.length - 20) / 32;\\n\\n        _burn(tokenId);\\n\\n        /* Transfer assets back to owner of token */\\n        uint256 offset = 20;\\n        for (uint256 i; i < tokenCount; i++) {\\n            IERC721(token).transferFrom(address(this), msg.sender, uint256(bytes32(context[offset:offset + 32])));\\n            offset += 32;\\n        }\\n\\n        emit BundleUnwrapped(tokenId, msg.sender);\\n    }\\n\\n    /******************************************************/\\n    /* ERC165 interface */\\n    /******************************************************/\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\\n        return interfaceId == type(ICollateralWrapper).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/wrappers/ERC1155CollateralWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\nimport \\\"../interfaces/ICollateralWrapper.sol\\\";\\n\\n/**\\n * @title ERC1155 Collateral Wrapper\\n * @author MetaStreet Labs\\n */\\ncontract ERC1155CollateralWrapper is ICollateralWrapper, ERC721, ERC1155Holder, ReentrancyGuard {\\n    /**************************************************************************/\\n    /* Constants */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Implementation version\\n     */\\n    string public constant IMPLEMENTATION_VERSION = \\\"1.1\\\";\\n\\n    /**\\n     * @notice Maximum token IDs\\n     */\\n    uint256 internal constant MAX_TOKEN_IDS = 32;\\n\\n    /**************************************************************************/\\n    /* Errors */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Invalid caller\\n     */\\n    error InvalidCaller();\\n\\n    /**\\n     * @notice Invalid context\\n     */\\n    error InvalidContext();\\n\\n    /**\\n     * @notice Invalid token IDs size\\n     */\\n    error InvalidSize();\\n\\n    /**\\n     * @notice Invalid token id\\n     */\\n    error InvalidOrdering();\\n\\n    /**************************************************************************/\\n    /* State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Encoding nonce\\n     */\\n    uint256 private _nonce;\\n\\n    /**************************************************************************/\\n    /* Events */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Emitted when batch is minted\\n     * @param tokenId Token ID of the new collateral wrapper token\\n     * @param account Address that created the batch\\n     * @param encodedBatch Encoded batch data\\n     */\\n    event BatchMinted(uint256 indexed tokenId, address indexed account, bytes encodedBatch);\\n\\n    /**\\n     * @notice Emitted when batch is unwrapped\\n     * @param tokenId Token ID of the batch collateral wrapper token\\n     * @param account Address that unwrapped the batch\\n     */\\n    event BatchUnwrapped(uint256 indexed tokenId, address indexed account);\\n\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice BatchCollateralWrapper constructor\\n     */\\n    constructor() ERC721(\\\"MetaStreet ERC1155 Collateral Wrapper\\\", \\\"MSMTCW\\\") {}\\n\\n    /**************************************************************************/\\n    /* Implementation */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc ICollateralWrapper\\n     */\\n    function name() public pure override(ERC721, ICollateralWrapper) returns (string memory) {\\n        return \\\"MetaStreet ERC1155 Collateral Wrapper\\\";\\n    }\\n\\n    /**\\n     * @inheritdoc ERC721\\n     */\\n    function symbol() public pure override returns (string memory) {\\n        return \\\"MSMTCW\\\";\\n    }\\n\\n    /**\\n     * @notice Check if token ID exists\\n     * @param tokenId Token ID\\n     * @return True if token ID exists, otherwise false\\n     */\\n    function exists(uint256 tokenId) external view returns (bool) {\\n        return _exists(tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc ICollateralWrapper\\n     */\\n    function enumerate(uint256 tokenId, bytes calldata context) external view returns (address, uint256[] memory) {\\n        if (tokenId != uint256(_hash(context))) revert InvalidContext();\\n\\n        /* Decode context */\\n        (address token, , , uint256[] memory tokenIds, ) = abi.decode(\\n            context,\\n            (address, uint256, uint256, uint256[], uint256[])\\n        );\\n\\n        return (token, tokenIds);\\n    }\\n\\n    /**\\n     * @inheritdoc ICollateralWrapper\\n     */\\n    function enumerateWithQuantities(\\n        uint256 tokenId,\\n        bytes calldata context\\n    ) external view returns (address, uint256[] memory, uint256[] memory) {\\n        if (tokenId != uint256(_hash(context))) revert InvalidContext();\\n\\n        /* Decode context */\\n        (address token, , , uint256[] memory tokenIds, uint256[] memory quantities) = abi.decode(\\n            context,\\n            (address, uint256, uint256, uint256[], uint256[])\\n        );\\n\\n        return (token, tokenIds, quantities);\\n    }\\n\\n    /**\\n     * @inheritdoc ICollateralWrapper\\n     */\\n    function count(uint256 tokenId, bytes calldata context) external view returns (uint256) {\\n        if (tokenId != uint256(_hash(context))) revert InvalidContext();\\n\\n        /* Decode context */\\n        (, , uint256 count_, , ) = abi.decode(context, (address, uint256, uint256, uint256[], uint256[]));\\n\\n        return count_;\\n    }\\n\\n    /**\\n     * @inheritdoc ICollateralWrapper\\n     */\\n    function transferCalldata(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        uint256 quantity\\n    ) external pure returns (address, bytes memory) {\\n        return (token, abi.encodeWithSelector(IERC1155.safeTransferFrom.selector, from, to, tokenId, quantity, \\\"\\\"));\\n    }\\n\\n    /**************************************************************************/\\n    /* Internal Helpers */\\n    /**************************************************************************/\\n\\n    /**\\n     * @dev Compute hash of encoded batch\\n     * @param encodedBatch Encoded batch\\n     * @return batchTokenId Hash\\n     */\\n    function _hash(bytes memory encodedBatch) internal view returns (bytes32) {\\n        /* Take hash of chain ID (32 bytes) concatenated with encoded batch */\\n        return keccak256(abi.encodePacked(block.chainid, encodedBatch));\\n    }\\n\\n    /**************************************************************************/\\n    /* User API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Deposit a ERC1155 collateral into contract and mint a ERC1155CollateralWrapper token\\n     *\\n     * Emits a {BatchMinted} event\\n     *\\n     * @dev Collateral token, nonce, token ids, batch size, and quantities are encoded,\\n     * hashed and stored as the ERC1155CollateralWrapper token ID.\\n     * @param token Collateral token address\\n     * @param tokenIds List of token ids\\n     * @param quantities List of quantities\\n     */\\n    function mint(\\n        address token,\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata quantities\\n    ) external nonReentrant returns (uint256) {\\n        /* Validate token IDs and quantities */\\n        if (tokenIds.length == 0 || tokenIds.length > MAX_TOKEN_IDS || tokenIds.length != quantities.length)\\n            revert InvalidSize();\\n\\n        /* Validate token ID and quantity */\\n        uint256 batchSize;\\n        for (uint256 i; i < tokenIds.length; i++) {\\n            /* Validate unique token ID */\\n            if (i != 0 && tokenIds[i] <= tokenIds[i - 1]) revert InvalidOrdering();\\n\\n            /* Validate quantity is non-zero */\\n            if (quantities[i] == 0) revert InvalidSize();\\n\\n            /* Compute batch size */\\n            batchSize += quantities[i];\\n        }\\n\\n        /* Create encoded batch and increment nonce */\\n        bytes memory encodedBatch = abi.encode(token, _nonce++, batchSize, tokenIds, quantities);\\n\\n        /* Hash encoded batch */\\n        uint256 tokenId = uint256(_hash(encodedBatch));\\n\\n        /* Batch transfer tokens */\\n        IERC1155(token).safeBatchTransferFrom(msg.sender, address(this), tokenIds, quantities, \\\"\\\");\\n\\n        /* Mint ERC1155CollateralWrapper token */\\n        _mint(msg.sender, tokenId);\\n\\n        emit BatchMinted(tokenId, msg.sender, encodedBatch);\\n\\n        return tokenId;\\n    }\\n\\n    /**\\n     * Emits a {BatchUnwrapped} event\\n     *\\n     * @inheritdoc ICollateralWrapper\\n     */\\n    function unwrap(uint256 tokenId, bytes calldata context) external nonReentrant {\\n        if (tokenId != uint256(_hash(context))) revert InvalidContext();\\n        if (msg.sender != ownerOf(tokenId)) revert InvalidCaller();\\n\\n        /* Decode context */\\n        (address token, , , uint256[] memory tokenIds, uint256[] memory quantities) = abi.decode(\\n            context,\\n            (address, uint256, uint256, uint256[], uint256[])\\n        );\\n\\n        /* Burn ERC1155CollateralWrapper token */\\n        _burn(tokenId);\\n\\n        /* Batch transfer tokens back to token owner */\\n        IERC1155(token).safeBatchTransferFrom(address(this), msg.sender, tokenIds, quantities, \\\"\\\");\\n\\n        emit BatchUnwrapped(tokenId, msg.sender);\\n    }\\n\\n    /******************************************************/\\n    /* ERC165 interface */\\n    /******************************************************/\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC1155Receiver) returns (bool) {\\n        return interfaceId == type(ICollateralWrapper).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/wrappers/PunkCollateralWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\n\\nimport \\\"../interfaces/ICollateralWrapper.sol\\\";\\n\\nimport {ICryptoPunksMarket} from \\\"../integrations/CryptoPunks/ICryptoPunksMarket.sol\\\";\\n\\n/**\\n * @title Punk Collateral Wrapper\\n * @author MetaStreet Labs\\n */\\ncontract PunkCollateralWrapper is ICollateralWrapper, ERC721, ReentrancyGuard {\\n    /**************************************************************************/\\n    /* Constants */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Implementation version\\n     */\\n    string public constant IMPLEMENTATION_VERSION = \\\"1.0\\\";\\n\\n    /**\\n     * @notice Maximum bundle size\\n     */\\n    uint256 internal constant MAX_BUNDLE_SIZE = 32;\\n\\n    /**************************************************************************/\\n    /* Errors */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Invalid caller\\n     */\\n    error InvalidCaller();\\n\\n    /**\\n     * @notice Invalid context\\n     */\\n    error InvalidContext();\\n\\n    /**\\n     * @notice Invalid bundle size\\n     */\\n    error InvalidSize();\\n\\n    /**************************************************************************/\\n    /* Events */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Emitted when punk collateral wrapper is minted\\n     * @param tokenId Token ID of the new collateral wrapper token\\n     * @param account Address that created the punk collateral wrapper\\n     * @param encodedBundle Encoded bundle data\\n     */\\n    event PunkMinted(uint256 indexed tokenId, address indexed account, bytes encodedBundle);\\n\\n    /**\\n     * @notice Emitted when punk collateral wrapper is unwrapped\\n     * @param tokenId Token ID of the punk collateral wrapper token\\n     * @param account Address that unwrapped the punk collateral wrapper\\n     */\\n    event PunkUnwrapped(uint256 indexed tokenId, address indexed account);\\n\\n    /**************************************************************************/\\n    /* Immutable State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Crypto Punks Market\\n     */\\n    ICryptoPunksMarket internal immutable _punksMarket;\\n\\n    /**\\n     * @notice Crypto Punks Token (returned by enumerate API)\\n     */\\n    address internal immutable _punksToken;\\n\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice PunkCollateralWrapper constructor\\n     * @param punksMarket Native Crypto Punks token address\\n     * @param punksToken Crypto Punks token address returned by enumerate API\\n     *\\n     * @dev This collateral wrapper is deployed with punksToken set to WPUNKS,\\n     * which is returned by the enumerate API, for backwards compatibility with\\n     * existing Crypto Punks pools. Frontends may need special handling for\\n     * dealing with the underlying native Crypto Punks tokens.\\n     */\\n    constructor(address punksMarket, address punksToken) ERC721(\\\"MetaStreet Punk Collateral Wrapper\\\", \\\"MSPCW\\\") {\\n        _punksMarket = ICryptoPunksMarket(punksMarket);\\n        _punksToken = punksToken;\\n    }\\n\\n    /**************************************************************************/\\n    /* Implementation */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc ICollateralWrapper\\n     */\\n    function name() public pure override(ERC721, ICollateralWrapper) returns (string memory) {\\n        return \\\"MetaStreet Punk Collateral Wrapper\\\";\\n    }\\n\\n    /**\\n     * @inheritdoc ERC721\\n     */\\n    function symbol() public pure override returns (string memory) {\\n        return \\\"MSPCW\\\";\\n    }\\n\\n    /**\\n     * @notice Check if token ID exists\\n     * @param tokenId Token ID\\n     * @return True if token ID exists, otherwise false\\n     */\\n    function exists(uint256 tokenId) external view returns (bool) {\\n        return _exists(tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc ICollateralWrapper\\n     */\\n    function enumerate(\\n        uint256 tokenId,\\n        bytes calldata context\\n    ) external view returns (address token, uint256[] memory tokenIds) {\\n        if (tokenId != uint256(_hash(context))) revert InvalidContext();\\n\\n        /* Set punks token */\\n        token = _punksToken;\\n\\n        /* Compute number of tokens in context */\\n        uint256 count_ = context.length / 32;\\n\\n        /* Instantiate asset info array */\\n        tokenIds = new uint256[](count_);\\n\\n        /* Populate asset info array */\\n        uint256 offset;\\n        for (uint256 i; i < count_; i++) {\\n            tokenIds[i] = uint256(bytes32(context[offset:offset + 32]));\\n            offset += 32;\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc ICollateralWrapper\\n     */\\n    function enumerateWithQuantities(\\n        uint256 tokenId,\\n        bytes calldata context\\n    ) external view returns (address token, uint256[] memory tokenIds, uint256[] memory quantities) {\\n        if (tokenId != uint256(_hash(context))) revert InvalidContext();\\n\\n        /* Set punks token */\\n        token = _punksToken;\\n\\n        /* Compute number of tokens in context */\\n        uint256 count_ = context.length / 32;\\n\\n        /* Instantiate asset info array */\\n        tokenIds = new uint256[](count_);\\n\\n        /* Instantiate quantities array */\\n        quantities = new uint256[](count_);\\n\\n        /* Populate arrays */\\n        uint256 offset;\\n        for (uint256 i; i < count_; i++) {\\n            tokenIds[i] = uint256(bytes32(context[offset:offset + 32]));\\n            quantities[i] = 1;\\n            offset += 32;\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc ICollateralWrapper\\n     */\\n    function count(uint256 tokenId, bytes calldata context) external view returns (uint256) {\\n        if (tokenId != uint256(_hash(context))) revert InvalidContext();\\n\\n        /* Compute number of tokens in context */\\n        return context.length / 32;\\n    }\\n\\n    /**\\n     * @inheritdoc ICollateralWrapper\\n     */\\n    function transferCalldata(\\n        address,\\n        address,\\n        address to,\\n        uint256 tokenId,\\n        uint256\\n    ) external view returns (address, bytes memory) {\\n        return (address(_punksMarket), abi.encodeWithSelector(_punksMarket.transferPunk.selector, to, tokenId));\\n    }\\n\\n    /**************************************************************************/\\n    /* Internal Helpers */\\n    /**************************************************************************/\\n\\n    /**\\n     * @dev Compute hash of encoded bundle\\n     * @param encodedBundle Encoded bundle\\n     * @return Hash of encoded bundle\\n     */\\n    function _hash(bytes memory encodedBundle) internal view returns (bytes32) {\\n        /* Take hash of chain ID (32 bytes) concatenated with encoded bundle */\\n        return keccak256(abi.encodePacked(block.chainid, encodedBundle));\\n    }\\n\\n    /**************************************************************************/\\n    /* User API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Deposit Punk NFT collateral into contract and mint a PunkCollateralWrapper token\\n     *\\n     * Emits a {PunkMinted} event\\n     *\\n     * @dev Token ids are encoded, hashed and stored as\\n     * the PunkCollateralWrapper token ID.\\n     * @param tokenIds Punk token IDs\\n     */\\n    function mint(uint256[] memory tokenIds) external nonReentrant returns (uint256) {\\n        /* Validate token IDs count */\\n        if (tokenIds.length == 0 || tokenIds.length > MAX_BUNDLE_SIZE) revert InvalidSize();\\n\\n        /* Create encoded bundle */\\n        bytes memory encodedBundle;\\n\\n        /* For each punk, add to encoded bundle and transfer to this contract */\\n        for (uint256 i; i < tokenIds.length; i++) {\\n            encodedBundle = abi.encodePacked(encodedBundle, tokenIds[i]);\\n\\n            /* Validate that caller owns the punk */\\n            if (_punksMarket.punkIndexToAddress(tokenIds[i]) != msg.sender) revert InvalidCaller();\\n\\n            /* Requires offerPunkForSaleToAddress with 0 ethers to this contract */\\n            _punksMarket.buyPunk(tokenIds[i]);\\n        }\\n\\n        /* Hash encodedBundle */\\n        uint256 tokenId = uint256(_hash(encodedBundle));\\n\\n        /* Mint PunkCollateralWrapper token */\\n        _mint(msg.sender, tokenId);\\n\\n        emit PunkMinted(tokenId, msg.sender, encodedBundle);\\n\\n        return tokenId;\\n    }\\n\\n    /**\\n     * Emits a {PunkUnwrapped} event\\n     *\\n     * @inheritdoc ICollateralWrapper\\n     */\\n    function unwrap(uint256 tokenId, bytes calldata context) external nonReentrant {\\n        if (tokenId != uint256(_hash(context))) revert InvalidContext();\\n        if (msg.sender != ownerOf(tokenId)) revert InvalidCaller();\\n\\n        /* Compute number of token ids */\\n        uint256 count_ = context.length / 32;\\n\\n        _burn(tokenId);\\n\\n        /* Transfer punk back to owner of token */\\n        uint256 offset;\\n        for (uint256 i; i < count_; i++) {\\n            _punksMarket.transferPunk(msg.sender, uint256(bytes32(context[offset:offset + 32])));\\n            offset += 32;\\n        }\\n\\n        /* Emits PunkUnwrapped */\\n        emit PunkUnwrapped(tokenId, msg.sender);\\n    }\\n\\n    /******************************************************/\\n    /* ERC165 interface */\\n    /******************************************************/\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\\n        return interfaceId == type(ICollateralWrapper).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"InactiveLiquidity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientShares\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientTickSpacing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRedemptionStatus\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTick\",\"type\":\"error\"}]", "ContractName": "DepositLogic", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}