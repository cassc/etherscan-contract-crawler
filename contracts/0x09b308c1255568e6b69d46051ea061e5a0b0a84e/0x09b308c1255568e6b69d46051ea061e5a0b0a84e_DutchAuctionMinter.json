{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/DutchAuctionMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {Blacklist} from \\\"./Blacklist.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"./lib/ABDKMathQuad.sol\\\";\\nimport \\\"./interfaces/IMinter.sol\\\";\\n\\ncontract DutchAuctionMinter is Pausable, AccessControl, Blacklist, ReentrancyGuard {\\n\\n    /// minterType for this minter\\n    string public constant minterType = \\\"DutchAuctionMinter\\\";\\n    \\n    bytes16 public HalfPeriod;\\n    bytes16 public BaseValue;\\n\\n    // @notice Amount of time in seconds after each price drops\\n    uint256 public priceDropSlot;\\n\\n    // @notice Role for pausing the contract\\n    bytes32 public constant PAUSER_ROLE = keccak256(\\\"PAUSER_ROLE\\\");\\n\\n    /// @notice ERC-721 pass contract whose tokens are minted by this auction\\n    /// @dev Must implement mint(address)\\n    IMinter public passes;\\n\\n    /// @notice ERC-721 pass contract, which tokens needed to mint passes\\n    IERC721 public mintPasses;\\n\\n    /// @notice Minimum amount of mint passes to mint pass\\n    uint256 public minMintPasses;\\n\\n    /// @notice Timestamp when this auction starts allowing minting\\n    uint256 public startTime;\\n\\n    /// @notice Starting price for the Dutch auction\\n    uint256 public startPrice;\\n\\n    /// @notice Resting price where price descent ends\\n    uint256 public restPrice;\\n\\n    /// @notice time of half period\\n    uint256 public halfPeriod;\\n\\n    /// @notice total amount of minted passes\\n    uint256 public totalSupply;\\n\\n    /// @notice maximum amount of passes which can be minted\\n    uint256 public maxMint;\\n\\n    mapping(address => uint256) public mintCount;\\n\\n    uint256 private pauseStart;\\n    uint256 private pastPauseDelay;\\n\\n    address public beneficiary;\\n\\n    uint256 public projectId;\\n\\n    /// @notice Determines if users without mint passes can mint item\\n    bool public mintPublic;\\n\\n    /// @notice An event to be emitted upon pass purchases for the benefit of the UI\\n    event Purchase(address purchaser, uint256 tokenId, uint256 price);\\n\\n    /// @notice An event emitted when mint being open for everyone or not.\\n    /// @dev open - true if mint open for everyone, false if not\\n    event MintPublicUpdated(bool open);\\n\\n    /// @notice An event emitted when mint passes contract changed\\n    /// @dev newMintPasses - address of new mint passes contract\\n    event MintPassesUpdated(address newMintPasses);\\n\\n    /// @notice An error returned when the auction has already started.\\n    error AlreadyStarted();\\n    /// @notice An error returned when the auction has not yet started.\\n    error NotYetStarted();\\n    /// @notice An error returned when funds transfer was not passed.\\n    error FailedPaying(address payee, bytes data);\\n    /// @notice An error returned when minting is not available for user.\\n    /// (mint not yet open for everyone and user don't have enough mint passes)\\n    error MintNotAvailable();\\n\\n    constructor(\\n        IMinter passes_,\\n        IERC721 mintPasses_,\\n        uint256 startTime_,\\n        uint256 startPrice_,\\n        uint256 restPrice_,\\n        uint256 priceDropSlot_,\\n        uint256 halfPeriod_,\\n        uint256 maxMint_,\\n        uint256 minMintPasses_,\\n        uint256 projectId_,\\n        address beneficiary_,\\n        address pauser\\n    ) {\\n        // CHECKS inputs\\n        require(address(passes_) != address(0), \\\"Pass contract must not be the zero address\\\");\\n        require(address(mintPasses_) != address(0), \\\"Mint pass contract must not be the zero address\\\");\\n        // require(passes_.supportsInterface(0x6a627842), \\\"Pass contract must implement mint(address)\\\"); // TODO: fix support of manifold mitner\\n        require(startTime_ >= block.timestamp, \\\"Start time cannot be in the past\\\");\\n\\n        require(startPrice_ > 1e15, \\\"Start price too low: check that prices are in wei\\\");\\n        require(restPrice_ > 1e15, \\\"Rest price too low: check that prices are in wei\\\");\\n        require(startPrice_ >= restPrice_, \\\"Start price must not be lower than rest price\\\");\\n        require(priceDropSlot_ > 0, \\\"Price drop slot must be greater than 0\\\");\\n        require(halfPeriod_ > 0, \\\"Half period must be greater than 0\\\");\\n        require(minMintPasses_ > 0, \\\"Minimum mint passes must be greater than 0\\\");\\n        require(beneficiary_ != address(0), \\\"Beneficiary must not be the zero address\\\");\\n        require(maxMint_ > 0, \\\"Max mint must be greater than 0\\\");\\n\\n        // EFFECTS\\n        passes = passes_;\\n        startTime = startTime_;\\n        startPrice = startPrice_;\\n        restPrice = restPrice_;\\n        priceDropSlot = priceDropSlot_;\\n        halfPeriod = halfPeriod_;\\n        maxMint = maxMint_;\\n        beneficiary = beneficiary_;\\n        mintPasses = mintPasses_;\\n        minMintPasses = minMintPasses_;\\n        projectId = projectId_;\\n\\n        HalfPeriod = ABDKMathQuad.fromUInt(halfPeriod);\\n        BaseValue = ABDKMathQuad.fromUInt(startPrice);\\n\\n\\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n        _grantRole(PAUSER_ROLE, msg.sender);\\n        _grantRole(PAUSER_ROLE, pauser);\\n    }\\n\\n    modifier started() {\\n        if (!isStarted()) revert NotYetStarted();\\n        _;\\n    }\\n\\n    modifier unstarted() {\\n        if (isStarted()) revert AlreadyStarted();\\n        _;\\n    }\\n\\n    // PUBLIC FUNCTIONS\\n\\n    /// @notice Mint a pass on the `passes` contract. Must include at least `currentPrice`.\\n    function mint() external payable started whenNotPaused onlyNotBlacklisted nonReentrant {\\n        // CHECKS inputs\\n        uint256 price = msg.value;\\n        uint256 cPrice = currentPrice();\\n        require(price >= cPrice, \\\"Insufficient payment\\\");\\n        require(totalSupply < maxMint, \\\"Maximum mint reached\\\");\\n\\n        if (!mintPublic && mintPasses.balanceOf(msg.sender) < minMintPasses) {\\n            revert MintNotAvailable();\\n        }\\n\\n        // EFFECTS\\n        unchecked {\\n            // Unchecked arithmetic: mintCount cannot exceed maxMint\\n            mintCount[msg.sender]++;\\n        }\\n\\n        // EFFECTS + INTERACTIONS: call mint on known contract (passes.mint contains no external interactions)\\n        totalSupply++;\\n        uint256 id = passes.mint(msg.sender, projectId, msg.sender);\\n\\n        emit Purchase(msg.sender, id, cPrice);\\n\\n        refundIfOver(cPrice);\\n    }\\n\\n    /// @notice Mint up to three passes on the `passes` contract. Must include at least `currentPrice` * `quantity`.\\n    /// @param quantity The number of passes to mint: must be 1, 2, or 3\\n    function mintMultiple(uint256 quantity) external payable started whenNotPaused onlyNotBlacklisted nonReentrant {\\n        // CHECKS inputs\\n        uint256 alreadyMinted = mintCount[msg.sender];\\n        require(quantity > 0, \\\"Must mint at least one pass\\\");\\n        uint256 payment = msg.value;\\n        uint256 price = payment / quantity;\\n        uint256 cPrice = currentPrice();\\n        require(price >= cPrice, \\\"Insufficient payment\\\");\\n        require(totalSupply + quantity <= maxMint, \\\"Maximum mint reached\\\");\\n\\n        if (!mintPublic && mintPasses.balanceOf(msg.sender) < minMintPasses) {\\n            revert MintNotAvailable();\\n        }\\n\\n        // EFFECTS\\n        unchecked {\\n            // Unchecked arithmetic: totalSupply cannot exceed max mint\\n            totalSupply = totalSupply + quantity;\\n            // Unchecked arithmetic: mintCount cannot exceed totalSupply and maxMint\\n            mintCount[msg.sender] = alreadyMinted + quantity;\\n        }\\n\\n        // EFFECTS + INTERACTIONS: call mint on known contract (passes.mint contains no external interactions)\\n        // One call without try/catch to make sure at least one is minted.\\n        for (uint256 i = 0; i < quantity; i++) {\\n            uint256 id = passes.mint(msg.sender, projectId, msg.sender);\\n            emit Purchase(msg.sender, id, cPrice);\\n        }\\n\\n        refundIfOver(cPrice * quantity);\\n    }\\n\\n    function refundIfOver(uint256 price) private {\\n        require(msg.value >= price, \\\"Need to send more ETH.\\\");\\n        if (msg.value > price) {\\n            payable(msg.sender).transfer(msg.value - price);\\n        }\\n    }\\n\\n    // OWNER FUNCTIONS\\n\\n    function setProjectId(uint256 projectId_) external unstarted onlyRole(DEFAULT_ADMIN_ROLE) {\\n        projectId = projectId_;\\n    }\\n\\n    /// @notice Update the passes contract address\\n    /// @dev Can only be called by the contract `owner`. Reverts if the auction has already started.\\n    function setPasses(IMinter passes_) external unstarted onlyRole(DEFAULT_ADMIN_ROLE) {\\n        // CHECKS inputs\\n        require(address(passes_) != address(0), \\\"Pass contract must not be the zero address\\\");\\n        // require(passes_.supportsInterface(0x6a627842), \\\"Pass contract must support mint(address)\\\"); // TODO\\n        // EFFECTS\\n        passes = passes_;\\n    }\\n\\n    /// @notice Pause this contract\\n    /// @dev Can only be called by the contract `owner`\\n    function pause() public onlyRole(PAUSER_ROLE) {\\n        // CHECKS + EFFECTS: `Pausable` handles checking permissions and setting pause state\\n        super._pause();\\n        // More EFFECTS\\n        pauseStart = block.timestamp;\\n    }\\n\\n    /// @notice Resume this contract\\n    /// @dev Can only be called by the contract `owner`. Pricing tiers will pick up where they left off.\\n    function unpause() public onlyRole(PAUSER_ROLE) {\\n        // CHECKS + EFFECTS: `Pausable` handles checking permissions and setting pause state\\n        super._unpause();\\n        // More EFFECTS\\n        if (block.timestamp <= startTime) {\\n            return;\\n        }\\n        // Find the amount time the auction should have been live, but was paused\\n        unchecked {\\n            // Unchecked arithmetic: computed value will be < block.timestamp and >= 0\\n            if (pauseStart < startTime) {\\n                pastPauseDelay = block.timestamp - startTime;\\n            } else {\\n                pastPauseDelay += (block.timestamp - pauseStart);\\n            }\\n        }\\n    }\\n\\n    /// @notice adds an address to blacklist blocking them from minting\\n    /// @dev Can only be called by the contract `owner`.\\n    /// @param account The address to add to the blacklist\\n    function addBlacklist(address account) public onlyRole(DEFAULT_ADMIN_ROLE) {\\n        _addBlacklist(account);\\n    }\\n\\n    /// @notice removes an address from blacklist allowing them to once again mint\\n    /// @dev Can only be called by the contract `owner`.\\n    /// @param account The address to removed to the blacklist\\n    function removeBlacklist(address account) public onlyRole(DEFAULT_ADMIN_ROLE) {\\n        _removeBlacklist(account);\\n    }\\n\\n    function withdraw() public onlyRole(DEFAULT_ADMIN_ROLE) nonReentrant {\\n        uint256 balanceAvailable = address(this).balance;\\n        (bool success, bytes memory data) = beneficiary.call{value: balanceAvailable}(\\\"\\\");\\n        if (!success) revert FailedPaying(beneficiary, data);\\n    }\\n\\n    /// @notice Update the auction start time\\n    /// @dev Can only be called by the contract `owner`. Reverts if the auction has already started.\\n    function setStartTime(uint256 startTime_) external unstarted onlyRole(DEFAULT_ADMIN_ROLE) {\\n        // CHECKS inputs\\n        require(startTime_ >= block.timestamp, \\\"New start time cannot be in the past\\\");\\n        // EFFECTS\\n        startTime = startTime_;\\n    }\\n\\n    /// @notice Update the auction start time\\n    /// @dev Can only be called by the contract `owner`. Reverts if the auction has already started.\\n    function setMaxMint(uint256 maxMint_) external unstarted onlyRole(DEFAULT_ADMIN_ROLE) {\\n        // CHECKS inputs\\n        require(maxMint_ > 0, \\\"Max mint must be greater than 0\\\");\\n        // EFFECTS\\n        maxMint = maxMint_;\\n    }\\n\\n    ///@notice Update the minimum number of passes required to mint\\n    ///@dev Can only be called by the contract `owner`.\\n    function setMinMintPasses(uint256 minMintPasses_) external unstarted onlyRole(DEFAULT_ADMIN_ROLE) {\\n        // CHECKS inputs\\n        require(minMintPasses_ > 0, \\\"Min mint passes must be greater than 0\\\");\\n        // EFFECTS\\n        minMintPasses = minMintPasses_;\\n    }\\n\\n    /// @notice Update the auction price range and rate of decrease\\n    /// @dev Since the values are validated against each other, they are all set together. Can only be called by the\\n    ///  contract `owner`. Reverts if the auction has already started.\\n    function setPriceRange(uint256 startPrice_, uint256 restPrice_, uint256 priceDropSlot_, uint256 halfPeriod_)\\n        external\\n        unstarted\\n        onlyRole(DEFAULT_ADMIN_ROLE)\\n    {\\n        // CHECKS inputs\\n        require(startPrice_ > 1e15, \\\"Start price too low: check that prices are in wei\\\");\\n        require(restPrice_ > 1e15, \\\"Rest price too low: check that prices are in wei\\\");\\n        require(startPrice_ >= restPrice_, \\\"Start price must not be lower than rest price\\\");\\n        require(priceDropSlot_ > 0, \\\"Price drop slot must be greater than 0\\\");\\n        require(halfPeriod_ > 0, \\\"Half period must be greater than 0\\\");\\n\\n        // EFFECTS\\n        startPrice = startPrice_;\\n        restPrice = restPrice_;\\n        priceDropSlot = priceDropSlot_;\\n        halfPeriod = halfPeriod_;\\n\\n        HalfPeriod = ABDKMathQuad.fromUInt(halfPeriod);\\n        BaseValue = ABDKMathQuad.fromUInt(startPrice);\\n    }\\n\\n    function setMintPasses(IERC721 mintPasses_) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        mintPasses = mintPasses_;\\n        emit MintPassesUpdated(address(mintPasses));\\n    }\\n\\n    function setMintPublic(bool mintPublic_) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        mintPublic = mintPublic_;\\n        emit MintPublicUpdated(mintPublic);\\n    }\\n\\n    // VIEW FUNCTIONS\\n\\n    /// @notice Query the current price\\n    function currentPrice() public view returns (uint256) {\\n        uint256 time = timeElapsed();\\n        unchecked {\\n            time = (time / priceDropSlot) * priceDropSlot;\\n        }\\n\\n        //function fromUInt (uint256 x) internal pure returns (bytes16)\\n        bytes16 currentTime = ABDKMathQuad.fromUInt(time);\\n\\n        //first: currentTime / half period\\n        bytes16 step0 = ABDKMathQuad.div(currentTime, HalfPeriod);\\n\\n        //second: pow_2\\n        bytes16 step1 = ABDKMathQuad.pow_2(step0);\\n\\n        //then: startPrice / step1\\n        bytes16 step2 = ABDKMathQuad.div(BaseValue, step1);\\n\\n        //last\\n        uint256 value = ABDKMathQuad.toUInt(step2);\\n\\n        if (value < restPrice) {\\n            value = restPrice;\\n        }\\n\\n        return value;\\n    }\\n\\n    /// @notice Returns time of total decay period\\n    function decayTime() public view returns (uint256) {\\n        bytes16 step0 = ABDKMathQuad.log_2(BaseValue);\\n        bytes16 step1 = ABDKMathQuad.log_2(ABDKMathQuad.fromUInt(restPrice));\\n\\n        bytes16 result = ABDKMathQuad.mul(HalfPeriod, ABDKMathQuad.sub(step0, step1));\\n        uint256 t = ABDKMathQuad.toUInt(result);\\n        unchecked {\\n            //padding 10\\n            t = ((t + 10) / 10) * 10;\\n        }\\n\\n        return t;\\n    }\\n\\n    /// @notice Returns timestamp of next price drop\\n    function nextPriceDrop() public view returns (uint256) {\\n        if (!isStarted()) return startTime + priceDropSlot;\\n\\n        uint256 timeUntilNextDrop = priceDropSlot - (timeElapsed() % priceDropSlot);\\n\\n        return block.timestamp + timeUntilNextDrop;\\n    }\\n\\n    function endTime() public view returns (uint256) {\\n        return startTime + decayTime() + pastPauseDelay;\\n    }\\n\\n    function isStarted() internal view returns (bool) {\\n        return (paused() ? pauseStart : block.timestamp) >= startTime;\\n    }\\n\\n    function timeElapsed() internal view returns (uint256) {\\n        if (!isStarted()) return 0;\\n        unchecked {\\n            // pastPauseDelay cannot be greater than the time passed since startTime.\\n            if (!paused()) {\\n                return block.timestamp - startTime - pastPauseDelay;\\n            }\\n\\n            // pastPauseDelay cannot be greater than the time between startTime and pauseStart.\\n            return pauseStart - startTime - pastPauseDelay;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(account),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/Blacklist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\ninterface BlacklistEvents {\\n    /// @dev Emitted when `account` is blacklisted\\n    event Blacklisted(address indexed account);\\n\\n    /// @dev Emitted when `account` is removed from the blacklist\\n    event Unblacklisted(address indexed account);\\n}\\n\\nabstract contract Blacklist is BlacklistEvents, Context {\\n    /// @dev maps if an address has been blacklisted\\n    mapping(address => bool) private _blacklist;\\n\\n    constructor() {}\\n\\n    /// @dev only allows non-blacklisted addresses to call a function\\n    modifier onlyNotBlacklisted() {\\n        require(!isBlacklisted(_msgSender()), \\\"Blacklist: caller is blacklisted\\\");\\n        _;\\n    }\\n\\n    /// @dev add address to blacklist\\n    function _addBlacklist(address account) internal virtual {\\n        _blacklist[account] = true;\\n        emit Blacklisted(account);\\n    }\\n\\n    /// @dev remove address from blacklist\\n    function _removeBlacklist(address account) internal virtual {\\n        _blacklist[account] = false;\\n        emit Unblacklisted(account);\\n    }\\n\\n    /// @dev checks if address is blacklisted\\n    function isBlacklisted(address account) public view virtual returns (bool) {\\n        return _blacklist[account];\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/ABDKMathQuad.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math Quad Smart Contract Library.  Copyright \u00a9 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity ^0.8.17;\\n\\n/**\\n * Smart contract library of mathematical functions operating with IEEE 754\\n * quadruple-precision binary floating-point numbers (quadruple precision\\n * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\\n * represented by bytes16 type.\\n */\\nlibrary ABDKMathQuad {\\n    /*\\n    * 0.\\n    */\\n    bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\\n\\n    /*\\n    * -0.\\n    */\\n    bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\\n\\n    /*\\n    * +Infinity.\\n    */\\n    bytes16 private constant POSITIVE_INFINITY = 0x7FFF0000000000000000000000000000;\\n\\n    /*\\n    * -Infinity.\\n    */\\n    bytes16 private constant NEGATIVE_INFINITY = 0xFFFF0000000000000000000000000000;\\n\\n    /*\\n    * Canonical NaN value.\\n    */\\n    bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\\n\\n    /**\\n     * Convert signed 256-bit integer number into quadruple precision number.\\n     *\\n     * @param x signed 256-bit integer number\\n     * @return quadruple precision number\\n     */\\n    function fromInt(int256 x) internal pure returns (bytes16) {\\n        unchecked {\\n            if (x == 0) {\\n                return bytes16(0);\\n            } else {\\n                // We rely on overflow behavior here\\n                uint256 result = uint256(x > 0 ? x : -x);\\n\\n                uint256 msb = mostSignificantBit(result);\\n                if (msb < 112) result <<= 112 - msb;\\n                else if (msb > 112) result >>= msb - 112;\\n\\n                result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\\n                if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n                return bytes16(uint128(result));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Convert quadruple precision number into signed 256-bit integer number\\n     * rounding towards zero.  Revert on overflow.\\n     *\\n     * @param x quadruple precision number\\n     * @return signed 256-bit integer number\\n     */\\n    function toInt(bytes16 x) internal pure returns (int256) {\\n        unchecked {\\n            uint256 exponent = uint128(x) >> 112 & 0x7FFF;\\n\\n            require(exponent <= 16638); // Overflow\\n            if (exponent < 16383) return 0; // Underflow\\n\\n            uint256 result = uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 0x10000000000000000000000000000;\\n\\n            if (exponent < 16495) result >>= 16495 - exponent;\\n            else if (exponent > 16495) result <<= exponent - 16495;\\n\\n            if (uint128(x) >= 0x80000000000000000000000000000000) {\\n                // Negative\\n                require(result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n                return -int256(result); // We rely on overflow behavior here\\n            } else {\\n                require(result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n                return int256(result);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Convert unsigned 256-bit integer number into quadruple precision number.\\n     *\\n     * @param x unsigned 256-bit integer number\\n     * @return quadruple precision number\\n     */\\n    function fromUInt(uint256 x) internal pure returns (bytes16) {\\n        unchecked {\\n            if (x == 0) {\\n                return bytes16(0);\\n            } else {\\n                uint256 result = x;\\n\\n                uint256 msb = mostSignificantBit(result);\\n                if (msb < 112) result <<= 112 - msb;\\n                else if (msb > 112) result >>= msb - 112;\\n\\n                result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\\n\\n                return bytes16(uint128(result));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Convert quadruple precision number into unsigned 256-bit integer number\\n     * rounding towards zero.  Revert on underflow.  Note, that negative floating\\n     * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\\n     * without error, because they are rounded to zero.\\n     *\\n     * @param x quadruple precision number\\n     * @return unsigned 256-bit integer number\\n     */\\n    function toUInt(bytes16 x) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 exponent = uint128(x) >> 112 & 0x7FFF;\\n\\n            if (exponent < 16383) return 0; // Underflow\\n\\n            require(uint128(x) < 0x80000000000000000000000000000000); // Negative\\n\\n            require(exponent <= 16638); // Overflow\\n            uint256 result = uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 0x10000000000000000000000000000;\\n\\n            if (exponent < 16495) result >>= 16495 - exponent;\\n            else if (exponent > 16495) result <<= exponent - 16495;\\n\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * Convert signed 128.128 bit fixed point number into quadruple precision\\n     * number.\\n     *\\n     * @param x signed 128.128 bit fixed point number\\n     * @return quadruple precision number\\n     */\\n    function from128x128(int256 x) internal pure returns (bytes16) {\\n        unchecked {\\n            if (x == 0) {\\n                return bytes16(0);\\n            } else {\\n                // We rely on overflow behavior here\\n                uint256 result = uint256(x > 0 ? x : -x);\\n\\n                uint256 msb = mostSignificantBit(result);\\n                if (msb < 112) result <<= 112 - msb;\\n                else if (msb > 112) result >>= msb - 112;\\n\\n                result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16255 + msb << 112;\\n                if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n                return bytes16(uint128(result));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Convert quadruple precision number into signed 128.128 bit fixed point\\n     * number.  Revert on overflow.\\n     *\\n     * @param x quadruple precision number\\n     * @return signed 128.128 bit fixed point number\\n     */\\n    function to128x128(bytes16 x) internal pure returns (int256) {\\n        unchecked {\\n            uint256 exponent = uint128(x) >> 112 & 0x7FFF;\\n\\n            require(exponent <= 16510); // Overflow\\n            if (exponent < 16255) return 0; // Underflow\\n\\n            uint256 result = uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 0x10000000000000000000000000000;\\n\\n            if (exponent < 16367) result >>= 16367 - exponent;\\n            else if (exponent > 16367) result <<= exponent - 16367;\\n\\n            if (uint128(x) >= 0x80000000000000000000000000000000) {\\n                // Negative\\n                require(result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n                return -int256(result); // We rely on overflow behavior here\\n            } else {\\n                require(result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n                return int256(result);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Convert signed 64.64 bit fixed point number into quadruple precision\\n     * number.\\n     *\\n     * @param x signed 64.64 bit fixed point number\\n     * @return quadruple precision number\\n     */\\n    function from64x64(int128 x) internal pure returns (bytes16) {\\n        unchecked {\\n            if (x == 0) {\\n                return bytes16(0);\\n            } else {\\n                // We rely on overflow behavior here\\n                uint256 result = uint128(x > 0 ? x : -x);\\n\\n                uint256 msb = mostSignificantBit(result);\\n                if (msb < 112) result <<= 112 - msb;\\n                else if (msb > 112) result >>= msb - 112;\\n\\n                result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16319 + msb << 112;\\n                if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n                return bytes16(uint128(result));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Convert quadruple precision number into signed 64.64 bit fixed point\\n     * number.  Revert on overflow.\\n     *\\n     * @param x quadruple precision number\\n     * @return signed 64.64 bit fixed point number\\n     */\\n    function to64x64(bytes16 x) internal pure returns (int128) {\\n        unchecked {\\n            uint256 exponent = uint128(x) >> 112 & 0x7FFF;\\n\\n            require(exponent <= 16446); // Overflow\\n            if (exponent < 16319) return 0; // Underflow\\n\\n            uint256 result = uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 0x10000000000000000000000000000;\\n\\n            if (exponent < 16431) result >>= 16431 - exponent;\\n            else if (exponent > 16431) result <<= exponent - 16431;\\n\\n            if (uint128(x) >= 0x80000000000000000000000000000000) {\\n                // Negative\\n                require(result <= 0x80000000000000000000000000000000);\\n                return -int128(int256(result)); // We rely on overflow behavior here\\n            } else {\\n                require(result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n                return int128(int256(result));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Convert octuple precision number into quadruple precision number.\\n     *\\n     * @param x octuple precision number\\n     * @return quadruple precision number\\n     */\\n    function fromOctuple(bytes32 x) internal pure returns (bytes16) {\\n        unchecked {\\n            bool negative = x & 0x8000000000000000000000000000000000000000000000000000000000000000 > 0;\\n\\n            uint256 exponent = uint256(x) >> 236 & 0x7FFFF;\\n            uint256 significand = uint256(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (exponent == 0x7FFFF) {\\n                if (significand > 0) return NaN;\\n                else return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            }\\n\\n            if (exponent > 278526) {\\n                return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            } else if (exponent < 245649) {\\n                return negative ? NEGATIVE_ZERO : POSITIVE_ZERO;\\n            } else if (exponent < 245761) {\\n                significand =\\n                    (significand | 0x100000000000000000000000000000000000000000000000000000000000) >> 245885 - exponent;\\n                exponent = 0;\\n            } else {\\n                significand >>= 124;\\n                exponent -= 245760;\\n            }\\n\\n            uint128 result = uint128(significand | exponent << 112);\\n            if (negative) result |= 0x80000000000000000000000000000000;\\n\\n            return bytes16(result);\\n        }\\n    }\\n\\n    /**\\n     * Convert quadruple precision number into octuple precision number.\\n     *\\n     * @param x quadruple precision number\\n     * @return octuple precision number\\n     */\\n    function toOctuple(bytes16 x) internal pure returns (bytes32) {\\n        unchecked {\\n            uint256 exponent = uint128(x) >> 112 & 0x7FFF;\\n\\n            uint256 result = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (exponent == 0x7FFF) {\\n                exponent = 0x7FFFF;\\n            } // Infinity or NaN\\n            else if (exponent == 0) {\\n                if (result > 0) {\\n                    uint256 msb = mostSignificantBit(result);\\n                    result = result << 236 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                    exponent = 245649 + msb;\\n                }\\n            } else {\\n                result <<= 124;\\n                exponent += 245760;\\n            }\\n\\n            result |= exponent << 236;\\n            if (uint128(x) >= 0x80000000000000000000000000000000) {\\n                result |= 0x8000000000000000000000000000000000000000000000000000000000000000;\\n            }\\n\\n            return bytes32(result);\\n        }\\n    }\\n\\n    /**\\n     * Convert double precision number into quadruple precision number.\\n     *\\n     * @param x double precision number\\n     * @return quadruple precision number\\n     */\\n    function fromDouble(bytes8 x) internal pure returns (bytes16) {\\n        unchecked {\\n            uint256 exponent = uint64(x) >> 52 & 0x7FF;\\n\\n            uint256 result = uint64(x) & 0xFFFFFFFFFFFFF;\\n\\n            if (exponent == 0x7FF) {\\n                exponent = 0x7FFF;\\n            } // Infinity or NaN\\n            else if (exponent == 0) {\\n                if (result > 0) {\\n                    uint256 msb = mostSignificantBit(result);\\n                    result = result << 112 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                    exponent = 15309 + msb;\\n                }\\n            } else {\\n                result <<= 60;\\n                exponent += 15360;\\n            }\\n\\n            result |= exponent << 112;\\n            if (x & 0x8000000000000000 > 0) {\\n                result |= 0x80000000000000000000000000000000;\\n            }\\n\\n            return bytes16(uint128(result));\\n        }\\n    }\\n\\n    /**\\n     * Convert quadruple precision number into double precision number.\\n     *\\n     * @param x quadruple precision number\\n     * @return double precision number\\n     */\\n    function toDouble(bytes16 x) internal pure returns (bytes8) {\\n        unchecked {\\n            bool negative = uint128(x) >= 0x80000000000000000000000000000000;\\n\\n            uint256 exponent = uint128(x) >> 112 & 0x7FFF;\\n            uint256 significand = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (exponent == 0x7FFF) {\\n                if (significand > 0) {\\n                    return 0x7FF8000000000000;\\n                } // NaN\\n                else {\\n                    return negative\\n                        ? bytes8(0xFFF0000000000000) // -Infinity\\n                        : bytes8(0x7FF0000000000000);\\n                } // Infinity\\n            }\\n\\n            if (exponent > 17406) {\\n                return negative\\n                    ? bytes8(0xFFF0000000000000) // -Infinity\\n                    : bytes8(0x7FF0000000000000);\\n            } // Infinity\\n            else if (exponent < 15309) {\\n                return negative\\n                    ? bytes8(0x8000000000000000) // -0\\n                    : bytes8(0x0000000000000000);\\n            } // 0\\n            else if (exponent < 15361) {\\n                significand = (significand | 0x10000000000000000000000000000) >> 15421 - exponent;\\n                exponent = 0;\\n            } else {\\n                significand >>= 60;\\n                exponent -= 15360;\\n            }\\n\\n            uint64 result = uint64(significand | exponent << 52);\\n            if (negative) result |= 0x8000000000000000;\\n\\n            return bytes8(result);\\n        }\\n    }\\n\\n    /**\\n     * Test whether given quadruple precision number is NaN.\\n     *\\n     * @param x quadruple precision number\\n     * @return true if x is NaN, false otherwise\\n     */\\n    function isNaN(bytes16 x) internal pure returns (bool) {\\n        unchecked {\\n            return uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF > 0x7FFF0000000000000000000000000000;\\n        }\\n    }\\n\\n    /**\\n     * Test whether given quadruple precision number is positive or negative\\n     * infinity.\\n     *\\n     * @param x quadruple precision number\\n     * @return true if x is positive or negative infinity, false otherwise\\n     */\\n    function isInfinity(bytes16 x) internal pure returns (bool) {\\n        unchecked {\\n            return uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0x7FFF0000000000000000000000000000;\\n        }\\n    }\\n\\n    /**\\n     * Calculate sign of x, i.e. -1 if x is negative, 0 if x if zero, and 1 if x\\n     * is positive.  Note that sign (-0) is zero.  Revert if x is NaN.\\n     *\\n     * @param x quadruple precision number\\n     * @return sign of x\\n     */\\n    function sign(bytes16 x) internal pure returns (int8) {\\n        unchecked {\\n            uint128 absoluteX = uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            require(absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n            if (absoluteX == 0) return 0;\\n            else if (uint128(x) >= 0x80000000000000000000000000000000) return -1;\\n            else return 1;\\n        }\\n    }\\n\\n    /**\\n     * Calculate sign (x - y).  Revert if either argument is NaN, or both\\n     * arguments are infinities of the same sign.\\n     *\\n     * @param x quadruple precision number\\n     * @param y quadruple precision number\\n     * @return sign (x - y)\\n     */\\n    function cmp(bytes16 x, bytes16 y) internal pure returns (int8) {\\n        unchecked {\\n            uint128 absoluteX = uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            require(absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n            uint128 absoluteY = uint128(y) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            require(absoluteY <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n            // Not infinities of the same sign\\n            require(x != y || absoluteX < 0x7FFF0000000000000000000000000000);\\n\\n            if (x == y) {\\n                return 0;\\n            } else {\\n                bool negativeX = uint128(x) >= 0x80000000000000000000000000000000;\\n                bool negativeY = uint128(y) >= 0x80000000000000000000000000000000;\\n\\n                if (negativeX) {\\n                    if (negativeY) return absoluteX > absoluteY ? -1 : int8(1);\\n                    else return -1;\\n                } else {\\n                    if (negativeY) return 1;\\n                    else return absoluteX > absoluteY ? int8(1) : -1;\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Test whether x equals y.  NaN, infinity, and -infinity are not equal to\\n     * anything.\\n     *\\n     * @param x quadruple precision number\\n     * @param y quadruple precision number\\n     * @return true if x equals to y, false otherwise\\n     */\\n    function eq(bytes16 x, bytes16 y) internal pure returns (bool) {\\n        unchecked {\\n            if (x == y) {\\n                return uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF < 0x7FFF0000000000000000000000000000;\\n            } else {\\n                return false;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Calculate x + y.  Special values behave in the following way:\\n     *\\n     * NaN + x = NaN for any x.\\n     * Infinity + x = Infinity for any finite x.\\n     * -Infinity + x = -Infinity for any finite x.\\n     * Infinity + Infinity = Infinity.\\n     * -Infinity + -Infinity = -Infinity.\\n     * Infinity + -Infinity = -Infinity + Infinity = NaN.\\n     *\\n     * @param x quadruple precision number\\n     * @param y quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function add(bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n        unchecked {\\n            uint256 xExponent = uint128(x) >> 112 & 0x7FFF;\\n            uint256 yExponent = uint128(y) >> 112 & 0x7FFF;\\n\\n            if (xExponent == 0x7FFF) {\\n                if (yExponent == 0x7FFF) {\\n                    if (x == y) return x;\\n                    else return NaN;\\n                } else {\\n                    return x;\\n                }\\n            } else if (yExponent == 0x7FFF) {\\n                return y;\\n            } else {\\n                bool xSign = uint128(x) >= 0x80000000000000000000000000000000;\\n                uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                if (xExponent == 0) xExponent = 1;\\n                else xSignifier |= 0x10000000000000000000000000000;\\n\\n                bool ySign = uint128(y) >= 0x80000000000000000000000000000000;\\n                uint256 ySignifier = uint128(y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                if (yExponent == 0) yExponent = 1;\\n                else ySignifier |= 0x10000000000000000000000000000;\\n\\n                if (xSignifier == 0) {\\n                    return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\\n                } else if (ySignifier == 0) {\\n                    return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\\n                } else {\\n                    int256 delta = int256(xExponent) - int256(yExponent);\\n\\n                    if (xSign == ySign) {\\n                        if (delta > 112) {\\n                            return x;\\n                        } else if (delta > 0) {\\n                            ySignifier >>= uint256(delta);\\n                        } else if (delta < -112) {\\n                            return y;\\n                        } else if (delta < 0) {\\n                            xSignifier >>= uint256(-delta);\\n                            xExponent = yExponent;\\n                        }\\n\\n                        xSignifier += ySignifier;\\n\\n                        if (xSignifier >= 0x20000000000000000000000000000) {\\n                            xSignifier >>= 1;\\n                            xExponent += 1;\\n                        }\\n\\n                        if (xExponent == 0x7FFF) {\\n                            return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n                        } else {\\n                            if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\\n                            else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n                            return bytes16(\\n                                uint128(\\n                                    (xSign ? 0x80000000000000000000000000000000 : 0) | (xExponent << 112) | xSignifier\\n                                )\\n                            );\\n                        }\\n                    } else {\\n                        if (delta > 0) {\\n                            xSignifier <<= 1;\\n                            xExponent -= 1;\\n                        } else if (delta < 0) {\\n                            ySignifier <<= 1;\\n                            xExponent = yExponent - 1;\\n                        }\\n\\n                        if (delta > 112) ySignifier = 1;\\n                        else if (delta > 1) ySignifier = (ySignifier - 1 >> uint256(delta - 1)) + 1;\\n                        else if (delta < -112) xSignifier = 1;\\n                        else if (delta < -1) xSignifier = (xSignifier - 1 >> uint256(-delta - 1)) + 1;\\n\\n                        if (xSignifier >= ySignifier) {\\n                            xSignifier -= ySignifier;\\n                        } else {\\n                            xSignifier = ySignifier - xSignifier;\\n                            xSign = ySign;\\n                        }\\n\\n                        if (xSignifier == 0) {\\n                            return POSITIVE_ZERO;\\n                        }\\n\\n                        uint256 msb = mostSignificantBit(xSignifier);\\n\\n                        if (msb == 113) {\\n                            xSignifier = xSignifier >> 1 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                            xExponent += 1;\\n                        } else if (msb < 112) {\\n                            uint256 shift = 112 - msb;\\n                            if (xExponent > shift) {\\n                                xSignifier = xSignifier << shift & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                                xExponent -= shift;\\n                            } else {\\n                                xSignifier <<= xExponent - 1;\\n                                xExponent = 0;\\n                            }\\n                        } else {\\n                            xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                        }\\n\\n                        if (xExponent == 0x7FFF) {\\n                            return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n                        } else {\\n                            return bytes16(\\n                                uint128(\\n                                    (xSign ? 0x80000000000000000000000000000000 : 0) | (xExponent << 112) | xSignifier\\n                                )\\n                            );\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Calculate x - y.  Special values behave in the following way:\\n     *\\n     * NaN - x = NaN for any x.\\n     * Infinity - x = Infinity for any finite x.\\n     * -Infinity - x = -Infinity for any finite x.\\n     * Infinity - -Infinity = Infinity.\\n     * -Infinity - Infinity = -Infinity.\\n     * Infinity - Infinity = -Infinity - -Infinity = NaN.\\n     *\\n     * @param x quadruple precision number\\n     * @param y quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function sub(bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n        unchecked {\\n            return add(x, y ^ 0x80000000000000000000000000000000);\\n        }\\n    }\\n\\n    /**\\n     * Calculate x * y.  Special values behave in the following way:\\n     *\\n     * NaN * x = NaN for any x.\\n     * Infinity * x = Infinity for any finite positive x.\\n     * Infinity * x = -Infinity for any finite negative x.\\n     * -Infinity * x = -Infinity for any finite positive x.\\n     * -Infinity * x = Infinity for any finite negative x.\\n     * Infinity * 0 = NaN.\\n     * -Infinity * 0 = NaN.\\n     * Infinity * Infinity = Infinity.\\n     * Infinity * -Infinity = -Infinity.\\n     * -Infinity * Infinity = -Infinity.\\n     * -Infinity * -Infinity = Infinity.\\n     *\\n     * @param x quadruple precision number\\n     * @param y quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function mul(bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n        unchecked {\\n            uint256 xExponent = uint128(x) >> 112 & 0x7FFF;\\n            uint256 yExponent = uint128(y) >> 112 & 0x7FFF;\\n\\n            if (xExponent == 0x7FFF) {\\n                if (yExponent == 0x7FFF) {\\n                    if (x == y) return x ^ y & 0x80000000000000000000000000000000;\\n                    else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\\n                    else return NaN;\\n                } else {\\n                    if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n                    else return x ^ y & 0x80000000000000000000000000000000;\\n                }\\n            } else if (yExponent == 0x7FFF) {\\n                if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n                else return y ^ x & 0x80000000000000000000000000000000;\\n            } else {\\n                uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                if (xExponent == 0) xExponent = 1;\\n                else xSignifier |= 0x10000000000000000000000000000;\\n\\n                uint256 ySignifier = uint128(y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                if (yExponent == 0) yExponent = 1;\\n                else ySignifier |= 0x10000000000000000000000000000;\\n\\n                xSignifier *= ySignifier;\\n                if (xSignifier == 0) {\\n                    return (x ^ y) & 0x80000000000000000000000000000000 > 0 ? NEGATIVE_ZERO : POSITIVE_ZERO;\\n                }\\n\\n                xExponent += yExponent;\\n\\n                uint256 msb = xSignifier >= 0x200000000000000000000000000000000000000000000000000000000\\n                    ? 225\\n                    : xSignifier >= 0x100000000000000000000000000000000000000000000000000000000\\n                        ? 224\\n                        : mostSignificantBit(xSignifier);\\n\\n                if (xExponent + msb < 16496) {\\n                    // Underflow\\n                    xExponent = 0;\\n                    xSignifier = 0;\\n                } else if (xExponent + msb < 16608) {\\n                    // Subnormal\\n                    if (xExponent < 16496) {\\n                        xSignifier >>= 16496 - xExponent;\\n                    } else if (xExponent > 16496) {\\n                        xSignifier <<= xExponent - 16496;\\n                    }\\n                    xExponent = 0;\\n                } else if (xExponent + msb > 49373) {\\n                    xExponent = 0x7FFF;\\n                    xSignifier = 0;\\n                } else {\\n                    if (msb > 112) {\\n                        xSignifier >>= msb - 112;\\n                    } else if (msb < 112) {\\n                        xSignifier <<= 112 - msb;\\n                    }\\n\\n                    xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n                    xExponent = xExponent + msb - 16607;\\n                }\\n\\n                return bytes16(\\n                    uint128(uint128((x ^ y) & 0x80000000000000000000000000000000) | xExponent << 112 | xSignifier)\\n                );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Calculate x / y.  Special values behave in the following way:\\n     *\\n     * NaN / x = NaN for any x.\\n     * x / NaN = NaN for any x.\\n     * Infinity / x = Infinity for any finite non-negative x.\\n     * Infinity / x = -Infinity for any finite negative x including -0.\\n     * -Infinity / x = -Infinity for any finite non-negative x.\\n     * -Infinity / x = Infinity for any finite negative x including -0.\\n     * x / Infinity = 0 for any finite non-negative x.\\n     * x / -Infinity = -0 for any finite non-negative x.\\n     * x / Infinity = -0 for any finite non-negative x including -0.\\n     * x / -Infinity = 0 for any finite non-negative x including -0.\\n     *\\n     * Infinity / Infinity = NaN.\\n     * Infinity / -Infinity = -NaN.\\n     * -Infinity / Infinity = -NaN.\\n     * -Infinity / -Infinity = NaN.\\n     *\\n     * Division by zero behaves in the following way:\\n     *\\n     * x / 0 = Infinity for any finite positive x.\\n     * x / -0 = -Infinity for any finite positive x.\\n     * x / 0 = -Infinity for any finite negative x.\\n     * x / -0 = Infinity for any finite negative x.\\n     * 0 / 0 = NaN.\\n     * 0 / -0 = NaN.\\n     * -0 / 0 = NaN.\\n     * -0 / -0 = NaN.\\n     *\\n     * @param x quadruple precision number\\n     * @param y quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function div(bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n        unchecked {\\n            uint256 xExponent = uint128(x) >> 112 & 0x7FFF;\\n            uint256 yExponent = uint128(y) >> 112 & 0x7FFF;\\n\\n            if (xExponent == 0x7FFF) {\\n                if (yExponent == 0x7FFF) return NaN;\\n                else return x ^ y & 0x80000000000000000000000000000000;\\n            } else if (yExponent == 0x7FFF) {\\n                if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\\n                else return POSITIVE_ZERO | (x ^ y) & 0x80000000000000000000000000000000;\\n            } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\\n                if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n                else return POSITIVE_INFINITY | (x ^ y) & 0x80000000000000000000000000000000;\\n            } else {\\n                uint256 ySignifier = uint128(y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                if (yExponent == 0) yExponent = 1;\\n                else ySignifier |= 0x10000000000000000000000000000;\\n\\n                uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                if (xExponent == 0) {\\n                    if (xSignifier != 0) {\\n                        uint256 shift = 226 - mostSignificantBit(xSignifier);\\n\\n                        xSignifier <<= shift;\\n\\n                        xExponent = 1;\\n                        yExponent += shift - 114;\\n                    }\\n                } else {\\n                    xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\\n                }\\n\\n                xSignifier = xSignifier / ySignifier;\\n                if (xSignifier == 0) {\\n                    return (x ^ y) & 0x80000000000000000000000000000000 > 0 ? NEGATIVE_ZERO : POSITIVE_ZERO;\\n                }\\n\\n                assert(xSignifier >= 0x1000000000000000000000000000);\\n\\n                uint256 msb = xSignifier >= 0x80000000000000000000000000000\\n                    ? mostSignificantBit(xSignifier)\\n                    : xSignifier >= 0x40000000000000000000000000000\\n                        ? 114\\n                        : xSignifier >= 0x20000000000000000000000000000 ? 113 : 112;\\n\\n                if (xExponent + msb > yExponent + 16497) {\\n                    // Overflow\\n                    xExponent = 0x7FFF;\\n                    xSignifier = 0;\\n                } else if (xExponent + msb + 16380 < yExponent) {\\n                    // Underflow\\n                    xExponent = 0;\\n                    xSignifier = 0;\\n                } else if (xExponent + msb + 16268 < yExponent) {\\n                    // Subnormal\\n                    if (xExponent + 16380 > yExponent) {\\n                        xSignifier <<= xExponent + 16380 - yExponent;\\n                    } else if (xExponent + 16380 < yExponent) {\\n                        xSignifier >>= yExponent - xExponent - 16380;\\n                    }\\n\\n                    xExponent = 0;\\n                } else {\\n                    // Normal\\n                    if (msb > 112) {\\n                        xSignifier >>= msb - 112;\\n                    }\\n\\n                    xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n                    xExponent = xExponent + msb + 16269 - yExponent;\\n                }\\n\\n                return bytes16(\\n                    uint128(uint128((x ^ y) & 0x80000000000000000000000000000000) | xExponent << 112 | xSignifier)\\n                );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Calculate -x.\\n     *\\n     * @param x quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function neg(bytes16 x) internal pure returns (bytes16) {\\n        unchecked {\\n            return x ^ 0x80000000000000000000000000000000;\\n        }\\n    }\\n\\n    /**\\n     * Calculate |x|.\\n     *\\n     * @param x quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function abs(bytes16 x) internal pure returns (bytes16) {\\n        unchecked {\\n            return x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        }\\n    }\\n\\n    /**\\n     * Calculate square root of x.  Return NaN on negative x excluding -0.\\n     *\\n     * @param x quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function sqrt(bytes16 x) internal pure returns (bytes16) {\\n        unchecked {\\n            if (uint128(x) > 0x80000000000000000000000000000000) {\\n                return NaN;\\n            } else {\\n                uint256 xExponent = uint128(x) >> 112 & 0x7FFF;\\n                if (xExponent == 0x7FFF) {\\n                    return x;\\n                } else {\\n                    uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                    if (xExponent == 0) xExponent = 1;\\n                    else xSignifier |= 0x10000000000000000000000000000;\\n\\n                    if (xSignifier == 0) return POSITIVE_ZERO;\\n\\n                    bool oddExponent = xExponent & 0x1 == 0;\\n                    xExponent = xExponent + 16383 >> 1;\\n\\n                    if (oddExponent) {\\n                        if (xSignifier >= 0x10000000000000000000000000000) {\\n                            xSignifier <<= 113;\\n                        } else {\\n                            uint256 msb = mostSignificantBit(xSignifier);\\n                            uint256 shift = (226 - msb) & 0xFE;\\n                            xSignifier <<= shift;\\n                            xExponent -= shift - 112 >> 1;\\n                        }\\n                    } else {\\n                        if (xSignifier >= 0x10000000000000000000000000000) {\\n                            xSignifier <<= 112;\\n                        } else {\\n                            uint256 msb = mostSignificantBit(xSignifier);\\n                            uint256 shift = (225 - msb) & 0xFE;\\n                            xSignifier <<= shift;\\n                            xExponent -= shift - 112 >> 1;\\n                        }\\n                    }\\n\\n                    uint256 r = 0x10000000000000000000000000000;\\n                    r = (r + xSignifier / r) >> 1;\\n                    r = (r + xSignifier / r) >> 1;\\n                    r = (r + xSignifier / r) >> 1;\\n                    r = (r + xSignifier / r) >> 1;\\n                    r = (r + xSignifier / r) >> 1;\\n                    r = (r + xSignifier / r) >> 1;\\n                    r = (r + xSignifier / r) >> 1; // Seven iterations should be enough\\n                    uint256 r1 = xSignifier / r;\\n                    if (r1 < r) r = r1;\\n\\n                    return bytes16(uint128(xExponent << 112 | r & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Calculate binary logarithm of x.  Return NaN on negative x excluding -0.\\n     *\\n     * @param x quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function log_2(bytes16 x) internal pure returns (bytes16) {\\n        unchecked {\\n            if (uint128(x) > 0x80000000000000000000000000000000) {\\n                return NaN;\\n            } else if (x == 0x3FFF0000000000000000000000000000) {\\n                return POSITIVE_ZERO;\\n            } else {\\n                uint256 xExponent = uint128(x) >> 112 & 0x7FFF;\\n                if (xExponent == 0x7FFF) {\\n                    return x;\\n                } else {\\n                    uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                    if (xExponent == 0) xExponent = 1;\\n                    else xSignifier |= 0x10000000000000000000000000000;\\n\\n                    if (xSignifier == 0) return NEGATIVE_INFINITY;\\n\\n                    bool resultNegative;\\n                    uint256 resultExponent = 16495;\\n                    uint256 resultSignifier;\\n\\n                    if (xExponent >= 0x3FFF) {\\n                        resultNegative = false;\\n                        resultSignifier = xExponent - 0x3FFF;\\n                        xSignifier <<= 15;\\n                    } else {\\n                        resultNegative = true;\\n                        if (xSignifier >= 0x10000000000000000000000000000) {\\n                            resultSignifier = 0x3FFE - xExponent;\\n                            xSignifier <<= 15;\\n                        } else {\\n                            uint256 msb = mostSignificantBit(xSignifier);\\n                            resultSignifier = 16493 - msb;\\n                            xSignifier <<= 127 - msb;\\n                        }\\n                    }\\n\\n                    if (xSignifier == 0x80000000000000000000000000000000) {\\n                        if (resultNegative) resultSignifier += 1;\\n                        uint256 shift = 112 - mostSignificantBit(resultSignifier);\\n                        resultSignifier <<= shift;\\n                        resultExponent -= shift;\\n                    } else {\\n                        uint256 bb = resultNegative ? 1 : 0;\\n                        while (resultSignifier < 0x10000000000000000000000000000) {\\n                            resultSignifier <<= 1;\\n                            resultExponent -= 1;\\n\\n                            xSignifier *= xSignifier;\\n                            uint256 b = xSignifier >> 255;\\n                            resultSignifier += b ^ bb;\\n                            xSignifier >>= 127 + b;\\n                        }\\n                    }\\n\\n                    return bytes16(\\n                        uint128(\\n                            (resultNegative ? 0x80000000000000000000000000000000 : 0) | resultExponent << 112\\n                                | resultSignifier & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                        )\\n                    );\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Calculate natural logarithm of x.  Return NaN on negative x excluding -0.\\n     *\\n     * @param x quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function ln(bytes16 x) internal pure returns (bytes16) {\\n        unchecked {\\n            return mul(log_2(x), 0x3FFE62E42FEFA39EF35793C7673007E5);\\n        }\\n    }\\n\\n    /**\\n     * Calculate 2^x.\\n     *\\n     * @param x quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function pow_2(bytes16 x) internal pure returns (bytes16) {\\n        unchecked {\\n            bool xNegative = uint128(x) > 0x80000000000000000000000000000000;\\n            uint256 xExponent = uint128(x) >> 112 & 0x7FFF;\\n            uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (xExponent == 0x7FFF && xSignifier != 0) {\\n                return NaN;\\n            } else if (xExponent > 16397) {\\n                return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\\n            } else if (xExponent < 16255) {\\n                return 0x3FFF0000000000000000000000000000;\\n            } else {\\n                if (xExponent == 0) xExponent = 1;\\n                else xSignifier |= 0x10000000000000000000000000000;\\n\\n                if (xExponent > 16367) {\\n                    xSignifier <<= xExponent - 16367;\\n                } else if (xExponent < 16367) {\\n                    xSignifier >>= 16367 - xExponent;\\n                }\\n\\n                if (xNegative && xSignifier > 0x406E00000000000000000000000000000000) {\\n                    return POSITIVE_ZERO;\\n                }\\n\\n                if (!xNegative && xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\\n                    return POSITIVE_INFINITY;\\n                }\\n\\n                uint256 resultExponent = xSignifier >> 128;\\n                xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                if (xNegative && xSignifier != 0) {\\n                    xSignifier = ~xSignifier;\\n                    resultExponent += 1;\\n                }\\n\\n                uint256 resultSignifier = 0x80000000000000000000000000000000;\\n                if (xSignifier & 0x80000000000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\n                }\\n                if (xSignifier & 0x40000000000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\n                }\\n                if (xSignifier & 0x20000000000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\n                }\\n                if (xSignifier & 0x10000000000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\n                }\\n                if (xSignifier & 0x8000000000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\n                }\\n                if (xSignifier & 0x4000000000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\n                }\\n                if (xSignifier & 0x2000000000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\n                }\\n                if (xSignifier & 0x1000000000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\n                }\\n                if (xSignifier & 0x800000000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\n                }\\n                if (xSignifier & 0x400000000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\n                }\\n                if (xSignifier & 0x200000000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\n                }\\n                if (xSignifier & 0x100000000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\n                }\\n                if (xSignifier & 0x80000000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\n                }\\n                if (xSignifier & 0x40000000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\n                }\\n                if (xSignifier & 0x20000000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000162E525EE054754457D5995292026 >> 128;\\n                }\\n                if (xSignifier & 0x10000000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\n                }\\n                if (xSignifier & 0x8000000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\n                }\\n                if (xSignifier & 0x4000000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\n                }\\n                if (xSignifier & 0x2000000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\n                }\\n                if (xSignifier & 0x1000000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\n                }\\n                if (xSignifier & 0x800000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\n                }\\n                if (xSignifier & 0x400000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\n                }\\n                if (xSignifier & 0x200000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\n                }\\n                if (xSignifier & 0x100000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\n                }\\n                if (xSignifier & 0x80000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\n                }\\n                if (xSignifier & 0x40000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\n                }\\n                if (xSignifier & 0x20000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\n                }\\n                if (xSignifier & 0x10000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\n                }\\n                if (xSignifier & 0x8000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\n                }\\n                if (xSignifier & 0x4000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\n                }\\n                if (xSignifier & 0x2000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\n                }\\n                if (xSignifier & 0x1000000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\n                }\\n                if (xSignifier & 0x800000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\n                }\\n                if (xSignifier & 0x400000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\n                }\\n                if (xSignifier & 0x200000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\n                }\\n                if (xSignifier & 0x100000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\n                }\\n                if (xSignifier & 0x80000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\n                }\\n                if (xSignifier & 0x40000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\n                }\\n                if (xSignifier & 0x20000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\n                }\\n                if (xSignifier & 0x10000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\n                }\\n                if (xSignifier & 0x8000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\n                }\\n                if (xSignifier & 0x4000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000002C5C85FDF477B662B26945 >> 128;\\n                }\\n                if (xSignifier & 0x2000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000162E42FEFA3AE53369388C >> 128;\\n                }\\n                if (xSignifier & 0x1000000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000B17217F7D1D351A389D40 >> 128;\\n                }\\n                if (xSignifier & 0x800000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\n                }\\n                if (xSignifier & 0x400000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\n                }\\n                if (xSignifier & 0x200000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\n                }\\n                if (xSignifier & 0x100000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\n                }\\n                if (xSignifier & 0x80000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\n                }\\n                if (xSignifier & 0x40000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\n                }\\n                if (xSignifier & 0x20000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000162E42FEFA39F02B772C >> 128;\\n                }\\n                if (xSignifier & 0x10000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\n                }\\n                if (xSignifier & 0x8000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\n                }\\n                if (xSignifier & 0x4000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000002C5C85FDF473DEA871F >> 128;\\n                }\\n                if (xSignifier & 0x2000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\n                }\\n                if (xSignifier & 0x1000000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000B17217F7D1CF79E949 >> 128;\\n                }\\n                if (xSignifier & 0x800000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\n                }\\n                if (xSignifier & 0x400000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\n                }\\n                if (xSignifier & 0x200000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000162E42FEFA39EF366F >> 128;\\n                }\\n                if (xSignifier & 0x100000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\n                }\\n                if (xSignifier & 0x80000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\n                }\\n                if (xSignifier & 0x40000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\n                }\\n                if (xSignifier & 0x20000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000000162E42FEFA39EF358 >> 128;\\n                }\\n                if (xSignifier & 0x10000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000000B17217F7D1CF79AB >> 128;\\n                }\\n                if (xSignifier & 0x8000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5 >> 128;\\n                }\\n                if (xSignifier & 0x4000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000002C5C85FDF473DE6A >> 128;\\n                }\\n                if (xSignifier & 0x2000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000000162E42FEFA39EF34 >> 128;\\n                }\\n                if (xSignifier & 0x1000000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000000B17217F7D1CF799 >> 128;\\n                }\\n                if (xSignifier & 0x800000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000000058B90BFBE8E7BCC >> 128;\\n                }\\n                if (xSignifier & 0x400000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000000002C5C85FDF473DE5 >> 128;\\n                }\\n                if (xSignifier & 0x200000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000000162E42FEFA39EF2 >> 128;\\n                }\\n                if (xSignifier & 0x100000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000000000B17217F7D1CF78 >> 128;\\n                }\\n                if (xSignifier & 0x80000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000000058B90BFBE8E7BB >> 128;\\n                }\\n                if (xSignifier & 0x40000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000000002C5C85FDF473DD >> 128;\\n                }\\n                if (xSignifier & 0x20000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000000000162E42FEFA39EE >> 128;\\n                }\\n                if (xSignifier & 0x10000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000000000B17217F7D1CF6 >> 128;\\n                }\\n                if (xSignifier & 0x8000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000000000058B90BFBE8E7A >> 128;\\n                }\\n                if (xSignifier & 0x4000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000000002C5C85FDF473C >> 128;\\n                }\\n                if (xSignifier & 0x2000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000000000162E42FEFA39D >> 128;\\n                }\\n                if (xSignifier & 0x1000000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000000000B17217F7D1CE >> 128;\\n                }\\n                if (xSignifier & 0x800000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000000000058B90BFBE8E6 >> 128;\\n                }\\n                if (xSignifier & 0x400000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000000000002C5C85FDF472 >> 128;\\n                }\\n                if (xSignifier & 0x200000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000000000162E42FEFA38 >> 128;\\n                }\\n                if (xSignifier & 0x100000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000000000000B17217F7D1B >> 128;\\n                }\\n                if (xSignifier & 0x80000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000000000058B90BFBE8D >> 128;\\n                }\\n                if (xSignifier & 0x40000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000000000002C5C85FDF46 >> 128;\\n                }\\n                if (xSignifier & 0x20000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000000000000162E42FEFA2 >> 128;\\n                }\\n                if (xSignifier & 0x10000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000000000000B17217F7D0 >> 128;\\n                }\\n                if (xSignifier & 0x8000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000000000000058B90BFBE7 >> 128;\\n                }\\n                if (xSignifier & 0x4000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000000000002C5C85FDF3 >> 128;\\n                }\\n                if (xSignifier & 0x2000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000000000000162E42FEF9 >> 128;\\n                }\\n                if (xSignifier & 0x1000000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000000000000B17217F7C >> 128;\\n                }\\n                if (xSignifier & 0x800000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000000000000058B90BFBD >> 128;\\n                }\\n                if (xSignifier & 0x400000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000000000000002C5C85FDE >> 128;\\n                }\\n                if (xSignifier & 0x200000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000000000000162E42FEE >> 128;\\n                }\\n                if (xSignifier & 0x100000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000000000000000B17217F6 >> 128;\\n                }\\n                if (xSignifier & 0x80000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000000000000058B90BFA >> 128;\\n                }\\n                if (xSignifier & 0x40000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000000000000002C5C85FC >> 128;\\n                }\\n                if (xSignifier & 0x20000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000000000000000162E42FD >> 128;\\n                }\\n                if (xSignifier & 0x10000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000000000000000B17217E >> 128;\\n                }\\n                if (xSignifier & 0x8000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000000000000000058B90BE >> 128;\\n                }\\n                if (xSignifier & 0x4000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000000000000002C5C85E >> 128;\\n                }\\n                if (xSignifier & 0x2000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000000000000000162E42E >> 128;\\n                }\\n                if (xSignifier & 0x1000000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000000000000000B17216 >> 128;\\n                }\\n                if (xSignifier & 0x800000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000000000000000058B90A >> 128;\\n                }\\n                if (xSignifier & 0x400000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000000000000000002C5C84 >> 128;\\n                }\\n                if (xSignifier & 0x200000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000000000000000162E41 >> 128;\\n                }\\n                if (xSignifier & 0x100000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000000000000000000B1720 >> 128;\\n                }\\n                if (xSignifier & 0x80000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000000000000000058B8F >> 128;\\n                }\\n                if (xSignifier & 0x40000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000000000000000002C5C7 >> 128;\\n                }\\n                if (xSignifier & 0x20000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000000000000000000162E3 >> 128;\\n                }\\n                if (xSignifier & 0x10000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000000000000000000B171 >> 128;\\n                }\\n                if (xSignifier & 0x8000 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000000000000000000058B8 >> 128;\\n                }\\n                if (xSignifier & 0x4000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000000000000000002C5B >> 128;\\n                }\\n                if (xSignifier & 0x2000 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000000000000000000162D >> 128;\\n                }\\n                if (xSignifier & 0x1000 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000000000000000000B16 >> 128;\\n                }\\n                if (xSignifier & 0x800 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000000000000000000058A >> 128;\\n                }\\n                if (xSignifier & 0x400 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000000000000000000002C4 >> 128;\\n                }\\n                if (xSignifier & 0x200 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000000000000000000161 >> 128;\\n                }\\n                if (xSignifier & 0x100 > 0) {\\n                    resultSignifier = resultSignifier * 0x1000000000000000000000000000000B0 >> 128;\\n                }\\n                if (xSignifier & 0x80 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000000000000000000057 >> 128;\\n                }\\n                if (xSignifier & 0x40 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000000000000000000002B >> 128;\\n                }\\n                if (xSignifier & 0x20 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000000000000000000015 >> 128;\\n                }\\n                if (xSignifier & 0x10 > 0) {\\n                    resultSignifier = resultSignifier * 0x10000000000000000000000000000000A >> 128;\\n                }\\n                if (xSignifier & 0x8 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000000000000000000004 >> 128;\\n                }\\n                if (xSignifier & 0x4 > 0) {\\n                    resultSignifier = resultSignifier * 0x100000000000000000000000000000001 >> 128;\\n                }\\n\\n                if (!xNegative) {\\n                    resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                    resultExponent += 0x3FFF;\\n                } else if (resultExponent <= 0x3FFE) {\\n                    resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                    resultExponent = 0x3FFF - resultExponent;\\n                } else {\\n                    resultSignifier = resultSignifier >> resultExponent - 16367;\\n                    resultExponent = 0;\\n                }\\n\\n                return bytes16(uint128(resultExponent << 112 | resultSignifier));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Calculate e^x.\\n     *\\n     * @param x quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function exp(bytes16 x) internal pure returns (bytes16) {\\n        unchecked {\\n            return pow_2(mul(x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\\n        }\\n    }\\n\\n    /**\\n     * Get index of the most significant non-zero bit in binary representation of\\n     * x.  Reverts if x is zero.\\n     *\\n     * @return index of the most significant non-zero bit in binary representation\\n     *         of x\\n     */\\n    function mostSignificantBit(uint256 x) private pure returns (uint256) {\\n        unchecked {\\n            require(x > 0);\\n\\n            uint256 result = 0;\\n\\n            if (x >= 0x100000000000000000000000000000000) {\\n                x >>= 128;\\n                result += 128;\\n            }\\n            if (x >= 0x10000000000000000) {\\n                x >>= 64;\\n                result += 64;\\n            }\\n            if (x >= 0x100000000) {\\n                x >>= 32;\\n                result += 32;\\n            }\\n            if (x >= 0x10000) {\\n                x >>= 16;\\n                result += 16;\\n            }\\n            if (x >= 0x100) {\\n                x >>= 8;\\n                result += 8;\\n            }\\n            if (x >= 0x10) {\\n                x >>= 4;\\n                result += 4;\\n            }\\n            if (x >= 0x4) {\\n                x >>= 2;\\n                result += 2;\\n            }\\n            if (x >= 0x2) result += 1; // No need to shift x anymore\\n\\n            return result;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\ninterface IMinter {\\n    function mint(address _to, uint256 _projectId, address sender) external returns (uint256 _tokenId);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@manifoldxyz/creator-core-solidity/=lib/creator-core-solidity/\",\r\n      \"@manifoldxyz/libraries-solidity/=lib/libraries-solidity/\",\r\n      \"@manifoldxyz/royalty-registry-solidity/=lib/royalty-registry-solidity/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"create2-helpers/=lib/royalty-registry-solidity/lib/create2-helpers/\",\r\n      \"create2-scripts/=lib/royalty-registry-solidity/lib/create2-helpers/script/\",\r\n      \"creator-core-solidity/=lib/creator-core-solidity/contracts/\",\r\n      \"libraries-solidity/=lib/libraries-solidity/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"royalty-registry-solidity/=lib/royalty-registry-solidity/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IMinter\",\"name\":\"passes_\",\"type\":\"address\"},{\"internalType\":\"contract IERC721\",\"name\":\"mintPasses_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startPrice_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"restPrice_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceDropSlot_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"halfPeriod_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxMint_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minMintPasses_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"projectId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pauser\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyStarted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"FailedPaying\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintNotAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotYetStarted\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Blacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newMintPasses\",\"type\":\"address\"}],\"name\":\"MintPassesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"}],\"name\":\"MintPublicUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Purchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unblacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BaseValue\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HalfPeriod\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAUSER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decayTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"halfPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minMintPasses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mintCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"mintMultiple\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPasses\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPublic\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterType\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextPriceDrop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"passes\",\"outputs\":[{\"internalType\":\"contract IMinter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceDropSlot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxMint_\",\"type\":\"uint256\"}],\"name\":\"setMaxMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minMintPasses_\",\"type\":\"uint256\"}],\"name\":\"setMinMintPasses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"mintPasses_\",\"type\":\"address\"}],\"name\":\"setMintPasses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"mintPublic_\",\"type\":\"bool\"}],\"name\":\"setMintPublic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMinter\",\"name\":\"passes_\",\"type\":\"address\"}],\"name\":\"setPasses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startPrice_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"restPrice_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceDropSlot_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"halfPeriod_\",\"type\":\"uint256\"}],\"name\":\"setPriceRange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId_\",\"type\":\"uint256\"}],\"name\":\"setProjectId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime_\",\"type\":\"uint256\"}],\"name\":\"setStartTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DutchAuctionMinter", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007e5236e3b67c13fefd4f8c3998767409688cea360000000000000000000000006864cc3b8cfdcfa8cfb22e9fe732cc6feff4e74000000000000000000000000000000000000000000000000000000000650afae00000000000000000000000000000000000000000000000007ce66c50e2840000000000000000000000000000000000000000000000000000044d575b885f0000000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000002e500000000000000000000000000000000000000000000000000000000000000c8000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000006b15fd9cc33dd0852f80567549e552d20a5bdce3000000000000000000000000e72669723c4fbe29ad77bcf745a58238acc82374", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}