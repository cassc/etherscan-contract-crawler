{"SourceCode": "// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\npragma experimental \"ABIEncoderV2\";\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://eips.ethereum.org/EIPS/eip-20\r\n * Originally based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n *\r\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\r\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\r\n * compliant implementations may not do it.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev Total number of tokens in existence\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param owner The address to query the balance of.\r\n     * @return A uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token to a specified address\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n     * Note that while this function emits an Approval event, this is not required as per the specification,\r\n     * and other compliant implementations may not emit the event.\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        _transfer(from, to, value);\r\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token for a specified addresses\r\n     * @param from The address to transfer from.\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0));\r\n\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that mints an amount of the token and assigns it to\r\n     * an account. This encapsulates the modification of balances such that the\r\n     * proper events are emitted.\r\n     * @param account The account that will receive the created tokens.\r\n     * @param value The amount that will be created.\r\n     */\r\n    function _mint(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.add(value);\r\n        _balances[account] = _balances[account].add(value);\r\n        emit Transfer(address(0), account, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account.\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve an address to spend another addresses' tokens.\r\n     * @param owner The address that owns the tokens.\r\n     * @param spender The address that will spend the tokens.\r\n     * @param value The number of tokens that can be spent.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(spender != address(0));\r\n        require(owner != address(0));\r\n\r\n        _allowed[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account, deducting from the sender's allowance for said account. Uses the\r\n     * internal burn function.\r\n     * Emits an Approval event (reflecting the reduced allowance).\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burnFrom(address account, uint256 value) internal {\r\n        _burn(account, value);\r\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title ERC20Detailed token\r\n * @dev The decimals are only for visualization purposes.\r\n * All the operations are done using the smallest and indivisible token unit,\r\n * just as on Ethereum all the operations are done in wei.\r\n */\r\ncontract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    /**\r\n     * @return the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @return the symbol of the token.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @return the number of decimals of the token.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/CommonMath.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\nlibrary CommonMath {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * Calculates and returns the maximum value for a uint256\r\n     *\r\n     * @return  The maximum value for uint256\r\n     */\r\n    function maxUInt256()\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return 2 ** 256 - 1;\r\n    }\r\n\r\n    /**\r\n    * @dev Performs the power on a specified value, reverts on overflow.\r\n    */\r\n    function safePower(\r\n        uint256 a,\r\n        uint256 pow\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(a > 0);\r\n\r\n        uint256 result = 1;\r\n        for (uint256 i = 0; i < pow; i++){\r\n            uint256 previousResult = result;\r\n\r\n            // Using safemath multiplication prevents overflows\r\n            result = previousResult.mul(a);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Checks for rounding errors and returns value of potential partial amounts of a principal\r\n     *\r\n     * @param  _principal       Number fractional amount is derived from\r\n     * @param  _numerator       Numerator of fraction\r\n     * @param  _denominator     Denominator of fraction\r\n     * @return uint256          Fractional amount of principal calculated\r\n     */\r\n    function getPartialAmount(\r\n        uint256 _principal,\r\n        uint256 _numerator,\r\n        uint256 _denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // Get remainder of partial amount (if 0 not a partial amount)\r\n        uint256 remainder = mulmod(_principal, _numerator, _denominator);\r\n\r\n        // Return if not a partial amount\r\n        if (remainder == 0) {\r\n            return _principal.mul(_numerator).div(_denominator);\r\n        }\r\n\r\n        // Calculate error percentage\r\n        uint256 errPercentageTimes1000000 = remainder.mul(1000000).div(_numerator.mul(_principal));\r\n\r\n        // Require error percentage is less than 0.1%.\r\n        require(\r\n            errPercentageTimes1000000 < 1000,\r\n            \"CommonMath.getPartialAmount: Rounding error exceeds bounds\"\r\n        );\r\n\r\n        return _principal.mul(_numerator).div(_denominator);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/core/interfaces/ICore.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title ICore\r\n * @author Set Protocol\r\n *\r\n * The ICore Contract defines all the functions exposed in the Core through its\r\n * various extensions and is a light weight way to interact with the contract.\r\n */\r\ninterface ICore {\r\n    /**\r\n     * Return transferProxy address.\r\n     *\r\n     * @return address       transferProxy address\r\n     */\r\n    function transferProxy()\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /**\r\n     * Return vault address.\r\n     *\r\n     * @return address       vault address\r\n     */\r\n    function vault()\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /**\r\n     * Return address belonging to given exchangeId.\r\n     *\r\n     * @param  _exchangeId       ExchangeId number\r\n     * @return address           Address belonging to given exchangeId\r\n     */\r\n    function exchangeIds(\r\n        uint8 _exchangeId\r\n    )\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /*\r\n     * Returns if valid set\r\n     *\r\n     * @return  bool      Returns true if Set created through Core and isn't disabled\r\n     */\r\n    function validSets(address)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /*\r\n     * Returns if valid module\r\n     *\r\n     * @return  bool      Returns true if valid module\r\n     */\r\n    function validModules(address)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * Return boolean indicating if address is a valid Rebalancing Price Library.\r\n     *\r\n     * @param  _priceLibrary    Price library address\r\n     * @return bool             Boolean indicating if valid Price Library\r\n     */\r\n    function validPriceLibraries(\r\n        address _priceLibrary\r\n    )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * Exchanges components for Set Tokens\r\n     *\r\n     * @param  _set          Address of set to issue\r\n     * @param  _quantity     Quantity of set to issue\r\n     */\r\n    function issue(\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Issues a specified Set for a specified quantity to the recipient\r\n     * using the caller's components from the wallet and vault.\r\n     *\r\n     * @param  _recipient    Address to issue to\r\n     * @param  _set          Address of the Set to issue\r\n     * @param  _quantity     Number of tokens to issue\r\n     */\r\n    function issueTo(\r\n        address _recipient,\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Converts user's components into Set Tokens held directly in Vault instead of user's account\r\n     *\r\n     * @param _set          Address of the Set\r\n     * @param _quantity     Number of tokens to redeem\r\n     */\r\n    function issueInVault(\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Function to convert Set Tokens into underlying components\r\n     *\r\n     * @param _set          The address of the Set token\r\n     * @param _quantity     The number of tokens to redeem. Should be multiple of natural unit.\r\n     */\r\n    function redeem(\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Redeem Set token and return components to specified recipient. The components\r\n     * are left in the vault\r\n     *\r\n     * @param _recipient    Recipient of Set being issued\r\n     * @param _set          Address of the Set\r\n     * @param _quantity     Number of tokens to redeem\r\n     */\r\n    function redeemTo(\r\n        address _recipient,\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Function to convert Set Tokens held in vault into underlying components\r\n     *\r\n     * @param _set          The address of the Set token\r\n     * @param _quantity     The number of tokens to redeem. Should be multiple of natural unit.\r\n     */\r\n    function redeemInVault(\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Composite method to redeem and withdraw with a single transaction\r\n     *\r\n     * Normally, you should expect to be able to withdraw all of the tokens.\r\n     * However, some have central abilities to freeze transfers (e.g. EOS). _toExclude\r\n     * allows you to optionally specify which component tokens to exclude when\r\n     * redeeming. They will remain in the vault under the users' addresses.\r\n     *\r\n     * @param _set          Address of the Set\r\n     * @param _to           Address to withdraw or attribute tokens to\r\n     * @param _quantity     Number of tokens to redeem\r\n     * @param _toExclude    Mask of indexes of tokens to exclude from withdrawing\r\n     */\r\n    function redeemAndWithdrawTo(\r\n        address _set,\r\n        address _to,\r\n        uint256 _quantity,\r\n        uint256 _toExclude\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Deposit multiple tokens to the vault. Quantities should be in the\r\n     * order of the addresses of the tokens being deposited.\r\n     *\r\n     * @param  _tokens           Array of the addresses of the ERC20 tokens\r\n     * @param  _quantities       Array of the number of tokens to deposit\r\n     */\r\n    function batchDeposit(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Withdraw multiple tokens from the vault. Quantities should be in the\r\n     * order of the addresses of the tokens being withdrawn.\r\n     *\r\n     * @param  _tokens            Array of the addresses of the ERC20 tokens\r\n     * @param  _quantities        Array of the number of tokens to withdraw\r\n     */\r\n    function batchWithdraw(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Deposit any quantity of tokens into the vault.\r\n     *\r\n     * @param  _token           The address of the ERC20 token\r\n     * @param  _quantity        The number of tokens to deposit\r\n     */\r\n    function deposit(\r\n        address _token,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Withdraw a quantity of tokens from the vault.\r\n     *\r\n     * @param  _token           The address of the ERC20 token\r\n     * @param  _quantity        The number of tokens to withdraw\r\n     */\r\n    function withdraw(\r\n        address _token,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Transfer tokens associated with the sender's account in vault to another user's\r\n     * account in vault.\r\n     *\r\n     * @param  _token           Address of token being transferred\r\n     * @param  _to              Address of user receiving tokens\r\n     * @param  _quantity        Amount of tokens being transferred\r\n     */\r\n    function internalTransfer(\r\n        address _token,\r\n        address _to,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Deploys a new Set Token and adds it to the valid list of SetTokens\r\n     *\r\n     * @param  _factory              The address of the Factory to create from\r\n     * @param  _components           The address of component tokens\r\n     * @param  _units                The units of each component token\r\n     * @param  _naturalUnit          The minimum unit to be issued or redeemed\r\n     * @param  _name                 The bytes32 encoded name of the new Set\r\n     * @param  _symbol               The bytes32 encoded symbol of the new Set\r\n     * @param  _callData             Byte string containing additional call parameters\r\n     * @return setTokenAddress       The address of the new Set\r\n     */\r\n    function createSet(\r\n        address _factory,\r\n        address[] calldata _components,\r\n        uint256[] calldata _units,\r\n        uint256 _naturalUnit,\r\n        bytes32 _name,\r\n        bytes32 _symbol,\r\n        bytes calldata _callData\r\n    )\r\n        external\r\n        returns (address);\r\n\r\n    /**\r\n     * Exposes internal function that deposits a quantity of tokens to the vault and attributes\r\n     * the tokens respectively, to system modules.\r\n     *\r\n     * @param  _from            Address to transfer tokens from\r\n     * @param  _to              Address to credit for deposit\r\n     * @param  _token           Address of token being deposited\r\n     * @param  _quantity        Amount of tokens to deposit\r\n     */\r\n    function depositModule(\r\n        address _from,\r\n        address _to,\r\n        address _token,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Exposes internal function that withdraws a quantity of tokens from the vault and\r\n     * deattributes the tokens respectively, to system modules.\r\n     *\r\n     * @param  _from            Address to decredit for withdraw\r\n     * @param  _to              Address to transfer tokens to\r\n     * @param  _token           Address of token being withdrawn\r\n     * @param  _quantity        Amount of tokens to withdraw\r\n     */\r\n    function withdrawModule(\r\n        address _from,\r\n        address _to,\r\n        address _token,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Exposes internal function that deposits multiple tokens to the vault, to system\r\n     * modules. Quantities should be in the order of the addresses of the tokens being\r\n     * deposited.\r\n     *\r\n     * @param  _from              Address to transfer tokens from\r\n     * @param  _to                Address to credit for deposits\r\n     * @param  _tokens            Array of the addresses of the tokens being deposited\r\n     * @param  _quantities        Array of the amounts of tokens to deposit\r\n     */\r\n    function batchDepositModule(\r\n        address _from,\r\n        address _to,\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Exposes internal function that withdraws multiple tokens from the vault, to system\r\n     * modules. Quantities should be in the order of the addresses of the tokens being withdrawn.\r\n     *\r\n     * @param  _from              Address to decredit for withdrawals\r\n     * @param  _to                Address to transfer tokens to\r\n     * @param  _tokens            Array of the addresses of the tokens being withdrawn\r\n     * @param  _quantities        Array of the amounts of tokens to withdraw\r\n     */\r\n    function batchWithdrawModule(\r\n        address _from,\r\n        address _to,\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Expose internal function that exchanges components for Set tokens,\r\n     * accepting any owner, to system modules\r\n     *\r\n     * @param  _owner        Address to use tokens from\r\n     * @param  _recipient    Address to issue Set to\r\n     * @param  _set          Address of the Set to issue\r\n     * @param  _quantity     Number of tokens to issue\r\n     */\r\n    function issueModule(\r\n        address _owner,\r\n        address _recipient,\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Expose internal function that exchanges Set tokens for components,\r\n     * accepting any owner, to system modules\r\n     *\r\n     * @param  _burnAddress         Address to burn token from\r\n     * @param  _incrementAddress    Address to increment component tokens to\r\n     * @param  _set                 Address of the Set to redeem\r\n     * @param  _quantity            Number of tokens to redeem\r\n     */\r\n    function redeemModule(\r\n        address _burnAddress,\r\n        address _incrementAddress,\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Expose vault function that increments user's balance in the vault.\r\n     * Available to system modules\r\n     *\r\n     * @param  _tokens          The addresses of the ERC20 tokens\r\n     * @param  _owner           The address of the token owner\r\n     * @param  _quantities      The numbers of tokens to attribute to owner\r\n     */\r\n    function batchIncrementTokenOwnerModule(\r\n        address[] calldata _tokens,\r\n        address _owner,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Expose vault function that decrement user's balance in the vault\r\n     * Only available to system modules.\r\n     *\r\n     * @param  _tokens          The addresses of the ERC20 tokens\r\n     * @param  _owner           The address of the token owner\r\n     * @param  _quantities      The numbers of tokens to attribute to owner\r\n     */\r\n    function batchDecrementTokenOwnerModule(\r\n        address[] calldata _tokens,\r\n        address _owner,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Expose vault function that transfer vault balances between users\r\n     * Only available to system modules.\r\n     *\r\n     * @param  _tokens           Addresses of tokens being transferred\r\n     * @param  _from             Address tokens being transferred from\r\n     * @param  _to               Address tokens being transferred to\r\n     * @param  _quantities       Amounts of tokens being transferred\r\n     */\r\n    function batchTransferBalanceModule(\r\n        address[] calldata _tokens,\r\n        address _from,\r\n        address _to,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Transfers token from one address to another using the transfer proxy.\r\n     * Only available to system modules.\r\n     *\r\n     * @param  _token          The address of the ERC20 token\r\n     * @param  _quantity       The number of tokens to transfer\r\n     * @param  _from           The address to transfer from\r\n     * @param  _to             The address to transfer to\r\n     */\r\n    function transferModule(\r\n        address _token,\r\n        uint256 _quantity,\r\n        address _from,\r\n        address _to\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Expose transfer proxy function to transfer tokens from one address to another\r\n     * Only available to system modules.\r\n     *\r\n     * @param  _tokens         The addresses of the ERC20 token\r\n     * @param  _quantities     The numbers of tokens to transfer\r\n     * @param  _from           The address to transfer from\r\n     * @param  _to             The address to transfer to\r\n     */\r\n    function batchTransferModule(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _quantities,\r\n        address _from,\r\n        address _to\r\n    )\r\n        external;\r\n}\r\n\r\n// File: contracts/core/interfaces/ISetFactory.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title ISetFactory\r\n * @author Set Protocol\r\n *\r\n * The ISetFactory interface provides operability for authorized contracts\r\n * to interact with SetTokenFactory\r\n */\r\ninterface ISetFactory {\r\n\r\n    /* ============ External Functions ============ */\r\n\r\n    /**\r\n     * Return core address\r\n     *\r\n     * @return address        core address\r\n     */\r\n    function core()\r\n        external\r\n        returns (address);\r\n\r\n    /**\r\n     * Deploys a new Set Token and adds it to the valid list of SetTokens\r\n     *\r\n     * @param  _components           The address of component tokens\r\n     * @param  _units                The units of each component token\r\n     * @param  _naturalUnit          The minimum unit to be issued or redeemed\r\n     * @param  _name                 The bytes32 encoded name of the new Set\r\n     * @param  _symbol               The bytes32 encoded symbol of the new Set\r\n     * @param  _callData             Byte string containing additional call parameters\r\n     * @return setTokenAddress       The address of the new Set\r\n     */\r\n    function createSet(\r\n        address[] calldata _components,\r\n        uint[] calldata _units,\r\n        uint256 _naturalUnit,\r\n        bytes32 _name,\r\n        bytes32 _symbol,\r\n        bytes calldata _callData\r\n    )\r\n        external\r\n        returns (address);\r\n}\r\n\r\n// File: contracts/core/interfaces/IWhiteList.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n/**\r\n * @title IWhiteList\r\n * @author Set Protocol\r\n *\r\n * The IWhiteList interface exposes the whitelist mapping to check components\r\n */\r\ninterface IWhiteList {\r\n\r\n    /* ============ External Functions ============ */\r\n\r\n    /**\r\n     * Validates address against white list\r\n     *\r\n     * @param  _address       Address to check\r\n     * @return bool           Whether passed in address is whitelisted\r\n     */\r\n    function whiteList(\r\n        address _address\r\n    )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * Verifies an array of addresses against the whitelist\r\n     *\r\n     * @param  _addresses    Array of addresses to verify\r\n     * @return bool          Whether all addresses in the list are whitelsited\r\n     */\r\n    function areValidAddresses(\r\n        address[] calldata _addresses\r\n    )\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n// File: contracts/core/interfaces/IRebalancingSetFactory.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title IRebalancingSetFactory\r\n * @author Set Protocol\r\n *\r\n * The IRebalancingSetFactory interface provides operability for authorized contracts\r\n * to interact with RebalancingSetTokenFactory\r\n */\r\ncontract IRebalancingSetFactory is\r\n    ISetFactory\r\n{\r\n    /**\r\n     * Getter for minimumRebalanceInterval of RebalancingSetTokenFactory, used\r\n     * to enforce rebalanceInterval when creating a RebalancingSetToken\r\n     *\r\n     * @return uint256    Minimum amount of time between rebalances in seconds\r\n     */\r\n    function minimumRebalanceInterval()\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Getter for minimumProposalPeriod of RebalancingSetTokenFactory, used\r\n     * to enforce proposalPeriod when creating a RebalancingSetToken\r\n     *\r\n     * @return uint256    Minimum amount of time users can review proposals in seconds\r\n     */\r\n    function minimumProposalPeriod()\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Getter for minimumTimeToPivot of RebalancingSetTokenFactory, used\r\n     * to enforce auctionTimeToPivot when proposing a rebalance\r\n     *\r\n     * @return uint256    Minimum amount of time before auction pivot reached\r\n     */\r\n    function minimumTimeToPivot()\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Getter for maximumTimeToPivot of RebalancingSetTokenFactory, used\r\n     * to enforce auctionTimeToPivot when proposing a rebalance\r\n     *\r\n     * @return uint256    Maximum amount of time before auction pivot reached\r\n     */\r\n    function maximumTimeToPivot()\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Getter for minimumNaturalUnit of RebalancingSetTokenFactory\r\n     *\r\n     * @return uint256    Minimum natural unit\r\n     */\r\n    function minimumNaturalUnit()\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Getter for maximumNaturalUnit of RebalancingSetTokenFactory\r\n     *\r\n     * @return uint256    Maximum Minimum natural unit\r\n     */\r\n    function maximumNaturalUnit()\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Getter for rebalanceAuctionModule address on RebalancingSetTokenFactory\r\n     *\r\n     * @return address      Address of rebalanceAuctionModule\r\n     */\r\n    function rebalanceAuctionModule()\r\n        external\r\n        returns (address);\r\n}\r\n\r\n// File: contracts/core/interfaces/ISetToken.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n/**\r\n * @title ISetToken\r\n * @author Set Protocol\r\n *\r\n * The ISetToken interface provides a light-weight, structured way to interact with the\r\n * SetToken contract from another contract.\r\n */\r\ninterface ISetToken {\r\n\r\n    /* ============ External Functions ============ */\r\n\r\n    /*\r\n     * Get natural unit of Set\r\n     *\r\n     * @return  uint256       Natural unit of Set\r\n     */\r\n    function naturalUnit()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get addresses of all components in the Set\r\n     *\r\n     * @return  componentAddresses       Array of component tokens\r\n     */\r\n    function getComponents()\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n\r\n    /*\r\n     * Get units of all tokens in Set\r\n     *\r\n     * @return  units       Array of component units\r\n     */\r\n    function getUnits()\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /*\r\n     * Checks to make sure token is component of Set\r\n     *\r\n     * @param  _tokenAddress     Address of token being checked\r\n     * @return  bool             True if token is component of Set\r\n     */\r\n    function tokenIsComponent(\r\n        address _tokenAddress\r\n    )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /*\r\n     * Mint set token for given address.\r\n     * Can only be called by authorized contracts.\r\n     *\r\n     * @param  _issuer      The address of the issuing account\r\n     * @param  _quantity    The number of sets to attribute to issuer\r\n     */\r\n    function mint(\r\n        address _issuer,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Burn set token for given address\r\n     * Can only be called by authorized contracts\r\n     *\r\n     * @param  _from        The address of the redeeming account\r\n     * @param  _quantity    The number of sets to burn from redeemer\r\n     */\r\n    function burn(\r\n        address _from,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n    * Transfer token for a specified address\r\n    *\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function transfer(\r\n        address to,\r\n        uint256 value\r\n    )\r\n        external;\r\n}\r\n\r\n// File: contracts/core/interfaces/IVault.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n/**\r\n * @title IVault\r\n * @author Set Protocol\r\n *\r\n * The IVault interface provides a light-weight, structured way to interact with the Vault\r\n * contract from another contract.\r\n */\r\ninterface IVault {\r\n\r\n    /*\r\n     * Withdraws user's unassociated tokens to user account. Can only be\r\n     * called by authorized core contracts.\r\n     *\r\n     * @param  _token          The address of the ERC20 token\r\n     * @param  _to             The address to transfer token to\r\n     * @param  _quantity       The number of tokens to transfer\r\n     */\r\n    function withdrawTo(\r\n        address _token,\r\n        address _to,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Increment quantity owned of a token for a given address. Can\r\n     * only be called by authorized core contracts.\r\n     *\r\n     * @param  _token           The address of the ERC20 token\r\n     * @param  _owner           The address of the token owner\r\n     * @param  _quantity        The number of tokens to attribute to owner\r\n     */\r\n    function incrementTokenOwner(\r\n        address _token,\r\n        address _owner,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Decrement quantity owned of a token for a given address. Can only\r\n     * be called by authorized core contracts.\r\n     *\r\n     * @param  _token           The address of the ERC20 token\r\n     * @param  _owner           The address of the token owner\r\n     * @param  _quantity        The number of tokens to deattribute to owner\r\n     */\r\n    function decrementTokenOwner(\r\n        address _token,\r\n        address _owner,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Transfers tokens associated with one account to another account in the vault\r\n     *\r\n     * @param  _token          Address of token being transferred\r\n     * @param  _from           Address token being transferred from\r\n     * @param  _to             Address token being transferred to\r\n     * @param  _quantity       Amount of tokens being transferred\r\n     */\r\n\r\n    function transferBalance(\r\n        address _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n\r\n    /*\r\n     * Withdraws user's unassociated tokens to user account. Can only be\r\n     * called by authorized core contracts.\r\n     *\r\n     * @param  _tokens          The addresses of the ERC20 tokens\r\n     * @param  _owner           The address of the token owner\r\n     * @param  _quantities      The numbers of tokens to attribute to owner\r\n     */\r\n    function batchWithdrawTo(\r\n        address[] calldata _tokens,\r\n        address _to,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Increment quantites owned of a collection of tokens for a given address. Can\r\n     * only be called by authorized core contracts.\r\n     *\r\n     * @param  _tokens          The addresses of the ERC20 tokens\r\n     * @param  _owner           The address of the token owner\r\n     * @param  _quantities      The numbers of tokens to attribute to owner\r\n     */\r\n    function batchIncrementTokenOwner(\r\n        address[] calldata _tokens,\r\n        address _owner,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Decrements quantites owned of a collection of tokens for a given address. Can\r\n     * only be called by authorized core contracts.\r\n     *\r\n     * @param  _tokens          The addresses of the ERC20 tokens\r\n     * @param  _owner           The address of the token owner\r\n     * @param  _quantities      The numbers of tokens to attribute to owner\r\n     */\r\n    function batchDecrementTokenOwner(\r\n        address[] calldata _tokens,\r\n        address _owner,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n   /**\r\n     * Transfers tokens associated with one account to another account in the vault\r\n     *\r\n     * @param  _tokens           Addresses of tokens being transferred\r\n     * @param  _from             Address tokens being transferred from\r\n     * @param  _to               Address tokens being transferred to\r\n     * @param  _quantities       Amounts of tokens being transferred\r\n     */\r\n    function batchTransferBalance(\r\n        address[] calldata _tokens,\r\n        address _from,\r\n        address _to,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Get balance of particular contract for owner.\r\n     *\r\n     * @param  _token    The address of the ERC20 token\r\n     * @param  _owner    The address of the token owner\r\n     */\r\n    function getOwnerBalance(\r\n        address _token,\r\n        address _owner\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n// File: contracts/core/lib/RebalancingLibrary.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title RebalancingLibrary\r\n * @author Set Protocol\r\n *\r\n * The RebalancingLibrary contains functions for facilitating the rebalancing process for\r\n * Rebalancing Set Tokens. Removes the old calculation functions\r\n *\r\n */\r\nlibrary RebalancingLibrary {\r\n\r\n    /* ============ Enums ============ */\r\n\r\n    enum State { Default, Proposal, Rebalance, Drawdown }\r\n\r\n    /* ============ Structs ============ */\r\n\r\n    struct AuctionPriceParameters {\r\n        uint256 auctionStartTime;\r\n        uint256 auctionTimeToPivot;\r\n        uint256 auctionStartPrice;\r\n        uint256 auctionPivotPrice;\r\n    }\r\n\r\n    struct BiddingParameters {\r\n        uint256 minimumBid;\r\n        uint256 remainingCurrentSets;\r\n        uint256[] combinedCurrentUnits;\r\n        uint256[] combinedNextSetUnits;\r\n        address[] combinedTokenArray;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/Math.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the average of two numbers. Since these are integers,\r\n     * averages of an even and odd number cannot be represented, and will be\r\n     * rounded down.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: contracts/core/tokens/rebalancing-libraries/FailAuctionLibrary.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title FailAuctionLibrary\r\n * @author Set Protocol\r\n *\r\n * Default implementation of Rebalancing Set Token endFailedAuction function\r\n */\r\nlibrary FailAuctionLibrary {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * Fail an auction that doesn't complete before reaching the pivot price. Move to Drawdown state\r\n     * if bids have been placed. Reset to Default state if no bids placed.\r\n     *\r\n     * @param _startingCurrentSetAmount     Amount of current set at beginning or rebalance\r\n     * @param _calculatedUnitShares         Calculated unitShares amount if rebalance were to be settled\r\n     * @param _currentSet                   The Set that failed to rebalance\r\n     * @param _coreAddress                  Core address\r\n     * @param _auctionPriceParameters       Struct containing auction price curve parameters\r\n     * @param _biddingParameters            Struct containing relevant data for calculating token flows\r\n     * @param _rebalanceState               State rebalancing set token is in\r\n     * @return                              State of Rebalancing Set after function called\r\n     */\r\n    function endFailedAuction(\r\n        uint256 _startingCurrentSetAmount,\r\n        uint256 _calculatedUnitShares,\r\n        address _currentSet,\r\n        address _coreAddress,\r\n        RebalancingLibrary.AuctionPriceParameters memory _auctionPriceParameters,\r\n        RebalancingLibrary.BiddingParameters memory _biddingParameters,\r\n        uint8 _rebalanceState\r\n    )\r\n        public\r\n        returns (uint8)\r\n    {\r\n        // Token must be in Rebalance State\r\n        require(\r\n            _rebalanceState ==  uint8(RebalancingLibrary.State.Rebalance),\r\n            \"RebalanceAuctionModule.endFailedAuction: Rebalancing Set Token must be in Rebalance State\"\r\n        );\r\n\r\n        // Calculate timestamp when pivot is reached\r\n        uint256 revertAuctionTime = _auctionPriceParameters.auctionStartTime.add(\r\n            _auctionPriceParameters.auctionTimeToPivot\r\n        );\r\n\r\n        // Make sure auction has gone past pivot point\r\n        require(\r\n            block.timestamp >= revertAuctionTime,\r\n            \"RebalanceAuctionModule.endFailedAuction: Can only be called after auction reaches pivot\"\r\n        );\r\n\r\n        uint8 newRebalanceState;\r\n        /**\r\n         * If not enough sets have been bid on then allow auction to fail where no bids being registered\r\n         * returns the rebalancing set token to pre-auction state and some bids being registered puts the\r\n         * rebalancing set token in Drawdown mode.\r\n         *\r\n         * However, if enough sets have been bid on. Then allow auction to fail and enter Drawdown state if\r\n         * and only if the calculated post-auction unitShares is equal to 0.\r\n         */\r\n        if (_biddingParameters.remainingCurrentSets >= _biddingParameters.minimumBid) {\r\n            // Check if any bids have been placed\r\n            if (_startingCurrentSetAmount == _biddingParameters.remainingCurrentSets) {\r\n                // If bid not placed, reissue current Set\r\n                ICore(_coreAddress).issueInVault(\r\n                    _currentSet,\r\n                    _startingCurrentSetAmount\r\n                );\r\n\r\n                // Set Rebalance Set Token state to Default\r\n                newRebalanceState = uint8(RebalancingLibrary.State.Default);\r\n            } else {\r\n                // Set Rebalancing Set Token to Drawdown state\r\n                newRebalanceState = uint8(RebalancingLibrary.State.Drawdown);\r\n            }\r\n        } else {\r\n            // If settleRebalance can be called then endFailedAuction can't be unless calculatedUnitShares\r\n            // equals 0\r\n            require(\r\n                _calculatedUnitShares == 0,\r\n                \"RebalancingSetToken.endFailedAuction: Cannot be called if rebalance is viably completed\"\r\n            );\r\n\r\n            // If calculated unitShares equals 0 set to Drawdown state\r\n            newRebalanceState = uint8(RebalancingLibrary.State.Drawdown);\r\n        }\r\n\r\n        return newRebalanceState;\r\n    }\r\n}\r\n\r\n// File: contracts/core/lib/auction-price-libraries/IAuctionPriceCurve.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/**\r\n * @title IAuctionPriceCurve\r\n * @author Set Protocol\r\n *\r\n * The IAuctionPriceCurve interface provides a structured way to interact with any AuctionLibrary\r\n */\r\ninterface IAuctionPriceCurve {\r\n\r\n    /*\r\n     * Getter for priceDivisor variable on Auction Price Curve Library\r\n     */\r\n    function priceDivisor()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Validate any auction parameters that have library-specific restrictions\r\n     *\r\n     * @param _auctionPriceParameters   Struct containing relevant auction price parameters\r\n     */\r\n    function validateAuctionPriceParameters(\r\n        RebalancingLibrary.AuctionPriceParameters calldata _auctionPriceParameters\r\n    )\r\n        external\r\n        view;\r\n\r\n    /*\r\n     * Calculate the current priceRatio for an auction given defined price and time parameters\r\n     *\r\n     * @param _auctionPriceParameters     Struct containing relevant auction price parameters\r\n     * @return uint256                    The auction price numerator\r\n     * @return uint256                    The auction price denominator\r\n     */\r\n    function getCurrentPrice(\r\n        RebalancingLibrary.AuctionPriceParameters calldata _auctionPriceParameters\r\n    )\r\n        external\r\n        view\r\n        returns (uint256, uint256);\r\n}\r\n\r\n// File: contracts/core/tokens/rebalancing-libraries/PlaceBidLibrary.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title PlaceBidLibrary\r\n * @author Set Protocol\r\n *\r\n * Default implementation of Rebalancing Set Token placeBid function\r\n */\r\nlibrary PlaceBidLibrary {\r\n    using SafeMath for uint256;\r\n\r\n    /* ============ Internal Functions ============ */\r\n\r\n    /*\r\n     * Place bid during rebalance auction. Can only be called by Core.\r\n     *\r\n     * @param _quantity                 The amount of currentSet to be rebalanced\r\n     * @param _coreAddress              Core address\r\n     * @param _biddingParameters        Struct containing relevant data for calculating token flows\r\n     * @return inflowUnitArray          Array of amount of tokens inserted into system in bid\r\n     * @return outflowUnitArray         Array of amount of tokens taken out of system in bid\r\n     */\r\n    function validatePlaceBid(\r\n        uint256 _quantity,\r\n        address _coreAddress,\r\n        RebalancingLibrary.BiddingParameters memory _biddingParameters\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // Make sure sender is a module\r\n        require(\r\n            ICore(_coreAddress).validModules(msg.sender),\r\n            \"RebalancingSetToken.placeBid: Sender must be approved module\"\r\n        );\r\n\r\n        // Make sure that bid amount is greater than zero\r\n        require(\r\n            _quantity > 0,\r\n            \"RebalancingSetToken.placeBid: Bid must be > 0\"\r\n        );\r\n\r\n        // Make sure that bid amount is multiple of minimum bid amount\r\n        require(\r\n            _quantity.mod(_biddingParameters.minimumBid) == 0,\r\n            \"RebalancingSetToken.placeBid: Must bid multiple of minimum bid\"\r\n        );\r\n\r\n        // Make sure that bid Amount is less than remainingCurrentSets\r\n        require(\r\n            _quantity <= _biddingParameters.remainingCurrentSets,\r\n            \"RebalancingSetToken.placeBid: Bid exceeds remaining current sets\"\r\n        );\r\n    }\r\n\r\n    /*\r\n     * Get token inflows and outflows required for bid. Also the amount of Rebalancing\r\n     * Sets that would be generated.\r\n     *\r\n     * @param _quantity               The amount of currentSet to be rebalanced\r\n     * @param _auctionLibrary         Auction library used in rebalance\r\n     * @param _biddingParameters      Struct containing relevant data for calculating token flows\r\n     * @param _auctionPriceParameters Struct containing auction price curve parameters\r\n     * @param _rebalanceState         State of rebalancing set token\r\n     * @return inflowUnitArray        Array of amount of tokens inserted into system in bid\r\n     * @return outflowUnitArray       Array of amount of tokens taken out of system in bid\r\n     */\r\n    function getBidPrice(\r\n        uint256 _quantity,\r\n        address _auctionLibrary,\r\n        RebalancingLibrary.BiddingParameters memory _biddingParameters,\r\n        RebalancingLibrary.AuctionPriceParameters memory _auctionPriceParameters,\r\n        uint8 _rebalanceState\r\n    )\r\n        public\r\n        view\r\n        returns (uint256[] memory, uint256[] memory)\r\n    {\r\n        // Confirm in Rebalance State\r\n        require(\r\n            _rebalanceState == uint8(RebalancingLibrary.State.Rebalance),\r\n            \"RebalancingSetToken.getBidPrice: State must be Rebalance\"\r\n        );\r\n\r\n        // Get bid conversion price, currently static placeholder for calling auctionlibrary\r\n        uint256 priceNumerator;\r\n        uint256 priceDivisor;\r\n        (priceNumerator, priceDivisor) = IAuctionPriceCurve(_auctionLibrary).getCurrentPrice(\r\n            _auctionPriceParameters\r\n        );\r\n\r\n        // Normalized quantity amount\r\n        uint256 unitsMultiplier = _quantity.div(_biddingParameters.minimumBid).mul(priceDivisor);\r\n\r\n        // Calculate token flow arrays\r\n        return createTokenFlowArrays(\r\n            unitsMultiplier,\r\n            priceNumerator,\r\n            priceDivisor,\r\n            _biddingParameters\r\n        );\r\n    }\r\n\r\n    /*\r\n     * Creates arrays of token inflows and outflows\r\n     *\r\n     * @param _unitsMultiplier        Bid amount normalized to number of standard bid amounts\r\n     * @param _priceNumerator         The numerator of the price ratio\r\n     * @param _priceDivisor           The denominator of the price ratio\r\n     * @param _biddingParameters      Struct containing relevant data for calculating token flows\r\n     * @return inflowUnitArray        Array of amount of tokens inserted into system in bid\r\n     * @return outflowUnitArray       Array of amount of tokens taken out of system in bid\r\n     */\r\n    function createTokenFlowArrays(\r\n        uint256 _unitsMultiplier,\r\n        uint256 _priceNumerator,\r\n        uint256 _priceDivisor,\r\n        RebalancingLibrary.BiddingParameters memory _biddingParameters\r\n    )\r\n        public\r\n        pure\r\n        returns (uint256[] memory, uint256[] memory)\r\n    {\r\n        // Declare unit arrays in memory\r\n        uint256 combinedTokenCount = _biddingParameters.combinedTokenArray.length;\r\n        uint256[] memory inflowUnitArray = new uint256[](combinedTokenCount);\r\n        uint256[] memory outflowUnitArray = new uint256[](combinedTokenCount);\r\n\r\n        // Cycle through each token in combinedTokenArray, calculate inflow/outflow and store\r\n        // result in array\r\n        for (uint256 i = 0; i < combinedTokenCount; i++) {\r\n            (\r\n                inflowUnitArray[i],\r\n                outflowUnitArray[i]\r\n            ) = calculateTokenFlows(\r\n                _biddingParameters.combinedCurrentUnits[i],\r\n                _biddingParameters.combinedNextSetUnits[i],\r\n                _unitsMultiplier,\r\n                _priceNumerator,\r\n                _priceDivisor\r\n            );\r\n        }\r\n\r\n        return (inflowUnitArray, outflowUnitArray);\r\n    }\r\n\r\n    /*\r\n     * Calculates token inflow/outflow for single component in combinedTokenArray\r\n     *\r\n     * @param _currentUnit          Amount of token i in currentSet per minimum bid amount\r\n     * @param _nextSetUnit          Amount of token i in nextSet per minimum bid amount\r\n     * @param _unitsMultiplier      Bid amount normalized to number of minimum bid amounts\r\n     * @param _priceNumerator       The numerator of the price ratio\r\n     * @param _priceDivisor         The denominator of the price ratio\r\n     * @return inflowUnit           Amount of token i transferred into the system\r\n     * @return outflowUnit          Amount of token i transferred to the bidder\r\n     */\r\n    function calculateTokenFlows(\r\n        uint256 _currentUnit,\r\n        uint256 _nextSetUnit,\r\n        uint256 _unitsMultiplier,\r\n        uint256 _priceNumerator,\r\n        uint256 _priceDivisor\r\n    )\r\n        public\r\n        pure\r\n        returns (uint256, uint256)\r\n    {\r\n        /*\r\n         * Below is a mathematically simplified formula for calculating token inflows and\r\n         * outflows, the following is it's derivation:\r\n         * token_flow = (bidQuantity/price)*(nextUnit - price*currentUnit)\r\n         *\r\n         * Where,\r\n         * 1) price = (priceNumerator/priceDivisor),\r\n         * 2) nextUnit and currentUnit are the amount of component i needed for a\r\n         * standardAmount of sets to be rebalanced where one standardAmount =\r\n         * max(natural unit nextSet, natural unit currentSet), and\r\n         * 3) bidQuantity is a normalized amount in terms of the standardAmount used\r\n         * to calculate nextUnit and currentUnit. This is represented by the unitsMultiplier\r\n         * variable.\r\n         *\r\n         * Given these definitions we can derive the below formula as follows:\r\n         * token_flow = (unitsMultiplier/(priceNumerator/priceDivisor))*\r\n         * (nextUnit - (priceNumerator/priceDivisor)*currentUnit)\r\n         *\r\n         * We can then multiply this equation by (priceDivisor/priceDivisor)\r\n         * which simplifies the above equation to:\r\n         *\r\n         * (unitsMultiplier/priceNumerator)* (nextUnit*priceDivisor - currentUnit*priceNumerator)\r\n         *\r\n         * This is the equation seen below, but since unsigned integers are used we must check to see if\r\n         * nextUnit*priceDivisor > currentUnit*priceNumerator, otherwise those two terms must be\r\n         * flipped in the equation.\r\n         */\r\n        uint256 inflowUnit;\r\n        uint256 outflowUnit;\r\n\r\n        // Use if statement to check if token inflow or outflow\r\n        if (_nextSetUnit.mul(_priceDivisor) > _currentUnit.mul(_priceNumerator)) {\r\n            // Calculate inflow amount\r\n            inflowUnit = _unitsMultiplier.mul(\r\n                _nextSetUnit.mul(_priceDivisor).sub(_currentUnit.mul(_priceNumerator))\r\n            ).div(_priceNumerator);\r\n\r\n            // Set outflow amount to 0 for component i, since tokens need to be injected in rebalance\r\n            outflowUnit = 0;\r\n        } else {\r\n            // Calculate outflow amount\r\n            outflowUnit = _unitsMultiplier.mul(\r\n                _currentUnit.mul(_priceNumerator).sub(_nextSetUnit.mul(_priceDivisor))\r\n            ).div(_priceNumerator);\r\n\r\n            // Set inflow amount to 0 for component i, since tokens need to be returned in rebalance\r\n            inflowUnit = 0;\r\n        }\r\n\r\n        return (inflowUnit, outflowUnit);\r\n    }\r\n}\r\n\r\n// File: contracts/core/tokens/rebalancing-libraries/ProposeLibrary.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ProposeLibrary\r\n * @author Set Protocol\r\n *\r\n * Default implementation of Rebalancing Set Token propose function\r\n */\r\nlibrary ProposeLibrary {\r\n    using SafeMath for uint256;\r\n\r\n    /* ============ Structs ============ */\r\n\r\n    struct ProposalContext {\r\n        address manager;\r\n        address currentSet;\r\n        address coreAddress;\r\n        address componentWhitelist;\r\n        address factoryAddress;\r\n        uint256 lastRebalanceTimestamp;\r\n        uint256 rebalanceInterval;\r\n        uint8 rebalanceState;\r\n    }\r\n\r\n    /* ============ Internal Functions ============ */\r\n\r\n    /**\r\n     * Function used to validate inputs to propose function\r\n     *\r\n     * @param _nextSet                    The Set to rebalance into\r\n     * @param _auctionLibrary             The library used to calculate the Dutch Auction price\r\n     * @param _proposalContext            Rebalancing Set Token state parameters needed for proposal validation\r\n     */\r\n    function validateProposal(\r\n        address _nextSet,\r\n        address _auctionLibrary,\r\n        ProposalContext memory _proposalContext,\r\n        RebalancingLibrary.AuctionPriceParameters memory _auctionPriceParameters\r\n    )\r\n        public\r\n    {\r\n        ICore coreInstance = ICore(_proposalContext.coreAddress);\r\n        IRebalancingSetFactory factoryInstance = IRebalancingSetFactory(_proposalContext.factoryAddress);\r\n\r\n        // Make sure it is manager that is proposing the rebalance\r\n        require(\r\n            msg.sender == _proposalContext.manager,\r\n            \"ProposeLibrary.validateProposal: Sender must be manager\"\r\n        );\r\n\r\n        // New Proposal can only be made in Default and Proposal state\r\n        require(\r\n            _proposalContext.rebalanceState == uint8(RebalancingLibrary.State.Default) ||\r\n            _proposalContext.rebalanceState == uint8(RebalancingLibrary.State.Proposal),\r\n            \"ProposeLibrary.validateProposal: State must be in Propose or Default\"\r\n        );\r\n\r\n        // Make sure enough time has passed from last rebalance to start a new proposal\r\n        require(\r\n            block.timestamp >= _proposalContext.lastRebalanceTimestamp.add(\r\n                _proposalContext.rebalanceInterval\r\n            ),\r\n            \"ProposeLibrary.validateProposal: Rebalance interval not elapsed\"\r\n        );\r\n\r\n        // Check that new proposed Set is valid Set created by Core\r\n        require(\r\n            coreInstance.validSets(_nextSet),\r\n            \"ProposeLibrary.validateProposal: Invalid or disabled proposed SetToken address\"\r\n        );\r\n\r\n        // Check proposed components on whitelist. This is to ensure managers are unable to add contract addresses\r\n        // to a propose that prohibit the set from carrying out an auction i.e. a token that only the manager possesses\r\n        require(\r\n            IWhiteList(\r\n                _proposalContext.componentWhitelist\r\n            ).areValidAddresses(ISetToken(_nextSet).getComponents()),\r\n            \"ProposeLibrary.validateProposal: Proposed set contains invalid component token\"\r\n        );\r\n\r\n        // Check that the auction library is a valid priceLibrary tracked by Core\r\n        require(\r\n            coreInstance.validPriceLibraries(_auctionLibrary),\r\n            \"ProposeLibrary.validateProposal: Invalid or disabled PriceLibrary address\"\r\n        );\r\n\r\n        // Check that auctionTimeToPivot is greater than or equal to 6 hours\r\n        require(\r\n            _auctionPriceParameters.auctionTimeToPivot >= factoryInstance.minimumTimeToPivot(),\r\n            \"ProposeLibrary.validateProposal: Time to pivot must be greater than minimum\"\r\n        );\r\n\r\n        // Check that auctionTimeToPivot is less than or equal to 3 days\r\n        require(\r\n            _auctionPriceParameters.auctionTimeToPivot <= factoryInstance.maximumTimeToPivot(),\r\n            \"ProposeLibrary.validateProposal: Time to pivot must be greater than maximum\"\r\n        );\r\n\r\n        // Check that the proposed set natural unit is a multiple of current set natural unit, or vice versa.\r\n        // Done to make sure that when calculating token units there will are no rounding errors.\r\n        uint256 currentNaturalUnit = ISetToken(_proposalContext.currentSet).naturalUnit();\r\n        uint256 nextSetNaturalUnit = ISetToken(_nextSet).naturalUnit();\r\n        require(\r\n            Math.max(currentNaturalUnit, nextSetNaturalUnit).mod(\r\n                Math.min(currentNaturalUnit, nextSetNaturalUnit)\r\n            ) == 0,\r\n            \"ProposeLibrary.validateProposal: Invalid proposed Set natural unit\"\r\n        );\r\n\r\n        // Check that pivot price is compliant with library restrictions\r\n        IAuctionPriceCurve(_auctionLibrary).validateAuctionPriceParameters(\r\n            _auctionPriceParameters\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/core/lib/SetTokenLibrary.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\nlibrary SetTokenLibrary {\r\n    using SafeMath for uint256;\r\n\r\n    struct SetDetails {\r\n        uint256 naturalUnit;\r\n        address[] components;\r\n        uint256[] units;\r\n    }\r\n\r\n    /**\r\n     * Validates that passed in tokens are all components of the Set\r\n     *\r\n     * @param _set                      Address of the Set\r\n     * @param _tokens                   List of tokens to check\r\n     */\r\n    function validateTokensAreComponents(\r\n        address _set,\r\n        address[] calldata _tokens\r\n    )\r\n        external\r\n        view\r\n    {\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            // Make sure all tokens are members of the Set\r\n            require(\r\n                ISetToken(_set).tokenIsComponent(_tokens[i]),\r\n                \"SetTokenLibrary.validateTokensAreComponents: Component must be a member of Set\"\r\n            );\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates that passed in quantity is a multiple of the natural unit of the Set.\r\n     *\r\n     * @param _set                      Address of the Set\r\n     * @param _quantity                   Quantity to validate\r\n     */\r\n    function isMultipleOfSetNaturalUnit(\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external\r\n        view\r\n    {\r\n        require(\r\n            _quantity.mod(ISetToken(_set).naturalUnit()) == 0,\r\n            \"SetTokenLibrary.isMultipleOfSetNaturalUnit: Quantity is not a multiple of nat unit\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Retrieves the Set's natural unit, components, and units.\r\n     *\r\n     * @param _set                      Address of the Set\r\n     * @return SetDetails               Struct containing the natural unit, components, and units\r\n     */\r\n    function getSetDetails(\r\n        address _set\r\n    )\r\n        internal\r\n        view\r\n        returns (SetDetails memory)\r\n    {\r\n        // Declare interface variables\r\n        ISetToken setToken = ISetToken(_set);\r\n\r\n        // Fetch set token properties\r\n        uint256 naturalUnit = setToken.naturalUnit();\r\n        address[] memory components = setToken.getComponents();\r\n        uint256[] memory units = setToken.getUnits();\r\n\r\n        return SetDetails({\r\n            naturalUnit: naturalUnit,\r\n            components: components,\r\n            units: units\r\n        });\r\n    }\r\n}\r\n\r\n// File: contracts/core/tokens/rebalancing-libraries/SettleRebalanceLibrary.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SettleRebalanceLibrary\r\n * @author Set Protocol\r\n *\r\n * Default implementation of Rebalancing Set Token settle rebalance and related functions.\r\n */\r\nlibrary SettleRebalanceLibrary {\r\n    using SafeMath for uint256;\r\n    /* ============ Internal Functions ============ */\r\n\r\n    /**\r\n     * Calculate the amount of nextSets to issue by using the component amounts in the\r\n     * vault, new unitShares follow from this calculation\r\n     *\r\n     * @param   _totalSupply            Total supply of rebalancing set token\r\n     * @param   _remainingCurrentSets   Amount of currentSets remaining\r\n     * @param   _minimumBid             Minimum bid allowed, used to see if valid settle\r\n     * @param   _naturalUnit            Natural unit of rebalancing set token\r\n     * @param   _nextSet                Address of next set\r\n     * @param   _coreAddress            Core address\r\n     * @param   _vaultAddress           Vault address\r\n     * @return  uint256                 Amount of nextSets to issue\r\n     */\r\n    function settleRebalance(\r\n        uint256 _totalSupply,\r\n        uint256 _remainingCurrentSets,\r\n        uint256 _minimumBid,\r\n        uint256 _naturalUnit,\r\n        address _nextSet,\r\n        address _coreAddress,\r\n        address _vaultAddress,\r\n        uint8 _rebalanceState\r\n    )\r\n        public\r\n        returns (uint256)\r\n    {\r\n        // Must be in Rebalance state to call settlement\r\n        require(\r\n            _rebalanceState == uint8(RebalancingLibrary.State.Rebalance),\r\n            \"RebalancingSetToken.settleRebalance: State must be Rebalance\"\r\n        );\r\n\r\n        // Make sure all currentSets have been rebalanced\r\n        require(\r\n            _remainingCurrentSets < _minimumBid,\r\n            \"RebalancingSetToken.settleRebalance: Rebalance not completed\"\r\n        );\r\n\r\n        // Calculate next Set quantities\r\n        uint256 issueAmount;\r\n        uint256 nextUnitShares;\r\n        (\r\n            issueAmount,\r\n            nextUnitShares\r\n        ) = calculateNextSetIssueQuantity(\r\n            _totalSupply,\r\n            _naturalUnit,\r\n            _nextSet,\r\n            _vaultAddress\r\n        );\r\n\r\n        require(\r\n            nextUnitShares > 0,\r\n            \"RebalancingSetToken.settleRebalance: Failed rebalance, unitshares equals 0. Call endFailedAuction.\"\r\n        );\r\n\r\n        // Issue nextSet to RebalancingSetToken\r\n        ICore(_coreAddress).issueInVault(\r\n            _nextSet,\r\n            issueAmount\r\n        );\r\n\r\n        return nextUnitShares;\r\n    }\r\n\r\n    /**\r\n     * Calculate the amount of nextSets to issue by using the component amounts in the\r\n     * vault, unitShares following from this calculation.\r\n     *\r\n     * @param   _totalSupply        Total supply of rebalancing set token\r\n     * @param   _naturalUnit        Natural unit of rebalancing set token\r\n     * @param   _nextSet            Address of next set\r\n     * @param   _vaultAddress       Vault address\r\n     * @return  uint256             Amount of nextSets to issue\r\n     * @return  uint256             New unitShares for the rebalancingSetToken\r\n     */\r\n    function calculateNextSetIssueQuantity(\r\n        uint256 _totalSupply,\r\n        uint256 _naturalUnit,\r\n        address _nextSet,\r\n        address _vaultAddress\r\n    )\r\n        public\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        // Collect data necessary to compute issueAmounts\r\n        SetTokenLibrary.SetDetails memory nextSetToken = SetTokenLibrary.getSetDetails(_nextSet);\r\n        uint256 maxIssueAmount = calculateMaxIssueAmount(\r\n            _vaultAddress,\r\n            nextSetToken\r\n        );\r\n\r\n        // Calculate the amount of naturalUnits worth of rebalancingSetToken outstanding\r\n        uint256 naturalUnitsOutstanding = _totalSupply.div(_naturalUnit);\r\n\r\n        // Issue amount of Sets that is closest multiple of nextNaturalUnit to the maxIssueAmount\r\n        // Since the initial division will round down to the nearest whole number when we multiply\r\n        // by that same number we will return the closest multiple less than the maxIssueAmount\r\n        uint256 issueAmount = maxIssueAmount.div(nextSetToken.naturalUnit).mul(nextSetToken.naturalUnit);\r\n\r\n        // Divide final issueAmount by naturalUnitsOutstanding to get newUnitShares\r\n        uint256 newUnitShares = issueAmount.div(naturalUnitsOutstanding);\r\n        return (issueAmount, newUnitShares);\r\n    }\r\n\r\n    /**\r\n     * Get the maximum possible issue amount of nextSet based on number of components owned by rebalancing\r\n     * set token.\r\n     *\r\n     * @param _vaultAddress     Vault address\r\n     * @param _setToken         nextSet details\r\n     * @return uint256          maxIssueAmount\r\n     */\r\n    function calculateMaxIssueAmount(\r\n        address _vaultAddress,\r\n        SetTokenLibrary.SetDetails memory _setToken\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 maxIssueAmount = CommonMath.maxUInt256();\r\n        IVault vaultInstance = IVault(_vaultAddress);\r\n\r\n        for (uint256 i = 0; i < _setToken.components.length; i++) {\r\n            // Get amount of components in vault owned by rebalancingSetToken\r\n            uint256 componentAmount = vaultInstance.getOwnerBalance(\r\n                _setToken.components[i],\r\n                address(this)\r\n            );\r\n\r\n            // Calculate amount of Sets that can be issued from those components, if less than amount for other\r\n            // components then set that as maxIssueAmount\r\n            uint256 componentIssueAmount = componentAmount.div(_setToken.units[i]).mul(_setToken.naturalUnit);\r\n            if (componentIssueAmount < maxIssueAmount) {\r\n                maxIssueAmount = componentIssueAmount;\r\n            }\r\n        }\r\n\r\n        return maxIssueAmount;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/AddressArrayUtils.sol\r\n\r\n// Pulled in from Cryptofin Solidity package in order to control Solidity compiler version\r\n// https://github.com/cryptofinlabs/cryptofin-solidity/blob/master/contracts/array-utils/AddressArrayUtils.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\nlibrary AddressArrayUtils {\r\n\r\n    /**\r\n     * Finds the index of the first occurrence of the given element.\r\n     * @param A The input array to search\r\n     * @param a The value to find\r\n     * @return Returns (index and isIn) for the first occurrence starting from index 0\r\n     */\r\n    function indexOf(address[] memory A, address a) internal pure returns (uint256, bool) {\r\n        uint256 length = A.length;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            if (A[i] == a) {\r\n                return (i, true);\r\n            }\r\n        }\r\n        return (0, false);\r\n    }\r\n\r\n    /**\r\n    * Returns true if the value is present in the list. Uses indexOf internally.\r\n    * @param A The input array to search\r\n    * @param a The value to find\r\n    * @return Returns isIn for the first occurrence starting from index 0\r\n    */\r\n    function contains(address[] memory A, address a) internal pure returns (bool) {\r\n        bool isIn;\r\n        (, isIn) = indexOf(A, a);\r\n        return isIn;\r\n    }\r\n\r\n    /// @return Returns index and isIn for the first occurrence starting from\r\n    /// end\r\n    function indexOfFromEnd(address[] memory A, address a) internal pure returns (uint256, bool) {\r\n        uint256 length = A.length;\r\n        for (uint256 i = length; i > 0; i--) {\r\n            if (A[i - 1] == a) {\r\n                return (i, true);\r\n            }\r\n        }\r\n        return (0, false);\r\n    }\r\n\r\n    /**\r\n     * Returns the combination of the two arrays\r\n     * @param A The first array\r\n     * @param B The second array\r\n     * @return Returns A extended by B\r\n     */\r\n    function extend(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\r\n        uint256 aLength = A.length;\r\n        uint256 bLength = B.length;\r\n        address[] memory newAddresses = new address[](aLength + bLength);\r\n        for (uint256 i = 0; i < aLength; i++) {\r\n            newAddresses[i] = A[i];\r\n        }\r\n        for (uint256 j = 0; j < bLength; j++) {\r\n            newAddresses[aLength + j] = B[j];\r\n        }\r\n        return newAddresses;\r\n    }\r\n\r\n    /**\r\n     * Returns the array with a appended to A.\r\n     * @param A The first array\r\n     * @param a The value to append\r\n     * @return Returns A appended by a\r\n     */\r\n    function append(address[] memory A, address a) internal pure returns (address[] memory) {\r\n        address[] memory newAddresses = new address[](A.length + 1);\r\n        for (uint256 i = 0; i < A.length; i++) {\r\n            newAddresses[i] = A[i];\r\n        }\r\n        newAddresses[A.length] = a;\r\n        return newAddresses;\r\n    }\r\n\r\n    /**\r\n     * Returns the combination of two storage arrays.\r\n     * @param A The first array\r\n     * @param B The second array\r\n     * @return Returns A appended by a\r\n     */\r\n    function sExtend(address[] storage A, address[] storage B) internal {\r\n        uint256 length = B.length;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            A.push(B[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the intersection of two arrays. Arrays are treated as collections, so duplicates are kept.\r\n     * @param A The first array\r\n     * @param B The second array\r\n     * @return The intersection of the two arrays\r\n     */\r\n    function intersect(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\r\n        uint256 length = A.length;\r\n        bool[] memory includeMap = new bool[](length);\r\n        uint256 newLength = 0;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            if (contains(B, A[i])) {\r\n                includeMap[i] = true;\r\n                newLength++;\r\n            }\r\n        }\r\n        address[] memory newAddresses = new address[](newLength);\r\n        uint256 j = 0;\r\n        for (uint256 k = 0; k < length; k++) {\r\n            if (includeMap[k]) {\r\n                newAddresses[j] = A[k];\r\n                j++;\r\n            }\r\n        }\r\n        return newAddresses;\r\n    }\r\n\r\n    /**\r\n     * Returns the union of the two arrays. Order is not guaranteed.\r\n     * @param A The first array\r\n     * @param B The second array\r\n     * @return The union of the two arrays\r\n     */\r\n    function union(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\r\n        address[] memory leftDifference = difference(A, B);\r\n        address[] memory rightDifference = difference(B, A);\r\n        address[] memory intersection = intersect(A, B);\r\n        return extend(leftDifference, extend(intersection, rightDifference));\r\n    }\r\n\r\n    /**\r\n     * Alternate implementation\r\n     * Assumes there are no duplicates\r\n     */\r\n    function unionB(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\r\n        bool[] memory includeMap = new bool[](A.length + B.length);\r\n        uint256 count = 0;\r\n        for (uint256 i = 0; i < A.length; i++) {\r\n            includeMap[i] = true;\r\n            count++;\r\n        }\r\n        for (uint256 j = 0; j < B.length; j++) {\r\n            if (!contains(A, B[j])) {\r\n                includeMap[A.length + j] = true;\r\n                count++;\r\n            }\r\n        }\r\n        address[] memory newAddresses = new address[](count);\r\n        uint256 k = 0;\r\n        for (uint256 m = 0; m < A.length; m++) {\r\n            if (includeMap[m]) {\r\n                newAddresses[k] = A[m];\r\n                k++;\r\n            }\r\n        }\r\n        for (uint256 n = 0; n < B.length; n++) {\r\n            if (includeMap[A.length + n]) {\r\n                newAddresses[k] = B[n];\r\n                k++;\r\n            }\r\n        }\r\n        return newAddresses;\r\n    }\r\n\r\n    /**\r\n     * Computes the difference of two arrays. Assumes there are no duplicates.\r\n     * @param A The first array\r\n     * @param B The second array\r\n     * @return The difference of the two arrays\r\n     */\r\n    function difference(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\r\n        uint256 length = A.length;\r\n        bool[] memory includeMap = new bool[](length);\r\n        uint256 count = 0;\r\n        // First count the new length because can't push for in-memory arrays\r\n        for (uint256 i = 0; i < length; i++) {\r\n            address e = A[i];\r\n            if (!contains(B, e)) {\r\n                includeMap[i] = true;\r\n                count++;\r\n            }\r\n        }\r\n        address[] memory newAddresses = new address[](count);\r\n        uint256 j = 0;\r\n        for (uint256 k = 0; k < length; k++) {\r\n            if (includeMap[k]) {\r\n                newAddresses[j] = A[k];\r\n                j++;\r\n            }\r\n        }\r\n        return newAddresses;\r\n    }\r\n\r\n    /**\r\n    * @dev Reverses storage array in place\r\n    */\r\n    function sReverse(address[] storage A) internal {\r\n        address t;\r\n        uint256 length = A.length;\r\n        for (uint256 i = 0; i < length / 2; i++) {\r\n            t = A[i];\r\n            A[i] = A[A.length - i - 1];\r\n            A[A.length - i - 1] = t;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Removes specified index from array\r\n    * Resulting ordering is not guaranteed\r\n    * @return Returns the new array and the removed entry\r\n    */\r\n    function pop(address[] memory A, uint256 index)\r\n        internal\r\n        pure\r\n        returns (address[] memory, address)\r\n    {\r\n        uint256 length = A.length;\r\n        address[] memory newAddresses = new address[](length - 1);\r\n        for (uint256 i = 0; i < index; i++) {\r\n            newAddresses[i] = A[i];\r\n        }\r\n        for (uint256 j = index + 1; j < length; j++) {\r\n            newAddresses[j - 1] = A[j];\r\n        }\r\n        return (newAddresses, A[index]);\r\n    }\r\n\r\n    /**\r\n     * @return Returns the new array\r\n     */\r\n    function remove(address[] memory A, address a)\r\n        internal\r\n        pure\r\n        returns (address[] memory)\r\n    {\r\n        (uint256 index, bool isIn) = indexOf(A, a);\r\n        if (!isIn) {\r\n            revert();\r\n        } else {\r\n            (address[] memory _A,) = pop(A, index);\r\n            return _A;\r\n        }\r\n    }\r\n\r\n    function sPop(address[] storage A, uint256 index) internal returns (address) {\r\n        uint256 length = A.length;\r\n        if (index >= length) {\r\n            revert(\"Error: index out of bounds\");\r\n        }\r\n        address entry = A[index];\r\n        for (uint256 i = index; i < length - 1; i++) {\r\n            A[i] = A[i + 1];\r\n        }\r\n        A.length--;\r\n        return entry;\r\n    }\r\n\r\n    /**\r\n    * Deletes address at index and fills the spot with the last address.\r\n    * Order is not preserved.\r\n    * @return Returns the removed entry\r\n    */\r\n    function sPopCheap(address[] storage A, uint256 index) internal returns (address) {\r\n        uint256 length = A.length;\r\n        if (index >= length) {\r\n            revert(\"Error: index out of bounds\");\r\n        }\r\n        address entry = A[index];\r\n        if (index != length - 1) {\r\n            A[index] = A[length - 1];\r\n            delete A[length - 1];\r\n        }\r\n        A.length--;\r\n        return entry;\r\n    }\r\n\r\n    /**\r\n     * Deletes address at index. Works by swapping it with the last address, then deleting.\r\n     * Order is not preserved\r\n     * @param A Storage array to remove from\r\n     */\r\n    function sRemoveCheap(address[] storage A, address a) internal {\r\n        (uint256 index, bool isIn) = indexOf(A, a);\r\n        if (!isIn) {\r\n            revert(\"Error: entry not found\");\r\n        } else {\r\n            sPopCheap(A, index);\r\n            return;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not there's a duplicate. Runs in O(n^2).\r\n     * @param A Array to search\r\n     * @return Returns true if duplicate, false otherwise\r\n     */\r\n    function hasDuplicate(address[] memory A) internal pure returns (bool) {\r\n        if (A.length == 0) {\r\n            return false;\r\n        }\r\n        for (uint256 i = 0; i < A.length - 1; i++) {\r\n            for (uint256 j = i + 1; j < A.length; j++) {\r\n                if (A[i] == A[j]) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns whether the two arrays are equal.\r\n     * @param A The first array\r\n     * @param B The second array\r\n     * @return True is the arrays are equal, false if not.\r\n     */\r\n    function isEqual(address[] memory A, address[] memory B) internal pure returns (bool) {\r\n        if (A.length != B.length) {\r\n            return false;\r\n        }\r\n        for (uint256 i = 0; i < A.length; i++) {\r\n            if (A[i] != B[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns the elements indexed at indexArray.\r\n     * @param A The array to index\r\n     * @param indexArray The array to use to index\r\n     * @return Returns array containing elements indexed at indexArray\r\n     */\r\n    function argGet(address[] memory A, uint256[] memory indexArray)\r\n        internal\r\n        pure\r\n        returns (address[] memory)\r\n    {\r\n        address[] memory array = new address[](indexArray.length);\r\n        for (uint256 i = 0; i < indexArray.length; i++) {\r\n            array[i] = A[indexArray[i]];\r\n        }\r\n        return array;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/core/tokens/rebalancing-libraries/StartRebalanceLibrary.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title StartRebalanceLibrary\r\n * @author Set Protocol\r\n *\r\n * Default implementation of Rebalancing Set Token startRebalance function\r\n */\r\n\r\n\r\nlibrary StartRebalanceLibrary {\r\n    using SafeMath for uint256;\r\n    using AddressArrayUtils for address[];\r\n\r\n    /* ============ Internal Functions ============ */\r\n\r\n    /**\r\n     * Function used to validate time passed to start a rebalance\r\n     *\r\n     * @param _proposalStartTime    Start time of proposal period\r\n     * @param _proposalPeriod       Required length of proposal period\r\n     * @param _rebalanceState       State rebalancing set token is in\r\n     */\r\n    function validateStartRebalance(\r\n        uint256 _proposalStartTime,\r\n        uint256 _proposalPeriod,\r\n        uint8 _rebalanceState\r\n    )\r\n        external\r\n    {\r\n        // Must be in \"Proposal\" state before going into \"Rebalance\" state\r\n        require(\r\n            _rebalanceState == uint8(RebalancingLibrary.State.Proposal),\r\n            \"RebalancingSetToken.validateStartRebalance: State must be Proposal\"\r\n        );\r\n\r\n        // Be sure the full proposal period has elapsed\r\n        require(\r\n            block.timestamp >= _proposalStartTime.add(_proposalPeriod),\r\n            \"RebalancingSetToken.validateStartRebalance: Proposal period not elapsed\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Function used to validate inputs to propose function and initialize biddingParameters struct\r\n     *\r\n     * @param _currentSet           Address of current Set\r\n     * @param _nextSet              Address of next Set\r\n     * @param _auctionLibrary       Address of auction library being used in rebalance\r\n     * @param _coreAddress          Core address\r\n     * @param _vaultAddress         Vault address\r\n     * @return                      Struct containing bidding parameters\r\n     */\r\n    function redeemCurrentSetAndGetBiddingParameters(\r\n        address _currentSet,\r\n        address _nextSet,\r\n        address _auctionLibrary,\r\n        address _coreAddress,\r\n        address _vaultAddress\r\n    )\r\n        public\r\n        returns (RebalancingLibrary.BiddingParameters memory)\r\n    {\r\n        // Redeem rounded quantity of current Sets and return redeemed amount of Sets\r\n        uint256 remainingCurrentSets = redeemCurrentSet(\r\n            _currentSet,\r\n            _coreAddress,\r\n            _vaultAddress\r\n        );\r\n\r\n        // Create combined array data structures and calculate minimum bid needed for auction\r\n        RebalancingLibrary.BiddingParameters memory biddingParameters = setUpBiddingParameters(\r\n            _currentSet,\r\n            _nextSet,\r\n            _auctionLibrary,\r\n            remainingCurrentSets\r\n        );\r\n\r\n        return biddingParameters;\r\n    }\r\n\r\n    /**\r\n     * Create struct that holds array representing all components in currentSet and nextSet.\r\n     * Calcualate unit difference between both sets relative to the largest natural\r\n     * unit of the two sets. Calculate minimumBid.\r\n     *\r\n     * @param _currentSet           Address of current Set\r\n     * @param _nextSet              Address of next Set\r\n     * @param _auctionLibrary       Address of auction library being used in rebalance\r\n     * @param _remainingCurrentSets Quantity of Current Sets redeemed\r\n     * @return                      Struct containing bidding parameters\r\n     */\r\n    function setUpBiddingParameters(\r\n        address _currentSet,\r\n        address _nextSet,\r\n        address _auctionLibrary,\r\n        uint256 _remainingCurrentSets\r\n    )\r\n        public\r\n        returns (RebalancingLibrary.BiddingParameters memory)\r\n    {\r\n        // Get set details for currentSet and nextSet (units, components, natural units)\r\n        SetTokenLibrary.SetDetails memory currentSet = SetTokenLibrary.getSetDetails(_currentSet);\r\n        SetTokenLibrary.SetDetails memory nextSet = SetTokenLibrary.getSetDetails(_nextSet);\r\n\r\n        // Create combinedTokenArray\r\n        address[] memory combinedTokenArray = currentSet.components.union(\r\n            nextSet.components\r\n        );\r\n\r\n        // Calcualate minimumBid\r\n        uint256 minimumBid = calculateMinimumBid(\r\n            currentSet.naturalUnit,\r\n            nextSet.naturalUnit,\r\n            _auctionLibrary\r\n        );\r\n\r\n        // Require remainingCurrentSets to be greater than minimumBid otherwise no bidding would\r\n        // be allowed\r\n        require(\r\n            _remainingCurrentSets >= minimumBid,\r\n            \"RebalancingSetToken.setUpBiddingParameters: Not enough collateral to rebalance\"\r\n        );\r\n\r\n        // Create memory version of combinedNextSetUnits and combinedCurrentUnits to only make one\r\n        // call to storage once arrays have been created\r\n        uint256[] memory combinedCurrentUnits;\r\n        uint256[] memory combinedNextSetUnits;\r\n        (\r\n            combinedCurrentUnits,\r\n            combinedNextSetUnits\r\n        ) = calculateCombinedUnitArrays(\r\n            currentSet,\r\n            nextSet,\r\n            minimumBid,\r\n            _auctionLibrary,\r\n            combinedTokenArray\r\n        );\r\n\r\n        // Build Bidding Parameters struct and return\r\n        return RebalancingLibrary.BiddingParameters({\r\n            minimumBid: minimumBid,\r\n            remainingCurrentSets: _remainingCurrentSets,\r\n            combinedCurrentUnits: combinedCurrentUnits,\r\n            combinedNextSetUnits: combinedNextSetUnits,\r\n            combinedTokenArray: combinedTokenArray\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Calculate the minimumBid allowed for the rebalance\r\n     *\r\n     * @param _currentSetNaturalUnit    Natural unit of currentSet\r\n     * @param _nextSetNaturalUnit       Natural of nextSet\r\n     * @param _auctionLibrary           Address of auction library being used in rebalance\r\n     * @return                          Minimum bid amount\r\n     */\r\n    function calculateMinimumBid(\r\n        uint256 _currentSetNaturalUnit,\r\n        uint256 _nextSetNaturalUnit,\r\n        address _auctionLibrary\r\n    )\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // Get priceDivisor from auctionLibrary\r\n        uint256 priceDivisor = IAuctionPriceCurve(_auctionLibrary).priceDivisor();\r\n\r\n        return Math.max(\r\n            _currentSetNaturalUnit.mul(priceDivisor),\r\n            _nextSetNaturalUnit.mul(priceDivisor)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Create arrays that represents all components in currentSet and nextSet.\r\n     * Calcualate unit difference between both sets relative to the largest natural\r\n     * unit of the two sets.\r\n     *\r\n     * @param _currentSet               Information on currentSet\r\n     * @param _nextSet                  Information on nextSet\r\n     * @param _minimumBid               Minimum bid amount\r\n     * @param _auctionLibrary           Address of auction library being used in rebalance\r\n     * @param _combinedTokenArray       Array of component tokens involved in rebalance\r\n     * @return                          Unit inflow/outflow arrays for current and next Set\r\n     */\r\n    function calculateCombinedUnitArrays(\r\n        SetTokenLibrary.SetDetails memory _currentSet,\r\n        SetTokenLibrary.SetDetails memory _nextSet,\r\n        uint256 _minimumBid,\r\n        address _auctionLibrary,\r\n        address[] memory _combinedTokenArray\r\n    )\r\n        public\r\n        returns (uint256[] memory, uint256[] memory)\r\n    {\r\n        // Create memory version of combinedNextSetUnits and combinedCurrentUnits to only make one\r\n        // call to storage once arrays have been created\r\n        uint256[] memory memoryCombinedCurrentUnits = new uint256[](_combinedTokenArray.length);\r\n        uint256[] memory memoryCombinedNextSetUnits = new uint256[](_combinedTokenArray.length);\r\n\r\n        for (uint256 i = 0; i < _combinedTokenArray.length; i++) {\r\n            memoryCombinedCurrentUnits[i] = calculateCombinedUnit(\r\n                _currentSet,\r\n                _minimumBid,\r\n                _auctionLibrary,\r\n                _combinedTokenArray[i]\r\n            );\r\n\r\n            memoryCombinedNextSetUnits[i] = calculateCombinedUnit(\r\n                _nextSet,\r\n                _minimumBid,\r\n                _auctionLibrary,\r\n                _combinedTokenArray[i]\r\n            );\r\n        }\r\n\r\n        return (memoryCombinedCurrentUnits, memoryCombinedNextSetUnits);\r\n    }\r\n\r\n    /**\r\n     * Calculations the unit amount of Token to include in the the combined Set units.\r\n     *\r\n     * @param _setToken                 Information on the SetToken\r\n     * @param _minimumBid               Minimum bid amount\r\n     * @param _auctionLibrary           Address of auction library being used in rebalance\r\n     * @param _currentComponent         Current component in iteration\r\n     * @return                          Unit inflow/outflow\r\n     */\r\n    function calculateCombinedUnit(\r\n        SetTokenLibrary.SetDetails memory _setToken,\r\n        uint256 _minimumBid,\r\n        address _auctionLibrary,\r\n        address _currentComponent\r\n    )\r\n        private\r\n        returns (uint256)\r\n    {\r\n        // Check if component in arrays and get index if it is\r\n        uint256 indexCurrent;\r\n        bool isComponent;\r\n        (indexCurrent, isComponent) = _setToken.components.indexOf(_currentComponent);\r\n\r\n        // Compute unit amounts of token in Set\r\n        if (isComponent) {\r\n            return computeTransferValue(\r\n                _setToken.units[indexCurrent],\r\n                _setToken.naturalUnit,\r\n                _minimumBid,\r\n                _auctionLibrary\r\n            );\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Calculates the maximum redemption quantity and redeems the Set into the vault.\r\n     * Also updates remainingCurrentSets state variable\r\n     *\r\n     * @param _currentSet           Address of current Set\r\n     * @param _coreAddress          Core address\r\n     * @param _vaultAddress         Vault address\r\n     * @return                      Amount of currentSets remaining\r\n     */\r\n    function redeemCurrentSet(\r\n        address _currentSet,\r\n        address _coreAddress,\r\n        address _vaultAddress\r\n    )\r\n        public\r\n        returns (uint256)\r\n    {\r\n        // Get remainingCurrentSets and make it divisible by currentSet natural unit\r\n        uint256 currentSetBalance = IVault(_vaultAddress).getOwnerBalance(\r\n            _currentSet,\r\n            address(this)\r\n        );\r\n\r\n        // Calculates the set's natural unit\r\n        uint256 currentSetNaturalUnit = ISetToken(_currentSet).naturalUnit();\r\n\r\n        // Rounds the redemption quantity to a multiple of the current Set natural unit and sets variable\r\n        uint256 remainingCurrentSets = currentSetBalance.div(currentSetNaturalUnit).mul(currentSetNaturalUnit);\r\n\r\n        ICore(_coreAddress).redeemInVault(\r\n            _currentSet,\r\n            remainingCurrentSets\r\n        );\r\n\r\n        return remainingCurrentSets;\r\n    }\r\n\r\n   /**\r\n     * Function to calculate the transfer value of a component given a standardized bid amount\r\n     * (minimumBid/priceDivisor)\r\n     *\r\n     * @param   _unit           Units of the component token\r\n     * @param   _naturalUnit    Natural unit of the Set token\r\n     * @param   _minimumBid     Minimum bid amount\r\n     * @return  uint256         Amount of tokens per standard bid amount (minimumBid/priceDivisor)\r\n     */\r\n    function computeTransferValue(\r\n        uint256 _unit,\r\n        uint256 _naturalUnit,\r\n        uint256 _minimumBid,\r\n        address _auctionLibrary\r\n    )\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        uint256 priceDivisor = IAuctionPriceCurve(_auctionLibrary).priceDivisor();\r\n        return _minimumBid.mul(_unit).div(_naturalUnit).div(priceDivisor);\r\n    }\r\n}\r\n\r\n// File: contracts/core/tokens/RebalancingSetToken.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title RebalancingSetToken\r\n * @author Set Protocol\r\n *\r\n * Implementation of Rebalancing Set token.\r\n */\r\ncontract RebalancingSetToken is\r\n    ERC20,\r\n    ERC20Detailed\r\n{\r\n    using SafeMath for uint256;\r\n\r\n    /* ============ State Variables ============ */\r\n\r\n    // Dependency variables\r\n    address public core;\r\n    address public factory;\r\n    address public vault;\r\n    address public componentWhiteListAddress;\r\n\r\n    // Core and Vault instances\r\n    ICore private coreInstance;\r\n    IVault private vaultInstance;\r\n    IWhiteList private componentWhiteListInstance;\r\n\r\n    uint256 public naturalUnit;\r\n    address public manager;\r\n    RebalancingLibrary.State public rebalanceState;\r\n\r\n    // State updated after every rebalance\r\n    address public currentSet;\r\n    uint256 public unitShares;\r\n    uint256 public lastRebalanceTimestamp;\r\n\r\n    // State governing rebalance cycle\r\n    uint256 public proposalPeriod;\r\n    uint256 public rebalanceInterval;\r\n\r\n    // State to track proposal period\r\n    uint256 public proposalStartTime;\r\n\r\n    // State needed for auction/rebalance\r\n    address public nextSet;\r\n    address public auctionLibrary;\r\n    uint256 public startingCurrentSetAmount;\r\n    RebalancingLibrary.AuctionPriceParameters public auctionPriceParameters;\r\n    RebalancingLibrary.BiddingParameters public biddingParameters;\r\n\r\n    // To be used if token put into Drawdown State\r\n    address[] public failedAuctionWithdrawComponents;\r\n\r\n    /* ============ Events ============ */\r\n\r\n    event NewManagerAdded(\r\n        address newManager,\r\n        address oldManager\r\n    );\r\n\r\n    event RebalanceProposed(\r\n        address nextSet,\r\n        address indexed auctionLibrary,\r\n        uint256 indexed proposalPeriodEndTime\r\n    );\r\n\r\n    event RebalanceStarted(\r\n        address oldSet,\r\n        address newSet\r\n    );\r\n\r\n    /* ============ Constructor ============ */\r\n\r\n    /**\r\n     * Constructor function for Rebalancing Set Token\r\n     *\r\n     * @param _factory                   Factory used to create the Rebalancing Set\r\n     * @param _manager                   Manager of the Rebalancing Set\r\n     * @param _initialSet                Initial set that collateralizes the Rebalancing set\r\n     * @param _initialUnitShares         Units of currentSet that equals one share\r\n     * @param _naturalUnit               The minimum multiple of Sets that can be issued or redeemed\r\n     * @param _proposalPeriod            Amount of time for users to inspect a rebalance proposal\r\n     * @param _rebalanceInterval         Minimum amount of time between rebalances\r\n     * @param _componentWhiteList        Address of component WhiteList contract\r\n     * @param _name                      The name of the new RebalancingSetToken\r\n     * @param _symbol                    The symbol of the new RebalancingSetToken\r\n     */\r\n\r\n    constructor(\r\n        address _factory,\r\n        address _manager,\r\n        address _initialSet,\r\n        uint256 _initialUnitShares,\r\n        uint256 _naturalUnit,\r\n        uint256 _proposalPeriod,\r\n        uint256 _rebalanceInterval,\r\n        address _componentWhiteList,\r\n        string memory _name,\r\n        string memory _symbol\r\n    )\r\n        public\r\n        ERC20Detailed(\r\n            _name,\r\n            _symbol,\r\n            18\r\n        )\r\n    {\r\n        // Require initial unit shares is non-zero\r\n        require(\r\n            _initialUnitShares > 0,\r\n            \"RebalancingSetToken.constructor: Unit shares must be positive\"\r\n        );\r\n\r\n        IRebalancingSetFactory tokenFactory = IRebalancingSetFactory(_factory);\r\n\r\n        require(\r\n            _naturalUnit >= tokenFactory.minimumNaturalUnit(),\r\n            \"RebalancingSetToken.constructor: Natural Unit too low\"\r\n        );\r\n\r\n        require(\r\n            _naturalUnit <= tokenFactory.maximumNaturalUnit(),\r\n            \"RebalancingSetToken.constructor: Natural Unit too large\"\r\n        );\r\n\r\n        // Require manager address is non-zero\r\n        require(\r\n            _manager != address(0),\r\n            \"RebalancingSetToken.constructor: Invalid manager address\"\r\n        );\r\n\r\n        // Require minimum rebalance interval and proposal period from factory\r\n        require(\r\n            _proposalPeriod >= tokenFactory.minimumProposalPeriod(),\r\n            \"RebalancingSetToken.constructor: Proposal period too short\"\r\n        );\r\n        require(\r\n            _rebalanceInterval >= tokenFactory.minimumRebalanceInterval(),\r\n            \"RebalancingSetToken.constructor: Rebalance interval too short\"\r\n        );\r\n\r\n        core = IRebalancingSetFactory(_factory).core();\r\n        coreInstance = ICore(core);\r\n        vault = coreInstance.vault();\r\n        vaultInstance = IVault(vault);\r\n        componentWhiteListAddress = _componentWhiteList;\r\n        componentWhiteListInstance = IWhiteList(_componentWhiteList);\r\n        factory = _factory;\r\n        manager = _manager;\r\n        currentSet = _initialSet;\r\n        unitShares = _initialUnitShares;\r\n        naturalUnit = _naturalUnit;\r\n\r\n        proposalPeriod = _proposalPeriod;\r\n        rebalanceInterval = _rebalanceInterval;\r\n        lastRebalanceTimestamp = block.timestamp;\r\n        rebalanceState = RebalancingLibrary.State.Default;\r\n    }\r\n\r\n    /* ============ Public Functions ============ */\r\n\r\n    /**\r\n     * Function used to set the terms of the next rebalance and start the proposal period\r\n     *\r\n     * @param _nextSet                      The Set to rebalance into\r\n     * @param _auctionLibrary               The library used to calculate the Dutch Auction price\r\n     * @param _auctionTimeToPivot           The amount of time for the auction to go ffrom start to pivot price\r\n     * @param _auctionStartPrice            The price to start the auction at\r\n     * @param _auctionPivotPrice            The price at which the price curve switches from linear to exponential\r\n     */\r\n    function propose(\r\n        address _nextSet,\r\n        address _auctionLibrary,\r\n        uint256 _auctionTimeToPivot,\r\n        uint256 _auctionStartPrice,\r\n        uint256 _auctionPivotPrice\r\n    )\r\n        external\r\n    {\r\n        // Put together auction price parameters\r\n        RebalancingLibrary.AuctionPriceParameters memory auctionPriceParams =\r\n            RebalancingLibrary.AuctionPriceParameters({\r\n                auctionTimeToPivot: _auctionTimeToPivot,\r\n                auctionStartPrice: _auctionStartPrice,\r\n                auctionPivotPrice: _auctionPivotPrice,\r\n                auctionStartTime: 0\r\n            });\r\n\r\n        // Create ProposeAuctionParameters\r\n        ProposeLibrary.ProposalContext memory proposalContext =\r\n            ProposeLibrary.ProposalContext({\r\n                manager: manager,\r\n                currentSet: currentSet,\r\n                coreAddress: core,\r\n                componentWhitelist: componentWhiteListAddress,\r\n                factoryAddress: factory,\r\n                lastRebalanceTimestamp: lastRebalanceTimestamp,\r\n                rebalanceInterval: rebalanceInterval,\r\n                rebalanceState: uint8(rebalanceState)\r\n            });\r\n\r\n        // Validate proposal inputs and initialize auctionPriceParameters\r\n        ProposeLibrary.validateProposal(\r\n            _nextSet,\r\n            _auctionLibrary,\r\n            proposalContext,\r\n            auctionPriceParams\r\n        );\r\n\r\n        // Update state parameters\r\n        auctionPriceParameters = auctionPriceParams;\r\n        nextSet = _nextSet;\r\n        auctionLibrary = _auctionLibrary;\r\n        proposalStartTime = block.timestamp;\r\n        rebalanceState = RebalancingLibrary.State.Proposal;\r\n\r\n        emit RebalanceProposed(\r\n            _nextSet,\r\n            _auctionLibrary,\r\n            proposalStartTime.add(proposalPeriod)\r\n        );\r\n    }\r\n\r\n    /*\r\n     * Initiate rebalance for the rebalancing set if the proposal period has elapsed after\r\n     * a proposal.\r\n     */\r\n    function startRebalance()\r\n        external\r\n    {\r\n        // Validate the correct rebalance state and time elapsed\r\n        StartRebalanceLibrary.validateStartRebalance(\r\n            proposalStartTime,\r\n            proposalPeriod,\r\n            uint8(rebalanceState)\r\n        );\r\n\r\n        // Redeem currentSet and set up biddingParameters\r\n        biddingParameters = StartRebalanceLibrary.redeemCurrentSetAndGetBiddingParameters(\r\n            currentSet,\r\n            nextSet,\r\n            auctionLibrary,\r\n            core,\r\n            vault\r\n        );\r\n\r\n        // Update state parameters\r\n        startingCurrentSetAmount = biddingParameters.remainingCurrentSets;\r\n        auctionPriceParameters.auctionStartTime = block.timestamp;\r\n        rebalanceState = RebalancingLibrary.State.Rebalance;\r\n\r\n        emit RebalanceStarted(currentSet, nextSet);\r\n    }\r\n\r\n    /*\r\n     * Initiate settlement for the rebalancing set. Full functionality now returned to\r\n     * set owners\r\n     *\r\n     */\r\n    function settleRebalance()\r\n        external\r\n    {\r\n        // Settle the rebalance and mint next Sets\r\n        unitShares = SettleRebalanceLibrary.settleRebalance(\r\n            totalSupply(),\r\n            biddingParameters.remainingCurrentSets,\r\n            biddingParameters.minimumBid,\r\n            naturalUnit,\r\n            nextSet,\r\n            core,\r\n            vault,\r\n            uint8(rebalanceState)\r\n        );\r\n\r\n        // Update other state parameters\r\n        currentSet = nextSet;\r\n        lastRebalanceTimestamp = block.timestamp;\r\n        rebalanceState = RebalancingLibrary.State.Default;\r\n        clearAuctionState();\r\n    }\r\n\r\n    /*\r\n     * Place bid during rebalance auction. Can only be called by Core.\r\n     *\r\n     * @param _quantity                 The amount of currentSet to be rebalanced\r\n     * @return combinedTokenArray       Array of token addresses invovled in rebalancing\r\n     * @return inflowUnitArray          Array of amount of tokens inserted into system in bid\r\n     * @return outflowUnitArray         Array of amount of tokens taken out of system in bid\r\n     */\r\n    function placeBid(\r\n        uint256 _quantity\r\n    )\r\n        external\r\n        returns (address[] memory, uint256[] memory, uint256[] memory)\r\n    {\r\n        // Validate bid quantity and module is sender\r\n        PlaceBidLibrary.validatePlaceBid(\r\n            _quantity,\r\n            core,\r\n            biddingParameters\r\n        );\r\n\r\n        // Place bid and get back inflow and outflow arrays\r\n        uint256[] memory inflowUnitArray;\r\n        uint256[] memory outflowUnitArray;\r\n        (\r\n            inflowUnitArray,\r\n            outflowUnitArray\r\n        ) = getBidPrice(_quantity);\r\n\r\n        // Update remainingCurrentSet figure to account for placed bid\r\n        biddingParameters.remainingCurrentSets = biddingParameters.remainingCurrentSets.sub(_quantity);\r\n\r\n        return (biddingParameters.combinedTokenArray, inflowUnitArray, outflowUnitArray);\r\n    }\r\n\r\n    /*\r\n     * Fail an auction that doesn't complete before reaching the pivot price. Move to Drawdown state\r\n     * if bids have been placed. Reset to Default state if no bids placed.\r\n     *\r\n     */\r\n    function endFailedAuction()\r\n        external\r\n    {\r\n        uint256 calculatedUnitShares;\r\n        (\r\n            ,\r\n            calculatedUnitShares\r\n        ) = SettleRebalanceLibrary.calculateNextSetIssueQuantity(\r\n            totalSupply(),\r\n            naturalUnit,\r\n            nextSet,\r\n            vault\r\n        );\r\n\r\n        // Fail auction and either reset to Default state or kill Rebalancing Set Token and enter Drawdown\r\n        // state\r\n        uint8 integerRebalanceState = FailAuctionLibrary.endFailedAuction(\r\n            startingCurrentSetAmount,\r\n            calculatedUnitShares,\r\n            currentSet,\r\n            core,\r\n            auctionPriceParameters,\r\n            biddingParameters,\r\n            uint8(rebalanceState)\r\n        );\r\n        rebalanceState = RebalancingLibrary.State(integerRebalanceState);\r\n\r\n        // Reset lastRebalanceTimestamp to now\r\n        lastRebalanceTimestamp = block.timestamp;\r\n\r\n        // Save combined token arrays to failedAuctionWithdrawComponents\r\n        failedAuctionWithdrawComponents = biddingParameters.combinedTokenArray;\r\n\r\n        // Clear auction state\r\n        clearAuctionState();\r\n    }\r\n\r\n    /*\r\n     * Get token inflows and outflows required for bid. Also the amount of Rebalancing\r\n     * Sets that would be generated.\r\n     *\r\n     * @param _quantity               The amount of currentSet to be rebalanced\r\n     * @return inflowUnitArray        Array of amount of tokens inserted into system in bid\r\n     * @return outflowUnitArray       Array of amount of tokens taken out of system in bid\r\n     */\r\n    function getBidPrice(\r\n        uint256 _quantity\r\n    )\r\n        public\r\n        view\r\n        returns (uint256[] memory, uint256[] memory)\r\n    {\r\n        return PlaceBidLibrary.getBidPrice(\r\n            _quantity,\r\n            auctionLibrary,\r\n            biddingParameters,\r\n            auctionPriceParameters,\r\n            uint8(rebalanceState)\r\n        );\r\n    }\r\n\r\n    /*\r\n     * Mint set token for given address.\r\n     * Can only be called by Core contract.\r\n     *\r\n     * @param  _issuer      The address of the issuing account\r\n     * @param  _quantity    The number of sets to attribute to issuer\r\n     */\r\n    function mint(\r\n        address _issuer,\r\n        uint256 _quantity\r\n    )\r\n        external\r\n    {\r\n        // Check that function caller is Core\r\n        require(\r\n            msg.sender == core,\r\n            \"RebalancingSetToken.mint: Sender must be core\"\r\n        );\r\n\r\n        // Check that set is not in Rebalance State\r\n        require(\r\n            rebalanceState != RebalancingLibrary.State.Rebalance,\r\n            \"RebalancingSetToken.mint: Cannot mint during Rebalance\"\r\n        );\r\n\r\n        // Check that set is not in Drawdown State\r\n        require(\r\n            rebalanceState != RebalancingLibrary.State.Drawdown,\r\n            \"RebalancingSetToken.mint: Cannot mint during Drawdown\"\r\n        );\r\n\r\n        // Update token balance of the manager\r\n        _mint(_issuer, _quantity);\r\n    }\r\n\r\n    /*\r\n     * Burn set token for given address.\r\n     * Can only be called by authorized contracts.\r\n     *\r\n     * @param  _from        The address of the redeeming account\r\n     * @param  _quantity    The number of sets to burn from redeemer\r\n     */\r\n    function burn(\r\n        address _from,\r\n        uint256 _quantity\r\n    )\r\n        external\r\n    {\r\n        // Check that set is not in Rebalancing State\r\n        require(\r\n            rebalanceState != RebalancingLibrary.State.Rebalance,\r\n            \"RebalancingSetToken.burn: Cannot burn during Rebalance\"\r\n        );\r\n\r\n        // Check to see if state is Drawdown\r\n        if (rebalanceState == RebalancingLibrary.State.Drawdown) {\r\n            // In Drawdown Sets can only be burned as part of the withdrawal process\r\n            require(\r\n                coreInstance.validModules(msg.sender),\r\n                \"RebalancingSetToken.burn: Set cannot be redeemed during Drawdown\"\r\n            );\r\n        } else {\r\n            // When in non-Rebalance or Drawdown state, check that function caller is Core\r\n            // so that Sets can be redeemed\r\n            require(\r\n                msg.sender == core,\r\n                \"RebalancingSetToken.burn: Sender must be core\"\r\n            );\r\n        }\r\n\r\n        _burn(_from, _quantity);\r\n    }\r\n\r\n    /*\r\n     * Set new manager address\r\n     *\r\n     * @param  _newManager       The address of the new manager account\r\n     */\r\n    function setManager(\r\n        address _newManager\r\n    )\r\n        external\r\n    {\r\n        require(\r\n            msg.sender == manager,\r\n            \"RebalancingSetToken.setManager: Sender must be the manager\"\r\n        );\r\n\r\n        emit NewManagerAdded(_newManager, manager);\r\n        manager = _newManager;\r\n    }\r\n\r\n    /* ============ Getter Functions ============ */\r\n\r\n    /*\r\n     * Get addresses of setToken underlying the Rebalancing Set\r\n     *\r\n     * @return  componentAddresses       Array of currentSet\r\n     */\r\n    function getComponents()\r\n        external\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        address[] memory components = new address[](1);\r\n        components[0] = currentSet;\r\n        return components;\r\n    }\r\n\r\n    /*\r\n     * Get unitShares of Rebalancing Set\r\n     *\r\n     * @return  units       Array of component unit\r\n     */\r\n    function getUnits()\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory units = new uint256[](1);\r\n        units[0] = unitShares;\r\n        return units;\r\n    }\r\n\r\n    /*\r\n     * Get biddingParameters of Rebalancing Set\r\n     *\r\n     * @return  biddingParams       Object with bidding information\r\n     */\r\n    function getBiddingParameters()\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory biddingParams = new uint256[](2);\r\n        biddingParams[0] = biddingParameters.minimumBid;\r\n        biddingParams[1] = biddingParameters.remainingCurrentSets;\r\n        return biddingParams;\r\n    }\r\n\r\n    /*\r\n     * Get auctionPriceParameters of Rebalancing Set\r\n     *\r\n     * @return  auctionParams       Object with auction information\r\n     */\r\n    function getAuctionPriceParameters()\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory auctionParams = new uint256[](4);\r\n        auctionParams[0] = auctionPriceParameters.auctionStartTime;\r\n        auctionParams[1] = auctionPriceParameters.auctionTimeToPivot;\r\n        auctionParams[2] = auctionPriceParameters.auctionStartPrice;\r\n        auctionParams[3] = auctionPriceParameters.auctionPivotPrice;\r\n        return auctionParams;\r\n    }\r\n\r\n    /*\r\n     * Checks to make sure address is the current set of the RebalancingSetToken.\r\n     * Conforms to the ISetToken Interface.\r\n     *\r\n     * @param  _tokenAddress     Address of token being checked\r\n     * @return  bool             True if token is the current Set\r\n     */\r\n    function tokenIsComponent(\r\n        address _tokenAddress\r\n    )\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _tokenAddress == currentSet;\r\n    }\r\n\r\n    /*\r\n     * Get combinedTokenArray of Rebalancing Set\r\n     *\r\n     * @return  combinedTokenArray\r\n     */\r\n    function getCombinedTokenArrayLength()\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return biddingParameters.combinedTokenArray.length;\r\n    }\r\n\r\n    /*\r\n     * Get combinedTokenArray of Rebalancing Set\r\n     *\r\n     * @return  combinedTokenArray\r\n     */\r\n    function getCombinedTokenArray()\r\n        external\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return biddingParameters.combinedTokenArray;\r\n    }\r\n\r\n    /*\r\n     * Get combinedCurrentUnits of Rebalancing Set\r\n     *\r\n     * @return  combinedCurrentUnits\r\n     */\r\n    function getCombinedCurrentUnits()\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        return biddingParameters.combinedCurrentUnits;\r\n    }\r\n\r\n    /*\r\n     * Get combinedNextSetUnits of Rebalancing Set\r\n     *\r\n     * @return  combinedNextSetUnits\r\n     */\r\n    function getCombinedNextSetUnits()\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        return biddingParameters.combinedNextSetUnits;\r\n    }\r\n\r\n    /*\r\n     * Get failedAuctionWithdrawComponents of Rebalancing Set\r\n     *\r\n     * @return  failedAuctionWithdrawComponents\r\n     */\r\n    function getFailedAuctionWithdrawComponents()\r\n        external\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return failedAuctionWithdrawComponents;\r\n    }\r\n\r\n    /* ============ Internal Functions ============ */\r\n\r\n    /*\r\n     * Reset auction specific state after failed or successful rebalance\r\n     */\r\n    function clearAuctionState()\r\n        internal\r\n    {\r\n        nextSet = address(0);\r\n        auctionLibrary = address(0);\r\n        startingCurrentSetAmount = 0;\r\n        delete auctionPriceParameters;\r\n        delete biddingParameters;\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"unitShares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUnits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"failedAuctionWithdrawComponents\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rebalanceInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"tokenIsComponent\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentSet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_issuer\",\"type\":\"address\"},{\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"naturalUnit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startingCurrentSetAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startRebalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCombinedTokenArrayLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"biddingParameters\",\"outputs\":[{\"name\":\"minimumBid\",\"type\":\"uint256\"},{\"name\":\"remainingCurrentSets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endFailedAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nextSet\",\"type\":\"address\"},{\"name\":\"_auctionLibrary\",\"type\":\"address\"},{\"name\":\"_auctionTimeToPivot\",\"type\":\"uint256\"},{\"name\":\"_auctionStartPrice\",\"type\":\"uint256\"},{\"name\":\"_auctionPivotPrice\",\"type\":\"uint256\"}],\"name\":\"propose\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCombinedTokenArray\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionLibrary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"placeBid\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getComponents\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"getBidPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAuctionPriceParameters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBiddingParameters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastRebalanceTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextSet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCombinedNextSetUnits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newManager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionPriceParameters\",\"outputs\":[{\"name\":\"auctionStartTime\",\"type\":\"uint256\"},{\"name\":\"auctionTimeToPivot\",\"type\":\"uint256\"},{\"name\":\"auctionStartPrice\",\"type\":\"uint256\"},{\"name\":\"auctionPivotPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFailedAuctionWithdrawComponents\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCombinedCurrentUnits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"core\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rebalanceState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"settleRebalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"componentWhiteListAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_factory\",\"type\":\"address\"},{\"name\":\"_manager\",\"type\":\"address\"},{\"name\":\"_initialSet\",\"type\":\"address\"},{\"name\":\"_initialUnitShares\",\"type\":\"uint256\"},{\"name\":\"_naturalUnit\",\"type\":\"uint256\"},{\"name\":\"_proposalPeriod\",\"type\":\"uint256\"},{\"name\":\"_rebalanceInterval\",\"type\":\"uint256\"},{\"name\":\"_componentWhiteList\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newManager\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldManager\",\"type\":\"address\"}],\"name\":\"NewManagerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"nextSet\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"auctionLibrary\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"proposalPeriodEndTime\",\"type\":\"uint256\"}],\"name\":\"RebalanceProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldSet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newSet\",\"type\":\"address\"}],\"name\":\"RebalanceStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "RebalancingSetToken", "CompilerVersion": "v0.5.7+commit.6da8b019", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000015518cdd49d83471e9f85cdcfbd72c8e2a78dde20000000000000000000000009d622389970120c38fa491b6d1ca5328237889e5000000000000000000000000d14d4e7eb9b36ae1ac0efd5e0833bf517eafd91c000000000000000000000000000000000000000000000000000000000008893500000000000000000000000000000000000000000000000000000000000f424000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054600000000000000000000000000c6449473be76ab2a70329fa66cbe504a2500533800000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000180000000000000000000000000000000000000000000000000000000000000001845544820353020534d412043726f73736f766572205365740000000000000000000000000000000000000000000000000000000000000000000000000000000a4554483530534d41434f00000000000000000000000000000000000000000000", "EVMVersion": "byzantium", "Library": "FailAuctionLibrary:a2619134b0851744d6e5052392400df73b24d7fc;PlaceBidLibrary:4689051f4246630deb7c1c4cfb2ffa25643d886c;ProposeLibrary:dd5825965a016d8bbbbdf4862a1ac9d3fb6d5382;SettleRebalanceLibrary:c0aafee4b4edc54dd3aea0bf4dbe7bddde6365ca;StartRebalanceLibrary:b2d113cd923b763bd4f2187233257da57f3f1ddb", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://2bbac5ffc9e275d60b7960627099bd2842502594fa837be06c87496fe14bbbf8"}