{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/DelegateRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.21;\\n\\nimport {IDelegateRegistry as IDelegateRegistry} from \\\"./IDelegateRegistry.sol\\\";\\nimport {RegistryHashes as Hashes} from \\\"./libraries/RegistryHashes.sol\\\";\\nimport {RegistryStorage as Storage} from \\\"./libraries/RegistryStorage.sol\\\";\\nimport {RegistryOps as Ops} from \\\"./libraries/RegistryOps.sol\\\";\\n\\n/**\\n * @title DelegateRegistry\\n * @custom:version 2.0\\n * @custom:coauthor foobar (0xfoobar)\\n * @custom:coauthor mireynolds\\n * @notice A standalone immutable registry storing delegated permissions from one address to another\\n */\\ncontract DelegateRegistry is IDelegateRegistry {\\n    /// @dev Only this mapping should be used to verify delegations; the other mapping arrays are for enumerations\\n    mapping(bytes32 delegationHash => bytes32[5] delegationStorage) internal delegations;\\n\\n    /// @dev Vault delegation enumeration outbox, for pushing new hashes only\\n    mapping(address from => bytes32[] delegationHashes) internal outgoingDelegationHashes;\\n\\n    /// @dev Delegate enumeration inbox, for pushing new hashes only\\n    mapping(address to => bytes32[] delegationHashes) internal incomingDelegationHashes;\\n\\n    /**\\n     * ----------- WRITE -----------\\n     */\\n\\n    /// @inheritdoc IDelegateRegistry\\n    function multicall(bytes[] calldata data) external payable override returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        bool success;\\n        unchecked {\\n            for (uint256 i = 0; i < data.length; ++i) {\\n                //slither-disable-next-line calls-loop,delegatecall-loop\\n                (success, results[i]) = address(this).delegatecall(data[i]);\\n                if (!success) revert MulticallFailed();\\n            }\\n        }\\n    }\\n\\n    /// @inheritdoc IDelegateRegistry\\n    function delegateAll(address to, bytes32 rights, bool enable) external payable override returns (bytes32 hash) {\\n        hash = Hashes.allHash(msg.sender, rights, to);\\n        bytes32 location = Hashes.location(hash);\\n        address loadedFrom = _loadFrom(location);\\n        if (enable) {\\n            if (loadedFrom == Storage.DELEGATION_EMPTY) {\\n                _pushDelegationHashes(msg.sender, to, hash);\\n                _writeDelegationAddresses(location, msg.sender, to, address(0));\\n                if (rights != \\\"\\\") _writeDelegation(location, Storage.POSITIONS_RIGHTS, rights);\\n            } else if (loadedFrom == Storage.DELEGATION_REVOKED) {\\n                _updateFrom(location, msg.sender);\\n            }\\n        } else if (loadedFrom == msg.sender) {\\n            _updateFrom(location, Storage.DELEGATION_REVOKED);\\n        }\\n        emit DelegateAll(msg.sender, to, rights, enable);\\n    }\\n\\n    /// @inheritdoc IDelegateRegistry\\n    function delegateContract(address to, address contract_, bytes32 rights, bool enable) external payable override returns (bytes32 hash) {\\n        hash = Hashes.contractHash(msg.sender, rights, to, contract_);\\n        bytes32 location = Hashes.location(hash);\\n        address loadedFrom = _loadFrom(location);\\n        if (enable) {\\n            if (loadedFrom == Storage.DELEGATION_EMPTY) {\\n                _pushDelegationHashes(msg.sender, to, hash);\\n                _writeDelegationAddresses(location, msg.sender, to, contract_);\\n                if (rights != \\\"\\\") _writeDelegation(location, Storage.POSITIONS_RIGHTS, rights);\\n            } else if (loadedFrom == Storage.DELEGATION_REVOKED) {\\n                _updateFrom(location, msg.sender);\\n            }\\n        } else if (loadedFrom == msg.sender) {\\n            _updateFrom(location, Storage.DELEGATION_REVOKED);\\n        }\\n        emit DelegateContract(msg.sender, to, contract_, rights, enable);\\n    }\\n\\n    /// @inheritdoc IDelegateRegistry\\n    function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable) external payable override returns (bytes32 hash) {\\n        hash = Hashes.erc721Hash(msg.sender, rights, to, tokenId, contract_);\\n        bytes32 location = Hashes.location(hash);\\n        address loadedFrom = _loadFrom(location);\\n        if (enable) {\\n            if (loadedFrom == Storage.DELEGATION_EMPTY) {\\n                _pushDelegationHashes(msg.sender, to, hash);\\n                _writeDelegationAddresses(location, msg.sender, to, contract_);\\n                _writeDelegation(location, Storage.POSITIONS_TOKEN_ID, tokenId);\\n                if (rights != \\\"\\\") _writeDelegation(location, Storage.POSITIONS_RIGHTS, rights);\\n            } else if (loadedFrom == Storage.DELEGATION_REVOKED) {\\n                _updateFrom(location, msg.sender);\\n            }\\n        } else if (loadedFrom == msg.sender) {\\n            _updateFrom(location, Storage.DELEGATION_REVOKED);\\n        }\\n        emit DelegateERC721(msg.sender, to, contract_, tokenId, rights, enable);\\n    }\\n\\n    // @inheritdoc IDelegateRegistry\\n    function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount) external payable override returns (bytes32 hash) {\\n        hash = Hashes.erc20Hash(msg.sender, rights, to, contract_);\\n        bytes32 location = Hashes.location(hash);\\n        address loadedFrom = _loadFrom(location);\\n        if (amount != 0) {\\n            if (loadedFrom == Storage.DELEGATION_EMPTY) {\\n                _pushDelegationHashes(msg.sender, to, hash);\\n                _writeDelegationAddresses(location, msg.sender, to, contract_);\\n                _writeDelegation(location, Storage.POSITIONS_AMOUNT, amount);\\n                if (rights != \\\"\\\") _writeDelegation(location, Storage.POSITIONS_RIGHTS, rights);\\n            } else if (loadedFrom == Storage.DELEGATION_REVOKED) {\\n                _updateFrom(location, msg.sender);\\n                _writeDelegation(location, Storage.POSITIONS_AMOUNT, amount);\\n            } else if (loadedFrom == msg.sender) {\\n                _writeDelegation(location, Storage.POSITIONS_AMOUNT, amount);\\n            }\\n        } else if (loadedFrom == msg.sender) {\\n            _updateFrom(location, Storage.DELEGATION_REVOKED);\\n            _writeDelegation(location, Storage.POSITIONS_AMOUNT, uint256(0));\\n        }\\n        emit DelegateERC20(msg.sender, to, contract_, rights, amount);\\n    }\\n\\n    /// @inheritdoc IDelegateRegistry\\n    function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount) external payable override returns (bytes32 hash) {\\n        hash = Hashes.erc1155Hash(msg.sender, rights, to, tokenId, contract_);\\n        bytes32 location = Hashes.location(hash);\\n        address loadedFrom = _loadFrom(location);\\n        if (amount != 0) {\\n            if (loadedFrom == Storage.DELEGATION_EMPTY) {\\n                _pushDelegationHashes(msg.sender, to, hash);\\n                _writeDelegationAddresses(location, msg.sender, to, contract_);\\n                _writeDelegation(location, Storage.POSITIONS_TOKEN_ID, tokenId);\\n                _writeDelegation(location, Storage.POSITIONS_AMOUNT, amount);\\n                if (rights != \\\"\\\") _writeDelegation(location, Storage.POSITIONS_RIGHTS, rights);\\n            } else if (loadedFrom == Storage.DELEGATION_REVOKED) {\\n                _updateFrom(location, msg.sender);\\n                _writeDelegation(location, Storage.POSITIONS_AMOUNT, amount);\\n            } else if (loadedFrom == msg.sender) {\\n                _writeDelegation(location, Storage.POSITIONS_AMOUNT, amount);\\n            }\\n        } else if (loadedFrom == msg.sender) {\\n            _updateFrom(location, Storage.DELEGATION_REVOKED);\\n            _writeDelegation(location, Storage.POSITIONS_AMOUNT, uint256(0));\\n        }\\n        emit DelegateERC1155(msg.sender, to, contract_, tokenId, rights, amount);\\n    }\\n\\n    /// @dev Transfer native token out\\n    function sweep() external {\\n        assembly (\\\"memory-safe\\\") {\\n            // This hardcoded address is a CREATE2 factory counterfactual smart contract wallet that will always accept native token transfers\\n            let result := call(gas(), 0x000000dE1E80ea5a234FB5488fee2584251BC7e8, selfbalance(), 0, 0, 0, 0)\\n        }\\n    }\\n\\n    /**\\n     * ----------- CHECKS -----------\\n     */\\n\\n    /// @inheritdoc IDelegateRegistry\\n    function checkDelegateForAll(address to, address from, bytes32 rights) external view override returns (bool valid) {\\n        if (!_invalidFrom(from)) {\\n            valid = _validateFrom(Hashes.allLocation(from, \\\"\\\", to), from);\\n            if (!Ops.or(rights == \\\"\\\", valid)) valid = _validateFrom(Hashes.allLocation(from, rights, to), from);\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            // Only first 32 bytes of scratch space is accessed\\n            mstore(0, iszero(iszero(valid))) // Compiler cleans dirty booleans on the stack to 1, so do the same here\\n            return(0, 32) // Direct return, skips Solidity's redundant copying to save gas\\n        }\\n    }\\n\\n    /// @inheritdoc IDelegateRegistry\\n    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights) external view override returns (bool valid) {\\n        if (!_invalidFrom(from)) {\\n            valid = _validateFrom(Hashes.allLocation(from, \\\"\\\", to), from) || _validateFrom(Hashes.contractLocation(from, \\\"\\\", to, contract_), from);\\n            if (!Ops.or(rights == \\\"\\\", valid)) {\\n                valid = _validateFrom(Hashes.allLocation(from, rights, to), from) || _validateFrom(Hashes.contractLocation(from, rights, to, contract_), from);\\n            }\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            // Only first 32 bytes of scratch space is accessed\\n            mstore(0, iszero(iszero(valid))) // Compiler cleans dirty booleans on the stack to 1, so do the same here\\n            return(0, 32) // Direct return, skips Solidity's redundant copying to save gas\\n        }\\n    }\\n\\n    /// @inheritdoc IDelegateRegistry\\n    function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights) external view override returns (bool valid) {\\n        if (!_invalidFrom(from)) {\\n            valid = _validateFrom(Hashes.allLocation(from, \\\"\\\", to), from) || _validateFrom(Hashes.contractLocation(from, \\\"\\\", to, contract_), from)\\n                || _validateFrom(Hashes.erc721Location(from, \\\"\\\", to, tokenId, contract_), from);\\n            if (!Ops.or(rights == \\\"\\\", valid)) {\\n                valid = _validateFrom(Hashes.allLocation(from, rights, to), from) || _validateFrom(Hashes.contractLocation(from, rights, to, contract_), from)\\n                    || _validateFrom(Hashes.erc721Location(from, rights, to, tokenId, contract_), from);\\n            }\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            // Only first 32 bytes of scratch space is accessed\\n            mstore(0, iszero(iszero(valid))) // Compiler cleans dirty booleans on the stack to 1, so do the same here\\n            return(0, 32) // Direct return, skips Solidity's redundant copying to save gas\\n        }\\n    }\\n\\n    /// @inheritdoc IDelegateRegistry\\n    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights) external view override returns (uint256 amount) {\\n        if (!_invalidFrom(from)) {\\n            amount = (_validateFrom(Hashes.allLocation(from, \\\"\\\", to), from) || _validateFrom(Hashes.contractLocation(from, \\\"\\\", to, contract_), from))\\n                ? type(uint256).max\\n                : _loadDelegationUint(Hashes.erc20Location(from, \\\"\\\", to, contract_), Storage.POSITIONS_AMOUNT);\\n            if (!Ops.or(rights == \\\"\\\", amount == type(uint256).max)) {\\n                uint256 rightsBalance = (_validateFrom(Hashes.allLocation(from, rights, to), from) || _validateFrom(Hashes.contractLocation(from, rights, to, contract_), from))\\n                    ? type(uint256).max\\n                    : _loadDelegationUint(Hashes.erc20Location(from, rights, to, contract_), Storage.POSITIONS_AMOUNT);\\n                amount = Ops.max(rightsBalance, amount);\\n            }\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0, amount) // Only first 32 bytes of scratch space being accessed\\n            return(0, 32) // Direct return, skips Solidity's redundant copying to save gas\\n        }\\n    }\\n\\n    /// @inheritdoc IDelegateRegistry\\n    function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights) external view override returns (uint256 amount) {\\n        if (!_invalidFrom(from)) {\\n            amount = (_validateFrom(Hashes.allLocation(from, \\\"\\\", to), from) || _validateFrom(Hashes.contractLocation(from, \\\"\\\", to, contract_), from))\\n                ? type(uint256).max\\n                : _loadDelegationUint(Hashes.erc1155Location(from, \\\"\\\", to, tokenId, contract_), Storage.POSITIONS_AMOUNT);\\n            if (!Ops.or(rights == \\\"\\\", amount == type(uint256).max)) {\\n                uint256 rightsBalance = (_validateFrom(Hashes.allLocation(from, rights, to), from) || _validateFrom(Hashes.contractLocation(from, rights, to, contract_), from))\\n                    ? type(uint256).max\\n                    : _loadDelegationUint(Hashes.erc1155Location(from, rights, to, tokenId, contract_), Storage.POSITIONS_AMOUNT);\\n                amount = Ops.max(rightsBalance, amount);\\n            }\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0, amount) // Only first 32 bytes of scratch space is accessed\\n            return(0, 32) // Direct return, skips Solidity's redundant copying to save gas\\n        }\\n    }\\n\\n    /**\\n     * ----------- ENUMERATIONS -----------\\n     */\\n\\n    /// @inheritdoc IDelegateRegistry\\n    function getIncomingDelegations(address to) external view override returns (Delegation[] memory delegations_) {\\n        delegations_ = _getValidDelegationsFromHashes(incomingDelegationHashes[to]);\\n    }\\n\\n    /// @inheritdoc IDelegateRegistry\\n    function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations_) {\\n        delegations_ = _getValidDelegationsFromHashes(outgoingDelegationHashes[from]);\\n    }\\n\\n    /// @inheritdoc IDelegateRegistry\\n    function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes) {\\n        delegationHashes = _getValidDelegationHashesFromHashes(incomingDelegationHashes[to]);\\n    }\\n\\n    /// @inheritdoc IDelegateRegistry\\n    function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes) {\\n        delegationHashes = _getValidDelegationHashesFromHashes(outgoingDelegationHashes[from]);\\n    }\\n\\n    /// @inheritdoc IDelegateRegistry\\n    function getDelegationsFromHashes(bytes32[] calldata hashes) external view returns (Delegation[] memory delegations_) {\\n        delegations_ = new Delegation[](hashes.length);\\n        unchecked {\\n            for (uint256 i = 0; i < hashes.length; ++i) {\\n                bytes32 location = Hashes.location(hashes[i]);\\n                address from = _loadFrom(location);\\n                if (_invalidFrom(from)) {\\n                    delegations_[i] = Delegation({type_: DelegationType.NONE, to: address(0), from: address(0), rights: \\\"\\\", amount: 0, contract_: address(0), tokenId: 0});\\n                } else {\\n                    (, address to, address contract_) = _loadDelegationAddresses(location);\\n                    delegations_[i] = Delegation({\\n                        type_: Hashes.decodeType(hashes[i]),\\n                        to: to,\\n                        from: from,\\n                        rights: _loadDelegationBytes32(location, Storage.POSITIONS_RIGHTS),\\n                        amount: _loadDelegationUint(location, Storage.POSITIONS_AMOUNT),\\n                        contract_: contract_,\\n                        tokenId: _loadDelegationUint(location, Storage.POSITIONS_TOKEN_ID)\\n                    });\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * ----------- EXTERNAL STORAGE ACCESS -----------\\n     */\\n\\n    function readSlot(bytes32 location) external view returns (bytes32 contents) {\\n        assembly {\\n            contents := sload(location)\\n        }\\n    }\\n\\n    function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory contents) {\\n        uint256 length = locations.length;\\n        contents = new bytes32[](length);\\n        bytes32 tempLocation;\\n        bytes32 tempValue;\\n        unchecked {\\n            for (uint256 i = 0; i < length; ++i) {\\n                tempLocation = locations[i];\\n                assembly {\\n                    tempValue := sload(tempLocation)\\n                }\\n                contents[i] = tempValue;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * ----------- ERC165 -----------\\n     */\\n\\n    /// @notice Query if a contract implements an ERC-165 interface\\n    /// @param interfaceId The interface identifier\\n    /// @return valid Whether the queried interface is supported\\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\\n        return Ops.or(interfaceId == type(IDelegateRegistry).interfaceId, interfaceId == 0x01ffc9a7);\\n    }\\n\\n    /**\\n     * ----------- INTERNAL -----------\\n     */\\n\\n    /// @dev Helper function to push new delegation hashes to the incoming and outgoing hashes mappings\\n    function _pushDelegationHashes(address from, address to, bytes32 delegationHash) internal {\\n        outgoingDelegationHashes[from].push(delegationHash);\\n        incomingDelegationHashes[to].push(delegationHash);\\n    }\\n\\n    /// @dev Helper function that writes bytes32 data to delegation data location at array position\\n    function _writeDelegation(bytes32 location, uint256 position, bytes32 data) internal {\\n        assembly {\\n            sstore(add(location, position), data)\\n        }\\n    }\\n\\n    /// @dev Helper function that writes uint256 data to delegation data location at array position\\n    function _writeDelegation(bytes32 location, uint256 position, uint256 data) internal {\\n        assembly {\\n            sstore(add(location, position), data)\\n        }\\n    }\\n\\n    /// @dev Helper function that writes addresses according to the packing rule for delegation storage\\n    function _writeDelegationAddresses(bytes32 location, address from, address to, address contract_) internal {\\n        (bytes32 firstSlot, bytes32 secondSlot) = Storage.packAddresses(from, to, contract_);\\n        uint256 firstPacked = Storage.POSITIONS_FIRST_PACKED;\\n        uint256 secondPacked = Storage.POSITIONS_SECOND_PACKED;\\n        assembly {\\n            sstore(add(location, firstPacked), firstSlot)\\n            sstore(add(location, secondPacked), secondSlot)\\n        }\\n    }\\n\\n    /// @dev Helper function that writes `from` while preserving the rest of the storage slot\\n    function _updateFrom(bytes32 location, address from) internal {\\n        uint256 firstPacked = Storage.POSITIONS_FIRST_PACKED;\\n        uint256 cleanAddress = Storage.CLEAN_ADDRESS;\\n        uint256 cleanUpper12Bytes = type(uint256).max << 160;\\n        assembly {\\n            let slot := and(sload(add(location, firstPacked)), cleanUpper12Bytes)\\n            sstore(add(location, firstPacked), or(slot, and(from, cleanAddress)))\\n        }\\n    }\\n\\n    /// @dev Helper function that takes an array of delegation hashes and returns an array of Delegation structs with their onchain information\\n    function _getValidDelegationsFromHashes(bytes32[] storage hashes) internal view returns (Delegation[] memory delegations_) {\\n        uint256 count = 0;\\n        uint256 hashesLength = hashes.length;\\n        bytes32 hash;\\n        bytes32[] memory filteredHashes = new bytes32[](hashesLength);\\n        unchecked {\\n            for (uint256 i = 0; i < hashesLength; ++i) {\\n                hash = hashes[i];\\n                if (_invalidFrom(_loadFrom(Hashes.location(hash)))) continue;\\n                filteredHashes[count++] = hash;\\n            }\\n            delegations_ = new Delegation[](count);\\n            bytes32 location;\\n            for (uint256 i = 0; i < count; ++i) {\\n                hash = filteredHashes[i];\\n                location = Hashes.location(hash);\\n                (address from, address to, address contract_) = _loadDelegationAddresses(location);\\n                delegations_[i] = Delegation({\\n                    type_: Hashes.decodeType(hash),\\n                    to: to,\\n                    from: from,\\n                    rights: _loadDelegationBytes32(location, Storage.POSITIONS_RIGHTS),\\n                    amount: _loadDelegationUint(location, Storage.POSITIONS_AMOUNT),\\n                    contract_: contract_,\\n                    tokenId: _loadDelegationUint(location, Storage.POSITIONS_TOKEN_ID)\\n                });\\n            }\\n        }\\n    }\\n\\n    /// @dev Helper function that takes an array of delegation hashes and returns an array of valid delegation hashes\\n    function _getValidDelegationHashesFromHashes(bytes32[] storage hashes) internal view returns (bytes32[] memory validHashes) {\\n        uint256 count = 0;\\n        uint256 hashesLength = hashes.length;\\n        bytes32 hash;\\n        bytes32[] memory filteredHashes = new bytes32[](hashesLength);\\n        unchecked {\\n            for (uint256 i = 0; i < hashesLength; ++i) {\\n                hash = hashes[i];\\n                if (_invalidFrom(_loadFrom(Hashes.location(hash)))) continue;\\n                filteredHashes[count++] = hash;\\n            }\\n            validHashes = new bytes32[](count);\\n            for (uint256 i = 0; i < count; ++i) {\\n                validHashes[i] = filteredHashes[i];\\n            }\\n        }\\n    }\\n\\n    /// @dev Helper function that loads delegation data from a particular array position and returns as bytes32\\n    function _loadDelegationBytes32(bytes32 location, uint256 position) internal view returns (bytes32 data) {\\n        assembly {\\n            data := sload(add(location, position))\\n        }\\n    }\\n\\n    /// @dev Helper function that loads delegation data from a particular array position and returns as uint256\\n    function _loadDelegationUint(bytes32 location, uint256 position) internal view returns (uint256 data) {\\n        assembly {\\n            data := sload(add(location, position))\\n        }\\n    }\\n\\n    // @dev Helper function that loads the from address from storage according to the packing rule for delegation storage\\n    function _loadFrom(bytes32 location) internal view returns (address) {\\n        bytes32 data;\\n        uint256 firstPacked = Storage.POSITIONS_FIRST_PACKED;\\n        assembly {\\n            data := sload(add(location, firstPacked))\\n        }\\n        return Storage.unpackAddress(data);\\n    }\\n\\n    /// @dev Helper function to establish whether a delegation is enabled\\n    function _validateFrom(bytes32 location, address from) internal view returns (bool) {\\n        return (from == _loadFrom(location));\\n    }\\n\\n    /// @dev Helper function that loads the address for the delegation according to the packing rule for delegation storage\\n    function _loadDelegationAddresses(bytes32 location) internal view returns (address from, address to, address contract_) {\\n        bytes32 firstSlot;\\n        bytes32 secondSlot;\\n        uint256 firstPacked = Storage.POSITIONS_FIRST_PACKED;\\n        uint256 secondPacked = Storage.POSITIONS_SECOND_PACKED;\\n        assembly {\\n            firstSlot := sload(add(location, firstPacked))\\n            secondSlot := sload(add(location, secondPacked))\\n        }\\n        (from, to, contract_) = Storage.unpackAddresses(firstSlot, secondSlot);\\n    }\\n\\n    function _invalidFrom(address from) internal pure returns (bool) {\\n        return Ops.or(from == Storage.DELEGATION_EMPTY, from == Storage.DELEGATION_REVOKED);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/IDelegateRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity >=0.8.13;\\n\\n/**\\n * @title IDelegateRegistry\\n * @custom:version 2.0\\n * @custom:author foobar (0xfoobar)\\n * @notice A standalone immutable registry storing delegated permissions from one address to another\\n */\\ninterface IDelegateRegistry {\\n    /// @notice Delegation type, NONE is used when a delegation does not exist or is revoked\\n    enum DelegationType {\\n        NONE,\\n        ALL,\\n        CONTRACT,\\n        ERC721,\\n        ERC20,\\n        ERC1155\\n    }\\n\\n    /// @notice Struct for returning delegations\\n    struct Delegation {\\n        DelegationType type_;\\n        address to;\\n        address from;\\n        bytes32 rights;\\n        address contract_;\\n        uint256 tokenId;\\n        uint256 amount;\\n    }\\n\\n    /// @notice Emitted when an address delegates or revokes rights for their entire wallet\\n    event DelegateAll(address indexed from, address indexed to, bytes32 rights, bool enable);\\n\\n    /// @notice Emitted when an address delegates or revokes rights for a contract address\\n    event DelegateContract(address indexed from, address indexed to, address indexed contract_, bytes32 rights, bool enable);\\n\\n    /// @notice Emitted when an address delegates or revokes rights for an ERC721 tokenId\\n    event DelegateERC721(address indexed from, address indexed to, address indexed contract_, uint256 tokenId, bytes32 rights, bool enable);\\n\\n    /// @notice Emitted when an address delegates or revokes rights for an amount of ERC20 tokens\\n    event DelegateERC20(address indexed from, address indexed to, address indexed contract_, bytes32 rights, uint256 amount);\\n\\n    /// @notice Emitted when an address delegates or revokes rights for an amount of an ERC1155 tokenId\\n    event DelegateERC1155(address indexed from, address indexed to, address indexed contract_, uint256 tokenId, bytes32 rights, uint256 amount);\\n\\n    /// @notice Thrown if multicall calldata is malformed\\n    error MulticallFailed();\\n\\n    /**\\n     * -----------  WRITE -----------\\n     */\\n\\n    /**\\n     * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\\n     * @param data The encoded function data for each of the calls to make to this contract\\n     * @return results The results from each of the calls passed in via data\\n     */\\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\\n\\n    /**\\n     * @notice Allow the delegate to act on behalf of `msg.sender` for all contracts\\n     * @param to The address to act as delegate\\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\\n     * @return delegationHash The unique identifier of the delegation\\n     */\\n    function delegateAll(address to, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\\n\\n    /**\\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific contract\\n     * @param to The address to act as delegate\\n     * @param contract_ The contract whose rights are being delegated\\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\\n     * @return delegationHash The unique identifier of the delegation\\n     */\\n    function delegateContract(address to, address contract_, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\\n\\n    /**\\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific ERC721 token\\n     * @param to The address to act as delegate\\n     * @param contract_ The contract whose rights are being delegated\\n     * @param tokenId The token id to delegate\\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\\n     * @return delegationHash The unique identifier of the delegation\\n     */\\n    function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\\n\\n    /**\\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC20 tokens\\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\\n     * @param to The address to act as delegate\\n     * @param contract_ The address for the fungible token contract\\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\\n     * @param amount The amount to delegate, > 0 delegates and 0 revokes\\n     * @return delegationHash The unique identifier of the delegation\\n     */\\n    function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount) external payable returns (bytes32 delegationHash);\\n\\n    /**\\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC1155 tokens\\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\\n     * @param to The address to act as delegate\\n     * @param contract_ The address of the contract that holds the token\\n     * @param tokenId The token id to delegate\\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\\n     * @param amount The amount of that token id to delegate, > 0 delegates and 0 revokes\\n     * @return delegationHash The unique identifier of the delegation\\n     */\\n    function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount) external payable returns (bytes32 delegationHash);\\n\\n    /**\\n     * ----------- CHECKS -----------\\n     */\\n\\n    /**\\n     * @notice Check if `to` is a delegate of `from` for the entire wallet\\n     * @param to The potential delegate address\\n     * @param from The potential address who delegated rights\\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\\n     * @return valid Whether delegate is granted to act on the from's behalf\\n     */\\n    function checkDelegateForAll(address to, address from, bytes32 rights) external view returns (bool);\\n\\n    /**\\n     * @notice Check if `to` is a delegate of `from` for the specified `contract_` or the entire wallet\\n     * @param to The delegated address to check\\n     * @param contract_ The specific contract address being checked\\n     * @param from The cold wallet who issued the delegation\\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet or that specific contract\\n     */\\n    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights) external view returns (bool);\\n\\n    /**\\n     * @notice Check if `to` is a delegate of `from` for the specific `contract` and `tokenId`, the entire `contract_`, or the entire wallet\\n     * @param to The delegated address to check\\n     * @param contract_ The specific contract address being checked\\n     * @param tokenId The token id for the token to delegating\\n     * @param from The wallet that issued the delegation\\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet, that contract, or that specific tokenId\\n     */\\n    function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the amount of ERC20 tokens the delegate is granted rights to act on the behalf of\\n     * @param to The delegated address to check\\n     * @param contract_ The address of the token contract\\n     * @param from The cold wallet who issued the delegation\\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\\n     */\\n    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the amount of a ERC1155 tokens the delegate is granted rights to act on the behalf of\\n     * @param to The delegated address to check\\n     * @param contract_ The address of the token contract\\n     * @param tokenId The token id to check the delegated amount of\\n     * @param from The cold wallet who issued the delegation\\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\\n     */\\n    function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights) external view returns (uint256);\\n\\n    /**\\n     * ----------- ENUMERATIONS -----------\\n     */\\n\\n    /**\\n     * @notice Returns all enabled delegations a given delegate has received\\n     * @param to The address to retrieve delegations for\\n     * @return delegations Array of Delegation structs\\n     */\\n    function getIncomingDelegations(address to) external view returns (Delegation[] memory delegations);\\n\\n    /**\\n     * @notice Returns all enabled delegations an address has given out\\n     * @param from The address to retrieve delegations for\\n     * @return delegations Array of Delegation structs\\n     */\\n    function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations);\\n\\n    /**\\n     * @notice Returns all hashes associated with enabled delegations an address has received\\n     * @param to The address to retrieve incoming delegation hashes for\\n     * @return delegationHashes Array of delegation hashes\\n     */\\n    function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes);\\n\\n    /**\\n     * @notice Returns all hashes associated with enabled delegations an address has given out\\n     * @param from The address to retrieve outgoing delegation hashes for\\n     * @return delegationHashes Array of delegation hashes\\n     */\\n    function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes);\\n\\n    /**\\n     * @notice Returns the delegations for a given array of delegation hashes\\n     * @param delegationHashes is an array of hashes that correspond to delegations\\n     * @return delegations Array of Delegation structs, return empty structs for nonexistent or revoked delegations\\n     */\\n    function getDelegationsFromHashes(bytes32[] calldata delegationHashes) external view returns (Delegation[] memory delegations);\\n\\n    /**\\n     * ----------- STORAGE ACCESS -----------\\n     */\\n\\n    /**\\n     * @notice Allows external contracts to read arbitrary storage slots\\n     */\\n    function readSlot(bytes32 location) external view returns (bytes32);\\n\\n    /**\\n     * @notice Allows external contracts to read an arbitrary array of storage slots\\n     */\\n    function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory);\\n}\\n\"\r\n    },\r\n    \"src/libraries/RegistryHashes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.21;\\n\\nimport {IDelegateRegistry} from \\\"../IDelegateRegistry.sol\\\";\\n\\n/**\\n * @title Library for calculating the hashes and storage locations used in the delegate registry\\n *\\n * The encoding for the 5 types of delegate registry hashes should be as follows:\\n *\\n * ALL:         keccak256(abi.encodePacked(rights, from, to))\\n * CONTRACT:    keccak256(abi.encodePacked(rights, from, to, contract_))\\n * ERC721:      keccak256(abi.encodePacked(rights, from, to, contract_, tokenId))\\n * ERC20:       keccak256(abi.encodePacked(rights, from, to, contract_))\\n * ERC1155:     keccak256(abi.encodePacked(rights, from, to, contract_, tokenId))\\n *\\n * To avoid collisions between the hashes with respect to type, the hash is shifted left by one byte\\n * and the last byte is then encoded with a unique number for the delegation type\\n *\\n */\\nlibrary RegistryHashes {\\n    /// @dev Used to delete everything but the last byte of a 32 byte word with and(word, EXTRACT_LAST_BYTE)\\n    uint256 internal constant EXTRACT_LAST_BYTE = 0xff;\\n    /// @dev Constants for the delegate registry delegation type enumeration\\n    uint256 internal constant ALL_TYPE = 1;\\n    uint256 internal constant CONTRACT_TYPE = 2;\\n    uint256 internal constant ERC721_TYPE = 3;\\n    uint256 internal constant ERC20_TYPE = 4;\\n    uint256 internal constant ERC1155_TYPE = 5;\\n    /// @dev Constant for the location of the delegations array in the delegate registry, defined to be zero\\n    uint256 internal constant DELEGATION_SLOT = 0;\\n\\n    /**\\n     * @notice Helper function to decode last byte of a delegation hash into its delegation type enum\\n     * @param inputHash The bytehash to decode the type from\\n     * @return decodedType The delegation type\\n     */\\n    function decodeType(bytes32 inputHash) internal pure returns (IDelegateRegistry.DelegationType decodedType) {\\n        assembly {\\n            decodedType := and(inputHash, EXTRACT_LAST_BYTE)\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function that computes the storage location of a particular delegation array\\n     * @dev Storage keys further down the array can be obtained by adding computedLocation with the element position\\n     * @dev Follows the solidity storage location encoding for a mapping(bytes32 => fixedArray) at the position of the delegationSlot\\n     * @param inputHash The bytehash to decode the type from\\n     * @return computedLocation is the storage key of the delegation array at position 0\\n     */\\n    function location(bytes32 inputHash) internal pure returns (bytes32 computedLocation) {\\n        assembly (\\\"memory-safe\\\") {\\n            // This block only allocates memory in the scratch space\\n            mstore(0, inputHash)\\n            mstore(32, DELEGATION_SLOT)\\n            computedLocation := keccak256(0, 64) // Run keccak256 over bytes in scratch space to obtain the storage key\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function to compute delegation hash for `DelegationType.ALL`\\n     * @dev Equivalent to `keccak256(abi.encodePacked(rights, from, to))` then left-shift by 1 byte and write the delegation type to the cleaned last byte\\n     * @dev Will not revert if `from` or `to` are > uint160, any input larger than uint160 for `from` and `to` will be cleaned to its lower 20 bytes\\n     * @param from The address making the delegation\\n     * @param rights The rights specified by the delegation\\n     * @param to The address receiving the delegation\\n     * @return hash The delegation parameters encoded with ALL_TYPE\\n     */\\n    function allHash(address from, bytes32 rights, address to) internal pure returns (bytes32 hash) {\\n        assembly (\\\"memory-safe\\\") {\\n            // This block only allocates memory after the free memory pointer\\n            let ptr := mload(64) // Load the free memory pointer\\n            // Lay out the variables from last to first, agnostic to upper 96 bits of address words.\\n            mstore(add(ptr, 40), to)\\n            mstore(add(ptr, 20), from)\\n            mstore(ptr, rights)\\n            hash := or(shl(8, keccak256(ptr, 72)), ALL_TYPE) // Keccak-hashes the packed encoding, left-shifts by one byte, then writes type to the lowest-order byte\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function to compute delegation location for `DelegationType.ALL`\\n     * @dev Equivalent to `location(allHash(rights, from, to))`\\n     * @dev Will not revert if `from` or `to` are > uint160, any input larger than uint160 for `from` and `to` will be cleaned to its lower 20 bytes\\n     * @param from The address making the delegation\\n     * @param rights The rights specified by the delegation\\n     * @param to The address receiving the delegation\\n     * @return computedLocation The storage location of the all delegation with those parameters in the delegations mapping\\n     */\\n    function allLocation(address from, bytes32 rights, address to) internal pure returns (bytes32 computedLocation) {\\n        assembly (\\\"memory-safe\\\") {\\n            // This block only allocates memory after the free memory pointer and in the scratch space\\n            let ptr := mload(64) // Load the free memory pointer\\n            // Lay out the variables from last to first, agnostic to upper 96 bits of address words.\\n            mstore(add(ptr, 40), to)\\n            mstore(add(ptr, 20), from)\\n            mstore(ptr, rights)\\n            mstore(0, or(shl(8, keccak256(ptr, 72)), ALL_TYPE)) // Computes `allHash`, then stores the result in scratch space\\n            mstore(32, DELEGATION_SLOT)\\n            computedLocation := keccak256(0, 64) // Runs keccak over the scratch space to obtain the storage key\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function to compute delegation hash for `DelegationType.CONTRACT`\\n     * @dev Equivalent to keccak256(abi.encodePacked(rights, from, to, contract_)) left-shifted by 1 then last byte overwritten with CONTRACT_TYPE\\n     * @dev Will not revert if `from`, `to` or `contract_` are > uint160, these inputs will be cleaned to their lower 20 bytes\\n     * @param from The address making the delegation\\n     * @param rights The rights specified by the delegation\\n     * @param to The address receiving the delegation\\n     * @param contract_ The address of the contract specified by the delegation\\n     * @return hash The delegation parameters encoded with CONTRACT_TYPE\\n     */\\n    function contractHash(address from, bytes32 rights, address to, address contract_) internal pure returns (bytes32 hash) {\\n        assembly (\\\"memory-safe\\\") {\\n            // This block only allocates memory after the free memory pointer\\n            let ptr := mload(64) // Load the free memory pointer\\n            // Lay out the variables from last to first, agnostic to upper 96 bits of address words.\\n            mstore(add(ptr, 60), contract_)\\n            mstore(add(ptr, 40), to)\\n            mstore(add(ptr, 20), from)\\n            mstore(ptr, rights)\\n            hash := or(shl(8, keccak256(ptr, 92)), CONTRACT_TYPE) // Keccak-hashes the packed encoding, left-shifts by one byte, then writes type to the lowest-order byte\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function to compute delegation location for `DelegationType.CONTRACT`\\n     * @dev Equivalent to `location(contractHash(rights, from, to, contract_))`\\n     * @dev Will not revert if `from`, `to` or `contract_` are > uint160, these inputs will be cleaned to their lower 20 bytes\\n     * @param from The address making the delegation\\n     * @param rights The rights specified by the delegation\\n     * @param to The address receiving the delegation\\n     * @param contract_ The address of the contract specified by the delegation\\n     * @return computedLocation The storage location of the contract delegation with those parameters in the delegations mapping\\n     */\\n    function contractLocation(address from, bytes32 rights, address to, address contract_) internal pure returns (bytes32 computedLocation) {\\n        assembly (\\\"memory-safe\\\") {\\n            // This block only allocates memory after the free memory pointer and in the scratch space\\n            let ptr := mload(64) // Load free memory pointer\\n            // Lay out the variables from last to first, agnostic to upper 96 bits of address words.\\n            mstore(add(ptr, 60), contract_)\\n            mstore(add(ptr, 40), to)\\n            mstore(add(ptr, 20), from)\\n            mstore(ptr, rights)\\n            mstore(0, or(shl(8, keccak256(ptr, 92)), CONTRACT_TYPE)) // Computes `contractHash`, then stores the result in scratch space\\n            mstore(32, DELEGATION_SLOT)\\n            computedLocation := keccak256(0, 64) // Runs keccak over the scratch space to obtain the storage key\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function to compute delegation hash for `DelegationType.ERC721`\\n     * @dev Equivalent to `keccak256(abi.encodePacked(rights, from, to, contract_, tokenId)) left-shifted by 1 then last byte overwritten with ERC721_TYPE\\n     * @dev Will not revert if `from`, `to` or `contract_` are > uint160, these inputs will be cleaned to their lower 20 bytes\\n     * @param from The address making the delegation\\n     * @param rights The rights specified by the delegation\\n     * @param to The address receiving the delegation\\n     * @param tokenId The id of the token specified by the delegation\\n     * @param contract_ The address of the contract specified by the delegation\\n     * @return hash The delegation parameters encoded with ERC721_TYPE\\n     */\\n    function erc721Hash(address from, bytes32 rights, address to, uint256 tokenId, address contract_) internal pure returns (bytes32 hash) {\\n        assembly (\\\"memory-safe\\\") {\\n            // This block only allocates memory after the free memory pointer\\n            let ptr := mload(64) // Cache the free memory pointer.\\n            // Lay out the variables from last to first, agnostic to upper 96 bits of address words.\\n            mstore(add(ptr, 92), tokenId)\\n            mstore(add(ptr, 60), contract_)\\n            mstore(add(ptr, 40), to)\\n            mstore(add(ptr, 20), from)\\n            mstore(ptr, rights)\\n            hash := or(shl(8, keccak256(ptr, 124)), ERC721_TYPE) // Keccak-hashes the packed encoding, left-shifts by one byte, then writes type to the lowest-order byte\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function to compute delegation location for `DelegationType.ERC721`\\n     * @dev Equivalent to `location(ERC721Hash(rights, from, to, contract_, tokenId))`\\n     * @dev Will not revert if `from`, `to` or `contract_` are > uint160, these inputs will be cleaned to their lower 20 bytes\\n     * @param from The address making the delegation\\n     * @param rights The rights specified by the delegation\\n     * @param to The address receiving the delegation\\n     * @param tokenId The id of the ERC721 token\\n     * @param contract_ The address of the ERC721 token contract\\n     * @return computedLocation The storage location of the ERC721 delegation with those parameters in the delegations mapping\\n     */\\n    function erc721Location(address from, bytes32 rights, address to, uint256 tokenId, address contract_) internal pure returns (bytes32 computedLocation) {\\n        assembly (\\\"memory-safe\\\") {\\n            // This block only allocates memory after the free memory pointer and in the scratch space\\n            let ptr := mload(64) // Cache the free memory pointer.\\n            // Lay out the variables from last to first, agnostic to upper 96 bits of address words.\\n            mstore(add(ptr, 92), tokenId)\\n            mstore(add(ptr, 60), contract_)\\n            mstore(add(ptr, 40), to)\\n            mstore(add(ptr, 20), from)\\n            mstore(ptr, rights)\\n            mstore(0, or(shl(8, keccak256(ptr, 124)), ERC721_TYPE)) // Computes erc721Hash, then stores the result in scratch space\\n            mstore(32, DELEGATION_SLOT)\\n            computedLocation := keccak256(0, 64) // Runs keccak256 over the scratch space to obtain the storage key\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function to compute delegation hash for `DelegationType.ERC20`\\n     * @dev Equivalent to `keccak256(abi.encodePacked(rights, from, to, contract_))` with the last byte overwritten with ERC20_TYPE\\n     * @dev Will not revert if `from`, `to` or `contract_` are > uint160, these inputs will be cleaned to their lower 20 bytes\\n     * @param from The address making the delegation\\n     * @param rights The rights specified by the delegation\\n     * @param to The address receiving the delegation\\n     * @param contract_ The address of the ERC20 token contract\\n     * @return hash The parameters encoded with ERC20_TYPE\\n     */\\n    function erc20Hash(address from, bytes32 rights, address to, address contract_) internal pure returns (bytes32 hash) {\\n        assembly (\\\"memory-safe\\\") {\\n            // This block only allocates memory after the free memory pointer\\n            let ptr := mload(64) // Load free memory pointer\\n            // Lay out the variables from last to first, agnostic to upper 96 bits of address words.\\n            mstore(add(ptr, 60), contract_)\\n            mstore(add(ptr, 40), to)\\n            mstore(add(ptr, 20), from)\\n            mstore(ptr, rights)\\n            hash := or(shl(8, keccak256(ptr, 92)), ERC20_TYPE) // Keccak-hashes the packed encoding, left-shifts by one byte, then writes type to the lowest-order byte\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function to compute delegation location for `DelegationType.ERC20`\\n     * @dev Equivalent to `location(ERC20Hash(rights, from, to, contract_))`\\n     * @dev Will not revert if `from`, `to` or `contract_` are > uint160, these inputs will be cleaned to their lower 20 bytes\\n     * @param from The address making the delegation\\n     * @param rights The rights specified by the delegation\\n     * @param to The address receiving the delegation\\n     * @param contract_ The address of the ERC20 token contract\\n     * @return computedLocation The storage location of the ERC20 delegation with those parameters in the delegations mapping\\n     */\\n    function erc20Location(address from, bytes32 rights, address to, address contract_) internal pure returns (bytes32 computedLocation) {\\n        assembly (\\\"memory-safe\\\") {\\n            // This block only allocates memory after the free memory pointer and in the scratch space\\n            let ptr := mload(64) // Loads the free memory pointer\\n            // Lay out the variables from last to first, agnostic to upper 96 bits of address words.\\n            mstore(add(ptr, 60), contract_)\\n            mstore(add(ptr, 40), to)\\n            mstore(add(ptr, 20), from)\\n            mstore(ptr, rights)\\n            mstore(0, or(shl(8, keccak256(ptr, 92)), ERC20_TYPE)) // Computes erc20Hash, then stores the result in scratch space\\n            mstore(32, DELEGATION_SLOT)\\n            computedLocation := keccak256(0, 64) // Runs keccak over the scratch space to obtain the storage key\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function to compute delegation hash for `DelegationType.ERC1155`\\n     * @dev Equivalent to keccak256(abi.encodePacked(rights, from, to, contract_, tokenId)) left-shifted with the last byte overwritten with ERC1155_TYPE\\n     * @dev Will not revert if `from`, `to` or `contract_` are > uint160, these inputs will be cleaned to their lower 20 bytes\\n     * @param from The address making the delegation\\n     * @param rights The rights specified by the delegation\\n     * @param to The address receiving the delegation\\n     * @param tokenId The id of the ERC1155 token\\n     * @param contract_ The address of the ERC1155 token contract\\n     * @return hash The parameters encoded with ERC1155_TYPE\\n     */\\n    function erc1155Hash(address from, bytes32 rights, address to, uint256 tokenId, address contract_) internal pure returns (bytes32 hash) {\\n        assembly (\\\"memory-safe\\\") {\\n            // This block only allocates memory after the free memory pointer\\n            let ptr := mload(64) // Load the free memory pointer.\\n            // Lay out the variables from last to first, agnostic to upper 96 bits of address words.\\n            mstore(add(ptr, 92), tokenId)\\n            mstore(add(ptr, 60), contract_)\\n            mstore(add(ptr, 40), to)\\n            mstore(add(ptr, 20), from)\\n            mstore(ptr, rights)\\n            hash := or(shl(8, keccak256(ptr, 124)), ERC1155_TYPE) // Keccak-hashes the packed encoding, left-shifts by one byte, then writes type to the lowest-order byte\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function to compute delegation location for `DelegationType.ERC1155`\\n     * @dev Equivalent to `location(ERC1155Hash(rights, from, to, contract_, tokenId))`\\n     * @dev Will not revert if `from`, `to` or `contract_` are > uint160, these inputs will be cleaned to their lower 20 bytes\\n     * @param from The address making the delegation\\n     * @param rights The rights specified by the delegation\\n     * @param to The address receiving the delegation\\n     * @param tokenId The id of the ERC1155 token\\n     * @param contract_ The address of the ERC1155 token contract\\n     * @return computedLocation The storage location of the ERC1155 delegation with those parameters in the delegations mapping\\n     */\\n    function erc1155Location(address from, bytes32 rights, address to, uint256 tokenId, address contract_) internal pure returns (bytes32 computedLocation) {\\n        assembly (\\\"memory-safe\\\") {\\n            // This block only allocates memory after the free memory pointer and in the scratch space\\n            let ptr := mload(64) // Cache the free memory pointer.\\n            // Lay out the variables from last to first, agnostic to upper 96 bits of address words.\\n            mstore(add(ptr, 92), tokenId)\\n            mstore(add(ptr, 60), contract_)\\n            mstore(add(ptr, 40), to)\\n            mstore(add(ptr, 20), from)\\n            mstore(ptr, rights)\\n            mstore(0, or(shl(8, keccak256(ptr, 124)), ERC1155_TYPE)) // Computes erc1155Hash, then stores the result in scratch space\\n            mstore(32, DELEGATION_SLOT)\\n            computedLocation := keccak256(0, 64) // Runs keccak over the scratch space to obtain the storage key\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/RegistryStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.21;\\n\\nlibrary RegistryStorage {\\n    /// @dev Standardizes `from` storage flags to prevent double-writes in the delegation in/outbox if the same delegation is revoked and rewritten\\n    address internal constant DELEGATION_EMPTY = address(0);\\n    address internal constant DELEGATION_REVOKED = address(1);\\n\\n    /// @dev Standardizes storage positions of delegation data\\n    uint256 internal constant POSITIONS_FIRST_PACKED = 0; //  | 4 bytes empty | first 8 bytes of contract address | 20 bytes of from address |\\n    uint256 internal constant POSITIONS_SECOND_PACKED = 1; // |        last 12 bytes of contract address          | 20 bytes of to address   |\\n    uint256 internal constant POSITIONS_RIGHTS = 2;\\n    uint256 internal constant POSITIONS_TOKEN_ID = 3;\\n    uint256 internal constant POSITIONS_AMOUNT = 4;\\n\\n    /// @dev Used to clean address types of dirty bits with `and(address, CLEAN_ADDRESS)`\\n    uint256 internal constant CLEAN_ADDRESS = 0x00ffffffffffffffffffffffffffffffffffffffff;\\n\\n    /// @dev Used to clean everything but the first 8 bytes of an address\\n    uint256 internal constant CLEAN_FIRST8_BYTES_ADDRESS = 0xffffffffffffffff << 96;\\n\\n    /// @dev Used to clean everything but the first 8 bytes of an address in the packed position\\n    uint256 internal constant CLEAN_PACKED8_BYTES_ADDRESS = 0xffffffffffffffff << 160;\\n\\n    /**\\n     * @notice Helper function that packs from, to, and contract_ address to into the two slot configuration\\n     * @param from The address making the delegation\\n     * @param to The address receiving the delegation\\n     * @param contract_ The contract address associated with the delegation (optional)\\n     * @return firstPacked The firstPacked storage configured with the parameters\\n     * @return secondPacked The secondPacked storage configured with the parameters\\n     * @dev Will not revert if `from`, `to`, and `contract_` are > uint160, any inputs with dirty bits outside the last 20 bytes will be cleaned\\n     */\\n    function packAddresses(address from, address to, address contract_) internal pure returns (bytes32 firstPacked, bytes32 secondPacked) {\\n        assembly {\\n            firstPacked := or(shl(64, and(contract_, CLEAN_FIRST8_BYTES_ADDRESS)), and(from, CLEAN_ADDRESS))\\n            secondPacked := or(shl(160, contract_), and(to, CLEAN_ADDRESS))\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function that unpacks from, to, and contract_ address inside the firstPacked secondPacked storage configuration\\n     * @param firstPacked The firstPacked storage to be decoded\\n     * @param secondPacked The secondPacked storage to be decoded\\n     * @return from The address making the delegation\\n     * @return to The address receiving the delegation\\n     * @return contract_ The contract address associated with the delegation\\n     * @dev Will not revert if `from`, `to`, and `contract_` are > uint160, any inputs with dirty bits outside the last 20 bytes will be cleaned\\n     */\\n    function unpackAddresses(bytes32 firstPacked, bytes32 secondPacked) internal pure returns (address from, address to, address contract_) {\\n        assembly {\\n            from := and(firstPacked, CLEAN_ADDRESS)\\n            to := and(secondPacked, CLEAN_ADDRESS)\\n            contract_ := or(shr(64, and(firstPacked, CLEAN_PACKED8_BYTES_ADDRESS)), shr(160, secondPacked))\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function that can unpack the from or to address from their respective packed slots in the registry\\n     * @param packedSlot The slot containing the from or to address\\n     * @return unpacked The `from` or `to` address\\n     * @dev Will not work if you want to obtain the contract address, use unpackAddresses\\n     */\\n    function unpackAddress(bytes32 packedSlot) internal pure returns (address unpacked) {\\n        assembly {\\n            unpacked := and(packedSlot, CLEAN_ADDRESS)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/RegistryOps.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.21;\\n\\nlibrary RegistryOps {\\n    /// @dev `x > y ? x : y`.\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            // `gt(y, x)` will evaluate to 1 if `y > x`, else 0.\\n            //\\n            // If `y > x`:\\n            //     `x ^ ((x ^ y) * 1) = x ^ (x ^ y) = (x ^ x) ^ y = 0 ^ y = y`.\\n            // otherwise:\\n            //     `x ^ ((x ^ y) * 0) = x ^ 0 = x`.\\n            z := xor(x, mul(xor(x, y), gt(y, x)))\\n        }\\n    }\\n\\n    /// @dev `x & y`.\\n    function and(bool x, bool y) internal pure returns (bool z) {\\n        assembly {\\n            z := and(iszero(iszero(x)), iszero(iszero(y))) // Compiler cleans dirty booleans on the stack to 1, so do the same here\\n        }\\n    }\\n\\n    /// @dev `x | y`.\\n    function or(bool x, bool y) internal pure returns (bool z) {\\n        assembly {\\n            z := or(iszero(iszero(x)), iszero(iszero(y))) // Compiler cleans dirty booleans on the stack to 1, so do the same here\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"murky/=lib/murky/src/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999999\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"MulticallFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"rights\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"DelegateAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"rights\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"DelegateContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"rights\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DelegateERC1155\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"rights\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DelegateERC20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"rights\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"DelegateERC721\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"rights\",\"type\":\"bytes32\"}],\"name\":\"checkDelegateForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"rights\",\"type\":\"bytes32\"}],\"name\":\"checkDelegateForContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"rights\",\"type\":\"bytes32\"}],\"name\":\"checkDelegateForERC1155\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"rights\",\"type\":\"bytes32\"}],\"name\":\"checkDelegateForERC20\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"rights\",\"type\":\"bytes32\"}],\"name\":\"checkDelegateForERC721\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"rights\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"delegateAll\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"rights\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"delegateContract\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"rights\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"delegateERC1155\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"rights\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"delegateERC20\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"rights\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"delegateERC721\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"hashes\",\"type\":\"bytes32[]\"}],\"name\":\"getDelegationsFromHashes\",\"outputs\":[{\"components\":[{\"internalType\":\"enum IDelegateRegistry.DelegationType\",\"name\":\"type_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"rights\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct IDelegateRegistry.Delegation[]\",\"name\":\"delegations_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"getIncomingDelegationHashes\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"delegationHashes\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"getIncomingDelegations\",\"outputs\":[{\"components\":[{\"internalType\":\"enum IDelegateRegistry.DelegationType\",\"name\":\"type_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"rights\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct IDelegateRegistry.Delegation[]\",\"name\":\"delegations_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"getOutgoingDelegationHashes\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"delegationHashes\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"getOutgoingDelegations\",\"outputs\":[{\"components\":[{\"internalType\":\"enum IDelegateRegistry.DelegationType\",\"name\":\"type_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"rights\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct IDelegateRegistry.Delegation[]\",\"name\":\"delegations_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"location\",\"type\":\"bytes32\"}],\"name\":\"readSlot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"contents\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"locations\",\"type\":\"bytes32[]\"}],\"name\":\"readSlots\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"contents\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sweep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DelegateRegistry", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "9999999", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}