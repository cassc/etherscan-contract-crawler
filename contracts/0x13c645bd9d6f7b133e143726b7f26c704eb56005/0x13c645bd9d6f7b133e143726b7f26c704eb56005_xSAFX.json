{"SourceCode": "// SPDX-License-Identifier: Unlicensed\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nabstract contract Ownable {\r\n    address internal owner;\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"!OWNER\");\r\n        _;\r\n    }\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n    function transferOwnership(address payable _ownerNew) external onlyOwner {\r\n        owner = _ownerNew;\r\n        emit OwnershipTransferred(_ownerNew);\r\n    }\r\n    event OwnershipTransferred(address _ownerNew);\r\n}\r\n\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IWETH {\r\n    function withdraw(uint wad) external;\r\n}\r\n\r\ninterface IRewardManager {\r\n    function setShare(address _wallet, uint256 _amount) external;\r\n    function depositRewards() external payable;\r\n}\r\n\r\ncontract RewardManager is IRewardManager, Ownable {\r\n    address _token;\r\n\r\n    struct Share {\r\n        uint256 amount;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised;\r\n    }\r\n\r\n    address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    IERC20 public weth = IERC20(WETH);\r\n    IWETH public wethContract = IWETH(WETH);\r\n\r\n    address[] private _wallets;\r\n    mapping (address => uint256) private _walletIndexes;\r\n\r\n    mapping (address => uint256) public totalRewardsDistributed;\r\n    mapping (address => mapping (address => uint256)) public totalRewardsToUser;\r\n\r\n    mapping (address => Share) public shares;\r\n\r\n    uint256 public totalShares;\r\n    uint256 public totalRewards;\r\n    uint256 public totalDistributed;\r\n    uint256 public rewardsPerShare;\r\n    uint256 public constant rpsPrecision = 10 ** 36;\r\n\r\n    modifier onlyToken() {\r\n        require(msg.sender == _token);\r\n        _;\r\n    }\r\n\r\n    constructor (address _owner) Ownable(_owner) {\r\n        _token = msg.sender;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function setShare(address _wallet, uint256 _amount) external override onlyToken {\r\n        if (shares[_wallet].amount > 0) _claimRewards(_wallet, address(0));\r\n\r\n        if (_amount > 0 && shares[_wallet].amount == 0) {\r\n            _walletIndexes[_wallet] = _wallets.length;\r\n            _wallets.push(_wallet);\r\n        } else if (_amount == 0 && shares[_wallet].amount > 0) {\r\n            _wallets[_walletIndexes[_wallet]] = _wallets[_wallets.length - 1];\r\n            _walletIndexes[_wallets[_wallets.length - 1]] = _walletIndexes[_wallet];\r\n            _wallets.pop();\r\n        }\r\n\r\n        totalShares = totalShares - shares[_wallet].amount + _amount;\r\n        shares[_wallet].amount = _amount;\r\n        shares[_wallet].totalExcluded = shares[_wallet].amount * rewardsPerShare / rpsPrecision;\r\n    }\r\n\r\n    function depositRewards() external payable override onlyToken {\r\n        totalRewards = totalRewards + msg.value;\r\n        rewardsPerShare = rewardsPerShare + (rpsPrecision * msg.value / totalShares);\r\n    }\r\n\r\n    function _claimRewards(address _wallet, address _reward) private {\r\n        require(_reward == address(0) || _reward == WETH, \"Invalid reward address!\");\r\n        if (shares[_wallet].amount == 0) return;\r\n\r\n        uint256 amount = getUnclaimedRewards(_wallet);\r\n        if (amount > 0) {\r\n            totalDistributed = totalDistributed + amount;\r\n            shares[_wallet].totalRealised = shares[_wallet].totalRealised + amount;\r\n            shares[_wallet].totalExcluded = shares[_wallet].amount * rewardsPerShare / rpsPrecision;\r\n            if (_reward == address(0)) {\r\n                payable(_wallet).call{value: amount}(\"\");\r\n                totalRewardsDistributed[_reward] = totalRewardsDistributed[_reward] + amount;\r\n                totalRewardsToUser[_reward][_wallet] = totalRewardsToUser[_reward][_wallet] + amount;\r\n            } else {\r\n                wethContract.withdraw(amount);\r\n                weth.transfer(_wallet, amount);\r\n                totalRewardsDistributed[_reward] = totalRewardsDistributed[_reward] + amount;\r\n                totalRewardsToUser[_reward][_wallet] = totalRewardsToUser[_reward][_wallet] + amount;\r\n            }\r\n        }\r\n    }\r\n\r\n    function claimRewards(address _reward) external {\r\n        _claimRewards(msg.sender, _reward);\r\n    }\r\n\r\n    function getUnclaimedRewards(address _wallet) public view returns (uint256) {\r\n        if (shares[_wallet].amount == 0) return 0;\r\n        uint256 walletTotalRewards = shares[_wallet].amount * rewardsPerShare / rpsPrecision;\r\n        uint256 walletTotalExcluded = shares[_wallet].totalExcluded;\r\n        return walletTotalRewards <= walletTotalExcluded ? 0 : walletTotalRewards - walletTotalExcluded;\r\n    }\r\n\r\n    function getTotalRewards(address token) external view returns (uint256) {\r\n        return totalRewardsDistributed[token];\r\n    }\r\n\r\n    function getTotalRewardsToUser(address token, address user) external view returns (uint256) {\r\n        return totalRewardsToUser[token][user];\r\n    }\r\n\r\n    function transferERC(address _erc20Address) external onlyOwner {\r\n        require(_erc20Address != WETH, \"Can't withdraw WETH\");\r\n        IERC20 _erc20 = IERC20(_erc20Address);\r\n        _erc20.transfer(msg.sender, _erc20.balanceOf(address(this)));\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract xSAFX is IERC20, Ownable, ReentrancyGuard {\r\n    string public constant _name = \"Staked SAFX\";\r\n    string public constant _symbol = \"xSAFX\";\r\n    uint8 public constant _decimals = 9;\r\n\r\n    uint256 public constant _totalSupply = 1_000_000_000 * (10 ** _decimals);\r\n\r\n    mapping (address => uint256) _balances;\r\n    mapping (address => mapping (address => uint256)) _allowances;\r\n\r\n    mapping (address => bool) public noReward;\r\n\r\n    address public SAFX = 0x0654b7f747c9Ee9F5Fb5EbA443E9FE64F1fA77ef;\r\n    IERC20 public safx = IERC20(SAFX);\r\n\r\n    address public XSAFX;\r\n    IERC20 public xsafx;\r\n\r\n    address public pair;\r\n\r\n    RewardManager manager;\r\n\r\n    bool public stakingLive = false;\r\n\r\n    bool public canChangeSAFX = true;\r\n    bool public canPause = true;\r\n    bool public paused = false;\r\n\r\n    mapping (address => bool) private _depositors;\r\n\r\n    constructor () Ownable(msg.sender) {\r\n        XSAFX = address(this);\r\n        xsafx = IERC20(XSAFX);\r\n\r\n        pair = IDEXFactory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f).createPair(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, XSAFX);\r\n        manager = new RewardManager(msg.sender);\r\n\r\n        noReward[pair] = true;\r\n        noReward[XSAFX] = true;\r\n        noReward[0x000000000000000000000000000000000000dEaD] = true;\r\n    \r\n        _depositors[msg.sender] = true;\r\n\r\n        approve(XSAFX, _totalSupply);\r\n        approve(SAFX, _totalSupply);\r\n        _balances[XSAFX] = _totalSupply;\r\n        emit Transfer(address(0), XSAFX, _totalSupply);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function isDepositor(address account) public view returns (bool) {\r\n        return _depositors[account];\r\n    }\r\n\r\n    modifier onlyDepositor() {\r\n        require(isDepositor(msg.sender), \"!DEPOSITOR\");\r\n        _;\r\n    }\r\n\r\n    function stake(uint256 _amount) external nonReentrant {\r\n        require(!paused, \"This contract is paused\");\r\n        require(safx.balanceOf(msg.sender) >= _amount, \"Your SAFX balance is too low\");\r\n        require(safx.allowance(msg.sender, XSAFX) >= _amount, \"SAFX allowance is too low\");\r\n        require(_totalSupply >= _amount, \"The amount exceeds the supply\");\r\n        bool _transfer = safx.transferFrom(msg.sender, XSAFX, _amount);\r\n        require(_transfer, \"Failed to receive tokens\");\r\n        _transferFrom(XSAFX, msg.sender, _amount);\r\n    }\r\n\r\n    function unstake(uint256 _amount) external nonReentrant {\r\n        require(!paused, \"This contract is paused\");\r\n        require(_balances[msg.sender] >= _amount, \"Your xSAFX balance is too low\");\r\n        require(_allowances[msg.sender][XSAFX] >= _amount, \"xSAFX allowance is too low\");\r\n        require(safx.balanceOf(XSAFX) >= _amount, \"The contract SAFX balance is too low\");\r\n        bool _transfer = _transferFrom(msg.sender, XSAFX, _amount);\r\n        require(_transfer, \"Failed to send tokens\");\r\n        safx.transfer(msg.sender, _amount);\r\n    }\r\n\r\n    function depositRewards() external payable onlyDepositor {\r\n        if (msg.value > 0) try manager.depositRewards{value: msg.value}() {} catch {}\r\n    }\r\n\r\n    function changeDepositor(address _depositor, bool _value) external onlyOwner {\r\n        _depositors[_depositor] = _value;\r\n    }\r\n\r\n    function disableCanPause() external onlyOwner {\r\n        require(canPause, \"Already disabled\");\r\n        canPause = false;\r\n    }\r\n\r\n    function setPaused(bool _paused) external onlyOwner {\r\n        if (_paused == false) require(canPause, \"Invalid permissions\");\r\n        paused = _paused;\r\n    }\r\n\r\n    function totalSupply() external pure override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function decimals() external pure override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function symbol() external pure override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function name() external pure override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function getOwner() external view override returns (address) {\r\n        return owner;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function allowance(address holder, address spender) external view override returns (uint256) {\r\n        return _allowances[holder][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, _totalSupply);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        if (_allowances[sender][msg.sender] != _totalSupply) {\r\n            require(_allowances[sender][msg.sender] >= amount, \"Insufficient allowance\");\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;\r\n        }\r\n\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function _transferFrom(address sender, address recipient, uint256 amount) private returns (bool) {\r\n        require(stakingLive, \"Staking not live\");\r\n        require(_balances[sender] >= amount, \"Insufficient balance\");\r\n        _balances[sender] = _balances[sender] - amount;\r\n        _balances[recipient] = _balances[recipient] + amount;\r\n\r\n        if (!noReward[sender]) try manager.setShare(sender, _balances[sender]) {} catch {}\r\n        if (!noReward[recipient]) try manager.setShare(recipient, _balances[recipient]) {} catch {}\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function disableCanChangeSAFX() external onlyOwner {\r\n        require(canChangeSAFX, \"Already disabled\");\r\n        canChangeSAFX = false;\r\n    }\r\n\r\n    function changeSAFX(address _SAFX) external onlyOwner {\r\n        require(canChangeSAFX, \"Invalid permissions\");\r\n        SAFX = _SAFX;\r\n        safx = IERC20(_SAFX);\r\n        approve(_SAFX, _totalSupply);\r\n    }\r\n\r\n    function setNoReward(address _wallet, bool _value) external onlyOwner {\r\n        noReward[_wallet] = _value;\r\n        manager.setShare(_wallet, _value ? 0 : _balances[_wallet]);\r\n    }\r\n\r\n    function fetchNoReward(address _wallet) public view returns (bool) {\r\n        return noReward[_wallet];\r\n    }\r\n\r\n    function enableStaking() external onlyOwner {\r\n        stakingLive = true;\r\n    }\r\n\r\n    function getCirculatingSupply() public view returns (uint256) {\r\n        return _totalSupply - balanceOf(0x000000000000000000000000000000000000dEaD) - balanceOf(0x0000000000000000000000000000000000000000);\r\n    }\r\n\r\n    function transferETH() external onlyOwner {\r\n        payable(msg.sender).call{value: SAFX.balance}(\"\");\r\n    }\r\n\r\n    function transferERC(address _erc20Address) external onlyOwner {\r\n        require(_erc20Address != SAFX, \"Can't withdraw SAFX\");\r\n        require(_erc20Address != XSAFX, \"Can't withdraw xSAFX\");\r\n        IERC20 _erc20 = IERC20(_erc20Address);\r\n        _erc20.transfer(msg.sender, _erc20.balanceOf(SAFX));\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_ownerNew\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SAFX\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"XSAFX\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canChangeSAFX\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canPause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"changeDepositor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_SAFX\",\"type\":\"address\"}],\"name\":\"changeSAFX\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositRewards\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableCanChangeSAFX\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableCanPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"fetchNoReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isDepositor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"noReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safx\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setNoReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingLive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_erc20Address\",\"type\":\"address\"}],\"name\":\"transferERC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_ownerNew\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xsafx\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "xSAFX", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5201a85ea7023299023b9d1e9a88a3574c8d89e3bb5d6816fc11652850230974"}