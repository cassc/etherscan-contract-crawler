{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/pkexec/WrappedSudoPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {LSSVMPair} from \\\"../LSSVMPair.sol\\\";\\nimport {ILSSVMPairFactoryLike} from \\\"../ILSSVMPairFactoryLike.sol\\\";\\nimport {IOwnershipTransferReceiver} from \\\"../lib/IOwnershipTransferReceiver.sol\\\";\\nimport {OwnableWithTransferCallback} from \\\"../lib/OwnableWithTransferCallback.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport {ERC721} from \\\"solmate/tokens/ERC721.sol\\\";\\n\\n/// @title Base64\\n/// @notice Provides a function for encoding some bytes in base64\\n/// @author Brecht Devos <brecht@loopring.org>\\nlibrary Base64 {\\n    bytes internal constant TABLE =\\n        \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /// @notice Encodes some bytes to the base64 representation\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        uint256 len = data.length;\\n        if (len == 0) return \\\"\\\";\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((len + 2) / 3);\\n\\n        // Add some extra buffer at the end\\n        bytes memory result = new bytes(encodedLen + 32);\\n\\n        bytes memory table = TABLE;\\n\\n        assembly {\\n            let tablePtr := add(table, 1)\\n            let resultPtr := add(result, 32)\\n\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n\\n            } {\\n                i := add(i, 3)\\n                let input := and(mload(add(data, i)), 0xffffff)\\n\\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n                out := shl(8, out)\\n                out := add(\\n                    out,\\n                    and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF)\\n                )\\n                out := shl(8, out)\\n                out := add(\\n                    out,\\n                    and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF)\\n                )\\n                out := shl(8, out)\\n                out := add(\\n                    out,\\n                    and(mload(add(tablePtr, and(input, 0x3F))), 0xFF)\\n                )\\n                out := shl(224, out)\\n\\n                mstore(resultPtr, out)\\n\\n                resultPtr := add(resultPtr, 4)\\n            }\\n\\n            switch mod(len, 3)\\n            case 1 {\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n            }\\n            case 2 {\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n            }\\n\\n            mstore(result, encodedLen)\\n        }\\n\\n        return string(result);\\n    }\\n}\\n\\ninterface Ownable {\\n    function transferOwnership(address newOwner) external;\\n}\\n\\ninterface IZorb {\\n    function gradientForAddress(\\n        address user\\n    ) external pure returns (bytes[5] memory);\\n}\\n\\ncontract WrappedSudoPool is\\n    IOwnershipTransferReceiver,\\n    ERC721,\\n    OwnableWithTransferCallback\\n{\\n    using Strings for uint256;\\n    ILSSVMPairFactoryLike immutable factory;\\n    IZorb zorb;\\n    mapping(address => string) public specialStuff;\\n\\n    constructor(\\n        ILSSVMPairFactoryLike _factory,\\n        address _zorb\\n    ) ERC721(\\\"Wrapped Sudo Pool\\\", \\\"WSP\\\") {\\n        factory = _factory;\\n        zorb = IZorb(_zorb);\\n        __Ownable_init(msg.sender);\\n    }\\n\\n    function onOwnershipTransferred(\\n        address oldOwner,\\n        bytes memory\\n    ) external payable {\\n        // Only for valid ERC721 ETH pairs\\n        require(factory.isValidPair(msg.sender), \\\"Invalid pair\\\");\\n        require(\\n            LSSVMPair(msg.sender).pairVariant() ==\\n                ILSSVMPairFactoryLike.PairVariant.ERC721_ETH,\\n            \\\"Invalid pair type\\\"\\n        );\\n        _mint(oldOwner, uint256(uint160(msg.sender)));\\n    }\\n\\n    function reclaimPairs(address[] calldata pairs) external {\\n        uint256 numPairs = pairs.length;\\n        for (uint i; i < numPairs; ) {\\n            address pairAddress = pairs[i];\\n            require(\\n                ownerOf(uint256(uint160(pairAddress))) == msg.sender,\\n                \\\"Not owner\\\"\\n            );\\n            _burn(uint256(uint160(pairAddress)));\\n            unchecked {\\n                ++i;\\n            }\\n            LSSVMPair(pairAddress).transferOwnership(msg.sender, \\\"\\\");\\n        }\\n    }\\n\\n    function multicall(\\n        address pair,\\n        bytes[] calldata calls,\\n        bool revertOnFail\\n    ) external {\\n        require(ownerOf(uint256(uint160(pair))) == msg.sender, \\\"Not owner\\\");\\n        LSSVMPair(pair).multicall(calls, revertOnFail);\\n    }\\n\\n    function tokenURI(uint256 id) public view override returns (string memory) {\\n        string memory collectionName = \\\"\\\";\\n        try ERC721(LSSVMPair(address(uint160(id))).nft()).name() returns (\\n            string memory name\\n        ) {\\n            collectionName = name;\\n        } catch {}\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"data:application/json;base64,\\\",\\n                    Base64.encode(\\n                        bytes(\\n                            abi.encodePacked(\\n                                '{\\\"name\\\":\\\"',\\n                                collectionName,\\n                                '<-> ETH LP\\\", \\\"description\\\":\\\"',\\n                                \\\"A wrapped Sudoswap pool for \\\",\\n                                collectionName,\\n                                '\\\", \\\"image\\\": \\\"',\\n                                \\\"data:image/svg+xml;base64,\\\",\\n                                Base64.encode(getSVG(id)),\\n                                '\\\"}'\\n                            )\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n\\n    function getSVG(uint256 id) public view returns (bytes memory) {\\n        return abi.encodePacked(\\n                getOpener(),\\n                getGradient(id),\\n                getBox(),\\n                getHeader(id),\\n                getPrice(id),\\n                getBalance(id),\\n                getSpecial(id),\\n                '</svg>'\\n            );\\n    }\\n\\n    function getHeader(uint256 id) private pure returns (string memory) {\\n        string memory poolType = \\\"TRADE\\\";\\n        string memory color = \\\"b9b9fa\\\";\\n\\n        {\\n            LSSVMPair pair = LSSVMPair(address(uint160(id)));\\n            if (pair.poolType() == LSSVMPair.PoolType.TOKEN) {\\n                poolType = \\\"TOKEN\\\";\\n                color = \\\"9dc1ef\\\";\\n            } else if (pair.poolType() == LSSVMPair.PoolType.NFT) {\\n                poolType = \\\"NFT\\\";\\n                color = \\\"dc92e4\\\";\\n            }\\n        }\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<g transform=\\\"translate(6,52) scale(0.1)\\\"><path d=\\\"M100 50C100 22.3858 77.6142 0 50 0C22.3858 0 0 22.3858 0 50C0 77.6142 22.3858 100 50 100C77.6142 100 100 77.6142 100 50Z\\\" fill=\\\"url(#g)\\\" /><path stroke=\\\"rgba(0,0,0,0.075)\\\" fill=\\\"transparent\\\" stroke-width=\\\"1\\\" d=\\\"M50,0.5c27.3,0,49.5,22.2,49.5,49.5S77.3,99.5,50,99.5S0.5,77.3,0.5,50S22.7,0.5,50,0.5z\\\" /></g><text x=\\\"18\\\" y=\\\"59\\\" fill=\\\"#9292a3\\\" class=\\\"s\\\">',\\n                    toAsciiString(address(uint160(id))),\\n                    '</text><rect width=\\\"24\\\" height=\\\"13\\\" x=\\\"93\\\" y=\\\"50.1\\\" ry=\\\"4.3\\\" style=\\\"fill:#',\\n                    color,\\n                    ';fill-opacity:1;stroke:none;stroke-width:.295635\\\"/><text x=\\\"95\\\" y=\\\"59\\\" fill=\\\"#000\\\" class=\\\"s\\\">',\\n                    poolType,\\n                    \\\"</text>\\\"\\n                )\\n            );\\n    }\\n\\n    function getOpener() private pure returns (string memory) {\\n        return\\n            '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 132 132\\\"><style>.s, .b {font-size: 5px;font-weight: bold; font-family: sans-serif;}.b {font-size: 8px;}</style><defs><radialGradient id=\\\"g\\\" gradientTransform=\\\"translate(66.4578 24.3575) scale(75.2908)\\\" gradientUnits=\\\"userSpaceOnUse\\\" r=\\\"1\\\" cx=\\\"0\\\" cy=\\\"0%\\\">';\\n    }\\n\\n    function getGradient(uint256 id) private view returns (string memory) {\\n        bytes[5] memory colors = zorb.gradientForAddress(address(uint160(id)));\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<stop offset=\\\"15.62%\\\" stop-color=\\\"',\\n                    colors[0],\\n                    '\\\" /><stop offset=\\\"39.58%\\\" stop-color=\\\"',\\n                    colors[1],\\n                    '\\\" /><stop offset=\\\"72.92%\\\" stop-color=\\\"',\\n                    colors[2],\\n                    '\\\" /><stop offset=\\\"90.63%\\\" stop-color=\\\"',\\n                    colors[3],\\n                    '\\\" /><stop offset=\\\"100%\\\" stop-color=\\\"',\\n                    colors[4],\\n                    '\\\" /></radialGradient></defs>'\\n                )\\n            );\\n    }\\n\\n    function getBox() private pure returns (string memory) {\\n        return\\n            '<rect width=\\\"127\\\" height=\\\"74.1\\\" x=\\\"3\\\" y=\\\"46.1\\\" ry=\\\"7.4\\\" style=\\\"fill:#14141b;fill-opacity:1;stroke:#36364a;stroke-width:.265;stroke-opacity:1\\\"/><rect width=\\\"127\\\" height=\\\"30.4\\\" x=\\\"3\\\" y=\\\"67.4\\\" ry=\\\"0\\\" style=\\\"fill:#1b1b24;fill-opacity:1;stroke:#36364a;stroke-width:.265;stroke-opacity:1\\\"/>';\\n    }\\n\\n    function getPrice(uint256 id) private view returns (string memory) {\\n        LSSVMPair pair = LSSVMPair(address(uint160(id)));\\n        uint256 buyPrice;\\n        uint256 sellPrice;\\n        {\\n            (, , , sellPrice, , ) = pair.bondingCurve().getSellInfo(\\n                pair.spotPrice(),\\n                pair.delta(),\\n                1,\\n                pair.fee(),\\n                pair.factory().protocolFeeMultiplier()\\n            );\\n            (, , , buyPrice, , ) = pair.bondingCurve().getBuyInfo(\\n                pair.spotPrice(),\\n                pair.delta(),\\n                1,\\n                pair.fee(),\\n                pair.factory().protocolFeeMultiplier()\\n            );\\n        }\\n\\n        if (pair.poolType() == LSSVMPair.PoolType.TOKEN) {\\n            uint256 preDecimalSell = sellPrice / (10 ** 18);\\n            uint256 postDecimalSell = (sellPrice / (10 ** 15)) -\\n                (preDecimalSell * 1000);\\n            return\\n                string(\\n                    abi.encodePacked(\\n                        '<text x=\\\"80\\\" y=\\\"75\\\" fill=\\\"#9dc1ef\\\" class=\\\"s\\\">Buy Price</text><text x=\\\"80\\\" y=\\\"90\\\" fill=\\\"#fff\\\" class=\\\"b\\\">',\\n                        preDecimalSell.toString(),\\n                        \\\".\\\",\\n                        postDecimalSell.toString(),\\n                        \\\" ETH</text>\\\"\\n                    )\\n                );\\n        } else if (pair.poolType() == LSSVMPair.PoolType.NFT) {\\n            uint256 preDecimalBuy = buyPrice / (10 ** 18);\\n            uint256 postDecimalBuy = (buyPrice / (10 ** 15)) -\\n                (preDecimalBuy * 1000);\\n            return\\n                string(\\n                    abi.encodePacked(\\n                        '<text x=\\\"20\\\" y=\\\"75\\\" fill=\\\"#dc92e4\\\" class=\\\"s\\\">Sell Price</text><text x=\\\"20\\\" y=\\\"90\\\" fill=\\\"#fff\\\" class=\\\"b\\\">',\\n                        preDecimalBuy.toString(),\\n                        \\\".\\\",\\n                        postDecimalBuy.toString(),\\n                        \\\" ETH</text>\\\"\\n                    )\\n                );\\n        } else {\\n            uint256 preDecimalSell = sellPrice / (10 ** 18);\\n            uint256 postDecimalSell = (sellPrice / (10 ** 15)) -\\n                (preDecimalSell * 1000);\\n            uint256 preDecimalBuy = buyPrice / (10 ** 18);\\n            uint256 postDecimalBuy = (buyPrice / (10 ** 15)) -\\n                (preDecimalBuy * 1000);\\n            return\\n                string(\\n                    abi.encodePacked(\\n                        '<text x=\\\"20\\\" y=\\\"75\\\" fill=\\\"#dc92e4\\\" class=\\\"s\\\">Sell Price</text><text x=\\\"20\\\" y=\\\"90\\\" fill=\\\"#fff\\\" class=\\\"b\\\">',\\n                        preDecimalBuy.toString(),\\n                        \\\".\\\",\\n                        postDecimalBuy.toString(),\\n                        \\\" ETH</text>\\\",\\n                        '<text x=\\\"80\\\" y=\\\"75\\\" fill=\\\"#9dc1ef\\\" class=\\\"s\\\">Buy Price</text><text x=\\\"80\\\" y=\\\"90\\\" fill=\\\"#fff\\\" class=\\\"b\\\">',\\n                        preDecimalSell.toString(),\\n                        \\\".\\\",\\n                        postDecimalSell.toString(),\\n                        \\\" ETH</text>\\\"\\n                    )\\n                );\\n        }\\n    }\\n\\n    function getBalance(uint256 id) internal view returns (string memory) {\\n      uint256 preDecimalBalance = address(uint160(id)).balance / (10 ** 18);\\n      uint256 postDecimalBalance = (address(uint160(id)).balance / (10 ** 16)) -\\n                (preDecimalBalance * 100);\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<text x=\\\"10\\\" y=\\\"110\\\" fill=\\\"#9292a3\\\" class=\\\"s\\\">Balance</text><text x=\\\"70\\\" y=\\\"110\\\" fill=\\\"#fff\\\" class=\\\"s\\\">',\\n                    preDecimalBalance.toString(),\\n                    '.',\\n                    postDecimalBalance.toString(),\\n                    ' ETH</text><text x=\\\"100\\\" y=\\\"110\\\" fill=\\\"#fff\\\" class=\\\"s\\\">',\\n                    ERC721(LSSVMPair(address(uint160(id))).nft()).balanceOf(\\n                        address(uint160(id))\\n                    ).toString(),\\n                    \\\"  \\\",\\n                    ERC721(LSSVMPair(address(uint160(id))).nft()).symbol(),\\n                    \\\"</text>\\\"\\n                )\\n            );\\n    }\\n\\n    function getSpecial(uint256 id) internal view returns (string memory) {\\n      return specialStuff[LSSVMPair(address(uint160(id))).nft()];\\n    }\\n\\n    function toAsciiString(address x) internal pure returns (string memory) {\\n        bytes memory s = new bytes(10);\\n        for (uint i = 0; i < 5; i++) {\\n            bytes1 b = bytes1(uint8(uint(uint160(x)) / (2 ** (8 * (19 - i)))));\\n            bytes1 hi = bytes1(uint8(b) / 16);\\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\n            s[2 * i] = char(hi);\\n            s[2 * i + 1] = char(lo);\\n        }\\n        return string(abi.encodePacked('0x', s));\\n    }\\n\\n    function char(bytes1 b) internal pure returns (bytes1 c) {\\n        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\\n        else return bytes1(uint8(b) + 0x57);\\n    }\\n\\n    function setZorb(address z) external onlyOwner {\\n      zorb = IZorb(z);\\n    }\\n\\n    function setSpecial(address a, string calldata s) external onlyOwner {\\n      specialStuff[a] = s;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/LSSVMPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {IRoyaltyEngineV1} from \\\"manifoldxyz/IRoyaltyEngineV1.sol\\\";\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\n\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport {ERC721Holder} from \\\"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\\\";\\nimport {ERC1155Holder} from \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\\\";\\n\\nimport {LSSVMRouter} from \\\"./LSSVMRouter.sol\\\";\\nimport {ICurve} from \\\"./bonding-curves/ICurve.sol\\\";\\nimport {ILSSVMPairFactoryLike} from \\\"./ILSSVMPairFactoryLike.sol\\\";\\nimport {CurveErrorCodes} from \\\"./bonding-curves/CurveErrorCodes.sol\\\";\\nimport {IOwnershipTransferReceiver} from \\\"./lib/IOwnershipTransferReceiver.sol\\\";\\nimport {OwnableWithTransferCallback} from \\\"./lib/OwnableWithTransferCallback.sol\\\";\\n\\n/**\\n * @title The base contract for an NFT/TOKEN AMM pair\\n * @author boredGenius, 0xmons, 0xCygaar\\n * @notice This implements the core swap logic from NFT to TOKEN\\n */\\nabstract contract LSSVMPair is OwnableWithTransferCallback, ERC721Holder, ERC1155Holder {\\n    /**\\n     * Library usage **\\n     */\\n\\n    using Address for address;\\n\\n    /**\\n     *  Enums **\\n     */\\n\\n    enum PoolType {\\n        TOKEN,\\n        NFT,\\n        TRADE\\n    }\\n\\n    /**\\n     * Constants **\\n     */\\n\\n    /**\\n     * @dev 50%, must <= 1 - MAX_PROTOCOL_FEE (set in LSSVMPairFactory)\\n     */\\n    uint256 internal constant MAX_TRADE_FEE = 0.5e18;\\n\\n    /**\\n     *  Immutable params **\\n     */\\n\\n    /**\\n     * @notice Sudoswap Royalty Engine\\n     */\\n    IRoyaltyEngineV1 public immutable ROYALTY_ENGINE;\\n\\n    /**\\n     *  Storage variables **\\n     */\\n\\n    /**\\n     * @dev This is generally used to mean the immediate sell price for the next marginal NFT.\\n     * However, this should NOT be assumed, as bonding curves may use spotPrice in different ways.\\n     * Use getBuyNFTQuote and getSellNFTQuote for accurate pricing info.\\n     */\\n    uint128 public spotPrice;\\n\\n    /**\\n     * @notice The parameter for the pair's bonding curve.\\n     * Units and meaning are bonding curve dependent.\\n     */\\n    uint128 public delta;\\n\\n    /**\\n     * @notice The spread between buy and sell prices, set to be a multiplier we apply to the buy price\\n     * Fee is only relevant for TRADE pools. Units are in base 1e18.\\n     */\\n    uint96 public fee;\\n\\n    /**\\n     * @notice The address that swapped assets are sent to.\\n     * For TRADE pools, assets are always sent to the pool, so this is used to track trade fee.\\n     * If set to address(0), will default to owner() for NFT and TOKEN pools.\\n     */\\n    address payable internal assetRecipient;\\n\\n    /**\\n     *  Events\\n     */\\n\\n    event SwapNFTInPair(uint256 amountOut, uint256[] ids);\\n    event SwapNFTInPair(uint256 amountOut, uint256 numNFTs);\\n    event SwapNFTOutPair(uint256 amountIn, uint256[] ids);\\n    event SwapNFTOutPair(uint256 amountIn, uint256 numNFTs);\\n    event SpotPriceUpdate(uint128 newSpotPrice);\\n    event TokenDeposit(uint256 amount);\\n    event TokenWithdrawal(uint256 amount);\\n    event NFTWithdrawal(uint256[] ids);\\n    event NFTWithdrawal(uint256 numNFTs);\\n    event DeltaUpdate(uint128 newDelta);\\n    event FeeUpdate(uint96 newFee);\\n    event AssetRecipientChange(address indexed a);\\n\\n    /**\\n     *  Errors\\n     */\\n\\n    error LSSVMPair__NotRouter();\\n    error LSSVMPair__CallFailed();\\n    error LSSVMPair__InvalidDelta();\\n    error LSSVMPair__WrongPoolType();\\n    error LSSVMPair__OutputTooSmall();\\n    error LSSVMPair__ZeroSwapAmount();\\n    error LSSVMPair__RoyaltyTooLarge();\\n    error LSSVMPair__TradeFeeTooLarge();\\n    error LSSVMPair__InvalidSpotPrice();\\n    error LSSVMPair__TargetNotAllowed();\\n    error LSSVMPair__NftNotTransferred();\\n    error LSSVMPair__AlreadyInitialized();\\n    error LSSVMPair__FunctionNotAllowed();\\n    error LSSVMPair__DemandedInputTooLarge();\\n    error LSSVMPair__NonTradePoolWithTradeFee();\\n    error LSSVMPair__BondingCurveError(CurveErrorCodes.Error error);\\n\\n    constructor(IRoyaltyEngineV1 royaltyEngine) {\\n        ROYALTY_ENGINE = royaltyEngine;\\n    }\\n\\n    /**\\n     * @notice Called during pair creation to set initial parameters\\n     * @dev Only called once by factory to initialize.\\n     * We verify this by making sure that the current owner is address(0).\\n     * The Ownable library we use disallows setting the owner to be address(0), so this condition\\n     * should only be valid before the first initialize call.\\n     * @param _owner The owner of the pair\\n     * @param _assetRecipient The address that will receive the TOKEN or NFT sent to this pair during swaps. NOTE: If set to address(0), they will go to the pair itself.\\n     * @param _delta The initial delta of the bonding curve\\n     * @param _fee The initial % fee taken, if this is a trade pair\\n     * @param _spotPrice The initial price to sell an asset into the pair\\n     */\\n    function initialize(\\n        address _owner,\\n        address payable _assetRecipient,\\n        uint128 _delta,\\n        uint96 _fee,\\n        uint128 _spotPrice\\n    ) external {\\n        if (owner() != address(0)) revert LSSVMPair__AlreadyInitialized();\\n        __Ownable_init(_owner);\\n\\n        ICurve _bondingCurve = bondingCurve();\\n        PoolType _poolType = poolType();\\n        if (_poolType != PoolType.TRADE) {\\n            if (_fee != 0) revert LSSVMPair__NonTradePoolWithTradeFee();\\n        } else {\\n            if (_fee > MAX_TRADE_FEE) revert LSSVMPair__TradeFeeTooLarge();\\n            fee = _fee;\\n        }\\n\\n        assetRecipient = _assetRecipient;\\n\\n        if (!_bondingCurve.validateDelta(_delta)) revert LSSVMPair__InvalidDelta();\\n        if (!_bondingCurve.validateSpotPrice(_spotPrice)) revert LSSVMPair__InvalidSpotPrice();\\n        delta = _delta;\\n        spotPrice = _spotPrice;\\n    }\\n\\n    /**\\n     * External state-changing functions\\n     */\\n\\n    /**\\n     * @notice Sends token to the pair in exchange for a specific set of NFTs\\n     * @dev To compute the amount of token to send, call bondingCurve.getBuyInfo\\n     * This swap is meant for users who want specific IDs. Also higher chance of\\n     * reverting if some of the specified IDs leave the pool before the swap goes through.\\n     * @param nftIds The list of IDs of the NFTs to purchase\\n     * @param maxExpectedTokenInput The maximum acceptable cost from the sender. If the actual\\n     * amount is greater than this value, the transaction will be reverted.\\n     * @param nftRecipient The recipient of the NFTs\\n     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for ETH pairs.\\n     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for ETH pairs.\\n     * @return - The amount of token used for purchase\\n     */\\n    function swapTokenForSpecificNFTs(\\n        uint256[] calldata nftIds,\\n        uint256 maxExpectedTokenInput,\\n        address nftRecipient,\\n        bool isRouter,\\n        address routerCaller\\n    ) external payable virtual returns (uint256);\\n\\n    /**\\n     * @notice Sends a set of NFTs to the pair in exchange for token\\n     * @dev To compute the amount of token to that will be received, call bondingCurve.getSellInfo.\\n     * @param nftIds The list of IDs of the NFTs to sell to the pair\\n     * @param minExpectedTokenOutput The minimum acceptable token received by the sender. If the actual\\n     * amount is less than this value, the transaction will be reverted.\\n     * @param tokenRecipient The recipient of the token output\\n     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for\\n     * ETH pairs.\\n     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for\\n     * ETH pairs.\\n     * @return outputAmount The amount of token received\\n     */\\n    function swapNFTsForToken(\\n        uint256[] calldata nftIds,\\n        uint256 minExpectedTokenOutput,\\n        address payable tokenRecipient,\\n        bool isRouter,\\n        address routerCaller\\n    ) external virtual returns (uint256 outputAmount);\\n\\n    /**\\n     * View functions\\n     */\\n\\n    /**\\n     * @dev Used as read function to query the bonding curve for buy pricing info\\n     * @param numNFTs The number of NFTs to buy from the pair\\n     */\\n    function getBuyNFTQuote(uint256 assetId, uint256 numNFTs)\\n        external\\n        view\\n        returns (\\n            CurveErrorCodes.Error error,\\n            uint256 newSpotPrice,\\n            uint256 newDelta,\\n            uint256 inputAmount,\\n            uint256 protocolFee,\\n            uint256 royaltyAmount\\n        )\\n    {\\n        uint256 tradeFee;\\n        (error, newSpotPrice, newDelta, inputAmount, tradeFee, protocolFee) =\\n            bondingCurve().getBuyInfo(spotPrice, delta, numNFTs, fee, factory().protocolFeeMultiplier());\\n\\n        if (numNFTs != 0) {\\n            // Calculate the inputAmount minus tradeFee and protocolFee\\n            uint256 inputAmountMinusFees = inputAmount - tradeFee - protocolFee;\\n\\n            // Compute royalties\\n            (,, royaltyAmount) = calculateRoyaltiesView(assetId, inputAmountMinusFees);\\n\\n            inputAmount += royaltyAmount;\\n        }\\n    }\\n\\n    /**\\n     * @dev Used as read function to query the bonding curve for sell pricing info including royalties\\n     * @param numNFTs The number of NFTs to sell to the pair\\n     */\\n    function getSellNFTQuote(uint256 assetId, uint256 numNFTs)\\n        external\\n        view\\n        returns (\\n            CurveErrorCodes.Error error,\\n            uint256 newSpotPrice,\\n            uint256 newDelta,\\n            uint256 outputAmount,\\n            uint256 protocolFee,\\n            uint256 royaltyAmount\\n        )\\n    {\\n        (error, newSpotPrice, newDelta, outputAmount, /* tradeFee */, protocolFee) =\\n            bondingCurve().getSellInfo(spotPrice, delta, numNFTs, fee, factory().protocolFeeMultiplier());\\n\\n        if (numNFTs != 0) {\\n            // Compute royalties\\n            (,, royaltyAmount) = calculateRoyaltiesView(assetId, outputAmount);\\n\\n            // Deduct royalties from outputAmount\\n            unchecked {\\n                // Safe because we already require outputAmount >= royaltyAmount in _calculateRoyalties()\\n                outputAmount -= royaltyAmount;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the pair's variant (Pair uses ETH or ERC20)\\n     */\\n    function pairVariant() public pure virtual returns (ILSSVMPairFactoryLike.PairVariant);\\n\\n    function factory() public pure returns (ILSSVMPairFactoryLike _factory) {\\n        uint256 paramsLength = _immutableParamsLength();\\n        assembly {\\n            _factory := shr(0x60, calldataload(sub(calldatasize(), paramsLength)))\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the type of bonding curve that parameterizes the pair\\n     */\\n    function bondingCurve() public pure returns (ICurve _bondingCurve) {\\n        uint256 paramsLength = _immutableParamsLength();\\n        assembly {\\n            _bondingCurve := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), 20)))\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the address of NFT collection that parameterizes the pair\\n     */\\n    function nft() public pure returns (address _nft) {\\n        uint256 paramsLength = _immutableParamsLength();\\n        assembly {\\n            _nft := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), 40)))\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the pair's type (TOKEN/NFT/TRADE)\\n     */\\n    function poolType() public pure returns (PoolType _poolType) {\\n        uint256 paramsLength = _immutableParamsLength();\\n        assembly {\\n            _poolType := shr(0xf8, calldataload(add(sub(calldatasize(), paramsLength), 60)))\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the address that receives assets when a swap is done with this pair\\n     * Can be set to another address by the owner, but has no effect on TRADE pools\\n     * If set to address(0), defaults to owner() for NFT/TOKEN pools\\n     */\\n    function getAssetRecipient() public view returns (address payable) {\\n        // TRADE pools will always receive the asset themselves\\n        if (poolType() == PoolType.TRADE) {\\n            return payable(address(this));\\n        }\\n\\n        address payable _assetRecipient = assetRecipient;\\n\\n        // Otherwise, we return the recipient if it's been set\\n        // Or, we replace it with owner() if it's address(0)\\n        if (_assetRecipient == address(0)) {\\n            return payable(owner());\\n        }\\n        return _assetRecipient;\\n    }\\n\\n    /**\\n     * @notice Returns the address that receives trade fees when a swap is done with this pair\\n     * Only relevant for TRADE pools\\n     * If set to address(0), defaults to the pair itself\\n     */\\n    function getFeeRecipient() public view returns (address payable _feeRecipient) {\\n        _feeRecipient = assetRecipient;\\n        if (_feeRecipient == address(0)) {\\n            _feeRecipient = payable(address(this));\\n        }\\n    }\\n\\n    /**\\n     * Internal functions\\n     */\\n\\n    /**\\n     * @notice Calculates the amount needed to be sent into the pair for a buy and adjusts spot price or delta if necessary\\n     * @param numNFTs The amount of NFTs to purchase from the pair\\n     * @param _bondingCurve The bonding curve to use for price calculation\\n     * @param _factory The factory to use for protocol fee lookup\\n     * @return tradeFee The amount of tokens to send as trade fee\\n     * @return protocolFee The amount of tokens to send as protocol fee\\n     * @return inputAmount The amount of tokens total tokens receive\\n     */\\n    function _calculateBuyInfoAndUpdatePoolParams(uint256 numNFTs, ICurve _bondingCurve, ILSSVMPairFactoryLike _factory)\\n        internal\\n        returns (uint256 tradeFee, uint256 protocolFee, uint256 inputAmount)\\n    {\\n        CurveErrorCodes.Error error;\\n        // Save on 2 SLOADs by caching\\n        uint128 currentSpotPrice = spotPrice;\\n        uint128 currentDelta = delta;\\n        uint128 newDelta;\\n        uint128 newSpotPrice;\\n        (error, newSpotPrice, newDelta, inputAmount, tradeFee, protocolFee) =\\n            _bondingCurve.getBuyInfo(currentSpotPrice, currentDelta, numNFTs, fee, _factory.protocolFeeMultiplier());\\n\\n        // Revert if bonding curve had an error\\n        if (error != CurveErrorCodes.Error.OK) {\\n            revert LSSVMPair__BondingCurveError(error);\\n        }\\n\\n        // Consolidate writes to save gas\\n        if (currentSpotPrice != newSpotPrice || currentDelta != newDelta) {\\n            spotPrice = newSpotPrice;\\n            delta = newDelta;\\n        }\\n\\n        // Emit spot price update if it has been updated\\n        if (currentSpotPrice != newSpotPrice) {\\n            emit SpotPriceUpdate(newSpotPrice);\\n        }\\n\\n        // Emit delta update if it has been updated\\n        if (currentDelta != newDelta) {\\n            emit DeltaUpdate(newDelta);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates the amount needed to be sent by the pair for a sell and adjusts spot price or delta if necessary\\n     * @param numNFTs The amount of NFTs to send to the the pair\\n     * @param _bondingCurve The bonding curve to use for price calculation\\n     * @param _factory The factory to use for protocol fee lookup\\n     * @return protocolFee The amount of tokens to send as protocol fee\\n     * @return outputAmount The amount of tokens total tokens receive\\n     */\\n    function _calculateSellInfoAndUpdatePoolParams(\\n        uint256 numNFTs,\\n        ICurve _bondingCurve,\\n        ILSSVMPairFactoryLike _factory\\n    ) internal returns (uint256 protocolFee, uint256 outputAmount) {\\n        CurveErrorCodes.Error error;\\n        // Save on 2 SLOADs by caching\\n        uint128 currentSpotPrice = spotPrice;\\n        uint128 currentDelta = delta;\\n        uint128 newSpotPrice;\\n        uint128 newDelta;\\n        (error, newSpotPrice, newDelta, outputAmount, /*tradeFee*/, protocolFee) =\\n            _bondingCurve.getSellInfo(currentSpotPrice, currentDelta, numNFTs, fee, _factory.protocolFeeMultiplier());\\n\\n        // Revert if bonding curve had an error\\n        if (error != CurveErrorCodes.Error.OK) {\\n            revert LSSVMPair__BondingCurveError(error);\\n        }\\n\\n        // Consolidate writes to save gas\\n        if (currentSpotPrice != newSpotPrice || currentDelta != newDelta) {\\n            spotPrice = newSpotPrice;\\n            delta = newDelta;\\n        }\\n\\n        // Emit spot price update if it has been updated\\n        if (currentSpotPrice != newSpotPrice) {\\n            emit SpotPriceUpdate(newSpotPrice);\\n        }\\n\\n        // Emit delta update if it has been updated\\n        if (currentDelta != newDelta) {\\n            emit DeltaUpdate(newDelta);\\n        }\\n    }\\n\\n    /**\\n     * @notice Pulls the token input of a trade from the trader (including all royalties and fees)\\n     * @param inputAmountExcludingRoyalty The amount of tokens to be sent, excluding the royalty (includes protocol fee)\\n     * @param royaltyAmounts The amounts of tokens to be sent as royalties\\n     * @param royaltyRecipients The recipients of the royalties\\n     * @param royaltyTotal The sum of all royaltyAmounts\\n     * @param tradeFeeAmount The amount of tokens to be sent as trade fee (if applicable)\\n     * @param isRouter Whether or not the caller is LSSVMRouter\\n     * @param routerCaller If called from LSSVMRouter, store the original caller\\n     * @param protocolFee The protocol fee to be paid\\n     */\\n    function _pullTokenInputs(\\n        uint256 inputAmountExcludingRoyalty,\\n        uint256[] memory royaltyAmounts,\\n        address payable[] memory royaltyRecipients,\\n        uint256 royaltyTotal,\\n        uint256 tradeFeeAmount,\\n        bool isRouter,\\n        address routerCaller,\\n        uint256 protocolFee\\n    ) internal virtual;\\n\\n    /**\\n     * @notice Sends excess tokens back to the caller (if applicable)\\n     * @dev Swap callers interacting with an ETH pair must be able to receive ETH (e.g. if the caller sends too much ETH)\\n     */\\n    function _refundTokenToSender(uint256 inputAmount) internal virtual;\\n\\n    /**\\n     * @notice Sends tokens to a recipient\\n     * @param tokenRecipient The address receiving the tokens\\n     * @param outputAmount The amount of tokens to send\\n     */\\n    function _sendTokenOutput(address payable tokenRecipient, uint256 outputAmount) internal virtual;\\n\\n    /**\\n     * @dev Used internally to grab pair parameters from calldata, see LSSVMPairCloner for technical details\\n     */\\n    function _immutableParamsLength() internal pure virtual returns (uint256);\\n\\n    /**\\n     * Royalty support functions\\n     */\\n\\n    function _calculateRoyalties(uint256 assetId, uint256 saleAmount)\\n        internal\\n        returns (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal)\\n    {\\n        (address payable[] memory recipients, uint256[] memory amounts) =\\n            ROYALTY_ENGINE.getRoyalty(nft(), assetId, saleAmount);\\n        return _calculateRoyaltiesLogic(recipients, amounts, saleAmount);\\n    }\\n\\n    /**\\n     * @dev Same as _calculateRoyalties, but uses getRoyaltyView to avoid state mutations and is public for external callers\\n     */\\n    function calculateRoyaltiesView(uint256 assetId, uint256 saleAmount)\\n        public\\n        view\\n        returns (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal)\\n    {\\n        (address payable[] memory recipients, uint256[] memory amounts) =\\n            ROYALTY_ENGINE.getRoyaltyView(nft(), assetId, saleAmount);\\n        return _calculateRoyaltiesLogic(recipients, amounts, saleAmount);\\n    }\\n\\n    /**\\n     * @dev Common logic used by _calculateRoyalties() and calculateRoyaltiesView()\\n     */\\n    function _calculateRoyaltiesLogic(address payable[] memory recipients, uint256[] memory amounts, uint256 saleAmount)\\n        internal\\n        view\\n        returns (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal)\\n    {\\n        // Cache to save gas\\n        uint256 numRecipients = recipients.length;\\n\\n        if (numRecipients != 0) {\\n            // If a pair has custom Settings, use the overridden royalty amount and only use the first receiver\\n            try factory().getSettingsForPair(address(this)) returns (bool settingsEnabled, uint96 bps) {\\n                if (settingsEnabled) {\\n                    royaltyRecipients = new address payable[](1);\\n                    royaltyRecipients[0] = recipients[0];\\n                    royaltyAmounts = new uint256[](1);\\n                    royaltyAmounts[0] = (saleAmount * bps) / 10000;\\n\\n                    // Update numRecipients to match new recipients list\\n                    numRecipients = 1;\\n                } else {\\n                    royaltyRecipients = recipients;\\n                    royaltyAmounts = amounts;\\n                }\\n            } catch {\\n                // Use the input values to calculate royalties if factory call fails\\n                royaltyRecipients = recipients;\\n                royaltyAmounts = amounts;\\n            }\\n        }\\n\\n        for (uint256 i; i < numRecipients;) {\\n            royaltyTotal += royaltyAmounts[i];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Ensure royalty total is at most 25% of the sale amount\\n        // This defends against a rogue Manifold registry that charges extremely high royalties\\n        if (royaltyTotal > saleAmount >> 2) {\\n            revert LSSVMPair__RoyaltyTooLarge();\\n        }\\n    }\\n\\n    /**\\n     * Owner functions\\n     */\\n\\n    /**\\n     * @notice Rescues a specified set of NFTs owned by the pair to the owner address. (onlyOwnable modifier is in the implemented function)\\n     * @param a The NFT to transfer\\n     * @param nftIds The list of IDs of the NFTs to send to the owner\\n     */\\n    function withdrawERC721(IERC721 a, uint256[] calldata nftIds) external virtual;\\n\\n    /**\\n     * @notice Rescues ERC20 tokens from the pair to the owner. Only callable by the owner (onlyOwnable modifier is in the implemented function).\\n     * @param a The token to transfer\\n     * @param amount The amount of tokens to send to the owner\\n     */\\n    function withdrawERC20(ERC20 a, uint256 amount) external virtual;\\n\\n    /**\\n     * @notice Rescues ERC1155 tokens from the pair to the owner. Only callable by the owner.\\n     * @param a The NFT to transfer\\n     * @param ids The NFT ids to transfer\\n     * @param amounts The amounts of each id to transfer\\n     */\\n    function withdrawERC1155(IERC1155 a, uint256[] calldata ids, uint256[] calldata amounts) external virtual;\\n\\n    /**\\n     * @notice Updates the selling spot price. Only callable by the owner.\\n     * @param newSpotPrice The new selling spot price value, in Token\\n     */\\n    function changeSpotPrice(uint128 newSpotPrice) external onlyOwner {\\n        ICurve _bondingCurve = bondingCurve();\\n        if (!_bondingCurve.validateSpotPrice(newSpotPrice)) revert LSSVMPair__InvalidSpotPrice();\\n        if (spotPrice != newSpotPrice) {\\n            spotPrice = newSpotPrice;\\n            emit SpotPriceUpdate(newSpotPrice);\\n        }\\n    }\\n\\n    /**\\n     * @notice Updates the delta parameter. Only callable by the owner.\\n     * @param newDelta The new delta parameter\\n     */\\n    function changeDelta(uint128 newDelta) external onlyOwner {\\n        ICurve _bondingCurve = bondingCurve();\\n        if (!_bondingCurve.validateDelta(newDelta)) revert LSSVMPair__InvalidDelta();\\n        if (delta != newDelta) {\\n            delta = newDelta;\\n            emit DeltaUpdate(newDelta);\\n        }\\n    }\\n\\n    /**\\n     * @notice Updates the fee taken by the LP. Only callable by the owner.\\n     * Only callable if the pool is a Trade pool. Reverts if the fee is >= MAX_FEE.\\n     * @param newFee The new LP fee percentage, 18 decimals\\n     */\\n    function changeFee(uint96 newFee) external onlyOwner {\\n        PoolType _poolType = poolType();\\n        if (_poolType != PoolType.TRADE) revert LSSVMPair__NonTradePoolWithTradeFee();\\n        if (newFee > MAX_TRADE_FEE) revert LSSVMPair__TradeFeeTooLarge();\\n        if (fee != newFee) {\\n            fee = newFee;\\n            emit FeeUpdate(newFee);\\n        }\\n    }\\n\\n    /**\\n     * @notice Changes the address that will receive assets received from\\n     * trades. Only callable by the owner.\\n     * @param newRecipient The new asset recipient\\n     */\\n    function changeAssetRecipient(address payable newRecipient) external onlyOwner {\\n        if (assetRecipient != newRecipient) {\\n            assetRecipient = newRecipient;\\n            emit AssetRecipientChange(newRecipient);\\n        }\\n    }\\n\\n    function _preCallCheck(address target) internal virtual;\\n\\n    /**\\n     * @notice Allows the pair to make arbitrary external calls to contracts\\n     * whitelisted by the protocol. Only callable by the owner.\\n     * @param target The contract to call\\n     * @param data The calldata to pass to the contract\\n     */\\n    function call(address payable target, bytes calldata data) external onlyOwner {\\n        ILSSVMPairFactoryLike _factory = factory();\\n        if (!_factory.callAllowed(target)) revert LSSVMPair__TargetNotAllowed();\\n\\n        // Ensure the call isn't calling a banned function\\n        bytes4 sig = bytes4(data[:4]);\\n        if (\\n            sig == IOwnershipTransferReceiver.onOwnershipTransferred.selector\\n                || sig == LSSVMRouter.pairTransferERC20From.selector || sig == LSSVMRouter.pairTransferNFTFrom.selector\\n                || sig == LSSVMRouter.pairTransferERC1155From.selector || sig == ILSSVMPairFactoryLike.openLock.selector\\n                || sig == ILSSVMPairFactoryLike.closeLock.selector\\n        ) {\\n            revert LSSVMPair__FunctionNotAllowed();\\n        }\\n\\n        // Prevent calling the pair's underlying nft\\n        // (We ban calling the underlying NFT/ERC20 to avoid maliciously transferring assets approved for the pair to spend)\\n        if (target == nft()) revert LSSVMPair__TargetNotAllowed();\\n\\n        _preCallCheck(target);\\n\\n        (bool success,) = target.call{value: 0}(data);\\n        if (!success) revert LSSVMPair__CallFailed();\\n    }\\n\\n    /**\\n     * @notice Allows owner to batch multiple calls, forked from: https://github.com/boringcrypto/BoringSolidity/blob/master/contracts/BoringBatchable.sol\\n     * @notice The revert handling is forked from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/c239e1af8d1a1296577108dd6989a17b57434f8e/contracts/utils/Address.sol#L201\\n     * @dev Intended for withdrawing/altering pool pricing in one tx, only callable by owner, cannot change owner\\n     * @param calls The calldata for each call to make\\n     * @param revertOnFail Whether or not to revert the entire tx if any of the calls fail. Calls to transferOwnership will revert regardless.\\n     */\\n    function multicall(bytes[] calldata calls, bool revertOnFail) external onlyOwner {\\n        for (uint256 i; i < calls.length;) {\\n            bytes4 sig = bytes4(calls[i][:4]);\\n            // We ban calling transferOwnership when ownership\\n            if (sig == transferOwnership.selector) revert LSSVMPair__FunctionNotAllowed();\\n\\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\\n            if (!success && revertOnFail) {\\n                assembly {\\n                    revert(add(0x20, result), mload(result))\\n                }\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/ILSSVMPairFactoryLike.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {LSSVMRouter} from \\\"./LSSVMRouter.sol\\\";\\n\\ninterface ILSSVMPairFactoryLike {\\n    struct Settings {\\n        uint96 bps;\\n        address pairAddress;\\n    }\\n\\n    enum PairNFTType {\\n        ERC721,\\n        ERC1155\\n    }\\n\\n    enum PairTokenType {\\n        ETH,\\n        ERC20\\n    }\\n\\n    enum PairVariant {\\n        ERC721_ETH,\\n        ERC721_ERC20,\\n        ERC1155_ETH,\\n        ERC1155_ERC20\\n    }\\n\\n    function protocolFeeMultiplier() external view returns (uint256);\\n\\n    function protocolFeeRecipient() external view returns (address payable);\\n\\n    function callAllowed(address target) external view returns (bool);\\n\\n    function authAllowedForToken(address tokenAddress, address proposedAuthAddress) external view returns (bool);\\n\\n    function getSettingsForPair(address pairAddress) external view returns (bool settingsEnabled, uint96 bps);\\n\\n    function enableSettingsForPair(address settings, address pairAddress) external;\\n\\n    function disableSettingsForPair(address settings, address pairAddress) external;\\n\\n    function routerStatus(LSSVMRouter router) external view returns (bool allowed, bool wasEverTouched);\\n\\n    function isValidPair(address pairAddress) external view returns (bool);\\n\\n    function getPairNFTType(address pairAddress) external pure returns (PairNFTType);\\n\\n    function getPairTokenType(address pairAddress) external pure returns (PairTokenType);\\n\\n    function openLock() external;\\n\\n    function closeLock() external;\\n}\\n\"\r\n    },\r\n    \"src/lib/IOwnershipTransferReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.4;\\n\\ninterface IOwnershipTransferReceiver {\\n    function onOwnershipTransferred(address oldOwner, bytes memory data) external payable;\\n}\\n\"\r\n    },\r\n    \"src/lib/OwnableWithTransferCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.4;\\n\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {ERC165Checker} from \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\n\\nimport {IOwnershipTransferReceiver} from \\\"./IOwnershipTransferReceiver.sol\\\";\\n\\nabstract contract OwnableWithTransferCallback {\\n    using ERC165Checker for address;\\n    using Address for address;\\n\\n    bytes4 constant TRANSFER_CALLBACK = type(IOwnershipTransferReceiver).interfaceId;\\n\\n    error Ownable_NotOwner();\\n    error Ownable_NewOwnerZeroAddress();\\n\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init(address initialOwner) internal {\\n        _owner = initialOwner;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        if (owner() != msg.sender) revert Ownable_NotOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * @param newOwner The new address to become owner\\n     * @param data Any additional data to send to the ownership received callback.\\n     * Disallows setting to the zero address as a way to more gas-efficiently avoid reinitialization.\\n     * When ownership is transferred, if the new owner implements IOwnershipTransferCallback, we make a callback.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner, bytes calldata data) public payable virtual onlyOwner {\\n        if (newOwner == address(0)) revert Ownable_NewOwnerZeroAddress();\\n        _transferOwnership(newOwner);\\n\\n        if (newOwner.isContract()) {\\n            try IOwnershipTransferReceiver(newOwner).onOwnershipTransferred{value: msg.value}(msg.sender, data) {}\\n            // If revert...\\n            catch (bytes memory reason) {\\n                // If we just transferred to a contract w/ no callback, this is fine\\n                if (reason.length == 0) {\\n                    // i.e., no need to revert\\n                }\\n                // Otherwise, the callback had an error, and we should revert\\n                else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\\n     * @dev Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        _owner = newOwner;\\n        emit OwnershipTransferred(newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/royalty-registry-solidity/contracts/IRoyaltyEngineV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Lookup engine interface\\n */\\ninterface IRoyaltyEngineV1 is IERC165 {\\n    /**\\n     * Get the royalty for a given token (address, id) and value amount.  Does not cache the bps/amounts.  Caches the spec for a given token address\\n     *\\n     * @param tokenAddress - The address of the token\\n     * @param tokenId      - The id of the token\\n     * @param value        - The value you wish to get the royalty of\\n     *\\n     * returns Two arrays of equal length, royalty recipients and the corresponding amount each recipient should get\\n     */\\n    function getRoyalty(address tokenAddress, uint256 tokenId, uint256 value)\\n        external\\n        returns (address payable[] memory recipients, uint256[] memory amounts);\\n\\n    /**\\n     * View only version of getRoyalty\\n     *\\n     * @param tokenAddress - The address of the token\\n     * @param tokenId      - The id of the token\\n     * @param value        - The value you wish to get the royalty of\\n     *\\n     * returns Two arrays of equal length, royalty recipients and the corresponding amount each recipient should get\\n     */\\n    function getRoyaltyView(address tokenAddress, uint256 tokenId, uint256 value)\\n        external\\n        view\\n        returns (address payable[] memory recipients, uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/utils/ERC721Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721Holder is IERC721Receiver {\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC1155Receiver.sol\\\";\\n\\n/**\\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\\n *\\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\\n * stuck.\\n *\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155Holder is ERC1155Receiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/LSSVMRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\n\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\nimport {LSSVMPair} from \\\"./LSSVMPair.sol\\\";\\nimport {ILSSVMPairFactoryLike} from \\\"./ILSSVMPairFactoryLike.sol\\\";\\nimport {CurveErrorCodes} from \\\"./bonding-curves/CurveErrorCodes.sol\\\";\\n\\ncontract LSSVMRouter {\\n    using SafeTransferLib for address payable;\\n    using SafeTransferLib for ERC20;\\n\\n    struct PairSwapSpecific {\\n        LSSVMPair pair;\\n        uint256[] nftIds;\\n    }\\n\\n    struct RobustPairSwapSpecific {\\n        PairSwapSpecific swapInfo;\\n        uint256 maxCost;\\n    }\\n\\n    struct RobustPairSwapSpecificForToken {\\n        PairSwapSpecific swapInfo;\\n        uint256 minOutput;\\n    }\\n\\n    struct NFTsForSpecificNFTsTrade {\\n        PairSwapSpecific[] nftToTokenTrades;\\n        PairSwapSpecific[] tokenToNFTTrades;\\n    }\\n\\n    struct RobustPairNFTsFoTokenAndTokenforNFTsTrade {\\n        RobustPairSwapSpecific[] tokenToNFTTrades;\\n        RobustPairSwapSpecificForToken[] nftToTokenTrades;\\n        uint256 inputAmount;\\n        address payable tokenRecipient;\\n        address nftRecipient;\\n    }\\n\\n    modifier checkDeadline(uint256 deadline) {\\n        _checkDeadline(deadline);\\n        _;\\n    }\\n\\n    ILSSVMPairFactoryLike public immutable factory;\\n\\n    constructor(ILSSVMPairFactoryLike _factory) {\\n        factory = _factory;\\n    }\\n\\n    /**\\n     * ETH swaps\\n     */\\n\\n    /**\\n     * @notice Swaps ETH into specific NFTs using multiple pairs.\\n     * @param swapList The list of pairs to trade with and the IDs of the NFTs to buy from each.\\n     * @param ethRecipient The address that will receive the unspent ETH input\\n     * @param nftRecipient The address that will receive the NFT output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return remainingValue The unspent ETH amount\\n     */\\n    function swapETHForSpecificNFTs(\\n        PairSwapSpecific[] calldata swapList,\\n        address payable ethRecipient,\\n        address nftRecipient,\\n        uint256 deadline\\n    ) external payable checkDeadline(deadline) returns (uint256 remainingValue) {\\n        return _swapETHForSpecificNFTs(swapList, msg.value, ethRecipient, nftRecipient);\\n    }\\n\\n    /**\\n     * @notice Swaps one set of NFTs into another set of specific NFTs using multiple pairs, using\\n     * ETH as the intermediary.\\n     * @param trade The struct containing all NFT-to-ETH swaps and ETH-to-NFT swaps.\\n     * @param minOutput The minimum acceptable total excess ETH received\\n     * @param ethRecipient The address that will receive the ETH output\\n     * @param nftRecipient The address that will receive the NFT output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return outputAmount The total ETH received\\n     */\\n    function swapNFTsForSpecificNFTsThroughETH(\\n        NFTsForSpecificNFTsTrade calldata trade,\\n        uint256 minOutput,\\n        address payable ethRecipient,\\n        address nftRecipient,\\n        uint256 deadline\\n    ) external payable checkDeadline(deadline) returns (uint256 outputAmount) {\\n        // Swap NFTs for ETH\\n        // minOutput of swap set to 0 since we're doing an aggregate slippage check\\n        outputAmount = _swapNFTsForToken(trade.nftToTokenTrades, 0, payable(address(this)));\\n\\n        // Add extra value to buy NFTs\\n        outputAmount += msg.value;\\n\\n        // Swap ETH for specific NFTs\\n        // cost <= inputValue = outputAmount - minOutput, so outputAmount' = (outputAmount - minOutput - cost) + minOutput >= minOutput\\n        outputAmount = _swapETHForSpecificNFTs(\\n            trade.tokenToNFTTrades, outputAmount - minOutput, ethRecipient, nftRecipient\\n        ) + minOutput;\\n    }\\n\\n    /**\\n     * ERC20 swaps\\n     *\\n     * Note: All ERC20 swaps assume that a single ERC20 token is used for all the pairs involved.\\n     * Swapping using multiple tokens in the same transaction is possible, but the slippage checks\\n     * & the return values will be meaningless, and may lead to undefined behavior.\\n     *\\n     * Note: The sender should ideally grant infinite token approval to the router in order for NFT-to-NFT\\n     * swaps to work smoothly.\\n     */\\n\\n    /**\\n     * @notice Swaps ERC20 tokens into specific NFTs using multiple pairs.\\n     * @param swapList The list of pairs to trade with and the IDs of the NFTs to buy from each.\\n     * @param inputAmount The amount of ERC20 tokens to add to the ERC20-to-NFT swaps\\n     * @param nftRecipient The address that will receive the NFT output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return remainingValue The unspent token amount\\n     */\\n    function swapERC20ForSpecificNFTs(\\n        PairSwapSpecific[] calldata swapList,\\n        uint256 inputAmount,\\n        address nftRecipient,\\n        uint256 deadline\\n    ) external checkDeadline(deadline) returns (uint256 remainingValue) {\\n        return _swapERC20ForSpecificNFTs(swapList, inputAmount, nftRecipient);\\n    }\\n\\n    /**\\n     * @notice Swaps NFTs into ETH/ERC20 using multiple pairs.\\n     * @param swapList The list of pairs to trade with and the IDs of the NFTs to sell to each.\\n     * @param minOutput The minimum acceptable total tokens received\\n     * @param tokenRecipient The address that will receive the token output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return outputAmount The total tokens received\\n     */\\n    function swapNFTsForToken(\\n        PairSwapSpecific[] calldata swapList,\\n        uint256 minOutput,\\n        address tokenRecipient,\\n        uint256 deadline\\n    ) external checkDeadline(deadline) returns (uint256 outputAmount) {\\n        return _swapNFTsForToken(swapList, minOutput, payable(tokenRecipient));\\n    }\\n\\n    /**\\n     * @notice Swaps one set of NFTs into another set of specific NFTs using multiple pairs, using\\n     * an ERC20 token as the intermediary.\\n     * @param trade The struct containing all NFT-to-ERC20 swaps and ERC20-to-NFT swaps.\\n     * @param inputAmount The amount of ERC20 tokens to add to the ERC20-to-NFT swaps\\n     * @param minOutput The minimum acceptable total excess tokens received\\n     * @param nftRecipient The address that will receive the NFT output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return outputAmount The total ERC20 tokens received\\n     */\\n    function swapNFTsForSpecificNFTsThroughERC20(\\n        NFTsForSpecificNFTsTrade calldata trade,\\n        uint256 inputAmount,\\n        uint256 minOutput,\\n        address nftRecipient,\\n        uint256 deadline\\n    ) external checkDeadline(deadline) returns (uint256 outputAmount) {\\n        // Swap NFTs for ERC20\\n        // minOutput of swap set to 0 since we're doing an aggregate slippage check\\n        // output tokens are sent to msg.sender\\n        outputAmount = _swapNFTsForToken(trade.nftToTokenTrades, 0, payable(msg.sender));\\n\\n        // Add extra value to buy NFTs\\n        outputAmount += inputAmount;\\n\\n        // Swap ERC20 for specific NFTs\\n        // cost <= maxCost = outputAmount - minOutput, so outputAmount' = outputAmount - cost >= minOutput\\n        // input tokens are taken directly from msg.sender\\n        outputAmount =\\n            _swapERC20ForSpecificNFTs(trade.tokenToNFTTrades, outputAmount - minOutput, nftRecipient) + minOutput;\\n    }\\n\\n    /**\\n     * Robust Swaps\\n     * These are \\\"robust\\\" versions of the NFT<>Token swap functions which will never revert due to slippage\\n     * Instead, users specify a per-swap max cost. If the price changes more than the user specifies, no swap is attempted. This allows users to specify a batch of swaps, and execute as many of them as possible.\\n     */\\n\\n    /**\\n     * @dev Ensure msg.value >= sum of values in maxCostPerPair to make sure the transaction doesn't revert\\n     * @param swapList The list of pairs to trade with and the IDs of the NFTs to buy from each.\\n     * @param ethRecipient The address that will receive the unspent ETH input\\n     * @param nftRecipient The address that will receive the NFT output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return remainingValue The unspent token amount\\n     */\\n    function robustSwapETHForSpecificNFTs(\\n        RobustPairSwapSpecific[] calldata swapList,\\n        address payable ethRecipient,\\n        address nftRecipient,\\n        uint256 deadline\\n    ) public payable virtual checkDeadline(deadline) returns (uint256 remainingValue) {\\n        remainingValue = msg.value;\\n        uint256 pairCost;\\n        CurveErrorCodes.Error error;\\n\\n        // Try doing each swap\\n        uint256 numSwaps = swapList.length;\\n        for (uint256 i; i < numSwaps;) {\\n            // Calculate actual cost per swap\\n            (error,,, pairCost,,) = swapList[i].swapInfo.pair.getBuyNFTQuote(\\n                swapList[i].swapInfo.nftIds[0], swapList[i].swapInfo.nftIds.length\\n            );\\n\\n            // If within our maxCost and no error, proceed\\n            if (pairCost <= swapList[i].maxCost && error == CurveErrorCodes.Error.OK) {\\n                // We know how much ETH to send because we already did the math above\\n                // So we just send that much\\n                remainingValue -= swapList[i].swapInfo.pair.swapTokenForSpecificNFTs{value: pairCost}(\\n                    swapList[i].swapInfo.nftIds, pairCost, nftRecipient, true, msg.sender\\n                );\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Return remaining value to sender\\n        if (remainingValue > 0) {\\n            ethRecipient.safeTransferETH(remainingValue);\\n        }\\n    }\\n\\n    /**\\n     * @notice Swaps as many ERC20 tokens for specific NFTs as possible, respecting the per-swap max cost.\\n     * @param swapList The list of pairs to trade with and the IDs of the NFTs to buy from each.\\n     * @param inputAmount The amount of ERC20 tokens to add to the ERC20-to-NFT swaps\\n     * @param nftRecipient The address that will receive the NFT output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return remainingValue The unspent token amount\\n     */\\n    function robustSwapERC20ForSpecificNFTs(\\n        RobustPairSwapSpecific[] calldata swapList,\\n        uint256 inputAmount,\\n        address nftRecipient,\\n        uint256 deadline\\n    ) public virtual checkDeadline(deadline) returns (uint256 remainingValue) {\\n        remainingValue = inputAmount;\\n        uint256 pairCost;\\n        CurveErrorCodes.Error error;\\n\\n        // Try doing each swap\\n        uint256 numSwaps = swapList.length;\\n        for (uint256 i; i < numSwaps;) {\\n            // Calculate actual cost per swap\\n            (error,,, pairCost,,) = swapList[i].swapInfo.pair.getBuyNFTQuote(\\n                swapList[i].swapInfo.nftIds[0], swapList[i].swapInfo.nftIds.length\\n            );\\n\\n            // If within our maxCost and no error, proceed\\n            if (pairCost <= swapList[i].maxCost && error == CurveErrorCodes.Error.OK) {\\n                remainingValue -= swapList[i].swapInfo.pair.swapTokenForSpecificNFTs(\\n                    swapList[i].swapInfo.nftIds, pairCost, nftRecipient, true, msg.sender\\n                );\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Swaps as many NFTs for tokens as possible, respecting the per-swap min output\\n     * @param swapList The list of pairs to trade with and the IDs of the NFTs to sell to each.\\n     * @param tokenRecipient The address that will receive the token output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return outputAmount The total ETH/ERC20 received\\n     */\\n    function robustSwapNFTsForToken(\\n        RobustPairSwapSpecificForToken[] calldata swapList,\\n        address payable tokenRecipient,\\n        uint256 deadline\\n    ) public virtual checkDeadline(deadline) returns (uint256 outputAmount) {\\n        // Try doing each swap\\n        uint256 numSwaps = swapList.length;\\n        for (uint256 i; i < numSwaps;) {\\n            uint256 pairOutput;\\n\\n            // Locally scoped to avoid stack too deep error\\n            {\\n                CurveErrorCodes.Error error;\\n                uint256[] memory nftIds = swapList[i].swapInfo.nftIds;\\n                if (nftIds.length == 0) {\\n                    unchecked {\\n                        ++i;\\n                    }\\n                    continue;\\n                }\\n                (error,,, pairOutput,,) = swapList[i].swapInfo.pair.getSellNFTQuote(nftIds[0], nftIds.length);\\n                if (error != CurveErrorCodes.Error.OK) {\\n                    unchecked {\\n                        ++i;\\n                    }\\n                    continue;\\n                }\\n            }\\n\\n            // If at least equal to our minOutput, proceed\\n            if (pairOutput >= swapList[i].minOutput) {\\n                // Do the swap and update outputAmount with how many tokens we got\\n                outputAmount += swapList[i].swapInfo.pair.swapNFTsForToken(\\n                    swapList[i].swapInfo.nftIds, 0, tokenRecipient, true, msg.sender\\n                );\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Buys NFTs with ETH and sells them for tokens in one transaction\\n     * @param params All the parameters for the swap (packed in struct to avoid stack too deep), containing:\\n     * - ethToNFTSwapList The list of NFTs to buy\\n     * - nftToTokenSwapList The list of NFTs to sell\\n     * - inputAmount The max amount of tokens to send (if ERC20)\\n     * - tokenRecipient The address that receives tokens from the NFTs sold\\n     * - nftRecipient The address that receives NFTs\\n     * - deadline UNIX timestamp deadline for the swap\\n     */\\n    function robustSwapETHForSpecificNFTsAndNFTsToToken(RobustPairNFTsFoTokenAndTokenforNFTsTrade calldata params)\\n        external\\n        payable\\n        virtual\\n        returns (uint256 remainingValue, uint256 outputAmount)\\n    {\\n        {\\n            remainingValue = msg.value;\\n            uint256 pairCost;\\n            CurveErrorCodes.Error error;\\n\\n            // Try doing each swap\\n            uint256 numSwaps = params.tokenToNFTTrades.length;\\n            for (uint256 i; i < numSwaps;) {\\n                // Calculate actual cost per swap\\n                (error,,, pairCost,,) = params.tokenToNFTTrades[i].swapInfo.pair.getBuyNFTQuote(\\n                    params.tokenToNFTTrades[i].swapInfo.nftIds[0], params.tokenToNFTTrades[i].swapInfo.nftIds.length\\n                );\\n\\n                // If within our maxCost and no error, proceed\\n                if (pairCost <= params.tokenToNFTTrades[i].maxCost && error == CurveErrorCodes.Error.OK) {\\n                    // We know how much ETH to send because we already did the math above\\n                    // So we just send that much\\n                    remainingValue -= params.tokenToNFTTrades[i].swapInfo.pair.swapTokenForSpecificNFTs{value: pairCost}(\\n                        params.tokenToNFTTrades[i].swapInfo.nftIds, pairCost, params.nftRecipient, true, msg.sender\\n                    );\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n\\n            // Return remaining value to sender\\n            if (remainingValue > 0) {\\n                params.tokenRecipient.safeTransferETH(remainingValue);\\n            }\\n        }\\n        {\\n            // Try doing each swap\\n            uint256 numSwaps = params.nftToTokenTrades.length;\\n            for (uint256 i; i < numSwaps;) {\\n                uint256 pairOutput;\\n\\n                // Locally scoped to avoid stack too deep error\\n                {\\n                    CurveErrorCodes.Error error;\\n                    uint256 assetId = params.nftToTokenTrades[i].swapInfo.nftIds[0];\\n                    (error,,, pairOutput,,) = params.nftToTokenTrades[i].swapInfo.pair.getSellNFTQuote(\\n                        assetId, params.nftToTokenTrades[i].swapInfo.nftIds.length\\n                    );\\n                    if (error != CurveErrorCodes.Error.OK) {\\n                        unchecked {\\n                            ++i;\\n                        }\\n                        continue;\\n                    }\\n                }\\n\\n                // If at least equal to our minOutput, proceed\\n                if (pairOutput >= params.nftToTokenTrades[i].minOutput) {\\n                    // Do the swap and update outputAmount with how many tokens we got\\n                    outputAmount += params.nftToTokenTrades[i].swapInfo.pair.swapNFTsForToken(\\n                        params.nftToTokenTrades[i].swapInfo.nftIds, 0, params.tokenRecipient, true, msg.sender\\n                    );\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Buys NFTs with ERC20, and sells them for tokens in one transaction\\n     * @param params All the parameters for the swap (packed in struct to avoid stack too deep), containing:\\n     * - ethToNFTSwapList The list of NFTs to buy\\n     * - nftToTokenSwapList The list of NFTs to sell\\n     * - inputAmount The max amount of tokens to send (if ERC20)\\n     * - tokenRecipient The address that receives tokens from the NFTs sold\\n     * - nftRecipient The address that receives NFTs\\n     * - deadline UNIX timestamp deadline for the swap\\n     */\\n    function robustSwapERC20ForSpecificNFTsAndNFTsToToken(RobustPairNFTsFoTokenAndTokenforNFTsTrade calldata params)\\n        external\\n        virtual\\n        returns (uint256 remainingValue, uint256 outputAmount)\\n    {\\n        {\\n            remainingValue = params.inputAmount;\\n            uint256 pairCost;\\n            CurveErrorCodes.Error error;\\n\\n            // Try doing each swap\\n            uint256 numSwaps = params.tokenToNFTTrades.length;\\n            for (uint256 i; i < numSwaps;) {\\n                // Calculate actual cost per swap\\n                (error,,, pairCost,,) = params.tokenToNFTTrades[i].swapInfo.pair.getBuyNFTQuote(\\n                    params.tokenToNFTTrades[i].swapInfo.nftIds[0], params.tokenToNFTTrades[i].swapInfo.nftIds.length\\n                );\\n\\n                // If within our maxCost and no error, proceed\\n                if (pairCost <= params.tokenToNFTTrades[i].maxCost && error == CurveErrorCodes.Error.OK) {\\n                    remainingValue -= params.tokenToNFTTrades[i].swapInfo.pair.swapTokenForSpecificNFTs(\\n                        params.tokenToNFTTrades[i].swapInfo.nftIds, pairCost, params.nftRecipient, true, msg.sender\\n                    );\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n        {\\n            // Try doing each swap\\n            uint256 numSwaps = params.nftToTokenTrades.length;\\n            for (uint256 i; i < numSwaps;) {\\n                uint256 pairOutput;\\n\\n                // Locally scoped to avoid stack too deep error\\n                {\\n                    CurveErrorCodes.Error error;\\n                    uint256 assetId = params.nftToTokenTrades[i].swapInfo.nftIds[0];\\n                    (error,,, pairOutput,,) = params.nftToTokenTrades[i].swapInfo.pair.getSellNFTQuote(\\n                        assetId, params.nftToTokenTrades[i].swapInfo.nftIds.length\\n                    );\\n                    if (error != CurveErrorCodes.Error.OK) {\\n                        unchecked {\\n                            ++i;\\n                        }\\n                        continue;\\n                    }\\n                }\\n\\n                // If at least equal to our minOutput, proceed\\n                if (pairOutput >= params.nftToTokenTrades[i].minOutput) {\\n                    // Do the swap and update outputAmount with how many tokens we got\\n                    outputAmount += params.nftToTokenTrades[i].swapInfo.pair.swapNFTsForToken(\\n                        params.nftToTokenTrades[i].swapInfo.nftIds, 0, params.tokenRecipient, true, msg.sender\\n                    );\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n    }\\n\\n    receive() external payable {}\\n\\n    /**\\n     * Restricted functions\\n     */\\n\\n    /**\\n     * @dev Allows an ERC20 pair contract to transfer ERC20 tokens directly from\\n     * the sender, in order to minimize the number of token transfers. Only callable by an ERC20 pair.\\n     * @param token The ERC20 token to transfer\\n     * @param from The address to transfer tokens from\\n     * @param to The address to transfer tokens to\\n     * @param amount The amount of tokens to transfer\\n     */\\n    function pairTransferERC20From(ERC20 token, address from, address to, uint256 amount) external {\\n        // verify caller is a trusted pair contract\\n        require(factory.isValidPair(msg.sender), \\\"Not pair\\\");\\n        // verify caller is an ERC20 pair\\n        require(factory.getPairTokenType(msg.sender) == ILSSVMPairFactoryLike.PairTokenType.ERC20, \\\"Not ERC20 pair\\\");\\n\\n        // transfer tokens to pair\\n        token.safeTransferFrom(from, to, amount);\\n    }\\n\\n    /**\\n     * @dev Allows a pair contract to transfer ERC721 NFTs directly from\\n     * the sender, in order to minimize the number of token transfers. Only callable by a pair.\\n     * @param nft The ERC721 NFT to transfer\\n     * @param from The address to transfer tokens from\\n     * @param to The address to transfer tokens to\\n     * @param id The ID of the NFT to transfer\\n     */\\n    function pairTransferNFTFrom(IERC721 nft, address from, address to, uint256 id) external {\\n        // verify caller is a trusted pair contract\\n        require(factory.isValidPair(msg.sender), \\\"Not pair\\\");\\n\\n        // transfer NFTs to pair\\n        nft.transferFrom(from, to, id);\\n    }\\n\\n    function pairTransferERC1155From(\\n        IERC1155 nft,\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        // verify caller is a trusted pair contract\\n        require(factory.isValidPair(msg.sender), \\\"Not pair\\\");\\n\\n        nft.safeBatchTransferFrom(from, to, ids, amounts, bytes(\\\"\\\"));\\n    }\\n\\n    /**\\n     * Internal functions\\n     */\\n\\n    /**\\n     * @param deadline The last valid time for a swap\\n     */\\n    function _checkDeadline(uint256 deadline) internal view {\\n        require(block.timestamp <= deadline, \\\"Deadline passed\\\");\\n    }\\n\\n    /**\\n     * @notice Internal function used to swap ETH for a specific set of NFTs\\n     * @param swapList The list of pairs and swap calldata\\n     * @param inputAmount The total amount of ETH to send\\n     * @param ethRecipient The address receiving excess ETH\\n     * @param nftRecipient The address receiving the NFTs from the pairs\\n     * @return remainingValue The unspent token amount\\n     */\\n    function _swapETHForSpecificNFTs(\\n        PairSwapSpecific[] calldata swapList,\\n        uint256 inputAmount,\\n        address payable ethRecipient,\\n        address nftRecipient\\n    ) internal virtual returns (uint256 remainingValue) {\\n        remainingValue = inputAmount;\\n\\n        uint256 pairCost;\\n        CurveErrorCodes.Error error;\\n\\n        // Do swaps\\n        uint256 numSwaps = swapList.length;\\n        for (uint256 i; i < numSwaps;) {\\n            // Calculate the cost per swap first to send exact amount of ETH over, saves gas by avoiding the need to send back excess ETH\\n            (error,,, pairCost,,) = swapList[i].pair.getBuyNFTQuote(swapList[i].nftIds[0], swapList[i].nftIds.length);\\n\\n            // Require no errors\\n            require(error == CurveErrorCodes.Error.OK, \\\"Bonding curve error\\\");\\n\\n            // Total ETH taken from sender cannot exceed inputAmount\\n            // because otherwise the deduction from remainingValue will fail\\n            remainingValue -= swapList[i].pair.swapTokenForSpecificNFTs{value: pairCost}(\\n                swapList[i].nftIds, remainingValue, nftRecipient, true, msg.sender\\n            );\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Return remaining value to sender\\n        if (remainingValue > 0) {\\n            ethRecipient.safeTransferETH(remainingValue);\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function used to swap an ERC20 token for specific NFTs\\n     * @dev Note that we don't need to query the pair's bonding curve first for pricing data because\\n     * we just calculate and take the required amount from the caller during swap time.\\n     * However, we can't \\\"pull\\\" ETH, which is why for the ETH->NFT swaps, we need to calculate the pricing info\\n     * to figure out how much the router should send to the pool.\\n     * @param swapList The list of pairs and swap calldata\\n     * @param inputAmount The total amount of ERC20 tokens to send\\n     * @param nftRecipient The address receiving the NFTs from the pairs\\n     * @return remainingValue The unspent token amount\\n     */\\n    function _swapERC20ForSpecificNFTs(PairSwapSpecific[] calldata swapList, uint256 inputAmount, address nftRecipient)\\n        internal\\n        virtual\\n        returns (uint256 remainingValue)\\n    {\\n        remainingValue = inputAmount;\\n\\n        // Do swaps\\n        uint256 numSwaps = swapList.length;\\n        for (uint256 i; i < numSwaps;) {\\n            // Tokens are transferred in by the pair calling router.pairTransferERC20From\\n            // Total tokens taken from sender cannot exceed inputAmount\\n            // because otherwise the deduction from remainingValue will fail\\n            remainingValue -= swapList[i].pair.swapTokenForSpecificNFTs(\\n                swapList[i].nftIds, remainingValue, nftRecipient, true, msg.sender\\n            );\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Swaps NFTs for tokens, designed to be used for 1 token at a time\\n     * @dev Calling with multiple tokens is permitted, BUT minOutput will be\\n     * far from enough of a safety check because different tokens almost certainly have different unit prices.\\n     * @param swapList The list of pairs and swap calldata\\n     * @param minOutput The minimum number of tokens to be receieved from the swaps\\n     * @param tokenRecipient The address that receives the tokens\\n     * @return outputAmount The number of tokens to be received\\n     */\\n    function _swapNFTsForToken(PairSwapSpecific[] calldata swapList, uint256 minOutput, address payable tokenRecipient)\\n        internal\\n        virtual\\n        returns (uint256 outputAmount)\\n    {\\n        // Do swaps\\n        uint256 numSwaps = swapList.length;\\n        for (uint256 i; i < numSwaps;) {\\n            // Do the swap for token and then update outputAmount\\n            // Note: minExpectedTokenOutput is set to 0 since we're doing an aggregate slippage check below\\n            outputAmount += swapList[i].pair.swapNFTsForToken(swapList[i].nftIds, 0, tokenRecipient, true, msg.sender);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Aggregate slippage check\\n        require(outputAmount >= minOutput, \\\"outputAmount too low\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/bonding-curves/ICurve.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {CurveErrorCodes} from \\\"./CurveErrorCodes.sol\\\";\\n\\ninterface ICurve {\\n    /**\\n     * @notice Validates if a delta value is valid for the curve. The criteria for\\n     * validity can be different for each type of curve, for instance ExponentialCurve\\n     * requires delta to be greater than 1.\\n     * @param delta The delta value to be validated\\n     * @return valid True if delta is valid, false otherwise\\n     */\\n    function validateDelta(uint128 delta) external pure returns (bool valid);\\n\\n    /**\\n     * @notice Validates if a new spot price is valid for the curve. Spot price is generally assumed to be the immediate sell price of 1 NFT to the pool, in units of the pool's paired token.\\n     * @param newSpotPrice The new spot price to be set\\n     * @return valid True if the new spot price is valid, false otherwise\\n     */\\n    function validateSpotPrice(uint128 newSpotPrice) external view returns (bool valid);\\n\\n    /**\\n     * @notice Given the current state of the pair and the trade, computes how much the user\\n     * should pay to purchase an NFT from the pair, the new spot price, and other values.\\n     * @param spotPrice The current selling spot price of the pair, in tokens\\n     * @param delta The delta parameter of the pair, what it means depends on the curve\\n     * @param numItems The number of NFTs the user is buying from the pair\\n     * @param feeMultiplier Determines how much fee the LP takes from this trade, 18 decimals\\n     * @param protocolFeeMultiplier Determines how much fee the protocol takes from this trade, 18 decimals\\n     * @return error Any math calculation errors, only Error.OK means the returned values are valid\\n     * @return newSpotPrice The updated selling spot price, in tokens\\n     * @return newDelta The updated delta, used to parameterize the bonding curve\\n     * @return inputValue The amount that the user should pay, in tokens\\n     * @return tradeFee The amount that is sent to the trade fee recipient\\n     * @return protocolFee The amount of fee to send to the protocol, in tokens\\n     */\\n    function getBuyInfo(\\n        uint128 spotPrice,\\n        uint128 delta,\\n        uint256 numItems,\\n        uint256 feeMultiplier,\\n        uint256 protocolFeeMultiplier\\n    )\\n        external\\n        view\\n        returns (\\n            CurveErrorCodes.Error error,\\n            uint128 newSpotPrice,\\n            uint128 newDelta,\\n            uint256 inputValue,\\n            uint256 tradeFee,\\n            uint256 protocolFee\\n        );\\n\\n    /**\\n     * @notice Given the current state of the pair and the trade, computes how much the user\\n     * should receive when selling NFTs to the pair, the new spot price, and other values.\\n     * @param spotPrice The current selling spot price of the pair, in tokens\\n     * @param delta The delta parameter of the pair, what it means depends on the curve\\n     * @param numItems The number of NFTs the user is selling to the pair\\n     * @param feeMultiplier Determines how much fee the LP takes from this trade, 18 decimals\\n     * @param protocolFeeMultiplier Determines how much fee the protocol takes from this trade, 18 decimals\\n     * @return error Any math calculation errors, only Error.OK means the returned values are valid\\n     * @return newSpotPrice The updated selling spot price, in tokens\\n     * @return newDelta The updated delta, used to parameterize the bonding curve\\n     * @return outputValue The amount that the user should receive, in tokens\\n     * @return tradeFee The amount that is sent to the trade fee recipient\\n     * @return protocolFee The amount of fee to send to the protocol, in tokens\\n     */\\n    function getSellInfo(\\n        uint128 spotPrice,\\n        uint128 delta,\\n        uint256 numItems,\\n        uint256 feeMultiplier,\\n        uint256 protocolFeeMultiplier\\n    )\\n        external\\n        view\\n        returns (\\n            CurveErrorCodes.Error error,\\n            uint128 newSpotPrice,\\n            uint128 newDelta,\\n            uint256 outputValue,\\n            uint256 tradeFee,\\n            uint256 protocolFee\\n        );\\n}\\n\"\r\n    },\r\n    \"src/bonding-curves/CurveErrorCodes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\ncontract CurveErrorCodes {\\n    enum Error {\\n        OK, // No error\\n        INVALID_NUMITEMS, // The numItem value is 0\\n        SPOT_PRICE_OVERFLOW, // The updated spot price doesn't fit into 128 bits\\n        DELTA_OVERFLOW, // The updated delta doesn't fit into 128 bits\\n        SPOT_PRICE_UNDERFLOW // The updated spot price goes too low\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165Checker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface.\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\\n        internal\\n        view\\n        returns (bool[] memory)\\n    {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success && returnSize >= 0x20 && returnValue > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Receiver.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@manifoldxyz/=lib/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@prb/math/=lib/prb-math/src/\",\r\n      \"clones-with-immutable-args/=lib/clones-with-immutable-args/src/\",\r\n      \"create3-factory/=lib/create3-factory/src/\",\r\n      \"ds-test/=lib/clones-with-immutable-args/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"foundry-huff/=lib/foundry-huff/src/\",\r\n      \"huffmate/=lib/huffmate/src/\",\r\n      \"lzero/=lib/solidity-examples/contracts/\",\r\n      \"manifoldxyz/=lib/royalty-registry-solidity/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"stringutils/=lib/foundry-huff/lib/solidity-stringutils/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ILSSVMPairFactoryLike\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_zorb\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Ownable_NewOwnerZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Ownable_NotOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getSVG\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bytes[]\",\"name\":\"calls\",\"type\":\"bytes[]\"},{\"internalType\":\"bool\",\"name\":\"revertOnFail\",\"type\":\"bool\"}],\"name\":\"multicall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onOwnershipTransferred\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pairs\",\"type\":\"address[]\"}],\"name\":\"reclaimPairs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"s\",\"type\":\"string\"}],\"name\":\"setSpecial\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"z\",\"type\":\"address\"}],\"name\":\"setZorb\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"specialStuff\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "WrappedSudoPool", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000a020d57ab0448ef74115c112d18a9c231cc86000000000000000000000000000ca21d4228cdcc68d4e23807e5e370c07577dd152", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}