{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/modules/SuperMinterV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport { Ownable, OwnableRoles } from \\\"solady/auth/OwnableRoles.sol\\\";\\nimport { ISoundEditionV2_1 } from \\\"@core/interfaces/ISoundEditionV2_1.sol\\\";\\nimport { ISuperMinterV2 } from \\\"@modules/interfaces/ISuperMinterV2.sol\\\";\\nimport { IERC165 } from \\\"openzeppelin/utils/introspection/IERC165.sol\\\";\\nimport { SafeTransferLib } from \\\"solady/utils/SafeTransferLib.sol\\\";\\nimport { EIP712 } from \\\"solady/utils/EIP712.sol\\\";\\nimport { MerkleProofLib } from \\\"solady/utils/MerkleProofLib.sol\\\";\\nimport { LibBitmap } from \\\"solady/utils/LibBitmap.sol\\\";\\nimport { SignatureCheckerLib } from \\\"solady/utils/SignatureCheckerLib.sol\\\";\\nimport { LibZip } from \\\"solady/utils/LibZip.sol\\\";\\nimport { LibMap } from \\\"solady/utils/LibMap.sol\\\";\\nimport { DelegateCashLib } from \\\"@modules/utils/DelegateCashLib.sol\\\";\\nimport { LibOps } from \\\"@core/utils/LibOps.sol\\\";\\nimport { LibMulticaller } from \\\"multicaller/LibMulticaller.sol\\\";\\n\\n/**\\n * @title SuperMinterV2\\n * @dev The `SuperMinterV2` class is a generalized minter.\\n */\\ncontract SuperMinterV2 is ISuperMinterV2, EIP712 {\\n    using LibBitmap for *;\\n    using MerkleProofLib for *;\\n    using LibMap for *;\\n\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    /**\\n     * @dev A struct to hold the mint data in storage.\\n     */\\n    struct MintData {\\n        // The platform address.\\n        address platform;\\n        // The price per token.\\n        uint96 price;\\n        // The start time of the mint.\\n        uint32 startTime;\\n        // The end time of the mint.\\n        uint32 endTime;\\n        // The maximum number of tokens an account can mint in this mint.\\n        uint32 maxMintablePerAccount;\\n        // The maximum tokens mintable.\\n        uint32 maxMintable;\\n        // The total number of tokens minted.\\n        uint32 minted;\\n        // The affiliate fee BPS.\\n        uint16 affiliateFeeBPS;\\n        // The offset to the next mint data in the linked list.\\n        uint16 next;\\n        // The head of the mint data linked list.\\n        // Only stored in the 0-th mint data per edition.\\n        uint16 head;\\n        // The total number of mint data.\\n        // Only stored in the 0-th mint data per edition.\\n        uint16 numMintData;\\n        // The total number of mints for the edition-tier.\\n        // Only stored in the 0-th mint data per edition-tier.\\n        uint8 nextScheduleNum;\\n        // The mode of the mint.\\n        uint8 mode;\\n        // The packed boolean flags.\\n        uint8 flags;\\n        // The affiliate Merkle root, if any.\\n        bytes32 affiliateMerkleRoot;\\n        // The Merkle root hash, required if `mode` is `VERIFY_MERKLE`.\\n        bytes32 merkleRoot;\\n    }\\n\\n    // =============================================================\\n    //                           CONSTANTS\\n    // =============================================================\\n\\n    /**\\n     * @dev The GA tier. Which is 0.\\n     */\\n    uint8 public constant GA_TIER = 0;\\n\\n    /**\\n     * @dev For EIP-712 signature digest calculation.\\n     */\\n    bytes32 public constant MINT_TO_TYPEHASH =\\n        // prettier-ignore\\n        keccak256(\\n            \\\"MintTo(\\\"\\n                \\\"address edition,\\\"\\n                \\\"uint8 tier,\\\"\\n                \\\"uint8 scheduleNum,\\\"\\n                \\\"address to,\\\"\\n                \\\"uint32 signedQuantity,\\\"\\n                \\\"uint32 signedClaimTicket,\\\"\\n                \\\"uint96 signedPrice,\\\"\\n                \\\"uint32 signedDeadline,\\\"\\n                \\\"address affiliate\\\"\\n            \\\")\\\"\\n        );\\n\\n    /**\\n     * @dev For EIP-712 platform airdrop signature digest calculation.\\n     */\\n    bytes32 public constant PLATFORM_AIRDROP_TYPEHASH =\\n        // prettier-ignore\\n        keccak256(\\n            \\\"PlatformAirdrop(\\\"\\n                \\\"address edition,\\\"\\n                \\\"uint8 tier,\\\"\\n                \\\"uint8 scheduleNum,\\\"\\n                \\\"address[] to,\\\"\\n                \\\"uint32 signedQuantity,\\\"\\n                \\\"uint32 signedClaimTicket,\\\"\\n                \\\"uint32 signedDeadline\\\"\\n            \\\")\\\"\\n        );\\n\\n    /**\\n     * @dev For EIP-712 signature digest calculation.\\n     */\\n    bytes32 public constant DOMAIN_TYPEHASH = _DOMAIN_TYPEHASH;\\n\\n    /**\\n     * @dev The default value for options.\\n     */\\n    uint8 public constant DEFAULT = 0;\\n\\n    /**\\n     * @dev The Merkle drop mint mode.\\n     */\\n    uint8 public constant VERIFY_MERKLE = 1;\\n\\n    /**\\n     * @dev The Signature mint mint mode.\\n     */\\n    uint8 public constant VERIFY_SIGNATURE = 2;\\n\\n    /**\\n     * @dev The platform airdrop mint mode.\\n     */\\n    uint8 public constant PLATFORM_AIRDROP = 3;\\n\\n    /**\\n     * @dev The denominator of all BPS calculations.\\n     */\\n    uint16 public constant BPS_DENOMINATOR = LibOps.BPS_DENOMINATOR;\\n\\n    /**\\n     * @dev The maximum affiliate fee BPS.\\n     */\\n    uint16 public constant MAX_AFFILIATE_FEE_BPS = 1000;\\n\\n    /**\\n     * @dev The maximum platform per-mint fee BPS.\\n     */\\n    uint16 public constant MAX_PLATFORM_PER_MINT_FEE_BPS = 1000;\\n\\n    /**\\n     * @dev The maximum per-mint reward. Applies to artists, affiliates, platform.\\n     */\\n    uint96 public constant MAX_PER_MINT_REWARD = 0.1 ether;\\n\\n    /**\\n     * @dev The maximum platform per-transaction flat fee.\\n     */\\n    uint96 public constant MAX_PLATFORM_PER_TX_FLAT_FEE = 0.1 ether;\\n\\n    /**\\n     * @dev The boolean flag on whether the mint has been created.\\n     */\\n    uint8 internal constant _MINT_CREATED_FLAG = 1 << 0;\\n\\n    /**\\n     * @dev The boolean flag on whether the mint is paused.\\n     */\\n    uint8 internal constant _MINT_PAUSED_FLAG = 1 << 1;\\n\\n    /**\\n     * @dev The boolean flag on whether the signer is the platform's signer.\\n     */\\n    uint8 internal constant _USE_PLATFORM_SIGNER_FLAG = 1 << 2;\\n\\n    /**\\n     * @dev The index for the per-platform default fee config.\\n     *      We use 256, as the tier is uint8, which ranges from 0 to 255.\\n     */\\n    uint16 internal constant _DEFAULT_FEE_CONFIG_INDEX = 256;\\n\\n    // =============================================================\\n    //                            STORAGE\\n    // =============================================================\\n\\n    /**\\n     * @dev A mapping of `platform` => `feesAccrued`.\\n     */\\n    mapping(address => uint256) public platformFeesAccrued;\\n\\n    /**\\n     * @dev A mapping of `platform` => `feeRecipient`.\\n     */\\n    mapping(address => address) public platformFeeAddress;\\n\\n    /**\\n     * @dev A mapping of `affiliate` => `feesAccrued`.\\n     */\\n    mapping(address => uint256) public affiliateFeesAccrued;\\n\\n    /**\\n     * @dev A mapping of `platform` => `price`.\\n     */\\n    mapping(address => uint96) public gaPrice;\\n\\n    /**\\n     * @dev A mapping of `platform` => `platformSigner`.\\n     */\\n    mapping(address => address) public platformSigner;\\n\\n    /**\\n     * @dev A mapping of `mintId` => `mintData`.\\n     */\\n    mapping(uint256 => MintData) internal _mintData;\\n\\n    /**\\n     * @dev A mapping of `platformTierId` => `platformFeeConfig`.\\n     */\\n    mapping(uint256 => PlatformFeeConfig) internal _platformFeeConfigs;\\n\\n    /**\\n     * @dev A mapping of `to` => `mintId` => `numberMinted`.\\n     */\\n    mapping(address => LibMap.Uint32Map) internal _numberMinted;\\n\\n    /**\\n     * @dev A mapping of `mintId` => `signedClaimedTicket` => `claimed`.\\n     */\\n    mapping(uint256 => LibBitmap.Bitmap) internal _claimsBitmaps;\\n\\n    // =============================================================\\n    //               PUBLIC / EXTERNAL WRITE FUNCTIONS\\n    // =============================================================\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function createEditionMint(MintCreation memory c) public returns (uint8 scheduleNum) {\\n        _requireOnlyEditionOwnerOrAdmin(c.edition);\\n\\n        _validateAffiliateFeeBPS(c.affiliateFeeBPS);\\n\\n        uint8 mode = c.mode;\\n\\n        if (mode == DEFAULT) {\\n            c.merkleRoot = bytes32(0);\\n        } else if (mode == VERIFY_MERKLE) {\\n            _validateMerkleRoot(c.merkleRoot);\\n        } else if (mode == VERIFY_SIGNATURE) {\\n            c.merkleRoot = bytes32(0);\\n            c.maxMintablePerAccount = type(uint32).max;\\n        } else if (mode == PLATFORM_AIRDROP) {\\n            c.merkleRoot = bytes32(0);\\n            c.maxMintablePerAccount = type(uint32).max;\\n            c.price = 0; // Platform airdrop mode doesn't have a price.\\n        } else {\\n            revert InvalidMode();\\n        }\\n\\n        // If GA, overwrite any immutable variables as required.\\n        if (c.tier == GA_TIER) {\\n            c.endTime = type(uint32).max;\\n            c.maxMintablePerAccount = type(uint32).max;\\n            // We allow the `price` to be the minimum price if the `mode` is `VERIFY_SIGNATURE`.\\n            // Otherwise, the actual default price is the live value of `gaPrice[platform]`,\\n            // and we'll simply set it to zero to avoid a SLOAD.\\n            if (mode != VERIFY_SIGNATURE) c.price = 0;\\n            // Set `maxMintable` to the maximum only if `mode` is `DEFAULT`.\\n            if (mode == DEFAULT) c.maxMintable = type(uint32).max;\\n        }\\n\\n        _validateTimeRange(c.startTime, c.endTime);\\n        _validateMaxMintablePerAccount(c.maxMintablePerAccount);\\n        _validateMaxMintable(c.maxMintable);\\n\\n        unchecked {\\n            MintData storage tierHead = _mintData[LibOps.packId(c.edition, c.tier, 0)];\\n            MintData storage editionHead = _mintData[LibOps.packId(c.edition, 0)];\\n\\n            scheduleNum = tierHead.nextScheduleNum;\\n            uint256 n = scheduleNum;\\n            if (++n >= 1 << 8) LibOps.revertOverflow();\\n            tierHead.nextScheduleNum = uint8(n);\\n\\n            n = editionHead.numMintData;\\n            if (++n >= 1 << 16) LibOps.revertOverflow();\\n            editionHead.numMintData = uint16(n);\\n\\n            uint256 mintId = LibOps.packId(c.edition, c.tier, scheduleNum);\\n\\n            MintData storage d = _mintData[mintId];\\n            d.platform = c.platform;\\n            d.price = c.price;\\n            d.startTime = c.startTime;\\n            d.endTime = c.endTime;\\n            d.maxMintablePerAccount = c.maxMintablePerAccount;\\n            d.maxMintable = c.maxMintable;\\n            d.affiliateFeeBPS = c.affiliateFeeBPS;\\n            d.mode = c.mode;\\n            d.flags = _MINT_CREATED_FLAG;\\n            d.next = editionHead.head;\\n            editionHead.head = uint16((uint256(c.tier) << 8) | uint256(scheduleNum));\\n\\n            // Skip writing zeros, to avoid cold SSTOREs.\\n            if (c.affiliateMerkleRoot != bytes32(0)) d.affiliateMerkleRoot = c.affiliateMerkleRoot;\\n            if (c.merkleRoot != bytes32(0)) d.merkleRoot = c.merkleRoot;\\n\\n            emit MintCreated(c.edition, c.tier, scheduleNum, c);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function mintTo(MintTo calldata p) public payable returns (uint256 fromTokenId) {\\n        MintData storage d = _getMintData(LibOps.packId(p.edition, p.tier, p.scheduleNum));\\n\\n        /* ------------------- CHECKS AND UPDATES ------------------- */\\n\\n        _requireMintOpen(d);\\n\\n        // Perform the sub workflows depending on the mint mode.\\n        uint8 mode = d.mode;\\n        if (mode == VERIFY_MERKLE) _verifyMerkle(d, p);\\n        else if (mode == VERIFY_SIGNATURE) _verifyAndClaimSignature(d, p);\\n        else if (mode == PLATFORM_AIRDROP) revert InvalidMode();\\n\\n        _incrementMinted(mode, d, p);\\n\\n        /* ----------------- COMPUTE AND ACCRUE FEES ---------------- */\\n\\n        MintedLogData memory l;\\n        // Blocking same address self referral is left curved, but we do anyway.\\n        l.affiliate = p.to == p.affiliate ? address(0) : p.affiliate;\\n        // Affiliate check.\\n        l.affiliated = _isAffiliatedWithProof(d, l.affiliate, p.affiliateProof);\\n\\n        TotalPriceAndFees memory f = _totalPriceAndFees(p.tier, d, p.quantity, p.signedPrice, l.affiliated);\\n\\n        if (msg.value != f.total) revert WrongPayment(msg.value, f.total); // Require exact payment.\\n\\n        l.finalArtistFee = f.finalArtistFee;\\n        l.finalPlatformFee = f.finalPlatformFee;\\n        l.finalAffiliateFee = f.finalAffiliateFee;\\n\\n        // Platform and affilaite fees are accrued mappings.\\n        // Artist earnings are directly forwarded to the nft contract in mint call below.\\n        // Overflow not possible since all fees are uint96s.\\n        unchecked {\\n            if (l.finalAffiliateFee != 0) {\\n                affiliateFeesAccrued[p.affiliate] += l.finalAffiliateFee;\\n            }\\n            if (l.finalPlatformFee != 0) {\\n                platformFeesAccrued[d.platform] += l.finalPlatformFee;\\n            }\\n        }\\n\\n        /* ------------------------- MINT --------------------------- */\\n\\n        ISoundEditionV2_1 edition = ISoundEditionV2_1(p.edition);\\n        l.quantity = p.quantity;\\n        l.fromTokenId = edition.mint{ value: l.finalArtistFee }(p.tier, p.to, p.quantity);\\n        l.allowlisted = p.allowlisted;\\n        l.allowlistedQuantity = p.allowlistedQuantity;\\n        l.signedClaimTicket = p.signedClaimTicket;\\n        l.requiredEtherValue = f.total;\\n        l.unitPrice = f.unitPrice;\\n\\n        emit Minted(p.edition, p.tier, p.scheduleNum, p.to, l, p.attributionId);\\n\\n        return l.fromTokenId;\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function platformAirdrop(PlatformAirdrop calldata p) public returns (uint256 fromTokenId) {\\n        MintData storage d = _getMintData(LibOps.packId(p.edition, p.tier, p.scheduleNum));\\n\\n        /* ------------------- CHECKS AND UPDATES ------------------- */\\n\\n        _requireMintOpen(d);\\n\\n        if (d.mode != PLATFORM_AIRDROP) revert InvalidMode();\\n        _verifyAndClaimPlatfromAidropSignature(d, p);\\n\\n        _incrementPlatformAirdropMinted(d, p);\\n\\n        /* ------------------------- MINT --------------------------- */\\n\\n        ISoundEditionV2_1 edition = ISoundEditionV2_1(p.edition);\\n        fromTokenId = edition.airdrop(p.tier, p.to, p.signedQuantity);\\n\\n        emit PlatformAirdropped(p.edition, p.tier, p.scheduleNum, p.to, p.signedQuantity, fromTokenId);\\n    }\\n\\n    // Per edition mint parameter setters:\\n    // -----------------------------------\\n    // These functions can only be called by the owner or admin of the edition.\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function setPrice(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        uint96 price\\n    ) public onlyEditionOwnerOrAdmin(edition) {\\n        uint256 mintId = LibOps.packId(edition, tier, scheduleNum);\\n        MintData storage d = _getMintData(mintId);\\n        // If the tier is GA and the `mode` is `VERIFY_SIGNATURE`, we'll use `gaPrice[platform]`.\\n        if (tier == GA_TIER && d.mode != VERIFY_SIGNATURE) revert NotConfigurable();\\n        // Platform airdropped mints will not have a price.\\n        if (d.mode == PLATFORM_AIRDROP) revert NotConfigurable();\\n        d.price = price;\\n        emit PriceSet(edition, tier, scheduleNum, price);\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function setPaused(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        bool paused\\n    ) public onlyEditionOwnerOrAdmin(edition) {\\n        uint256 mintId = LibOps.packId(edition, tier, scheduleNum);\\n        MintData storage d = _getMintData(mintId);\\n        d.flags = LibOps.setFlagTo(d.flags, _MINT_PAUSED_FLAG, paused);\\n        emit PausedSet(edition, tier, scheduleNum, paused);\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function setTimeRange(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        uint32 startTime,\\n        uint32 endTime\\n    ) public onlyEditionOwnerOrAdmin(edition) {\\n        uint256 mintId = LibOps.packId(edition, tier, scheduleNum);\\n        MintData storage d = _getMintData(mintId);\\n        // For GA tier, `endTime` will always be `type(uint32).max`.\\n        if (tier == GA_TIER && endTime != type(uint32).max) revert NotConfigurable();\\n        _validateTimeRange(startTime, endTime);\\n        d.startTime = startTime;\\n        d.endTime = endTime;\\n        emit TimeRangeSet(edition, tier, scheduleNum, startTime, endTime);\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function setStartTime(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        uint32 startTime\\n    ) public {\\n        uint256 mintId = LibOps.packId(edition, tier, scheduleNum);\\n        setTimeRange(edition, tier, scheduleNum, startTime, _mintData[mintId].endTime);\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function setAffiliateFee(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        uint16 bps\\n    ) public onlyEditionOwnerOrAdmin(edition) {\\n        uint256 mintId = LibOps.packId(edition, tier, scheduleNum);\\n        MintData storage d = _getMintData(mintId);\\n        _validateAffiliateFeeBPS(bps);\\n        d.affiliateFeeBPS = bps;\\n        emit AffiliateFeeSet(edition, tier, scheduleNum, bps);\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function setAffiliateMerkleRoot(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        bytes32 root\\n    ) public onlyEditionOwnerOrAdmin(edition) {\\n        uint256 mintId = LibOps.packId(edition, tier, scheduleNum);\\n        MintData storage d = _getMintData(mintId);\\n        d.affiliateMerkleRoot = root;\\n        emit AffiliateMerkleRootSet(edition, tier, scheduleNum, root);\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function setMaxMintablePerAccount(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        uint32 value\\n    ) public onlyEditionOwnerOrAdmin(edition) {\\n        uint256 mintId = LibOps.packId(edition, tier, scheduleNum);\\n        MintData storage d = _getMintData(mintId);\\n        // GA tier will have `type(uint32).max`.\\n        if (tier == GA_TIER) revert NotConfigurable();\\n        // Signature mints will have `type(uint32).max`.\\n        if (d.mode == VERIFY_SIGNATURE) revert NotConfigurable();\\n        // Platform airdrops will have `type(uint32).max`.\\n        if (d.mode == PLATFORM_AIRDROP) revert NotConfigurable();\\n        _validateMaxMintablePerAccount(value);\\n        d.maxMintablePerAccount = value;\\n        emit MaxMintablePerAccountSet(edition, tier, scheduleNum, value);\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function setMaxMintable(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        uint32 value\\n    ) public onlyEditionOwnerOrAdmin(edition) {\\n        uint256 mintId = LibOps.packId(edition, tier, scheduleNum);\\n        MintData storage d = _getMintData(mintId);\\n        // We allow edits for GA tier, if the `mode` is not `DEFAULT`.\\n        if (tier == GA_TIER && d.mode == DEFAULT) revert NotConfigurable();\\n        _validateMaxMintable(value);\\n        d.maxMintable = value;\\n        emit MaxMintableSet(edition, tier, scheduleNum, value);\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function setMerkleRoot(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        bytes32 merkleRoot\\n    ) public onlyEditionOwnerOrAdmin(edition) {\\n        uint256 mintId = LibOps.packId(edition, tier, scheduleNum);\\n        MintData storage d = _getMintData(mintId);\\n        if (d.mode != VERIFY_MERKLE) revert NotConfigurable();\\n        _validateMerkleRoot(merkleRoot);\\n        d.merkleRoot = merkleRoot;\\n        emit MerkleRootSet(edition, tier, scheduleNum, merkleRoot);\\n    }\\n\\n    // Withdrawal functions:\\n    // ---------------------\\n    // These functions can be called by anyone.\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function withdrawForAffiliate(address affiliate) public {\\n        uint256 accrued = affiliateFeesAccrued[affiliate];\\n        if (accrued != 0) {\\n            affiliateFeesAccrued[affiliate] = 0;\\n            SafeTransferLib.forceSafeTransferETH(affiliate, accrued);\\n            emit AffiliateFeesWithdrawn(affiliate, accrued);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function withdrawForPlatform(address platform) public {\\n        address recipient = platformFeeAddress[platform];\\n        _validatePlatformFeeAddress(recipient);\\n        uint256 accrued = platformFeesAccrued[platform];\\n        if (accrued != 0) {\\n            platformFeesAccrued[platform] = 0;\\n            SafeTransferLib.forceSafeTransferETH(recipient, accrued);\\n            emit PlatformFeesWithdrawn(platform, accrued);\\n        }\\n    }\\n\\n    // Platform fee functions:\\n    // -----------------------\\n    // These functions enable any caller to set their own platform fees.\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function setPlatformFeeAddress(address recipient) public {\\n        address sender = LibMulticaller.senderOrSigner();\\n        _validatePlatformFeeAddress(recipient);\\n        platformFeeAddress[sender] = recipient;\\n        emit PlatformFeeAddressSet(sender, recipient);\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function setPlatformFeeConfig(uint8 tier, PlatformFeeConfig memory c) public {\\n        address sender = LibMulticaller.senderOrSigner();\\n        _validatePlatformFeeConfig(c);\\n        _platformFeeConfigs[LibOps.packId(sender, tier)] = c;\\n        emit PlatformFeeConfigSet(sender, tier, c);\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function setDefaultPlatformFeeConfig(PlatformFeeConfig memory c) public {\\n        address sender = LibMulticaller.senderOrSigner();\\n        _validatePlatformFeeConfig(c);\\n        _platformFeeConfigs[LibOps.packId(sender, _DEFAULT_FEE_CONFIG_INDEX)] = c;\\n        emit DefaultPlatformFeeConfigSet(sender, c);\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function setGAPrice(uint96 price) public {\\n        address sender = LibMulticaller.senderOrSigner();\\n        gaPrice[sender] = price;\\n        emit GAPriceSet(sender, price);\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function setPlatformSigner(address signer) public {\\n        address sender = LibMulticaller.senderOrSigner();\\n        platformSigner[sender] = signer;\\n        emit PlatformSignerSet(sender, signer);\\n    }\\n\\n    // Misc functions:\\n    // ---------------\\n\\n    /**\\n     * @dev For calldata compression.\\n     */\\n    fallback() external payable {\\n        LibZip.cdFallback();\\n    }\\n\\n    /**\\n     * @dev For calldata compression.\\n     */\\n    receive() external payable {\\n        LibZip.cdFallback();\\n    }\\n\\n    // =============================================================\\n    //               PUBLIC / EXTERNAL VIEW FUNCTIONS\\n    // =============================================================\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function computeMintToDigest(MintTo calldata p) public view returns (bytes32) {\\n        // prettier-ignore\\n        return\\n            _hashTypedData(keccak256(abi.encode(\\n                MINT_TO_TYPEHASH,\\n                p.edition,\\n                p.tier, \\n                p.scheduleNum,\\n                p.to,\\n                p.signedQuantity,\\n                p.signedClaimTicket,\\n                p.signedPrice,\\n                p.signedDeadline,\\n                p.affiliate\\n            )));\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function computePlatformAirdropDigest(PlatformAirdrop calldata p) public view returns (bytes32) {\\n        // prettier-ignore\\n        return\\n            _hashTypedData(keccak256(abi.encode(\\n                PLATFORM_AIRDROP_TYPEHASH,\\n                p.edition,\\n                p.tier, \\n                p.scheduleNum,\\n                keccak256(abi.encodePacked(p.to)),\\n                p.signedQuantity,\\n                p.signedClaimTicket,\\n                p.signedDeadline\\n            )));\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function totalPriceAndFees(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        uint32 quantity,\\n        bool hasValidAffiliate\\n    ) public view returns (TotalPriceAndFees memory) {\\n        return totalPriceAndFeesWithSignedPrice(edition, tier, scheduleNum, quantity, 0, hasValidAffiliate);\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function totalPriceAndFeesWithSignedPrice(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        uint32 quantity,\\n        uint96 signedPrice,\\n        bool hasValidAffiliate\\n    ) public view returns (TotalPriceAndFees memory) {\\n        uint256 mintId = LibOps.packId(edition, tier, scheduleNum);\\n        return _totalPriceAndFees(tier, _getMintData(mintId), quantity, signedPrice, hasValidAffiliate);\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function nextScheduleNum(address edition, uint8 tier) public view returns (uint8) {\\n        return _mintData[LibOps.packId(edition, tier, 0)].nextScheduleNum;\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function numberMinted(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        address collector\\n    ) external view returns (uint32) {\\n        uint256 mintId = LibOps.packId(edition, tier, scheduleNum);\\n        return _numberMinted[collector].get(mintId);\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function isAffiliatedWithProof(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        address affiliate,\\n        bytes32[] calldata affiliateProof\\n    ) public view virtual returns (bool) {\\n        uint256 mintId = LibOps.packId(edition, tier, scheduleNum);\\n        return _isAffiliatedWithProof(_getMintData(mintId), affiliate, affiliateProof);\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function isAffiliated(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        address affiliate\\n    ) public view virtual returns (bool) {\\n        return isAffiliatedWithProof(edition, tier, scheduleNum, affiliate, MerkleProofLib.emptyProof());\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function checkClaimTickets(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        uint32[] calldata claimTickets\\n    ) public view returns (bool[] memory claimed) {\\n        uint256 mintId = LibOps.packId(edition, tier, scheduleNum);\\n        LibBitmap.Bitmap storage bitmap = _claimsBitmaps[mintId];\\n        claimed = new bool[](claimTickets.length);\\n        unchecked {\\n            for (uint256 i; i != claimTickets.length; i++) {\\n                claimed[i] = bitmap.get(claimTickets[i]);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function platformFeeConfig(address platform, uint8 tier) public view returns (PlatformFeeConfig memory) {\\n        return _platformFeeConfigs[LibOps.packId(platform, tier)];\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function defaultPlatformFeeConfig(address platform) public view returns (PlatformFeeConfig memory) {\\n        return _platformFeeConfigs[LibOps.packId(platform, _DEFAULT_FEE_CONFIG_INDEX)];\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function effectivePlatformFeeConfig(address platform, uint8 tier) public view returns (PlatformFeeConfig memory) {\\n        PlatformFeeConfig memory c = _platformFeeConfigs[LibOps.packId(platform, tier)];\\n        if (!c.active) c = _platformFeeConfigs[LibOps.packId(platform, _DEFAULT_FEE_CONFIG_INDEX)];\\n        if (!c.active) delete c; // Set all values to zero.\\n        return c;\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function mintInfoList(address edition) public view returns (MintInfo[] memory a) {\\n        unchecked {\\n            MintData storage editionHead = _mintData[LibOps.packId(edition, 0)];\\n            uint256 n = editionHead.numMintData; // Linked-list length.\\n            uint16 p = editionHead.head; // Current linked-list pointer.\\n            a = new MintInfo[](n);\\n            // Traverse the linked-list and fill the array in reverse.\\n            // Front: earliest added mint schedule. Back: latest added mint schedule.\\n            while (n != 0) {\\n                MintData storage d = _mintData[LibOps.packId(edition, p)];\\n                a[--n] = mintInfo(edition, uint8(p >> 8), uint8(p));\\n                p = d.next;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function mintInfo(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum\\n    ) public view returns (MintInfo memory info) {\\n        uint256 mintId = LibOps.packId(edition, tier, scheduleNum);\\n        MintData storage d = _getMintData(mintId);\\n        info.edition = edition;\\n        info.tier = tier;\\n        info.scheduleNum = scheduleNum;\\n        info.platform = d.platform;\\n        info.price = tier == GA_TIER && d.mode != VERIFY_SIGNATURE ? gaPrice[d.platform] : d.price;\\n        info.startTime = d.startTime;\\n        info.endTime = d.endTime;\\n        info.maxMintablePerAccount = d.maxMintablePerAccount;\\n        info.maxMintable = d.maxMintable;\\n        info.minted = d.minted;\\n        info.affiliateFeeBPS = d.affiliateFeeBPS;\\n        info.mode = d.mode;\\n        info.paused = _isPaused(d);\\n        info.affiliateMerkleRoot = d.affiliateMerkleRoot;\\n        info.merkleRoot = d.merkleRoot;\\n        info.signer = platformSigner[d.platform];\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function name() external pure returns (string memory name_) {\\n        (name_, ) = _domainNameAndVersion();\\n    }\\n\\n    /**\\n     * @inheritdoc ISuperMinterV2\\n     */\\n    function version() external pure returns (string memory version_) {\\n        (, version_) = _domainNameAndVersion();\\n    }\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            LibOps.or(interfaceId == type(ISuperMinterV2).interfaceId, interfaceId == this.supportsInterface.selector);\\n    }\\n\\n    // =============================================================\\n    //                  INTERNAL / PRIVATE HELPERS\\n    // =============================================================\\n\\n    // Validations:\\n    // ------------\\n\\n    /**\\n     * @dev Guards a function to make it callable only by the edition's owner or admin.\\n     * @param edition The edition address.\\n     */\\n    modifier onlyEditionOwnerOrAdmin(address edition) {\\n        _requireOnlyEditionOwnerOrAdmin(edition);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Requires that the caller is the owner or admin of `edition`.\\n     * @param edition The edition address.\\n     */\\n    function _requireOnlyEditionOwnerOrAdmin(address edition) internal view {\\n        address sender = LibMulticaller.senderOrSigner();\\n        if (sender != OwnableRoles(edition).owner())\\n            if (!OwnableRoles(edition).hasAnyRole(sender, LibOps.ADMIN_ROLE)) LibOps.revertUnauthorized();\\n    }\\n\\n    /**\\n     * @dev Validates that `startTime <= endTime`.\\n     * @param startTime  The start time of the mint.\\n     * @param endTime    The end time of the mint.\\n     */\\n    function _validateTimeRange(uint32 startTime, uint32 endTime) internal pure {\\n        if (startTime > endTime) revert InvalidTimeRange();\\n    }\\n\\n    /**\\n     * @dev Validates that the max mintable amount per account is not zero.\\n     * @param value The max mintable amount.\\n     */\\n    function _validateMaxMintablePerAccount(uint32 value) internal pure {\\n        if (value == 0) revert MaxMintablePerAccountIsZero();\\n    }\\n\\n    /**\\n     * @dev Validates that the max mintable per schedule.\\n     * @param value The max mintable amount.\\n     */\\n    function _validateMaxMintable(uint32 value) internal pure {\\n        if (value == 0) revert MaxMintableIsZero();\\n    }\\n\\n    /**\\n     * @dev Validates that the Merkle root is not empty.\\n     * @param merkleRoot The Merkle root.\\n     */\\n    function _validateMerkleRoot(bytes32 merkleRoot) internal pure {\\n        if (merkleRoot == bytes32(0)) revert MerkleRootIsEmpty();\\n    }\\n\\n    /**\\n     * @dev Validates that the affiliate fee BPS does not exceed the max threshold.\\n     * @param bps The affiliate fee BPS.\\n     */\\n    function _validateAffiliateFeeBPS(uint16 bps) internal pure {\\n        if (bps > MAX_AFFILIATE_FEE_BPS) revert InvalidAffiliateFeeBPS();\\n    }\\n\\n    /**\\n     * @dev Validates the platform fee configuration.\\n     * @param c The platform fee configuration.\\n     */\\n    function _validatePlatformFeeConfig(PlatformFeeConfig memory c) internal pure {\\n        if (\\n            LibOps.or(\\n                LibOps.or(\\n                    c.platformTxFlatFee > MAX_PLATFORM_PER_TX_FLAT_FEE,\\n                    c.platformMintFeeBPS > MAX_PLATFORM_PER_MINT_FEE_BPS\\n                ),\\n                LibOps.or(\\n                    c.artistMintReward > MAX_PER_MINT_REWARD,\\n                    c.affiliateMintReward > MAX_PER_MINT_REWARD,\\n                    c.platformMintReward > MAX_PER_MINT_REWARD\\n                ),\\n                LibOps.or(\\n                    c.thresholdArtistMintReward > MAX_PER_MINT_REWARD,\\n                    c.thresholdAffiliateMintReward > MAX_PER_MINT_REWARD,\\n                    c.thresholdPlatformMintReward > MAX_PER_MINT_REWARD\\n                )\\n            )\\n        ) revert InvalidPlatformFeeConfig();\\n    }\\n\\n    /**\\n     * @dev Validates that the platform fee address is not the zero address.\\n     * @param a The platform fee address.\\n     */\\n    function _validatePlatformFeeAddress(address a) internal pure {\\n        if (a == address(0)) revert PlatformFeeAddressIsZero();\\n    }\\n\\n    // EIP-712:\\n    // --------\\n\\n    /**\\n     * @dev Override for EIP-712.\\n     * @return name_    The EIP-712 name.\\n     * @return version_ The EIP-712 version.\\n     */\\n    function _domainNameAndVersion()\\n        internal\\n        pure\\n        virtual\\n        override\\n        returns (string memory name_, string memory version_)\\n    {\\n        name_ = \\\"SuperMinter\\\";\\n        version_ = \\\"1_1\\\";\\n    }\\n\\n    // Minting:\\n    // --------\\n\\n    /**\\n     * @dev Increments the number minted in the mint and the number minted by the collector.\\n     * @param mode The mint mode.\\n     * @param d    The mint data storage pointer.\\n     * @param p    The mint-to parameters.\\n     */\\n    function _incrementMinted(\\n        uint8 mode,\\n        MintData storage d,\\n        MintTo calldata p\\n    ) internal {\\n        unchecked {\\n            // Increment the number minted in the mint.\\n            uint256 n = uint256(d.minted) + uint256(p.quantity); // The next `minted`.\\n            if (n > d.maxMintable) revert ExceedsMintSupply();\\n            d.minted = uint32(n);\\n\\n            // Increment the number minted by the collector.\\n            uint256 mintId = LibOps.packId(p.edition, p.tier, p.scheduleNum);\\n            if (mode == VERIFY_MERKLE) {\\n                LibMap.Uint32Map storage m = _numberMinted[p.allowlisted];\\n                n = uint256(m.get(mintId)) + uint256(p.quantity);\\n                // Check that `n` does not exceed either the default limit,\\n                // or the limit in the Merkle leaf if a non-zero value is provided.\\n                if (LibOps.or(n > d.maxMintablePerAccount, n > p.allowlistedQuantity)) revert ExceedsMaxPerAccount();\\n                m.set(mintId, uint32(n));\\n            } else {\\n                LibMap.Uint32Map storage m = _numberMinted[p.to];\\n                n = uint256(m.get(mintId)) + uint256(p.quantity);\\n                if (n > d.maxMintablePerAccount) revert ExceedsMaxPerAccount();\\n                m.set(mintId, uint32(n));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Increments the number minted in the mint and the number minted by the collector.\\n     * @param d    The mint data storage pointer.\\n     * @param p    The platform airdrop parameters.\\n     */\\n    function _incrementPlatformAirdropMinted(MintData storage d, PlatformAirdrop calldata p) internal {\\n        unchecked {\\n            uint256 mintId = LibOps.packId(p.edition, p.tier, p.scheduleNum);\\n            uint256 toLength = p.to.length;\\n\\n            // Increment the number minted in the mint.\\n            uint256 n = uint256(d.minted) + toLength * uint256(p.signedQuantity); // The next `minted`.\\n            if (n > d.maxMintable) revert ExceedsMintSupply();\\n            d.minted = uint32(n);\\n\\n            // Increment the number minted by the collectors.\\n            for (uint256 i; i != toLength; ++i) {\\n                LibMap.Uint32Map storage m = _numberMinted[p.to[i]];\\n                m.set(mintId, uint32(uint256(m.get(mintId)) + uint256(p.signedQuantity)));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Requires that the mint is open and not paused.\\n     * @param d    The mint data storage pointer.\\n     */\\n    function _requireMintOpen(MintData storage d) internal view {\\n        if (LibOps.or(block.timestamp < d.startTime, block.timestamp > d.endTime))\\n            revert MintNotOpen(block.timestamp, d.startTime, d.endTime);\\n        if (_isPaused(d)) revert MintPaused(); // Check if the mint is not paused.\\n    }\\n\\n    /**\\n     * @dev Verify the signature, and mark the signed claim ticket as claimed.\\n     * @param d The mint data storage pointer.\\n     * @param p The mint-to parameters.\\n     */\\n    function _verifyAndClaimSignature(MintData storage d, MintTo calldata p) internal {\\n        if (p.quantity > p.signedQuantity) revert ExceedsSignedQuantity();\\n        address signer = platformSigner[d.platform];\\n        if (!SignatureCheckerLib.isValidSignatureNowCalldata(signer, computeMintToDigest(p), p.signature))\\n            revert InvalidSignature();\\n        if (block.timestamp > p.signedDeadline) revert SignatureExpired();\\n        uint256 mintId = LibOps.packId(p.edition, p.tier, p.scheduleNum);\\n        if (!_claimsBitmaps[mintId].toggle(p.signedClaimTicket)) revert SignatureAlreadyUsed();\\n    }\\n\\n    /**\\n     * @dev Verify the platform airdrop signature, and mark the signed claim ticket as claimed.\\n     * @param d The mint data storage pointer.\\n     * @param p The platform airdrop parameters.\\n     */\\n    function _verifyAndClaimPlatfromAidropSignature(MintData storage d, PlatformAirdrop calldata p) internal {\\n        // Unlike regular signature mints, platform airdrops only use `signedQuantity`.\\n        address signer = platformSigner[d.platform];\\n        if (!SignatureCheckerLib.isValidSignatureNowCalldata(signer, computePlatformAirdropDigest(p), p.signature))\\n            revert InvalidSignature();\\n        if (block.timestamp > p.signedDeadline) revert SignatureExpired();\\n        uint256 mintId = LibOps.packId(p.edition, p.tier, p.scheduleNum);\\n        if (!_claimsBitmaps[mintId].toggle(p.signedClaimTicket)) revert SignatureAlreadyUsed();\\n    }\\n\\n    /**\\n     * @dev Verify the Merkle proof.\\n     * @param d The mint data storage pointer.\\n     * @param p The mint-to parameters.\\n     */\\n    function _verifyMerkle(MintData storage d, MintTo calldata p) internal view {\\n        uint32 allowlistedQuantity = p.allowlistedQuantity;\\n        address allowlisted = p.allowlisted;\\n        // Revert if `allowlisted` is the zero address to prevent libraries\\n        // that fill up partial Merkle trees with empty leafs from screwing things up.\\n        if (allowlisted == address(0)) revert InvalidMerkleProof();\\n        // If `allowlistedQuantity` is the max limit, we've got to check two cases for backwards compatibility.\\n        if (allowlistedQuantity == type(uint32).max) {\\n            // Revert if neither `keccak256(abi.encodePacked(allowlisted))` nor\\n            // `keccak256(abi.encodePacked(allowlisted, uint32(0)))` are in the Merkle tree.\\n            if (\\n                !p.allowlistProof.verifyCalldata(d.merkleRoot, _leaf(allowlisted)) &&\\n                !p.allowlistProof.verifyCalldata(d.merkleRoot, _leaf(allowlisted, type(uint32).max))\\n            ) revert InvalidMerkleProof();\\n        } else {\\n            // Revert if `keccak256(abi.encodePacked(allowlisted, uint32(allowlistedQuantity)))`\\n            // is not in the Merkle tree.\\n            if (!p.allowlistProof.verifyCalldata(d.merkleRoot, _leaf(allowlisted, allowlistedQuantity)))\\n                revert InvalidMerkleProof();\\n        }\\n        // To mint, either the sender or `to` must be equal to `allowlisted`,\\n        address sender = LibMulticaller.senderOrSigner();\\n        if (!LibOps.or(sender == allowlisted, p.to == allowlisted)) {\\n            // or the sender must be a delegate of `allowlisted`.\\n            if (!DelegateCashLib.checkDelegateForAll(sender, allowlisted)) revert CallerNotDelegated();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total price and fees for the mint.\\n     * @param tier        The tier.\\n     * @param d           The mint data storage pointer.\\n     * @param quantity    How many tokens to mint.\\n     * @param signedPrice The signed price. Only for `VERIFY_SIGNATURE`.\\n     * @return f A struct containing the total price and fees.\\n     */\\n    function _totalPriceAndFees(\\n        uint8 tier,\\n        MintData storage d,\\n        uint32 quantity,\\n        uint96 signedPrice,\\n        bool hasValidAffiliate\\n    ) internal view returns (TotalPriceAndFees memory f) {\\n        // All flat prices are stored as uint96s in storage.\\n        // The quantity is a uint32. Multiplications between a uint96 and uint32 won't overflow.\\n        unchecked {\\n            PlatformFeeConfig memory c = effectivePlatformFeeConfig(d.platform, tier);\\n\\n            // For signature mints, even if it is GA tier, we will use the signed price.\\n            if (d.mode == VERIFY_SIGNATURE) {\\n                if (signedPrice < d.price) revert SignedPriceTooLow(); // Enforce the price floor.\\n                f.unitPrice = signedPrice;\\n            } else if (tier == GA_TIER) {\\n                f.unitPrice = gaPrice[d.platform]; // Else if GA tier, use `gaPrice[platform]`.\\n            } else {\\n                f.unitPrice = d.price; // Else, use the `price`.\\n            }\\n\\n            // The total price before any additive fees.\\n            f.subTotal = f.unitPrice * uint256(quantity);\\n\\n            // Artist earns `subTotal` minus any basis points (BPS) split with affiliates and platform\\n            f.finalArtistFee = f.subTotal;\\n\\n            // `affiliateBPSFee` is deducted from the `finalArtistFee`.\\n            if (d.affiliateFeeBPS != 0 && hasValidAffiliate) {\\n                uint256 affiliateBPSFee = LibOps.rawMulDiv(f.subTotal, d.affiliateFeeBPS, BPS_DENOMINATOR);\\n                f.finalArtistFee -= affiliateBPSFee;\\n                f.finalAffiliateFee = affiliateBPSFee;\\n            }\\n            // `platformBPSFee` is deducted from the `finalArtistFee`.\\n            if (c.platformMintFeeBPS != 0) {\\n                uint256 platformBPSFee = LibOps.rawMulDiv(f.subTotal, c.platformMintFeeBPS, BPS_DENOMINATOR);\\n                f.finalArtistFee -= platformBPSFee;\\n                f.finalPlatformFee = platformBPSFee;\\n            }\\n\\n            // Protocol rewards are additive to `unitPrice` and paid by the buyer.\\n            // There are 2 sets of rewards, one for prices below `thresholdPrice` and one for prices above.\\n            if (f.unitPrice <= c.thresholdPrice) {\\n                f.finalArtistFee += c.artistMintReward * uint256(quantity);\\n                f.finalPlatformFee += c.platformMintReward * uint256(quantity);\\n\\n                // The platform is the affiliate if no affiliate is provided.\\n                if (hasValidAffiliate) {\\n                    f.finalAffiliateFee += c.affiliateMintReward * uint256(quantity);\\n                } else {\\n                    f.finalPlatformFee += c.affiliateMintReward * uint256(quantity);\\n                }\\n            } else {\\n                f.finalArtistFee += c.thresholdArtistMintReward * uint256(quantity);\\n                f.finalPlatformFee += c.thresholdPlatformMintReward * uint256(quantity);\\n\\n                // The platform is the affiliate if no affiliate is provided\\n                if (hasValidAffiliate) {\\n                    f.finalAffiliateFee += c.thresholdAffiliateMintReward * uint256(quantity);\\n                } else {\\n                    f.finalPlatformFee += c.thresholdAffiliateMintReward * uint256(quantity);\\n                }\\n            }\\n\\n            // Per-transaction flat fee.\\n            f.finalPlatformFee += c.platformTxFlatFee;\\n\\n            // The total is the final value which the minter has to pay. It includes all fees.\\n            f.total = f.finalArtistFee + f.finalAffiliateFee + f.finalPlatformFee;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether the affiliate is affiliated for the mint\\n     * @param d              The mint data storage pointer.\\n     * @param affiliate      The affiliate address.\\n     * @param affiliateProof The Merkle proof for the affiliate.\\n     * @return The result.\\n     */\\n    function _isAffiliatedWithProof(\\n        MintData storage d,\\n        address affiliate,\\n        bytes32[] calldata affiliateProof\\n    ) internal view virtual returns (bool) {\\n        bytes32 root = d.affiliateMerkleRoot;\\n        // If the root is empty, then use the default logic.\\n        if (root == bytes32(0)) return affiliate != address(0);\\n        // Otherwise, check if the affiliate is in the Merkle tree.\\n        // The check that that affiliate is not a zero address is to prevent libraries\\n        // that fill up partial Merkle trees with empty leafs from screwing things up.\\n        return LibOps.and(affiliate != address(0), affiliateProof.verifyCalldata(root, _leaf(affiliate)));\\n    }\\n\\n    // Utilities:\\n    // ----------\\n\\n    /**\\n     * @dev Equivalent to `keccak256(abi.encodePacked(allowlisted))`.\\n     * @param allowlisted The allowlisted address.\\n     * @return result The leaf in the Merkle tree.\\n     */\\n    function _leaf(address allowlisted) internal pure returns (bytes32 result) {\\n        assembly {\\n            mstore(0x00, allowlisted)\\n            result := keccak256(0x0c, 0x14)\\n        }\\n    }\\n\\n    /**\\n     * @dev Equivalent to `keccak256(abi.encodePacked(allowlisted, allowlistedQuantity))`.\\n     * @param allowlisted         The allowlisted address.\\n     * @param allowlistedQuantity Number of mints allowlisted.\\n     * @return result The leaf in the Merkle tree.\\n     */\\n    function _leaf(address allowlisted, uint32 allowlistedQuantity) internal pure returns (bytes32 result) {\\n        assembly {\\n            mstore(0x04, allowlistedQuantity)\\n            mstore(0x00, allowlisted)\\n            result := keccak256(0x0c, 0x18)\\n        }\\n    }\\n\\n    /**\\n     * @dev Retrieves the mint data from storage, reverting if the mint does not exist.\\n     * @param mintId The mint ID.\\n     * @return d The storage pointer to the mint data.\\n     */\\n    function _getMintData(uint256 mintId) internal view returns (MintData storage d) {\\n        d = _mintData[mintId];\\n        if (d.flags & _MINT_CREATED_FLAG == 0) revert MintDoesNotExist();\\n    }\\n\\n    /**\\n     * @dev Returns whether the mint is paused.\\n     * @param d The storage pointer to the mint data.\\n     * @return Whether the mint is paused.\\n     */\\n    function _isPaused(MintData storage d) internal view returns (bool) {\\n        return d.flags & _MINT_PAUSED_FLAG != 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/auth/OwnableRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {Ownable} from \\\"./Ownable.sol\\\";\\n\\n/// @notice Simple single owner and multiroles authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n/// @dev While the ownable portion follows [EIP-173](https://eips.ethereum.org/EIPS/eip-173)\\n/// for compatibility, the nomenclature for the 2-step ownership handover and roles\\n/// may be unique to this codebase.\\nabstract contract OwnableRoles is Ownable {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The `user`'s roles is updated to `roles`.\\n    /// Each bit of `roles` represents whether the role is set.\\n    event RolesUpdated(address indexed user, uint256 indexed roles);\\n\\n    /// @dev `keccak256(bytes(\\\"RolesUpdated(address,uint256)\\\"))`.\\n    uint256 private constant _ROLES_UPDATED_EVENT_SIGNATURE =\\n        0x715ad5ce61fc9595c7b415289d59cf203f23a94fa06f04af7e489a0a76e1fe26;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The role slot of `user` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _ROLE_SLOT_SEED))\\n    ///     let roleSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// This automatically ignores the upper bits of the `user` in case\\n    /// they are not clean, as well as keep the `keccak256` under 32-bytes.\\n    ///\\n    /// Note: This is equivalent to `uint32(bytes4(keccak256(\\\"_OWNER_SLOT_NOT\\\")))`.\\n    uint256 private constant _ROLE_SLOT_SEED = 0x8b78c6d8;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Overwrite the roles directly without authorization guard.\\n    function _setRoles(address user, uint256 roles) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x0c, _ROLE_SLOT_SEED)\\n            mstore(0x00, user)\\n            // Store the new value.\\n            sstore(keccak256(0x0c, 0x20), roles)\\n            // Emit the {RolesUpdated} event.\\n            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, mload(0x0c)), roles)\\n        }\\n    }\\n\\n    /// @dev Updates the roles directly without authorization guard.\\n    /// If `on` is true, each set bit of `roles` will be turned on,\\n    /// otherwise, each set bit of `roles` will be turned off.\\n    function _updateRoles(address user, uint256 roles, bool on) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x0c, _ROLE_SLOT_SEED)\\n            mstore(0x00, user)\\n            let roleSlot := keccak256(0x0c, 0x20)\\n            // Load the current value.\\n            let current := sload(roleSlot)\\n            // Compute the updated roles if `on` is true.\\n            let updated := or(current, roles)\\n            // Compute the updated roles if `on` is false.\\n            // Use `and` to compute the intersection of `current` and `roles`,\\n            // `xor` it with `current` to flip the bits in the intersection.\\n            if iszero(on) { updated := xor(current, and(current, roles)) }\\n            // Then, store the new value.\\n            sstore(roleSlot, updated)\\n            // Emit the {RolesUpdated} event.\\n            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, mload(0x0c)), updated)\\n        }\\n    }\\n\\n    /// @dev Grants the roles directly without authorization guard.\\n    /// Each bit of `roles` represents the role to turn on.\\n    function _grantRoles(address user, uint256 roles) internal virtual {\\n        _updateRoles(user, roles, true);\\n    }\\n\\n    /// @dev Removes the roles directly without authorization guard.\\n    /// Each bit of `roles` represents the role to turn off.\\n    function _removeRoles(address user, uint256 roles) internal virtual {\\n        _updateRoles(user, roles, false);\\n    }\\n\\n    /// @dev Throws if the sender does not have any of the `roles`.\\n    function _checkRoles(uint256 roles) internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the role slot.\\n            mstore(0x0c, _ROLE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            // Load the stored value, and if the `and` intersection\\n            // of the value and `roles` is zero, revert.\\n            if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Throws if the sender is not the owner,\\n    /// and does not have any of the `roles`.\\n    /// Checks for ownership first, then lazily checks for roles.\\n    function _checkOwnerOrRoles(uint256 roles) internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the caller is not the stored owner.\\n            // Note: `_ROLE_SLOT_SEED` is equal to `_OWNER_SLOT_NOT`.\\n            if iszero(eq(caller(), sload(not(_ROLE_SLOT_SEED)))) {\\n                // Compute the role slot.\\n                mstore(0x0c, _ROLE_SLOT_SEED)\\n                mstore(0x00, caller())\\n                // Load the stored value, and if the `and` intersection\\n                // of the value and `roles` is zero, revert.\\n                if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {\\n                    mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Throws if the sender does not have any of the `roles`,\\n    /// and is not the owner.\\n    /// Checks for roles first, then lazily checks for ownership.\\n    function _checkRolesOrOwner(uint256 roles) internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the role slot.\\n            mstore(0x0c, _ROLE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            // Load the stored value, and if the `and` intersection\\n            // of the value and `roles` is zero, revert.\\n            if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {\\n                // If the caller is not the stored owner.\\n                // Note: `_ROLE_SLOT_SEED` is equal to `_OWNER_SLOT_NOT`.\\n                if iszero(eq(caller(), sload(not(_ROLE_SLOT_SEED)))) {\\n                    mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Convenience function to return a `roles` bitmap from an array of `ordinals`.\\n    /// This is meant for frontends like Etherscan, and is therefore not fully optimized.\\n    /// Not recommended to be called on-chain.\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n    function _rolesFromOrdinals(uint8[] memory ordinals) internal pure returns (uint256 roles) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let i := shl(5, mload(ordinals)) } i { i := sub(i, 0x20) } {\\n                // We don't need to mask the values of `ordinals`, as Solidity\\n                // cleans dirty upper bits when storing variables into memory.\\n                roles := or(shl(mload(add(ordinals, i)), 1), roles)\\n            }\\n        }\\n    }\\n\\n    /// @dev Convenience function to return an array of `ordinals` from the `roles` bitmap.\\n    /// This is meant for frontends like Etherscan, and is therefore not fully optimized.\\n    /// Not recommended to be called on-chain.\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n    function _ordinalsFromRoles(uint256 roles) internal pure returns (uint8[] memory ordinals) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the pointer to the free memory.\\n            ordinals := mload(0x40)\\n            let ptr := add(ordinals, 0x20)\\n            let o := 0\\n            // The absence of lookup tables, De Bruijn, etc., here is intentional for\\n            // smaller bytecode, as this function is not meant to be called on-chain.\\n            for { let t := roles } 1 {} {\\n                mstore(ptr, o)\\n                // `shr` 5 is equivalent to multiplying by 0x20.\\n                // Push back into the ordinals array if the bit is set.\\n                ptr := add(ptr, shl(5, and(t, 1)))\\n                o := add(o, 1)\\n                t := shr(o, roles)\\n                if iszero(t) { break }\\n            }\\n            // Store the length of `ordinals`.\\n            mstore(ordinals, shr(5, sub(ptr, add(ordinals, 0x20))))\\n            // Allocate the memory.\\n            mstore(0x40, ptr)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Allows the owner to grant `user` `roles`.\\n    /// If the `user` already has a role, then it will be an no-op for the role.\\n    function grantRoles(address user, uint256 roles) public payable virtual onlyOwner {\\n        _grantRoles(user, roles);\\n    }\\n\\n    /// @dev Allows the owner to remove `user` `roles`.\\n    /// If the `user` does not have a role, then it will be an no-op for the role.\\n    function revokeRoles(address user, uint256 roles) public payable virtual onlyOwner {\\n        _removeRoles(user, roles);\\n    }\\n\\n    /// @dev Allow the caller to remove their own roles.\\n    /// If the caller does not have a role, then it will be an no-op for the role.\\n    function renounceRoles(uint256 roles) public payable virtual {\\n        _removeRoles(msg.sender, roles);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the roles of `user`.\\n    function rolesOf(address user) public view virtual returns (uint256 roles) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the role slot.\\n            mstore(0x0c, _ROLE_SLOT_SEED)\\n            mstore(0x00, user)\\n            // Load the stored value.\\n            roles := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Returns whether `user` has any of `roles`.\\n    function hasAnyRole(address user, uint256 roles) public view virtual returns (bool) {\\n        return rolesOf(user) & roles != 0;\\n    }\\n\\n    /// @dev Returns whether `user` has all of `roles`.\\n    function hasAllRoles(address user, uint256 roles) public view virtual returns (bool) {\\n        return rolesOf(user) & roles == roles;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Marks a function as only callable by an account with `roles`.\\n    modifier onlyRoles(uint256 roles) virtual {\\n        _checkRoles(roles);\\n        _;\\n    }\\n\\n    /// @dev Marks a function as only callable by the owner or by an account\\n    /// with `roles`. Checks for ownership first, then lazily checks for roles.\\n    modifier onlyOwnerOrRoles(uint256 roles) virtual {\\n        _checkOwnerOrRoles(roles);\\n        _;\\n    }\\n\\n    /// @dev Marks a function as only callable by an account with `roles`\\n    /// or the owner. Checks for roles first, then lazily checks for ownership.\\n    modifier onlyRolesOrOwner(uint256 roles) virtual {\\n        _checkRolesOrOwner(roles);\\n        _;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ROLE CONSTANTS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // IYKYK\\n\\n    uint256 internal constant _ROLE_0 = 1 << 0;\\n    uint256 internal constant _ROLE_1 = 1 << 1;\\n    uint256 internal constant _ROLE_2 = 1 << 2;\\n    uint256 internal constant _ROLE_3 = 1 << 3;\\n    uint256 internal constant _ROLE_4 = 1 << 4;\\n    uint256 internal constant _ROLE_5 = 1 << 5;\\n    uint256 internal constant _ROLE_6 = 1 << 6;\\n    uint256 internal constant _ROLE_7 = 1 << 7;\\n    uint256 internal constant _ROLE_8 = 1 << 8;\\n    uint256 internal constant _ROLE_9 = 1 << 9;\\n    uint256 internal constant _ROLE_10 = 1 << 10;\\n    uint256 internal constant _ROLE_11 = 1 << 11;\\n    uint256 internal constant _ROLE_12 = 1 << 12;\\n    uint256 internal constant _ROLE_13 = 1 << 13;\\n    uint256 internal constant _ROLE_14 = 1 << 14;\\n    uint256 internal constant _ROLE_15 = 1 << 15;\\n    uint256 internal constant _ROLE_16 = 1 << 16;\\n    uint256 internal constant _ROLE_17 = 1 << 17;\\n    uint256 internal constant _ROLE_18 = 1 << 18;\\n    uint256 internal constant _ROLE_19 = 1 << 19;\\n    uint256 internal constant _ROLE_20 = 1 << 20;\\n    uint256 internal constant _ROLE_21 = 1 << 21;\\n    uint256 internal constant _ROLE_22 = 1 << 22;\\n    uint256 internal constant _ROLE_23 = 1 << 23;\\n    uint256 internal constant _ROLE_24 = 1 << 24;\\n    uint256 internal constant _ROLE_25 = 1 << 25;\\n    uint256 internal constant _ROLE_26 = 1 << 26;\\n    uint256 internal constant _ROLE_27 = 1 << 27;\\n    uint256 internal constant _ROLE_28 = 1 << 28;\\n    uint256 internal constant _ROLE_29 = 1 << 29;\\n    uint256 internal constant _ROLE_30 = 1 << 30;\\n    uint256 internal constant _ROLE_31 = 1 << 31;\\n    uint256 internal constant _ROLE_32 = 1 << 32;\\n    uint256 internal constant _ROLE_33 = 1 << 33;\\n    uint256 internal constant _ROLE_34 = 1 << 34;\\n    uint256 internal constant _ROLE_35 = 1 << 35;\\n    uint256 internal constant _ROLE_36 = 1 << 36;\\n    uint256 internal constant _ROLE_37 = 1 << 37;\\n    uint256 internal constant _ROLE_38 = 1 << 38;\\n    uint256 internal constant _ROLE_39 = 1 << 39;\\n    uint256 internal constant _ROLE_40 = 1 << 40;\\n    uint256 internal constant _ROLE_41 = 1 << 41;\\n    uint256 internal constant _ROLE_42 = 1 << 42;\\n    uint256 internal constant _ROLE_43 = 1 << 43;\\n    uint256 internal constant _ROLE_44 = 1 << 44;\\n    uint256 internal constant _ROLE_45 = 1 << 45;\\n    uint256 internal constant _ROLE_46 = 1 << 46;\\n    uint256 internal constant _ROLE_47 = 1 << 47;\\n    uint256 internal constant _ROLE_48 = 1 << 48;\\n    uint256 internal constant _ROLE_49 = 1 << 49;\\n    uint256 internal constant _ROLE_50 = 1 << 50;\\n    uint256 internal constant _ROLE_51 = 1 << 51;\\n    uint256 internal constant _ROLE_52 = 1 << 52;\\n    uint256 internal constant _ROLE_53 = 1 << 53;\\n    uint256 internal constant _ROLE_54 = 1 << 54;\\n    uint256 internal constant _ROLE_55 = 1 << 55;\\n    uint256 internal constant _ROLE_56 = 1 << 56;\\n    uint256 internal constant _ROLE_57 = 1 << 57;\\n    uint256 internal constant _ROLE_58 = 1 << 58;\\n    uint256 internal constant _ROLE_59 = 1 << 59;\\n    uint256 internal constant _ROLE_60 = 1 << 60;\\n    uint256 internal constant _ROLE_61 = 1 << 61;\\n    uint256 internal constant _ROLE_62 = 1 << 62;\\n    uint256 internal constant _ROLE_63 = 1 << 63;\\n    uint256 internal constant _ROLE_64 = 1 << 64;\\n    uint256 internal constant _ROLE_65 = 1 << 65;\\n    uint256 internal constant _ROLE_66 = 1 << 66;\\n    uint256 internal constant _ROLE_67 = 1 << 67;\\n    uint256 internal constant _ROLE_68 = 1 << 68;\\n    uint256 internal constant _ROLE_69 = 1 << 69;\\n    uint256 internal constant _ROLE_70 = 1 << 70;\\n    uint256 internal constant _ROLE_71 = 1 << 71;\\n    uint256 internal constant _ROLE_72 = 1 << 72;\\n    uint256 internal constant _ROLE_73 = 1 << 73;\\n    uint256 internal constant _ROLE_74 = 1 << 74;\\n    uint256 internal constant _ROLE_75 = 1 << 75;\\n    uint256 internal constant _ROLE_76 = 1 << 76;\\n    uint256 internal constant _ROLE_77 = 1 << 77;\\n    uint256 internal constant _ROLE_78 = 1 << 78;\\n    uint256 internal constant _ROLE_79 = 1 << 79;\\n    uint256 internal constant _ROLE_80 = 1 << 80;\\n    uint256 internal constant _ROLE_81 = 1 << 81;\\n    uint256 internal constant _ROLE_82 = 1 << 82;\\n    uint256 internal constant _ROLE_83 = 1 << 83;\\n    uint256 internal constant _ROLE_84 = 1 << 84;\\n    uint256 internal constant _ROLE_85 = 1 << 85;\\n    uint256 internal constant _ROLE_86 = 1 << 86;\\n    uint256 internal constant _ROLE_87 = 1 << 87;\\n    uint256 internal constant _ROLE_88 = 1 << 88;\\n    uint256 internal constant _ROLE_89 = 1 << 89;\\n    uint256 internal constant _ROLE_90 = 1 << 90;\\n    uint256 internal constant _ROLE_91 = 1 << 91;\\n    uint256 internal constant _ROLE_92 = 1 << 92;\\n    uint256 internal constant _ROLE_93 = 1 << 93;\\n    uint256 internal constant _ROLE_94 = 1 << 94;\\n    uint256 internal constant _ROLE_95 = 1 << 95;\\n    uint256 internal constant _ROLE_96 = 1 << 96;\\n    uint256 internal constant _ROLE_97 = 1 << 97;\\n    uint256 internal constant _ROLE_98 = 1 << 98;\\n    uint256 internal constant _ROLE_99 = 1 << 99;\\n    uint256 internal constant _ROLE_100 = 1 << 100;\\n    uint256 internal constant _ROLE_101 = 1 << 101;\\n    uint256 internal constant _ROLE_102 = 1 << 102;\\n    uint256 internal constant _ROLE_103 = 1 << 103;\\n    uint256 internal constant _ROLE_104 = 1 << 104;\\n    uint256 internal constant _ROLE_105 = 1 << 105;\\n    uint256 internal constant _ROLE_106 = 1 << 106;\\n    uint256 internal constant _ROLE_107 = 1 << 107;\\n    uint256 internal constant _ROLE_108 = 1 << 108;\\n    uint256 internal constant _ROLE_109 = 1 << 109;\\n    uint256 internal constant _ROLE_110 = 1 << 110;\\n    uint256 internal constant _ROLE_111 = 1 << 111;\\n    uint256 internal constant _ROLE_112 = 1 << 112;\\n    uint256 internal constant _ROLE_113 = 1 << 113;\\n    uint256 internal constant _ROLE_114 = 1 << 114;\\n    uint256 internal constant _ROLE_115 = 1 << 115;\\n    uint256 internal constant _ROLE_116 = 1 << 116;\\n    uint256 internal constant _ROLE_117 = 1 << 117;\\n    uint256 internal constant _ROLE_118 = 1 << 118;\\n    uint256 internal constant _ROLE_119 = 1 << 119;\\n    uint256 internal constant _ROLE_120 = 1 << 120;\\n    uint256 internal constant _ROLE_121 = 1 << 121;\\n    uint256 internal constant _ROLE_122 = 1 << 122;\\n    uint256 internal constant _ROLE_123 = 1 << 123;\\n    uint256 internal constant _ROLE_124 = 1 << 124;\\n    uint256 internal constant _ROLE_125 = 1 << 125;\\n    uint256 internal constant _ROLE_126 = 1 << 126;\\n    uint256 internal constant _ROLE_127 = 1 << 127;\\n    uint256 internal constant _ROLE_128 = 1 << 128;\\n    uint256 internal constant _ROLE_129 = 1 << 129;\\n    uint256 internal constant _ROLE_130 = 1 << 130;\\n    uint256 internal constant _ROLE_131 = 1 << 131;\\n    uint256 internal constant _ROLE_132 = 1 << 132;\\n    uint256 internal constant _ROLE_133 = 1 << 133;\\n    uint256 internal constant _ROLE_134 = 1 << 134;\\n    uint256 internal constant _ROLE_135 = 1 << 135;\\n    uint256 internal constant _ROLE_136 = 1 << 136;\\n    uint256 internal constant _ROLE_137 = 1 << 137;\\n    uint256 internal constant _ROLE_138 = 1 << 138;\\n    uint256 internal constant _ROLE_139 = 1 << 139;\\n    uint256 internal constant _ROLE_140 = 1 << 140;\\n    uint256 internal constant _ROLE_141 = 1 << 141;\\n    uint256 internal constant _ROLE_142 = 1 << 142;\\n    uint256 internal constant _ROLE_143 = 1 << 143;\\n    uint256 internal constant _ROLE_144 = 1 << 144;\\n    uint256 internal constant _ROLE_145 = 1 << 145;\\n    uint256 internal constant _ROLE_146 = 1 << 146;\\n    uint256 internal constant _ROLE_147 = 1 << 147;\\n    uint256 internal constant _ROLE_148 = 1 << 148;\\n    uint256 internal constant _ROLE_149 = 1 << 149;\\n    uint256 internal constant _ROLE_150 = 1 << 150;\\n    uint256 internal constant _ROLE_151 = 1 << 151;\\n    uint256 internal constant _ROLE_152 = 1 << 152;\\n    uint256 internal constant _ROLE_153 = 1 << 153;\\n    uint256 internal constant _ROLE_154 = 1 << 154;\\n    uint256 internal constant _ROLE_155 = 1 << 155;\\n    uint256 internal constant _ROLE_156 = 1 << 156;\\n    uint256 internal constant _ROLE_157 = 1 << 157;\\n    uint256 internal constant _ROLE_158 = 1 << 158;\\n    uint256 internal constant _ROLE_159 = 1 << 159;\\n    uint256 internal constant _ROLE_160 = 1 << 160;\\n    uint256 internal constant _ROLE_161 = 1 << 161;\\n    uint256 internal constant _ROLE_162 = 1 << 162;\\n    uint256 internal constant _ROLE_163 = 1 << 163;\\n    uint256 internal constant _ROLE_164 = 1 << 164;\\n    uint256 internal constant _ROLE_165 = 1 << 165;\\n    uint256 internal constant _ROLE_166 = 1 << 166;\\n    uint256 internal constant _ROLE_167 = 1 << 167;\\n    uint256 internal constant _ROLE_168 = 1 << 168;\\n    uint256 internal constant _ROLE_169 = 1 << 169;\\n    uint256 internal constant _ROLE_170 = 1 << 170;\\n    uint256 internal constant _ROLE_171 = 1 << 171;\\n    uint256 internal constant _ROLE_172 = 1 << 172;\\n    uint256 internal constant _ROLE_173 = 1 << 173;\\n    uint256 internal constant _ROLE_174 = 1 << 174;\\n    uint256 internal constant _ROLE_175 = 1 << 175;\\n    uint256 internal constant _ROLE_176 = 1 << 176;\\n    uint256 internal constant _ROLE_177 = 1 << 177;\\n    uint256 internal constant _ROLE_178 = 1 << 178;\\n    uint256 internal constant _ROLE_179 = 1 << 179;\\n    uint256 internal constant _ROLE_180 = 1 << 180;\\n    uint256 internal constant _ROLE_181 = 1 << 181;\\n    uint256 internal constant _ROLE_182 = 1 << 182;\\n    uint256 internal constant _ROLE_183 = 1 << 183;\\n    uint256 internal constant _ROLE_184 = 1 << 184;\\n    uint256 internal constant _ROLE_185 = 1 << 185;\\n    uint256 internal constant _ROLE_186 = 1 << 186;\\n    uint256 internal constant _ROLE_187 = 1 << 187;\\n    uint256 internal constant _ROLE_188 = 1 << 188;\\n    uint256 internal constant _ROLE_189 = 1 << 189;\\n    uint256 internal constant _ROLE_190 = 1 << 190;\\n    uint256 internal constant _ROLE_191 = 1 << 191;\\n    uint256 internal constant _ROLE_192 = 1 << 192;\\n    uint256 internal constant _ROLE_193 = 1 << 193;\\n    uint256 internal constant _ROLE_194 = 1 << 194;\\n    uint256 internal constant _ROLE_195 = 1 << 195;\\n    uint256 internal constant _ROLE_196 = 1 << 196;\\n    uint256 internal constant _ROLE_197 = 1 << 197;\\n    uint256 internal constant _ROLE_198 = 1 << 198;\\n    uint256 internal constant _ROLE_199 = 1 << 199;\\n    uint256 internal constant _ROLE_200 = 1 << 200;\\n    uint256 internal constant _ROLE_201 = 1 << 201;\\n    uint256 internal constant _ROLE_202 = 1 << 202;\\n    uint256 internal constant _ROLE_203 = 1 << 203;\\n    uint256 internal constant _ROLE_204 = 1 << 204;\\n    uint256 internal constant _ROLE_205 = 1 << 205;\\n    uint256 internal constant _ROLE_206 = 1 << 206;\\n    uint256 internal constant _ROLE_207 = 1 << 207;\\n    uint256 internal constant _ROLE_208 = 1 << 208;\\n    uint256 internal constant _ROLE_209 = 1 << 209;\\n    uint256 internal constant _ROLE_210 = 1 << 210;\\n    uint256 internal constant _ROLE_211 = 1 << 211;\\n    uint256 internal constant _ROLE_212 = 1 << 212;\\n    uint256 internal constant _ROLE_213 = 1 << 213;\\n    uint256 internal constant _ROLE_214 = 1 << 214;\\n    uint256 internal constant _ROLE_215 = 1 << 215;\\n    uint256 internal constant _ROLE_216 = 1 << 216;\\n    uint256 internal constant _ROLE_217 = 1 << 217;\\n    uint256 internal constant _ROLE_218 = 1 << 218;\\n    uint256 internal constant _ROLE_219 = 1 << 219;\\n    uint256 internal constant _ROLE_220 = 1 << 220;\\n    uint256 internal constant _ROLE_221 = 1 << 221;\\n    uint256 internal constant _ROLE_222 = 1 << 222;\\n    uint256 internal constant _ROLE_223 = 1 << 223;\\n    uint256 internal constant _ROLE_224 = 1 << 224;\\n    uint256 internal constant _ROLE_225 = 1 << 225;\\n    uint256 internal constant _ROLE_226 = 1 << 226;\\n    uint256 internal constant _ROLE_227 = 1 << 227;\\n    uint256 internal constant _ROLE_228 = 1 << 228;\\n    uint256 internal constant _ROLE_229 = 1 << 229;\\n    uint256 internal constant _ROLE_230 = 1 << 230;\\n    uint256 internal constant _ROLE_231 = 1 << 231;\\n    uint256 internal constant _ROLE_232 = 1 << 232;\\n    uint256 internal constant _ROLE_233 = 1 << 233;\\n    uint256 internal constant _ROLE_234 = 1 << 234;\\n    uint256 internal constant _ROLE_235 = 1 << 235;\\n    uint256 internal constant _ROLE_236 = 1 << 236;\\n    uint256 internal constant _ROLE_237 = 1 << 237;\\n    uint256 internal constant _ROLE_238 = 1 << 238;\\n    uint256 internal constant _ROLE_239 = 1 << 239;\\n    uint256 internal constant _ROLE_240 = 1 << 240;\\n    uint256 internal constant _ROLE_241 = 1 << 241;\\n    uint256 internal constant _ROLE_242 = 1 << 242;\\n    uint256 internal constant _ROLE_243 = 1 << 243;\\n    uint256 internal constant _ROLE_244 = 1 << 244;\\n    uint256 internal constant _ROLE_245 = 1 << 245;\\n    uint256 internal constant _ROLE_246 = 1 << 246;\\n    uint256 internal constant _ROLE_247 = 1 << 247;\\n    uint256 internal constant _ROLE_248 = 1 << 248;\\n    uint256 internal constant _ROLE_249 = 1 << 249;\\n    uint256 internal constant _ROLE_250 = 1 << 250;\\n    uint256 internal constant _ROLE_251 = 1 << 251;\\n    uint256 internal constant _ROLE_252 = 1 << 252;\\n    uint256 internal constant _ROLE_253 = 1 << 253;\\n    uint256 internal constant _ROLE_254 = 1 << 254;\\n    uint256 internal constant _ROLE_255 = 1 << 255;\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/ISoundEditionV2_1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport { IERC721AUpgradeable } from \\\"chiru-labs/ERC721A-Upgradeable/IERC721AUpgradeable.sol\\\";\\nimport { IERC2981Upgradeable } from \\\"openzeppelin-upgradeable/interfaces/IERC2981Upgradeable.sol\\\";\\nimport { IERC165Upgradeable } from \\\"openzeppelin-upgradeable/utils/introspection/IERC165Upgradeable.sol\\\";\\n\\nimport { IMetadataModule } from \\\"./IMetadataModule.sol\\\";\\n\\n/**\\n * @title ISoundEditionV2_1\\n * @notice The interface for Sound edition contracts.\\n */\\ninterface ISoundEditionV2_1 is IERC721AUpgradeable, IERC2981Upgradeable {\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    /**\\n     * @dev The information pertaining to a tier.\\n     */\\n    struct TierInfo {\\n        // The tier.\\n        uint8 tier;\\n        // The current max mintable amount.\\n        uint32 maxMintable;\\n        // The lower bound of the maximum number of tokens that can be minted for the tier.\\n        uint32 maxMintableLower;\\n        // The upper bound of the maximum number of tokens that can be minted for the tier.\\n        uint32 maxMintableUpper;\\n        // The timestamp (in seconds since unix epoch) after which the\\n        // max amount of tokens mintable for the tier will drop from\\n        // `maxMintableUpper` to `maxMintableLower`.\\n        uint32 cutoffTime;\\n        // The total number of tokens minted for the tier.\\n        uint32 minted;\\n        // The mint randomness for the tier.\\n        uint256 mintRandomness;\\n        // Whether the tier mints have concluded.\\n        bool mintConcluded;\\n        // Whether the tier has mint randomness enabled.\\n        bool mintRandomnessEnabled;\\n        // Whether the tier is frozen.\\n        bool isFrozen;\\n    }\\n\\n    /**\\n     * @dev A struct containing the arguments for creating a tier.\\n     */\\n    struct TierCreation {\\n        // The tier.\\n        uint8 tier;\\n        // The lower bound of the maximum number of tokens that can be minted for the tier.\\n        uint32 maxMintableLower;\\n        // The upper bound of the maximum number of tokens that can be minted for the tier.\\n        uint32 maxMintableUpper;\\n        // The timestamp (in seconds since unix epoch) after which the\\n        // max amount of tokens mintable for the tier will drop from\\n        // `maxMintableUpper` to `maxMintableLower`.\\n        uint32 cutoffTime;\\n        // Whether the tier has mint randomness enabled.\\n        bool mintRandomnessEnabled;\\n        // Whether the tier is frozen.\\n        bool isFrozen;\\n    }\\n\\n    /**\\n     * @dev The information pertaining to this edition.\\n     */\\n    struct EditionInfo {\\n        // Base URI for the metadata.\\n        string baseURI;\\n        // Contract URI for OpenSea storefront.\\n        string contractURI;\\n        // Name of the collection.\\n        string name;\\n        // Symbol of the collection.\\n        string symbol;\\n        // Address that receives primary and secondary royalties.\\n        address fundingRecipient;\\n        // Address of the metadata module. Optional.\\n        address metadataModule;\\n        // Whether the metadata is frozen.\\n        bool isMetadataFrozen;\\n        // Whether the ability to create tiers is frozen.\\n        bool isCreateTierFrozen;\\n        // The royalty BPS (basis points).\\n        uint16 royaltyBPS;\\n        // Next token ID to be minted.\\n        uint256 nextTokenId;\\n        // Total number of tokens burned.\\n        uint256 totalBurned;\\n        // Total number of tokens minted.\\n        uint256 totalMinted;\\n        // Total number of tokens currently in existence.\\n        uint256 totalSupply;\\n        // An array of tier info. From lowest (0-indexed) to highest.\\n        TierInfo[] tierInfo;\\n    }\\n\\n    /**\\n     * @dev A struct containing the arguments for initialization.\\n     */\\n    struct EditionInitialization {\\n        // Name of the collection.\\n        string name;\\n        // Symbol of the collection.\\n        string symbol;\\n        // Address of the metadata module. Optional.\\n        address metadataModule;\\n        // Base URI for the metadata.\\n        string baseURI;\\n        // Contract URI for OpenSea storefront.\\n        string contractURI;\\n        // Address that receives primary and secondary royalties.\\n        address fundingRecipient;\\n        // The royalty BPS (basis points).\\n        uint16 royaltyBPS;\\n        // Whether the metadata is frozen.\\n        bool isMetadataFrozen;\\n        // Whether the ability to create tiers is frozen.\\n        bool isCreateTierFrozen;\\n        // An array of tier creation structs. From lowest (0-indexed) to highest.\\n        TierCreation[] tierCreations;\\n    }\\n\\n    // =============================================================\\n    //                            EVENTS\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when the metadata module is set.\\n     * @param metadataModule the address of the metadata module.\\n     */\\n    event MetadataModuleSet(address metadataModule);\\n\\n    /**\\n     * @dev Emitted when the `baseURI` is set.\\n     * @param baseURI the base URI of the edition.\\n     */\\n    event BaseURISet(string baseURI);\\n\\n    /**\\n     * @dev Emitted when the `contractURI` is set.\\n     * @param contractURI The contract URI of the edition.\\n     */\\n    event ContractURISet(string contractURI);\\n\\n    /**\\n     * @dev Emitted when the metadata is frozen (e.g.: `baseURI` can no longer be changed).\\n     * @param metadataModule The address of the metadata module.\\n     * @param baseURI        The base URI of the edition.\\n     * @param contractURI    The contract URI of the edition.\\n     */\\n    event MetadataFrozen(address metadataModule, string baseURI, string contractURI);\\n\\n    /**\\n     * @dev Emitted when the ability to create tier is removed.\\n     */\\n    event CreateTierFrozen();\\n\\n    /**\\n     * @dev Emitted when the `fundingRecipient` is set.\\n     * @param recipient The address of the funding recipient.\\n     */\\n    event FundingRecipientSet(address recipient);\\n\\n    /**\\n     * @dev Emitted when the `royaltyBPS` is set.\\n     * @param bps The new royalty, measured in basis points.\\n     */\\n    event RoyaltySet(uint16 bps);\\n\\n    /**\\n     * @dev Emitted when the tier's maximum mintable token quantity range is set.\\n     * @param tier  The tier.\\n     * @param lower The lower limit of the maximum number of tokens that can be minted.\\n     * @param upper The upper limit of the maximum number of tokens that can be minted.\\n     */\\n    event MaxMintableRangeSet(uint8 tier, uint32 lower, uint32 upper);\\n\\n    /**\\n     * @dev Emitted when the tier's cutoff time set.\\n     * @param tier    The tier.\\n     * @param cutoff The timestamp.\\n     */\\n    event CutoffTimeSet(uint8 tier, uint32 cutoff);\\n\\n    /**\\n     * @dev Emitted when the `mintRandomnessEnabled` for the tier is set.\\n     * @param tier    The tier.\\n     * @param enabled The boolean value.\\n     */\\n    event MintRandomnessEnabledSet(uint8 tier, bool enabled);\\n\\n    /**\\n     * @dev Emitted upon initialization.\\n     * @param init The initialization data.\\n     */\\n    event SoundEditionInitialized(EditionInitialization init);\\n\\n    /**\\n     * @dev Emitted when a tier is created.\\n     * @param creation The tier creation data.\\n     */\\n    event TierCreated(TierCreation creation);\\n\\n    /**\\n     * @dev Emitted when a tier is frozen.\\n     * @param tier The tier.\\n     */\\n    event TierFrozen(uint8 tier);\\n\\n    /**\\n     * @dev Emitted upon ETH withdrawal.\\n     * @param recipient The recipient of the withdrawal.\\n     * @param amount    The amount withdrawn.\\n     * @param caller    The account that initiated the withdrawal.\\n     */\\n    event ETHWithdrawn(address recipient, uint256 amount, address caller);\\n\\n    /**\\n     * @dev Emitted upon ERC20 withdrawal.\\n     * @param recipient The recipient of the withdrawal.\\n     * @param tokens    The addresses of the ERC20 tokens.\\n     * @param amounts   The amount of each token withdrawn.\\n     * @param caller    The account that initiated the withdrawal.\\n     */\\n    event ERC20Withdrawn(address recipient, address[] tokens, uint256[] amounts, address caller);\\n\\n    /**\\n     * @dev Emitted upon a mint.\\n     * @param tier                 The tier.\\n     * @param to                   The address to mint to.\\n     * @param quantity             The number of minted.\\n     * @param fromTokenId          The first token ID minted.\\n     * @param fromTierTokenIdIndex The first token index in the tier.\\n     */\\n    event Minted(uint8 tier, address to, uint256 quantity, uint256 fromTokenId, uint32 fromTierTokenIdIndex);\\n\\n    /**\\n     * @dev Emitted upon an airdrop.\\n     * @param tier                 The tier.\\n     * @param to                   The recipients of the airdrop.\\n     * @param quantity             The number of tokens airdropped to each address in `to`.\\n     * @param fromTokenId          The first token ID minted to the first address in `to`.\\n     * @param fromTierTokenIdIndex The first token index in the tier.\\n     */\\n    event Airdropped(uint8 tier, address[] to, uint256 quantity, uint256 fromTokenId, uint32 fromTierTokenIdIndex);\\n\\n    /**\\n     * @dev EIP-4906 event to signal marketplaces to refresh the metadata.\\n     * @param fromTokenId The starting token ID.\\n     * @param toTokenId   The ending token ID.\\n     */\\n    event BatchMetadataUpdate(uint256 fromTokenId, uint256 toTokenId);\\n\\n    // =============================================================\\n    //                            ERRORS\\n    // =============================================================\\n\\n    /**\\n     * @dev The edition's metadata is frozen (e.g.: `baseURI` can no longer be changed).\\n     */\\n    error MetadataIsFrozen();\\n\\n    /**\\n     * @dev The ability to create tiers is frozen.\\n     */\\n    error CreateTierIsFrozen();\\n\\n    /**\\n     * @dev The given `royaltyBPS` is invalid.\\n     */\\n    error InvalidRoyaltyBPS();\\n\\n    /**\\n     * @dev A minimum of one tier must be provided to initialize a Sound Edition.\\n     */\\n    error ZeroTiersProvided();\\n\\n    /**\\n     * @dev The requested quantity exceeds the edition's remaining mintable token quantity.\\n     */\\n    error ExceedsAvailableSupply();\\n\\n    /**\\n     * @dev The given `fundingRecipient` address is invalid.\\n     */\\n    error InvalidFundingRecipient();\\n\\n    /**\\n     * @dev The `maxMintableLower` must not be greater than `maxMintableUpper`.\\n     */\\n    error InvalidMaxMintableRange();\\n\\n    /**\\n     * @dev The mint has already concluded.\\n     */\\n    error MintHasConcluded();\\n\\n    /**\\n     * @dev The mint has not concluded.\\n     */\\n    error MintNotConcluded();\\n\\n    /**\\n     * @dev Cannot perform the operation after a token has been minted.\\n     */\\n    error MintsAlreadyExist();\\n\\n    /**\\n     * @dev Cannot perform the operation after a token has been minted in the tier.\\n     */\\n    error TierMintsAlreadyExist();\\n\\n    /**\\n     * @dev The token IDs must be in strictly ascending order.\\n     */\\n    error TokenIdsNotStrictlyAscending();\\n\\n    /**\\n     * @dev The tier does not exist.\\n     */\\n    error TierDoesNotExist();\\n\\n    /**\\n     * @dev The tier already exists.\\n     */\\n    error TierAlreadyExists();\\n\\n    /**\\n     * @dev The tier is frozen.\\n     */\\n    error TierIsFrozen();\\n\\n    /**\\n     * @dev One of more of the tokens do not have the correct token tier.\\n     */\\n    error InvalidTokenTier();\\n\\n    /**\\n     * @dev Please wait for a while before you burn.\\n     */\\n    error CannotBurnImmediately();\\n\\n    /**\\n     * @dev The token for the tier query doesn't exist.\\n     */\\n    error TierQueryForNonexistentToken();\\n\\n    // =============================================================\\n    //               PUBLIC / EXTERNAL WRITE FUNCTIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Initializes the contract.\\n     * @param init The initialization struct.\\n     */\\n    function initialize(EditionInitialization calldata init) external;\\n\\n    /**\\n     * @dev Mints `quantity` tokens to addrress `to`\\n     *      Each token will be assigned a token ID that is consecutively increasing.\\n     *\\n     * Calling conditions:\\n     * - The caller must be the owner of the contract, or have either the\\n     *   `ADMIN_ROLE`, `MINTER_ROLE`, which can be granted via {grantRole}.\\n     *   Multiple minters, such as different minter contracts,\\n     *   can be authorized simultaneously.\\n     *\\n     * @param tier     The tier.\\n     * @param to       Address to mint to.\\n     * @param quantity Number of tokens to mint.\\n     * @return fromTokenId The first token ID minted.\\n     */\\n    function mint(\\n        uint8 tier,\\n        address to,\\n        uint256 quantity\\n    ) external payable returns (uint256 fromTokenId);\\n\\n    /**\\n     * @dev Mints `quantity` tokens to each of the addresses in `to`.\\n     *\\n     * Calling conditions:\\n     * - The caller must be the owner of the contract, or have the\\n     *   `ADMIN_ROLE`, which can be granted via {grantRole}.\\n     *\\n     * @param tier         The tier.\\n     * @param to           Address to mint to.\\n     * @param quantity     Number of tokens to mint.\\n     * @return fromTokenId The first token ID minted.\\n     */\\n    function airdrop(\\n        uint8 tier,\\n        address[] calldata to,\\n        uint256 quantity\\n    ) external payable returns (uint256 fromTokenId);\\n\\n    /**\\n     * @dev Withdraws collected ETH royalties to the fundingRecipient.\\n     */\\n    function withdrawETH() external;\\n\\n    /**\\n     * @dev Withdraws collected ERC20 royalties to the fundingRecipient.\\n     * @param tokens array of ERC20 tokens to withdraw\\n     */\\n    function withdrawERC20(address[] calldata tokens) external;\\n\\n    /**\\n     * @dev Sets metadata module.\\n     *\\n     * Calling conditions:\\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\\n     *\\n     * @param metadataModule Address of metadata module.\\n     */\\n    function setMetadataModule(address metadataModule) external;\\n\\n    /**\\n     * @dev Sets global base URI.\\n     *\\n     * Calling conditions:\\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\\n     *\\n     * @param baseURI The base URI to be set.\\n     */\\n    function setBaseURI(string memory baseURI) external;\\n\\n    /**\\n     * @dev Sets contract URI.\\n     *\\n     * Calling conditions:\\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\\n     *\\n     * @param contractURI The contract URI to be set.\\n     */\\n    function setContractURI(string memory contractURI) external;\\n\\n    /**\\n     * @dev Freezes metadata by preventing any more changes to base URI.\\n     *\\n     * Calling conditions:\\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\\n     */\\n    function freezeMetadata() external;\\n\\n    /**\\n     * @dev Freezes the max tier by preventing any more tiers from being added,\\n     *\\n     * Calling conditions:\\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\\n     */\\n    function freezeCreateTier() external;\\n\\n    /**\\n     * @dev Sets funding recipient address.\\n     *\\n     * Calling conditions:\\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\\n     *\\n     * @param fundingRecipient Address to be set as the new funding recipient.\\n     */\\n    function setFundingRecipient(address fundingRecipient) external;\\n\\n    /**\\n     * @dev Creates a new split wallet via the SplitMain contract, then sets it as the `fundingRecipient`.\\n     *\\n     * Calling conditions:\\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\\n     *\\n     * @param splitMain The address of the SplitMain contract.\\n     * @param splitData The calldata to forward to the SplitMain contract to create a split.\\n     * @return split The address of the new split contract.\\n     */\\n    function createSplit(address splitMain, bytes calldata splitData) external returns (address split);\\n\\n    /**\\n     * @dev Sets royalty amount in bps (basis points).\\n     *\\n     * Calling conditions:\\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\\n     *\\n     * @param bps The new royalty basis points to be set.\\n     */\\n    function setRoyalty(uint16 bps) external;\\n\\n    /**\\n     * @dev Freezes the tier.\\n     *\\n     * Calling conditions:\\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\\n     *\\n     * @param tier  The tier.\\n     */\\n    function freezeTier(uint8 tier) external;\\n\\n    /**\\n     * @dev Sets the edition max mintable range.\\n     *\\n     * Calling conditions:\\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\\n     *\\n     * @param tier  The tier.\\n     * @param lower The lower limit of the maximum number of tokens that can be minted.\\n     * @param upper The upper limit of the maximum number of tokens that can be minted.\\n     */\\n    function setMaxMintableRange(\\n        uint8 tier,\\n        uint32 lower,\\n        uint32 upper\\n    ) external;\\n\\n    /**\\n     * @dev Sets the timestamp after which, the `editionMaxMintable` drops\\n     *      from `editionMaxMintableUpper` to `editionMaxMintableLower.\\n     *\\n     * Calling conditions:\\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\\n     *\\n     * @param tier       The tier.\\n     * @param cutoffTime The timestamp.\\n     */\\n    function setCutoffTime(uint8 tier, uint32 cutoffTime) external;\\n\\n    /**\\n     * @dev Sets whether the `mintRandomness` is enabled.\\n     *\\n     * Calling conditions:\\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\\n     *\\n     * @param tier    The tier.\\n     * @param enabled The boolean value.\\n     */\\n    function setMintRandomnessEnabled(uint8 tier, bool enabled) external;\\n\\n    /**\\n     * @dev Adds a new tier.\\n     *\\n     * Calling conditions:\\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\\n     *\\n     * @param creation The tier creation data.\\n     */\\n    function createTier(TierCreation calldata creation) external;\\n\\n    /**\\n     * @dev Emits an event to signal to marketplaces to refresh all the metadata.\\n     */\\n    function emitAllMetadataUpdate() external;\\n\\n    // =============================================================\\n    //               PUBLIC / EXTERNAL VIEW FUNCTIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the edition info.\\n     * @return info The latest value.\\n     */\\n    function editionInfo() external view returns (EditionInfo memory info);\\n\\n    /**\\n     * @dev Returns the tier info.\\n     * @param tier The tier.\\n     * @return info The latest value.\\n     */\\n    function tierInfo(uint8 tier) external view returns (TierInfo memory info);\\n\\n    /**\\n     * @dev Returns the GA tier, which is 0.\\n     * @return The constant value.\\n     */\\n    function GA_TIER() external pure returns (uint8);\\n\\n    /**\\n     * @dev Basis points denominator used in fee calculations.\\n     * @return The constant value.\\n     */\\n    function BPS_DENOMINATOR() external pure returns (uint16);\\n\\n    /**\\n     * @dev Returns the minter role flag.\\n     *      Note: This constant will always be 2 for past and future sound protocol contracts.\\n     * @return The constant value.\\n     */\\n    function MINTER_ROLE() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the admin role flag.\\n     *      Note: This constant will always be 1 for past and future sound protocol contracts.\\n     * @return The constant value.\\n     */\\n    function ADMIN_ROLE() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the tier of the `tokenId`.\\n     * @param tokenId The token ID.\\n     * @return The latest value.\\n     */\\n    function tokenTier(uint256 tokenId) external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the tier of the `tokenId`.\\n     *      Note: Will NOT revert if any `tokenId` does not exist.\\n     *      If the token has not been minted, the tier will be zero.\\n     *      If the token is burned, the tier will be the tier before it was burned.\\n     * @param tokenId The token ID.\\n     * @return The latest value.\\n     */\\n    function explicitTokenTier(uint256 tokenId) external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the tiers of the `tokenIds`.\\n     *      Note: Will NOT revert if any `tokenId` does not exist.\\n     *      If the token has not been minted, the tier will be zero.\\n     *      If the token is burned, the tier will be the tier before it was burned.\\n     * @param tokenIds The token IDs.\\n     * @return The latest values.\\n     */\\n    function tokenTiers(uint256[] calldata tokenIds) external view returns (uint8[] memory);\\n\\n    /**\\n     * @dev Returns an array of all the token IDs in the tier.\\n     * @param tier The tier.\\n     * @return tokenIds The array of token IDs in the tier.\\n     */\\n    function tierTokenIds(uint8 tier) external view returns (uint256[] memory tokenIds);\\n\\n    /**\\n     * @dev Returns an array of all the token IDs in the tier, within the range [start, stop).\\n     * @param tier  The tier.\\n     * @param start The start of the range. Inclusive.\\n     * @param stop  The end of the range. Exclusive.\\n     * @return tokenIds The array of token IDs in the tier.\\n     */\\n    function tierTokenIdsIn(\\n        uint8 tier,\\n        uint256 start,\\n        uint256 stop\\n    ) external view returns (uint256[] memory tokenIds);\\n\\n    /**\\n     * @dev Returns the index of `tokenId` in it's tier token ID array.\\n     * @param tokenId The token ID to find.\\n     * @return The index of `tokenId`. If not found, returns `type(uint256).max`.\\n     */\\n    function tierTokenIdIndex(uint256 tokenId) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the maximum amount of tokens mintable for the tier.\\n     * @param tier The tier.\\n     * @return The configured value.\\n     */\\n    function maxMintable(uint8 tier) external view returns (uint32);\\n\\n    /**\\n     * @dev Returns the upper bound for the maximum tokens that can be minted for the tier.\\n     * @param tier The tier.\\n     * @return The configured value.\\n     */\\n    function maxMintableUpper(uint8 tier) external view returns (uint32);\\n\\n    /**\\n     * @dev Returns the lower bound for the maximum tokens that can be minted for the tier.\\n     * @param tier The tier.\\n     * @return The configured value.\\n     */\\n    function maxMintableLower(uint8 tier) external view returns (uint32);\\n\\n    /**\\n     * @dev Returns the timestamp after which `maxMintable` drops from\\n     *      `maxMintableUpper` to `maxMintableLower`.\\n     * @param tier The tier.\\n     * @return The configured value.\\n     */\\n    function cutoffTime(uint8 tier) external view returns (uint32);\\n\\n    /**\\n     * @dev Returns the number of tokens minted for the tier.\\n     * @param tier The tier.\\n     * @return The latest value.\\n     */\\n    function tierMinted(uint8 tier) external view returns (uint32);\\n\\n    /**\\n     * @dev Returns the mint randomness for the tier.\\n     * @param tier The tier.\\n     * @return The latest value.\\n     */\\n    function mintRandomness(uint8 tier) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the one-of-one token ID for the tier.\\n     * @param tier The tier.\\n     * @return The latest value.\\n     */\\n    function mintRandomnessOneOfOne(uint8 tier) external view returns (uint32);\\n\\n    /**\\n     * @dev Returns whether the `mintRandomness` has been enabled.\\n     * @return The configured value.\\n     */\\n    function mintRandomnessEnabled(uint8 tier) external view returns (bool);\\n\\n    /**\\n     * @dev Returns whether the mint has been concluded for the tier.\\n     * @param tier The tier.\\n     * @return The latest value.\\n     */\\n    function mintConcluded(uint8 tier) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the base token URI for the collection.\\n     * @return The configured value.\\n     */\\n    function baseURI() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the contract URI to be used by Opensea.\\n     *      See: https://docs.opensea.io/docs/contract-level-metadata\\n     * @return The configured value.\\n     */\\n    function contractURI() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the address of the funding recipient.\\n     * @return The configured value.\\n     */\\n    function fundingRecipient() external view returns (address);\\n\\n    /**\\n     * @dev Returns the address of the metadata module.\\n     * @return The configured value.\\n     */\\n    function metadataModule() external view returns (address);\\n\\n    /**\\n     * @dev Returns the royalty basis points.\\n     * @return The configured value.\\n     */\\n    function royaltyBPS() external view returns (uint16);\\n\\n    /**\\n     * @dev Returns whether the tier is frozen.\\n     * @return The configured value.\\n     */\\n    function isFrozen(uint8 tier) external view returns (bool);\\n\\n    /**\\n     * @dev Returns whether the metadata module is frozen.\\n     * @return The configured value.\\n     */\\n    function isMetadataFrozen() external view returns (bool);\\n\\n    /**\\n     * @dev Returns whether the ability to create tiers is frozen.\\n     * @return The configured value.\\n     */\\n    function isCreateTierFrozen() external view returns (bool);\\n\\n    /**\\n     * @dev Returns the next token ID to be minted.\\n     * @return The latest value.\\n     */\\n    function nextTokenId() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the number of tokens minted by `owner`.\\n     * @param owner Address to query for number minted.\\n     * @return The latest value.\\n     */\\n    function numberMinted(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the number of tokens burned by `owner`.\\n     * @param owner Address to query for number burned.\\n     * @return The latest value.\\n     */\\n    function numberBurned(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the total amount of tokens minted.\\n     * @return The latest value.\\n     */\\n    function totalMinted() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the total amount of tokens burned.\\n     * @return The latest value.\\n     */\\n    function totalBurned() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the token URI of `tokenId`, but without reverting if\\n     *      the token does not exist.\\n     * @return The latest value.\\n     */\\n    function explicitTokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    /**\\n     * @dev Informs other contracts which interfaces this contract supports.\\n     *      Required by https://eips.ethereum.org/EIPS/eip-165\\n     * @param interfaceId The interface id to check.\\n     * @return Whether the `interfaceId` is supported.\\n     */\\n    function supportsInterface(bytes4 interfaceId)\\n        external\\n        view\\n        override(IERC721AUpgradeable, IERC165Upgradeable)\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/modules/interfaces/ISuperMinterV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport { IERC165 } from \\\"openzeppelin/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @title ISuperMinterV2\\n * @notice The interface for the generalized minter.\\n */\\ninterface ISuperMinterV2 is IERC165 {\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    /**\\n     * @dev A struct containing the arguments to create a mint.\\n     */\\n    struct MintCreation {\\n        // The edition address.\\n        address edition;\\n        // The base price per token.\\n        // For `VERIFY_SIGNATURE`, this will be the minimum limit of the signed price.\\n        // Will be 0 if the `tier` is `GA_TIER`.\\n        uint96 price;\\n        // The start time of the mint.\\n        uint32 startTime;\\n        // The end time of the mint.\\n        uint32 endTime;\\n        // The maximum number of tokens an account can mint in this mint.\\n        uint32 maxMintablePerAccount;\\n        // The maximum number of tokens mintable.\\n        uint32 maxMintable;\\n        // The affiliate fee BPS.\\n        uint16 affiliateFeeBPS;\\n        // The affiliate Merkle root, if any.\\n        bytes32 affiliateMerkleRoot;\\n        // The tier of the mint.\\n        uint8 tier;\\n        // The address of the platform.\\n        address platform;\\n        // The mode of the mint. Options: `DEFAULT`, `VERIFY_MERKLE`, `VERIFY_SIGNATURE`.\\n        uint8 mode;\\n        // The Merkle root hash, required if `mode` is `VERIFY_MERKLE`.\\n        bytes32 merkleRoot;\\n    }\\n\\n    /**\\n     * @dev A struct containing the arguments for mint-to.\\n     */\\n    struct MintTo {\\n        // The mint ID.\\n        address edition;\\n        // The tier of the mint.\\n        uint8 tier;\\n        // The edition-tier schedule number.\\n        uint8 scheduleNum;\\n        // The address to mint to.\\n        address to;\\n        // The number of tokens to mint.\\n        uint32 quantity;\\n        // The allowlisted address. Used if `mode` is `VERIFY_MERKLE`.\\n        address allowlisted;\\n        // The allowlisted quantity. Used if `mode` is `VERIFY_MERKLE`.\\n        // A default zero value means no limit.\\n        uint32 allowlistedQuantity;\\n        // The allowlist Merkle proof.\\n        bytes32[] allowlistProof;\\n        // The signed price. Used if `mode` is `VERIFY_SIGNATURE`.\\n        uint96 signedPrice;\\n        // The signed quantity. Used if `mode` is `VERIFY_SIGNATURE`.\\n        uint32 signedQuantity;\\n        // The signed claimed ticket. Used if `mode` is `VERIFY_SIGNATURE`.\\n        uint32 signedClaimTicket;\\n        // The expiry timestamp for the signature. Used if `mode` is `VERIFY_SIGNATURE`.\\n        uint32 signedDeadline;\\n        // The signature by the signer. Used if `mode` is `VERIFY_SIGNATURE`.\\n        bytes signature;\\n        // The affiliate address. Optional.\\n        address affiliate;\\n        // The Merkle proof for the affiliate.\\n        bytes32[] affiliateProof;\\n        // The attribution ID, optional.\\n        uint256 attributionId;\\n    }\\n\\n    /**\\n     * @dev A struct containing the arguments for platformAirdrop.\\n     */\\n    struct PlatformAirdrop {\\n        // The mint ID.\\n        address edition;\\n        // The tier of the mint.\\n        uint8 tier;\\n        // The edition-tier schedule number.\\n        uint8 scheduleNum;\\n        // The addresses to mint to.\\n        address[] to;\\n        // The signed quantity.\\n        uint32 signedQuantity;\\n        // The signed claimed ticket. Used if `mode` is `VERIFY_SIGNATURE`.\\n        uint32 signedClaimTicket;\\n        // The expiry timestamp for the signature. Used if `mode` is `VERIFY_SIGNATURE`.\\n        uint32 signedDeadline;\\n        // The signature by the signer. Used if `mode` is `VERIFY_SIGNATURE`.\\n        bytes signature;\\n    }\\n\\n    /**\\n     * @dev A struct containing the total prices and fees.\\n     */\\n    struct TotalPriceAndFees {\\n        // The required Ether value.\\n        // (`subTotal + platformTxFlatFee + artistReward + affiliateReward + platformReward`).\\n        uint256 total;\\n        // The total price before any additive fees.\\n        uint256 subTotal;\\n        // The price per token.\\n        uint256 unitPrice;\\n        // The final artist fee (inclusive of `finalArtistReward`).\\n        uint256 finalArtistFee;\\n        // The total affiliate fee (inclusive of `finalAffiliateReward`).\\n        uint256 finalAffiliateFee;\\n        // The final platform fee\\n        // (inclusive of `finalPlatformReward`, `perTxFlat`, sum of `perMintBPS`).\\n        uint256 finalPlatformFee;\\n    }\\n\\n    /**\\n     * @dev A struct containing the log data for the `Minted` event.\\n     */\\n    struct MintedLogData {\\n        // The number of tokens minted.\\n        uint32 quantity;\\n        // The starting token ID minted.\\n        uint256 fromTokenId;\\n        // The allowlisted address.\\n        address allowlisted;\\n        // The allowlisted quantity.\\n        uint32 allowlistedQuantity;\\n        // The signed quantity.\\n        uint32 signedQuantity;\\n        // The signed claim ticket.\\n        uint32 signedClaimTicket;\\n        // The affiliate address.\\n        address affiliate;\\n        // Whether the affiliate address is affiliated.\\n        bool affiliated;\\n        // The total price paid, inclusive of all fees.\\n        uint256 requiredEtherValue;\\n        // The price per token.\\n        uint256 unitPrice;\\n        // The final artist fee (inclusive of `finalArtistReward`).\\n        uint256 finalArtistFee;\\n        // The total affiliate fee (inclusive of `finalAffiliateReward`).\\n        uint256 finalAffiliateFee;\\n        // The final platform fee\\n        // (inclusive of `finalPlatformReward`, `perTxFlat`, sum of `perMintBPS`).\\n        uint256 finalPlatformFee;\\n    }\\n\\n    /**\\n     * @dev A struct to hold the fee configuration for a platform and a tier.\\n     */\\n    struct PlatformFeeConfig {\\n        // The amount of reward to give to the artist per mint.\\n        uint96 artistMintReward;\\n        // The amount of reward to give to the affiliate per mint.\\n        uint96 affiliateMintReward;\\n        // The amount of reward to give to the platform per mint.\\n        uint96 platformMintReward;\\n        // If the price is greater than this, the rewards will become the threshold variants.\\n        uint96 thresholdPrice;\\n        // The amount of reward to give to the artist (`unitPrice >= thresholdPrice`).\\n        uint96 thresholdArtistMintReward;\\n        // The amount of reward to give to the affiliate (`unitPrice >= thresholdPrice`).\\n        uint96 thresholdAffiliateMintReward;\\n        // The amount of reward to give to the platform (`unitPrice >= thresholdPrice`).\\n        uint96 thresholdPlatformMintReward;\\n        // The per-transaction flat fee.\\n        uint96 platformTxFlatFee;\\n        // The per-token fee BPS.\\n        uint16 platformMintFeeBPS;\\n        // Whether the fees are active.\\n        bool active;\\n    }\\n\\n    /**\\n     * @dev A struct containing the mint information.\\n     */\\n    struct MintInfo {\\n        // The mint ID.\\n        address edition;\\n        // The tier of the mint.\\n        uint8 tier;\\n        // The edition-tier schedule number.\\n        uint8 scheduleNum;\\n        // The platform address.\\n        address platform;\\n        // The base price per token.\\n        // For `VERIFY_SIGNATURE` this will be the minimum limit of the signed price.\\n        // If the `tier` is `GA_TIER`, and the `mode` is NOT `VERIFY_SIGNATURE`,\\n        // this value will be the GA price instead.\\n        uint96 price;\\n        // The start time of the mint.\\n        uint32 startTime;\\n        // The end time of the mint.\\n        uint32 endTime;\\n        // The maximum number of tokens an account can mint in this mint.\\n        uint32 maxMintablePerAccount;\\n        // The maximum number of tokens mintable.\\n        uint32 maxMintable;\\n        // The total number of tokens minted.\\n        uint32 minted;\\n        // The affiliate fee BPS.\\n        uint16 affiliateFeeBPS;\\n        // The mode of the mint.\\n        uint8 mode;\\n        // Whether the mint is paused.\\n        bool paused;\\n        // Whether the mint already has mints.\\n        bool hasMints;\\n        // The affiliate Merkle root, if any.\\n        bytes32 affiliateMerkleRoot;\\n        // The Merkle root hash, required if `mode` is `VERIFY_MERKLE`.\\n        bytes32 merkleRoot;\\n        // The signer address, used if `mode` is `VERIFY_SIGNATURE` or `PLATFORM_AIRDROP`.\\n        address signer;\\n    }\\n\\n    // =============================================================\\n    //                            EVENTS\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when a new mint is created.\\n     * @param edition       The address of the Sound Edition.\\n     * @param tier          The tier.\\n     * @param scheduleNum   The edition-tier schedule number.\\n     * @param creation      The mint creation struct.\\n     */\\n    event MintCreated(address indexed edition, uint8 tier, uint8 scheduleNum, MintCreation creation);\\n\\n    /**\\n     * @dev Emitted when a mint is paused or un-paused.\\n     * @param edition       The address of the Sound Edition.\\n     * @param tier          The tier.\\n     * @param scheduleNum   The edition-tier schedule number.\\n     * @param paused        Whether the mint is paused.\\n     */\\n    event PausedSet(address indexed edition, uint8 tier, uint8 scheduleNum, bool paused);\\n\\n    /**\\n     * @dev Emitted when the time range of a mint is updated.\\n     * @param edition       The address of the Sound Edition.\\n     * @param tier          The tier.\\n     * @param scheduleNum   The edition-tier schedule number.\\n     * @param startTime     The start time.\\n     * @param endTime       The end time.\\n     */\\n    event TimeRangeSet(address indexed edition, uint8 tier, uint8 scheduleNum, uint32 startTime, uint32 endTime);\\n\\n    /**\\n     * @dev Emitted when the base per-token price of a mint is updated.\\n     * @param edition       The address of the Sound Edition.\\n     * @param tier          The tier.\\n     * @param scheduleNum   The edition-tier schedule number.\\n     * @param price         The base per-token price.\\n     */\\n    event PriceSet(address indexed edition, uint8 tier, uint8 scheduleNum, uint96 price);\\n\\n    /**\\n     * @dev Emitted when the max mintable per account for a mint is updated.\\n     * @param edition       The address of the Sound Edition.\\n     * @param tier          The tier.\\n     * @param scheduleNum   The edition-tier schedule number.\\n     * @param value         The max mintable per account.\\n     */\\n    event MaxMintablePerAccountSet(address indexed edition, uint8 tier, uint8 scheduleNum, uint32 value);\\n\\n    /**\\n     * @dev Emitted when the max mintable for a mint is updated.\\n     * @param edition       The address of the Sound Edition.\\n     * @param tier          The tier.\\n     * @param scheduleNum   The edition-tier schedule number.\\n     * @param value         The max mintable for the mint.\\n     */\\n    event MaxMintableSet(address indexed edition, uint8 tier, uint8 scheduleNum, uint32 value);\\n\\n    /**\\n     * @dev Emitted when the Merkle root of a mint is updated.\\n     * @param edition       The address of the Sound Edition.\\n     * @param tier          The tier.\\n     * @param scheduleNum   The edition-tier schedule number.\\n     * @param merkleRoot    The Merkle root of the mint.\\n     */\\n    event MerkleRootSet(address indexed edition, uint8 tier, uint8 scheduleNum, bytes32 merkleRoot);\\n\\n    /**\\n     * @dev Emitted when the affiliate fee BPS for a mint is updated.\\n     * @param edition       The address of the Sound Edition.\\n     * @param tier          The tier.\\n     * @param scheduleNum   The edition-tier schedule number.\\n     * @param bps           The affiliate fee BPS.\\n     */\\n    event AffiliateFeeSet(address indexed edition, uint8 tier, uint8 scheduleNum, uint16 bps);\\n\\n    /**\\n     * @dev Emitted when the affiliate Merkle root for a mint is updated.\\n     * @param edition       The address of the Sound Edition.\\n     * @param tier          The tier.\\n     * @param scheduleNum   The edition-tier schedule number.\\n     * @param root          The affiliate Merkle root hash.\\n     */\\n    event AffiliateMerkleRootSet(address indexed edition, uint8 tier, uint8 scheduleNum, bytes32 root);\\n\\n    /**\\n     * @dev Emitted when tokens are minted.\\n     * @param edition       The address of the Sound Edition.\\n     * @param tier          The tier.\\n     * @param scheduleNum   The edition-tier schedule number.\\n     * @param to            The recipient of the tokens minted.\\n     * @param data          The mint-to log data.\\n     * @param attributionId The optional attribution ID.\\n     */\\n    event Minted(\\n        address indexed edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        address indexed to,\\n        MintedLogData data,\\n        uint256 indexed attributionId\\n    );\\n\\n    /**\\n     * @dev Emitted when tokens are platform airdropped.\\n     * @param edition        The address of the Sound Edition.\\n     * @param tier           The tier.\\n     * @param scheduleNum    The edition-tier schedule number.\\n     * @param to             The recipients of the tokens minted.\\n     * @param signedQuantity The amount of tokens per address.\\n     * @param fromTokenId    The first token ID minted.\\n     */\\n    event PlatformAirdropped(\\n        address indexed edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        address[] to,\\n        uint32 signedQuantity,\\n        uint256 fromTokenId\\n    );\\n\\n    /**\\n     * @dev Emitted when the platform fee configuration for `tier` is updated.\\n     * @param platform The platform address.\\n     * @param tier     The tier of the mint.\\n     * @param config   The platform fee configuration.\\n     */\\n    event PlatformFeeConfigSet(address indexed platform, uint8 tier, PlatformFeeConfig config);\\n\\n    /**\\n     * @dev Emitted when the default platform fee configuration is updated.\\n     * @param platform The platform address.\\n     * @param config   The platform fee configuration.\\n     */\\n    event DefaultPlatformFeeConfigSet(address indexed platform, PlatformFeeConfig config);\\n\\n    /**\\n     * @dev Emitted when affiliate fees are withdrawn.\\n     * @param affiliate The recipient of the fees.\\n     * @param accrued   The amount of Ether accrued and withdrawn.\\n     */\\n    event AffiliateFeesWithdrawn(address indexed affiliate, uint256 accrued);\\n\\n    /**\\n     * @dev Emitted when platform fees are withdrawn.\\n     * @param platform  The platform address.\\n     * @param accrued   The amount of Ether accrued and withdrawn.\\n     */\\n    event PlatformFeesWithdrawn(address indexed platform, uint256 accrued);\\n\\n    /**\\n     * @dev Emitted when the platform fee recipient address is updated.\\n     * @param platform  The platform address.\\n     * @param recipient The platform fee recipient address.\\n     */\\n    event PlatformFeeAddressSet(address indexed platform, address recipient);\\n\\n    /**\\n     * @dev Emitted when the per-token price for the GA tier is set.\\n     * @param platform The platform address.\\n     * @param price    The price per token for the GA tier.\\n     */\\n    event GAPriceSet(address indexed platform, uint96 price);\\n\\n    /**\\n     * @dev Emitted when the signer for a platform is set.\\n     * @param platform The platform address.\\n     * @param signer   The signer for the platform.\\n     */\\n    event PlatformSignerSet(address indexed platform, address signer);\\n\\n    // =============================================================\\n    //                            ERRORS\\n    // =============================================================\\n\\n    /**\\n     * @dev Exact payment required.\\n     * @param paid The amount of Ether paid.\\n     * @param required The amount of Ether required.\\n     */\\n    error WrongPayment(uint256 paid, uint256 required);\\n\\n    /**\\n     * @dev The mint is not opened.\\n     * @param blockTimestamp The current block timestamp.\\n     * @param startTime      The opening time of the mint.\\n     * @param endTime        The closing time of the mint.\\n     */\\n    error MintNotOpen(uint256 blockTimestamp, uint32 startTime, uint32 endTime);\\n\\n    /**\\n     * @dev The mint is paused.\\n     */\\n    error MintPaused();\\n\\n    /**\\n     * @dev Cannot perform the operation when any mints exist.\\n     */\\n    error MintsAlreadyExist();\\n\\n    /**\\n     * @dev The time range is invalid.\\n     */\\n    error InvalidTimeRange();\\n\\n    /**\\n     * @dev The max mintable range is invalid.\\n     */\\n    error InvalidMaxMintableRange();\\n\\n    /**\\n     * @dev The affiliate fee BPS cannot exceed the limit.\\n     */\\n    error InvalidAffiliateFeeBPS();\\n\\n    /**\\n     * @dev The affiliate fee BPS cannot exceed the limit.\\n     */\\n    error InvalidPlatformFeeBPS();\\n\\n    /**\\n     * @dev The affiliate fee BPS cannot exceed the limit.\\n     */\\n    error InvalidPlatformFlatFee();\\n\\n    /**\\n     * @dev Cannot mint more than the maximum limit per account.\\n     */\\n    error ExceedsMaxPerAccount();\\n\\n    /**\\n     * @dev Cannot mint more than the maximum supply.\\n     */\\n    error ExceedsMintSupply();\\n\\n    /**\\n     * @dev Cannot mint more than the signed quantity.\\n     */\\n    error ExceedsSignedQuantity();\\n\\n    /**\\n     * @dev The signature is invalid.\\n     */\\n    error InvalidSignature();\\n\\n    /**\\n     * @dev The signature has expired.\\n     */\\n    error SignatureExpired();\\n\\n    /**\\n     * @dev The signature claim ticket has already been used.\\n     */\\n    error SignatureAlreadyUsed();\\n\\n    /**\\n     * @dev The Merkle root cannot be empty.\\n     */\\n    error MerkleRootIsEmpty();\\n\\n    /**\\n     * @dev The Merkle proof is invalid.\\n     */\\n    error InvalidMerkleProof();\\n\\n    /**\\n     * @dev The caller has not been delegated via delegate cash.\\n     */\\n    error CallerNotDelegated();\\n\\n    /**\\n     * @dev The max mintable amount per account cannot be zero.\\n     */\\n    error MaxMintablePerAccountIsZero();\\n\\n    /**\\n     * @dev The max mintable value cannot be zero.\\n     */\\n    error MaxMintableIsZero();\\n\\n    /**\\n     * @dev The plaform fee address cannot be the zero address.\\n     */\\n    error PlatformFeeAddressIsZero();\\n\\n    /**\\n     * @dev The mint does not exist.\\n     */\\n    error MintDoesNotExist();\\n\\n    /**\\n     * @dev The affiliate provided is invalid.\\n     */\\n    error InvalidAffiliate();\\n\\n    /**\\n     * @dev The mint mode provided is invalid.\\n     */\\n    error InvalidMode();\\n\\n    /**\\n     * @dev The signed price is too low.\\n     */\\n    error SignedPriceTooLow();\\n\\n    /**\\n     * @dev The platform fee configuration provided is invalid.\\n     */\\n    error InvalidPlatformFeeConfig();\\n\\n    /**\\n     * @dev The parameter cannot be configured.\\n     */\\n    error NotConfigurable();\\n\\n    // =============================================================\\n    //               PUBLIC / EXTERNAL WRITE FUNCTIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Creates a mint.\\n     * @param c The mint creation struct.\\n     * @return scheduleNum The mint ID.\\n     */\\n    function createEditionMint(MintCreation calldata c) external returns (uint8 scheduleNum);\\n\\n    /**\\n     * @dev Performs a mint.\\n     * @param p The mint-to parameters.\\n     * @return fromTokenId The first token ID minted.\\n     */\\n    function mintTo(MintTo calldata p) external payable returns (uint256 fromTokenId);\\n\\n    /**\\n     * @dev Performs a platform airdrop.\\n     * @param p The platform airdrop parameters.\\n     * @return fromTokenId The first token ID minted.\\n     */\\n    function platformAirdrop(PlatformAirdrop calldata p) external returns (uint256 fromTokenId);\\n\\n    /**\\n     * @dev Sets the price of the mint.\\n     * @param edition       The address of the Sound Edition.\\n     * @param tier          The tier.\\n     * @param scheduleNum   The edition-tier schedule number.\\n     * @param price         The price per token.\\n     */\\n    function setPrice(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        uint96 price\\n    ) external;\\n\\n    /**\\n     * @dev Pause or unpase the the mint.\\n     * @param edition       The address of the Sound Edition.\\n     * @param tier          The tier.\\n     * @param scheduleNum   The edition-tier schedule number.\\n     * @param paused        Whether to pause the mint.\\n     */\\n    function setPaused(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        bool paused\\n    ) external;\\n\\n    /**\\n     * @dev Sets the time range for the the mint.\\n     * @param edition       The address of the Sound Edition.\\n     * @param tier          The tier.\\n     * @param scheduleNum   The edition-tier schedule number.\\n     * @param startTime     The mint start time.\\n     * @param endTime       The mint end time.\\n     */\\n    function setTimeRange(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        uint32 startTime,\\n        uint32 endTime\\n    ) external;\\n\\n    /**\\n     * @dev Sets the start time for the the mint.\\n     * @param edition       The address of the Sound Edition.\\n     * @param tier          The tier.\\n     * @param scheduleNum   The edition-tier schedule number.\\n     * @param startTime     The mint start time.\\n     */\\n    function setStartTime(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        uint32 startTime\\n    ) external;\\n\\n    /**\\n     * @dev Sets the affiliate fee BPS for the mint.\\n     * @param edition       The address of the Sound Edition.\\n     * @param tier          The tier.\\n     * @param scheduleNum   The edition-tier schedule number.\\n     * @param bps           The fee BPS.\\n     */\\n    function setAffiliateFee(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        uint16 bps\\n    ) external;\\n\\n    /**\\n     * @dev Sets the affiliate Merkle root for the mint.\\n     * @param edition       The address of the Sound Edition.\\n     * @param tier          The tier.\\n     * @param scheduleNum   The edition-tier schedule number.\\n     * @param root          The affiliate Merkle root.\\n     */\\n    function setAffiliateMerkleRoot(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        bytes32 root\\n    ) external;\\n\\n    /**\\n     * @dev Sets the max mintable per account.\\n     * @param edition       The address of the Sound Edition.\\n     * @param tier          The tier.\\n     * @param scheduleNum   The edition-tier schedule number.\\n     * @param value         The max mintable per account.\\n     */\\n    function setMaxMintablePerAccount(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        uint32 value\\n    ) external;\\n\\n    /**\\n     * @dev Sets the max mintable for the mint.\\n     * @param edition       The address of the Sound Edition.\\n     * @param tier          The tier.\\n     * @param scheduleNum   The edition-tier schedule number.\\n     * @param value         The max mintable for the mint.\\n     */\\n    function setMaxMintable(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        uint32 value\\n    ) external;\\n\\n    /**\\n     * @dev Sets the mode for the mint. The mint mode must be `VERIFY_MERKLE`.\\n     * @param edition       The address of the Sound Edition.\\n     * @param tier          The tier.\\n     * @param scheduleNum   The edition-tier schedule number.\\n     * @param merkleRoot    The Merkle root of the mint.\\n     */\\n    function setMerkleRoot(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        bytes32 merkleRoot\\n    ) external;\\n\\n    /**\\n     * @dev Withdraws all accrued fees of the affiliate, to the affiliate.\\n     * @param affiliate The affiliate address.\\n     */\\n    function withdrawForAffiliate(address affiliate) external;\\n\\n    /**\\n     * @dev Withdraws all accrued fees of the platform, to the their fee address.\\n     * @param platform The platform address.\\n     */\\n    function withdrawForPlatform(address platform) external;\\n\\n    /**\\n     * @dev Allows the caller, as a platform, to set their fee address\\n     * @param recipient The platform fee address of the caller.\\n     */\\n    function setPlatformFeeAddress(address recipient) external;\\n\\n    /**\\n     * @dev Allows the caller, as a platform, to set their per-tier fee configuration.\\n     * @param tier The tier of the mint.\\n     * @param c    The platform fee configuration struct.\\n     */\\n    function setPlatformFeeConfig(uint8 tier, PlatformFeeConfig memory c) external;\\n\\n    /**\\n     * @dev Allows the caller, as a platform, to set their default fee configuration.\\n     * @param c    The platform fee configuration struct.\\n     */\\n    function setDefaultPlatformFeeConfig(PlatformFeeConfig memory c) external;\\n\\n    /**\\n     * @dev Allows the platform to set the price for the GA tier.\\n     * @param price The price per token for the GA tier.\\n     */\\n    function setGAPrice(uint96 price) external;\\n\\n    /**\\n     * @dev Allows the platform to set their signer.\\n     * @param signer The signer for the platform.\\n     */\\n    function setPlatformSigner(address signer) external;\\n\\n    // =============================================================\\n    //               PUBLIC / EXTERNAL VIEW FUNCTIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the GA tier. Which is 0.\\n     * @return The constant value.\\n     */\\n    function GA_TIER() external pure returns (uint8);\\n\\n    /**\\n     * @dev The EIP-712 typehash for signed mints.\\n     * @return The constant value.\\n     */\\n    function MINT_TO_TYPEHASH() external pure returns (bytes32);\\n\\n    /**\\n     * @dev The EIP-712 typehash for platform airdrop mints.\\n     * @return The constant value.\\n     */\\n    function PLATFORM_AIRDROP_TYPEHASH() external pure returns (bytes32);\\n\\n    /**\\n     * @dev The default mint mode.\\n     * @return The constant value.\\n     */\\n    function DEFAULT() external pure returns (uint8);\\n\\n    /**\\n     * @dev The mint mode for Merkle drops.\\n     * @return The constant value.\\n     */\\n    function VERIFY_MERKLE() external pure returns (uint8);\\n\\n    /**\\n     * @dev The mint mode for Merkle drops.\\n     * @return The constant value.\\n     */\\n    function VERIFY_SIGNATURE() external pure returns (uint8);\\n\\n    /**\\n     * @dev The mint mode for platform airdrop.\\n     * @return The constant value.\\n     */\\n    function PLATFORM_AIRDROP() external pure returns (uint8);\\n\\n    /**\\n     * @dev The denominator used in BPS fee calculations.\\n     * @return The constant value.\\n     */\\n    function BPS_DENOMINATOR() external pure returns (uint16);\\n\\n    /**\\n     * @dev The maximum affiliate fee BPS.\\n     * @return The constant value.\\n     */\\n    function MAX_AFFILIATE_FEE_BPS() external pure returns (uint16);\\n\\n    /**\\n     * @dev The maximum per-mint platform fee BPS.\\n     * @return The constant value.\\n     */\\n    function MAX_PLATFORM_PER_MINT_FEE_BPS() external pure returns (uint16);\\n\\n    /**\\n     * @dev The maximum per-mint reward. Applies to artists, affiliates, platform.\\n     * @return The constant value.\\n     */\\n    function MAX_PER_MINT_REWARD() external pure returns (uint96);\\n\\n    /**\\n     * @dev The maximum platform per-transaction flat fee.\\n     * @return The constant value.\\n     */\\n    function MAX_PLATFORM_PER_TX_FLAT_FEE() external pure returns (uint96);\\n\\n    /**\\n     * @dev Returns the amount of fees accrued by the platform.\\n     * @param platform The platform address.\\n     * @return The latest value.\\n     */\\n    function platformFeesAccrued(address platform) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the fee recipient for the platform.\\n     * @param platform The platform address.\\n     * @return The configured value.\\n     */\\n    function platformFeeAddress(address platform) external view returns (address);\\n\\n    /**\\n     * @dev Returns the amount of fees accrued by the affiliate.\\n     * @param affiliate The affiliate address.\\n     * @return The latest value.\\n     */\\n    function affiliateFeesAccrued(address affiliate) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the EIP-712 digest of the mint-to data for signature mints.\\n     * @param p The mint-to parameters.\\n     * @return The computed value.\\n     */\\n    function computeMintToDigest(MintTo calldata p) external view returns (bytes32);\\n\\n    /**\\n     * @dev Returns the EIP-712 digest of the mint-to data for platform airdrops.\\n     * @param p The platform airdrop parameters.\\n     * @return The computed value.\\n     */\\n    function computePlatformAirdropDigest(PlatformAirdrop calldata p) external view returns (bytes32);\\n\\n    /**\\n     * @dev Returns the total price and fees for the mint.\\n     * @param edition           The address of the Sound Edition.\\n     * @param tier              The tier.\\n     * @param scheduleNum       The edition-tier schedule number.\\n     * @param quantity          How many tokens to mint.\\n     * @param hasValidAffiliate Whether there is a valid affiliate for the mint.\\n     * @return A struct containing the total price and fees.\\n     */\\n    function totalPriceAndFees(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        uint32 quantity,\\n        bool hasValidAffiliate\\n    ) external view returns (TotalPriceAndFees memory);\\n\\n    /**\\n     * @dev Returns the total price and fees for the mint.\\n     * @param edition          The address of the Sound Edition.\\n     * @param tier             The tier.\\n     * @param scheduleNum      The edition-tier schedule number.\\n     * @param quantity         How many tokens to mint.\\n     * @param signedPrice      The signed price.\\n     * @param hasValidAffiliate Whether there is a valid affiliate for the mint.\\n     * @return A struct containing the total price and fees.\\n     */\\n    function totalPriceAndFeesWithSignedPrice(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        uint32 quantity,\\n        uint96 signedPrice,\\n        bool hasValidAffiliate\\n    ) external view returns (TotalPriceAndFees memory);\\n\\n    /**\\n     * @dev Returns the GA price for the platform.\\n     * @param platform The platform address.\\n     * @return The configured value.\\n     */\\n    function gaPrice(address platform) external view returns (uint96);\\n\\n    /**\\n     * @dev Returns the signer for the platform.\\n     * @param platform The platform address.\\n     * @return The configured value.\\n     */\\n    function platformSigner(address platform) external view returns (address);\\n\\n    /**\\n     * @dev Returns the next mint schedule number for the edition-tier.\\n     * @param edition The Sound Edition address.\\n     * @param tier    The tier.\\n     * @return The next schedule number for the edition-tier.\\n     */\\n    function nextScheduleNum(address edition, uint8 tier) external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the number of tokens minted by `collector` for the mint.\\n     * @param edition       The address of the Sound Edition.\\n     * @param tier          The tier.\\n     * @param scheduleNum   The edition-tier schedule number.\\n     * @param collector     The address which tokens are minted to,\\n     *                      or in the case of `VERIFY_MERKLE`, is the allowlisted address.\\n     * @return The number of tokens minted.\\n     */\\n    function numberMinted(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        address collector\\n    ) external view returns (uint32);\\n\\n    /**\\n     * @dev Returns whether the affiliate is affiliated for the mint\\n     * @param edition        The address of the Sound Edition.\\n     * @param tier           The tier.\\n     * @param scheduleNum    The edition-tier schedule number.\\n     * @param affiliate      The affiliate address.\\n     * @param affiliateProof The Merkle proof for the affiliate.\\n     * @return The result.\\n     */\\n    function isAffiliatedWithProof(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        address affiliate,\\n        bytes32[] calldata affiliateProof\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Returns whether the affiliate is affiliated for the mint.\\n     * @param edition       The address of the Sound Edition.\\n     * @param tier          The tier.\\n     * @param scheduleNum   The edition-tier schedule number.\\n     * @param affiliate     The affiliate address.\\n     * @return A boolean on whether the affiliate is affiliated for the mint.\\n     */\\n    function isAffiliated(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        address affiliate\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Returns whether the claim tickets have been used.\\n     * @param edition       The address of the Sound Edition.\\n     * @param tier          The tier.\\n     * @param scheduleNum   The edition-tier schedule number.\\n     * @param claimTickets  An array of claim tickets.\\n     * @return An array of bools, where true means that a ticket has been used.\\n     */\\n    function checkClaimTickets(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum,\\n        uint32[] calldata claimTickets\\n    ) external view returns (bool[] memory);\\n\\n    /**\\n     * @dev Returns the platform fee configuration for the tier.\\n     * @param platform The platform address.\\n     * @param tier     The tier of the mint.\\n     * @return The platform fee configuration struct.\\n     */\\n    function platformFeeConfig(address platform, uint8 tier) external view returns (PlatformFeeConfig memory);\\n\\n    /**\\n     * @dev Returns the default platform fee configuration.\\n     * @param platform The platform address.\\n     * @return The platform fee configuration struct.\\n     */\\n    function defaultPlatformFeeConfig(address platform) external view returns (PlatformFeeConfig memory);\\n\\n    /**\\n     * @dev Returns the effective platform fee configuration.\\n     * @param platform The platform address.\\n     * @param tier     The tier of the mint.\\n     * @return The platform fee configuration struct.\\n     */\\n    function effectivePlatformFeeConfig(address platform, uint8 tier) external view returns (PlatformFeeConfig memory);\\n\\n    /**\\n     * @dev Returns an array of mint information structs pertaining to the mint.\\n     * @param edition The Sound Edition address.\\n     * @return An array of mint information structs.\\n     */\\n    function mintInfoList(address edition) external view returns (MintInfo[] memory);\\n\\n    /**\\n     * @dev Returns information pertaining to the mint.\\n     * @param edition       The address of the Sound Edition.\\n     * @param tier          The tier.\\n     * @param scheduleNum   The edition-tier schedule number.\\n     * @return The mint info struct.\\n     */\\n    function mintInfo(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum\\n    ) external view returns (MintInfo memory);\\n\\n    /**\\n     * @dev Retuns the EIP-712 name for the contract.\\n     * @return The constant value.\\n     */\\n    function name() external pure returns (string memory);\\n\\n    /**\\n     * @dev Retuns the EIP-712 version for the contract.\\n     * @return The constant value.\\n     */\\n    function version() external pure returns (string memory);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Contract for EIP-712 typed structured data hashing and signing.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EIP712.sol)\\n/// @author Modified from Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/EIP712.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol)\\n///\\n/// @dev Note, this implementation:\\n/// - Uses `address(this)` for the `verifyingContract` field.\\n/// - Does NOT use the optional EIP-712 salt.\\n/// - Does NOT use any EIP-712 extensions.\\n/// This is for simplicity and to save gas.\\n/// If you need to customize, please fork / modify accordingly.\\nabstract contract EIP712 {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  CONSTANTS AND IMMUTABLES                  */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev `keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")`.\\n    bytes32 internal constant _DOMAIN_TYPEHASH =\\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\n    uint256 private immutable _cachedThis;\\n    uint256 private immutable _cachedChainId;\\n    bytes32 private immutable _cachedNameHash;\\n    bytes32 private immutable _cachedVersionHash;\\n    bytes32 private immutable _cachedDomainSeparator;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        CONSTRUCTOR                         */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Cache the hashes for cheaper runtime gas costs.\\n    /// In the case of upgradeable contracts (i.e. proxies),\\n    /// or if the chain id changes due to a hard fork,\\n    /// the domain separator will be seamlessly calculated on-the-fly.\\n    constructor() {\\n        _cachedThis = uint256(uint160(address(this)));\\n        _cachedChainId = block.chainid;\\n\\n        string memory name;\\n        string memory version;\\n        if (!_domainNameAndVersionMayChange()) (name, version) = _domainNameAndVersion();\\n        bytes32 nameHash = _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(name));\\n        bytes32 versionHash =\\n            _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(version));\\n        _cachedNameHash = nameHash;\\n        _cachedVersionHash = versionHash;\\n\\n        bytes32 separator;\\n        if (!_domainNameAndVersionMayChange()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let m := mload(0x40) // Load the free memory pointer.\\n                mstore(m, _DOMAIN_TYPEHASH)\\n                mstore(add(m, 0x20), nameHash)\\n                mstore(add(m, 0x40), versionHash)\\n                mstore(add(m, 0x60), chainid())\\n                mstore(add(m, 0x80), address())\\n                separator := keccak256(m, 0xa0)\\n            }\\n        }\\n        _cachedDomainSeparator = separator;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   FUNCTIONS TO OVERRIDE                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Please override this function to return the domain name and version.\\n    /// ```\\n    ///     function _domainNameAndVersion()\\n    ///         internal\\n    ///         pure\\n    ///         virtual\\n    ///         returns (string memory name, string memory version)\\n    ///     {\\n    ///         name = \\\"Solady\\\";\\n    ///         version = \\\"1\\\";\\n    ///     }\\n    /// ```\\n    ///\\n    /// Note: If the returned result may change after the contract has been deployed,\\n    /// you must override `_domainNameAndVersionMayChange()` to return true.\\n    function _domainNameAndVersion()\\n        internal\\n        view\\n        virtual\\n        returns (string memory name, string memory version);\\n\\n    /// @dev Returns if `_domainNameAndVersion()` may change\\n    /// after the contract has been deployed (i.e. after the constructor).\\n    /// Default: false.\\n    function _domainNameAndVersionMayChange() internal pure virtual returns (bool result) {}\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     HASHING OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the EIP-712 domain separator.\\n    function _domainSeparator() internal view virtual returns (bytes32 separator) {\\n        if (_domainNameAndVersionMayChange()) {\\n            separator = _buildDomainSeparator();\\n        } else {\\n            separator = _cachedDomainSeparator;\\n            if (_cachedDomainSeparatorInvalidated()) separator = _buildDomainSeparator();\\n        }\\n    }\\n\\n    /// @dev Returns the hash of the fully encoded EIP-712 message for this domain,\\n    /// given `structHash`, as defined in\\n    /// https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\\n    ///\\n    /// The hash can be used together with {ECDSA-recover} to obtain the signer of a message:\\n    /// ```\\n    ///     bytes32 digest = _hashTypedData(keccak256(abi.encode(\\n    ///         keccak256(\\\"Mail(address to,string contents)\\\"),\\n    ///         mailTo,\\n    ///         keccak256(bytes(mailContents))\\n    ///     )));\\n    ///     address signer = ECDSA.recover(digest, signature);\\n    /// ```\\n    function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {\\n        // We will use `digest` to store the domain separator to save a bit of gas.\\n        if (_domainNameAndVersionMayChange()) {\\n            digest = _buildDomainSeparator();\\n        } else {\\n            digest = _cachedDomainSeparator;\\n            if (_cachedDomainSeparatorInvalidated()) digest = _buildDomainSeparator();\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the digest.\\n            mstore(0x00, 0x1901000000000000) // Store \\\"\\\\x19\\\\x01\\\".\\n            mstore(0x1a, digest) // Store the domain separator.\\n            mstore(0x3a, structHash) // Store the struct hash.\\n            digest := keccak256(0x18, 0x42)\\n            // Restore the part of the free memory slot that was overwritten.\\n            mstore(0x3a, 0)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                    EIP-5267 OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev See: https://eips.ethereum.org/EIPS/eip-5267\\n    function eip712Domain()\\n        public\\n        view\\n        virtual\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        )\\n    {\\n        fields = hex\\\"0f\\\"; // `0b01111`.\\n        (name, version) = _domainNameAndVersion();\\n        chainId = block.chainid;\\n        verifyingContract = address(this);\\n        salt = salt; // `bytes32(0)`.\\n        extensions = extensions; // `new uint256[](0)`.\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the EIP-712 domain separator.\\n    function _buildDomainSeparator() private view returns (bytes32 separator) {\\n        // We will use `separator` to store the name hash to save a bit of gas.\\n        bytes32 versionHash;\\n        if (_domainNameAndVersionMayChange()) {\\n            (string memory name, string memory version) = _domainNameAndVersion();\\n            separator = keccak256(bytes(name));\\n            versionHash = keccak256(bytes(version));\\n        } else {\\n            separator = _cachedNameHash;\\n            versionHash = _cachedVersionHash;\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Load the free memory pointer.\\n            mstore(m, _DOMAIN_TYPEHASH)\\n            mstore(add(m, 0x20), separator) // Name hash.\\n            mstore(add(m, 0x40), versionHash)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            separator := keccak256(m, 0xa0)\\n        }\\n    }\\n\\n    /// @dev Returns if the cached domain separator has been invalidated.\\n    function _cachedDomainSeparatorInvalidated() private view returns (bool result) {\\n        uint256 cachedChainId = _cachedChainId;\\n        uint256 cachedThis = _cachedThis;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/MerkleProofLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Gas optimized verification of proof of inclusion for a leaf in a Merkle tree.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/MerkleProofLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/MerkleProofLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol)\\nlibrary MerkleProofLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*            MERKLE PROOF VERIFICATION OPERATIONS            */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns whether `leaf` exists in the Merkle tree with `root`, given `proof`.\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf)\\n        internal\\n        pure\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(proof) {\\n                // Initialize `offset` to the offset of `proof` elements in memory.\\n                let offset := add(proof, 0x20)\\n                // Left shift by 5 is equivalent to multiplying by 0x20.\\n                let end := add(offset, shl(5, mload(proof)))\\n                // Iterate over proof elements to compute root hash.\\n                for {} 1 {} {\\n                    // Slot of `leaf` in scratch space.\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\n                    let scratch := shl(5, gt(leaf, mload(offset)))\\n                    // Store elements to hash contiguously in scratch space.\\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\\n                    mstore(scratch, leaf)\\n                    mstore(xor(scratch, 0x20), mload(offset))\\n                    // Reuse `leaf` to store the hash to reduce stack operations.\\n                    leaf := keccak256(0x00, 0x40)\\n                    offset := add(offset, 0x20)\\n                    if iszero(lt(offset, end)) { break }\\n                }\\n            }\\n            isValid := eq(leaf, root)\\n        }\\n    }\\n\\n    /// @dev Returns whether `leaf` exists in the Merkle tree with `root`, given `proof`.\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf)\\n        internal\\n        pure\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if proof.length {\\n                // Left shift by 5 is equivalent to multiplying by 0x20.\\n                let end := add(proof.offset, shl(5, proof.length))\\n                // Initialize `offset` to the offset of `proof` in the calldata.\\n                let offset := proof.offset\\n                // Iterate over proof elements to compute root hash.\\n                for {} 1 {} {\\n                    // Slot of `leaf` in scratch space.\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\n                    let scratch := shl(5, gt(leaf, calldataload(offset)))\\n                    // Store elements to hash contiguously in scratch space.\\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\\n                    mstore(scratch, leaf)\\n                    mstore(xor(scratch, 0x20), calldataload(offset))\\n                    // Reuse `leaf` to store the hash to reduce stack operations.\\n                    leaf := keccak256(0x00, 0x40)\\n                    offset := add(offset, 0x20)\\n                    if iszero(lt(offset, end)) { break }\\n                }\\n            }\\n            isValid := eq(leaf, root)\\n        }\\n    }\\n\\n    /// @dev Returns whether all `leaves` exist in the Merkle tree with `root`,\\n    /// given `proof` and `flags`.\\n    ///\\n    /// Note:\\n    /// - Breaking the invariant `flags.length == (leaves.length - 1) + proof.length`\\n    ///   will always return false.\\n    /// - The sum of the lengths of `proof` and `leaves` must never overflow.\\n    /// - Any non-zero word in the `flags` array is treated as true.\\n    /// - The memory offset of `proof` must be non-zero\\n    ///   (i.e. `proof` is not pointing to the scratch space).\\n    function verifyMultiProof(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32[] memory leaves,\\n        bool[] memory flags\\n    ) internal pure returns (bool isValid) {\\n        // Rebuilds the root by consuming and producing values on a queue.\\n        // The queue starts with the `leaves` array, and goes into a `hashes` array.\\n        // After the process, the last element on the queue is verified\\n        // to be equal to the `root`.\\n        //\\n        // The `flags` array denotes whether the sibling\\n        // should be popped from the queue (`flag == true`), or\\n        // should be popped from the `proof` (`flag == false`).\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cache the lengths of the arrays.\\n            let leavesLength := mload(leaves)\\n            let proofLength := mload(proof)\\n            let flagsLength := mload(flags)\\n\\n            // Advance the pointers of the arrays to point to the data.\\n            leaves := add(0x20, leaves)\\n            proof := add(0x20, proof)\\n            flags := add(0x20, flags)\\n\\n            // If the number of flags is correct.\\n            for {} eq(add(leavesLength, proofLength), add(flagsLength, 1)) {} {\\n                // For the case where `proof.length + leaves.length == 1`.\\n                if iszero(flagsLength) {\\n                    // `isValid = (proof.length == 1 ? proof[0] : leaves[0]) == root`.\\n                    isValid := eq(mload(xor(leaves, mul(xor(proof, leaves), proofLength))), root)\\n                    break\\n                }\\n\\n                // The required final proof offset if `flagsLength` is not zero, otherwise zero.\\n                let proofEnd := add(proof, shl(5, proofLength))\\n                // We can use the free memory space for the queue.\\n                // We don't need to allocate, since the queue is temporary.\\n                let hashesFront := mload(0x40)\\n                // Copy the leaves into the hashes.\\n                // Sometimes, a little memory expansion costs less than branching.\\n                // Should cost less, even with a high free memory offset of 0x7d00.\\n                leavesLength := shl(5, leavesLength)\\n                for { let i := 0 } iszero(eq(i, leavesLength)) { i := add(i, 0x20) } {\\n                    mstore(add(hashesFront, i), mload(add(leaves, i)))\\n                }\\n                // Compute the back of the hashes.\\n                let hashesBack := add(hashesFront, leavesLength)\\n                // This is the end of the memory for the queue.\\n                // We recycle `flagsLength` to save on stack variables (sometimes save gas).\\n                flagsLength := add(hashesBack, shl(5, flagsLength))\\n\\n                for {} 1 {} {\\n                    // Pop from `hashes`.\\n                    let a := mload(hashesFront)\\n                    // Pop from `hashes`.\\n                    let b := mload(add(hashesFront, 0x20))\\n                    hashesFront := add(hashesFront, 0x40)\\n\\n                    // If the flag is false, load the next proof,\\n                    // else, pops from the queue.\\n                    if iszero(mload(flags)) {\\n                        // Loads the next proof.\\n                        b := mload(proof)\\n                        proof := add(proof, 0x20)\\n                        // Unpop from `hashes`.\\n                        hashesFront := sub(hashesFront, 0x20)\\n                    }\\n\\n                    // Advance to the next flag.\\n                    flags := add(flags, 0x20)\\n\\n                    // Slot of `a` in scratch space.\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\n                    let scratch := shl(5, gt(a, b))\\n                    // Hash the scratch space and push the result onto the queue.\\n                    mstore(scratch, a)\\n                    mstore(xor(scratch, 0x20), b)\\n                    mstore(hashesBack, keccak256(0x00, 0x40))\\n                    hashesBack := add(hashesBack, 0x20)\\n                    if iszero(lt(hashesBack, flagsLength)) { break }\\n                }\\n                isValid :=\\n                    and(\\n                        // Checks if the last value in the queue is same as the root.\\n                        eq(mload(sub(hashesBack, 0x20)), root),\\n                        // And whether all the proofs are used, if required.\\n                        eq(proofEnd, proof)\\n                    )\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns whether all `leaves` exist in the Merkle tree with `root`,\\n    /// given `proof` and `flags`.\\n    ///\\n    /// Note:\\n    /// - Breaking the invariant `flags.length == (leaves.length - 1) + proof.length`\\n    ///   will always return false.\\n    /// - Any non-zero word in the `flags` array is treated as true.\\n    /// - The calldata offset of `proof` must be non-zero\\n    ///   (i.e. `proof` is from a regular Solidity function with a 4-byte selector).\\n    function verifyMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32[] calldata leaves,\\n        bool[] calldata flags\\n    ) internal pure returns (bool isValid) {\\n        // Rebuilds the root by consuming and producing values on a queue.\\n        // The queue starts with the `leaves` array, and goes into a `hashes` array.\\n        // After the process, the last element on the queue is verified\\n        // to be equal to the `root`.\\n        //\\n        // The `flags` array denotes whether the sibling\\n        // should be popped from the queue (`flag == true`), or\\n        // should be popped from the `proof` (`flag == false`).\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the number of flags is correct.\\n            for {} eq(add(leaves.length, proof.length), add(flags.length, 1)) {} {\\n                // For the case where `proof.length + leaves.length == 1`.\\n                if iszero(flags.length) {\\n                    // `isValid = (proof.length == 1 ? proof[0] : leaves[0]) == root`.\\n                    // forgefmt: disable-next-item\\n                    isValid := eq(\\n                        calldataload(\\n                            xor(leaves.offset, mul(xor(proof.offset, leaves.offset), proof.length))\\n                        ),\\n                        root\\n                    )\\n                    break\\n                }\\n\\n                // The required final proof offset if `flagsLength` is not zero, otherwise zero.\\n                let proofEnd := add(proof.offset, shl(5, proof.length))\\n                // We can use the free memory space for the queue.\\n                // We don't need to allocate, since the queue is temporary.\\n                let hashesFront := mload(0x40)\\n                // Copy the leaves into the hashes.\\n                // Sometimes, a little memory expansion costs less than branching.\\n                // Should cost less, even with a high free memory offset of 0x7d00.\\n                calldatacopy(hashesFront, leaves.offset, shl(5, leaves.length))\\n                // Compute the back of the hashes.\\n                let hashesBack := add(hashesFront, shl(5, leaves.length))\\n                // This is the end of the memory for the queue.\\n                // We recycle `flagsLength` to save on stack variables (sometimes save gas).\\n                flags.length := add(hashesBack, shl(5, flags.length))\\n\\n                // We don't need to make a copy of `proof.offset` or `flags.offset`,\\n                // as they are pass-by-value (this trick may not always save gas).\\n\\n                for {} 1 {} {\\n                    // Pop from `hashes`.\\n                    let a := mload(hashesFront)\\n                    // Pop from `hashes`.\\n                    let b := mload(add(hashesFront, 0x20))\\n                    hashesFront := add(hashesFront, 0x40)\\n\\n                    // If the flag is false, load the next proof,\\n                    // else, pops from the queue.\\n                    if iszero(calldataload(flags.offset)) {\\n                        // Loads the next proof.\\n                        b := calldataload(proof.offset)\\n                        proof.offset := add(proof.offset, 0x20)\\n                        // Unpop from `hashes`.\\n                        hashesFront := sub(hashesFront, 0x20)\\n                    }\\n\\n                    // Advance to the next flag offset.\\n                    flags.offset := add(flags.offset, 0x20)\\n\\n                    // Slot of `a` in scratch space.\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\n                    let scratch := shl(5, gt(a, b))\\n                    // Hash the scratch space and push the result onto the queue.\\n                    mstore(scratch, a)\\n                    mstore(xor(scratch, 0x20), b)\\n                    mstore(hashesBack, keccak256(0x00, 0x40))\\n                    hashesBack := add(hashesBack, 0x20)\\n                    if iszero(lt(hashesBack, flags.length)) { break }\\n                }\\n                isValid :=\\n                    and(\\n                        // Checks if the last value in the queue is same as the root.\\n                        eq(mload(sub(hashesBack, 0x20)), root),\\n                        // And whether all the proofs are used, if required.\\n                        eq(proofEnd, proof.offset)\\n                    )\\n                break\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   EMPTY CALLDATA HELPERS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns an empty calldata bytes32 array.\\n    function emptyProof() internal pure returns (bytes32[] calldata proof) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            proof.length := 0\\n        }\\n    }\\n\\n    /// @dev Returns an empty calldata bytes32 array.\\n    function emptyLeaves() internal pure returns (bytes32[] calldata leaves) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            leaves.length := 0\\n        }\\n    }\\n\\n    /// @dev Returns an empty calldata bool array.\\n    function emptyFlags() internal pure returns (bool[] calldata flags) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            flags.length := 0\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/LibBitmap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {LibBit} from \\\"./LibBit.sol\\\";\\n\\n/// @notice Library for storage of packed unsigned booleans.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBitmap.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibBitmap.sol)\\n/// @author Modified from Solidity-Bits (https://github.com/estarriolvetch/solidity-bits/blob/main/contracts/BitMaps.sol)\\nlibrary LibBitmap {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The constant returned when a bitmap scan does not find a result.\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev A bitmap in storage.\\n    struct Bitmap {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         OPERATIONS                         */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the boolean value of the bit at `index` in `bitmap`.\\n    function get(Bitmap storage bitmap, uint256 index) internal view returns (bool isSet) {\\n        // It is better to set `isSet` to either 0 or 1, than zero vs non-zero.\\n        // Both cost the same amount of gas, but the former allows the returned value\\n        // to be reused without cleaning the upper bits.\\n        uint256 b = (bitmap.map[index >> 8] >> (index & 0xff)) & 1;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            isSet := b\\n        }\\n    }\\n\\n    /// @dev Updates the bit at `index` in `bitmap` to true.\\n    function set(Bitmap storage bitmap, uint256 index) internal {\\n        bitmap.map[index >> 8] |= (1 << (index & 0xff));\\n    }\\n\\n    /// @dev Updates the bit at `index` in `bitmap` to false.\\n    function unset(Bitmap storage bitmap, uint256 index) internal {\\n        bitmap.map[index >> 8] &= ~(1 << (index & 0xff));\\n    }\\n\\n    /// @dev Flips the bit at `index` in `bitmap`.\\n    /// Returns the boolean result of the flipped bit.\\n    function toggle(Bitmap storage bitmap, uint256 index) internal returns (bool newIsSet) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, bitmap.slot)\\n            mstore(0x00, shr(8, index))\\n            let storageSlot := keccak256(0x00, 0x40)\\n            let shift := and(index, 0xff)\\n            let storageValue := xor(sload(storageSlot), shl(shift, 1))\\n            // It makes sense to return the `newIsSet`,\\n            // as it allow us to skip an additional warm `sload`,\\n            // and it costs minimal gas (about 15),\\n            // which may be optimized away if the returned value is unused.\\n            newIsSet := and(1, shr(shift, storageValue))\\n            sstore(storageSlot, storageValue)\\n        }\\n    }\\n\\n    /// @dev Updates the bit at `index` in `bitmap` to `shouldSet`.\\n    function setTo(Bitmap storage bitmap, uint256 index, bool shouldSet) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, bitmap.slot)\\n            mstore(0x00, shr(8, index))\\n            let storageSlot := keccak256(0x00, 0x40)\\n            let storageValue := sload(storageSlot)\\n            let shift := and(index, 0xff)\\n            sstore(\\n                storageSlot,\\n                // Unsets the bit at `shift` via `and`, then sets its new value via `or`.\\n                or(and(storageValue, not(shl(shift, 1))), shl(shift, iszero(iszero(shouldSet))))\\n            )\\n        }\\n    }\\n\\n    /// @dev Consecutively sets `amount` of bits starting from the bit at `start`.\\n    function setBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let max := not(0)\\n            let shift := and(start, 0xff)\\n            mstore(0x20, bitmap.slot)\\n            mstore(0x00, shr(8, start))\\n            if iszero(lt(add(shift, amount), 257)) {\\n                let storageSlot := keccak256(0x00, 0x40)\\n                sstore(storageSlot, or(sload(storageSlot), shl(shift, max)))\\n                let bucket := add(mload(0x00), 1)\\n                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))\\n                amount := and(add(amount, shift), 0xff)\\n                shift := 0\\n                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {\\n                    mstore(0x00, bucket)\\n                    sstore(keccak256(0x00, 0x40), max)\\n                }\\n                mstore(0x00, bucket)\\n            }\\n            let storageSlot := keccak256(0x00, 0x40)\\n            sstore(storageSlot, or(sload(storageSlot), shl(shift, shr(sub(256, amount), max))))\\n        }\\n    }\\n\\n    /// @dev Consecutively unsets `amount` of bits starting from the bit at `start`.\\n    function unsetBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let shift := and(start, 0xff)\\n            mstore(0x20, bitmap.slot)\\n            mstore(0x00, shr(8, start))\\n            if iszero(lt(add(shift, amount), 257)) {\\n                let storageSlot := keccak256(0x00, 0x40)\\n                sstore(storageSlot, and(sload(storageSlot), not(shl(shift, not(0)))))\\n                let bucket := add(mload(0x00), 1)\\n                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))\\n                amount := and(add(amount, shift), 0xff)\\n                shift := 0\\n                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {\\n                    mstore(0x00, bucket)\\n                    sstore(keccak256(0x00, 0x40), 0)\\n                }\\n                mstore(0x00, bucket)\\n            }\\n            let storageSlot := keccak256(0x00, 0x40)\\n            sstore(\\n                storageSlot, and(sload(storageSlot), not(shl(shift, shr(sub(256, amount), not(0)))))\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns number of set bits within a range by\\n    /// scanning `amount` of bits starting from the bit at `start`.\\n    function popCount(Bitmap storage bitmap, uint256 start, uint256 amount)\\n        internal\\n        view\\n        returns (uint256 count)\\n    {\\n        unchecked {\\n            uint256 bucket = start >> 8;\\n            uint256 shift = start & 0xff;\\n            if (!(amount + shift < 257)) {\\n                count = LibBit.popCount(bitmap.map[bucket] >> shift);\\n                uint256 bucketEnd = bucket + ((amount + shift) >> 8);\\n                amount = (amount + shift) & 0xff;\\n                shift = 0;\\n                for (++bucket; bucket != bucketEnd; ++bucket) {\\n                    count += LibBit.popCount(bitmap.map[bucket]);\\n                }\\n            }\\n            count += LibBit.popCount((bitmap.map[bucket] >> shift) << (256 - amount));\\n        }\\n    }\\n\\n    /// @dev Returns the index of the most significant set bit before the bit at `before`.\\n    /// If no set bit is found, returns `NOT_FOUND`.\\n    function findLastSet(Bitmap storage bitmap, uint256 before)\\n        internal\\n        view\\n        returns (uint256 setBitIndex)\\n    {\\n        uint256 bucket;\\n        uint256 bucketBits;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            setBitIndex := not(0)\\n            bucket := shr(8, before)\\n            mstore(0x00, bucket)\\n            mstore(0x20, bitmap.slot)\\n            let offset := and(0xff, not(before)) // `256 - (255 & before) - 1`.\\n            bucketBits := shr(offset, shl(offset, sload(keccak256(0x00, 0x40))))\\n            if iszero(or(bucketBits, iszero(bucket))) {\\n                for {} 1 {} {\\n                    bucket := add(bucket, setBitIndex) // `sub(bucket, 1)`.\\n                    mstore(0x00, bucket)\\n                    bucketBits := sload(keccak256(0x00, 0x40))\\n                    if or(bucketBits, iszero(bucket)) { break }\\n                }\\n            }\\n        }\\n        if (bucketBits != 0) {\\n            setBitIndex = (bucket << 8) | LibBit.fls(bucketBits);\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                setBitIndex := or(setBitIndex, sub(0, gt(setBitIndex, before)))\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/SignatureCheckerLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Signature verification helper that supports both ECDSA signatures from EOAs\\n/// and ERC1271 signatures from smart contract wallets like Argent and Gnosis safe.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SignatureCheckerLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/SignatureChecker.sol)\\n///\\n/// @dev Note:\\n/// - The signature checking functions use the ecrecover precompile (0x1).\\n/// - The `bytes memory signature` variants use the identity precompile (0x4)\\n///   to copy memory internally.\\n/// - Unlike ECDSA signatures, contract signatures are revocable.\\n/// - As of Solady version 0.0.134, all `bytes signature` variants accept both\\n///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.\\n///   See: https://eips.ethereum.org/EIPS/eip-2098\\n///   This is for calldata efficiency on smart accounts prevalent on L2s.\\n///\\n/// WARNING! Do NOT use signatures as unique identifiers:\\n/// - Use a nonce in the digest to prevent replay attacks on the same contract.\\n/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.\\n///   EIP-712 also enables readable signing of typed data for better user safety.\\n/// This implementation does NOT check if a signature is non-malleable.\\nlibrary SignatureCheckerLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*               SIGNATURE CHECKING OPERATIONS                */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits of `signer` in case they are dirty.\\n            for { signer := shr(96, shl(96, signer)) } signer {} {\\n                let m := mload(0x40)\\n                mstore(0x00, hash)\\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\\n                if eq(mload(signature), 64) {\\n                    let vs := mload(add(signature, 0x40))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                    let t :=\\n                        staticcall(\\n                            gas(), // Amount of gas left for the transaction.\\n                            1, // Address of `ecrecover`.\\n                            0x00, // Start of input.\\n                            0x80, // Size of input.\\n                            0x01, // Start of output.\\n                            0x20 // Size of output.\\n                        )\\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                        isValid := 1\\n                        mstore(0x60, 0) // Restore the zero slot.\\n                        mstore(0x40, m) // Restore the free memory pointer.\\n                        break\\n                    }\\n                }\\n                if eq(mload(signature), 65) {\\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\\n                    let t :=\\n                        staticcall(\\n                            gas(), // Amount of gas left for the transaction.\\n                            1, // Address of `ecrecover`.\\n                            0x00, // Start of input.\\n                            0x80, // Size of input.\\n                            0x01, // Start of output.\\n                            0x20 // Size of output.\\n                        )\\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                        isValid := 1\\n                        mstore(0x60, 0) // Restore the zero slot.\\n                        mstore(0x40, m) // Restore the free memory pointer.\\n                        break\\n                    }\\n                }\\n                mstore(0x60, 0) // Restore the zero slot.\\n                mstore(0x40, m) // Restore the free memory pointer.\\n\\n                let f := shl(224, 0x1626ba7e)\\n                mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m, 0x04), hash)\\n                let d := add(m, 0x24)\\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n                // Copy the `signature` over.\\n                let n := add(0x20, mload(signature))\\n                pop(staticcall(gas(), 4, signature, n, add(m, 0x44), n))\\n                // forgefmt: disable-next-item\\n                isValid := and(\\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                    eq(mload(d), f),\\n                    // Whether the staticcall does not revert.\\n                    // This must be placed at the end of the `and` clause,\\n                    // as the arguments are evaluated from right to left.\\n                    staticcall(\\n                        gas(), // Remaining gas.\\n                        signer, // The `signer` address.\\n                        m, // Offset of calldata in memory.\\n                        add(returndatasize(), 0x44), // Length of calldata in memory.\\n                        d, // Offset of returndata.\\n                        0x20 // Length of returndata to write.\\n                    )\\n                )\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\\n    function isValidSignatureNowCalldata(address signer, bytes32 hash, bytes calldata signature)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits of `signer` in case they are dirty.\\n            for { signer := shr(96, shl(96, signer)) } signer {} {\\n                let m := mload(0x40)\\n                mstore(0x00, hash)\\n                if eq(signature.length, 64) {\\n                    let vs := calldataload(add(signature.offset, 0x20))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                    let t :=\\n                        staticcall(\\n                            gas(), // Amount of gas left for the transaction.\\n                            1, // Address of `ecrecover`.\\n                            0x00, // Start of input.\\n                            0x80, // Size of input.\\n                            0x01, // Start of output.\\n                            0x20 // Size of output.\\n                        )\\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                        isValid := 1\\n                        mstore(0x60, 0) // Restore the zero slot.\\n                        mstore(0x40, m) // Restore the free memory pointer.\\n                        break\\n                    }\\n                }\\n                if eq(signature.length, 65) {\\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\n                    calldatacopy(0x40, signature.offset, 0x40) // `r`, `s`.\\n                    let t :=\\n                        staticcall(\\n                            gas(), // Amount of gas left for the transaction.\\n                            1, // Address of `ecrecover`.\\n                            0x00, // Start of input.\\n                            0x80, // Size of input.\\n                            0x01, // Start of output.\\n                            0x20 // Size of output.\\n                        )\\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                        isValid := 1\\n                        mstore(0x60, 0) // Restore the zero slot.\\n                        mstore(0x40, m) // Restore the free memory pointer.\\n                        break\\n                    }\\n                }\\n                mstore(0x60, 0) // Restore the zero slot.\\n                mstore(0x40, m) // Restore the free memory pointer.\\n\\n                let f := shl(224, 0x1626ba7e)\\n                mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m, 0x04), hash)\\n                let d := add(m, 0x24)\\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n                mstore(add(m, 0x44), signature.length)\\n                // Copy the `signature` over.\\n                calldatacopy(add(m, 0x64), signature.offset, signature.length)\\n                // forgefmt: disable-next-item\\n                isValid := and(\\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                    eq(mload(d), f),\\n                    // Whether the staticcall does not revert.\\n                    // This must be placed at the end of the `and` clause,\\n                    // as the arguments are evaluated from right to left.\\n                    staticcall(\\n                        gas(), // Remaining gas.\\n                        signer, // The `signer` address.\\n                        m, // Offset of calldata in memory.\\n                        add(signature.length, 0x64), // Length of calldata in memory.\\n                        d, // Offset of returndata.\\n                        0x20 // Length of returndata to write.\\n                    )\\n                )\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `signer` and `hash`.\\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\\n    function isValidSignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits of `signer` in case they are dirty.\\n            for { signer := shr(96, shl(96, signer)) } signer {} {\\n                let m := mload(0x40)\\n                mstore(0x00, hash)\\n                mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                mstore(0x40, r) // `r`.\\n                mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                let t :=\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        1, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                    isValid := 1\\n                    mstore(0x60, 0) // Restore the zero slot.\\n                    mstore(0x40, m) // Restore the free memory pointer.\\n                    break\\n                }\\n\\n                let f := shl(224, 0x1626ba7e)\\n                mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m, 0x04), hash)\\n                let d := add(m, 0x24)\\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n                mstore(add(m, 0x44), 65) // Length of the signature.\\n                mstore(add(m, 0x64), r) // `r`.\\n                mstore(add(m, 0x84), mload(0x60)) // `s`.\\n                mstore8(add(m, 0xa4), mload(0x20)) // `v`.\\n                // forgefmt: disable-next-item\\n                isValid := and(\\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                    eq(mload(d), f),\\n                    // Whether the staticcall does not revert.\\n                    // This must be placed at the end of the `and` clause,\\n                    // as the arguments are evaluated from right to left.\\n                    staticcall(\\n                        gas(), // Remaining gas.\\n                        signer, // The `signer` address.\\n                        m, // Offset of calldata in memory.\\n                        0xa5, // Length of calldata in memory.\\n                        d, // Offset of returndata.\\n                        0x20 // Length of returndata to write.\\n                    )\\n                )\\n                mstore(0x60, 0) // Restore the zero slot.\\n                mstore(0x40, m) // Restore the free memory pointer.\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `signer` and `hash`.\\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\\n    function isValidSignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits of `signer` in case they are dirty.\\n            for { signer := shr(96, shl(96, signer)) } signer {} {\\n                let m := mload(0x40)\\n                mstore(0x00, hash)\\n                mstore(0x20, and(v, 0xff)) // `v`.\\n                mstore(0x40, r) // `r`.\\n                mstore(0x60, s) // `s`.\\n                let t :=\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        1, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                    isValid := 1\\n                    mstore(0x60, 0) // Restore the zero slot.\\n                    mstore(0x40, m) // Restore the free memory pointer.\\n                    break\\n                }\\n\\n                let f := shl(224, 0x1626ba7e)\\n                mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m, 0x04), hash)\\n                let d := add(m, 0x24)\\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n                mstore(add(m, 0x44), 65) // Length of the signature.\\n                mstore(add(m, 0x64), r) // `r`.\\n                mstore(add(m, 0x84), s) // `s`.\\n                mstore8(add(m, 0xa4), v) // `v`.\\n                // forgefmt: disable-next-item\\n                isValid := and(\\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                    eq(mload(d), f),\\n                    // Whether the staticcall does not revert.\\n                    // This must be placed at the end of the `and` clause,\\n                    // as the arguments are evaluated from right to left.\\n                    staticcall(\\n                        gas(), // Remaining gas.\\n                        signer, // The `signer` address.\\n                        m, // Offset of calldata in memory.\\n                        0xa5, // Length of calldata in memory.\\n                        d, // Offset of returndata.\\n                        0x20 // Length of returndata to write.\\n                    )\\n                )\\n                mstore(0x60, 0) // Restore the zero slot.\\n                mstore(0x40, m) // Restore the free memory pointer.\\n                break\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     ERC1271 OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes memory signature)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            let f := shl(224, 0x1626ba7e)\\n            mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n            mstore(add(m, 0x04), hash)\\n            let d := add(m, 0x24)\\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n            // Copy the `signature` over.\\n            let n := add(0x20, mload(signature))\\n            pop(staticcall(gas(), 4, signature, n, add(m, 0x44), n))\\n            // forgefmt: disable-next-item\\n            isValid := and(\\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                eq(mload(d), f),\\n                // Whether the staticcall does not revert.\\n                // This must be placed at the end of the `and` clause,\\n                // as the arguments are evaluated from right to left.\\n                staticcall(\\n                    gas(), // Remaining gas.\\n                    signer, // The `signer` address.\\n                    m, // Offset of calldata in memory.\\n                    add(returndatasize(), 0x44), // Length of calldata in memory.\\n                    d, // Offset of returndata.\\n                    0x20 // Length of returndata to write.\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\\n    function isValidERC1271SignatureNowCalldata(\\n        address signer,\\n        bytes32 hash,\\n        bytes calldata signature\\n    ) internal view returns (bool isValid) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            let f := shl(224, 0x1626ba7e)\\n            mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n            mstore(add(m, 0x04), hash)\\n            let d := add(m, 0x24)\\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n            mstore(add(m, 0x44), signature.length)\\n            // Copy the `signature` over.\\n            calldatacopy(add(m, 0x64), signature.offset, signature.length)\\n            // forgefmt: disable-next-item\\n            isValid := and(\\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                eq(mload(d), f),\\n                // Whether the staticcall does not revert.\\n                // This must be placed at the end of the `and` clause,\\n                // as the arguments are evaluated from right to left.\\n                staticcall(\\n                    gas(), // Remaining gas.\\n                    signer, // The `signer` address.\\n                    m, // Offset of calldata in memory.\\n                    add(signature.length, 0x64), // Length of calldata in memory.\\n                    d, // Offset of returndata.\\n                    0x20 // Length of returndata to write.\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `hash`\\n    /// for an ERC1271 `signer` contract.\\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            let f := shl(224, 0x1626ba7e)\\n            mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n            mstore(add(m, 0x04), hash)\\n            let d := add(m, 0x24)\\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n            mstore(add(m, 0x44), 65) // Length of the signature.\\n            mstore(add(m, 0x64), r) // `r`.\\n            mstore(add(m, 0x84), shr(1, shl(1, vs))) // `s`.\\n            mstore8(add(m, 0xa4), add(shr(255, vs), 27)) // `v`.\\n            // forgefmt: disable-next-item\\n            isValid := and(\\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                eq(mload(d), f),\\n                // Whether the staticcall does not revert.\\n                // This must be placed at the end of the `and` clause,\\n                // as the arguments are evaluated from right to left.\\n                staticcall(\\n                    gas(), // Remaining gas.\\n                    signer, // The `signer` address.\\n                    m, // Offset of calldata in memory.\\n                    0xa5, // Length of calldata in memory.\\n                    d, // Offset of returndata.\\n                    0x20 // Length of returndata to write.\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `hash`\\n    /// for an ERC1271 `signer` contract.\\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            let f := shl(224, 0x1626ba7e)\\n            mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n            mstore(add(m, 0x04), hash)\\n            let d := add(m, 0x24)\\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n            mstore(add(m, 0x44), 65) // Length of the signature.\\n            mstore(add(m, 0x64), r) // `r`.\\n            mstore(add(m, 0x84), s) // `s`.\\n            mstore8(add(m, 0xa4), v) // `v`.\\n            // forgefmt: disable-next-item\\n            isValid := and(\\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                eq(mload(d), f),\\n                // Whether the staticcall does not revert.\\n                // This must be placed at the end of the `and` clause,\\n                // as the arguments are evaluated from right to left.\\n                staticcall(\\n                    gas(), // Remaining gas.\\n                    signer, // The `signer` address.\\n                    m, // Offset of calldata in memory.\\n                    0xa5, // Length of calldata in memory.\\n                    d, // Offset of returndata.\\n                    0x20 // Length of returndata to write.\\n                )\\n            )\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     HASHING OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, hash) // Store into scratch space for keccak256.\\n            mstore(0x00, \\\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19Ethereum Signed Message:\\\\n32\\\") // 28 bytes.\\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\\n        }\\n    }\\n\\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    /// Note: Supports lengths of `s` up to 999999 bytes.\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let sLength := mload(s)\\n            let o := 0x20\\n            mstore(o, \\\"\\\\x19Ethereum Signed Message:\\\\n\\\") // 26 bytes, zero-right-padded.\\n            mstore(0x00, 0x00)\\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\\n            for { let temp := sLength } 1 {} {\\n                o := sub(o, 1)\\n                mstore8(o, add(48, mod(temp, 10)))\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\\n            mstore(s, sLength) // Restore the length.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   EMPTY CALLDATA HELPERS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns an empty calldata bytes.\\n    function emptySignature() internal pure returns (bytes calldata signature) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            signature.length := 0\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/LibZip.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for compressing and decompressing bytes.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibZip.sol)\\n/// @author Calldata compression by clabby (https://github.com/clabby/op-kompressor)\\n/// @author FastLZ by ariya (https://github.com/ariya/FastLZ)\\n///\\n/// @dev Note:\\n/// The accompanying solady.js library includes implementations of\\n/// FastLZ and calldata operations for convenience.\\nlibrary LibZip {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     FAST LZ OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // LZ77 implementation based on FastLZ.\\n    // Equivalent to level 1 compression and decompression at the following commit:\\n    // https://github.com/ariya/FastLZ/commit/344eb4025f9ae866ebf7a2ec48850f7113a97a42\\n    // Decompression is backwards compatible.\\n\\n    /// @dev Returns the compressed `data`.\\n    function flzCompress(bytes memory data) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function ms8(d_, v_) -> _d {\\n                mstore8(d_, v_)\\n                _d := add(d_, 1)\\n            }\\n            function u24(p_) -> _u {\\n                let w := mload(p_)\\n                _u := or(shl(16, byte(2, w)), or(shl(8, byte(1, w)), byte(0, w)))\\n            }\\n            function cmp(p_, q_, e_) -> _l {\\n                for { e_ := sub(e_, q_) } lt(_l, e_) { _l := add(_l, 1) } {\\n                    e_ := mul(iszero(byte(0, xor(mload(add(p_, _l)), mload(add(q_, _l))))), e_)\\n                }\\n            }\\n            function literals(runs_, src_, dest_) -> _o {\\n                for { _o := dest_ } iszero(lt(runs_, 0x20)) { runs_ := sub(runs_, 0x20) } {\\n                    mstore(ms8(_o, 31), mload(src_))\\n                    _o := add(_o, 0x21)\\n                    src_ := add(src_, 0x20)\\n                }\\n                if iszero(runs_) { leave }\\n                mstore(ms8(_o, sub(runs_, 1)), mload(src_))\\n                _o := add(1, add(_o, runs_))\\n            }\\n            function match(l_, d_, o_) -> _o {\\n                for { d_ := sub(d_, 1) } iszero(lt(l_, 263)) { l_ := sub(l_, 262) } {\\n                    o_ := ms8(ms8(ms8(o_, add(224, shr(8, d_))), 253), and(0xff, d_))\\n                }\\n                if iszero(lt(l_, 7)) {\\n                    _o := ms8(ms8(ms8(o_, add(224, shr(8, d_))), sub(l_, 7)), and(0xff, d_))\\n                    leave\\n                }\\n                _o := ms8(ms8(o_, add(shl(5, l_), shr(8, d_))), and(0xff, d_))\\n            }\\n            function setHash(i_, v_) {\\n                let p := add(mload(0x40), shl(2, i_))\\n                mstore(p, xor(mload(p), shl(224, xor(shr(224, mload(p)), v_))))\\n            }\\n            function getHash(i_) -> _h {\\n                _h := shr(224, mload(add(mload(0x40), shl(2, i_))))\\n            }\\n            function hash(v_) -> _r {\\n                _r := and(shr(19, mul(2654435769, v_)), 0x1fff)\\n            }\\n            function setNextHash(ip_, ipStart_) -> _ip {\\n                setHash(hash(u24(ip_)), sub(ip_, ipStart_))\\n                _ip := add(ip_, 1)\\n            }\\n            codecopy(mload(0x40), codesize(), 0x8000) // Zeroize the hashmap.\\n            let op := add(mload(0x40), 0x8000)\\n            let a := add(data, 0x20)\\n            let ipStart := a\\n            let ipLimit := sub(add(ipStart, mload(data)), 13)\\n            for { let ip := add(2, a) } lt(ip, ipLimit) {} {\\n                let r := 0\\n                let d := 0\\n                for {} 1 {} {\\n                    let s := u24(ip)\\n                    let h := hash(s)\\n                    r := add(ipStart, getHash(h))\\n                    setHash(h, sub(ip, ipStart))\\n                    d := sub(ip, r)\\n                    if iszero(lt(ip, ipLimit)) { break }\\n                    ip := add(ip, 1)\\n                    if iszero(gt(d, 0x1fff)) { if eq(s, u24(r)) { break } }\\n                }\\n                if iszero(lt(ip, ipLimit)) { break }\\n                ip := sub(ip, 1)\\n                if gt(ip, a) { op := literals(sub(ip, a), a, op) }\\n                let l := cmp(add(r, 3), add(ip, 3), add(ipLimit, 9))\\n                op := match(l, d, op)\\n                ip := setNextHash(setNextHash(add(ip, l), ipStart), ipStart)\\n                a := ip\\n            }\\n            op := literals(sub(add(ipStart, mload(data)), a), a, op)\\n            result := mload(0x40)\\n            let t := add(result, 0x8000)\\n            let n := sub(op, t)\\n            mstore(result, n) // Store the length.\\n            // Copy the result to compact the memory, overwriting the hashmap.\\n            let o := add(result, 0x20)\\n            for { let i } lt(i, n) { i := add(i, 0x20) } { mstore(add(o, i), mload(add(t, i))) }\\n            mstore(add(o, n), 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(add(o, n), 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Returns the decompressed `data`.\\n    function flzDecompress(bytes memory data) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := 0\\n            let end := add(add(data, 0x20), mload(data))\\n            result := mload(0x40)\\n            let op := add(result, 0x20)\\n            for { data := add(data, 0x20) } lt(data, end) {} {\\n                let w := mload(data)\\n                let c := byte(0, w)\\n                let t := shr(5, c)\\n                if iszero(t) {\\n                    mstore(add(op, n), mload(add(data, 1)))\\n                    data := add(data, add(2, c))\\n                    n := add(n, add(1, c))\\n                    continue\\n                }\\n                let g := eq(t, 7)\\n                let l := add(2, xor(t, mul(g, xor(t, add(7, byte(1, w))))))\\n                for {\\n                    let s := add(add(shl(8, and(0x1f, c)), byte(add(1, g), w)), 1)\\n                    let r := add(op, sub(n, s))\\n                    let o := add(op, n)\\n                    let f := xor(s, mul(gt(s, 0x20), xor(s, 0x20)))\\n                    let j := 0\\n                } 1 {} {\\n                    mstore(add(o, j), mload(add(r, j)))\\n                    j := add(j, f)\\n                    if iszero(lt(j, l)) { break }\\n                }\\n                data := add(data, add(2, g))\\n                n := add(n, l)\\n            }\\n            mstore(result, n) // Store the length.\\n            let o := add(add(result, 0x20), n)\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                    CALLDATA OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // Calldata compression and decompression using selective run length encoding:\\n    // - Sequences of 0x00 (up to 128 consecutive).\\n    // - Sequences of 0xff (up to 32 consecutive).\\n    //\\n    // A run length encoded block consists of two bytes:\\n    // (0) 0x00\\n    // (1) A control byte with the following bit layout:\\n    //     - [7]     `0: 0x00, 1: 0xff`.\\n    //     - [0..6]  `runLength - 1`.\\n    //\\n    // The first 4 bytes are bitwise negated so that the compressed calldata\\n    // can be dispatched into the `fallback` and `receive` functions.\\n\\n    /// @dev Returns the compressed `data`.\\n    function cdCompress(bytes memory data) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function rle(v_, o_, d_) -> _o, _d {\\n                mstore(o_, shl(240, or(and(0xff, add(d_, 0xff)), and(0x80, v_))))\\n                _o := add(o_, 2)\\n            }\\n            result := mload(0x40)\\n            let o := add(result, 0x20)\\n            let z := 0 // Number of consecutive 0x00.\\n            let y := 0 // Number of consecutive 0xff.\\n            for { let end := add(data, mload(data)) } iszero(eq(data, end)) {} {\\n                data := add(data, 1)\\n                let c := byte(31, mload(data))\\n                if iszero(c) {\\n                    if y { o, y := rle(0xff, o, y) }\\n                    z := add(z, 1)\\n                    if eq(z, 0x80) { o, z := rle(0x00, o, 0x80) }\\n                    continue\\n                }\\n                if eq(c, 0xff) {\\n                    if z { o, z := rle(0x00, o, z) }\\n                    y := add(y, 1)\\n                    if eq(y, 0x20) { o, y := rle(0xff, o, 0x20) }\\n                    continue\\n                }\\n                if y { o, y := rle(0xff, o, y) }\\n                if z { o, z := rle(0x00, o, z) }\\n                mstore8(o, c)\\n                o := add(o, 1)\\n            }\\n            if y { o, y := rle(0xff, o, y) }\\n            if z { o, z := rle(0x00, o, z) }\\n            // Bitwise negate the first 4 bytes.\\n            mstore(add(result, 4), not(mload(add(result, 4))))\\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Returns the decompressed `data`.\\n    function cdDecompress(bytes memory data) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(data) {\\n                result := mload(0x40)\\n                let o := add(result, 0x20)\\n                let s := add(data, 4)\\n                let v := mload(s)\\n                let end := add(data, mload(data))\\n                mstore(s, not(v)) // Bitwise negate the first 4 bytes.\\n                for {} lt(data, end) {} {\\n                    data := add(data, 1)\\n                    let c := byte(31, mload(data))\\n                    if iszero(c) {\\n                        data := add(data, 1)\\n                        let d := byte(31, mload(data))\\n                        // Fill with either 0xff or 0x00.\\n                        mstore(o, not(0))\\n                        if iszero(gt(d, 0x7f)) { codecopy(o, codesize(), add(d, 1)) }\\n                        o := add(o, add(and(d, 0x7f), 1))\\n                        continue\\n                    }\\n                    mstore8(o, c)\\n                    o := add(o, 1)\\n                }\\n                mstore(s, v) // Restore the first 4 bytes.\\n                mstore(result, sub(o, add(result, 0x20))) // Store the length.\\n                mstore(o, 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev To be called in the `receive` and `fallback` functions.\\n    /// ```\\n    ///     receive() external payable { LibZip.cdFallback(); }\\n    ///     fallback() external payable { LibZip.cdFallback(); }\\n    /// ```\\n    /// For efficiency, this function will directly return the results, terminating the context.\\n    /// If called internally, it must be called at the end of the function.\\n    function cdFallback() internal {\\n        assembly {\\n            if iszero(calldatasize()) { return(calldatasize(), calldatasize()) }\\n            let o := 0\\n            let f := not(3) // For negating the first 4 bytes.\\n            for { let i := 0 } lt(i, calldatasize()) {} {\\n                let c := byte(0, xor(add(i, f), calldataload(i)))\\n                i := add(i, 1)\\n                if iszero(c) {\\n                    let d := byte(0, xor(add(i, f), calldataload(i)))\\n                    i := add(i, 1)\\n                    // Fill with either 0xff or 0x00.\\n                    mstore(o, not(0))\\n                    if iszero(gt(d, 0x7f)) { codecopy(o, codesize(), add(d, 1)) }\\n                    o := add(o, add(and(d, 0x7f), 1))\\n                    continue\\n                }\\n                mstore8(o, c)\\n                o := add(o, 1)\\n            }\\n            let success := delegatecall(gas(), address(), 0x00, o, codesize(), 0x00)\\n            returndatacopy(0x00, 0x00, returndatasize())\\n            if iszero(success) { revert(0x00, returndatasize()) }\\n            return(0x00, returndatasize())\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/LibMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for storage of packed unsigned integers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibMap.sol)\\nlibrary LibMap {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev A uint8 map in storage.\\n    struct Uint8Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /// @dev A uint16 map in storage.\\n    struct Uint16Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /// @dev A uint32 map in storage.\\n    struct Uint32Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /// @dev A uint40 map in storage. Useful for storing timestamps up to 34841 A.D.\\n    struct Uint40Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /// @dev A uint64 map in storage.\\n    struct Uint64Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /// @dev A uint128 map in storage.\\n    struct Uint128Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     GETTERS / SETTERS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the uint8 value at `index` in `map`.\\n    function get(Uint8Map storage map, uint256 index) internal view returns (uint8 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(5, index))\\n            result := byte(and(31, not(index)), sload(keccak256(0x00, 0x40)))\\n        }\\n    }\\n\\n    /// @dev Updates the uint8 value at `index` in `map`.\\n    function set(Uint8Map storage map, uint256 index, uint8 value) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(5, index))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            mstore(0x00, sload(s))\\n            mstore8(and(31, not(index)), value)\\n            sstore(s, mload(0x00))\\n        }\\n    }\\n\\n    /// @dev Returns the uint16 value at `index` in `map`.\\n    function get(Uint16Map storage map, uint256 index) internal view returns (uint16 result) {\\n        result = uint16(map.map[index >> 4] >> ((index & 15) << 4));\\n    }\\n\\n    /// @dev Updates the uint16 value at `index` in `map`.\\n    function set(Uint16Map storage map, uint256 index, uint16 value) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(4, index))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := shl(4, and(index, 15)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n\\n    /// @dev Returns the uint32 value at `index` in `map`.\\n    function get(Uint32Map storage map, uint256 index) internal view returns (uint32 result) {\\n        result = uint32(map.map[index >> 3] >> ((index & 7) << 5));\\n    }\\n\\n    /// @dev Updates the uint32 value at `index` in `map`.\\n    function set(Uint32Map storage map, uint256 index, uint32 value) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(3, index))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := shl(5, and(index, 7)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n\\n    /// @dev Returns the uint40 value at `index` in `map`.\\n    function get(Uint40Map storage map, uint256 index) internal view returns (uint40 result) {\\n        unchecked {\\n            result = uint40(map.map[index / 6] >> ((index % 6) * 40));\\n        }\\n    }\\n\\n    /// @dev Updates the uint40 value at `index` in `map`.\\n    function set(Uint40Map storage map, uint256 index, uint40 value) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, div(index, 6))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := mul(40, mod(index, 6)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n\\n    /// @dev Returns the uint64 value at `index` in `map`.\\n    function get(Uint64Map storage map, uint256 index) internal view returns (uint64 result) {\\n        result = uint64(map.map[index >> 2] >> ((index & 3) << 6));\\n    }\\n\\n    /// @dev Updates the uint64 value at `index` in `map`.\\n    function set(Uint64Map storage map, uint256 index, uint64 value) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(2, index))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := shl(6, and(index, 3)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffffffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n\\n    /// @dev Returns the uint128 value at `index` in `map`.\\n    function get(Uint128Map storage map, uint256 index) internal view returns (uint128 result) {\\n        result = uint128(map.map[index >> 1] >> ((index & 1) << 7));\\n    }\\n\\n    /// @dev Updates the uint128 value at `index` in `map`.\\n    function set(Uint128Map storage map, uint256 index, uint128 value) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(1, index))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := shl(7, and(index, 1)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffffffffffffffffffffffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n\\n    /// @dev Returns the value at `index` in `map`.\\n    function get(mapping(uint256 => uint256) storage map, uint256 index, uint256 bitWidth)\\n        internal\\n        view\\n        returns (uint256 result)\\n    {\\n        unchecked {\\n            uint256 d = _rawDiv(256, bitWidth); // Bucket size.\\n            uint256 m = (1 << bitWidth) - 1; // Value mask.\\n            result = (map[_rawDiv(index, d)] >> (_rawMod(index, d) * bitWidth)) & m;\\n        }\\n    }\\n\\n    /// @dev Updates the value at `index` in `map`.\\n    function set(\\n        mapping(uint256 => uint256) storage map,\\n        uint256 index,\\n        uint256 value,\\n        uint256 bitWidth\\n    ) internal {\\n        unchecked {\\n            uint256 d = _rawDiv(256, bitWidth); // Bucket size.\\n            uint256 m = (1 << bitWidth) - 1; // Value mask.\\n            uint256 o = _rawMod(index, d) * bitWidth; // Storage slot offset (bits).\\n            map[_rawDiv(index, d)] ^= (((map[_rawDiv(index, d)] >> o) ^ value) & m) << o;\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       BINARY SEARCH                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // The following functions search in the range of [`start`, `end`)\\n    // (i.e. `start <= index < end`).\\n    // The range must be sorted in ascending order.\\n    // `index` precedence: equal to > nearest before > nearest after.\\n    // An invalid search range will simply return `(found = false, index = start)`.\\n\\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\\n    function searchSorted(Uint8Map storage map, uint8 needle, uint256 start, uint256 end)\\n        internal\\n        view\\n        returns (bool found, uint256 index)\\n    {\\n        return searchSorted(map.map, needle, start, end, 8);\\n    }\\n\\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\\n    function searchSorted(Uint16Map storage map, uint16 needle, uint256 start, uint256 end)\\n        internal\\n        view\\n        returns (bool found, uint256 index)\\n    {\\n        return searchSorted(map.map, needle, start, end, 16);\\n    }\\n\\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\\n    function searchSorted(Uint32Map storage map, uint32 needle, uint256 start, uint256 end)\\n        internal\\n        view\\n        returns (bool found, uint256 index)\\n    {\\n        return searchSorted(map.map, needle, start, end, 32);\\n    }\\n\\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\\n    function searchSorted(Uint40Map storage map, uint40 needle, uint256 start, uint256 end)\\n        internal\\n        view\\n        returns (bool found, uint256 index)\\n    {\\n        return searchSorted(map.map, needle, start, end, 40);\\n    }\\n\\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\\n    function searchSorted(Uint64Map storage map, uint64 needle, uint256 start, uint256 end)\\n        internal\\n        view\\n        returns (bool found, uint256 index)\\n    {\\n        return searchSorted(map.map, needle, start, end, 64);\\n    }\\n\\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\\n    function searchSorted(Uint128Map storage map, uint128 needle, uint256 start, uint256 end)\\n        internal\\n        view\\n        returns (bool found, uint256 index)\\n    {\\n        return searchSorted(map.map, needle, start, end, 128);\\n    }\\n\\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\\n    function searchSorted(\\n        mapping(uint256 => uint256) storage map,\\n        uint256 needle,\\n        uint256 start,\\n        uint256 end,\\n        uint256 bitWidth\\n    ) internal view returns (bool found, uint256 index) {\\n        unchecked {\\n            if (start >= end) end = start;\\n            uint256 t;\\n            uint256 o = start - 1; // Offset to derive the actual index.\\n            uint256 l = 1; // Low.\\n            uint256 d = _rawDiv(256, bitWidth); // Bucket size.\\n            uint256 m = (1 << bitWidth) - 1; // Value mask.\\n            uint256 h = end - start; // High.\\n            while (true) {\\n                index = (l & h) + ((l ^ h) >> 1);\\n                if (l > h) break;\\n                t = (map[_rawDiv(index + o, d)] >> (_rawMod(index + o, d) * bitWidth)) & m;\\n                if (t == needle) break;\\n                if (needle <= t) h = index - 1;\\n                else l = index + 1;\\n            }\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                m := or(iszero(index), iszero(bitWidth))\\n                found := iszero(or(xor(t, needle), m))\\n                index := add(o, xor(index, mul(xor(index, 1), m)))\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\\n    function _rawDiv(uint256 x, uint256 y) private pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := div(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\\n    function _rawMod(uint256 x, uint256 y) private pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mod(x, y)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/utils/DelegateCashLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nlibrary DelegateCashLib {\\n    address internal constant REGISTRY_V2 = 0x00000000000000447e69651d841bD8D104Bed493;\\n\\n    function checkDelegateForAll(address delegate, address vault) internal view returns (bool result) {\\n        assembly {\\n            // Cache the free memory pointer.\\n            let m := mload(0x40)\\n            // Store the function selector of `checkDelegateForAll(address,address,bytes32)`.\\n            mstore(0x00, 0xe839bd53)\\n            // Store the `delegate`.\\n            mstore(0x20, delegate)\\n            // Store the `vault`.\\n            mstore(0x40, vault)\\n            // The `bytes32 right` argument points to 0x60, which is zero.\\n\\n            // Arguments are evaulated last to first.\\n            result := and(\\n                // The returndata is 1, which represents a bool true.\\n                eq(mload(0x00), 1),\\n                // The staticcall is successful.\\n                staticcall(gas(), REGISTRY_V2, 0x1c, 0x64, 0x00, 0x20)\\n            )\\n\\n            // Restore the free memory pointer.\\n            mstore(0x40, m)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/utils/LibOps.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\n/**\\n * @title LibOps\\n * @dev Shared utilities.\\n */\\nlibrary LibOps {\\n    // =============================================================\\n    //                            ERRORS\\n    // =============================================================\\n\\n    /**\\n     * @dev Error for overflows.\\n     */\\n    error Overflow();\\n\\n    /**\\n     * @dev Error for unauthorized access.\\n     */\\n    error Unauthorized();\\n\\n    // =============================================================\\n    //                           CONSTANTS\\n    // =============================================================\\n\\n    /**\\n     * @dev A role every minter module must have in order to mint new tokens.\\n     *      IMPORTANT: This constant must NEVER be changed!\\n     *      It will always be 2 across all past and future sound protocol contracts.\\n     */\\n    uint256 internal constant MINTER_ROLE = 1 << 1;\\n\\n    /**\\n     * @dev A role the owner can grant for performing admin actions.\\n     *      IMPORTANT: This constant must NEVER be changed!\\n     *      It will always be 1 across all past and future sound protocol contracts.\\n     */\\n    uint256 internal constant ADMIN_ROLE = 1 << 0;\\n\\n    /**\\n     * @dev Basis points denominator used in fee calculations.\\n     *      IMPORTANT: This constant must NEVER be changed!\\n     *      It will always be 10000 across all past and future sound protocol contracts.\\n     */\\n    uint16 internal constant BPS_DENOMINATOR = 10000;\\n\\n    // =============================================================\\n    //                           FUNCTIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev `isOn ? flag : 0`.\\n     */\\n    function toFlag(bool isOn, uint8 flag) internal pure returns (uint8 result) {\\n        assembly {\\n            result := mul(iszero(iszero(isOn)), flag)\\n        }\\n    }\\n\\n    /**\\n     * @dev `(flags & flag != 0) != isOn ? flags ^ flag : flags`.\\n     *      Sets `flag` in `flags` to 1 if `isOn` is true.\\n     *      Sets `flag` in `flags` to 0 if `isOn` is false.\\n     */\\n    function setFlagTo(\\n        uint8 flags,\\n        uint8 flag,\\n        bool isOn\\n    ) internal pure returns (uint8 result) {\\n        assembly {\\n            result := xor(flags, mul(xor(iszero(and(0xff, and(flags, flag))), iszero(isOn)), flag))\\n        }\\n    }\\n\\n    /**\\n     * @dev `x > y ? x : y`.\\n     */\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            z := xor(x, mul(xor(x, y), gt(y, x)))\\n        }\\n    }\\n\\n    /**\\n     * @dev `x < y ? x : y`.\\n     */\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            z := xor(x, mul(xor(x, y), lt(y, x)))\\n        }\\n    }\\n\\n    /**\\n     * @dev `(a * b) / d`. Returns 0 if `d` is zero.\\n     */\\n    function rawMulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 d\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            z := div(mul(a, b), d)\\n        }\\n    }\\n\\n    /**\\n     * @dev `a / d`. Returns 0 if `d` is zero.\\n     */\\n    function rawMod(uint256 a, uint256 d) internal pure returns (uint256 z) {\\n        assembly {\\n            z := mod(a, d)\\n        }\\n    }\\n\\n    /**\\n     * @dev `a | b`.\\n     */\\n    function or(bool a, bool b) internal pure returns (bool z) {\\n        assembly {\\n            z := or(iszero(iszero(a)), iszero(iszero(b)))\\n        }\\n    }\\n\\n    /**\\n     * @dev `a | b | c`.\\n     */\\n    function or(\\n        bool a,\\n        bool b,\\n        bool c\\n    ) internal pure returns (bool z) {\\n        z = or(a, or(b, c));\\n    }\\n\\n    /**\\n     * @dev `a | b | c | d`.\\n     */\\n    function or(\\n        bool a,\\n        bool b,\\n        bool c,\\n        bool d\\n    ) internal pure returns (bool z) {\\n        z = or(a, or(b, or(c, d)));\\n    }\\n\\n    /**\\n     * @dev `a & b`.\\n     */\\n    function and(bool a, bool b) internal pure returns (bool z) {\\n        assembly {\\n            z := and(iszero(iszero(a)), iszero(iszero(b)))\\n        }\\n    }\\n\\n    /**\\n     * @dev `x == 0 ? type(uint256).max : x`\\n     */\\n    function maxIfZero(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            z := sub(x, iszero(x))\\n        }\\n    }\\n\\n    /**\\n     * @dev Packs an address and an index to create an unique identifier.\\n     * @param a The address.\\n     * @param i The index.\\n     * @return result The packed result.\\n     */\\n    function packId(address a, uint96 i) internal pure returns (uint256 result) {\\n        assembly {\\n            result := or(shl(96, a), shr(160, shl(160, i)))\\n        }\\n    }\\n\\n    /**\\n     * @dev Packs `edition`, `tier`, `scheduleNum` to create an unique identifier.\\n     * @param edition     The address of the Sound Edition.\\n     * @param tier        The tier.\\n     * @param scheduleNum The edition-tier schedule number.\\n     * @return result The packed result.\\n     */\\n    function packId(\\n        address edition,\\n        uint8 tier,\\n        uint8 scheduleNum\\n    ) internal pure returns (uint256 result) {\\n        assembly {\\n            mstore(0x00, shl(96, edition))\\n            mstore8(0x1e, tier)\\n            mstore8(0x1f, scheduleNum)\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /**\\n     * @dev `revert Overflow()`.\\n     */\\n    function revertOverflow() internal pure {\\n        assembly {\\n            mstore(0x00, 0x35278d12) // `Overflow()`.\\n            revert(0x1c, 0x04)\\n        }\\n    }\\n\\n    /**\\n     * @dev `revert Unauthorized()`.\\n     */\\n    function revertUnauthorized() internal pure {\\n        assembly {\\n            mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n            revert(0x1c, 0x04)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/multicaller/src/LibMulticaller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title LibMulticaller\\n * @author vectorized.eth\\n * @notice Library to read the `msg.sender` of the multicaller with sender contract.\\n *\\n * @dev Note:\\n * The functions in this library do NOT guard against reentrancy.\\n * A single transaction can recurse through different Multicallers\\n * (e.g. `MulticallerWithSender -> contract -> MulticallerWithSigner -> contract`).\\n *\\n * Think of these functions like `msg.sender`.\\n *\\n * If your contract `C` can handle reentrancy safely with plain old `msg.sender`\\n * for any `A -> C -> B -> C`, you should be fine substituting `msg.sender` with these functions.\\n */\\nlibrary LibMulticaller {\\n    /**\\n     * @dev The address of the multicaller contract.\\n     */\\n    address internal constant MULTICALLER = 0x0000000000002Bdbf1Bf3279983603Ec279CC6dF;\\n\\n    /**\\n     * @dev The address of the multicaller with sender contract.\\n     */\\n    address internal constant MULTICALLER_WITH_SENDER = 0x00000000002Fd5Aeb385D324B580FCa7c83823A0;\\n\\n    /**\\n     * @dev The address of the multicaller with signer contract.\\n     */\\n    address internal constant MULTICALLER_WITH_SIGNER = 0x000000000000D9ECebf3C23529de49815Dac1c4c;\\n\\n    /**\\n     * @dev Returns the caller of `aggregateWithSender` on `MULTICALLER_WITH_SENDER`.\\n     */\\n    function multicallerSender() internal view returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x00)\\n            if iszero(staticcall(gas(), MULTICALLER_WITH_SENDER, codesize(), 0x00, 0x00, 0x20)) {\\n                revert(codesize(), codesize()) // For better gas estimation.\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the signer of `aggregateWithSigner` on `MULTICALLER_WITH_SIGNER`.\\n     */\\n    function multicallerSigner() internal view returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x00)\\n            if iszero(staticcall(gas(), MULTICALLER_WITH_SIGNER, codesize(), 0x00, 0x00, 0x20)) {\\n                revert(codesize(), codesize()) // For better gas estimation.\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the caller of `aggregateWithSender` on `MULTICALLER_WITH_SENDER`,\\n     *      if the current context's `msg.sender` is `MULTICALLER_WITH_SENDER`.\\n     *      Otherwise, returns `msg.sender`.\\n     */\\n    function sender() internal view returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, caller())\\n            let withSender := MULTICALLER_WITH_SENDER\\n            if eq(caller(), withSender) {\\n                if iszero(staticcall(gas(), withSender, codesize(), 0x00, 0x00, 0x20)) {\\n                    revert(codesize(), codesize()) // For better gas estimation.\\n                }\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the caller of `aggregateWithSigner` on `MULTICALLER_WITH_SIGNER`,\\n     *      if the current context's `msg.sender` is `MULTICALLER_WITH_SIGNER`.\\n     *      Otherwise, returns `msg.sender`.\\n     */\\n    function signer() internal view returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, caller())\\n            let withSigner := MULTICALLER_WITH_SIGNER\\n            if eq(caller(), withSigner) {\\n                if iszero(staticcall(gas(), withSigner, codesize(), 0x00, 0x00, 0x20)) {\\n                    revert(codesize(), codesize()) // For better gas estimation.\\n                }\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the caller of `aggregateWithSender` on `MULTICALLER_WITH_SENDER`,\\n     *      if the current context's `msg.sender` is `MULTICALLER_WITH_SENDER`.\\n     *      Returns the signer of `aggregateWithSigner` on `MULTICALLER_WITH_SIGNER`,\\n     *      if the current context's `msg.sender` is `MULTICALLER_WITH_SIGNER`.\\n     *      Otherwise, returns `msg.sender`.\\n     */\\n    function senderOrSigner() internal view returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, caller())\\n            let withSender := MULTICALLER_WITH_SENDER\\n            if eq(caller(), withSender) {\\n                if iszero(staticcall(gas(), withSender, codesize(), 0x00, 0x00, 0x20)) {\\n                    revert(codesize(), codesize()) // For better gas estimation.\\n                }\\n            }\\n            let withSigner := MULTICALLER_WITH_SIGNER\\n            if eq(caller(), withSigner) {\\n                if iszero(staticcall(gas(), withSigner, codesize(), 0x00, 0x00, 0x20)) {\\n                    revert(codesize(), codesize()) // For better gas estimation.\\n                }\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/auth/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n///\\n/// @dev Note:\\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\\n///\\n/// While the ownable portion follows\\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\\nabstract contract Ownable {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The caller is not authorized to call the function.\\n    error Unauthorized();\\n\\n    /// @dev The `newOwner` cannot be the zero address.\\n    error NewOwnerIsZeroAddress();\\n\\n    /// @dev The `pendingOwner` does not have a valid handover request.\\n    error NoHandoverRequest();\\n\\n    /// @dev Cannot double-initialize.\\n    error AlreadyInitialized();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\n    /// despite it not being as lightweight as a single argument event.\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @dev An ownership handover to `pendingOwner` has been requested.\\n    event OwnershipHandoverRequested(address indexed pendingOwner);\\n\\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The owner slot is given by:\\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\\\"_OWNER_SLOT_NOT\\\")))))`.\\n    /// It is intentionally chosen to be a high value\\n    /// to avoid collision with lower slots.\\n    /// The choice of manual storage layout is to enable compatibility\\n    /// with both regular and upgradeable contracts.\\n    bytes32 internal constant _OWNER_SLOT =\\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\\n\\n    /// The ownership handover slot of `newOwner` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\n    ///     let handoverSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// It stores the expiry timestamp of the two-step ownership handover.\\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\\n\\n    /// @dev Initializes the owner directly without authorization guard.\\n    /// This function must be called upon initialization,\\n    /// regardless of whether the contract is upgradeable or not.\\n    /// This is to enable generalization to both regular and upgradeable contracts,\\n    /// and to save gas in case the initial owner is not the caller.\\n    /// For performance reasons, this function will not check if there\\n    /// is an existing owner.\\n    function _initializeOwner(address newOwner) internal virtual {\\n        if (_guardInitializeOwner()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                if sload(ownerSlot) {\\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Store the new value.\\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n            }\\n        } else {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Store the new value.\\n                sstore(_OWNER_SLOT, newOwner)\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sets the owner directly without authorization guard.\\n    function _setOwner(address newOwner) internal virtual {\\n        if (_guardInitializeOwner()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n                // Store the new value.\\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\\n            }\\n        } else {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n                // Store the new value.\\n                sstore(ownerSlot, newOwner)\\n            }\\n        }\\n    }\\n\\n    /// @dev Throws if the sender is not the owner.\\n    function _checkOwner() internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the caller is not the stored owner, revert.\\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\\n    /// Override to return a different value if needed.\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\\n        return 48 * 3600;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(shl(96, newOwner)) {\\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @dev Allows the owner to renounce their ownership.\\n    function renounceOwnership() public payable virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /// @dev Request a two-step ownership handover to the caller.\\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\\n    function requestOwnershipHandover() public payable virtual {\\n        unchecked {\\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Compute and set the handover slot to `expires`.\\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\\n                mstore(0x00, caller())\\n                sstore(keccak256(0x0c, 0x20), expires)\\n                // Emit the {OwnershipHandoverRequested} event.\\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\n            }\\n        }\\n    }\\n\\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\\n    function cancelOwnershipHandover() public payable virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x20), 0)\\n            // Emit the {OwnershipHandoverCanceled} event.\\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\n        }\\n    }\\n\\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            let handoverSlot := keccak256(0x0c, 0x20)\\n            // If the handover does not exist, or has expired.\\n            if gt(timestamp(), sload(handoverSlot)) {\\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Set the handover slot to 0.\\n            sstore(handoverSlot, 0)\\n        }\\n        _setOwner(pendingOwner);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the owner of the contract.\\n    function owner() public view virtual returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(_OWNER_SLOT)\\n        }\\n    }\\n\\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\n    function ownershipHandoverExpiresAt(address pendingOwner)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the handover slot.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            // Load the handover slot.\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Marks a function as only callable by the owner.\\n    modifier onlyOwner() virtual {\\n        _checkOwner();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/ERC721A-Upgradeable/contracts/IERC721AUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of ERC721A.\\n */\\ninterface IERC721AUpgradeable {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\n     */\\n    error MintERC2309QuantityExceedsLimit();\\n\\n    /**\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\n     */\\n    error OwnershipNotInitializedForExtraData();\\n\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\n        uint24 extraData;\\n    }\\n\\n    // =============================================================\\n    //                         TOKEN COUNTERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // =============================================================\\n    //                            IERC721\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\n     * checking first that contract recipients are aware of the ERC721 protocol\\n     * to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move\\n     * this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\n     * whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    // =============================================================\\n    //                           IERC2309\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\n     *\\n     * See {_mintERC2309} for more details.\\n     */\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/interfaces/IERC2981Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IMetadataModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\n/**\\n * @title IMetadataModule\\n * @notice The interface for custom metadata modules.\\n */\\ninterface IMetadataModule {\\n    /**\\n     * @dev When implemented, SoundEdition's `tokenURI` redirects execution to this `tokenURI`.\\n     * @param tokenId The token ID to retrieve the token URI for.\\n     * @return The token URI string.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/LibBit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for bit twiddling and boolean operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBit.sol)\\n/// @author Inspired by (https://graphics.stanford.edu/~seander/bithacks.html)\\nlibrary LibBit {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  BIT TWIDDLING OPERATIONS                  */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Find last set.\\n    /// Returns the index of the most significant bit of `x`,\\n    /// counting from the least significant bit position.\\n    /// If `x` is zero, returns 256.\\n    function fls(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := or(shl(8, iszero(x)), shl(7, lt(0xffffffffffffffffffffffffffffffff, x)))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // forgefmt: disable-next-item\\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\\n                0x0706060506020504060203020504030106050205030304010505030400000000))\\n        }\\n    }\\n\\n    /// @dev Count leading zeros.\\n    /// Returns the number of zeros preceding the most significant one bit.\\n    /// If `x` is zero, returns 256.\\n    function clz(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // forgefmt: disable-next-item\\n            r := add(xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff)), iszero(x))\\n        }\\n    }\\n\\n    /// @dev Find first set.\\n    /// Returns the index of the least significant bit of `x`,\\n    /// counting from the least significant bit position.\\n    /// If `x` is zero, returns 256.\\n    /// Equivalent to `ctz` (count trailing zeros), which gives\\n    /// the number of zeros following the least significant one bit.\\n    function ffs(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Isolate the least significant bit.\\n            let b := and(x, add(not(x), 1))\\n\\n            r := or(shl(8, iszero(x)), shl(7, lt(0xffffffffffffffffffffffffffffffff, b)))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, b))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, b))))\\n\\n            // For the remaining 32 bits, use a De Bruijn lookup.\\n            // forgefmt: disable-next-item\\n            r := or(r, byte(and(div(0xd76453e0, shr(r, b)), 0x1f),\\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\\n        }\\n    }\\n\\n    /// @dev Returns the number of set bits in `x`.\\n    function popCount(uint256 x) internal pure returns (uint256 c) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let max := not(0)\\n            let isMax := eq(x, max)\\n            x := sub(x, and(shr(1, x), div(max, 3)))\\n            x := add(and(x, div(max, 5)), and(shr(2, x), div(max, 5)))\\n            x := and(add(x, shr(4, x)), div(max, 17))\\n            c := or(shl(8, isMax), shr(248, mul(x, div(max, 255))))\\n        }\\n    }\\n\\n    /// @dev Returns whether `x` is a power of 2.\\n    function isPo2(uint256 x) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `x && !(x & (x - 1))`.\\n            result := iszero(add(and(x, sub(x, 1)), iszero(x)))\\n        }\\n    }\\n\\n    /// @dev Returns `x` reversed at the bit level.\\n    function reverseBits(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Computing masks on-the-fly reduces bytecode size by about 500 bytes.\\n            let m := not(0)\\n            r := x\\n            for { let s := 128 } 1 {} {\\n                m := xor(m, shl(s, m))\\n                r := or(and(shr(s, r), m), and(shl(s, r), not(m)))\\n                s := shr(1, s)\\n                if iszero(s) { break }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns `x` reversed at the byte level.\\n    function reverseBytes(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Computing masks on-the-fly reduces bytecode size by about 200 bytes.\\n            let m := not(0)\\n            r := x\\n            for { let s := 128 } 1 {} {\\n                m := xor(m, shl(s, m))\\n                r := or(and(shr(s, r), m), and(shl(s, r), not(m)))\\n                s := shr(1, s)\\n                if eq(s, 4) { break }\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     BOOLEAN OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // A Solidity bool on the stack or memory is represented as a 256-bit word.\\n    // Non-zero values are true, zero is false.\\n    // A clean bool is either 0 (false) or 1 (true) under the hood.\\n    // Usually, if not always, the bool result of a regular Solidity expression,\\n    // or the argument of a public/external function will be a clean bool.\\n    // You can usually use the raw variants for more performance.\\n    // If uncertain, test (best with exact compiler settings).\\n    // Or use the non-raw variants (compiler can sometimes optimize out the double `iszero`s).\\n\\n    /// @dev Returns `x & y`. Inputs must be clean.\\n    function rawAnd(bool x, bool y) internal pure returns (bool z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := and(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x & y`.\\n    function and(bool x, bool y) internal pure returns (bool z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := and(iszero(iszero(x)), iszero(iszero(y)))\\n        }\\n    }\\n\\n    /// @dev Returns `x | y`. Inputs must be clean.\\n    function rawOr(bool x, bool y) internal pure returns (bool z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := or(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x | y`.\\n    function or(bool x, bool y) internal pure returns (bool z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := or(iszero(iszero(x)), iszero(iszero(y)))\\n        }\\n    }\\n\\n    /// @dev Returns 1 if `b` is true, else 0. Input must be clean.\\n    function rawToUint(bool b) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := b\\n        }\\n    }\\n\\n    /// @dev Returns 1 if `b` is true, else 0.\\n    function toUint(bool b) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := iszero(iszero(b))\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"chiru-labs/ERC721A-Upgradeable/=lib/ERC721A-Upgradeable/contracts/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"closedsea/=lib/closedsea/src/\",\r\n      \"preapprove/=lib/preapprove/src/\",\r\n      \"multicaller/=lib/multicaller/src/\",\r\n      \"@core/=contracts/core/\",\r\n      \"@modules/=contracts/modules/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"ERC721A-Upgradeable/=lib/ERC721A-Upgradeable/contracts/\",\r\n      \"ds-test/=lib/solady/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/closedsea/lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"erc721a-upgradeable/=lib/multicaller/lib/erc721a-upgradeable/contracts/\",\r\n      \"erc721a/=lib/multicaller/lib/erc721a/contracts/\",\r\n      \"murky/=lib/murky/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"operator-filter-registry/=lib/closedsea/lib/operator-filter-registry/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"CallerNotDelegated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExceedsMaxPerAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExceedsMintSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExceedsSignedQuantity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAffiliate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAffiliateFeeBPS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMaxMintableRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMerkleProof\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPlatformFeeBPS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPlatformFeeConfig\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPlatformFlatFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTimeRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxMintableIsZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxMintablePerAccountIsZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MerkleRootIsEmpty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTime\",\"type\":\"uint32\"}],\"name\":\"MintNotOpen\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintsAlreadyExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotConfigurable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PlatformFeeAddressIsZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignatureAlreadyUsed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignatureExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignedPriceTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"paid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"WrongPayment\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"bps\",\"type\":\"uint16\"}],\"name\":\"AffiliateFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accrued\",\"type\":\"uint256\"}],\"name\":\"AffiliateFeesWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"AffiliateMerkleRootSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"platform\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint96\",\"name\":\"artistMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"affiliateMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"platformMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdPrice\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdArtistMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdAffiliateMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdPlatformMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"platformTxFlatFee\",\"type\":\"uint96\"},{\"internalType\":\"uint16\",\"name\":\"platformMintFeeBPS\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"indexed\":false,\"internalType\":\"struct ISuperMinterV2.PlatformFeeConfig\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"DefaultPlatformFeeConfigSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"platform\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"price\",\"type\":\"uint96\"}],\"name\":\"GAPriceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"value\",\"type\":\"uint32\"}],\"name\":\"MaxMintablePerAccountSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"value\",\"type\":\"uint32\"}],\"name\":\"MaxMintableSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"MerkleRootSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"price\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxMintablePerAccount\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxMintable\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"affiliateFeeBPS\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"affiliateMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"platform\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"mode\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"indexed\":false,\"internalType\":\"struct ISuperMinterV2.MintCreation\",\"name\":\"creation\",\"type\":\"tuple\"}],\"name\":\"MintCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"quantity\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"allowlisted\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"allowlistedQuantity\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"signedQuantity\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"signedClaimTicket\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"affiliated\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"requiredEtherValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unitPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalArtistFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalAffiliateFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalPlatformFee\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct ISuperMinterV2.MintedLogData\",\"name\":\"data\",\"type\":\"tuple\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"attributionId\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"PausedSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"signedQuantity\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"}],\"name\":\"PlatformAirdropped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"platform\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"PlatformFeeAddressSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"platform\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint96\",\"name\":\"artistMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"affiliateMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"platformMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdPrice\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdArtistMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdAffiliateMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdPlatformMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"platformTxFlatFee\",\"type\":\"uint96\"},{\"internalType\":\"uint16\",\"name\":\"platformMintFeeBPS\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"indexed\":false,\"internalType\":\"struct ISuperMinterV2.PlatformFeeConfig\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"PlatformFeeConfigSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"platform\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accrued\",\"type\":\"uint256\"}],\"name\":\"PlatformFeesWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"platform\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"PlatformSignerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"price\",\"type\":\"uint96\"}],\"name\":\"PriceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"endTime\",\"type\":\"uint32\"}],\"name\":\"TimeRangeSet\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"BPS_DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GA_TIER\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_AFFILIATE_FEE_BPS\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PER_MINT_REWARD\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PLATFORM_PER_MINT_FEE_BPS\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PLATFORM_PER_TX_FLAT_FEE\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINT_TO_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PLATFORM_AIRDROP\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PLATFORM_AIRDROP_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERIFY_MERKLE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERIFY_SIGNATURE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"affiliateFeesAccrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"internalType\":\"uint32[]\",\"name\":\"claimTickets\",\"type\":\"uint32[]\"}],\"name\":\"checkClaimTickets\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"claimed\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"quantity\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"allowlisted\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"allowlistedQuantity\",\"type\":\"uint32\"},{\"internalType\":\"bytes32[]\",\"name\":\"allowlistProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint96\",\"name\":\"signedPrice\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"signedQuantity\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"signedClaimTicket\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"signedDeadline\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"affiliateProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"attributionId\",\"type\":\"uint256\"}],\"internalType\":\"struct ISuperMinterV2.MintTo\",\"name\":\"p\",\"type\":\"tuple\"}],\"name\":\"computeMintToDigest\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"},{\"internalType\":\"uint32\",\"name\":\"signedQuantity\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"signedClaimTicket\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"signedDeadline\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct ISuperMinterV2.PlatformAirdrop\",\"name\":\"p\",\"type\":\"tuple\"}],\"name\":\"computePlatformAirdropDigest\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"price\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxMintablePerAccount\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxMintable\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"affiliateFeeBPS\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"affiliateMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"platform\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"mode\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct ISuperMinterV2.MintCreation\",\"name\":\"c\",\"type\":\"tuple\"}],\"name\":\"createEditionMint\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"platform\",\"type\":\"address\"}],\"name\":\"defaultPlatformFeeConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint96\",\"name\":\"artistMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"affiliateMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"platformMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdPrice\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdArtistMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdAffiliateMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdPlatformMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"platformTxFlatFee\",\"type\":\"uint96\"},{\"internalType\":\"uint16\",\"name\":\"platformMintFeeBPS\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"internalType\":\"struct ISuperMinterV2.PlatformFeeConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"platform\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"}],\"name\":\"effectivePlatformFeeConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint96\",\"name\":\"artistMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"affiliateMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"platformMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdPrice\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdArtistMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdAffiliateMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdPlatformMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"platformTxFlatFee\",\"type\":\"uint96\"},{\"internalType\":\"uint16\",\"name\":\"platformMintFeeBPS\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"internalType\":\"struct ISuperMinterV2.PlatformFeeConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eip712Domain\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"fields\",\"type\":\"bytes1\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifyingContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"extensions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"gaPrice\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"}],\"name\":\"isAffiliated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"affiliateProof\",\"type\":\"bytes32[]\"}],\"name\":\"isAffiliatedWithProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"}],\"name\":\"mintInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"platform\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"price\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxMintablePerAccount\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxMintable\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"minted\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"affiliateFeeBPS\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"mode\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasMints\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"affiliateMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"internalType\":\"struct ISuperMinterV2.MintInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"}],\"name\":\"mintInfoList\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"platform\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"price\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxMintablePerAccount\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxMintable\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"minted\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"affiliateFeeBPS\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"mode\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasMints\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"affiliateMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"internalType\":\"struct ISuperMinterV2.MintInfo[]\",\"name\":\"a\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"quantity\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"allowlisted\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"allowlistedQuantity\",\"type\":\"uint32\"},{\"internalType\":\"bytes32[]\",\"name\":\"allowlistProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint96\",\"name\":\"signedPrice\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"signedQuantity\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"signedClaimTicket\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"signedDeadline\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"affiliateProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"attributionId\",\"type\":\"uint256\"}],\"internalType\":\"struct ISuperMinterV2.MintTo\",\"name\":\"p\",\"type\":\"tuple\"}],\"name\":\"mintTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"}],\"name\":\"nextScheduleNum\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"collector\",\"type\":\"address\"}],\"name\":\"numberMinted\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"},{\"internalType\":\"uint32\",\"name\":\"signedQuantity\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"signedClaimTicket\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"signedDeadline\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct ISuperMinterV2.PlatformAirdrop\",\"name\":\"p\",\"type\":\"tuple\"}],\"name\":\"platformAirdrop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"platformFeeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"platform\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"}],\"name\":\"platformFeeConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint96\",\"name\":\"artistMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"affiliateMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"platformMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdPrice\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdArtistMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdAffiliateMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdPlatformMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"platformTxFlatFee\",\"type\":\"uint96\"},{\"internalType\":\"uint16\",\"name\":\"platformMintFeeBPS\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"internalType\":\"struct ISuperMinterV2.PlatformFeeConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"platformFeesAccrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"platformSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"bps\",\"type\":\"uint16\"}],\"name\":\"setAffiliateFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"setAffiliateMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint96\",\"name\":\"artistMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"affiliateMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"platformMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdPrice\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdArtistMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdAffiliateMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdPlatformMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"platformTxFlatFee\",\"type\":\"uint96\"},{\"internalType\":\"uint16\",\"name\":\"platformMintFeeBPS\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"internalType\":\"struct ISuperMinterV2.PlatformFeeConfig\",\"name\":\"c\",\"type\":\"tuple\"}],\"name\":\"setDefaultPlatformFeeConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"price\",\"type\":\"uint96\"}],\"name\":\"setGAPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"value\",\"type\":\"uint32\"}],\"name\":\"setMaxMintable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"value\",\"type\":\"uint32\"}],\"name\":\"setMaxMintablePerAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"setPlatformFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint96\",\"name\":\"artistMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"affiliateMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"platformMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdPrice\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdArtistMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdAffiliateMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"thresholdPlatformMintReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"platformTxFlatFee\",\"type\":\"uint96\"},{\"internalType\":\"uint16\",\"name\":\"platformMintFeeBPS\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"internalType\":\"struct ISuperMinterV2.PlatformFeeConfig\",\"name\":\"c\",\"type\":\"tuple\"}],\"name\":\"setPlatformFeeConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"setPlatformSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"internalType\":\"uint96\",\"name\":\"price\",\"type\":\"uint96\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"}],\"name\":\"setStartTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTime\",\"type\":\"uint32\"}],\"name\":\"setTimeRange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"quantity\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"hasValidAffiliate\",\"type\":\"bool\"}],\"name\":\"totalPriceAndFees\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"subTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unitPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalArtistFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalAffiliateFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalPlatformFee\",\"type\":\"uint256\"}],\"internalType\":\"struct ISuperMinterV2.TotalPriceAndFees\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"edition\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"scheduleNum\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"quantity\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"signedPrice\",\"type\":\"uint96\"},{\"internalType\":\"bool\",\"name\":\"hasValidAffiliate\",\"type\":\"bool\"}],\"name\":\"totalPriceAndFeesWithSignedPrice\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"subTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unitPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalArtistFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalAffiliateFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalPlatformFee\",\"type\":\"uint256\"}],\"internalType\":\"struct ISuperMinterV2.TotalPriceAndFees\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"version_\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"}],\"name\":\"withdrawForAffiliate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"platform\",\"type\":\"address\"}],\"name\":\"withdrawForPlatform\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SuperMinterV2", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7ebafb7b76188b79b0bde174d599a0d340478ed83ec0a06d25b34aede9727299"}