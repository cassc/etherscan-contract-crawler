{"SourceCode": "# @version 0.3.1\r\n\"\"\"\r\n@title Voting Escrow\r\n@author Aladdin DAO\r\n@license MIT\r\n@notice Votes have a weight depending on time, so that users are\r\n        committed to the future of (whatever they are voting for)\r\n@dev Vote weight decays linearly over time. Lock time cannot be\r\n     more than `MAXTIME` (4 years).\r\n\"\"\"\r\n\r\n# Original idea and credit:\r\n# Curve Finance's veCRV\r\n# https://resources.curve.fi/faq/vote-locking-boost\r\n# https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy\r\n# This contract is an almost-identical fork of Curve's contract\r\n\r\n# Voting escrow to have time-weighted votes\r\n# Votes have a weight depending on time, so that users are committed\r\n# to the future of (whatever they are voting for).\r\n# The weight in this implementation is linear, and lock cannot be more than maxtime:\r\n# w ^\r\n# 1 +        /\r\n#   |      /\r\n#   |    /\r\n#   |  /\r\n#   |/\r\n# 0 +--------+------> time\r\n#       maxtime (4 years?)\r\n\r\nstruct Point:\r\n    bias: int128\r\n    slope: int128  # - dweight / dt\r\n    ts: uint256\r\n    blk: uint256  # block\r\n# We cannot really do block numbers per se b/c slope is per time, not per block\r\n# and per block could be fairly bad b/c Ethereum changes blocktimes.\r\n# What we can do is to extrapolate ***At functions\r\n\r\nstruct LockedBalance:\r\n    amount: int128\r\n    end: uint256\r\n\r\n\r\ninterface ERC20:\r\n    def decimals() -> uint256: view\r\n    def name() -> String[64]: view\r\n    def symbol() -> String[32]: view\r\n    def transfer(to: address, amount: uint256) -> bool: nonpayable\r\n    def transferFrom(spender: address, to: address, amount: uint256) -> bool: nonpayable\r\n\r\n\r\n# Interface for checking whether address belongs to a whitelisted\r\n# type of a smart wallet.\r\n# When new types are added - the whole contract is changed\r\n# The check() method is modifying to be able to use caching\r\n# for individual wallet addresses\r\ninterface SmartWalletChecker:\r\n    def check(addr: address) -> bool: nonpayable\r\n\r\nDEPOSIT_FOR_TYPE: constant(int128) = 0\r\nCREATE_LOCK_TYPE: constant(int128) = 1\r\nINCREASE_LOCK_AMOUNT: constant(int128) = 2\r\nINCREASE_UNLOCK_TIME: constant(int128) = 3\r\n\r\n\r\nevent CommitOwnership:\r\n    admin: address\r\n\r\nevent ApplyOwnership:\r\n    admin: address\r\n\r\nevent Deposit:\r\n    provider: indexed(address)\r\n    value: uint256\r\n    locktime: indexed(uint256)\r\n    type: int128\r\n    ts: uint256\r\n\r\nevent Withdraw:\r\n    provider: indexed(address)\r\n    value: uint256\r\n    ts: uint256\r\n\r\nevent Supply:\r\n    prevSupply: uint256\r\n    supply: uint256\r\n\r\n\r\nWEEK: constant(uint256) = 7 * 86400  # all future times are rounded by week\r\nMAXTIME: constant(uint256) = 4 * 365 * 86400  # 4 years\r\nMULTIPLIER: constant(uint256) = 10 ** 18\r\n\r\ntoken: public(address)\r\nsupply: public(uint256)\r\n\r\nlocked: public(HashMap[address, LockedBalance])\r\n\r\nepoch: public(uint256)\r\npoint_history: public(Point[100000000000000000000000000000])  # epoch -> unsigned point\r\nuser_point_history: public(HashMap[address, Point[1000000000]])  # user -> Point[user_epoch]\r\nuser_point_epoch: public(HashMap[address, uint256])\r\nslope_changes: public(HashMap[uint256, int128])  # time -> signed slope change\r\n\r\n# Aragon's view methods for compatibility\r\ncontroller: public(address)\r\ntransfersEnabled: public(bool)\r\n\r\nname: public(String[64])\r\nsymbol: public(String[32])\r\nversion: public(String[32])\r\ndecimals: public(uint256)\r\n\r\n# Checker for whitelisted (smart contract) wallets which are allowed to deposit\r\n# The goal is to prevent tokenizing the escrow\r\nfuture_smart_wallet_checker: public(address)\r\nsmart_wallet_checker: public(address)\r\n\r\nadmin: public(address)  # Can and will be a smart contract\r\nfuture_admin: public(address)\r\n\r\n\r\n@external\r\ndef initialize(_admin: address, token_addr: address, _name: String[64], _symbol: String[32], _version: String[32]):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param token_addr `ERC20 ACT` token address\r\n    @param _name Token name\r\n    @param _symbol Token symbol\r\n    @param _version Contract version - required for Aragon compatibility\r\n    \"\"\"\r\n    assert self.token == ZERO_ADDRESS, \"already initialized\"\r\n\r\n    self.admin = _admin\r\n    self.token = token_addr\r\n    self.point_history[0].blk = block.number\r\n    self.point_history[0].ts = block.timestamp\r\n    self.controller = _admin\r\n    self.transfersEnabled = True\r\n\r\n    _decimals: uint256 = ERC20(token_addr).decimals()\r\n    assert _decimals <= 255\r\n    self.decimals = _decimals\r\n\r\n    self.name = _name\r\n    self.symbol = _symbol\r\n    self.version = _version\r\n\r\n\r\n@external\r\ndef commit_transfer_ownership(addr: address):\r\n    \"\"\"\r\n    @notice Transfer ownership of VotingEscrow contract to `addr`\r\n    @param addr Address to have ownership transferred to\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n    self.future_admin = addr\r\n    log CommitOwnership(addr)\r\n\r\n\r\n@external\r\ndef apply_transfer_ownership():\r\n    \"\"\"\r\n    @notice Apply ownership transfer\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n    _admin: address = self.future_admin\r\n    assert _admin != ZERO_ADDRESS  # dev: admin not set\r\n    self.admin = _admin\r\n    log ApplyOwnership(_admin)\r\n\r\n\r\n@external\r\ndef commit_smart_wallet_checker(addr: address):\r\n    \"\"\"\r\n    @notice Set an external contract to check for approved smart contract wallets\r\n    @param addr Address of Smart contract checker\r\n    \"\"\"\r\n    assert msg.sender == self.admin\r\n    self.future_smart_wallet_checker = addr\r\n\r\n\r\n@external\r\ndef apply_smart_wallet_checker():\r\n    \"\"\"\r\n    @notice Apply setting external contract to check approved smart contract wallets\r\n    \"\"\"\r\n    assert msg.sender == self.admin\r\n    self.smart_wallet_checker = self.future_smart_wallet_checker\r\n\r\n\r\n@internal\r\ndef assert_not_contract(addr: address):\r\n    \"\"\"\r\n    @notice Check if the call is from a whitelisted smart contract, revert if not\r\n    @param addr Address to be checked\r\n    \"\"\"\r\n    if addr != tx.origin:\r\n        checker: address = self.smart_wallet_checker\r\n        if checker != ZERO_ADDRESS:\r\n            if SmartWalletChecker(checker).check(addr):\r\n                return\r\n        raise \"Smart contract depositors not allowed\"\r\n\r\n\r\n@external\r\n@view\r\ndef get_last_user_slope(addr: address) -> int128:\r\n    \"\"\"\r\n    @notice Get the most recently recorded rate of voting power decrease for `addr`\r\n    @param addr Address of the user wallet\r\n    @return Value of the slope\r\n    \"\"\"\r\n    uepoch: uint256 = self.user_point_epoch[addr]\r\n    return self.user_point_history[addr][uepoch].slope\r\n\r\n\r\n@external\r\n@view\r\ndef user_point_history__ts(_addr: address, _idx: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get the timestamp for checkpoint `_idx` for `_addr`\r\n    @param _addr User wallet address\r\n    @param _idx User epoch number\r\n    @return Epoch time of the checkpoint\r\n    \"\"\"\r\n    return self.user_point_history[_addr][_idx].ts\r\n\r\n\r\n@external\r\n@view\r\ndef locked__end(_addr: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get timestamp when `_addr`'s lock finishes\r\n    @param _addr User wallet\r\n    @return Epoch time of the lock end\r\n    \"\"\"\r\n    return self.locked[_addr].end\r\n\r\n\r\n@internal\r\ndef _checkpoint(addr: address, old_locked: LockedBalance, new_locked: LockedBalance):\r\n    \"\"\"\r\n    @notice Record global and per-user data to checkpoint\r\n    @param addr User's wallet address. No user checkpoint if 0x0\r\n    @param old_locked Pevious locked amount / end lock time for the user\r\n    @param new_locked New locked amount / end lock time for the user\r\n    \"\"\"\r\n    u_old: Point = empty(Point)\r\n    u_new: Point = empty(Point)\r\n    old_dslope: int128 = 0\r\n    new_dslope: int128 = 0\r\n    _epoch: uint256 = self.epoch\r\n\r\n    if addr != ZERO_ADDRESS:\r\n        # Calculate slopes and biases\r\n        # Kept at zero when they have to\r\n        if old_locked.end > block.timestamp and old_locked.amount > 0:\r\n            u_old.slope = old_locked.amount / MAXTIME\r\n            u_old.bias = u_old.slope * convert(old_locked.end - block.timestamp, int128)\r\n        if new_locked.end > block.timestamp and new_locked.amount > 0:\r\n            u_new.slope = new_locked.amount / MAXTIME\r\n            u_new.bias = u_new.slope * convert(new_locked.end - block.timestamp, int128)\r\n\r\n        # Read values of scheduled changes in the slope\r\n        # old_locked.end can be in the past and in the future\r\n        # new_locked.end can ONLY by in the FUTURE unless everything expired: than zeros\r\n        old_dslope = self.slope_changes[old_locked.end]\r\n        if new_locked.end != 0:\r\n            if new_locked.end == old_locked.end:\r\n                new_dslope = old_dslope\r\n            else:\r\n                new_dslope = self.slope_changes[new_locked.end]\r\n\r\n    last_point: Point = Point({bias: 0, slope: 0, ts: block.timestamp, blk: block.number})\r\n    if _epoch > 0:\r\n        last_point = self.point_history[_epoch]\r\n    last_checkpoint: uint256 = last_point.ts\r\n    # initial_last_point is used for extrapolation to calculate block number\r\n    # (approximately, for *At methods) and save them\r\n    # as we cannot figure that out exactly from inside the contract\r\n    initial_last_point: Point = last_point\r\n    block_slope: uint256 = 0  # dblock/dt\r\n    if block.timestamp > last_point.ts:\r\n        block_slope = MULTIPLIER * (block.number - last_point.blk) / (block.timestamp - last_point.ts)\r\n    # If last point is already recorded in this block, slope=0\r\n    # But that's ok b/c we know the block in such case\r\n\r\n    # Go over weeks to fill history and calculate what the current point is\r\n    t_i: uint256 = (last_checkpoint / WEEK) * WEEK\r\n    for i in range(255):\r\n        # Hopefully it won't happen that this won't get used in 5 years!\r\n        # If it does, users will be able to withdraw but vote weight will be broken\r\n        t_i += WEEK\r\n        d_slope: int128 = 0\r\n        if t_i > block.timestamp:\r\n            t_i = block.timestamp\r\n        else:\r\n            d_slope = self.slope_changes[t_i]\r\n        last_point.bias -= last_point.slope * convert(t_i - last_checkpoint, int128)\r\n        last_point.slope += d_slope\r\n        if last_point.bias < 0:  # This can happen\r\n            last_point.bias = 0\r\n        if last_point.slope < 0:  # This cannot happen - just in case\r\n            last_point.slope = 0\r\n        last_checkpoint = t_i\r\n        last_point.ts = t_i\r\n        last_point.blk = initial_last_point.blk + block_slope * (t_i - initial_last_point.ts) / MULTIPLIER\r\n        _epoch += 1\r\n        if t_i == block.timestamp:\r\n            last_point.blk = block.number\r\n            break\r\n        else:\r\n            self.point_history[_epoch] = last_point\r\n\r\n    self.epoch = _epoch\r\n    # Now point_history is filled until t=now\r\n\r\n    if addr != ZERO_ADDRESS:\r\n        # If last point was in this block, the slope change has been applied already\r\n        # But in such case we have 0 slope(s)\r\n        last_point.slope += (u_new.slope - u_old.slope)\r\n        last_point.bias += (u_new.bias - u_old.bias)\r\n        if last_point.slope < 0:\r\n            last_point.slope = 0\r\n        if last_point.bias < 0:\r\n            last_point.bias = 0\r\n\r\n    # Record the changed point into history\r\n    self.point_history[_epoch] = last_point\r\n\r\n    if addr != ZERO_ADDRESS:\r\n        # Schedule the slope changes (slope is going down)\r\n        # We subtract new_user_slope from [new_locked.end]\r\n        # and add old_user_slope to [old_locked.end]\r\n        if old_locked.end > block.timestamp:\r\n            # old_dslope was <something> - u_old.slope, so we cancel that\r\n            old_dslope += u_old.slope\r\n            if new_locked.end == old_locked.end:\r\n                old_dslope -= u_new.slope  # It was a new deposit, not extension\r\n            self.slope_changes[old_locked.end] = old_dslope\r\n\r\n        if new_locked.end > block.timestamp:\r\n            if new_locked.end > old_locked.end:\r\n                new_dslope -= u_new.slope  # old slope disappeared at this point\r\n                self.slope_changes[new_locked.end] = new_dslope\r\n            # else: we recorded it already in old_dslope\r\n\r\n        # Now handle user history\r\n        user_epoch: uint256 = self.user_point_epoch[addr] + 1\r\n\r\n        self.user_point_epoch[addr] = user_epoch\r\n        u_new.ts = block.timestamp\r\n        u_new.blk = block.number\r\n        self.user_point_history[addr][user_epoch] = u_new\r\n\r\n\r\n@internal\r\ndef _deposit_for(_sender: address, _addr: address, _value: uint256, unlock_time: uint256, locked_balance: LockedBalance, type: int128):\r\n    \"\"\"\r\n    @notice Deposit and lock tokens for a user\r\n    @param _addr User's wallet address\r\n    @param _value Amount to deposit\r\n    @param unlock_time New time when to unlock the tokens, or 0 if unchanged\r\n    @param locked_balance Previous locked amount / timestamp\r\n    \"\"\"\r\n    _locked: LockedBalance = locked_balance\r\n    supply_before: uint256 = self.supply\r\n\r\n    self.supply = supply_before + _value\r\n    old_locked: LockedBalance = _locked\r\n    # Adding to existing lock, or if a lock is expired - creating a new one\r\n    _locked.amount += convert(_value, int128)\r\n    if unlock_time != 0:\r\n        _locked.end = unlock_time\r\n    self.locked[_addr] = _locked\r\n\r\n    # Possibilities:\r\n    # Both old_locked.end could be current or expired (>/< block.timestamp)\r\n    # value == 0 (extend lock) or value > 0 (add to lock or extend lock)\r\n    # _locked.end > block.timestamp (always)\r\n    self._checkpoint(_addr, old_locked, _locked)\r\n\r\n    if _value != 0:\r\n        assert ERC20(self.token).transferFrom(_sender, self, _value)\r\n\r\n    log Deposit(_addr, _value, _locked.end, type, block.timestamp)\r\n    log Supply(supply_before, supply_before + _value)\r\n\r\n\r\n@external\r\ndef checkpoint():\r\n    \"\"\"\r\n    @notice Record global data to checkpoint\r\n    \"\"\"\r\n    self._checkpoint(ZERO_ADDRESS, empty(LockedBalance), empty(LockedBalance))\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef deposit_for(_addr: address, _value: uint256):\r\n    \"\"\"\r\n    @notice Deposit `_value` tokens for `_addr` and add to the lock\r\n    @dev Anyone (even a smart contract) can deposit for someone else, but\r\n         cannot extend their locktime and deposit for a brand new user\r\n    @param _addr User's wallet address\r\n    @param _value Amount to add to user's lock\r\n    \"\"\"\r\n    _locked: LockedBalance = self.locked[_addr]\r\n\r\n    assert _value > 0  # dev: need non-zero value\r\n    assert _locked.amount > 0, \"No existing lock found\"\r\n    assert _locked.end > block.timestamp, \"Cannot add to expired lock. Withdraw\"\r\n\r\n    self._deposit_for(msg.sender, _addr, _value, 0, self.locked[_addr], DEPOSIT_FOR_TYPE)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef create_lock(_value: uint256, _unlock_time: uint256):\r\n    \"\"\"\r\n    @notice Deposit `_value` tokens for `msg.sender` and lock until `_unlock_time`\r\n    @param _value Amount to deposit\r\n    @param _unlock_time Epoch time when tokens unlock, rounded down to whole weeks\r\n    \"\"\"\r\n    self.assert_not_contract(msg.sender)\r\n    unlock_time: uint256 = (_unlock_time / WEEK) * WEEK  # Locktime is rounded down to weeks\r\n    _locked: LockedBalance = self.locked[msg.sender]\r\n\r\n    assert _value > 0  # dev: need non-zero value\r\n    assert _locked.amount == 0, \"Withdraw old tokens first\"\r\n    assert unlock_time > block.timestamp, \"Can only lock until time in the future\"\r\n    assert unlock_time <= block.timestamp + MAXTIME, \"Voting lock can be 4 years max\"\r\n\r\n    self._deposit_for(msg.sender, msg.sender, _value, unlock_time, _locked, CREATE_LOCK_TYPE)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef increase_amount(_value: uint256):\r\n    \"\"\"\r\n    @notice Deposit `_value` additional tokens for `msg.sender`\r\n            without modifying the unlock time\r\n    @param _value Amount of tokens to deposit and add to the lock\r\n    \"\"\"\r\n    self.assert_not_contract(msg.sender)\r\n    _locked: LockedBalance = self.locked[msg.sender]\r\n\r\n    assert _value > 0  # dev: need non-zero value\r\n    assert _locked.amount > 0, \"No existing lock found\"\r\n    assert _locked.end > block.timestamp, \"Cannot add to expired lock. Withdraw\"\r\n\r\n    self._deposit_for(msg.sender, msg.sender, _value, 0, _locked, INCREASE_LOCK_AMOUNT)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef increase_unlock_time(_unlock_time: uint256):\r\n    \"\"\"\r\n    @notice Extend the unlock time for `msg.sender` to `_unlock_time`\r\n    @param _unlock_time New epoch time for unlocking\r\n    \"\"\"\r\n    self.assert_not_contract(msg.sender)\r\n    _locked: LockedBalance = self.locked[msg.sender]\r\n    unlock_time: uint256 = (_unlock_time / WEEK) * WEEK  # Locktime is rounded down to weeks\r\n\r\n    assert _locked.end > block.timestamp, \"Lock expired\"\r\n    assert _locked.amount > 0, \"Nothing is locked\"\r\n    assert unlock_time > _locked.end, \"Can only increase lock duration\"\r\n    assert unlock_time <= block.timestamp + MAXTIME, \"Voting lock can be 4 years max\"\r\n\r\n    self._deposit_for(msg.sender, msg.sender, 0, unlock_time, _locked, INCREASE_UNLOCK_TIME)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef withdraw():\r\n    \"\"\"\r\n    @notice Withdraw all tokens for `msg.sender`\r\n    @dev Only possible if the lock has expired\r\n    \"\"\"\r\n    _locked: LockedBalance = self.locked[msg.sender]\r\n    assert block.timestamp >= _locked.end, \"The lock didn't expire\"\r\n    value: uint256 = convert(_locked.amount, uint256)\r\n\r\n    old_locked: LockedBalance = _locked\r\n    _locked.end = 0\r\n    _locked.amount = 0\r\n    self.locked[msg.sender] = _locked\r\n    supply_before: uint256 = self.supply\r\n    self.supply = supply_before - value\r\n\r\n    # old_locked can have either expired <= timestamp or zero end\r\n    # _locked has only 0 end\r\n    # Both can have >= 0 amount\r\n    self._checkpoint(msg.sender, old_locked, _locked)\r\n\r\n    assert ERC20(self.token).transfer(msg.sender, value)\r\n\r\n    log Withdraw(msg.sender, value, block.timestamp)\r\n    log Supply(supply_before, supply_before - value)\r\n\r\n\r\n# The following ERC20/minime-compatible methods are not real balanceOf and supply!\r\n# They measure the weights for the purpose of voting, so they don't represent\r\n# real coins.\r\n\r\n@internal\r\n@view\r\ndef find_block_epoch(_block: uint256, max_epoch: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Binary search to estimate timestamp for block number\r\n    @param _block Block to find\r\n    @param max_epoch Don't go beyond this epoch\r\n    @return Approximate timestamp for block\r\n    \"\"\"\r\n    # Binary search\r\n    _min: uint256 = 0\r\n    _max: uint256 = max_epoch\r\n    for i in range(128):  # Will be always enough for 128-bit numbers\r\n        if _min >= _max:\r\n            break\r\n        _mid: uint256 = (_min + _max + 1) / 2\r\n        if self.point_history[_mid].blk <= _block:\r\n            _min = _mid\r\n        else:\r\n            _max = _mid - 1\r\n    return _min\r\n\r\n\r\n@external\r\n@view\r\ndef balanceOf(addr: address, _t: uint256 = block.timestamp) -> uint256:\r\n    \"\"\"\r\n    @notice Get the current voting power for `msg.sender`\r\n    @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\r\n    @param addr User wallet address\r\n    @param _t Epoch time to return voting power at\r\n    @return User voting power\r\n    \"\"\"\r\n    _epoch: uint256 = self.user_point_epoch[addr]\r\n    if _epoch == 0:\r\n        return 0\r\n    else:\r\n        last_point: Point = self.user_point_history[addr][_epoch]\r\n        last_point.bias -= last_point.slope * convert(_t - last_point.ts, int128)\r\n        if last_point.bias < 0:\r\n            last_point.bias = 0\r\n        return convert(last_point.bias, uint256)\r\n\r\n\r\n@external\r\n@view\r\ndef balanceOfAt(addr: address, _block: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Measure voting power of `addr` at block height `_block`\r\n    @dev Adheres to MiniMe `balanceOfAt` interface: https://github.com/Giveth/minime\r\n    @param addr User's wallet address\r\n    @param _block Block to calculate the voting power at\r\n    @return Voting power\r\n    \"\"\"\r\n    # Copying and pasting totalSupply code because Vyper cannot pass by\r\n    # reference yet\r\n    assert _block <= block.number\r\n\r\n    # Binary search\r\n    _min: uint256 = 0\r\n    _max: uint256 = self.user_point_epoch[addr]\r\n    for i in range(128):  # Will be always enough for 128-bit numbers\r\n        if _min >= _max:\r\n            break\r\n        _mid: uint256 = (_min + _max + 1) / 2\r\n        if self.user_point_history[addr][_mid].blk <= _block:\r\n            _min = _mid\r\n        else:\r\n            _max = _mid - 1\r\n\r\n    upoint: Point = self.user_point_history[addr][_min]\r\n\r\n    max_epoch: uint256 = self.epoch\r\n    _epoch: uint256 = self.find_block_epoch(_block, max_epoch)\r\n    point_0: Point = self.point_history[_epoch]\r\n    d_block: uint256 = 0\r\n    d_t: uint256 = 0\r\n    if _epoch < max_epoch:\r\n        point_1: Point = self.point_history[_epoch + 1]\r\n        d_block = point_1.blk - point_0.blk\r\n        d_t = point_1.ts - point_0.ts\r\n    else:\r\n        d_block = block.number - point_0.blk\r\n        d_t = block.timestamp - point_0.ts\r\n    block_time: uint256 = point_0.ts\r\n    if d_block != 0:\r\n        block_time += d_t * (_block - point_0.blk) / d_block\r\n\r\n    upoint.bias -= upoint.slope * convert(block_time - upoint.ts, int128)\r\n    if upoint.bias >= 0:\r\n        return convert(upoint.bias, uint256)\r\n    else:\r\n        return 0\r\n\r\n\r\n@internal\r\n@view\r\ndef supply_at(point: Point, t: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate total voting power at some point in the past\r\n    @param point The point (bias/slope) to start search from\r\n    @param t Time to calculate the total voting power at\r\n    @return Total voting power at that time\r\n    \"\"\"\r\n    last_point: Point = point\r\n    t_i: uint256 = (last_point.ts / WEEK) * WEEK\r\n    for i in range(255):\r\n        t_i += WEEK\r\n        d_slope: int128 = 0\r\n        if t_i > t:\r\n            t_i = t\r\n        else:\r\n            d_slope = self.slope_changes[t_i]\r\n        last_point.bias -= last_point.slope * convert(t_i - last_point.ts, int128)\r\n        if t_i == t:\r\n            break\r\n        last_point.slope += d_slope\r\n        last_point.ts = t_i\r\n\r\n    if last_point.bias < 0:\r\n        last_point.bias = 0\r\n    return convert(last_point.bias, uint256)\r\n\r\n\r\n@external\r\n@view\r\ndef totalSupply(t: uint256 = block.timestamp) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate total voting power\r\n    @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\r\n    @return Total voting power\r\n    \"\"\"\r\n    _epoch: uint256 = self.epoch\r\n    last_point: Point = self.point_history[_epoch]\r\n    return self.supply_at(last_point, t)\r\n\r\n\r\n@external\r\n@view\r\ndef totalSupplyAt(_block: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate total voting power at some point in the past\r\n    @param _block Block to calculate the total voting power at\r\n    @return Total voting power at `_block`\r\n    \"\"\"\r\n    assert _block <= block.number\r\n    _epoch: uint256 = self.epoch\r\n    target_epoch: uint256 = self.find_block_epoch(_block, _epoch)\r\n\r\n    point: Point = self.point_history[target_epoch]\r\n    dt: uint256 = 0\r\n    if target_epoch < _epoch:\r\n        point_next: Point = self.point_history[target_epoch + 1]\r\n        if point.blk != point_next.blk:\r\n            dt = (_block - point.blk) * (point_next.ts - point.ts) / (point_next.blk - point.blk)\r\n    else:\r\n        if point.blk != block.number:\r\n            dt = (_block - point.blk) * (block.timestamp - point.ts) / (block.number - point.blk)\r\n    # Now dt contains info on how far are we beyond point\r\n\r\n    return self.supply_at(point, point.ts + dt)\r\n\r\n\r\n# Dummy methods for compatibility with Aragon\r\n\r\n@external\r\ndef changeController(_newController: address):\r\n    \"\"\"\r\n    @dev Dummy method required for Aragon compatibility\r\n    \"\"\"\r\n    assert msg.sender == self.controller\r\n    self.controller = _newController", "ABI": "[{\"name\":\"CommitOwnership\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ApplyOwnership\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Deposit\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"locktime\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"type\",\"type\":\"int128\",\"indexed\":false},{\"name\":\"ts\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Withdraw\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"ts\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Supply\",\"inputs\":[{\"name\":\"prevSupply\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"initialize\",\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"token_addr\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_version\",\"type\":\"string\"}],\"outputs\":[],\"gas\":510181},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_transfer_ownership\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[],\"gas\":39475},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"apply_transfer_ownership\",\"inputs\":[],\"outputs\":[],\"gas\":41566},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_smart_wallet_checker\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[],\"gas\":37695},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"apply_smart_wallet_checker\",\"inputs\":[],\"outputs\":[],\"gas\":39671},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_last_user_slope\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}],\"gas\":5154},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"user_point_history__ts\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_idx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2957},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"locked__end\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2942},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"checkpoint\",\"inputs\":[],\"outputs\":[],\"gas\":37283310},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit_for\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":37475860},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"create_lock\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_unlock_time\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":37483708},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"increase_amount\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":37479930},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"increase_unlock_time\",\"inputs\":[{\"name\":\"_unlock_time\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":37487084},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[],\"outputs\":[],\"gas\":37465833},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":12690},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"_t\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":12690},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOfAt\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"_block\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":792970},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":905086},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[{\"name\":\"t\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":905086},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupplyAt\",\"inputs\":[{\"name\":\"_block\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":1287578},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"changeController\",\"inputs\":[{\"name\":\"_newController\",\"type\":\"address\"}],\"outputs\":[],\"gas\":38145},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3030},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"supply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3060},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"locked\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"amount\",\"type\":\"int128\"},{\"name\":\"end\",\"type\":\"uint256\"}]}],\"gas\":5513},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"epoch\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3120},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"point_history\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"bias\",\"type\":\"int128\"},{\"name\":\"slope\",\"type\":\"int128\"},{\"name\":\"ts\",\"type\":\"uint256\"},{\"name\":\"blk\",\"type\":\"uint256\"}]}],\"gas\":9584},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"user_point_history\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"bias\",\"type\":\"int128\"},{\"name\":\"slope\",\"type\":\"int128\"},{\"name\":\"ts\",\"type\":\"uint256\"},{\"name\":\"blk\",\"type\":\"uint256\"}]}],\"gas\":9880},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"user_point_epoch\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3476},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"slope_changes\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}],\"gas\":3355},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"controller\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3270},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"transfersEnabled\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":3300},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"gas\":13619},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"gas\":11378},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"version\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"gas\":11408},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"decimals\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3420},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_smart_wallet_checker\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3450},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"smart_wallet_checker\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3480},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3510},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3540}]", "ContractName": "Voting Escrow", "CompilerVersion": "vyper:0.3.1", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}