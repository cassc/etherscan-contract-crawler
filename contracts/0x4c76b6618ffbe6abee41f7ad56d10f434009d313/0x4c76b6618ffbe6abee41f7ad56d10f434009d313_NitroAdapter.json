{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@routerprotocol/intents-core/contracts/AdapterDataProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport {IAdapterDataProvider} from \\\"./interfaces/IAdapterDataProvider.sol\\\";\\n\\n/**\\n * @title AdapterDataProvider\\n * @author Router Protocol\\n * @notice This contract serves as the data provider for an intent adapter based on Router\\n * Cross-Chain Intent Framework.\\n */\\ncontract AdapterDataProvider is IAdapterDataProvider {\\n    address private _owner;\\n    mapping(address => bool) private _headRegistry;\\n    mapping(address => bool) private _tailRegistry;\\n    mapping(address => bool) private _inboundAssetRegistry;\\n    mapping(address => bool) private _outboundAssetRegistry;\\n\\n    constructor(address __owner) {\\n        _owner = __owner;\\n    }\\n\\n    /**\\n     * @inheritdoc IAdapterDataProvider\\n     */\\n    function owner() external view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @inheritdoc IAdapterDataProvider\\n     */\\n    function setOwner(address __owner) external onlyOwner {\\n        _owner = __owner;\\n    }\\n\\n    /**\\n     * @inheritdoc IAdapterDataProvider\\n     */\\n    function isAuthorizedPrecedingContract(\\n        address precedingContract\\n    ) external view returns (bool) {\\n        if (precedingContract == address(0)) return true;\\n        return _headRegistry[precedingContract];\\n    }\\n\\n    /**\\n     * @inheritdoc IAdapterDataProvider\\n     */\\n    function isAuthorizedSucceedingContract(\\n        address succeedingContract\\n    ) external view returns (bool) {\\n        if (succeedingContract == address(0)) return true;\\n        return _tailRegistry[succeedingContract];\\n    }\\n\\n    /**\\n     * @inheritdoc IAdapterDataProvider\\n     */\\n    function isValidInboundAsset(address asset) external view returns (bool) {\\n        return _inboundAssetRegistry[asset];\\n    }\\n\\n    /**\\n     * @inheritdoc IAdapterDataProvider\\n     */\\n    function isValidOutboundAsset(address asset) external view returns (bool) {\\n        return _outboundAssetRegistry[asset];\\n    }\\n\\n    /**\\n     * @inheritdoc IAdapterDataProvider\\n     */\\n    function setPrecedingContract(\\n        address precedingContract,\\n        bool isValid\\n    ) external onlyOwner {\\n        _headRegistry[precedingContract] = isValid;\\n    }\\n\\n    /**\\n     * @inheritdoc IAdapterDataProvider\\n     */\\n    function setSucceedingContract(\\n        address succeedingContract,\\n        bool isValid\\n    ) external onlyOwner {\\n        _tailRegistry[succeedingContract] = isValid;\\n    }\\n\\n    /**\\n     * @inheritdoc IAdapterDataProvider\\n     */\\n    function setInboundAsset(address asset, bool isValid) external onlyOwner {\\n        _inboundAssetRegistry[asset] = isValid;\\n    }\\n\\n    /**\\n     * @inheritdoc IAdapterDataProvider\\n     */\\n    function setOutboundAsset(address asset, bool isValid) external onlyOwner {\\n        _outboundAssetRegistry[asset] = isValid;\\n    }\\n\\n    /**\\n     * @notice modifier to ensure that only owner can call this function\\n     */\\n    modifier onlyOwner() {\\n        _onlyOwner();\\n        _;\\n    }\\n\\n    function _onlyOwner() private view {\\n        require(msg.sender == _owner, \\\"Only owner\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@routerprotocol/intents-core/contracts/BaseAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport {Basic} from \\\"./common/Basic.sol\\\";\\nimport {Errors} from \\\"./utils/Errors.sol\\\";\\nimport {ReentrancyGuard} from \\\"./utils/ReentrancyGuard.sol\\\";\\nimport {AdapterDataProvider} from \\\"./AdapterDataProvider.sol\\\";\\n\\n/**\\n * @title BaseAdapter\\n * @author Router Protocol\\n * @notice This contract is the base implementation of an intent adapter based on Router\\n * Cross-Chain Intent Framework.\\n */\\nabstract contract BaseAdapter is Basic, ReentrancyGuard {\\n    address private immutable _self;\\n    address private immutable _native;\\n    address private immutable _wnative;\\n    AdapterDataProvider private immutable _adapterDataProvider;\\n\\n    event ExecutionEvent(string indexed adapterName, bytes data);\\n    event OperationFailedRefundEvent(\\n        address token,\\n        address recipient,\\n        uint256 amount\\n    );\\n    event UnsupportedOperation(\\n        address token,\\n        address refundAddress,\\n        uint256 amount\\n    );\\n\\n    constructor(\\n        address __native,\\n        address __wnative,\\n        bool __deployDataProvider,\\n        address __owner\\n    ) {\\n        _self = address(this);\\n        _native = __native;\\n        _wnative = __wnative;\\n\\n        AdapterDataProvider dataProvider;\\n\\n        if (__deployDataProvider)\\n            dataProvider = new AdapterDataProvider(__owner);\\n        else dataProvider = AdapterDataProvider(address(0));\\n\\n        _adapterDataProvider = dataProvider;\\n    }\\n\\n    /**\\n     * @dev function to get the address of weth\\n     */\\n    function wnative() public view override returns (address) {\\n        return _wnative;\\n    }\\n\\n    /**\\n     * @dev function to get the address of native token\\n     */\\n    function native() public view override returns (address) {\\n        return _native;\\n    }\\n\\n    /**\\n     * @dev function to get the AdapterDataProvider instance for this contract\\n     */\\n    function adapterDataProvider() public view returns (AdapterDataProvider) {\\n        return _adapterDataProvider;\\n    }\\n\\n    /**\\n     * @dev Function to check whether the contract is a valid preceding contract registered in\\n     * the head registry.\\n     * @dev This registry governs the initiation of the adapter, exclusively listing authorized\\n     * preceding adapters.\\n     * @notice Only the adapters documented in this registry can invoke the current adapter,\\n     * thereby guaranteeing regulated and secure execution sequences.\\n     * @param precedingContract Address of preceding contract.\\n     * @return true if valid, false if invalid.\\n     */\\n    function isAuthorizedPrecedingContract(\\n        address precedingContract\\n    ) public view returns (bool) {\\n        return\\n            _adapterDataProvider.isAuthorizedPrecedingContract(\\n                precedingContract\\n            );\\n    }\\n\\n    /**\\n     * @dev Function to check whether the contract is a valid succeeding contract registered in\\n     * the tail registry.\\n     * @dev This registry dictates the potential succeeding actions by listing adapters that\\n     * may be invoked following the current one.\\n     * @notice Only the adapters documented in this registry can be invoked by the current adapter,\\n     * thereby guaranteeing regulated and secure execution sequences.\\n     * @param succeedingContract Address of succeeding contract.\\n     * @return true if valid, false if invalid.\\n     */\\n    function isAuthorizedSucceedingContract(\\n        address succeedingContract\\n    ) public view returns (bool) {\\n        return\\n            _adapterDataProvider.isAuthorizedSucceedingContract(\\n                succeedingContract\\n            );\\n    }\\n\\n    /**\\n     * @dev Function to check whether the asset is a valid inbound asset registered in the inbound\\n     * asset registry.\\n     * @dev This registry keeps track of all the acceptable incoming assets, ensuring that the\\n     * adapter only processes predefined asset types.\\n     * @param asset Address of the asset.\\n     * @return true if valid, false if invalid.\\n     */\\n    function isValidInboundAsset(address asset) public view returns (bool) {\\n        return _adapterDataProvider.isValidInboundAsset(asset);\\n    }\\n\\n    /**\\n     * @dev Function to check whether the asset is a valid outbound asset registered in the outbound\\n     * asset registry.\\n     * @dev It manages the types of assets that the adapter is allowed to output, thus controlling\\n     * the flow\u2019s output and maintaining consistency.\\n     * @param asset Address of the asset.\\n     * @return true if valid, false if invalid.\\n     */\\n    function isValidOutboundAsset(address asset) public view returns (bool) {\\n        return _adapterDataProvider.isValidOutboundAsset(asset);\\n    }\\n\\n    /**\\n     * @dev function to get the name of the adapter\\n     */\\n    function name() public view virtual returns (string memory);\\n\\n    /**\\n     * @dev function to get the address of the contract\\n     */\\n    function self() public view returns (address) {\\n        return _self;\\n    }\\n}\\n\"\r\n    },\r\n    \"@routerprotocol/intents-core/contracts/common/Basic.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport {TokenInterface} from \\\"./Interfaces.sol\\\";\\nimport {TokenUtilsBase} from \\\"./TokenUtilsBase.sol\\\";\\n\\nabstract contract Basic is TokenUtilsBase {\\n    function getTokenBal(address token) internal view returns (uint _amt) {\\n        _amt = address(token) == native()\\n            ? address(this).balance\\n            : TokenInterface(token).balanceOf(address(this));\\n    }\\n\\n    function approve(address token, address spender, uint256 amount) internal {\\n        // solhint-disable-next-line no-empty-blocks\\n        try TokenInterface(token).approve(spender, amount) {} catch {\\n            TokenInterface(token).approve(spender, 0);\\n            TokenInterface(token).approve(spender, amount);\\n        }\\n    }\\n\\n    function convertNativeToWnative(uint amount) internal {\\n        TokenInterface(wnative()).deposit{value: amount}();\\n    }\\n\\n    function convertWnativeToNative(uint amount) internal {\\n        TokenInterface(wnative()).withdraw(amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@routerprotocol/intents-core/contracts/common/Interfaces.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\ninterface TokenInterface {\\n    function approve(address, uint256) external;\\n\\n    function transfer(address, uint) external;\\n\\n    function transferFrom(address, address, uint) external;\\n\\n    function deposit() external payable;\\n\\n    function withdraw(uint) external;\\n\\n    function balanceOf(address) external view returns (uint);\\n\\n    function decimals() external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"@routerprotocol/intents-core/contracts/common/TokenUtilsBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport {IWETH} from \\\"../interfaces/IWETH.sol\\\";\\nimport {SafeERC20, IERC20} from \\\"../utils/SafeERC20.sol\\\";\\n\\nabstract contract TokenUtilsBase {\\n    using SafeERC20 for IERC20;\\n\\n    function wnative() public view virtual returns (address);\\n\\n    function native() public view virtual returns (address);\\n\\n    function approveToken(\\n        address _tokenAddr,\\n        address _to,\\n        uint256 _amount\\n    ) internal {\\n        if (_tokenAddr == native()) return;\\n\\n        if (IERC20(_tokenAddr).allowance(address(this), _to) < _amount) {\\n            IERC20(_tokenAddr).safeApprove(_to, _amount);\\n        }\\n    }\\n\\n    function pullTokensIfNeeded(\\n        address _token,\\n        address _from,\\n        uint256 _amount\\n    ) internal returns (uint256) {\\n        // handle max uint amount\\n        if (_amount == type(uint256).max) {\\n            _amount = getBalance(_token, _from);\\n        }\\n\\n        if (\\n            _from != address(0) &&\\n            _from != address(this) &&\\n            _token != native() &&\\n            _amount != 0\\n        ) {\\n            IERC20(_token).safeTransferFrom(_from, address(this), _amount);\\n        }\\n\\n        return _amount;\\n    }\\n\\n    function withdrawTokens(\\n        address _token,\\n        address _to,\\n        uint256 _amount\\n    ) internal returns (uint256) {\\n        if (_amount == type(uint256).max) {\\n            _amount = getBalance(_token, address(this));\\n        }\\n\\n        if (_to != address(0) && _to != address(this) && _amount != 0) {\\n            if (_token != native()) {\\n                IERC20(_token).safeTransfer(_to, _amount);\\n            } else {\\n                (bool success, ) = _to.call{value: _amount}(\\\"\\\");\\n                require(success, \\\"native send fail\\\");\\n            }\\n        }\\n\\n        return _amount;\\n    }\\n\\n    function depositWnative(uint256 _amount) internal {\\n        IWETH(wnative()).deposit{value: _amount}();\\n    }\\n\\n    function withdrawWnative(uint256 _amount) internal {\\n        IWETH(wnative()).withdraw(_amount);\\n    }\\n\\n    function getBalance(\\n        address _tokenAddr,\\n        address _acc\\n    ) internal view returns (uint256) {\\n        if (_tokenAddr == native()) {\\n            return _acc.balance;\\n        } else {\\n            return IERC20(_tokenAddr).balanceOf(_acc);\\n        }\\n    }\\n\\n    function getTokenDecimals(address _token) internal view returns (uint256) {\\n        if (_token == native()) return 18;\\n\\n        return IERC20(_token).decimals();\\n    }\\n}\\n\"\r\n    },\r\n    \"@routerprotocol/intents-core/contracts/interfaces/IAdapterDataProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\n/**\\n * @title Interface for Adapter Data Provider contract for intent adapter.\\n * @author Router Protocol.\\n */\\n\\ninterface IAdapterDataProvider {\\n    /**\\n     * @dev Function to get the address of owner.\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @dev Function to set the address of owner.\\n     * @dev This function can only be called by the owner of this contract.\\n     * @param __owner Address of the new owner\\n     */\\n    function setOwner(address __owner) external;\\n\\n    /**\\n     * @dev Function to check whether the contract is a valid preceding contract registered in\\n     * the head registry.\\n     * @dev This registry governs the initiation of the adapter, exclusively listing authorized\\n     * preceding adapters.\\n     * @notice Only the adapters documented in this registry can invoke the current adapter,\\n     * thereby guaranteeing regulated and secure execution sequences.\\n     * @param precedingContract Address of preceding contract.\\n     * @return true if valid, false if invalid.\\n     */\\n    function isAuthorizedPrecedingContract(\\n        address precedingContract\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Function to check whether the contract is a valid succeeding contract registered in\\n     * the tail registry.\\n     * @dev This registry dictates the potential succeeding actions by listing adapters that\\n     * may be invoked following the current one.\\n     * @notice Only the adapters documented in this registry can be invoked by the current adapter,\\n     * thereby guaranteeing regulated and secure execution sequences.\\n     * @param succeedingContract Address of succeeding contract.\\n     * @return true if valid, false if invalid.\\n     */\\n    function isAuthorizedSucceedingContract(\\n        address succeedingContract\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Function to check whether the asset is a valid inbound asset registered in the inbound\\n     * asset registry.\\n     * @dev This registry keeps track of all the acceptable incoming assets, ensuring that the\\n     * adapter only processes predefined asset types.\\n     * @param asset Address of the asset.\\n     * @return true if valid, false if invalid.\\n     */\\n    function isValidInboundAsset(address asset) external view returns (bool);\\n\\n    /**\\n     * @dev Function to check whether the asset is a valid outbound asset registered in the outbound\\n     * asset registry.\\n     * @dev It manages the types of assets that the adapter is allowed to output, thus controlling\\n     * the flow\u2019s output and maintaining consistency.\\n     * @param asset Address of the asset.\\n     * @return true if valid, false if invalid.\\n     */\\n    function isValidOutboundAsset(address asset) external view returns (bool);\\n\\n    /**\\n     * @dev Function to set preceding contract (head registry) for the adapter.\\n     * @dev This registry governs the initiation of the adapter, exclusively listing authorized\\n     * preceding adapters.\\n     * @notice Only the adapters documented in this registry can invoke the current adapter,\\n     * thereby guaranteeing regulated and secure execution sequences.\\n     * @param precedingContract Address of preceding contract.\\n     * @param isValid Boolean value suggesting if this is a valid preceding contract.\\n     */\\n    function setPrecedingContract(\\n        address precedingContract,\\n        bool isValid\\n    ) external;\\n\\n    /**\\n     * @dev Function to set succeeding contract (tail registry) for the adapter.\\n     * @dev This registry dictates the potential succeeding actions by listing adapters that\\n     * may be invoked following the current one.\\n     * @notice Only the adapters documented in this registry can be invoked by the current adapter,\\n     * thereby guaranteeing regulated and secure execution sequences.\\n     * @param succeedingContract Address of succeeding contract.\\n     * @param isValid Boolean value suggesting if this is a valid succeeding contract.\\n     */\\n    function setSucceedingContract(\\n        address succeedingContract,\\n        bool isValid\\n    ) external;\\n\\n    /**\\n     * @dev Function to set inbound asset registry for the adapter.\\n     * @dev This registry keeps track of all the acceptable incoming assets, ensuring that the\\n     * adapter only processes predefined asset types.\\n     * @param asset Address of the asset.\\n     * @param isValid Boolean value suggesting if this is a valid inbound asset.\\n     */\\n    function setInboundAsset(address asset, bool isValid) external;\\n\\n    /**\\n     * @dev Function to set outbound asset registry for the adapter.\\n     * @dev It manages the types of assets that the adapter is allowed to output, thus controlling\\n     * the flow\u2019s output and maintaining consistency.\\n     * @param asset Address of the asset.\\n     * @param isValid Boolean value suggesting if this is a valid inbound asset.\\n     */\\n    function setOutboundAsset(address asset, bool isValid) external;\\n}\\n\"\r\n    },\r\n    \"@routerprotocol/intents-core/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\ninterface IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256 supply);\\n\\n    function balanceOf(address _owner) external view returns (uint256 balance);\\n\\n    function transfer(\\n        address _to,\\n        uint256 _value\\n    ) external returns (bool success);\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    ) external returns (bool success);\\n\\n    function approve(\\n        address _spender,\\n        uint256 _value\\n    ) external returns (bool success);\\n\\n    function allowance(\\n        address _owner,\\n        address _spender\\n    ) external view returns (uint256 remaining);\\n\\n    event Approval(\\n        address indexed _owner,\\n        address indexed _spender,\\n        uint256 _value\\n    );\\n}\\n\"\r\n    },\r\n    \"@routerprotocol/intents-core/contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport {IERC20} from \\\"../utils/SafeERC20.sol\\\";\\n\\nabstract contract IWETH {\\n    function allowance(address, address) public view virtual returns (uint256);\\n\\n    function balanceOf(address) public view virtual returns (uint256);\\n\\n    function approve(address, uint256) public virtual;\\n\\n    function transfer(address, uint256) public virtual returns (bool);\\n\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) public virtual returns (bool);\\n\\n    function deposit() public payable virtual;\\n\\n    function withdraw(uint256) public virtual;\\n}\\n\"\r\n    },\r\n    \"@routerprotocol/intents-core/contracts/RouterIntentEoaAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport {BaseAdapter} from \\\"./BaseAdapter.sol\\\";\\nimport {EoaExecutorWithDataProvider, EoaExecutorWithoutDataProvider} from \\\"./utils/EoaExecutor.sol\\\";\\n\\nabstract contract RouterIntentEoaAdapterWithDataProvider is\\n    BaseAdapter,\\n    EoaExecutorWithDataProvider\\n{\\n    constructor(\\n        address __native,\\n        address __wnative,\\n        address __owner\\n    )\\n        BaseAdapter(__native, __wnative, true, __owner)\\n    // solhint-disable-next-line no-empty-blocks\\n    {\\n\\n    }\\n}\\n\\nabstract contract RouterIntentEoaAdapterWithoutDataProvider is\\n    BaseAdapter,\\n    EoaExecutorWithoutDataProvider\\n{\\n    constructor(\\n        address __native,\\n        address __wnative\\n    )\\n        BaseAdapter(__native, __wnative, false, address(0))\\n    // solhint-disable-next-line no-empty-blocks\\n    {\\n\\n    }\\n}\\n\"\r\n    },\r\n    \"@routerprotocol/intents-core/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nlibrary Address {\\n    //insufficient balance\\n    error InsufficientBalance(uint256 available, uint256 required);\\n    //unable to send value, recipient may have reverted\\n    error SendingValueFail();\\n    //insufficient balance for call\\n    error InsufficientBalanceForCall(uint256 available, uint256 required);\\n    //call to non-contract\\n    error NonContractCall();\\n\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            codehash := extcodehash(account)\\n        }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        uint256 balance = address(this).balance;\\n        if (balance < amount) {\\n            revert InsufficientBalance(balance, amount);\\n        }\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!(success)) {\\n            revert SendingValueFail();\\n        }\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data\\n    ) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                \\\"Address: low-level call with value failed\\\"\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        uint256 balance = address(this).balance;\\n        if (balance < value) {\\n            revert InsufficientBalanceForCall(balance, value);\\n        }\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 weiValue,\\n        string memory errorMessage\\n    ) private returns (bytes memory) {\\n        if (!(isContract(target))) {\\n            revert NonContractCall();\\n        }\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\\n            data\\n        );\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@routerprotocol/intents-core/contracts/utils/EoaExecutor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nabstract contract EoaExecutorWithDataProvider {\\n    /**\\n     * @dev function to execute an action on an adapter used in an EOA.\\n     * @param precedingAdapter Address of the preceding adapter.\\n     * @param succeedingAdapter Address of the succeeding adapter.\\n     * @param data inputs data.\\n     * @return tokens to be refunded to user at the end of tx.\\n     */\\n    function execute(\\n        address precedingAdapter,\\n        address succeedingAdapter,\\n        bytes calldata data\\n    ) external payable virtual returns (address[] memory tokens);\\n}\\n\\nabstract contract EoaExecutorWithoutDataProvider {\\n    /**\\n     * @dev function to execute an action on an adapter used in an EOA.\\n     * @param data inputs data.\\n     * @return tokens to be refunded to user at the end of tx.\\n     */\\n    function execute(\\n        bytes calldata data\\n    ) external payable virtual returns (address[] memory tokens);\\n}\\n\"\r\n    },\r\n    \"@routerprotocol/intents-core/contracts/utils/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\n/**\\n * @title Errors library\\n * @author Router Intents Error\\n * @notice Defines the error messages emitted by the contracts on Router Intents\\n */\\nlibrary Errors {\\n    string public constant ARRAY_LENGTH_MISMATCH = \\\"1\\\"; // 'Array lengths mismatch'\\n    string public constant INSUFFICIENT_NATIVE_FUNDS_PASSED = \\\"2\\\"; // 'Insufficient native tokens passed'\\n    string public constant WRONG_BATCH_PROVIDED = \\\"3\\\"; // 'The targetLength, valueLength, callTypeLength, funcLength do not match in executeBatch transaction functions in batch transaction contract'\\n    string public constant INVALID_CALL_TYPE = \\\"4\\\"; // 'The callType value can only be 1 (call)' and 2(delegatecall)'\\n    string public constant ONLY_NITRO = \\\"5\\\"; // 'Only nitro can call this function'\\n    string public constant ONLY_SELF = \\\"6\\\"; // 'Only the current contract can call this function'\\n    string public constant ADAPTER_NOT_WHITELISTED = \\\"7\\\"; // 'Adapter not whitelisted'\\n}\\n\"\r\n    },\r\n    \"@routerprotocol/intents-core/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.18;\\n\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    error ReentrantCall();\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        if (_status == _ENTERED) {\\n            revert ReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@routerprotocol/intents-core/contracts/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport {IERC20} from \\\"../interfaces/IERC20.sol\\\";\\nimport {Address} from \\\"./Address.sol\\\";\\nimport {SafeMath} from \\\"./SafeMath.sol\\\";\\n\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n        );\\n    }\\n\\n    /// @dev Edited so it always first approves 0 and then the value, because of non standard tokens\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.approve.selector, spender, 0)\\n        );\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.approve.selector, spender, value)\\n        );\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(\\n            value\\n        );\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\\n            value,\\n            \\\"SafeERC20: decreased allowance below zero\\\"\\n        );\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        bytes memory returndata = address(token).functionCall(\\n            data,\\n            \\\"SafeERC20: low-level call failed\\\"\\n        );\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(\\n                abi.decode(returndata, (bool)),\\n                \\\"SafeERC20: operation failed\\\"\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@routerprotocol/intents-core/contracts/utils/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: mul overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\n/**\\n * @title Errors library\\n * @author Router Intents Error\\n * @notice Defines the error messages emitted by the contracts on Router Intents\\n */\\nlibrary Errors {\\n    string public constant ARRAY_LENGTH_MISMATCH = \\\"1\\\"; // 'Array lengths mismatch'\\n    string public constant INSUFFICIENT_NATIVE_FUNDS_PASSED = \\\"2\\\"; // 'Insufficient native tokens passed'\\n    string public constant WRONG_BATCH_PROVIDED = \\\"3\\\"; // 'The targetLength, valueLength, callTypeLength, funcLength do not match in executeBatch transaction functions in batch transaction contract'\\n    string public constant INVALID_CALL_TYPE = \\\"4\\\"; // 'The callType value can only be 1 (call)' and 2(delegatecall)'\\n    string public constant ONLY_NITRO = \\\"5\\\"; // 'Only nitro can call this function'\\n    string public constant ONLY_SELF = \\\"6\\\"; // 'Only the current contract can call this function'\\n    string public constant ADAPTER_NOT_WHITELISTED = \\\"7\\\"; // 'Adapter not whitelisted'\\n    string public constant INVALID_BRIDGE_ADDRESS = \\\"8\\\"; // 'Bridge address neither asset forwarder nor dexspan'\\n    string public constant BRIDGE_CALL_FAILED = \\\"9\\\"; // 'Bridge call failed'\\n    string public constant INVALID_BRDIGE_TX_TYPE = \\\"10\\\"; // 'Bridge tx type cannot be greater than 3'\\n    string public constant INVALID_AMOUNT = \\\"11\\\"; // 'Amount is invalid'\\n    string public constant INVALID_BRIDGE_CHAIN_ID = \\\"12\\\"; // 'Bridging chainId is invalid'\\n    string public constant ZERO_AMOUNT_RECEIVED = \\\"13\\\"; // 'Zero amount received'\\n    string public constant INVALID_TX_TYPE = \\\"14\\\"; // 'Invalid txType value'\\n    string public constant INVALID_REQUEST = \\\"15\\\"; // 'Invalid Request'\\n}\\n\"\r\n    },\r\n    \"contracts/intent-adapters/bridge/NitroAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport {RouterIntentEoaAdapterWithoutDataProvider, EoaExecutorWithoutDataProvider} from \\\"@routerprotocol/intents-core/contracts/RouterIntentEoaAdapter.sol\\\";\\nimport {Errors} from \\\"../../Errors.sol\\\";\\nimport {IERC20, SafeERC20} from \\\"../../utils/SafeERC20.sol\\\";\\nimport {IAssetForwarder} from \\\"../../interfaces/IAssetForwarder.sol\\\";\\nimport {IDexSpan} from \\\"../../interfaces/IDexSpan.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract NitroDataStore is Ownable {\\n    address public assetForwarder;\\n    address public dexspan;\\n\\n    constructor(address _assetForwarder, address _dexspan) {\\n        assetForwarder = _assetForwarder;\\n        dexspan = _dexspan;\\n    }\\n\\n    function setDexSpan(address _dexspan) external onlyOwner {\\n        dexspan = _dexspan;\\n    }\\n\\n    function setAssetForwarder(address _assetForwarder) external onlyOwner {\\n        assetForwarder = _assetForwarder;\\n    }\\n}\\n\\n/**\\n * @title NitroAdapter\\n * @author Shivam Agrawal\\n * @notice Adapter for bridging funds and instructions to another chain.\\n */\\ncontract NitroAdapter is RouterIntentEoaAdapterWithoutDataProvider {\\n    using SafeERC20 for IERC20;\\n\\n    address public immutable usdc;\\n    NitroDataStore public immutable nitroDataStore;\\n    uint256 public constant PARTNER_ID = 1;\\n\\n    struct SwapAndDepositData {\\n        uint256 partnerId;\\n        bytes32 destChainIdBytes;\\n        bytes recipient;\\n        address refundRecipient;\\n        uint256 feeAmount;\\n        IDexSpan.SwapParams swapData;\\n        bytes message;\\n    }\\n\\n    struct UsdcCCTPData {\\n        uint256 partnerId;\\n        uint256 amount;\\n        bytes32 destChainIdBytes;\\n        bytes32 recipient;\\n    }\\n\\n    constructor(\\n        address __native,\\n        address __wnative,\\n        address __assetForwarder,\\n        address __dexspan\\n    )\\n        RouterIntentEoaAdapterWithoutDataProvider(__native, __wnative)\\n    // solhint-disable-next-line no-empty-blocks\\n    {\\n        nitroDataStore = new NitroDataStore(__assetForwarder, __dexspan);\\n        usdc = IAssetForwarder(__assetForwarder).usdc();\\n    }\\n\\n    function name() public pure override returns (string memory) {\\n        return \\\"NitroAdapter\\\";\\n    }\\n\\n    /**\\n     * @inheritdoc EoaExecutorWithoutDataProvider\\n     */\\n    function execute(\\n        bytes calldata data\\n    ) external payable override returns (address[] memory tokens) {\\n        // txType = 0 -> assetForwarder iDeposit\\n        // txType = 1 -> dexspan swapAndDeposit\\n        // txType = 2 -> usdcRequest\\n        // txType = 3 -> swapAndDeposit USDC\\n        uint8 txType = abi.decode(data, (uint8));\\n\\n        if (txType > 3) revert(Errors.INVALID_BRDIGE_TX_TYPE);\\n\\n        address[] memory _tokens = new address[](1);\\n\\n        if (txType == 0) {\\n            (\\n                ,\\n                IAssetForwarder.DepositData memory depositData,\\n                bytes memory destToken,\\n                bytes memory recipient,\\n                bytes memory message\\n            ) = abi.decode(\\n                    data,\\n                    (uint8, IAssetForwarder.DepositData, bytes, bytes, bytes)\\n                );\\n\\n            address assetForwarder = nitroDataStore.assetForwarder();\\n\\n            if (address(depositData.srcToken) == native()) {\\n                if (address(this) == self())\\n                    require(\\n                        msg.value == depositData.amount,\\n                        Errors.INSUFFICIENT_NATIVE_FUNDS_PASSED\\n                    );\\n                else if (depositData.amount == type(uint256).max)\\n                    depositData.amount = address(this).balance;\\n\\n                _tokens[0] = native();\\n\\n                if (message.length == 0) {\\n                    IAssetForwarder(assetForwarder).iDeposit{\\n                        value: depositData.amount\\n                    }(depositData, destToken, recipient);\\n                } else\\n                    IAssetForwarder(assetForwarder).iDepositMessage{\\n                        value: depositData.amount\\n                    }(depositData, destToken, recipient, message);\\n            } else {\\n                if (address(this) == self())\\n                    IERC20(depositData.srcToken).safeTransferFrom(\\n                        msg.sender,\\n                        address(this),\\n                        depositData.amount\\n                    );\\n                else if (depositData.amount == type(uint256).max)\\n                    depositData.amount = IERC20(depositData.srcToken).balanceOf(\\n                        address(this)\\n                    );\\n\\n                IERC20(depositData.srcToken).safeIncreaseAllowance(\\n                    assetForwarder,\\n                    depositData.amount\\n                );\\n\\n                _tokens[0] = depositData.srcToken;\\n\\n                if (message.length == 0)\\n                    IAssetForwarder(assetForwarder).iDeposit(\\n                        depositData,\\n                        destToken,\\n                        recipient\\n                    );\\n                else\\n                    IAssetForwarder(assetForwarder).iDepositMessage(\\n                        depositData,\\n                        destToken,\\n                        recipient,\\n                        message\\n                    );\\n            }\\n        } else if (txType == 1) {\\n            (\\n                ,\\n                SwapAndDepositData memory dexspanData,\\n                bytes memory message\\n            ) = abi.decode(data, (uint8, SwapAndDepositData, bytes));\\n\\n            address dexspan = nitroDataStore.dexspan();\\n\\n            address srcToken = address(dexspanData.swapData.tokens[0]);\\n            uint256 amount = dexspanData.swapData.amount;\\n\\n            if (address(this) == self()) {\\n                if (srcToken == native()) {\\n                    if (msg.value != amount)\\n                        revert(Errors.INSUFFICIENT_NATIVE_FUNDS_PASSED);\\n                } else {\\n                    IERC20(srcToken).safeTransferFrom(\\n                        msg.sender,\\n                        self(),\\n                        amount\\n                    );\\n                }\\n            } else if (amount == type(uint256).max) {\\n                if (srcToken == native()) {\\n                    amount = address(this).balance;\\n                } else {\\n                    amount = IERC20(srcToken).balanceOf(address(this));\\n                }\\n            }\\n\\n            withdrawTokens(srcToken, dexspan, amount);\\n\\n            dexspanData.swapData.amount = amount;\\n            dexspanData.swapData.isWrapper = true;\\n\\n            _tokens[0] = srcToken;\\n\\n            if (message.length == 0)\\n                IDexSpan(dexspan).swapAndDeposit(\\n                    dexspanData.partnerId,\\n                    dexspanData.destChainIdBytes,\\n                    dexspanData.recipient,\\n                    0,\\n                    dexspanData.feeAmount,\\n                    hex\\\"\\\",\\n                    dexspanData.swapData,\\n                    dexspanData.refundRecipient\\n                );\\n            else\\n                IDexSpan(dexspan).swapAndDeposit(\\n                    dexspanData.partnerId,\\n                    dexspanData.destChainIdBytes,\\n                    dexspanData.recipient,\\n                    1,\\n                    dexspanData.feeAmount,\\n                    message,\\n                    dexspanData.swapData,\\n                    dexspanData.refundRecipient\\n                );\\n        } else if (txType == 2) {\\n            (, UsdcCCTPData memory usdcData) = abi.decode(\\n                data,\\n                (uint8, UsdcCCTPData)\\n            );\\n\\n            address assetForwarder = nitroDataStore.assetForwarder();\\n\\n            if (address(this) == self())\\n                IERC20(usdc).safeTransferFrom(\\n                    msg.sender,\\n                    self(),\\n                    usdcData.amount\\n                );\\n            else if (usdcData.amount == type(uint256).max)\\n                usdcData.amount = IERC20(usdc).balanceOf(address(this));\\n\\n            IERC20(usdc).safeIncreaseAllowance(assetForwarder, usdcData.amount);\\n\\n            _tokens[0] = usdc;\\n\\n            IAssetForwarder(assetForwarder).iDepositUSDC(\\n                usdcData.partnerId,\\n                usdcData.destChainIdBytes,\\n                usdcData.recipient,\\n                usdcData.amount\\n            );\\n        } else {\\n            address assetForwarder = nitroDataStore.assetForwarder();\\n            address dexspan = nitroDataStore.dexspan();\\n\\n            (, SwapAndDepositData memory dexspanData) = abi.decode(\\n                data,\\n                (uint8, SwapAndDepositData)\\n            );\\n\\n            IAssetForwarder.DestDetails memory destDetails = IAssetForwarder(\\n                assetForwarder\\n            ).destDetails(dexspanData.destChainIdBytes);\\n\\n            if (!destDetails.isSet) revert(Errors.INVALID_REQUEST);\\n\\n            address srcToken = address(dexspanData.swapData.tokens[0]);\\n            uint256 amount = dexspanData.swapData.amount;\\n\\n            if (address(this) == self()) {\\n                if (srcToken == native()) {\\n                    if (msg.value != amount + destDetails.fee)\\n                        revert(Errors.INSUFFICIENT_NATIVE_FUNDS_PASSED);\\n                } else {\\n                    IERC20(srcToken).safeTransferFrom(\\n                        msg.sender,\\n                        self(),\\n                        amount\\n                    );\\n                }\\n            } else if (amount == type(uint256).max) {\\n                if (srcToken == native()) {\\n                    amount = address(this).balance - destDetails.fee;\\n                } else {\\n                    amount = IERC20(srcToken).balanceOf(address(this));\\n                }\\n            }\\n\\n            withdrawTokens(srcToken, dexspan, amount);\\n\\n            dexspanData.swapData.amount = amount;\\n            dexspanData.swapData.isWrapper = true;\\n\\n            _tokens[0] = srcToken;\\n\\n            IDexSpan(dexspan).swapAndDeposit{value: destDetails.fee}(\\n                dexspanData.partnerId,\\n                dexspanData.destChainIdBytes,\\n                dexspanData.recipient,\\n                2,\\n                dexspanData.feeAmount,\\n                hex\\\"\\\",\\n                dexspanData.swapData,\\n                dexspanData.refundRecipient\\n            );\\n        }\\n\\n        emit ExecutionEvent(name(), data);\\n        return _tokens;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAssetForwarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\n/// @title Interface for handler contracts that support deposits and deposit executions.\\n/// @author Router Protocol.\\ninterface IAssetForwarder {\\n    event FundsDeposited(\\n        uint256 partnerId,\\n        uint256 amount,\\n        bytes32 destChainIdBytes,\\n        uint256 destAmount,\\n        uint256 depositId,\\n        address srcToken,\\n        address depositor,\\n        bytes recipient,\\n        bytes destToken\\n    );\\n\\n    event iUSDCDeposited(\\n        uint256 partnerId,\\n        uint256 amount,\\n        bytes32 destChainIdBytes,\\n        uint256 usdcNonce,\\n        address srcToken,\\n        bytes32 recipient,\\n        address depositor\\n    );\\n\\n    event FundsDepositedWithMessage(\\n        uint256 partnerId,\\n        uint256 amount,\\n        bytes32 destChainIdBytes,\\n        uint256 destAmount,\\n        uint256 depositId,\\n        address srcToken,\\n        bytes recipient,\\n        address depositor,\\n        bytes destToken,\\n        bytes message\\n    );\\n    event FundsPaid(bytes32 messageHash, address forwarder, uint256 nonce);\\n\\n    event DepositInfoUpdate(\\n        address srcToken,\\n        uint256 feeAmount,\\n        uint256 depositId,\\n        uint256 eventNonce,\\n        bool initiatewithdrawal,\\n        address depositor\\n    );\\n\\n    event FundsPaidWithMessage(\\n        bytes32 messageHash,\\n        address forwarder,\\n        uint256 nonce,\\n        bool execFlag,\\n        bytes execData\\n    );\\n\\n    struct DestDetails {\\n        uint32 domainId;\\n        uint256 fee;\\n        bool isSet;\\n    }\\n\\n    struct RelayData {\\n        uint256 amount;\\n        bytes32 srcChainId;\\n        uint256 depositId;\\n        address destToken;\\n        address recipient;\\n    }\\n\\n    struct RelayDataMessage {\\n        uint256 amount;\\n        bytes32 srcChainId;\\n        uint256 depositId;\\n        address destToken;\\n        address recipient;\\n        bytes message;\\n    }\\n\\n    struct DepositData {\\n        uint256 partnerId;\\n        uint256 amount;\\n        uint256 destAmount;\\n        address srcToken;\\n        address refundRecipient;\\n        bytes32 destChainIdBytes;\\n    }\\n\\n    function iDepositUSDC(\\n        uint256 partnerId,\\n        bytes32 destChainIdBytes,\\n        bytes32 recipient,\\n        uint256 amount\\n    ) external payable;\\n\\n    function iDeposit(\\n        DepositData memory depositData,\\n        bytes memory destToken,\\n        bytes memory recipient\\n    ) external payable;\\n\\n    function iDepositInfoUpdate(\\n        address srcToken,\\n        uint256 feeAmount,\\n        uint256 depositId,\\n        bool initiatewithdrawal\\n    ) external payable;\\n\\n    function iDepositMessage(\\n        DepositData memory depositData,\\n        bytes memory destToken,\\n        bytes memory recipient,\\n        bytes memory message\\n    ) external payable;\\n\\n    function iRelay(RelayData memory relayData) external payable;\\n\\n    function iRelayMessage(RelayDataMessage memory relayData) external payable;\\n\\n    function usdc() external view returns (address);\\n\\n    function destDetails(\\n        bytes32 destChainIdBytes\\n    ) external view returns (DestDetails memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDexSpan.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport {IERC20} from \\\"../utils/SafeERC20.sol\\\";\\n\\ninterface IDexSpan {\\n    struct SameChainSwapParams {\\n        IERC20[] tokens;\\n        uint256 amount;\\n        uint256 minReturn;\\n        uint256[] flags;\\n        bytes[] dataTx;\\n        address recipient;\\n    }\\n\\n    struct SwapParams {\\n        IERC20[] tokens;\\n        uint256 amount;\\n        uint256 minReturn;\\n        uint256[] flags;\\n        bytes[] dataTx;\\n        bool isWrapper;\\n        address recipient;\\n        bytes destToken;\\n    }\\n\\n    function swapInSameChain(\\n        IERC20[] memory tokens,\\n        uint256 amount,\\n        uint256 minReturn,\\n        uint256[] memory flags,\\n        bytes[] memory dataTx,\\n        bool isWrapper,\\n        address recipient,\\n        uint256 widgetID\\n    ) external payable returns (uint256 returnAmount);\\n\\n    function swapAndDeposit(\\n        uint256 partnerId,\\n        bytes32 destChainIdBytes,\\n        bytes calldata recipient,\\n        uint8 depositType,\\n        uint256 feeAmount,\\n        bytes memory message,\\n        SwapParams memory swapData,\\n        address refundRecipient\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\ninterface IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256 supply);\\n\\n    function balanceOf(address _owner) external view returns (uint256 balance);\\n\\n    function transfer(\\n        address _to,\\n        uint256 _value\\n    ) external returns (bool success);\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    ) external returns (bool success);\\n\\n    function approve(\\n        address _spender,\\n        uint256 _value\\n    ) external returns (bool success);\\n\\n    function allowance(\\n        address _owner,\\n        address _spender\\n    ) external view returns (uint256 remaining);\\n\\n    event Approval(\\n        address indexed _owner,\\n        address indexed _spender,\\n        uint256 _value\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nlibrary Address {\\n    //insufficient balance\\n    error InsufficientBalance(uint256 available, uint256 required);\\n    //unable to send value, recipient may have reverted\\n    error SendingValueFail();\\n    //insufficient balance for call\\n    error InsufficientBalanceForCall(uint256 available, uint256 required);\\n    //call to non-contract\\n    error NonContractCall();\\n\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            codehash := extcodehash(account)\\n        }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        uint256 balance = address(this).balance;\\n        if (balance < amount) {\\n            revert InsufficientBalance(balance, amount);\\n        }\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!(success)) {\\n            revert SendingValueFail();\\n        }\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data\\n    ) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                \\\"Address: low-level call with value failed\\\"\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        uint256 balance = address(this).balance;\\n        if (balance < value) {\\n            revert InsufficientBalanceForCall(balance, value);\\n        }\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 weiValue,\\n        string memory errorMessage\\n    ) private returns (bytes memory) {\\n        if (!(isContract(target))) {\\n            revert NonContractCall();\\n        }\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\\n            data\\n        );\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport {IERC20} from \\\"../interfaces/IERC20.sol\\\";\\nimport {Address} from \\\"./Address.sol\\\";\\nimport {SafeMath} from \\\"./SafeMath.sol\\\";\\n\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n        );\\n    }\\n\\n    /// @dev Edited so it always first approves 0 and then the value, because of non standard tokens\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.approve.selector, spender, 0)\\n        );\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.approve.selector, spender, value)\\n        );\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(\\n            value\\n        );\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\\n            value,\\n            \\\"SafeERC20: decreased allowance below zero\\\"\\n        );\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        bytes memory returndata = address(token).functionCall(\\n            data,\\n            \\\"SafeERC20: low-level call failed\\\"\\n        );\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(\\n                abi.decode(returndata, (bool)),\\n                \\\"SafeERC20: operation failed\\\"\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: mul overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"__native\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"__wnative\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"__assetForwarder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"__dexspan\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NonContractCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonContractCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"adapterName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ExecutionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"OperationFailedRefundEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"refundAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnsupportedOperation\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PARTNER_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adapterDataProvider\",\"outputs\":[{\"internalType\":\"contract AdapterDataProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"precedingContract\",\"type\":\"address\"}],\"name\":\"isAuthorizedPrecedingContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"succeedingContract\",\"type\":\"address\"}],\"name\":\"isAuthorizedSucceedingContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"isValidInboundAsset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"isValidOutboundAsset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"native\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nitroDataStore\",\"outputs\":[{\"internalType\":\"contract NitroDataStore\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"self\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdc\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wnative\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "NitroAdapter", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c21e4ebd1d92036cb467b53fe3258f219d909eb90000000000000000000000006c45e28a76977a96e263f84f95912b47f927b687", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}