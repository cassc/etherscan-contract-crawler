{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/USDC.sol\": {\r\n      \"content\": \"/*\\n\\n\u018e\u0500\u018e\u0500\\n\\n\u02d9u\u0183\u1d09\u01dd\u0279 \u01dd\u029e\u0250\u0287 o\u0287 \u01ddd\u01dd\u0500 \u0279o\u025f \u01dd\u026f\u1d09\u0287 s\u2019\u0287\u1d09 '\u028e\u0250p \u0279\u1d09\u01dd\u0265\u0287 p\u0250\u0265 \u01dd\u028c\u0250\u0265 s\u0183op \u01dd\u0265\u2534 \u02d9\u01dd\u0254u\u01dd\u0287s\u1d09x\u01dd u\u1d09 u\u1d09o\u0254\u01dd\u026f\u01dd\u026f \u01ddlq\u0250\u01dd\u026f\u01dd\u026f \u0287so\u026f \u01dd\u0265\u0287\\n\\nX\u2200\u2534 0/0\\np\u018e\u0186N\u2229ON\u018e\u0279 \u2200\u0186 \u214b p\u018e\u029e\u0186O\u02e5 \u2144\u02e5\u2534N\u018eN\u2200W\u0279\u018e\u0500 \u2144\u2534IpI\u2229QI\u02e5\\n000000000000\u0196 :\u2144\u02e5\u0500\u0500\u2229S\\n\\n\\n\u0279\u01dd\u0287\u0287\u1d09\u028d\u2534: https://epep.lol/\\n\u026f\u0250\u0279\u0183\u01ddl\u01dd\u2534: https://t.me/nekotepep\\n\u01dd\u0287\u1d09sq\u01ddM: https://twitter.com/nekotepep\\n\\n*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n/// @title ERC-721 Non-Fungible Token Standard\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\\n/* is ERC165 */ interface ERC721 {\\n  /// @dev This emits when ownership of any NFT changes by any mechanism.\\n  ///  This event emits when NFTs are created (`from` == 0) and destroyed\\n  ///  (`to` == 0). Exception: during contract creation, any number of NFTs\\n  ///  may be created and assigned without emitting Transfer. At the time of\\n  ///  any transfer, the approved address for that NFT (if any) is reset to none.\\n  event Transfer(\\n    address indexed _from,\\n    address indexed _to,\\n    uint256 indexed _tokenId\\n  );\\n\\n  /// @dev This emits when the approved address for an NFT is changed or\\n  ///  reaffirmed. The zero address indicates there is no approved address.\\n  ///  When a Transfer event emits, this also indicates that the approved\\n  ///  address for that NFT (if any) is reset to none.\\n  event Approval(\\n    address indexed _owner,\\n    address indexed _approved,\\n    uint256 indexed _tokenId\\n  );\\n\\n  /// @dev This emits when an operator is enabled or disabled for an owner.\\n  ///  The operator can manage all NFTs of the owner.\\n  event ApprovalForAll(\\n    address indexed _owner,\\n    address indexed _operator,\\n    bool _approved\\n  );\\n\\n  /// @notice Count all NFTs assigned to an owner\\n  /// @dev NFTs assigned to the zero address are considered invalid, and this\\n  ///  function throws for queries about the zero address.\\n  /// @param _owner An address for whom to query the balance\\n  /// @return The number of NFTs owned by `_owner`, possibly zero\\n  function balanceOf(address _owner) external view returns (uint256);\\n\\n  /// @notice Find the owner of an NFT\\n  /// @dev NFTs assigned to zero address are considered invalid, and queries\\n  ///  about them do throw.\\n  /// @param _tokenId The identifier for an NFT\\n  /// @return The address of the owner of the NFT\\n  function ownerOf(uint256 _tokenId) external view returns (address);\\n\\n  /// @notice Transfers the ownership of an NFT from one address to another address\\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\\n  ///  operator, or the approved address for this NFT. Throws if `_from` is\\n  ///  not the current owner. Throws if `_to` is the zero address. Throws if\\n  ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\\n  ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\\n  ///  `onERC721Received` on `_to` and throws if the return value is not\\n  ///  `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n  /// @param _from The current owner of the NFT\\n  /// @param _to The new owner\\n  /// @param _tokenId The NFT to transfer\\n  /// @param data Additional data with no specified format, sent in call to `_to`\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId,\\n    bytes memory data\\n  ) external payable;\\n\\n  /// @notice Transfers the ownership of an NFT from one address to another address\\n  /// @dev This works identically to the other function with an extra data parameter,\\n  ///  except this function just sets data to \\\"\\\".\\n  /// @param _from The current owner of the NFT\\n  /// @param _to The new owner\\n  /// @param _tokenId The NFT to transfer\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId\\n  ) external payable;\\n\\n  /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\n  ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\n  ///  THEY MAY BE PERMANENTLY LOST\\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\\n  ///  operator, or the approved address for this NFT. Throws if `_from` is\\n  ///  not the current owner. Throws if `_to` is the zero address. Throws if\\n  ///  `_tokenId` is not a valid NFT.\\n  /// @param _from The current owner of the NFT\\n  /// @param _to The new owner\\n  /// @param _tokenId The NFT to transfer\\n  function transferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId\\n  ) external payable;\\n\\n  /// @notice Change or reaffirm the approved address for an NFT\\n  /// @dev The zero address indicates there is no approved address.\\n  ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\\n  ///  operator of the current owner.\\n  /// @param _approved The new approved NFT controller\\n  /// @param _tokenId The NFT to approve\\n  function approve(address _approved, uint256 _tokenId) external payable;\\n\\n  /// @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\n  ///  all of `msg.sender`'s assets\\n  /// @dev Emits the ApprovalForAll event. The contract MUST allow\\n  ///  multiple operators per owner.\\n  /// @param _operator Address to add to the set of authorized operators\\n  /// @param _approved True if the operator is approved, false to revoke approval\\n  function setApprovalForAll(address _operator, bool _approved) external;\\n\\n  /// @notice Get the approved address for a single NFT\\n  /// @dev Throws if `_tokenId` is not a valid NFT.\\n  /// @param _tokenId The NFT to find the approved address for\\n  /// @return The approved address for this NFT, or the zero address if there is none\\n  function getApproved(uint256 _tokenId) external view returns (address);\\n\\n  /// @notice Query if an address is an authorized operator for another address\\n  /// @param _owner The address that owns the NFTs\\n  /// @param _operator The address that acts on behalf of the owner\\n  /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\\n  function isApprovedForAll(\\n    address _owner,\\n    address _operator\\n  ) external view returns (bool);\\n}\\n\\ninterface ERC165 {\\n  /// @notice Query if a contract implements an interface\\n  /// @param interfaceID The interface identifier, as specified in ERC-165\\n  /// @dev Interface identification is specified in ERC-165. This function\\n  ///  uses less than 30,000 gas.\\n  /// @return `true` if the contract implements `interfaceID` and\\n  ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n  function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\\ninterface Callable {\\n  function tokenCallback(\\n    address _from,\\n    uint256 _tokens,\\n    bytes calldata _data\\n  ) external returns (bool);\\n}\\n\\ninterface Router {\\n  function factory() external view returns (address);\\n\\n  function positionManager() external view returns (address);\\n\\n  function WETH9() external view returns (address);\\n}\\n\\ninterface Factory {\\n  function createPool(\\n    address _tokenA,\\n    address _tokenB,\\n    uint24 _fee\\n  ) external returns (address);\\n}\\n\\ninterface Pool {\\n  function initialize(uint160 _sqrtPriceX96) external;\\n}\\n\\ninterface PositionManager {\\n  struct MintParams {\\n    address token0;\\n    address token1;\\n    uint24 fee;\\n    int24 tickLower;\\n    int24 tickUpper;\\n    uint256 amount0Desired;\\n    uint256 amount1Desired;\\n    uint256 amount0Min;\\n    uint256 amount1Min;\\n    address recipient;\\n    uint256 deadline;\\n  }\\n  struct CollectParams {\\n    uint256 tokenId;\\n    address recipient;\\n    uint128 amount0Max;\\n    uint128 amount1Max;\\n  }\\n\\n  function mint(\\n    MintParams calldata\\n  )\\n    external\\n    payable\\n    returns (\\n      uint256 tokenId,\\n      uint128 liquidity,\\n      uint256 amount0,\\n      uint256 amount1\\n    );\\n\\n  function collect(\\n    CollectParams calldata\\n  ) external payable returns (uint256 amount0, uint256 amount1);\\n}\\n\\ncontract NekotEpep {\\n  uint256 private constant FLOAT_SCALAR = 2 ** 64;\\n  uint256 private constant UINT_MAX = type(uint256).max;\\n  uint128 private constant UINT128_MAX = type(uint128).max;\\n  uint256 private constant INITIAL_SUPPLY = 1e30; // 1 trillion\\n  address private deployer = tx.origin;\\n  Router public constant ROUTER =\\n    Router(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45);\\n  uint256 private constant INITIAL_ETH_MC = 100 ether; // 100 ETH initial market cap price\\n  uint256 private constant CONCENTRATED_PERCENT = 20; // 20% of tokens will be sold at the min price (20 ETH)\\n  uint256 private constant UPPER_ETH_MC = 1e6 ether; // 1,000,000 ETH max market cap price\\n\\n  int24 private constant MIN_TICK = -887272;\\n  int24 private constant MAX_TICK = -MIN_TICK;\\n  uint160 private constant MIN_SQRT_RATIO = 4295128739;\\n  uint160 private constant MAX_SQRT_RATIO =\\n    1461446703485210103287273052203988822378723970342;\\n\\n  string public constant name = unicode\\\"\u018e\u0500\u018e\u0500\\\";\\n  string public constant symbol = unicode\\\"\u018e\u0500\u018e\u0500\\\";\\n  uint8 public constant decimals = 18;\\n\\n  struct User {\\n    uint256 balance;\\n    mapping(address => uint256) allowance;\\n  }\\n\\n  struct Info {\\n    address owner;\\n    address pool;\\n    uint256 totalSupply;\\n    mapping(address => User) users;\\n    uint256 lowerPositionId1;\\n    uint256 lowerPositionId2;\\n    uint256 upperPositionId1;\\n    uint256 upperPositionId2;\\n  }\\n  Info private info;\\n\\n  event Transfer(address indexed from, address indexed to, uint256 tokens);\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 tokens\\n  );\\n\\n  constructor() {\\n    address _this = address(this);\\n    address _weth = ROUTER.WETH9();\\n    (uint160 _initialSqrtPrice, ) = _getPriceAndTickFromValues(\\n      _weth < _this,\\n      INITIAL_SUPPLY,\\n      INITIAL_ETH_MC\\n    );\\n    info.pool = Factory(ROUTER.factory()).createPool(_this, _weth, 10000);\\n    Pool(pool()).initialize(_initialSqrtPrice);\\n  }\\n\\n  function initialize() external {\\n    require(msg.sender == deployer);\\n    require(totalSupply() == 0);\\n    address _this = address(this);\\n    address _weth = ROUTER.WETH9();\\n    bool _weth0 = _weth < _this;\\n    PositionManager _pm = PositionManager(ROUTER.positionManager());\\n    info.totalSupply = INITIAL_SUPPLY;\\n    info.users[_this].balance = INITIAL_SUPPLY;\\n    emit Transfer(address(0x0), _this, INITIAL_SUPPLY);\\n    _approve(_this, address(_pm), INITIAL_SUPPLY);\\n    (, int24 _minTick) = _getPriceAndTickFromValues(\\n      _weth0,\\n      INITIAL_SUPPLY,\\n      INITIAL_ETH_MC\\n    );\\n    (, int24 _maxTick) = _getPriceAndTickFromValues(\\n      _weth0,\\n      INITIAL_SUPPLY,\\n      UPPER_ETH_MC\\n    );\\n    uint256 _concentratedTokens = (CONCENTRATED_PERCENT * INITIAL_SUPPLY) / 100;\\n    (info.lowerPositionId1, , , ) = _pm.mint(\\n      PositionManager.MintParams({\\n        token0: _weth0 ? _weth : _this,\\n        token1: !_weth0 ? _weth : _this,\\n        fee: 10000,\\n        tickLower: _weth0 ? _minTick - 200 : _minTick,\\n        tickUpper: !_weth0 ? _minTick + 200 : _minTick,\\n        amount0Desired: _weth0 ? 0 : _concentratedTokens / 2,\\n        amount1Desired: !_weth0 ? 0 : _concentratedTokens / 2,\\n        amount0Min: 0,\\n        amount1Min: 0,\\n        recipient: _this,\\n        deadline: block.timestamp\\n      })\\n    );\\n    (info.lowerPositionId2, , , ) = _pm.mint(\\n      PositionManager.MintParams({\\n        token0: _weth0 ? _weth : _this,\\n        token1: !_weth0 ? _weth : _this,\\n        fee: 10000,\\n        tickLower: _weth0 ? _minTick - 200 : _minTick,\\n        tickUpper: !_weth0 ? _minTick + 200 : _minTick,\\n        amount0Desired: _weth0 ? 0 : _concentratedTokens / 2,\\n        amount1Desired: !_weth0 ? 0 : _concentratedTokens / 2,\\n        amount0Min: 0,\\n        amount1Min: 0,\\n        recipient: _this,\\n        deadline: block.timestamp\\n      })\\n    );\\n    (info.upperPositionId1, , , ) = _pm.mint(\\n      PositionManager.MintParams({\\n        token0: _weth0 ? _weth : _this,\\n        token1: !_weth0 ? _weth : _this,\\n        fee: 10000,\\n        tickLower: _weth0 ? _maxTick : _minTick + 200,\\n        tickUpper: !_weth0 ? _maxTick : _minTick - 200,\\n        amount0Desired: _weth0 ? 0 : (INITIAL_SUPPLY - _concentratedTokens) / 2,\\n        amount1Desired: !_weth0\\n          ? 0\\n          : (INITIAL_SUPPLY - _concentratedTokens) / 2,\\n        amount0Min: 0,\\n        amount1Min: 0,\\n        recipient: _this,\\n        deadline: block.timestamp\\n      })\\n    );\\n    (info.upperPositionId2, , , ) = _pm.mint(\\n      PositionManager.MintParams({\\n        token0: _weth0 ? _weth : _this,\\n        token1: !_weth0 ? _weth : _this,\\n        fee: 10000,\\n        tickLower: _weth0 ? _maxTick : _minTick + 200,\\n        tickUpper: !_weth0 ? _maxTick : _minTick - 200,\\n        amount0Desired: _weth0 ? 0 : (INITIAL_SUPPLY - _concentratedTokens) / 2,\\n        amount1Desired: !_weth0\\n          ? 0\\n          : (INITIAL_SUPPLY - _concentratedTokens) / 2,\\n        amount0Min: 0,\\n        amount1Min: 0,\\n        recipient: _this,\\n        deadline: block.timestamp\\n      })\\n    );\\n  }\\n\\n  function collectTradingFees() external {\\n    require(msg.sender == deployer, \\\"Only deployer can collect fees\\\");\\n    PositionManager _pm = PositionManager(ROUTER.positionManager());\\n    ERC721(address(_pm)).setApprovalForAll(deployer, true);\\n    _pm.collect(\\n      PositionManager.CollectParams({\\n        tokenId: info.lowerPositionId1,\\n        recipient: deployer,\\n        amount0Max: UINT128_MAX,\\n        amount1Max: UINT128_MAX\\n      })\\n    );\\n    _pm.collect(\\n      PositionManager.CollectParams({\\n        tokenId: info.lowerPositionId2,\\n        recipient: deployer,\\n        amount0Max: UINT128_MAX,\\n        amount1Max: UINT128_MAX\\n      })\\n    );\\n    _pm.collect(\\n      PositionManager.CollectParams({\\n        tokenId: info.upperPositionId1,\\n        recipient: deployer,\\n        amount0Max: UINT128_MAX,\\n        amount1Max: UINT128_MAX\\n      })\\n    );\\n    _pm.collect(\\n      PositionManager.CollectParams({\\n        tokenId: info.upperPositionId2,\\n        recipient: deployer,\\n        amount0Max: UINT128_MAX,\\n        amount1Max: UINT128_MAX\\n      })\\n    );\\n  }\\n\\n  function transfer(address _to, uint256 _tokens) external returns (bool) {\\n    return _transfer(msg.sender, _to, _tokens);\\n  }\\n\\n  function approve(address _spender, uint256 _tokens) external returns (bool) {\\n    return _approve(msg.sender, _spender, _tokens);\\n  }\\n\\n  function transferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokens\\n  ) external returns (bool) {\\n    uint256 _allowance = allowance(_from, msg.sender);\\n    require(_allowance >= _tokens);\\n    if (_allowance != UINT_MAX) {\\n      info.users[_from].allowance[msg.sender] -= _tokens;\\n    }\\n    return _transfer(_from, _to, _tokens);\\n  }\\n\\n  function transferAndCall(\\n    address _to,\\n    uint256 _tokens,\\n    bytes calldata _data\\n  ) external returns (bool) {\\n    _transfer(msg.sender, _to, _tokens);\\n    uint32 _size;\\n    assembly {\\n      _size := extcodesize(_to)\\n    }\\n    if (_size > 0) {\\n      require(Callable(_to).tokenCallback(msg.sender, _tokens, _data));\\n    }\\n    return true;\\n  }\\n\\n  function pool() public view returns (address) {\\n    return info.pool;\\n  }\\n\\n  function totalSupply() public view returns (uint256) {\\n    return info.totalSupply;\\n  }\\n\\n  function balanceOf(address _user) public view returns (uint256) {\\n    return info.users[_user].balance;\\n  }\\n\\n  function allowance(\\n    address _user,\\n    address _spender\\n  ) public view returns (uint256) {\\n    return info.users[_user].allowance[_spender];\\n  }\\n\\n  function positions()\\n    external\\n    view\\n    returns (uint256 lower1, uint256 lower2, uint256 upper1, uint256 upper2)\\n  {\\n    return (\\n      info.lowerPositionId1,\\n      info.lowerPositionId2,\\n      info.upperPositionId1,\\n      info.upperPositionId2\\n    );\\n  }\\n\\n  function _approve(\\n    address _owner,\\n    address _spender,\\n    uint256 _tokens\\n  ) internal returns (bool) {\\n    info.users[_owner].allowance[_spender] = _tokens;\\n    emit Approval(_owner, _spender, _tokens);\\n    return true;\\n  }\\n\\n  function _transfer(\\n    address _from,\\n    address _to,\\n    uint256 _tokens\\n  ) internal returns (bool) {\\n    unchecked {\\n      require(balanceOf(_from) >= _tokens);\\n      info.users[_from].balance -= _tokens;\\n      info.users[_to].balance += _tokens;\\n      emit Transfer(_from, _to, _tokens);\\n      return true;\\n    }\\n  }\\n\\n  function _getSqrtRatioAtTick(\\n    int24 tick\\n  ) internal pure returns (uint160 sqrtPriceX96) {\\n    unchecked {\\n      uint256 absTick = tick < 0\\n        ? uint256(-int256(tick))\\n        : uint256(int256(tick));\\n      require(absTick <= uint256(int256(MAX_TICK)), \\\"T\\\");\\n\\n      uint256 ratio = absTick & 0x1 != 0\\n        ? 0xfffcb933bd6fad37aa2d162d1a594001\\n        : 0x100000000000000000000000000000000;\\n      if (absTick & 0x2 != 0)\\n        ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n      if (absTick & 0x4 != 0)\\n        ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n      if (absTick & 0x8 != 0)\\n        ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n      if (absTick & 0x10 != 0)\\n        ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n      if (absTick & 0x20 != 0)\\n        ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n      if (absTick & 0x40 != 0)\\n        ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n      if (absTick & 0x80 != 0)\\n        ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n      if (absTick & 0x100 != 0)\\n        ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n      if (absTick & 0x200 != 0)\\n        ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n      if (absTick & 0x400 != 0)\\n        ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n      if (absTick & 0x800 != 0)\\n        ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n      if (absTick & 0x1000 != 0)\\n        ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n      if (absTick & 0x2000 != 0)\\n        ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n      if (absTick & 0x4000 != 0)\\n        ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n      if (absTick & 0x8000 != 0)\\n        ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n      if (absTick & 0x10000 != 0)\\n        ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n      if (absTick & 0x20000 != 0)\\n        ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n      if (absTick & 0x40000 != 0)\\n        ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n      if (absTick & 0x80000 != 0)\\n        ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n      if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n      sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\\n    }\\n  }\\n\\n  function _getTickAtSqrtRatio(\\n    uint160 sqrtPriceX96\\n  ) internal pure returns (int24 tick) {\\n    unchecked {\\n      require(\\n        sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO,\\n        \\\"R\\\"\\n      );\\n      uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n      uint256 r = ratio;\\n      uint256 msb = 0;\\n\\n      assembly {\\n        let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n        msb := or(msb, f)\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n        msb := or(msb, f)\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        let f := shl(5, gt(r, 0xFFFFFFFF))\\n        msb := or(msb, f)\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        let f := shl(4, gt(r, 0xFFFF))\\n        msb := or(msb, f)\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        let f := shl(3, gt(r, 0xFF))\\n        msb := or(msb, f)\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        let f := shl(2, gt(r, 0xF))\\n        msb := or(msb, f)\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        let f := shl(1, gt(r, 0x3))\\n        msb := or(msb, f)\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        let f := gt(r, 0x1)\\n        msb := or(msb, f)\\n      }\\n\\n      if (msb >= 128) r = ratio >> (msb - 127);\\n      else r = ratio << (127 - msb);\\n\\n      int256 log_2 = (int256(msb) - 128) << 64;\\n\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(63, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(62, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(61, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(60, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(59, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(58, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(57, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(56, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(55, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(54, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(53, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(52, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(51, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(50, f))\\n      }\\n\\n      int256 log_sqrt10001 = log_2 * 255738958999603826347141;\\n\\n      int24 tickLow = int24(\\n        (log_sqrt10001 - 3402992956809132418596140100660247210) >> 128\\n      );\\n      int24 tickHi = int24(\\n        (log_sqrt10001 + 291339464771989622907027621153398088495) >> 128\\n      );\\n\\n      tick = tickLow == tickHi\\n        ? tickLow\\n        : _getSqrtRatioAtTick(tickHi) <= sqrtPriceX96\\n        ? tickHi\\n        : tickLow;\\n    }\\n  }\\n\\n  function _sqrt(uint256 _n) internal pure returns (uint256 result) {\\n    unchecked {\\n      uint256 _tmp = (_n + 1) / 2;\\n      result = _n;\\n      while (_tmp < result) {\\n        result = _tmp;\\n        _tmp = (_n / _tmp + _tmp) / 2;\\n      }\\n    }\\n  }\\n\\n  function _getPriceAndTickFromValues(\\n    bool _weth0,\\n    uint256 _tokens,\\n    uint256 _weth\\n  ) internal pure returns (uint160 price, int24 tick) {\\n    uint160 _tmpPrice = uint160(\\n      _sqrt(\\n        (2 ** 192 / (!_weth0 ? _tokens : _weth)) * (_weth0 ? _tokens : _weth)\\n      )\\n    );\\n    tick = _getTickAtSqrtRatio(_tmpPrice);\\n    tick = tick - (tick % 200);\\n    price = _getSqrtRatioAtTick(tick);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ROUTER\",\"outputs\":[{\"internalType\":\"contract Router\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectTradingFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"positions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lower1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lower2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"upper1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"upper2\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NekotEpep", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}