{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/teamVault/teamVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// XEN Contracts v0.6.0\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nimport {CQuorum}                                from './dao/quorum.sol';\\r\\n\\r\\ncontract CTeamVault is CQuorum {\\r\\n\\r\\n    constructor() {\\r\\n    }\\r\\n\\r\\n    modifier onlyInterCall() {\\r\\n        require( address(this) == msg.sender, \\\"onlyInterCall: caller is not this\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function approval( uint256 docId ) public onlyMember noReentrancy {\\r\\n        _approval( docId );\\r\\n    }\\r\\n\\r\\n    function proposalRecommend( address newMember ) public onlyMember noReentrancy returns( uint256 ) {\\r\\n        require( _memberIndex.getIndex( newMember ) == 0, \\\"proposalRecommend: already a member\\\" );\\r\\n        bytes memory param      = abi.encode( newMember );\\r\\n        bytes memory packed     = abi.encode( \\\"recommend(address)\\\", param );\\r\\n        return _proposal( address(this), packed );\\r\\n    }\\r\\n \\r\\n    function proposalExpulsion( address member ) public onlyMember noReentrancy returns( uint256 ) {\\r\\n        require( _memberIndex.getIndexedSize() > 2, \\\"proposalExpulsion: must have at least 3 members\\\" );\\r\\n        require( _memberIndex.getIndex( member ) > 0, \\\"proposalExpulsion: not a member\\\" );\\r\\n        bytes memory param      = abi.encode( member );\\r\\n        bytes memory packed     = abi.encode( \\\"expulsion(address)\\\", param );\\r\\n        return _proposal( address(this), packed );\\r\\n    }\\r\\n\\r\\n    function proposalTransfer20( address toContract, address to, uint256 amount ) public onlyMember noReentrancy returns( uint256 ) {\\r\\n        bytes memory param      = abi.encode( to, amount );\\r\\n        bytes memory packed     = abi.encode( \\\"transfer(address,uint256)\\\", param );\\r\\n        return _proposal( toContract, packed );           \\r\\n    }     \\r\\n\\r\\n    function proposalTransfer721( address toContract, address to, uint256 tokenId ) public onlyMember noReentrancy returns( uint256 ) {\\r\\n        bytes memory param      = abi.encode( address(this), to, tokenId );\\r\\n        bytes memory packed     = abi.encode( \\\"transferFrom(address,address,uint256)\\\", param );\\r\\n        return _proposal( toContract, packed );           \\r\\n    }      \\r\\n\\r\\n    function proposalTransfer1155( address toContract, address to, uint256 tokenId, uint256 amount ) public onlyMember noReentrancy returns( uint256 ) {\\r\\n        bytes memory param      = abi.encode( address(this), to, tokenId, amount, \\\"\\\" );\\r\\n        bytes memory packed     = abi.encode( \\\"safeTransferFrom(address,address,uint256,uint256,bytes)\\\", param );\\r\\n        return _proposal( toContract, packed );           \\r\\n    }    \\r\\n\\r\\n    //ERC20.ERC721\\r\\n    function proposalApprove( address toContract, address spender, uint256 value ) public onlyMember noReentrancy returns( uint256 ) {\\r\\n        bytes memory param      = abi.encode( spender, value );\\r\\n        bytes memory packed     = abi.encode( \\\"approve(address,uint256)\\\", param );\\r\\n        return _proposal( toContract, packed );           \\r\\n    }       \\r\\n\\r\\n    function proposal( address toContract, string calldata funcSignatrue, bytes calldata funcParams ) public onlyMember noReentrancy returns( uint256 ) {\\r\\n        bytes memory packed     = abi.encode( funcSignatrue, funcParams );\\r\\n        return _proposal( toContract, packed );       \\r\\n    }\\r\\n\\r\\n    ////////////////////////////////////////////////////////////////////////////////\\r\\n    //invoke funtion\\r\\n\\r\\n    function recommend( address newMember ) public onlyInterCall {\\r\\n        _addMember( newMember );\\r\\n    }\\r\\n\\r\\n    function expulsion( address member ) public onlyInterCall {\\r\\n        _removeMember( member );\\r\\n    }\\r\\n \\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/teamVault/dao/quorum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// XEN Contracts v0.6.0\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nimport {_CReentrancyGuards}                     from '../security/reentrancyGuards.sol';\\r\\nimport {CAddressIndexing}                       from '../index/addressIndex.sol';\\r\\nimport {IQuorum}                                from './iQuorum.sol';\\r\\n\\r\\ncontract CQuorum is _CReentrancyGuards, IQuorum {\\r\\n\\r\\n    uint256                                    private                 _idTracker;\\r\\n    uint256                                    internal                _expirationPeriod;   //\uc548\uac74 \uc720\ud6a8 \uae30\uac04 (\uc624\ub298 \ud3ec\ud568 \ub41c \uae30\uac04)\\r\\n    uint256                                    internal                _minimumMembers;     //\ucd5c\uc18c \uad6c\uc131\uc6d0 \uc218\\r\\n    CAddressIndexing                           internal                _memberIndex;\\r\\n    mapping( uint256 => TDraftDoc )            internal                _doc;\\r\\n    address                                    internal                _creator;\\r\\n\\r\\n    event eventAddMember( address newMember );\\r\\n    event eventRemoveMember( address member );\\r\\n    event eventProposal( address drafter, uint256 docId, address toContract, bytes callData, bool invokable );\\r\\n    event eventApproval( address approvor, uint256 docId, bool invokable );\\r\\n    event eventCancel( uint256 docId );\\r\\n    event eventInvoke( address sender, uint256 docId, bytes returnData );\\r\\n\\r\\n    constructor() {\\r\\n        _memberIndex        = new CAddressIndexing();\\r\\n        _idTracker          = 1;  \\r\\n        _expirationPeriod   = 3;    //3 days\\r\\n        _minimumMembers     = 2;    //2 \uba85\\r\\n        _creator            = msg.sender;\\r\\n    }\\r\\n\\r\\n    modifier onlyMember() {\\r\\n        if( _memberIndex.getIndexedSize() < _minimumMembers ) { //\ucd5c\uc18c \ub9f4\ubc84 \uc778\uc6d0\uc744 \ucda9\uc871\ud558\uc9c0 \ubabb \ud560 \uacbd\uc6b0 contract owner\ub9cc \ud638\ucd9c \uac00\ub2a5\ud558\ub2e4\\r\\n            require( msg.sender == _creator, \\\"onlyMember: If less than the minimum number of members, caller must be a contract owner\\\");\\r\\n        } else {\\r\\n            require( _memberIndex.getIndex( msg.sender ) > 0, \\\"onlyMember: caller is not member\\\");\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyQuorum( uint256 docId ) {\\r\\n        /*\\r\\n            \uc2b9\uc778\ub41c \ud6c4 invoke \ud638\ucd9c\ud55c\uc801\uc774 \uc5c6\uc5b4\uc57c \uc57c \ud55c\ub2e4.\\r\\n            \uae30\uc548\uc791\uc131\uc790\uac00 invoke\ub97c \ud638\ucd9c \ud558\uc5ec\uc57c \ud55c\ub2e4.\\r\\n            \uae30\uc548\uc791\uc131\uc77c\ub85c \ubd80\ud130 3\uc77c \uc774\ub0b4\uc5d0 \ud638\ucd9c\ub418\uc5b4\uc57c \ud55c\ub2e4.\\r\\n            2\uba85 \ubbf8\ub9cc \uc778\uacbd\uc6b0 contract \uc0dd\uc131\uc790\ub9cc \ud638\ucd9c \uac00\ub2a5\\r\\n        */\\r\\n        require( !_doc[ docId ].cancellation, \\\"onlyQuorum: cancelled\\\");\\r\\n        require( !_doc[ docId ].invoked, \\\"onlyQuorum: already invoked\\\");\\r\\n        require( _doc[ docId ].drafter == msg.sender, \\\"onlyQuorum: caller is not drafter\\\");\\r\\n        require( (_doc[ docId ].draftDate + ( _expirationPeriod * 86400) ) > block.timestamp, \\\"onlyQuorum: approval period has expired\\\" );\\r\\n\\r\\n        uint256 numberOfMembers = _memberIndex.getIndexedSize();\\r\\n        if( _minimumMembers == 0 || numberOfMembers < _minimumMembers ) { //\ucd5c\uc18c \uc778\uc6d0 \uc774\ud558\uc774\uba74 contract owner\ub9cc \ud638\ucd9c \uac00\ub2a5\ud558\ub2e4\\r\\n             require( msg.sender == _creator, \\\"onlyMember: If less than the minimum number of members, caller must be a contract owner\\\");\\r\\n        } else { //\ucd5c\uc18c \uc778\uc6d0 \uc774\uc0c1\uc778 \uacbd\uc6b0\\r\\n            uint256 minimumApproval = (numberOfMembers / 2) + 1; \\r\\n            require( _doc[ docId ].approval >= minimumApproval, \\\"onlyQuorum: approval count must be at least (number of members / 2) + 1\\\");\\r\\n        } \\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function _revertReason (bytes memory revertData) internal pure returns (string memory reason) {\\r\\n        uint l = revertData.length;\\r\\n        if (l < 68) return \\\"\\\";\\r\\n        uint t;\\r\\n        assembly {\\r\\n            revertData := add (revertData, 4)\\r\\n            t := mload (revertData)\\r\\n            mstore (revertData, sub (l, 4))\\r\\n        }\\r\\n        reason = abi.decode (revertData, (string));\\r\\n        assembly {\\r\\n            mstore (revertData, t)\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function _isInvokable( uint256 docId ) internal view returns( bool ) {\\r\\n        if( _doc[ docId ].invoked ) \\r\\n            return false;\\r\\n        if( (_doc[ docId ].draftDate + ( _expirationPeriod * 86400) ) < block.timestamp)\\r\\n            return false;\\r\\n\\r\\n        uint256 numberOfMembers = _memberIndex.getIndexedSize();\\r\\n        if( _minimumMembers == 0 || numberOfMembers < _minimumMembers ) {\\r\\n            if( _creator != msg.sender ) {\\r\\n               return false;\\r\\n            }\\r\\n        } else { //\ucd5c\uc18c \uc778\uc6d0 \uc774\uc0c1\uc778 \uacbd\uc6b0\\r\\n            uint256 minimumApproval = (numberOfMembers / 2) + 1;\\r\\n            if( _doc[ docId ].approval < minimumApproval ) {\\r\\n                return false;\\r\\n            }\\r\\n        } \\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function cancel( uint256 docId ) public noReentrancy override {\\r\\n        require( _doc[ docId ].drafter == msg.sender, \\\"cancel: caller is not the drafter\\\" );\\r\\n        require( !_doc[ docId ].cancellation, \\\"cancel: already cancelled\\\");\\r\\n        require( (_doc[ docId ].draftDate + ( _expirationPeriod * 86400) ) > block.timestamp, \\\"cancel: approval period has expired\\\" );\\r\\n        require( !_doc[ docId ].invoked, \\\"_approval: already invoked\\\" );\\r\\n\\r\\n        _doc[ docId ].cancellation = true;\\r\\n        emit eventCancel( docId );\\r\\n    }\\r\\n\\r\\n    function invoke( uint256 docId ) public onlyQuorum(docId) noReentrancy override {\\r\\n        (string memory func, bytes memory param )   = abi.decode( _doc[docId].callData, ( string, bytes ) );  \\r\\n        bytes4          FUNC_SELECTOR               = bytes4( keccak256(bytes(func)) );\\r\\n        bytes memory    packedData                  = abi.encodePacked( FUNC_SELECTOR, param );\\r\\n\\r\\n        ( _doc[docId].success, _doc[docId].returnData) = address(_doc[ docId ].to).call( packedData );\\r\\n        if( !_doc[docId].success ) {\\r\\n            revert( _revertReason(_doc[docId].returnData) );\\r\\n        }\\r\\n        _doc[docId].invoked     = true;\\r\\n        _doc[docId].invokeDate  = block.timestamp;\\r\\n        emit eventInvoke( msg.sender, docId, _doc[docId].returnData );        \\r\\n    }\\r\\n\\r\\n    function inquery( uint256 docId ) public view override returns( TDrafeDocViewer memory doc ) {\\r\\n        doc.drafter         = _doc[docId].drafter;\\r\\n        doc.draftDate       = _doc[docId].draftDate;\\r\\n        doc.approval        = _doc[docId].approval;\\r\\n        doc.cancellation    = _doc[docId].cancellation; \\r\\n        doc.invoked         = _doc[docId].invoked; \\r\\n        doc.invokeDate      = _doc[docId].invokeDate;\\r\\n        doc.to              = _doc[docId].to;\\r\\n        return doc;\\r\\n    }\\r\\n\\r\\n    function inqueryApprover( uint256 docId ) public view override returns( TSigner[] memory approvers ) {\\r\\n        uint8 approval = _doc[docId].approval;\\r\\n        if( approval > 0 ) {\\r\\n           approvers      = new TSigner[]( approval );\\r\\n            uint8 i = 0;\\r\\n            for( ; i<approval; i++ ) {\\r\\n               approvers[i] = _doc[ docId ].signer[i];\\r\\n            } \\r\\n        }\\r\\n    }\\r\\n\\r\\n    function inqueryCallData( uint256 docId ) public view override returns( address, string memory, bytes memory ) {\\r\\n        (string memory func, bytes memory param )   = abi.decode( _doc[docId].callData, ( string, bytes ) );\\r\\n        return ( _doc[docId].to, func, param );\\r\\n    }    \\r\\n\\r\\n    function inqueryReturnData( uint256 docId ) public view override returns( bool, bool, bytes memory ) {\\r\\n        return ( _doc[docId].invoked, _doc[docId].success, _doc[docId].returnData );\\r\\n    }    \\r\\n\\r\\n    function inqueryMembers() public view override returns( address[] memory members) {\\r\\n        uint256 size = _memberIndex.getIndexedSize();\\r\\n        members = new address[](size);\\r\\n        uint256 i = 0;\\r\\n        for( ; i<size; i++ ) {\\r\\n            members[i] = _memberIndex.getAddress( i + 1 );\\r\\n        }\\r\\n        return members;\\r\\n    }\\r\\n\\r\\n    function inqueryNumberOfMembers() public view override returns( uint256 ) {\\r\\n        return _memberIndex.getIndexedSize();\\r\\n    }    \\r\\n\\r\\n    function inqueryLatestId() public view override returns( uint256 ) {    \\r\\n        return _idTracker-1;\\r\\n    }\\r\\n\\r\\n    function _proposal( address toContract, bytes memory callData ) internal returns( uint256 ) {\\r\\n        uint256 docId = _idTracker;\\r\\n        _doc[ docId ].drafter        = msg.sender;\\r\\n        _doc[ docId ].draftDate      = (block.timestamp / 86400 ) * 86400;\\r\\n        \\r\\n        TSigner memory tSigner;\\r\\n        tSigner.approver            = msg.sender;\\r\\n        tSigner.time                = block.timestamp;\\r\\n\\r\\n        _doc[ docId ].indexing[msg.sender]              = _doc[ docId ].approval;\\r\\n        _doc[ docId ].signer[_doc[ docId ].approval]    = tSigner;\\r\\n\\r\\n        _doc[ docId ].to             = toContract;        \\r\\n        _doc[ docId ].callData       = callData;\\r\\n\\r\\n        _doc[ docId ].approval++;   //drafter\ub294 \uae30\ubcf8\uc73c\ub85c approve \ud55c \uc0c1\ud0dc\ub85c \uac04\uc8fc \ud55c\ub2e4         \\r\\n        _idTracker++;        \\r\\n        emit eventProposal( msg.sender, docId, toContract, callData, _isInvokable( docId ) ) ;\\r\\n        return docId;\\r\\n    }\\r\\n\\r\\n    function _approval( uint256 docId ) internal {\\r\\n        /*\\r\\n            \uae30\uc548\uc790\ub294 sign\uc744 \ud560 \uc218 \uc5c6\ub2e4\\r\\n            \uc548\uac74 \uc0c1\uc815 \ucde8\uc18c\ub41c \ubb38\uac74\uc740 \uc2b9\uc778 \ubd88\uac00 \ud558\ub2e4\\r\\n            \uae30\uc548\uc791\uc131 \ub0a0\uc9dc\ub85c \ubd80\ud130 \uae08\uc77c \ud3ec\ud568 _expirationPeriod \uc77c \uc774\ub0b4\uc5d0 \uc2b9\uc778 \ud558\uc5ec\uc57c \ud55c\ub2e4.\\r\\n            \uad6c\uc131\uc6d0\ub9cc\uc774 sign\uc744 \ud560 \uc218 \uc788\ub2e4\\r\\n            sign\ud55c \uad6c\uc131\uc6d0\uc740 \uc911\ubcf5 \uc2b9\uc778\uc744 \ud560 \uc218 \uc5c6\ub2e4\\r\\n            invoke\ub41c \uae30\uc548\uc740 sign \ud560 \uc218 \uc5c6\ub2e4.\\r\\n            drafter\ub294 \uae30\ubcf8\uc73c\ub85c approve \ud55c \uc0c1\ud0dc\ub85c \uac04\uc8fc \ud55c\ub2e4.\\r\\n        */\\r\\n        require( _doc[ docId ].drafter != msg.sender, \\\"_approval: the drafter and signer must be different\\\" );\\r\\n        require( !_doc[ docId ].cancellation, \\\"onlyQuorum: cancelled\\\");\\r\\n        require( (_doc[ docId ].draftDate + ( _expirationPeriod * 86400) ) > block.timestamp, \\\"_approval: approval period has expired\\\" );\\r\\n        require( _memberIndex.getIndex( msg.sender ) > 0, \\\"_approval: caller is not member\\\" );\\r\\n        require( _doc[ docId ].indexing[msg.sender] == 0, \\\"_approval: already approved\\\" );\\r\\n        require( !_doc[ docId ].invoked, \\\"_approval: already invoked\\\" );\\r\\n\\r\\n        TSigner memory tSigner;\\r\\n        tSigner.approver    = msg.sender;\\r\\n        tSigner.time        = block.timestamp;\\r\\n\\r\\n        _doc[ docId ].indexing[msg.sender]              = _doc[ docId ].approval;\\r\\n        _doc[ docId ].signer[_doc[ docId ].approval]    = tSigner;\\r\\n        _doc[ docId ].approval++;        \\r\\n        emit eventApproval( msg.sender, docId, _isInvokable( docId ) );        \\r\\n    }\\r\\n\\r\\n    function _addMember( address newMember ) internal {\\r\\n        _memberIndex.addIndex( newMember );\\r\\n        emit eventAddMember( newMember ) ;\\r\\n    }\\r\\n\\r\\n    function _removeMember( address member ) internal {\\r\\n        require( _memberIndex.getIndexedSize() > 2, \\\"_removeMember: must have at least 3 members\\\" );\\r\\n        _memberIndex.removeIndex( member );\\r\\n        emit eventRemoveMember( member ) ;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/teamVault/dao/iQuorum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// XEN Contracts v0.6.0\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\n\\r\\ninterface IQuorum {\\r\\n\\r\\nstruct TSigner {\\r\\n    address                         approver;\\r\\n    uint256                         time;\\r\\n}\\r\\n\\r\\nstruct TDraftDoc {\\r\\n    address                         drafter;        //\uae30\uc548\uc790\\r\\n    uint256                         draftDate;      //\uc791\uc131 \ub0a0\uc9dc\\r\\n\\r\\n    uint8                           approval;       //\ub3d9\uc758\ud55c member \uc218\\r\\n    mapping( uint8 => TSigner )     signer;         //\ub3d9\uc758\ud55c account\\r\\n    mapping( address => uint8 )     indexing;\\r\\n\\r\\n\\r\\n    bool                            cancellation;   //\uc548\uac74 \uc0c1\uc815 \ucde8\uc18c\\r\\n    bool                            invoked;        //transaction \ud638\ucd9c \uc5ec\ubd80\\r\\n    uint256                         invokeDate;\\r\\n    address                         to;    \\r\\n    bytes                           callData;\\r\\n    bool                            success;\\r\\n    bytes                           returnData;\\r\\n}\\r\\n\\r\\nstruct TDrafeDocViewer {\\r\\n    address                         drafter;        //\uae30\uc548\uc790\\r\\n    uint256                         draftDate;      //\uc791\uc131 \ub0a0\uc9dc\\r\\n\\r\\n    uint8                           approval;       //\ub3d9\uc758\ud55c member \uc218\\r\\n    bool                            cancellation;   //\uc0c1\uc815 \ucde8\uc18c \uc5ec\ubd80\\r\\n    bool                            invoked;        //transaction \ud638\ucd9c \uc5ec\ubd80\\r\\n    uint256                         invokeDate;     //\uc2e4\ud589\ud55c \ub0a0\uc9dc\\r\\n    address                         to;             //\ud638\ucd9c \ud560 contract address -> 0.6.0.2 \uc774\uc0c1 \ubc84\uc804\\r\\n}\\r\\n\\r\\n    function invoke( uint256 docId ) external;\\r\\n    function cancel( uint256 docId ) external;\\r\\n    \\r\\n    function inquery( uint256 docId ) external view returns( TDrafeDocViewer memory doc );\\r\\n    function inqueryApprover( uint256 docId ) external view returns( TSigner[] memory approvers );\\r\\n    function inqueryCallData( uint256 docId ) external view returns( address, string memory, bytes memory );\\r\\n    function inqueryReturnData( uint256 docId ) external view returns( bool, bool, bytes memory );\\r\\n\\r\\n    function inqueryMembers() external view returns( address[] memory members);\\r\\n    function inqueryNumberOfMembers() external view returns( uint256 );\\r\\n    function inqueryLatestId() external view returns( uint256 );\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/teamVault/index/addressIndex.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// XEN Contracts v0.6.0\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nimport {_CJeffBaseOwnerShip}                    from '../base/jeffBaseOwnerShip.sol';\\r\\n\\r\\n//index 1 \ubd80\ud130 \uc2dc\uc791 \ud568\\r\\ncontract CAddressIndexing is _CJeffBaseOwnerShip {\\r\\n\\r\\n    uint256                         internal _mIndexSize;\\r\\n    mapping(address => uint256)     internal _mAddress;\\r\\n    mapping(uint256 => address)     internal _mIndex;\\r\\n\\r\\n    constructor() {\\r\\n        _mIndexSize = 1;\\r\\n    }\\r\\n\\r\\n    function _addIndex( address account ) internal returns(bool res){\\r\\n      assembly {\\r\\n        function getSlotAddress(acc) -> a {\\r\\n            mstore(0, acc)\\r\\n            mstore(32, _mAddress.slot)\\r\\n            a := keccak256(0, 64)\\r\\n        }\\r\\n        function getSlotIndex(idx) -> a {\\r\\n            mstore(0, idx)\\r\\n            mstore(32, _mIndex.slot)\\r\\n            a := keccak256(0, 64)\\r\\n        }            \\r\\n\\r\\n        let slotAccount   := getSlotAddress( account )\\r\\n        let slotIndexSize := _mIndexSize.slot\\r\\n\\r\\n        let accountIndex  := sload(slotAccount) \\r\\n        let indexSize     := sload(slotIndexSize)\\r\\n\\r\\n        if or( eq(indexSize, 1), iszero( accountIndex )) {\\r\\n          let slotIndex := getSlotIndex(indexSize)\\r\\n          sstore(slotAccount, indexSize)\\r\\n          sstore(slotIndex, account)\\r\\n          sstore(slotIndexSize, add(indexSize,1))\\r\\n          res := 1\\r\\n        }\\r\\n      }\\r\\n      return res;\\r\\n    }    \\r\\n    \\r\\n    function _removeIndex( address account ) internal {\\r\\n      assembly {\\r\\n        function getSlotAddress(acc) -> a {\\r\\n            mstore(0, acc)\\r\\n            mstore(32, _mAddress.slot)\\r\\n            a := keccak256(0, 64)\\r\\n        }\\r\\n        function getSlotIndex(idx) -> a {\\r\\n            mstore(0, idx)\\r\\n            mstore(32, _mIndex.slot)\\r\\n            a := keccak256(0, 64)\\r\\n        }        \\r\\n\\r\\n        let slotIndexSize := _mIndexSize.slot\\r\\n        let indexSize     := sload(slotIndexSize)\\r\\n\\r\\n        let slotAccount   := getSlotAddress( account )\\r\\n        let accountIndex  := sload(slotAccount) \\r\\n\\r\\n        let lastIdx       := sub( indexSize, 1 )\\r\\n        let slotLastIndex := getSlotIndex(lastIdx)\\r\\n\\r\\n        if gt( accountIndex, 0 ) {\\r\\n          switch eq( lastIdx, accountIndex ) \\r\\n          case 0 {\\r\\n            let slotIndex := getSlotIndex(accountIndex)\\r\\n            let lastAddress := sload(slotLastIndex)\\r\\n            sstore( slotIndex, lastAddress )\\r\\n            \\r\\n            let slotLastAddress := getSlotAddress( lastAddress )\\r\\n            sstore( slotLastAddress, accountIndex )\\r\\n          }\\r\\n          sstore( slotAccount, 0 )\\r\\n          sstore( slotLastIndex, 0 )\\r\\n          sstore( slotIndexSize, lastIdx )\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    function _getIndex( address val ) internal view returns( uint256 ){\\r\\n        return _mAddress[ val ];\\r\\n    }\\r\\n\\r\\n    //index: 1\ubd80\ud130 \uc2dc\uc791\\r\\n    function _getAddress( uint256 index ) internal view returns( address ){\\r\\n        return _mIndex[index];\\r\\n    }\\r\\n\\r\\n    function _getIndexedSize() internal view returns( uint256 ) {\\r\\n        return _mIndexSize -1;\\r\\n    }\\r\\n\\r\\n    ////////////////////////////////////////////////////////////////////////////////\\r\\n    //public\\r\\n    function addIndex( address val ) public onlyOwner returns(bool) {\\r\\n        return _addIndex( val );\\r\\n    }\\r\\n    \\r\\n    function removeIndex( address val ) public onlyOwner {\\r\\n        _removeIndex( val );\\r\\n    }\\r\\n\\r\\n    function getIndex( address val ) public view returns( uint256 ){\\r\\n        return _getIndex( val );\\r\\n    }\\r\\n\\r\\n    function getAddress( uint256 index ) public view returns( address ){\\r\\n        return _getAddress( index );\\r\\n    }\\r\\n\\r\\n    function getIndexedSize() public view returns( uint256 ) {\\r\\n        return _getIndexedSize();\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/teamVault/security/reentrancyGuards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// XEN Contracts v0.6.0\\r\\npragma solidity ^0.8.1;\\r\\n\\r\\ncontract _CReentrancyGuards {\\r\\n    bool        private                 _bGuard;\\r\\n    modifier noReentrancy() {\\r\\n        require( !_bGuard, \\\"Reentrant call\\\" );\\r\\n        _bGuard = true;\\r\\n        _;\\r\\n        _bGuard = false;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/teamVault/base/jeffBaseOwnerShip.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\n/*\\r\\n    Edition:\\r\\n        V0.6.0.2    -   2023.08.30\\r\\n\\r\\n*/\\r\\ncontract _CJeffBaseOwnerShip is Ownable {\\r\\n\\r\\n    constructor() {\\r\\n    }\\r\\n\\r\\n    function _isContract( address a ) internal view returns(bool){\\r\\n      uint32 size;\\r\\n      assembly {\\r\\n        size := extcodesize(a)\\r\\n      }\\r\\n      return (size > 0);\\r\\n    }\\r\\n\\r\\n    modifier onlyOwnerShip() {\\r\\n        require( Ownable(msg.sender).owner() == owner(), \\\"onlyOwnerShip: caller' owner is different\\\" );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwnerShipEx() {\\r\\n        if( msg.sender != owner() ) {\\r\\n            if( _isContract( msg.sender )) { // caller\uac00 contract \uc774\uba74\\r\\n                try Ownable(msg.sender).owner() returns ( address res ) {\\r\\n                    //\ud638\ucd9c\ud55c contract\uc758 owner\uc640 this owner\uac00 \ub3d9\uc77c \ud574\uc57c \ud55c\ub2e4\\r\\n                    require( res == owner(), \\\"onlyOwnerShipEx: caller' owner is different\\\" );\\r\\n                } catch {\\r\\n                    revert( \\\"onlyOwnerShipEx: caller does not have ownable interface\\\" );\\r\\n                }\\r\\n            } else { //caller\uac00 account \uc774\uba74\\r\\n                revert( \\\"onlyOwnerShipEx: caller is not owner\\\" );\\r\\n            }\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function owner() public view virtual override(Ownable) returns (address) {\\r\\n        return Ownable.owner();\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newMember\",\"type\":\"address\"}],\"name\":\"eventAddMember\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"approvor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"docId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"invokable\",\"type\":\"bool\"}],\"name\":\"eventApproval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"docId\",\"type\":\"uint256\"}],\"name\":\"eventCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"docId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"name\":\"eventInvoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"drafter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"docId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"invokable\",\"type\":\"bool\"}],\"name\":\"eventProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"eventRemoveMember\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"docId\",\"type\":\"uint256\"}],\"name\":\"approval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"docId\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"expulsion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"docId\",\"type\":\"uint256\"}],\"name\":\"inquery\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"drafter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"draftDate\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"approval\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"cancellation\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"invoked\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"invokeDate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"internalType\":\"struct IQuorum.TDrafeDocViewer\",\"name\":\"doc\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"docId\",\"type\":\"uint256\"}],\"name\":\"inqueryApprover\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct IQuorum.TSigner[]\",\"name\":\"approvers\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"docId\",\"type\":\"uint256\"}],\"name\":\"inqueryCallData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inqueryLatestId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inqueryMembers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"members\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inqueryNumberOfMembers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"docId\",\"type\":\"uint256\"}],\"name\":\"inqueryReturnData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"docId\",\"type\":\"uint256\"}],\"name\":\"invoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toContract\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"funcSignatrue\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"funcParams\",\"type\":\"bytes\"}],\"name\":\"proposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"proposalApprove\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"proposalExpulsion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMember\",\"type\":\"address\"}],\"name\":\"proposalRecommend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"proposalTransfer1155\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"proposalTransfer20\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"proposalTransfer721\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMember\",\"type\":\"address\"}],\"name\":\"recommend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CTeamVault", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "20", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}