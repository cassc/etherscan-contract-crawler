{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/contracts/authorities/AuthorityControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {Context} from '@openzeppelin/contracts/utils/Context.sol';\\n\\nimport {CannotSetNullAddress} from '@floor/utils/Errors.sol';\\n\\nimport {IAuthorityControl} from '@floor-interfaces/authorities/AuthorityControl.sol';\\nimport {IAuthorityRegistry} from '@floor-interfaces/authorities/AuthorityRegistry.sol';\\n\\n/// If the account does not have the required role for the call.\\n/// @param caller The address making the call\\n/// @param role The role that is required for the call\\nerror AccountDoesNotHaveRole(address caller, bytes32 role);\\n\\n/// If the account does not have the required admin role for the call.\\n/// @param caller The address making the call\\nerror AccountDoesNotHaveAdminRole(address caller);\\n\\n/**\\n * This contract is heavily based on the standardised OpenZeppelin `AccessControl` library.\\n * This allows for the creation of role based access levels that can be assigned to 1-n\\n * addresses.\\n *\\n * Contracts will be able to implement the AuthorityControl to provide access to the `onlyRole` modifier or the\\n * `hasRole` function. This will ensure that the `msg.sender` is allowed to perform an action.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed in the external API and be\\n * unique. The best way to achieve this is by using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"TreasuryManager\\\");\\n * ```\\n */\\ncontract AuthorityControl is Context, IAuthorityControl {\\n    /// CollectionManager - Can approve token addresses to be allowed to be used in strategies\\n    bytes32 public constant COLLECTION_MANAGER = keccak256('CollectionManager');\\n\\n    /// EpochTrigger - Can run epoch trigger contract specific logic\\n    bytes32 public constant EPOCH_TRIGGER = keccak256('EpochTrigger');\\n\\n    /// FloorManager - Can mint and manage Floor and VeFloor tokens\\n    bytes32 public constant FLOOR_MANAGER = keccak256('FloorManager');\\n\\n    /// Governor - A likely DAO owned vote address to allow for wide scale decisions to\\n    /// be made and implemented.\\n    bytes32 public constant GOVERNOR = keccak256('Governor');\\n\\n    /// Guardian - Wallet address that will allow for Governor based actions, except without\\n    /// timeframe restrictions.\\n    bytes32 public constant GUARDIAN = keccak256('Guardian');\\n\\n    /// TreasuryManager - Access to Treasury asset management\\n    bytes32 public constant TREASURY_MANAGER = keccak256('TreasuryManager');\\n\\n    /// StrategyManager - Can create new strategies against approved strategies and collections\\n    bytes32 public constant STRATEGY_MANAGER = keccak256('StrategyManager');\\n\\n    /// VoteManager - Can manage account votes\\n    bytes32 public constant VOTE_MANAGER = keccak256('VoteManager');\\n\\n    /// Reference to the {AuthorityRegistry} contract that maintains role allocations\\n    IAuthorityRegistry public immutable registry;\\n\\n    /**\\n     * Modifier that checks that an account has a specific role. Reverts with a\\n     * standardized message if user does not have specified role.\\n     *\\n     * @param role The keccak256 encoded role string\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        if (!registry.hasRole(role, _msgSender())) {\\n            revert AccountDoesNotHaveRole(_msgSender(), role);\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * Modifier that checks that an account has a governor or guardian role.\\n     * Reverts with a standardized message if sender does not have an admin role.\\n     */\\n    modifier onlyAdminRole() {\\n        if (!registry.hasAdminRole(_msgSender())) {\\n            revert AccountDoesNotHaveAdminRole(_msgSender());\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * The address that deploys the {AuthorityControl} becomes the default controller. This\\n     * can only be overwritten by the existing.\\n     *\\n     * @param _registry The address of our deployed AuthorityRegistry contract\\n     */\\n    constructor(address _registry) {\\n        if (_registry == address(0)) revert CannotSetNullAddress();\\n        registry = IAuthorityRegistry(_registry);\\n    }\\n\\n    /**\\n     * Returns `true` if `account` has been granted `role`.\\n     *\\n     * @param role The keccak256 encoded role string\\n     * @param account Address to check ownership of role\\n     *\\n     * @return bool If the address has the specified user role\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return registry.hasRole(role, account);\\n    }\\n\\n    /**\\n     * Returns `true` if `account` has been granted either GOVERNOR or GUARDIAN role.\\n     *\\n     * @param account Address to check ownership of role\\n     *\\n     * @return bool If the address has the GOVERNOR or GUARDIAN role\\n     */\\n    function hasAdminRole(address account) public view returns (bool) {\\n        return registry.hasAdminRole(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/utils/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\n/**\\n * A collection of generic errors that can be referenced across multiple\\n * contracts. Contract-specific errors should still be stored in their\\n * individual Solidity files.\\n */\\n\\n/// If a NULL address tries to be stored which should not be accepted\\nerror CannotSetNullAddress();\\n\\n/// If the caller has entered an insufficient amount to process the action. This\\n/// will likely be a zero amount.\\nerror InsufficientAmount();\\n\\n/// If the caller enters a percentage value that is too high for the requirements\\nerror PercentageTooHigh(uint amount);\\n\\n/// If a required ETH or token `transfer` call fails\\nerror TransferFailed();\\n\\n/// If a user calls a deposit related function with a zero amount\\nerror CannotDepositZeroAmount();\\n\\n/// If a user calls a withdrawal related function with a zero amount\\nerror CannotWithdrawZeroAmount();\\n\\n/// If there are no rewards available to be claimed\\nerror NoRewardsAvailableToClaim();\\n\\n/// If the requested collection is not approved\\n/// @param collection Address of the collection requested\\nerror CollectionNotApproved(address collection);\\n\\n/// If the requested strategy implementation is not approved\\n/// @param strategyImplementation Address of the strategy implementation requested\\nerror StrategyNotApproved(address strategyImplementation);\\n\"\r\n    },\r\n    \"src/interfaces/authorities/AuthorityControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IAuthorityControl {\\n    /// CollectionManager - Can approve token addresses to be allowed to be used in strategies\\n    function COLLECTION_MANAGER() external returns (bytes32);\\n\\n    /// EpochTrigger - Can run epoch trigger contract specific logic\\n    function EPOCH_TRIGGER() external returns (bytes32);\\n\\n    /// FloorManager - Can mint and manage Floor and VeFloor tokens\\n    function FLOOR_MANAGER() external returns (bytes32);\\n\\n    /// Governor - A likely DAO owned vote address to allow for wide scale decisions to\\n    /// be made and implemented.\\n    function GOVERNOR() external returns (bytes32);\\n\\n    /// Guardian - Wallet address that will allow for Governor based actions, except without\\n    /// timeframe restrictions.\\n    function GUARDIAN() external returns (bytes32);\\n\\n    /// TreasuryManager - Access to Treasury asset management\\n    function TREASURY_MANAGER() external returns (bytes32);\\n\\n    /// StrategyManager - Can create new strategies against approved strategies and collections\\n    function STRATEGY_MANAGER() external returns (bytes32);\\n\\n    /// VoteManager - Can manage account votes\\n    function VOTE_MANAGER() external returns (bytes32);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted either the GOVERNOR or\\n     * GUARDIAN `role`.\\n     */\\n    function hasAdminRole(address account) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/authorities/AuthorityRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * This interface expands upon the OpenZeppelin `IAccessControl` interface:\\n * https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/master/contracts/access/IAccessControl.sol\\n */\\n\\ninterface IAuthorityRegistry {\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted either the GOVERNOR or\\n     * GUARDIAN `role`.\\n     */\\n    function hasAdminRole(address account) external view returns (bool);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@uniswap-v3/=lib/\",\r\n      \"@uniswap/v3-periphery/=lib/v3-periphery/\",\r\n      \"@chainlink/=lib/chainlink/\",\r\n      \"@murky/=lib/murky/src/\",\r\n      \"@solidity-math-utils/=lib/solidity-math-utils/project/contracts/\",\r\n      \"@solidity-trigonometry/=lib/solidity-trigonometry/src/\",\r\n      \"@1inch/=lib/\",\r\n      \"@charmfi/=lib/charmfi-contracts-0.8.0-support/\",\r\n      \"@sudoswap/=lib/lssvm/src/\",\r\n      \"@floor/=src/contracts/\",\r\n      \"@floor-interfaces/=src/interfaces/\",\r\n      \"@floor-scripts/=script/\",\r\n      \"@ERC721A/=lib/ERC721A/contracts/\",\r\n      \"foundry-random/=lib/foundry-random/src/\",\r\n      \"lssvm2/=lib/lssvm2/src/\",\r\n      \"@nftx-protocol-v3/=lib/nftx-protocol-v3/src/\",\r\n      \"@manifoldxyz/=lib/lssvm2/lib/\",\r\n      \"@mocks/=lib/nftx-protocol-v3/src/mocks/\",\r\n      \"@permit2/=lib/nftx-protocol-v3/lib/permit2/src/\",\r\n      \"@prb/math/=lib/lssvm2/lib/prb-math/src/\",\r\n      \"@prb/test/=lib/foundry-random/lib/prb-test/src/\",\r\n      \"@src/=lib/nftx-protocol-v3/src/\",\r\n      \"@test/=lib/nftx-protocol-v3/test/\",\r\n      \"@uni-core/=lib/nftx-protocol-v3/src/uniswap/v3-core/\",\r\n      \"@uni-periphery/=lib/nftx-protocol-v3/src/uniswap/v3-periphery/\",\r\n      \"@uniswap/lib/=lib/nftx-protocol-v3/lib/solidity-lib/\",\r\n      \"@uniswap/v2-core/=lib/nftx-protocol-v3/lib/v2-core/\",\r\n      \"@uniswap/v3-core/contracts/=lib/nftx-protocol-v3/src/uniswap/v3-core/\",\r\n      \"CramBit/=lib/foundry-random/lib/CramBit/\",\r\n      \"ERC721A/=lib/ERC721A/contracts/\",\r\n      \"base64-sol/=lib/nftx-protocol-v3/src/uniswap/v3-periphery/libraries/\",\r\n      \"chainlink/=lib/chainlink/\",\r\n      \"charmfi-contracts-0.8.0-support/=lib/charmfi-contracts-0.8.0-support/\",\r\n      \"clones-with-immutable-args/=lib/lssvm2/lib/clones-with-immutable-args/src/\",\r\n      \"crambit/=lib/foundry-random/lib/CramBit/src/\",\r\n      \"create2-helpers/=lib/lssvm2/lib/royalty-registry-solidity/lib/create2-helpers/\",\r\n      \"create3-factory/=lib/lssvm2/lib/create3-factory/\",\r\n      \"foundry-huff/=lib/lssvm2/lib/foundry-huff/src/\",\r\n      \"foundry-random/=lib/foundry-random/src/\",\r\n      \"huffmate/=lib/lssvm2/lib/huffmate/src/\",\r\n      \"libraries-solidity/=lib/lssvm2/lib/libraries-solidity/contracts/\",\r\n      \"lssvm/=lib/lssvm/src/\",\r\n      \"lssvm2/=lib/lssvm2/src/\",\r\n      \"manifoldxyz/=lib/lssvm2/lib/royalty-registry-solidity/contracts/\",\r\n      \"murky/=lib/murky/src/\",\r\n      \"nftx-protocol-v3/=lib/nftx-protocol-v3/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"prb-math/=lib/solidity-trigonometry/lib/prb-math/contracts/\",\r\n      \"prb-test/=lib/foundry-random/lib/prb-test/src/\",\r\n      \"royalty-registry-solidity.git/=lib/lssvm/lib/royalty-registry-solidity.git/contracts/\",\r\n      \"royalty-registry-solidity/=lib/lssvm2/lib/royalty-registry-solidity/\",\r\n      \"solidity-bytes-utils/=lib/foundry-random/lib/solidity-bytes-utils/contracts/\",\r\n      \"solidity-math-utils/=lib/solidity-math-utils/\",\r\n      \"solidity-stringutils/=lib/lssvm2/lib/foundry-huff/lib/solidity-stringutils/\",\r\n      \"solidity-trigonometry/=lib/solidity-trigonometry/src/\",\r\n      \"solidity-utils/=lib/solidity-utils/contracts/\",\r\n      \"solmate/=lib/lssvm2/lib/solmate/src/\",\r\n      \"src/=lib/foundry-random/src/\",\r\n      \"stringutils/=lib/lssvm2/lib/foundry-huff/lib/solidity-stringutils/\",\r\n      \"v3-core/=lib/v3-core/contracts/\",\r\n      \"v3-periphery/=lib/v3-periphery/contracts/\",\r\n      \"weird-erc20/=lib/lssvm/lib/solmate/lib/weird-erc20/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CannotSetNullAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"COLLECTION_MANAGER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EPOCH_TRIGGER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FLOOR_MANAGER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GOVERNOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GUARDIAN\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STRATEGY_MANAGER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TREASURY_MANAGER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VOTE_MANAGER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasAdminRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract IAuthorityRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AuthorityControl", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a864ecf7751348592307a089468a429c5dc7d693", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}