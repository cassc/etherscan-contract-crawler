{"SourceCode": "pragma solidity 0.6.7;\r\n\r\n\r\n\r\ncontract GebMath {\r\n    uint256 public constant RAY = 10 ** 27;\r\n    uint256 public constant WAD = 10 ** 18;\r\n\r\n    function ray(uint x) public pure returns (uint z) {\r\n        z = multiply(x, 10 ** 9);\r\n    }\r\n    function rad(uint x) public pure returns (uint z) {\r\n        z = multiply(x, 10 ** 27);\r\n    }\r\n    function minimum(uint x, uint y) public pure returns (uint z) {\r\n        z = (x <= y) ? x : y;\r\n    }\r\n    function addition(uint x, uint y) public pure returns (uint z) {\r\n        z = x + y;\r\n        require(z >= x, \"uint-uint-add-overflow\");\r\n    }\r\n    function subtract(uint x, uint y) public pure returns (uint z) {\r\n        z = x - y;\r\n        require(z <= x, \"uint-uint-sub-underflow\");\r\n    }\r\n    function multiply(uint x, uint y) public pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"uint-uint-mul-overflow\");\r\n    }\r\n    function rmultiply(uint x, uint y) public pure returns (uint z) {\r\n        z = multiply(x, y) / RAY;\r\n    }\r\n    function rdivide(uint x, uint y) public pure returns (uint z) {\r\n        z = multiply(x, RAY) / y;\r\n    }\r\n    function wdivide(uint x, uint y) public pure returns (uint z) {\r\n        z = multiply(x, WAD) / y;\r\n    }\r\n    function wmultiply(uint x, uint y) public pure returns (uint z) {\r\n        z = multiply(x, y) / WAD;\r\n    }\r\n    function rpower(uint x, uint n, uint base) public pure returns (uint z) {\r\n        assembly {\r\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\r\n            default {\r\n                switch mod(n, 2) case 0 { z := base } default { z := x }\r\n                let half := div(base, 2)  // for rounding.\r\n                for { n := div(n, 2) } n { n := div(n,2) } {\r\n                    let xx := mul(x, x)\r\n                    if iszero(eq(div(xx, x), x)) { revert(0,0) }\r\n                    let xxRound := add(xx, half)\r\n                    if lt(xxRound, xx) { revert(0,0) }\r\n                    x := div(xxRound, base)\r\n                    if mod(n,2) {\r\n                        let zx := mul(z, x)\r\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\r\n                        let zxRound := add(zx, half)\r\n                        if lt(zxRound, zx) { revert(0,0) }\r\n                        z := div(zxRound, base)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ninterface AggregatorInterface {\r\n    event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\r\n    event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\r\n\r\n    function latestAnswer() external view returns (int256);\r\n    function latestTimestamp() external view returns (uint256);\r\n    function latestRound() external view returns (uint256);\r\n    function getAnswer(uint256 roundId) external view returns (int256);\r\n    function getTimestamp(uint256 roundId) external view returns (uint256);\r\n\r\n    // post-Historic\r\n\r\n    function decimals() external view returns (uint8);\r\n    function getRoundData(uint256 _roundId)\r\n      external\r\n      view\r\n      returns (\r\n        uint256 roundId,\r\n        int256 answer,\r\n        uint256 startedAt,\r\n        uint256 updatedAt,\r\n        uint256 answeredInRound\r\n      );\r\n    function latestRoundData()\r\n      external\r\n      view\r\n      returns (\r\n        uint256 roundId,\r\n        int256 answer,\r\n        uint256 startedAt,\r\n        uint256 updatedAt,\r\n        uint256 answeredInRound\r\n      );\r\n}\r\n\r\n\r\ncontract ChainlinkTWAP is GebMath {\r\n\r\n    // --- Variables ---\r\n    AggregatorInterface public immutable chainlinkAggregator;\r\n\r\n    // Delay between updates after which the reward starts to increase\r\n    uint256 public immutable periodSize;\r\n    // Timestamp of the Chainlink aggregator\r\n    uint256 public linkAggregatorTimestamp;\r\n    // Last timestamp when the median was updated\r\n    uint256 public lastUpdateTime;                  // [unix timestamp]\r\n    // Cumulative result\r\n    uint256 public converterResultCumulative;\r\n    // Latest result\r\n    uint256 private medianResult;                   // [wad]\r\n    /**\r\n      The ideal amount of time over which the moving average should be computed, e.g. 24 hours.\r\n      In practice it can and most probably will be different than the actual window over which the contract medianizes.\r\n    **/\r\n    uint256 public immutable windowSize;\r\n    // Maximum window size used to determine if the median is 'valid' (close to the real one) or not\r\n    uint256 public immutable maxWindowSize;\r\n    // Total number of updates\r\n    uint256 public updates;\r\n    // Multiplier for the Chainlink result\r\n    uint256 public immutable multiplier;\r\n    // Number of updates in the window\r\n    uint8   public immutable granularity;\r\n\r\n    // You want to change these every deployment\r\n    bytes32 public immutable symbol = \"fast-gas\";\r\n\r\n    ChainlinkObservation[] public chainlinkObservations;\r\n\r\n    // --- Structs ---\r\n    struct ChainlinkObservation {\r\n        uint timestamp;\r\n        uint timeAdjustedResult;\r\n    }\r\n\r\n    // --- Events ---\r\n    event UpdateResult(uint256 result);\r\n\r\n    constructor(\r\n      address aggregator,\r\n      uint256 windowSize_,\r\n      uint256 maxWindowSize_,\r\n      uint256 multiplier_,\r\n      uint8   granularity_\r\n    ) public {\r\n        require(aggregator != address(0), \"ChainlinkTWAP/null-aggregator\");\r\n        require(multiplier_ >= 1, \"ChainlinkTWAP/null-multiplier\");\r\n        require(granularity_ > 1, 'ChainlinkTWAP/null-granularity');\r\n        require(windowSize_ > 0, 'ChainlinkTWAP/null-window-size');\r\n        require(\r\n          (periodSize = windowSize_ / granularity_) * granularity_ == windowSize_,\r\n          'ChainlinkTWAP/window-not-evenly-divisible'\r\n        );\r\n\r\n        windowSize                     = windowSize_;\r\n        maxWindowSize                  = maxWindowSize_;\r\n        granularity                    = granularity_;\r\n        multiplier                     = multiplier_;\r\n\r\n        chainlinkAggregator            = AggregatorInterface(aggregator);\r\n    }\r\n\r\n    // --- Boolean Utils ---\r\n    function both(bool x, bool y) internal pure returns (bool z) {\r\n        assembly{ z := and(x, y)}\r\n    }\r\n\r\n    // --- General Utils ---\r\n    /**\r\n    * @notice Returns the oldest observations (relative to the current index in the Uniswap/Converter lists)\r\n    **/\r\n    function getFirstObservationInWindow()\r\n      private view returns (ChainlinkObservation storage firstChainlinkObservation) {\r\n        uint256 earliestObservationIndex = earliestObservationIndex();\r\n        firstChainlinkObservation        = chainlinkObservations[earliestObservationIndex];\r\n    }\r\n    /**\r\n      @notice It returns the time passed since the first observation in the window\r\n    **/\r\n    function timeElapsedSinceFirstObservation() public view returns (uint256) {\r\n        if (updates > 1) {\r\n          ChainlinkObservation memory firstChainlinkObservation = getFirstObservationInWindow();\r\n          return subtract(now, firstChainlinkObservation.timestamp);\r\n        }\r\n        return 0;\r\n    }\r\n    /**\r\n    * @notice Returns the index of the earliest observation in the window\r\n    **/\r\n    function earliestObservationIndex() public view returns (uint256) {\r\n        if (updates <= granularity) {\r\n          return 0;\r\n        }\r\n        return subtract(updates, uint(granularity));\r\n    }\r\n    /**\r\n    * @notice Get the observation list length\r\n    **/\r\n    function getObservationListLength() public view returns (uint256) {\r\n        return chainlinkObservations.length;\r\n    }\r\n\r\n    // --- Main Getters ---\r\n    /**\r\n    * @notice Fetch the latest medianResult or revert if is is null\r\n    **/\r\n    function read() external view returns (uint256) {\r\n        require(\r\n          both(both(medianResult > 0, updates > granularity), timeElapsedSinceFirstObservation() <= maxWindowSize),\r\n          \"ChainlinkTWAP/invalid-price-feed\"\r\n        );\r\n        return multiply(medianResult, multiplier);\r\n    }\r\n    /**\r\n    * @notice Fetch the latest medianResult and whether it is null or not\r\n    **/\r\n    function getResultWithValidity() external view returns (uint256, bool) {\r\n        return (\r\n          multiply(medianResult, multiplier),\r\n          both(both(medianResult > 0, updates > granularity), timeElapsedSinceFirstObservation() <= maxWindowSize)\r\n        );\r\n    }\r\n\r\n    // --- Median Updates ---\r\n    /*\r\n    * @notify Update the moving average\r\n    * @param feeReceiver The address that will receive a SF payout for calling this function\r\n    */\r\n    function updateResult() external {\r\n        uint256 elapsedTime = (chainlinkObservations.length == 0) ?\r\n          periodSize : subtract(now, chainlinkObservations[chainlinkObservations.length - 1].timestamp);\r\n\r\n        // Check delay between calls\r\n        require(elapsedTime >= periodSize, \"ChainlinkTWAP/wait-more\");\r\n\r\n        (, int256 aggregatorResult, , uint256 aggregatorTimestamp, ) = chainlinkAggregator.latestRoundData();\r\n\r\n        require(aggregatorResult > 0, \"ChainlinkTWAP/invalid-feed-result\");\r\n        require(both(aggregatorTimestamp > 0, aggregatorTimestamp > linkAggregatorTimestamp), \"ChainlinkTWAP/invalid-timestamp\");\r\n\r\n        // Get current first observation timestamp\r\n        uint256 timeSinceFirst;\r\n        if (updates > 0) {\r\n          ChainlinkObservation memory firstUniswapObservation = getFirstObservationInWindow();\r\n          timeSinceFirst = subtract(now, firstUniswapObservation.timestamp);\r\n        } else {\r\n          timeSinceFirst = elapsedTime;\r\n        }\r\n\r\n        // Update the observations array\r\n        updateObservations(elapsedTime, uint256(aggregatorResult));\r\n\r\n        // Update var state\r\n        medianResult            = converterResultCumulative / timeSinceFirst;\r\n        updates                 = addition(updates, 1);\r\n        linkAggregatorTimestamp = aggregatorTimestamp;\r\n        lastUpdateTime          = now;\r\n\r\n        emit UpdateResult(medianResult);\r\n    }\r\n    /**\r\n    * @notice Push new observation data in the observation array\r\n    * @param timeElapsedSinceLatest Time elapsed between now and the earliest observation in the window\r\n    * @param newResult Latest result coming from Chainlink\r\n    **/\r\n    function updateObservations(\r\n      uint256 timeElapsedSinceLatest,\r\n      uint256 newResult\r\n    ) internal {\r\n        // Compute the new time adjusted result\r\n        uint256 newTimeAdjustedResult = multiply(newResult, timeElapsedSinceLatest);\r\n        // Add Chainlink observation\r\n        chainlinkObservations.push(ChainlinkObservation(now, newTimeAdjustedResult));\r\n        // Add the new update\r\n        converterResultCumulative = addition(converterResultCumulative, newTimeAdjustedResult);\r\n\r\n        // Subtract the earliest update\r\n        if (updates >= granularity) {\r\n          ChainlinkObservation memory chainlinkObservation = getFirstObservationInWindow();\r\n          converterResultCumulative = subtract(converterResultCumulative, chainlinkObservation.timeAdjustedResult);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"windowSize_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWindowSize_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"multiplier_\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"granularity_\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"name\":\"UpdateResult\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"RAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WAD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"addition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainlinkAggregator\",\"outputs\":[{\"internalType\":\"contract AggregatorInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"chainlinkObservations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeAdjustedResult\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"converterResultCumulative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earliestObservationIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getObservationListLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getResultWithValidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"granularity\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"linkAggregatorTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWindowSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"minimum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"multiply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"rad\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"ray\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"rdivide\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"read\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"rmultiply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"base\",\"type\":\"uint256\"}],\"name\":\"rpower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"subtract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeElapsedSinceFirstObservation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateResult\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"wdivide\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"windowSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"wmultiply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "ChainlinkTWAP", "CompilerVersion": "v0.6.7+commit.b8d736ae", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b84190000000000000000000000000000000000000000000000000000000000093a80000000000000000000000000000000000000000000000000000000000012750000000000000000000000000000000000000000000000000000000002540be400000000000000000000000000000000000000000000000000000000000000000e", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ce6de25906b704300c2cf8fecec20596702befdb3e2beeab6c858b0d22527bab"}