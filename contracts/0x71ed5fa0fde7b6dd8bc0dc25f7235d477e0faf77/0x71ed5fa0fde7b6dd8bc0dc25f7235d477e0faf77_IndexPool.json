{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"temp-contracts/balancer/BConst.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\n\\n\\n/************************************************************************************************\\nOriginally from https://github.com/balancer-labs/balancer-core/blob/master/contracts/BConst.sol\\n\\nThis source code has been modified from the original, which was copied from the github repository\\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\\n\\nSubject to the GPL-3.0 license\\n*************************************************************************************************/\\n\\n\\ncontract BConst {\\n  uint256 public constant VERSION_NUMBER = 0;\\n\\n/* ---  Weight Updates  --- */\\n\\n  // Minimum time passed between each weight update for a token.\\n  uint256 internal constant WEIGHT_UPDATE_DELAY = 1 hours;\\n\\n  // Maximum percent by which a weight can adjust at a time\\n  // relative to the current weight.\\n  // The number of iterations needed to move from weight A to weight B is the floor of:\\n  // (A > B): (ln(A) - ln(B)) / ln(1.01)\\n  // (B > A): (ln(A) - ln(B)) / ln(0.99)\\n  uint256 internal constant WEIGHT_CHANGE_PCT = BONE/100;\\n\\n  uint256 internal constant BONE = 10**18;\\n\\n  uint256 internal constant MIN_BOUND_TOKENS = 2;\\n  uint256 internal constant MAX_BOUND_TOKENS = 10;\\n\\n  // Minimum swap fee.\\n  uint256 internal constant MIN_FEE = BONE / 10**6;\\n  // Maximum swap or exit fee.\\n  uint256 internal constant MAX_FEE = BONE / 10;\\n  // Actual exit fee.\\n  uint256 internal constant EXIT_FEE = 0;\\n\\n  // Default total of all desired weights. Can differ by up to BONE.\\n  uint256 internal constant DEFAULT_TOTAL_WEIGHT = BONE * 25;\\n  // Minimum weight for any token (1/100).\\n  uint256 internal constant MIN_WEIGHT = BONE / 4;\\n  uint256 internal constant MAX_WEIGHT = BONE * 25;\\n  // Maximum total weight.\\n  uint256 internal constant MAX_TOTAL_WEIGHT = BONE * 26;\\n  // Minimum balance for a token (only applied at initialization)\\n  uint256 internal constant MIN_BALANCE = BONE / 10**12;\\n  // Initial pool tokens\\n  uint256 internal constant INIT_POOL_SUPPLY = BONE * 100;\\n\\n  uint256 internal constant MIN_BPOW_BASE = 1 wei;\\n  uint256 internal constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\\n  uint256 internal constant BPOW_PRECISION = BONE / 10**10;\\n\\n  // Maximum ratio of input tokens to balance for swaps.\\n  uint256 internal constant MAX_IN_RATIO = BONE / 2;\\n  // Maximum ratio of output tokens to balance for swaps.\\n  uint256 internal constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\\n}\\n\"\r\n    },\r\n    \"temp-contracts/balancer/BMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\n\\nimport \\\"./BNum.sol\\\";\\n\\n\\n/************************************************************************************************\\nOriginally from https://github.com/balancer-labs/balancer-core/blob/master/contracts/BMath.sol\\n\\nThis source code has been modified from the original, which was copied from the github repository\\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\\n\\nSubject to the GPL-3.0 license\\n*************************************************************************************************/\\n\\n\\ncontract BMath is BConst, BNum {\\n  /**********************************************************************************************\\n    // calcSpotPrice                                                                             //\\n    // sP = spotPrice                                                                            //\\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n  function calcSpotPrice(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 spotPrice) {\\n    uint256 numer = bdiv(tokenBalanceIn, tokenWeightIn);\\n    uint256 denom = bdiv(tokenBalanceOut, tokenWeightOut);\\n    uint256 ratio = bdiv(numer, denom);\\n    uint256 scale = bdiv(BONE, bsub(BONE, swapFee));\\n    return (spotPrice = bmul(ratio, scale));\\n  }\\n\\n  /**********************************************************************************************\\n    // calcOutGivenIn                                                                            //\\n    // aO = tokenAmountOut                                                                       //\\n    // bO = tokenBalanceOut                                                                      //\\n    // bI = tokenBalanceIn              /      /            bI             \\\\    (wI / wO) \\\\      //\\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\\n    // wI = tokenWeightIn               \\\\      \\\\ ( bI + ( aI * ( 1 - sF )) /              /      //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n  function calcOutGivenIn(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 tokenAmountIn,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 tokenAmountOut) {\\n    uint256 weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\\n    uint256 adjustedIn = bsub(BONE, swapFee);\\n    adjustedIn = bmul(tokenAmountIn, adjustedIn);\\n    uint256 y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\\n    uint256 foo = bpow(y, weightRatio);\\n    uint256 bar = bsub(BONE, foo);\\n    tokenAmountOut = bmul(tokenBalanceOut, bar);\\n    return tokenAmountOut;\\n  }\\n\\n  /**********************************************************************************************\\n    // calcInGivenOut                                                                            //\\n    // aI = tokenAmountIn                                                                        //\\n    // bO = tokenBalanceOut               /  /     bO      \\\\    (wO / wI)      \\\\                 //\\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\\n    // aO = tokenAmountOut    aI =        \\\\  \\\\ ( bO - aO ) /                   /                 //\\n    // wI = tokenWeightIn           --------------------------------------------                 //\\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n  function calcInGivenOut(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 tokenAmountOut,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 tokenAmountIn) {\\n    uint256 weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\\n    uint256 diff = bsub(tokenBalanceOut, tokenAmountOut);\\n    uint256 y = bdiv(tokenBalanceOut, diff);\\n    uint256 foo = bpow(y, weightRatio);\\n    foo = bsub(foo, BONE);\\n    tokenAmountIn = bsub(BONE, swapFee);\\n    tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\\n    return tokenAmountIn;\\n  }\\n\\n  /**********************************************************************************************\\n    // calcPoolOutGivenSingleIn                                                                  //\\n    // pAo = poolAmountOut         /                                              \\\\              //\\n    // tAi = tokenAmountIn        ///      /     //    wI \\\\      \\\\\\\\       \\\\     wI \\\\             //\\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\\\    --  \\\\            //\\n    // tW = totalWeight     pAo=||  \\\\      \\\\     \\\\\\\\    tW /      //         | ^ tW   | * pS - pS //\\n    // tBi = tokenBalanceIn      \\\\\\\\  ------------------------------------- /        /            //\\n    // pS = poolSupply            \\\\\\\\                    tBi               /        /             //\\n    // sF = swapFee                \\\\                                              /              //\\n    **********************************************************************************************/\\n  function calcPoolOutGivenSingleIn(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 tokenAmountIn,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 poolAmountOut) {\\n    // Charge the trading fee for the proportion of tokenAi\\n    ///  which is implicitly traded to the other pool tokens.\\n    // That proportion is (1- weightTokenIn)\\n    // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\\n    uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n    uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\\n    uint256 tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\\n\\n    uint256 newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\\n    uint256 tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\\n\\n    // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\\n    uint256 poolRatio = bpow(tokenInRatio, normalizedWeight);\\n    uint256 newPoolSupply = bmul(poolRatio, poolSupply);\\n    poolAmountOut = bsub(newPoolSupply, poolSupply);\\n    return poolAmountOut;\\n  }\\n\\n  /**********************************************************************************************\\n    // calcSingleInGivenPoolOut                                                                  //\\n    // tAi = tokenAmountIn              //(pS + pAo)\\\\     /    1    \\\\\\\\                           //\\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\\n    // pAo = poolAmountOut              \\\\\\\\    pS    /     \\\\(wI / tW)//                           //\\n    // bI = balanceIn          tAi =  --------------------------------------------               //\\n    // wI = weightIn                              /      wI  \\\\                                   //\\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\\n    // sF = swapFee                               \\\\      tW  /                                   //\\n    **********************************************************************************************/\\n  function calcSingleInGivenPoolOut(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 poolAmountOut,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 tokenAmountIn) {\\n    uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n    uint256 newPoolSupply = badd(poolSupply, poolAmountOut);\\n    uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\\n\\n    //uint newBalTi = poolRatio^(1/weightTi) * balTi;\\n    uint256 boo = bdiv(BONE, normalizedWeight);\\n    uint256 tokenInRatio = bpow(poolRatio, boo);\\n    uint256 newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\\n    uint256 tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\\n    // Do reverse order of fees charged in joinswap_ExternAmountIn, this way\\n    //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\\n    //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\\n    uint256 zar = bmul(bsub(BONE, normalizedWeight), swapFee);\\n    tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\\n    return tokenAmountIn;\\n  }\\n\\n  /**********************************************************************************************\\n    // calcSingleOutGivenPoolIn                                                                  //\\n    // tAo = tokenAmountOut            /      /                                             \\\\\\\\   //\\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\\\     /    1    \\\\      \\\\\\\\  //\\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\\n    // ps = poolSupply                \\\\      \\\\\\\\          pS           /     \\\\(wO / tW)/      //  //\\n    // wI = tokenWeightIn      tAo =   \\\\      \\\\                                             //   //\\n    // tW = totalWeight                    /     /      wO \\\\       \\\\                             //\\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\\n    // eF = exitFee                        \\\\     \\\\      tW /       /                             //\\n    **********************************************************************************************/\\n  function calcSingleOutGivenPoolIn(\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 poolAmountIn,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 tokenAmountOut) {\\n    uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n    // charge exit fee on the pool token side\\n    // pAiAfterExitFee = pAi*(1-exitFee)\\n    uint256 poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\\n    uint256 newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\\n    uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\\n\\n    // newBalTo = poolRatio^(1/weightTo) * balTo;\\n    uint256 tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\\n    uint256 newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\\n\\n    uint256 tokenAmountOutBeforeSwapFee = bsub(\\n      tokenBalanceOut,\\n      newTokenBalanceOut\\n    );\\n\\n    // charge swap fee on the output token side\\n    //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\\n    uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\\n    tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\\n    return tokenAmountOut;\\n  }\\n\\n  /**********************************************************************************************\\n    // calcPoolInGivenSingleOut                                                                  //\\n    // pAi = poolAmountIn               // /               tAo             \\\\\\\\     / wO \\\\     \\\\   //\\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\\\   | ---- |     \\\\  //\\n    // tAo = tokenAmountOut      pS - ||   \\\\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\\\ tW /  * pS | //\\n    // ps = poolSupply                 \\\\\\\\ -----------------------------------/                /  //\\n    // wO = tokenWeightOut  pAi =       \\\\\\\\               bO                 /                /   //\\n    // tW = totalWeight           -------------------------------------------------------------  //\\n    // sF = swapFee                                        ( 1 - eF )                            //\\n    // eF = exitFee                                                                              //\\n    **********************************************************************************************/\\n  function calcPoolInGivenSingleOut(\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 tokenAmountOut,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 poolAmountIn) {\\n    // charge swap fee on the output token side\\n    uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n    //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\\n    uint256 zoo = bsub(BONE, normalizedWeight);\\n    uint256 zar = bmul(zoo, swapFee);\\n    uint256 tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\\n\\n    uint256 newTokenBalanceOut = bsub(\\n      tokenBalanceOut,\\n      tokenAmountOutBeforeSwapFee\\n    );\\n    uint256 tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\\n\\n    //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\\n    uint256 poolRatio = bpow(tokenOutRatio, normalizedWeight);\\n    uint256 newPoolSupply = bmul(poolRatio, poolSupply);\\n    uint256 poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\\n\\n    // charge exit fee on the pool token side\\n    // pAi = pAiAfterExitFee/(1-exitFee)\\n    poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));\\n    return poolAmountIn;\\n  }\\n}\\n\"\r\n    },\r\n    \"temp-contracts/balancer/BNum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\n\\nimport \\\"./BConst.sol\\\";\\n\\n\\n/************************************************************************************************\\nOriginally from https://github.com/balancer-labs/balancer-core/blob/master/contracts/BNum.sol\\n\\nThis source code has been modified from the original, which was copied from the github repository\\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\\n\\nSubject to the GPL-3.0 license\\n*************************************************************************************************/\\n\\n\\ncontract BNum is BConst {\\n  function btoi(uint256 a) internal pure returns (uint256) {\\n    return a / BONE;\\n  }\\n\\n  function bfloor(uint256 a) internal pure returns (uint256) {\\n    return btoi(a) * BONE;\\n  }\\n\\n  function badd(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, \\\"ERR_ADD_OVERFLOW\\\");\\n    return c;\\n  }\\n\\n  function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    (uint256 c, bool flag) = bsubSign(a, b);\\n    require(!flag, \\\"ERR_SUB_UNDERFLOW\\\");\\n    return c;\\n  }\\n\\n  function bsubSign(uint256 a, uint256 b)\\n    internal\\n    pure\\n    returns (uint256, bool)\\n  {\\n    if (a >= b) {\\n      return (a - b, false);\\n    } else {\\n      return (b - a, true);\\n    }\\n  }\\n\\n  function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c0 = a * b;\\n    require(a == 0 || c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\n    uint256 c1 = c0 + (BONE / 2);\\n    require(c1 >= c0, \\\"ERR_MUL_OVERFLOW\\\");\\n    uint256 c2 = c1 / BONE;\\n    return c2;\\n  }\\n\\n  function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, \\\"ERR_DIV_ZERO\\\");\\n    uint256 c0 = a * BONE;\\n    require(a == 0 || c0 / a == BONE, \\\"ERR_DIV_INTERNAL\\\"); // bmul overflow\\n    uint256 c1 = c0 + (b / 2);\\n    require(c1 >= c0, \\\"ERR_DIV_INTERNAL\\\"); //  badd require\\n    uint256 c2 = c1 / b;\\n    return c2;\\n  }\\n\\n  // DSMath.wpow\\n  function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\\n    uint256 z = n % 2 != 0 ? a : BONE;\\n\\n    for (n /= 2; n != 0; n /= 2) {\\n      a = bmul(a, a);\\n\\n      if (n % 2 != 0) {\\n        z = bmul(z, a);\\n      }\\n    }\\n    return z;\\n  }\\n\\n  // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n  // Use `bpowi` for `b^e` and `bpowK` for k iterations\\n  // of approximation of b^0.w\\n  function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\\n    require(base >= MIN_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_LOW\\\");\\n    require(base <= MAX_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_HIGH\\\");\\n\\n    uint256 whole = bfloor(exp);\\n    uint256 remain = bsub(exp, whole);\\n\\n    uint256 wholePow = bpowi(base, btoi(whole));\\n\\n    if (remain == 0) {\\n      return wholePow;\\n    }\\n\\n    uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\\n    return bmul(wholePow, partialResult);\\n  }\\n\\n  function bpowApprox(\\n    uint256 base,\\n    uint256 exp,\\n    uint256 precision\\n  ) internal pure returns (uint256) {\\n    // term 0:\\n    uint256 a = exp;\\n    (uint256 x, bool xneg) = bsubSign(base, BONE);\\n    uint256 term = BONE;\\n    uint256 sum = term;\\n    bool negative = false;\\n\\n    // term(k) = numer / denom\\n    //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\\n    // each iteration, multiply previous term by (a-(k-1)) * x / k\\n    // continue until term is less than precision\\n    for (uint256 i = 1; term >= precision; i++) {\\n      uint256 bigK = i * BONE;\\n      (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\\n      term = bmul(term, bmul(c, x));\\n      term = bdiv(term, bigK);\\n      if (term == 0) break;\\n\\n      if (xneg) negative = !negative;\\n      if (cneg) negative = !negative;\\n      if (negative) {\\n        sum = bsub(sum, term);\\n      } else {\\n        sum = badd(sum, term);\\n      }\\n    }\\n\\n    return sum;\\n  }\\n}\\n\"\r\n    },\r\n    \"temp-contracts/balancer/BToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\n\\nimport \\\"./BNum.sol\\\";\\n\\n\\n/************************************************************************************************\\nOriginally from https://github.com/balancer-labs/balancer-core/blob/master/contracts/BToken.sol\\n\\nThis source code has been modified from the original, which was copied from the github repository\\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\\n\\nSubject to the GPL-3.0 license\\n*************************************************************************************************/\\n\\n\\n// Highly opinionated token implementation\\ninterface IERC20 {\\n  event Approval(address indexed src, address indexed dst, uint256 amt);\\n  event Transfer(address indexed src, address indexed dst, uint256 amt);\\n\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function decimals() external view returns (uint8);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address whom) external view returns (uint256);\\n\\n  function allowance(address src, address dst) external view returns (uint256);\\n\\n  function approve(address dst, uint256 amt) external returns (bool);\\n\\n  function transfer(address dst, uint256 amt) external returns (bool);\\n\\n  function transferFrom(\\n    address src,\\n    address dst,\\n    uint256 amt\\n  ) external returns (bool);\\n}\\n\\n\\ncontract BTokenBase is BNum {\\n  mapping(address => uint256) internal _balance;\\n  mapping(address => mapping(address => uint256)) internal _allowance;\\n  uint256 internal _totalSupply;\\n\\n  event Approval(address indexed src, address indexed dst, uint256 amt);\\n  event Transfer(address indexed src, address indexed dst, uint256 amt);\\n\\n  function _mint(uint256 amt) internal {\\n    _balance[address(this)] = badd(_balance[address(this)], amt);\\n    _totalSupply = badd(_totalSupply, amt);\\n    emit Transfer(address(0), address(this), amt);\\n  }\\n\\n  function _burn(uint256 amt) internal {\\n    require(_balance[address(this)] >= amt, \\\"ERR_INSUFFICIENT_BAL\\\");\\n    _balance[address(this)] = bsub(_balance[address(this)], amt);\\n    _totalSupply = bsub(_totalSupply, amt);\\n    emit Transfer(address(this), address(0), amt);\\n  }\\n\\n  function _move(\\n    address src,\\n    address dst,\\n    uint256 amt\\n  ) internal {\\n    require(_balance[src] >= amt, \\\"ERR_INSUFFICIENT_BAL\\\");\\n    _balance[src] = bsub(_balance[src], amt);\\n    _balance[dst] = badd(_balance[dst], amt);\\n    emit Transfer(src, dst, amt);\\n  }\\n\\n  function _push(address to, uint256 amt) internal {\\n    _move(address(this), to, amt);\\n  }\\n\\n  function _pull(address from, uint256 amt) internal {\\n    _move(from, address(this), amt);\\n  }\\n}\\n\\n\\ncontract BToken is BTokenBase, IERC20 {\\n  uint8 private constant DECIMALS = 18;\\n  string private _name;\\n  string private _symbol;\\n\\n  function _initializeToken(string memory name, string memory symbol) internal {\\n    require(\\n      bytes(_name).length == 0 &&\\n      bytes(name).length != 0 &&\\n      bytes(symbol).length != 0,\\n      \\\"ERR_BTOKEN_INITIALIZED\\\"\\n    );\\n    _name = name;\\n    _symbol = symbol;\\n  }\\n\\n  function name()\\n    external\\n    override\\n    view\\n    returns (string memory)\\n  {\\n    return _name;\\n  }\\n\\n  function symbol()\\n    external\\n    override\\n    view\\n    returns (string memory)\\n  {\\n    return _symbol;\\n  }\\n\\n  function decimals()\\n    external\\n    override\\n    view\\n    returns (uint8)\\n  {\\n    return DECIMALS;\\n  }\\n\\n  function allowance(address src, address dst)\\n    external\\n    override\\n    view\\n    returns (uint256)\\n  {\\n    return _allowance[src][dst];\\n  }\\n\\n  function balanceOf(address whom) external override view returns (uint256) {\\n    return _balance[whom];\\n  }\\n\\n  function totalSupply() public override view returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  function approve(address dst, uint256 amt) external override returns (bool) {\\n    _allowance[msg.sender][dst] = amt;\\n    emit Approval(msg.sender, dst, amt);\\n    return true;\\n  }\\n\\n  function increaseApproval(address dst, uint256 amt) external returns (bool) {\\n    _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\\n    emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n    return true;\\n  }\\n\\n  function decreaseApproval(address dst, uint256 amt) external returns (bool) {\\n    uint256 oldValue = _allowance[msg.sender][dst];\\n    if (amt > oldValue) {\\n      _allowance[msg.sender][dst] = 0;\\n    } else {\\n      _allowance[msg.sender][dst] = bsub(oldValue, amt);\\n    }\\n    emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n    return true;\\n  }\\n\\n  function transfer(address dst, uint256 amt) external override returns (bool) {\\n    _move(msg.sender, dst, amt);\\n    return true;\\n  }\\n\\n  function transferFrom(\\n    address src,\\n    address dst,\\n    uint256 amt\\n  ) external override returns (bool) {\\n    require(\\n      msg.sender == src || amt <= _allowance[src][msg.sender],\\n      \\\"ERR_BTOKEN_BAD_CALLER\\\"\\n    );\\n    _move(src, dst, amt);\\n    if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\\n      _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\\n      emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\\n    }\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"temp-contracts/balancer/IndexPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\n/* ========== Internal Inheritance ========== */\\nimport \\\"./BToken.sol\\\";\\nimport \\\"./BMath.sol\\\";\\n\\n/* ========== Internal Interfaces ========== */\\nimport \\\"../interfaces/IFlashLoanRecipient.sol\\\";\\nimport \\\"../interfaces/IIndexPool.sol\\\";\\n\\n/************************************************************************************************\\nOriginally from https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol\\n\\nThis source code has been modified from the original, which was copied from the github repository\\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\\n\\nSubject to the GPL-3.0 license\\n*************************************************************************************************/\\n\\n\\ncontract IndexPool is BToken, BMath, IIndexPool {\\n\\n/* ==========  EVENTS  ========== */\\n\\n  /** @dev Emitted when tokens are swapped. */\\n  event LOG_SWAP(\\n    address indexed caller,\\n    address indexed tokenIn,\\n    address indexed tokenOut,\\n    uint256 tokenAmountIn,\\n    uint256 tokenAmountOut\\n  );\\n\\n  /** @dev Emitted when underlying tokens are deposited for pool tokens. */\\n  event LOG_JOIN(\\n    address indexed caller,\\n    address indexed tokenIn,\\n    uint256 tokenAmountIn\\n  );\\n\\n  /** @dev Emitted when pool tokens are burned for underlying. */\\n  event LOG_EXIT(\\n    address indexed caller,\\n    address indexed tokenOut,\\n    uint256 tokenAmountOut\\n  );\\n\\n  /** @dev Emitted when a token's weight updates. */\\n  event LOG_DENORM_UPDATED(address indexed token, uint256 newDenorm);\\n\\n  /** @dev Emitted when a token's desired weight is set. */\\n  event LOG_DESIRED_DENORM_SET(address indexed token, uint256 desiredDenorm);\\n\\n  /** @dev Emitted when a token is unbound from the pool. */\\n  event LOG_TOKEN_REMOVED(address token);\\n\\n  /** @dev Emitted when a token is unbound from the pool. */\\n  event LOG_TOKEN_ADDED(\\n    address indexed token,\\n    uint256 desiredDenorm,\\n    uint256 minimumBalance\\n  );\\n\\n  /** @dev Emitted when a token's minimum balance is updated. */\\n  event LOG_MINIMUM_BALANCE_UPDATED(address token, uint256 minimumBalance);\\n\\n  /** @dev Emitted when a token reaches its minimum balance. */\\n  event LOG_TOKEN_READY(address indexed token);\\n\\n  /** @dev Emitted when public trades are enabled. */\\n  event LOG_PUBLIC_SWAP_ENABLED();\\n\\n  /** @dev Emitted when the maximum tokens value is updated. */\\n  event LOG_MAX_TOKENS_UPDATED(uint256 maxPoolTokens);\\n\\n  /** @dev Emitted when the swap fee is updated. */\\n  event LOG_SWAP_FEE_UPDATED(uint256 swapFee);\\n\\n/* ==========  Modifiers  ========== */\\n\\n  modifier _lock_ {\\n    require(!_mutex, \\\"ERR_REENTRY\\\");\\n    _mutex = true;\\n    _;\\n    _mutex = false;\\n  }\\n\\n  modifier _viewlock_() {\\n    require(!_mutex, \\\"ERR_REENTRY\\\");\\n    _;\\n  }\\n\\n  modifier _control_ {\\n    require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n    _;\\n  }\\n\\n  modifier _public_ {\\n    require(_publicSwap, \\\"ERR_NOT_PUBLIC\\\");\\n    _;\\n  }\\n\\n/* ==========  Storage  ========== */\\n\\n  bool internal _mutex;\\n\\n  // Account with CONTROL role. Able to modify the swap fee,\\n  // adjust token weights, bind and unbind tokens and lock\\n  // public swaps & joins.\\n  address internal _controller;\\n\\n  // Contract that handles unbound tokens.\\n  TokenUnbindHandler internal _unbindHandler;\\n\\n  // True if PUBLIC can call SWAP & JOIN functions\\n  bool internal _publicSwap;\\n\\n  // `setSwapFee` requires CONTROL\\n  uint256 internal _swapFee;\\n\\n  // Array of underlying tokens in the pool.\\n  address[] internal _tokens;\\n\\n  // Internal records of the pool's underlying tokens\\n  mapping(address => Record) internal _records;\\n\\n  // Total denormalized weight of the pool.\\n  uint256 internal _totalWeight;\\n\\n  // Minimum balances for tokens which have been added without the\\n  // requisite initial balance.\\n  mapping(address => uint256) internal _minimumBalances;\\n\\n  // Maximum LP tokens that can be bound.\\n  // Used in alpha to restrict the economic impact of a catastrophic\\n  // failure. It can be gradually increased as the pool continues to\\n  // not be exploited.\\n  uint256 internal _maxPoolTokens;\\n\\n/* ==========  Controls  ========== */\\n\\n  /**\\n   * @dev Sets the controller address and the token name & symbol.\\n   *\\n   * Note: This saves on storage costs for multi-step pool deployment.\\n   *\\n   * @param controller Controller of the pool\\n   * @param name Name of the pool token\\n   * @param symbol Symbol of the pool token\\n   */\\n  function configure(\\n    address controller,\\n    string calldata name,\\n    string calldata symbol\\n  ) external override {\\n    require(_controller == address(0), \\\"ERR_CONFIGURED\\\");\\n    require(controller != address(0), \\\"ERR_NULL_ADDRESS\\\");\\n    _controller = controller;\\n    // default fee is 2.5%\\n    _swapFee = BONE / 40;\\n    _initializeToken(name, symbol);\\n  }\\n\\n  /**\\n   * @dev Sets up the initial assets for the pool.\\n   *\\n   * Note: `tokenProvider` must have approved the pool to transfer the\\n   * corresponding `balances` of `tokens`.\\n   *\\n   * @param tokens Underlying tokens to initialize the pool with\\n   * @param balances Initial balances to transfer\\n   * @param denorms Initial denormalized weights for the tokens\\n   * @param tokenProvider Address to transfer the balances from\\n   */\\n  function initialize(\\n    address[] calldata tokens,\\n    uint256[] calldata balances,\\n    uint96[] calldata denorms,\\n    address tokenProvider,\\n    address unbindHandler\\n  )\\n    external\\n    override\\n    _control_\\n  {\\n    require(_tokens.length == 0, \\\"ERR_INITIALIZED\\\");\\n    uint256 len = tokens.length;\\n    require(len >= MIN_BOUND_TOKENS, \\\"ERR_MIN_TOKENS\\\");\\n    require(len <= MAX_BOUND_TOKENS, \\\"ERR_MAX_TOKENS\\\");\\n    require(balances.length == len && denorms.length == len, \\\"ERR_ARR_LEN\\\");\\n    uint256 totalWeight = 0;\\n    for (uint256 i = 0; i < len; i++) {\\n      address token = tokens[i];\\n      uint96 denorm = denorms[i];\\n      uint256 balance = balances[i];\\n      require(denorm >= MIN_WEIGHT, \\\"ERR_MIN_WEIGHT\\\");\\n      require(denorm <= MAX_WEIGHT, \\\"ERR_MAX_WEIGHT\\\");\\n      require(balance >= MIN_BALANCE, \\\"ERR_MIN_BALANCE\\\");\\n      _records[token] = Record({\\n        bound: true,\\n        ready: true,\\n        lastDenormUpdate: uint40(now),\\n        denorm: denorm,\\n        desiredDenorm: denorm,\\n        index: uint8(i),\\n        balance: balance\\n      });\\n      _tokens.push(token);\\n      totalWeight = badd(totalWeight, denorm);\\n      _pullUnderlying(token, tokenProvider, balance);\\n    }\\n    require(totalWeight <= MAX_TOTAL_WEIGHT, \\\"ERR_MAX_TOTAL_WEIGHT\\\");\\n    _totalWeight = totalWeight;\\n    _publicSwap = true;\\n    emit LOG_PUBLIC_SWAP_ENABLED();\\n    _mintPoolShare(INIT_POOL_SUPPLY);\\n    _pushPoolShare(tokenProvider, INIT_POOL_SUPPLY);\\n    _unbindHandler = TokenUnbindHandler(unbindHandler);\\n  }\\n\\n  /**\\n   * @dev Sets the maximum number of pool tokens that can be minted.\\n   *\\n   * This value will be used in the alpha to limit the maximum damage\\n   * that can be caused by a catastrophic error. It can be gradually\\n   * increased as the pool continues to not be exploited.\\n   *\\n   * If it is set to 0, the limit will be removed.\\n   */\\n  function setMaxPoolTokens(uint256 maxPoolTokens) external override _control_ {\\n    _maxPoolTokens = maxPoolTokens;\\n    emit LOG_MAX_TOKENS_UPDATED(maxPoolTokens);\\n  }\\n\\n/* ==========  Configuration Actions  ========== */\\n\\n  /**\\n   * @dev Set the swap fee.\\n   * Note: Swap fee must be between 0.0001% and 10%\\n   */\\n  function setSwapFee(uint256 swapFee) external override _control_ {\\n    require(swapFee >= MIN_FEE, \\\"ERR_MIN_FEE\\\");\\n    require(swapFee <= MAX_FEE, \\\"ERR_MAX_FEE\\\");\\n    _swapFee = swapFee;\\n    emit LOG_SWAP_FEE_UPDATED(swapFee);\\n  }\\n\\n/* ==========  Token Management Actions  ========== */\\n\\n  /**\\n   * @dev Sets the desired weights for the pool tokens, which\\n   * will be adjusted over time as they are swapped.\\n   *\\n   * Note: This does not check for duplicate tokens or that the total\\n   * of the desired weights is equal to the target total weight (25).\\n   * Those assumptions should be met in the controller. Further, the\\n   * provided tokens should only include the tokens which are not set\\n   * for removal.\\n   */\\n  function reweighTokens(\\n    address[] calldata tokens,\\n    uint96[] calldata desiredDenorms\\n  )\\n    external\\n    override\\n    _lock_\\n    _control_\\n  {\\n    uint256 len = tokens.length;\\n    require(desiredDenorms.length == len, \\\"ERR_ARR_LEN\\\");\\n    for (uint256 i = 0; i < len; i++)\\n      _setDesiredDenorm(tokens[i], desiredDenorms[i]);\\n  }\\n\\n  /**\\n   * @dev Update the underlying assets held by the pool and their associated\\n   * weights. Tokens which are not currently bound will be gradually added\\n   * as they are swapped in to reach the provided minimum balances, which must\\n   * be an amount of tokens worth the minimum weight of the total pool value.\\n   * If a currently bound token is not received in this call, the token's\\n   * desired weight will be set to 0.\\n   */\\n  function reindexTokens(\\n    address[] calldata tokens,\\n    uint96[] calldata desiredDenorms,\\n    uint256[] calldata minimumBalances\\n  )\\n    external\\n    override\\n    _lock_\\n    _control_\\n  {\\n    uint256 len = tokens.length;\\n    require(\\n      desiredDenorms.length == len && minimumBalances.length == len,\\n      \\\"ERR_ARR_LEN\\\"\\n    );\\n    // This size may not be the same as the input size, as it is possible\\n    // to temporarily exceed the index size while tokens are being phased in\\n    // or out.\\n    uint256 tLen = _tokens.length;\\n    bool[] memory receivedIndices = new bool[](tLen);\\n    // We need to read token records in two separate loops, so\\n    // write them to memory to avoid duplicate storage reads.\\n    Record[] memory records = new Record[](len);\\n    // Read all the records from storage and mark which of the existing tokens\\n    // were represented in the reindex call.\\n    for (uint256 i = 0; i < len; i++) {\\n      records[i] = _records[tokens[i]];\\n      if (records[i].bound) receivedIndices[records[i].index] = true;\\n    }\\n    // If any bound tokens were not sent in this call, set their desired weights to 0.\\n    for (uint256 i = 0; i < tLen; i++) {\\n      if (!receivedIndices[i]) {\\n        _setDesiredDenorm(_tokens[i], 0);\\n      }\\n    }\\n    for (uint256 i = 0; i < len; i++) {\\n      address token = tokens[i];\\n      // If an input weight is less than the minimum weight, use that instead.\\n      uint96 denorm = desiredDenorms[i];\\n      if (denorm < MIN_WEIGHT) denorm = uint96(MIN_WEIGHT);\\n      if (!records[i].bound) {\\n        // If the token is not bound, bind it.\\n        _bind(token, minimumBalances[i], denorm);\\n      } else {\\n        _setDesiredDenorm(token, denorm);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Updates the minimum balance for an uninitialized token.\\n   * This becomes useful if a token's external price significantly\\n   * rises after being bound, since the pool can not send a token\\n   * out until it reaches the minimum balance.\\n   */\\n  function setMinimumBalance(\\n    address token,\\n    uint256 minimumBalance\\n  )\\n    external\\n    override\\n    _control_\\n  {\\n    Record storage record = _records[token];\\n    require(record.bound, \\\"ERR_NOT_BOUND\\\");\\n    require(!record.ready, \\\"ERR_READY\\\");\\n    _minimumBalances[token] = minimumBalance;\\n    emit LOG_MINIMUM_BALANCE_UPDATED(token, minimumBalance);\\n  }\\n\\n/* ==========  Liquidity Provider Actions  ========== */\\n\\n  /**\\n   * @dev Mint new pool tokens by providing the proportional amount of each\\n   * underlying token's balance relative to the proportion of pool tokens minted.\\n   *\\n   * For any underlying tokens which are not initialized, the caller must provide\\n   * the proportional share of the minimum balance for the token rather than the\\n   * actual balance.\\n   *\\n   * @param poolAmountOut Amount of pool tokens to mint\\n   * @param maxAmountsIn Maximum amount of each token to pay in the same\\n   * order as the pool's _tokens list.\\n   */\\n  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn)\\n    external\\n    override\\n    _lock_\\n    _public_\\n  {\\n    uint256 poolTotal = totalSupply();\\n    uint256 ratio = bdiv(poolAmountOut, poolTotal);\\n    require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n    require(maxAmountsIn.length == _tokens.length, \\\"ERR_ARR_LEN\\\");\\n\\n    uint256 maxPoolTokens = _maxPoolTokens;\\n    if (maxPoolTokens > 0) {\\n      require(\\n        badd(poolTotal, poolAmountOut) <= maxPoolTokens,\\n        \\\"ERR_MAX_POOL_TOKENS\\\"\\n      );\\n    }\\n\\n    for (uint256 i = 0; i < maxAmountsIn.length; i++) {\\n      address t = _tokens[i];\\n      (Record memory record, uint256 realBalance) = _getInputToken(t);\\n      uint256 tokenAmountIn = bmul(ratio, record.balance);\\n      require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n      require(tokenAmountIn <= maxAmountsIn[i], \\\"ERR_LIMIT_IN\\\");\\n      _updateInputToken(t, record, badd(realBalance, tokenAmountIn));\\n      emit LOG_JOIN(msg.sender, t, tokenAmountIn);\\n      _pullUnderlying(t, msg.sender, tokenAmountIn);\\n    }\\n    _mintPoolShare(poolAmountOut);\\n    _pushPoolShare(msg.sender, poolAmountOut);\\n  }\\n\\n  /**\\n   * @dev Pay `tokenAmountIn` of `tokenIn` to mint at least `minPoolAmountOut`\\n   * pool tokens.\\n   *\\n   * The pool implicitly swaps `(1- weightTokenIn) * tokenAmountIn` to the other\\n   * underlying tokens. Thus a swap fee is charged against the input tokens.\\n   *\\n   * @param tokenIn Token to send the pool\\n   * @param tokenAmountIn Exact amount of `tokenIn` to pay\\n   * @param minPoolAmountOut Minimum amount of pool tokens to mint\\n   * @return poolAmountOut - Amount of pool tokens minted\\n   */\\n  function joinswapExternAmountIn(\\n    address tokenIn,\\n    uint256 tokenAmountIn,\\n    uint256 minPoolAmountOut\\n  )\\n    external\\n    override\\n    _lock_\\n    _public_\\n    returns (uint256/* poolAmountOut */)\\n  {\\n    (Record memory inRecord, uint256 realInBalance) = _getInputToken(tokenIn);\\n\\n    require(tokenAmountIn != 0, \\\"ERR_ZERO_IN\\\");\\n\\n    require(\\n      tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO),\\n      \\\"ERR_MAX_IN_RATIO\\\"\\n    );\\n\\n    uint256 poolAmountOut = calcPoolOutGivenSingleIn(\\n      inRecord.balance,\\n      inRecord.denorm,\\n      _totalSupply,\\n      _totalWeight,\\n      tokenAmountIn,\\n      _swapFee\\n    );\\n\\n    uint256 maxPoolTokens = _maxPoolTokens;\\n    if (maxPoolTokens > 0) {\\n      require(\\n        badd(_totalSupply, poolAmountOut) <= maxPoolTokens,\\n        \\\"ERR_MAX_POOL_TOKENS\\\"\\n      );\\n    }\\n\\n    require(poolAmountOut >= minPoolAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n    _updateInputToken(tokenIn, inRecord, badd(realInBalance, tokenAmountIn));\\n\\n    emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\\n\\n    _mintPoolShare(poolAmountOut);\\n    _pushPoolShare(msg.sender, poolAmountOut);\\n    _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n\\n    return poolAmountOut;\\n  }\\n\\n  /**\\n   * @dev Pay up to `maxAmountIn` of `tokenIn` to mint exactly `poolAmountOut`.\\n   *\\n   * The pool implicitly swaps `(1- weightTokenIn) * tokenAmountIn` to the other\\n   * underlying tokens. Thus a swap fee is charged against the input tokens.\\n   *\\n   * @param tokenIn Token to send the pool\\n   * @param poolAmountOut Exact amount of pool tokens to mint\\n   * @param maxAmountIn Maximum amount of `tokenIn` to pay\\n   * @return tokenAmountIn - Amount of `tokenIn` paid\\n   */\\n  function joinswapPoolAmountOut(\\n    address tokenIn,\\n    uint256 poolAmountOut,\\n    uint256 maxAmountIn\\n  )\\n    external\\n    override\\n    _lock_\\n    _public_\\n    returns (uint256/* tokenAmountIn */)\\n  {\\n    uint256 maxPoolTokens = _maxPoolTokens;\\n    if (maxPoolTokens > 0) {\\n      require(\\n        badd(_totalSupply, poolAmountOut) <= maxPoolTokens,\\n        \\\"ERR_MAX_POOL_TOKENS\\\"\\n      );\\n    }\\n\\n    (Record memory inRecord, uint256 realInBalance) = _getInputToken(tokenIn);\\n\\n    uint256 tokenAmountIn = calcSingleInGivenPoolOut(\\n      inRecord.balance,\\n      inRecord.denorm,\\n      _totalSupply,\\n      _totalWeight,\\n      poolAmountOut,\\n      _swapFee\\n    );\\n\\n    require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n    require(tokenAmountIn <= maxAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n    require(\\n      tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO),\\n      \\\"ERR_MAX_IN_RATIO\\\"\\n    );\\n\\n    _updateInputToken(tokenIn, inRecord, badd(realInBalance, tokenAmountIn));\\n\\n    emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\\n\\n    _mintPoolShare(poolAmountOut);\\n    _pushPoolShare(msg.sender, poolAmountOut);\\n    _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n\\n    return tokenAmountIn;\\n  }\\n\\n  /**\\n   * @dev Burns `poolAmountIn` pool tokens in exchange for the amounts of each\\n   * underlying token's balance proportional to the ratio of tokens burned to\\n   * total pool supply. The amount of each token transferred to the caller must\\n   * be greater than or equal to the associated minimum output amount from the\\n   * `minAmountsOut` array.\\n   *\\n   * @param poolAmountIn Exact amount of pool tokens to burn\\n   * @param minAmountsOut Minimum amount of each token to receive, in the same\\n   * order as the pool's _tokens list.\\n   */\\n  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut)\\n    external\\n    override\\n    _lock_\\n  {\\n    require(minAmountsOut.length == _tokens.length, \\\"ERR_ARR_LEN\\\");\\n    uint256 poolTotal = totalSupply();\\n    uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\\n    uint256 pAiAfterExitFee = bsub(poolAmountIn, exitFee);\\n    uint256 ratio = bdiv(pAiAfterExitFee, poolTotal);\\n    require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n\\n    _pullPoolShare(msg.sender, poolAmountIn);\\n    _pushPoolShare(_controller, exitFee);\\n    _burnPoolShare(pAiAfterExitFee);\\n    for (uint256 i = 0; i < minAmountsOut.length; i++) {\\n      address t = _tokens[i];\\n      Record memory record = _records[t];\\n      if (record.ready) {\\n        uint256 tokenAmountOut = bmul(ratio, record.balance);\\n        require(tokenAmountOut != 0, \\\"ERR_MATH_APPROX\\\");\\n        require(tokenAmountOut >= minAmountsOut[i], \\\"ERR_LIMIT_OUT\\\");\\n\\n        _records[t].balance = bsub(record.balance, tokenAmountOut);\\n        emit LOG_EXIT(msg.sender, t, tokenAmountOut);\\n        _pushUnderlying(t, msg.sender, tokenAmountOut);\\n      } else {\\n        // If the token is not initialized, it can not exit the pool.\\n        require(minAmountsOut[i] == 0, \\\"ERR_OUT_NOT_READY\\\");\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Burns `poolAmountIn` pool tokens in exchange for at least `minAmountOut`\\n   * of `tokenOut`. Returns the number of tokens sent to the caller.\\n   *\\n   * The pool implicitly burns the tokens for all underlying tokens and swaps them\\n   * to the desired output token. A swap fee is charged against the output tokens.\\n   *\\n   * @param tokenOut Token to receive\\n   * @param poolAmountIn Exact amount of pool tokens to burn\\n   * @param minAmountOut Minimum amount of `tokenOut` to receive\\n   * @return tokenAmountOut - Amount of `tokenOut` received\\n   */\\n  function exitswapPoolAmountIn(\\n    address tokenOut,\\n    uint256 poolAmountIn,\\n    uint256 minAmountOut\\n  )\\n    external\\n    override\\n    _lock_\\n    returns (uint256/* tokenAmountOut */)\\n  {\\n    Record memory outRecord = _getOutputToken(tokenOut);\\n\\n    uint256 tokenAmountOut = calcSingleOutGivenPoolIn(\\n      outRecord.balance,\\n      outRecord.denorm,\\n      _totalSupply,\\n      _totalWeight,\\n      poolAmountIn,\\n      _swapFee\\n    );\\n\\n    require(tokenAmountOut >= minAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n    require(\\n      tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO),\\n      \\\"ERR_MAX_OUT_RATIO\\\"\\n    );\\n\\n    _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n    _records[tokenOut].balance = bsub(outRecord.balance, tokenAmountOut);\\n    _decreaseDenorm(outRecord, tokenOut);\\n    uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\\n\\n    emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\\n\\n    _pullPoolShare(msg.sender, poolAmountIn);\\n    _burnPoolShare(bsub(poolAmountIn, exitFee));\\n    _pushPoolShare(_controller, exitFee);\\n\\n    return tokenAmountOut;\\n  }\\n\\n  /**\\n   * @dev Burn up to `maxPoolAmountIn` for exactly `tokenAmountOut` of `tokenOut`.\\n   * Returns the number of pool tokens burned.\\n   *\\n   * The pool implicitly burns the tokens for all underlying tokens and swaps them\\n   * to the desired output token. A swap fee is charged against the output tokens.\\n   *\\n   * @param tokenOut Token to receive\\n   * @param tokenAmountOut Exact amount of `tokenOut` to receive\\n   * @param maxPoolAmountIn Maximum amount of pool tokens to burn\\n   * @return poolAmountIn - Amount of pool tokens burned\\n   */\\n  function exitswapExternAmountOut(\\n    address tokenOut,\\n    uint256 tokenAmountOut,\\n    uint256 maxPoolAmountIn\\n  )\\n    external\\n    override\\n    _lock_\\n    returns (uint256/* poolAmountIn */)\\n  {\\n    Record memory outRecord = _getOutputToken(tokenOut);\\n    require(\\n      tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO),\\n      \\\"ERR_MAX_OUT_RATIO\\\"\\n    );\\n\\n    uint256 poolAmountIn = calcPoolInGivenSingleOut(\\n      outRecord.balance,\\n      outRecord.denorm,\\n      _totalSupply,\\n      _totalWeight,\\n      tokenAmountOut,\\n      _swapFee\\n    );\\n\\n    require(poolAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n    require(poolAmountIn <= maxPoolAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n    _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n    _records[tokenOut].balance = bsub(outRecord.balance, tokenAmountOut);\\n    _decreaseDenorm(outRecord, tokenOut);\\n\\n    uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\\n\\n    emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\\n\\n    _pullPoolShare(msg.sender, poolAmountIn);\\n    _burnPoolShare(bsub(poolAmountIn, exitFee));\\n    _pushPoolShare(_controller, exitFee);\\n\\n    return poolAmountIn;\\n  }\\n\\n/* ==========  Other  ========== */\\n\\n  /**\\n   * @dev Absorb any tokens that have been sent to the pool.\\n   * If the token is not bound, it will be sent to the unbound\\n   * token handler.\\n   */\\n  function gulp(address token) external override _lock_ {\\n    Record storage record = _records[token];\\n    uint256 balance = IERC20(token).balanceOf(address(this));\\n    if (record.bound) {\\n      if (!record.ready) {\\n        uint256 minimumBalance = _minimumBalances[token];\\n        if (balance >= minimumBalance) {\\n          _minimumBalances[token] = 0;\\n          record.ready = true;\\n          emit LOG_TOKEN_READY(token);\\n          uint256 additionalBalance = bsub(balance, minimumBalance);\\n          uint256 balRatio = bdiv(additionalBalance, minimumBalance);\\n          uint96 newDenorm = uint96(badd(MIN_WEIGHT, bmul(MIN_WEIGHT, balRatio)));\\n          record.denorm = newDenorm;\\n          record.lastDenormUpdate = uint40(now);\\n          _totalWeight = badd(_totalWeight, newDenorm);\\n          emit LOG_DENORM_UPDATED(token, record.denorm);\\n        }\\n      }\\n      _records[token].balance = balance;\\n    } else {\\n      _pushUnderlying(token, address(_unbindHandler), balance);\\n      _unbindHandler.handleUnbindToken(token, balance);\\n    }\\n  }\\n\\n/* ==========  Flash Loan  ========== */\\n\\n  /**\\n   * @dev Execute a flash loan, transferring `amount` of `token` to `recipient`.\\n   * `amount` must be repaid with `swapFee` interest by the end of the transaction.\\n   *\\n   * @param recipient Must implement the IFlashLoanRecipient interface\\n   * @param token Token to borrow\\n   * @param amount Amount to borrow\\n   * @param data Data to send to the recipient in `receiveFlashLoan` call\\n   */\\n  function flashBorrow(\\n    address recipient,\\n    address token,\\n    uint256 amount,\\n    bytes calldata data\\n  )\\n    external\\n    override\\n    _lock_\\n  {\\n    Record storage record = _records[token];\\n    require(record.bound, \\\"ERR_NOT_BOUND\\\");\\n    uint256 balStart = IERC20(token).balanceOf(address(this));\\n    require(balStart >= amount, \\\"ERR_INSUFFICIENT_BAL\\\");\\n    _pushUnderlying(token, address(recipient), amount);\\n    uint256 fee = bmul(balStart, _swapFee);\\n    uint256 amountDue = badd(amount, fee);\\n    IFlashLoanRecipient(recipient).receiveFlashLoan(token, amount, amountDue, data);\\n    uint256 balEnd = IERC20(token).balanceOf(address(this));\\n    require(\\n      balEnd > balStart && balEnd >= amountDue,\\n      \\\"ERR_INSUFFICIENT_PAYMENT\\\"\\n    );\\n    record.balance = balEnd;\\n    // If the payment brings the token above its minimum balance,\\n    // clear the minimum and mark the token as ready.\\n    if (!record.ready) {\\n      uint256 minimumBalance = _minimumBalances[token];\\n      if (balEnd >= minimumBalance) {\\n        _minimumBalances[token] = 0;\\n        record.ready = true;\\n        emit LOG_TOKEN_READY(token);\\n        uint256 additionalBalance = bsub(balEnd, minimumBalance);\\n        uint256 balRatio = bdiv(additionalBalance, minimumBalance);\\n        uint96 newDenorm = uint96(badd(MIN_WEIGHT, bmul(MIN_WEIGHT, balRatio)));\\n        record.denorm = newDenorm;\\n        record.lastDenormUpdate = uint40(now);\\n        _totalWeight = badd(_totalWeight, newDenorm);\\n        emit LOG_DENORM_UPDATED(token, record.denorm);\\n      }\\n    }\\n  }\\n\\n/* ==========  Token Swaps  ========== */\\n\\n  /**\\n   * @dev Execute a token swap with a specified amount of input\\n   * tokens and a minimum amount of output tokens.\\n   *\\n   * Note: Will revert if `tokenOut` is uninitialized.\\n   *\\n   * @param tokenIn Token to swap in\\n   * @param tokenAmountIn Exact amount of `tokenIn` to swap in\\n   * @param tokenOut Token to swap out\\n   * @param minAmountOut Minimum amount of `tokenOut` to receive\\n   * @param maxPrice Maximum ratio of input to output tokens\\n   * @return (tokenAmountOut, spotPriceAfter)\\n   */\\n  function swapExactAmountIn(\\n    address tokenIn,\\n    uint256 tokenAmountIn,\\n    address tokenOut,\\n    uint256 minAmountOut,\\n    uint256 maxPrice\\n  )\\n    external\\n    override\\n    _lock_\\n    _public_\\n    returns (uint256/* tokenAmountOut */, uint256/* spotPriceAfter */)\\n  {\\n    (Record memory inRecord, uint256 realInBalance) = _getInputToken(tokenIn);\\n    Record memory outRecord = _getOutputToken(tokenOut);\\n\\n    require(\\n      tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO),\\n      \\\"ERR_MAX_IN_RATIO\\\"\\n    );\\n\\n    uint256 spotPriceBefore = calcSpotPrice(\\n      inRecord.balance,\\n      inRecord.denorm,\\n      outRecord.balance,\\n      outRecord.denorm,\\n      _swapFee\\n    );\\n    require(spotPriceBefore <= maxPrice, \\\"ERR_BAD_LIMIT_PRICE\\\");\\n\\n    uint256 tokenAmountOut = calcOutGivenIn(\\n      inRecord.balance,\\n      inRecord.denorm,\\n      outRecord.balance,\\n      outRecord.denorm,\\n      tokenAmountIn,\\n      _swapFee\\n    );\\n\\n    require(tokenAmountOut >= minAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n    _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n    _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n    realInBalance = badd(realInBalance, tokenAmountIn);\\n    _updateInputToken(tokenIn, inRecord, realInBalance);\\n    if (inRecord.ready) {\\n      inRecord.balance = realInBalance;\\n    }\\n    // Update the in-memory record for the spotPriceAfter calculation,\\n    // then update the storage record with the local balance.\\n    outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n    _records[tokenOut].balance = outRecord.balance;\\n    // If needed, update the output token's weight.\\n    _decreaseDenorm(outRecord, tokenOut);\\n\\n    uint256 spotPriceAfter = calcSpotPrice(\\n      inRecord.balance,\\n      inRecord.denorm,\\n      outRecord.balance,\\n      outRecord.denorm,\\n      _swapFee\\n    );\\n\\n    require(spotPriceAfter >= spotPriceBefore, \\\"ERR_MATH_APPROX_2\\\");\\n    require(spotPriceAfter <= maxPrice, \\\"ERR_LIMIT_PRICE\\\");\\n    require(\\n      spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut),\\n      \\\"ERR_MATH_APPROX\\\"\\n    );\\n\\n    emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\\n\\n    return (tokenAmountOut, spotPriceAfter);\\n  }\\n\\n  /**\\n   * @dev Trades at most `maxAmountIn` of `tokenIn` for exactly `tokenAmountOut`\\n   * of `tokenOut`.\\n   *\\n   * Returns the actual input amount and the new spot price after the swap,\\n   * which can not exceed `maxPrice`.\\n   *\\n   * @param tokenIn Token to swap in\\n   * @param maxAmountIn Maximum amount of `tokenIn` to pay\\n   * @param tokenOut Token to swap out\\n   * @param tokenAmountOut Exact amount of `tokenOut` to receive\\n   * @param maxPrice Maximum ratio of input to output tokens\\n   * @return (tokenAmountIn, spotPriceAfter)\\n   */\\n  function swapExactAmountOut(\\n    address tokenIn,\\n    uint256 maxAmountIn,\\n    address tokenOut,\\n    uint256 tokenAmountOut,\\n    uint256 maxPrice\\n  )\\n    external\\n    override\\n    _lock_\\n    _public_\\n    returns (uint256 /* tokenAmountIn */, uint256 /* spotPriceAfter */)\\n  {\\n    (Record memory inRecord, uint256 realInBalance) = _getInputToken(tokenIn);\\n    Record memory outRecord = _getOutputToken(tokenOut);\\n\\n    require(\\n      tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO),\\n      \\\"ERR_MAX_OUT_RATIO\\\"\\n    );\\n\\n    uint256 spotPriceBefore = calcSpotPrice(\\n      inRecord.balance,\\n      inRecord.denorm,\\n      outRecord.balance,\\n      outRecord.denorm,\\n      _swapFee\\n    );\\n    require(spotPriceBefore <= maxPrice, \\\"ERR_BAD_LIMIT_PRICE\\\");\\n\\n    uint256 tokenAmountIn = calcInGivenOut(\\n      inRecord.balance,\\n      inRecord.denorm,\\n      outRecord.balance,\\n      outRecord.denorm,\\n      tokenAmountOut,\\n      _swapFee\\n    );\\n\\n    require(tokenAmountIn <= maxAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n    _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n    _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n    // Update the balance and (if necessary) weight of the input token.\\n    realInBalance = badd(realInBalance, tokenAmountIn);\\n    _updateInputToken(tokenIn, inRecord, realInBalance);\\n    if (inRecord.ready) {\\n      inRecord.balance = realInBalance;\\n    }\\n    // Update the in-memory record for the spotPriceAfter calculation,\\n    // then update the storage record with the local balance.\\n    outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n    _records[tokenOut].balance = outRecord.balance;\\n    // If needed, update the output token's weight.\\n    _decreaseDenorm(outRecord, tokenOut);\\n\\n    uint256 spotPriceAfter = calcSpotPrice(\\n      inRecord.balance,\\n      inRecord.denorm,\\n      outRecord.balance,\\n      outRecord.denorm,\\n      _swapFee\\n    );\\n\\n    require(spotPriceAfter >= spotPriceBefore, \\\"ERR_MATH_APPROX\\\");\\n    require(spotPriceAfter <= maxPrice, \\\"ERR_LIMIT_PRICE\\\");\\n    require(\\n      spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut),\\n      \\\"ERR_MATH_APPROX\\\"\\n    );\\n\\n    emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\\n\\n    return (tokenAmountIn, spotPriceAfter);\\n  }\\n\\n/* ==========  Config Queries  ========== */\\n  /**\\n   * @dev Check if swapping tokens and joining the pool is allowed.\\n   */\\n  function isPublicSwap() external view override returns (bool) {\\n    return _publicSwap;\\n  }\\n\\n  function getSwapFee() external view override _viewlock_ returns (uint256/* swapFee */) {\\n    return _swapFee;\\n  }\\n\\n  /**\\n   * @dev Returns the controller address.\\n   */\\n  function getController() external view override returns (address)\\n  {\\n    return _controller;\\n  }\\n\\n/* ==========  Token Queries  ========== */\\n  function getMaxPoolTokens() external view override returns (uint256) {\\n    return _maxPoolTokens;\\n  }\\n\\n  /**\\n   * @dev Check if a token is bound to the pool.\\n   */\\n  function isBound(address t) external view override returns (bool) {\\n    return _records[t].bound;\\n  }\\n\\n  /**\\n   * @dev Get the number of tokens bound to the pool.\\n   */\\n  function getNumTokens() external view override returns (uint256) {\\n    return _tokens.length;\\n  }\\n\\n  /**\\n   * @dev Get all bound tokens.\\n   */\\n  function getCurrentTokens()\\n    external\\n    view\\n    override\\n    _viewlock_\\n    returns (address[] memory tokens)\\n  {\\n    tokens = _tokens;\\n  }\\n\\n  /**\\n   * @dev Returns the list of tokens which have a desired weight above 0.\\n   * Tokens with a desired weight of 0 are set to be phased out of the pool.\\n   */\\n  function getCurrentDesiredTokens()\\n    external\\n    view\\n    override\\n    _viewlock_\\n    returns (address[] memory tokens)\\n  {\\n    address[] memory tempTokens = _tokens;\\n    tokens = new address[](tempTokens.length);\\n    uint256 usedIndex = 0;\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      address token = tempTokens[i];\\n      if (_records[token].desiredDenorm > 0) {\\n        tokens[usedIndex++] = token;\\n      }\\n    }\\n    assembly { mstore(tokens, usedIndex) }\\n  }\\n\\n  /**\\n   * @dev Returns the denormalized weight of a bound token.\\n   */\\n  function getDenormalizedWeight(address token)\\n    external\\n    view\\n    override\\n    _viewlock_\\n    returns (uint256/* denorm */)\\n  {\\n    require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n    return _records[token].denorm;\\n  }\\n\\n  /**\\n   * @dev Returns the record for a token bound to the pool.\\n   */\\n  function getTokenRecord(address token)\\n    external\\n    view\\n    override\\n    _viewlock_\\n    returns (Record memory record)\\n  {\\n    record = _records[token];\\n    require(record.bound, \\\"ERR_NOT_BOUND\\\");\\n  }\\n\\n  /**\\n   * @dev Finds the first token which is both initialized and has a\\n   * desired weight above 0, then returns the address of that token\\n   * and the extrapolated value of the pool in terms of that token.\\n   *\\n   * The value is extrapolated by multiplying the token's\\n   * balance by the reciprocal of its normalized weight.\\n   * @return (token, extrapolatedValue)\\n   */\\n  function extrapolatePoolValueFromToken()\\n    external\\n    view\\n    override\\n    _viewlock_\\n    returns (address/* token */, uint256/* extrapolatedValue */)\\n  {\\n    address token;\\n    uint256 extrapolatedValue;\\n    uint256 len = _tokens.length;\\n    for (uint256 i = 0; i < len; i++) {\\n      token = _tokens[i];\\n      Record storage record = _records[token];\\n      if (record.ready && record.desiredDenorm > 0) {\\n        extrapolatedValue = bmul(\\n          record.balance,\\n          bdiv(_totalWeight, record.denorm)\\n        );\\n        break;\\n      }\\n    }\\n    require(extrapolatedValue > 0, \\\"ERR_NONE_READY\\\");\\n    return (token, extrapolatedValue);\\n  }\\n\\n  /**\\n   * @dev Get the total denormalized weight of the pool.\\n   */\\n  function getTotalDenormalizedWeight()\\n    external\\n    view\\n    override\\n    _viewlock_\\n    returns (uint256)\\n  {\\n    return _totalWeight;\\n  }\\n\\n  /**\\n   * @dev Returns the stored balance of a bound token.\\n   */\\n  function getBalance(address token) external view override _viewlock_ returns (uint256) {\\n    Record storage record = _records[token];\\n    require(record.bound, \\\"ERR_NOT_BOUND\\\");\\n    return record.balance;\\n  }\\n\\n  /**\\n   * @dev Get the minimum balance of an uninitialized token.\\n   * Note: Throws if the token is initialized.\\n   */\\n  function getMinimumBalance(address token) external view override _viewlock_ returns (uint256) {\\n    Record memory record = _records[token];\\n    require(record.bound, \\\"ERR_NOT_BOUND\\\");\\n    require(!record.ready, \\\"ERR_READY\\\");\\n    return _minimumBalances[token];\\n  }\\n\\n  /**\\n   * @dev Returns the balance of a token which is used in price\\n   * calculations. If the token is initialized, this is the\\n   * stored balance; if not, this is the minimum balance.\\n   */\\n  function getUsedBalance(address token) external view override _viewlock_ returns (uint256) {\\n    Record memory record = _records[token];\\n    require(record.bound, \\\"ERR_NOT_BOUND\\\");\\n    if (!record.ready) {\\n      return _minimumBalances[token];\\n    }\\n    return record.balance;\\n  }\\n\\n/* ==========  Price Queries  ========== */\\n  /**\\n   * @dev Returns the spot price for `tokenOut` in terms of `tokenIn`.\\n   */\\n  function getSpotPrice(address tokenIn, address tokenOut)\\n    external\\n    view\\n    override\\n    _viewlock_\\n    returns (uint256)\\n  {\\n    (Record memory inRecord,) = _getInputToken(tokenIn);\\n    Record memory outRecord = _getOutputToken(tokenOut);\\n    return\\n      calcSpotPrice(\\n        inRecord.balance,\\n        inRecord.denorm,\\n        outRecord.balance,\\n        outRecord.denorm,\\n        _swapFee\\n      );\\n  }\\n\\n/* ==========  Pool Share Internal Functions  ========== */\\n\\n  function _pullPoolShare(address from, uint256 amount) internal {\\n    _pull(from, amount);\\n  }\\n\\n  function _pushPoolShare(address to, uint256 amount) internal {\\n    _push(to, amount);\\n  }\\n\\n  function _mintPoolShare(uint256 amount) internal {\\n    _mint(amount);\\n  }\\n\\n  function _burnPoolShare(uint256 amount) internal {\\n    _burn(amount);\\n  }\\n\\n/* ==========  Underlying Token Internal Functions  ========== */\\n  // 'Underlying' token-manipulation functions make external calls but are NOT locked\\n  // You must `_lock_` or otherwise ensure reentry-safety\\n\\n  function _pullUnderlying(\\n    address erc20,\\n    address from,\\n    uint256 amount\\n  ) internal {\\n    (bool success, bytes memory data) = erc20.call(\\n      abi.encodeWithSelector(\\n        IERC20.transferFrom.selector,\\n        from,\\n        address(this),\\n        amount\\n      )\\n    );\\n    require(\\n      success && (data.length == 0 || abi.decode(data, (bool))),\\n      \\\"ERR_ERC20_FALSE\\\"\\n    );\\n  }\\n\\n  function _pushUnderlying(\\n    address erc20,\\n    address to,\\n    uint256 amount\\n  ) internal {\\n    (bool success, bytes memory data) = erc20.call(\\n      abi.encodeWithSelector(\\n        IERC20.transfer.selector,\\n        to,\\n        amount\\n      )\\n    );\\n    require(\\n      success && (data.length == 0 || abi.decode(data, (bool))),\\n      \\\"ERR_ERC20_FALSE\\\"\\n    );\\n  }\\n\\n/* ==========  Token Management Internal Functions  ========== */\\n\\n  /**\\n   * @dev Bind a token by address without actually depositing a balance.\\n   * The token will be unable to be swapped out until it reaches the minimum balance.\\n   * Note: Token must not already be bound.\\n   * Note: `minimumBalance` should represent an amount of the token which is worth\\n   * the portion of the current pool value represented by the minimum weight.\\n   * @param token Address of the token to bind\\n   * @param minimumBalance minimum balance to reach before the token can be swapped out\\n   * @param desiredDenorm Desired weight for the token.\\n   */\\n  function _bind(\\n    address token,\\n    uint256 minimumBalance,\\n    uint96 desiredDenorm\\n  ) internal {\\n    require(!_records[token].bound, \\\"ERR_IS_BOUND\\\");\\n\\n    require(desiredDenorm >= MIN_WEIGHT, \\\"ERR_MIN_WEIGHT\\\");\\n    require(desiredDenorm <= MAX_WEIGHT, \\\"ERR_MAX_WEIGHT\\\");\\n    require(minimumBalance >= MIN_BALANCE, \\\"ERR_MIN_BALANCE\\\");\\n\\n    _records[token] = Record({\\n      bound: true,\\n      ready: false,\\n      lastDenormUpdate: 0,\\n      denorm: 0,\\n      desiredDenorm: desiredDenorm,\\n      index: uint8(_tokens.length),\\n      balance: 0\\n    });\\n    _tokens.push(token);\\n    _minimumBalances[token] = minimumBalance;\\n    emit LOG_TOKEN_ADDED(token, desiredDenorm, minimumBalance);\\n  }\\n\\n  /**\\n   * @dev Remove a token from the pool.\\n   * Replaces the address in the tokens array with the last address,\\n   * then removes it from the array.\\n   * Note: This should only be called after the total weight has been adjusted.\\n   * Note: Must be called in a function with:\\n   * - _lock_ modifier to prevent reentrance\\n   * - requirement that the token is bound\\n   */\\n  function _unbind(address token) internal {\\n    Record memory record = _records[token];\\n    uint256 tokenBalance = record.balance;\\n\\n    // Swap the token-to-unbind with the last token,\\n    // then delete the last token\\n    uint256 index = record.index;\\n    uint256 last = _tokens.length - 1;\\n    // Only swap the token with the last token if it is not\\n    // already at the end of the array.\\n    if (index != last) {\\n      _tokens[index] = _tokens[last];\\n      _records[_tokens[index]].index = uint8(index);\\n    }\\n    _tokens.pop();\\n    _records[token] = Record({\\n      bound: false,\\n      ready: false,\\n      lastDenormUpdate: 0,\\n      denorm: 0,\\n      desiredDenorm: 0,\\n      index: 0,\\n      balance: 0\\n    });\\n    // transfer any remaining tokens out\\n    _pushUnderlying(token, address(_unbindHandler), tokenBalance);\\n    _unbindHandler.handleUnbindToken(token, tokenBalance);\\n    emit LOG_TOKEN_REMOVED(token);\\n  }\\n\\n  function _setDesiredDenorm(address token, uint96 desiredDenorm) internal {\\n    Record storage record = _records[token];\\n    require(record.bound, \\\"ERR_NOT_BOUND\\\");\\n    // If the desired weight is 0, this will trigger a gradual unbinding of the token.\\n    // Therefore the weight only needs to be above the minimum weight if it isn't 0.\\n    require(\\n      desiredDenorm >= MIN_WEIGHT || desiredDenorm == 0,\\n      \\\"ERR_MIN_WEIGHT\\\"\\n    );\\n    require(desiredDenorm <= MAX_WEIGHT, \\\"ERR_MAX_WEIGHT\\\");\\n    record.desiredDenorm = desiredDenorm;\\n    emit LOG_DESIRED_DENORM_SET(token, desiredDenorm);\\n  }\\n\\n  function _increaseDenorm(Record memory record, address token) internal {\\n    // If the weight does not need to increase or the token is not\\n    // initialized, don't do anything.\\n    if (\\n      record.denorm >= record.desiredDenorm ||\\n      !record.ready ||\\n      now - record.lastDenormUpdate < WEIGHT_UPDATE_DELAY\\n    ) return;\\n    uint96 oldWeight = record.denorm;\\n    uint96 denorm = record.desiredDenorm;\\n    uint256 maxDiff = bmul(oldWeight, WEIGHT_CHANGE_PCT);\\n    uint256 diff = bsub(denorm, oldWeight);\\n    if (diff > maxDiff) {\\n      denorm = uint96(badd(oldWeight, maxDiff));\\n      diff = maxDiff;\\n    }\\n    _totalWeight = badd(_totalWeight, diff);\\n    require(_totalWeight <= MAX_TOTAL_WEIGHT, \\\"ERR_MAX_TOTAL_WEIGHT\\\");\\n    // Update the in-memory denorm value for spot-price computations.\\n    record.denorm = denorm;\\n    // Update the storage record\\n    _records[token].denorm = denorm;\\n    _records[token].lastDenormUpdate = uint40(now);\\n    emit LOG_DENORM_UPDATED(token, denorm);\\n  }\\n\\n  function _decreaseDenorm(Record memory record, address token) internal {\\n    // If the weight does not need to decrease, don't do anything.\\n    if (\\n      record.denorm <= record.desiredDenorm ||\\n      !record.ready ||\\n      now - record.lastDenormUpdate < WEIGHT_UPDATE_DELAY\\n    ) return;\\n    uint96 oldWeight = record.denorm;\\n    uint96 denorm = record.desiredDenorm;\\n    uint256 maxDiff = bmul(oldWeight, WEIGHT_CHANGE_PCT);\\n    uint256 diff = bsub(oldWeight, denorm);\\n    if (diff > maxDiff) {\\n      denorm = uint96(bsub(oldWeight, maxDiff));\\n      diff = maxDiff;\\n    }\\n    if (denorm <= MIN_WEIGHT) {\\n      denorm = 0;\\n      _totalWeight = bsub(_totalWeight, denorm);\\n      // Because this is removing the token from the pool, the\\n      // in-memory denorm value is irrelevant, as it is only used\\n      // to calculate the new spot price, but the spot price calc\\n      // will throw if it is passed 0 for the denorm.\\n      _unbind(token);\\n    } else {\\n      _totalWeight = bsub(_totalWeight, diff);\\n      // Update the in-memory denorm value for spot-price computations.\\n      record.denorm = denorm;\\n      // Update the stored denorm value\\n      _records[token].denorm = denorm;\\n      _records[token].lastDenormUpdate = uint40(now);\\n      emit LOG_DENORM_UPDATED(token, denorm);\\n    }\\n  }\\n\\n  /**\\n   * @dev Handles weight changes and initialization of an\\n   * input token.\\n   *\\n   * If the token is not initialized and the new balance is\\n   * still below the minimum, this will not do anything.\\n   *\\n   * If the token is not initialized but the new balance will\\n   * bring the token above the minimum balance, this will\\n   * mark the token as initialized, remove the minimum\\n   * balance and set the weight to the minimum weight plus\\n   * 1%.\\n   *\\n   *\\n   * @param token Address of the input token\\n   * @param record Token record with minimums applied to the balance\\n   * and weight if the token was uninitialized.\\n   */\\n  function _updateInputToken(\\n    address token,\\n    Record memory record,\\n    uint256 realBalance\\n  )\\n    internal\\n  {\\n    if (!record.ready) {\\n      // Check if the minimum balance has been reached\\n      if (realBalance >= record.balance) {\\n        // Remove the minimum balance record\\n        _minimumBalances[token] = 0;\\n        // Mark the token as initialized\\n        _records[token].ready = true;\\n        record.ready = true;\\n        emit LOG_TOKEN_READY(token);\\n        // Set the initial denorm value to the minimum weight times one plus\\n        // the ratio of the increase in balance over the minimum to the minimum\\n        // balance.\\n        // weight = (1 + ((bal - min_bal) / min_bal)) * min_weight\\n        uint256 additionalBalance = bsub(realBalance, record.balance);\\n        uint256 balRatio = bdiv(additionalBalance, record.balance);\\n        record.denorm = uint96(badd(MIN_WEIGHT, bmul(MIN_WEIGHT, balRatio)));\\n        _records[token].denorm = record.denorm;\\n        _records[token].lastDenormUpdate = uint40(now);\\n        _totalWeight = badd(_totalWeight, record.denorm);\\n        emit LOG_DENORM_UPDATED(token, record.denorm);\\n      } else {\\n        uint256 realToMinRatio = bdiv(\\n          bsub(record.balance, realBalance),\\n          record.balance\\n        );\\n        uint256 weightPremium = bmul(MIN_WEIGHT / 10, realToMinRatio);\\n        record.denorm = uint96(badd(MIN_WEIGHT, weightPremium));\\n      }\\n      // If the token is still not ready, do not adjust the weight.\\n    } else {\\n      // If the token is already initialized, update the weight (if any adjustment\\n      // is needed).\\n      _increaseDenorm(record, token);\\n    }\\n    // Regardless of whether the token is initialized, store the actual new balance.\\n    _records[token].balance = realBalance;\\n  }\\n\\n/* ==========  Token Query Internal Functions  ========== */\\n\\n  /**\\n   * @dev Get the record for a token which is being swapped in.\\n   * The token must be bound to the pool. If the token is not\\n   * initialized (meaning it does not have the minimum balance)\\n   * this function will return the actual balance of the token\\n   * which the pool holds, but set the record's balance and weight\\n   * to the token's minimum balance and the pool's minimum weight.\\n   * This allows the token swap to be priced correctly even if the\\n   * pool does not own any of the tokens.\\n   */\\n  function _getInputToken(address token)\\n    internal\\n    view\\n    returns (Record memory record, uint256 realBalance)\\n  {\\n    record = _records[token];\\n    require(record.bound, \\\"ERR_NOT_BOUND\\\");\\n\\n    realBalance = record.balance;\\n    // If the input token is not initialized, we use the minimum\\n    // initial weight and minimum initial balance instead of the\\n    // real values for price and output calculations.\\n    if (!record.ready) {\\n      record.balance = _minimumBalances[token];\\n      uint256 realToMinRatio = bdiv(\\n        bsub(record.balance, realBalance),\\n        record.balance\\n      );\\n      uint256 weightPremium = bmul(MIN_WEIGHT / 10, realToMinRatio);\\n      record.denorm = uint96(badd(MIN_WEIGHT, weightPremium));\\n    }\\n  }\\n\\n  function _getOutputToken(address token)\\n    internal\\n    view\\n    returns (Record memory record)\\n  {\\n    record = _records[token];\\n    require(record.bound, \\\"ERR_NOT_BOUND\\\");\\n    // Tokens which have not reached their minimum balance can not be\\n    // swapped out.\\n    require(record.ready, \\\"ERR_OUT_NOT_READY\\\");\\n  }\\n}\\n\\n\\ninterface TokenUnbindHandler {\\n  /**\\n   * @dev Receive `amount` of `token` from the pool.\\n   */\\n  function handleUnbindToken(address token, uint256 amount) external;\\n}\"\r\n    },\r\n    \"temp-contracts/interfaces/IFlashLoanRecipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\n\\ninterface IFlashLoanRecipient {\\n  function receiveFlashLoan(\\n    address tokenBorrowed,\\n    uint256 amountBorrowed,\\n    uint256 amountDue,\\n    bytes calldata data\\n  ) external;\\n}\"\r\n    },\r\n    \"temp-contracts/interfaces/IIndexPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\n\\ninterface IIndexPool {\\n  /**\\n   * @dev Token record data structure\\n   * @param bound is token bound to pool\\n   * @param ready has token been initialized\\n   * @param lastDenormUpdate timestamp of last denorm change\\n   * @param denorm denormalized weight\\n   * @param desiredDenorm desired denormalized weight (used for incremental changes)\\n   * @param index index of address in tokens array\\n   * @param balance token balance\\n   */\\n  struct Record {\\n    bool bound;\\n    bool ready;\\n    uint40 lastDenormUpdate;\\n    uint96 denorm;\\n    uint96 desiredDenorm;\\n    uint8 index;\\n    uint256 balance;\\n  }\\n\\n  event LOG_SWAP(\\n    address indexed caller,\\n    address indexed tokenIn,\\n    address indexed tokenOut,\\n    uint256 tokenAmountIn,\\n    uint256 tokenAmountOut\\n  );\\n\\n  event LOG_JOIN(\\n    address indexed caller,\\n    address indexed tokenIn,\\n    uint256 tokenAmountIn\\n  );\\n\\n  event LOG_EXIT(\\n    address indexed caller,\\n    address indexed tokenOut,\\n    uint256 tokenAmountOut\\n  );\\n\\n  event LOG_DENORM_UPDATED(address indexed token, uint256 newDenorm);\\n\\n  event LOG_DESIRED_DENORM_SET(address indexed token, uint256 desiredDenorm);\\n\\n  event LOG_TOKEN_REMOVED(address token);\\n\\n  event LOG_TOKEN_ADDED(\\n    address indexed token,\\n    uint256 desiredDenorm,\\n    uint256 minimumBalance\\n  );\\n\\n  event LOG_MINIMUM_BALANCE_UPDATED(address token, uint256 minimumBalance);\\n\\n  event LOG_TOKEN_READY(address indexed token);\\n\\n  event LOG_PUBLIC_SWAP_ENABLED();\\n\\n  event LOG_MAX_TOKENS_UPDATED(uint256 maxPoolTokens);\\n\\n  event LOG_SWAP_FEE_UPDATED(uint256 swapFee);\\n\\n  function configure(\\n    address controller,\\n    string calldata name,\\n    string calldata symbol\\n  ) external;\\n\\n  function initialize(\\n    address[] calldata tokens,\\n    uint256[] calldata balances,\\n    uint96[] calldata denorms,\\n    address tokenProvider,\\n    address unbindHandler\\n  ) external;\\n\\n  function setMaxPoolTokens(uint256 maxPoolTokens) external;\\n\\n  function setSwapFee(uint256 swapFee) external;\\n\\n  function reweighTokens(\\n    address[] calldata tokens,\\n    uint96[] calldata desiredDenorms\\n  ) external;\\n\\n  function reindexTokens(\\n    address[] calldata tokens,\\n    uint96[] calldata desiredDenorms,\\n    uint256[] calldata minimumBalances\\n  ) external;\\n\\n  function setMinimumBalance(address token, uint256 minimumBalance) external;\\n\\n  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\\n\\n  function joinswapExternAmountIn(\\n    address tokenIn,\\n    uint256 tokenAmountIn,\\n    uint256 minPoolAmountOut\\n  ) external returns (uint256/* poolAmountOut */);\\n\\n  function joinswapPoolAmountOut(\\n    address tokenIn,\\n    uint256 poolAmountOut,\\n    uint256 maxAmountIn\\n  ) external returns (uint256/* tokenAmountIn */);\\n\\n  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\\n\\n  function exitswapPoolAmountIn(\\n    address tokenOut,\\n    uint256 poolAmountIn,\\n    uint256 minAmountOut\\n  )\\n    external returns (uint256/* tokenAmountOut */);\\n\\n  function exitswapExternAmountOut(\\n    address tokenOut,\\n    uint256 tokenAmountOut,\\n    uint256 maxPoolAmountIn\\n  ) external returns (uint256/* poolAmountIn */);\\n\\n  function gulp(address token) external;\\n\\n  function flashBorrow(\\n    address recipient,\\n    address token,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external;\\n\\n  function swapExactAmountIn(\\n    address tokenIn,\\n    uint256 tokenAmountIn,\\n    address tokenOut,\\n    uint256 minAmountOut,\\n    uint256 maxPrice\\n  ) external returns (uint256/* tokenAmountOut */, uint256/* spotPriceAfter */);\\n\\n  function swapExactAmountOut(\\n    address tokenIn,\\n    uint256 maxAmountIn,\\n    address tokenOut,\\n    uint256 tokenAmountOut,\\n    uint256 maxPrice\\n  ) external returns (uint256 /* tokenAmountIn */, uint256 /* spotPriceAfter */);\\n\\n  function isPublicSwap() external view returns (bool);\\n\\n  function getSwapFee() external view returns (uint256/* swapFee */);\\n\\n  function getController() external view returns (address);\\n\\n  function getMaxPoolTokens() external view returns (uint256);\\n\\n  function isBound(address t) external view returns (bool);\\n\\n  function getNumTokens() external view returns (uint256);\\n\\n  function getCurrentTokens() external view returns (address[] memory tokens);\\n\\n  function getCurrentDesiredTokens() external view returns (address[] memory tokens);\\n\\n  function getDenormalizedWeight(address token) external view returns (uint256/* denorm */);\\n\\n  function getTokenRecord(address token) external view returns (Record memory record);\\n\\n  function extrapolatePoolValueFromToken() external view returns (address/* token */, uint256/* extrapolatedValue */);\\n\\n  function getTotalDenormalizedWeight() external view returns (uint256);\\n\\n  function getBalance(address token) external view returns (uint256);\\n\\n  function getMinimumBalance(address token) external view returns (uint256);\\n\\n  function getUsedBalance(address token) external view returns (uint256);\\n\\n  function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDenorm\",\"type\":\"uint256\"}],\"name\":\"LOG_DENORM_UPDATED\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"desiredDenorm\",\"type\":\"uint256\"}],\"name\":\"LOG_DESIRED_DENORM_SET\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_EXIT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"name\":\"LOG_JOIN\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxPoolTokens\",\"type\":\"uint256\"}],\"name\":\"LOG_MAX_TOKENS_UPDATED\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumBalance\",\"type\":\"uint256\"}],\"name\":\"LOG_MINIMUM_BALANCE_UPDATED\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LOG_PUBLIC_SWAP_ENABLED\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_SWAP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"LOG_SWAP_FEE_UPDATED\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"desiredDenorm\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumBalance\",\"type\":\"uint256\"}],\"name\":\"LOG_TOKEN_ADDED\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"LOG_TOKEN_READY\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"LOG_TOKEN_REMOVED\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"VERSION_NUMBER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"whom\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"configure\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[]\"}],\"name\":\"exitPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPoolAmountIn\",\"type\":\"uint256\"}],\"name\":\"exitswapExternAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"}],\"name\":\"exitswapPoolAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extrapolatePoolValueFromToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"flashBorrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentDesiredTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getDenormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxPoolTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getMinimumBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSwapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenRecord\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"bound\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"ready\",\"type\":\"bool\"},{\"internalType\":\"uint40\",\"name\":\"lastDenormUpdate\",\"type\":\"uint40\"},{\"internalType\":\"uint96\",\"name\":\"denorm\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"desiredDenorm\",\"type\":\"uint96\"},{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IIndexPool.Record\",\"name\":\"record\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDenormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getUsedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"gulp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint96[]\",\"name\":\"denorms\",\"type\":\"uint96[]\"},{\"internalType\":\"address\",\"name\":\"tokenProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"unbindHandler\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"isBound\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPublicSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[]\"}],\"name\":\"joinPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPoolAmountOut\",\"type\":\"uint256\"}],\"name\":\"joinswapExternAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountIn\",\"type\":\"uint256\"}],\"name\":\"joinswapPoolAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint96[]\",\"name\":\"desiredDenorms\",\"type\":\"uint96[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minimumBalances\",\"type\":\"uint256[]\"}],\"name\":\"reindexTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint96[]\",\"name\":\"desiredDenorms\",\"type\":\"uint96[]\"}],\"name\":\"reweighTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxPoolTokens\",\"type\":\"uint256\"}],\"name\":\"setMaxPoolTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumBalance\",\"type\":\"uint256\"}],\"name\":\"setMinimumBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"setSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "IndexPool", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}