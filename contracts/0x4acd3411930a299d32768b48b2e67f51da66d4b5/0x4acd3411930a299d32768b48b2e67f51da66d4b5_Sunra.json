{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/AccLandData.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.23;\\r\\n\\r\\nstruct AccLandData {\\r\\n    uint256 landId; // id of the land or 0\\r\\n    uint256 tokenStaked; // count of staked tokens of account\\r\\n    uint256 takePeriod; // last used take period\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/ISunra.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.23;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface ISunra {\\r\\n    function token1() external view returns (IERC20);\\r\\n\\r\\n    function token2() external view returns (IERC20);\\r\\n\\r\\n    function createNewLands() external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Land.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.23;\\r\\n\\r\\nstruct Land {\\r\\n    // constant for land\\r\\n    uint256 id; // id of land or 0 if it not exists\\r\\n    uint256 creationTime; // when was created\\r\\n    uint256 periodSeconds; // period time season\\r\\n    uint256 takeGoldSeconds; // time seconds to extract gold on new take period\\r\\n    // erase\\r\\n    uint256 eraseTime; // time when will be eraseed or 0\\r\\n    // total savings\\r\\n    uint256 eth; // eth to take\\r\\n    uint256 token1; // token1 to take\\r\\n    uint256 token2; // token2 to take\\r\\n    // accounts data\\r\\n    uint256 accountsCount; // accounts count on land\\r\\n    uint256 tokenStaked; // total staked tokens\\r\\n    // snapshot\\r\\n    uint256 takePeriodSnapshot; // number of snapshot period to take\\r\\n    uint256 tokenStakedSnapshot; // tokens staked for takes on take period\\r\\n    uint256 ethSnapshot;\\r\\n    uint256 tokenSnapshot;\\r\\n    uint256 token2Snapshot;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/LandPrediction.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.23;\\r\\n\\r\\nimport \\\"./Land.sol\\\";\\r\\n\\r\\nstruct Period {\\r\\n    uint256 number; // period number\\r\\n    uint256 eth; // ether on period for rewards\\r\\n    uint256 token; // token on period (not includes stakes) for rewards\\r\\n    uint256 token2; // token2 on period for rewards\\r\\n    uint256 tokenStaked; // token stacks sum on period\\r\\n    bool isTakeTime; // is now take time or not\\r\\n    bool isDirty; // is period dirty\\r\\n    uint256 time; // time since the beginning of the period\\r\\n    uint256 remainingTime; // remaining time until next period\\r\\n    uint256 endTime; // when period expires\\r\\n}\\r\\n\\r\\nstruct LandData {\\r\\n    Land land; // land data\\r\\n    Period period; // land period data\\r\\n    uint8 number; // land number\\r\\n    bool isExists; // is land exists\\r\\n}\\r\\n\\r\\nlibrary LandPrediction {\\r\\n    // time from period start\\r\\n    function periodTime(Land memory land) internal view returns (uint256) {\\r\\n        return (block.timestamp - land.creationTime) % land.periodSeconds;\\r\\n    }\\r\\n\\r\\n    function nextPeriodRemainingTime(\\r\\n        Land memory land\\r\\n    ) internal view returns (uint256) {\\r\\n        return land.periodSeconds - periodTime(land);\\r\\n    }\\r\\n\\r\\n    function nextPeriodTime(\\r\\n        Land memory land\\r\\n    ) internal view returns (uint256) {\\r\\n        return block.timestamp + nextPeriodRemainingTime(land);\\r\\n    }\\r\\n\\r\\n    function periodNumber(\\r\\n        Land memory land\\r\\n    ) internal view returns (uint256) {\\r\\n        return (block.timestamp - land.creationTime) / land.periodSeconds;\\r\\n    }\\r\\n\\r\\n    function isTakePeriodDirty(\\r\\n        Land memory land\\r\\n    ) internal view returns (bool) {\\r\\n        return land.takePeriodSnapshot != periodNumber(land);\\r\\n    }\\r\\n\\r\\n    function isTakeTime(Land memory land) internal view returns (bool) {\\r\\n        return periodTime(land) < land.takeGoldSeconds;\\r\\n    }\\r\\n\\r\\n    function ethOnLand(Land memory land) internal view returns (uint256) {\\r\\n        if (!isExists(land)) return 0;\\r\\n        return land.eth;\\r\\n    }\\r\\n\\r\\n    function token2OnLand(\\r\\n        Land memory land\\r\\n    ) internal view returns (uint256) {\\r\\n        if (!isExists(land)) return 0;\\r\\n        return land.token2;\\r\\n    }\\r\\n\\r\\n    function ethOnPeriod(Land memory land) internal view returns (uint256) {\\r\\n        if (!isExists(land)) return 0;\\r\\n        if (isTakePeriodDirty(land)) return land.eth;\\r\\n        else return land.ethSnapshot;\\r\\n    }\\r\\n\\r\\n    function tokenOnPeriod(\\r\\n        Land memory land\\r\\n    ) internal view returns (uint256) {\\r\\n        if (!isExists(land)) return 0;\\r\\n        if (isTakePeriodDirty(land)) return land.token1;\\r\\n        else return land.tokenSnapshot;\\r\\n    }\\r\\n\\r\\n    function token2OnPeriod(\\r\\n        Land memory land\\r\\n    ) internal view returns (uint256) {\\r\\n        if (!isExists(land)) return 0;\\r\\n        if (isTakePeriodDirty(land)) return land.token2;\\r\\n        else return land.token2Snapshot;\\r\\n    }\\r\\n\\r\\n    function tokenStakedOnPeriod(\\r\\n        Land memory land\\r\\n    ) internal view returns (uint256) {\\r\\n        if (isTakePeriodDirty(land)) return land.tokenStaked;\\r\\n        else return land.tokenStakedSnapshot;\\r\\n    }\\r\\n\\r\\n    function ethRewardForTokens(\\r\\n        Land memory land,\\r\\n        uint256 tokenstaked\\r\\n    ) internal view returns (uint256) {\\r\\n        if (tokenstaked == 0 || !isExists(land)) return 0;\\r\\n        if (land.tokenStaked == 0) return land.eth;\\r\\n        return (land.eth * tokenstaked) / land.tokenStaked;\\r\\n    }\\r\\n\\r\\n    function tokenRewardForTokens(\\r\\n        Land memory land,\\r\\n        uint256 tokenstaked\\r\\n    ) internal view returns (uint256) {\\r\\n        if (tokenstaked == 0 || !isExists(land)) return 0;\\r\\n        if (land.tokenStaked == 0) return land.token1;\\r\\n        return (land.token1 * tokenstaked) / land.tokenStaked;\\r\\n    }\\r\\n\\r\\n    function token2RewardForTokens(\\r\\n        Land memory land,\\r\\n        uint256 tokenstaked\\r\\n    ) internal view returns (uint256) {\\r\\n        if (tokenstaked == 0 || !isExists(land)) return 0;\\r\\n        if (land.tokenStaked == 0) return land.token2;\\r\\n        return (land.token2 * tokenstaked) / land.tokenStaked;\\r\\n    }\\r\\n\\r\\n    function ethRewardPeriod(\\r\\n        Land memory land,\\r\\n        uint256 tokenstaked\\r\\n    ) internal view returns (uint256) {\\r\\n        if (tokenstaked == 0 || !isExists(land)) return 0;\\r\\n        uint256 stacke = tokenStakedOnPeriod(land);\\r\\n        if (stacke == 0) return ethOnPeriod(land);\\r\\n        return (ethOnPeriod(land) * tokenstaked) / stacke;\\r\\n    }\\r\\n\\r\\n    function tokenRewardPeriod(\\r\\n        Land memory land,\\r\\n        uint256 tokenstaked\\r\\n    ) internal view returns (uint256) {\\r\\n        if (tokenstaked == 0 || !isExists(land)) return 0;\\r\\n        uint256 stacke = tokenStakedOnPeriod(land);\\r\\n        if (stacke == 0) return tokenOnPeriod(land);\\r\\n        return (tokenOnPeriod(land) * tokenstaked) / stacke;\\r\\n    }\\r\\n\\r\\n    function token2RewardPeriod(\\r\\n        Land memory land,\\r\\n        uint256 tokenstaked\\r\\n    ) internal view returns (uint256) {\\r\\n        if (tokenstaked == 0 || !isExists(land)) return 0;\\r\\n        uint256 stacke = tokenStakedOnPeriod(land);\\r\\n        if (stacke == 0) return token2OnPeriod(land);\\r\\n        return (token2OnPeriod(land) * tokenstaked) / stacke;\\r\\n    }\\r\\n\\r\\n    function isExists(Land memory land) internal view returns (bool) {\\r\\n        return\\r\\n            land.id > 0 &&\\r\\n            (land.eraseTime == 0 || (block.timestamp < land.eraseTime));\\r\\n    }\\r\\n\\r\\n    function getData(\\r\\n        Land memory land,\\r\\n        uint8 number\\r\\n    ) internal view returns (LandData memory) {\\r\\n        return\\r\\n            LandData(\\r\\n                land,\\r\\n                Period(\\r\\n                    periodNumber(land),\\r\\n                    ethOnPeriod(land),\\r\\n                    tokenOnPeriod(land),\\r\\n                    token2OnPeriod(land),\\r\\n                    tokenStakedOnPeriod(land),\\r\\n                    isTakeTime(land),\\r\\n                    isTakePeriodDirty(land),\\r\\n                    periodTime(land),\\r\\n                    nextPeriodRemainingTime(land),\\r\\n                    nextPeriodTime(land)\\r\\n                ),\\r\\n                number,\\r\\n                isExists(land)\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function changeEraseSeconds(Land storage land, uint256 timer) internal {\\r\\n        land.eraseTime = block.timestamp + timer;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Sunra.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.23;\\r\\n\\r\\nimport \\\"./ISunra.sol\\\";\\r\\nimport \\\"./Land.sol\\\";\\r\\nimport \\\"./AccLandData.sol\\\";\\r\\nimport \\\"./LandPrediction.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ncontract Ownable {\\r\\n    address public owner;\\r\\n\\r\\n    event OwnershipRenounced();\\r\\n\\r\\n    constructor() {\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(owner == msg.sender, \\\"not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() external onlyOwner {\\r\\n        owner = address(0);\\r\\n        emit OwnershipRenounced();\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) external onlyOwner {\\r\\n        require(owner != address(0));\\r\\n        owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract EthReceivable {\\r\\n    string constant ERR_SEND_ETHER_FEE = \\\"#1\\\"; // sent fee error: master ether is not sent\\r\\n\\r\\n    address public immutable master; // eth master\\r\\n    uint256 _ethMasterFeePercent = 41; // master fee percent\\r\\n\\r\\n    constructor(address master_) {\\r\\n        master = master_;\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n        uint256 masterFee = (msg.value * _ethMasterFeePercent) / 100;\\r\\n        (bool sentFee, ) = payable(master).call{value: masterFee}(\\\"\\\");\\r\\n        require(sentFee, ERR_SEND_ETHER_FEE);\\r\\n    }\\r\\n\\r\\n    function ethMasterFeePercent() external view returns (uint256) {\\r\\n        return _ethMasterFeePercent;\\r\\n    }\\r\\n\\r\\n    function _changeEthMasterFeePercent(uint256 percent) internal {\\r\\n        require(percent <= 51);\\r\\n        _ethMasterFeePercent = percent;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Initializeable {\\r\\n    string constant ERR_ALREADY_LAUNCHED = \\\"#2\\\"; // already initializeed\\r\\n    bool public isInitialized;\\r\\n\\r\\n    function _initialize() internal {\\r\\n        require(!isInitialized, ERR_ALREADY_LAUNCHED); // already initializeed\\r\\n        isInitialized = true;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract HasRandom {\\r\\n    uint256 internal _nonce = 1;\\r\\n\\r\\n    function _rand() internal virtual returns (uint256) {\\r\\n        //return _nonce++ * block.timestamp * block.number;\\r\\n        return _nonce++ * block.number;\\r\\n    }\\r\\n\\r\\n    function _rand(uint256 min, uint256 max) internal returns (uint256) {\\r\\n        return min + (_rand() % (max - min + 1));\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Sunra is ISunra, Ownable, EthReceivable, Initializeable, HasRandom {\\r\\n    string constant ERR_NOT_CORRECT = \\\"#3\\\"; // not correct\\r\\n    string constant ERR_NOT_LAUNCHED = \\\"#4\\\"; // not initializeed\\r\\n    string constant ERR_WORLD_NOT_EXISTS = \\\"#5\\\"; // land is not exists\\r\\n    string constant ERR_SLOT_NOT_FOUND = \\\"#6\\\"; // slot for land is not found\\r\\n    string constant ERR_CAN_NOT_COLLECT_REWARDS = \\\"#7\\\"; // can not take rewards yet\\r\\n    string constant ERR_NO_WORLD_WITH_ID = \\\"#8\\\"; // has no land with certain id\\r\\n    string constant ERR_ETHER_NOT_SEND = \\\"#9\\\"; // sent fee error: ether is not sent\\r\\n    string constant ERR_INCORRECT_WORLD_NUMBER = \\\"#10\\\"; // incorrect land number\\r\\n    using LandPrediction for Land;\\r\\n\\r\\n    IERC20 _token;\\r\\n    IERC20 _token2;\\r\\n    uint256 public landslCreatedTotal; // total created lands count\\r\\n\\r\\n    uint8 constant _initializeLandsCount = 2;\\r\\n    uint8 public constant maxLandsCount = 4; // maximum lands count\\r\\n    uint256 public constant newLandTimeMin = 1 minutes;\\r\\n    uint256 public constant newLandTimeMax = 1 hours;\\r\\n\\r\\n    uint256 public landPeriodWaitSecondsMin = 61 seconds; // land period wait time season min\\r\\n    uint256 public landPeriodWaitSecondsMax = 36001 seconds; // land period wait time season max\\r\\n    uint256 public landRewardPercentMin = 51; // 100%=1000\\r\\n    uint256 public landRewardPercentMax = 501; // 100%=1000\\r\\n    uint256 public landEraseTimeMin = 61 seconds;\\r\\n    uint256 public landEraseTimeMax = 601 seconds;\\r\\n    uint256 public landEraseStartChance = 31; // noe of this is initializes erase on take\\r\\n    uint256 public landTakeGoldSecondsMin = 61 seconds; // land take time season min\\r\\n    uint256 public landTakeGoldSecondsMax = 3601 seconds; // land take time season max\\r\\n\\r\\n    Land[maxLandsCount] _lands; // accounts land data\\r\\n    mapping(address => AccLandData[maxLandsCount]) accs;\\r\\n    address _deployer;\\r\\n    uint256 _newLandTime;\\r\\n\\r\\n    constructor(address master_) EthReceivable(master_) {\\r\\n        _deployer = msg.sender;\\r\\n    }\\r\\n\\r\\n    function initialize() external onlyOwner {\\r\\n        _initialize();\\r\\n        for (uint8 i = 1; i <= _initializeLandsCount; ++i) _createLand(i);\\r\\n    }\\r\\n\\r\\n    function token1() external view returns (IERC20) {\\r\\n        return _token;\\r\\n    }\\r\\n\\r\\n    function token2() external view returns (IERC20) {\\r\\n        return _token2;\\r\\n    }\\r\\n\\r\\n    function changeEthMasterFeePercent(uint256 percent) external onlyOwner {\\r\\n        _changeEthMasterFeePercent(percent);\\r\\n    }\\r\\n\\r\\n    function changePeriodWaitSeconds(\\r\\n        uint256 landPeriodWaitSecondsMin_,\\r\\n        uint256 landPeriodWaitSecondsMax_\\r\\n    ) external onlyOwner {\\r\\n        require(\\r\\n            landPeriodWaitSecondsMin_ > 0 &&\\r\\n                landPeriodWaitSecondsMin_ <= landPeriodWaitSecondsMax_,\\r\\n            ERR_NOT_CORRECT\\r\\n        );\\r\\n        landPeriodWaitSecondsMin = landPeriodWaitSecondsMin_;\\r\\n        landPeriodWaitSecondsMax = landPeriodWaitSecondsMax_;\\r\\n    }\\r\\n\\r\\n    function changeTakeGoldSeconds(\\r\\n        uint256 landTakeGoldSecondsMin_,\\r\\n        uint256 landTakeGoldSecondsMax_\\r\\n    ) external onlyOwner {\\r\\n        require(\\r\\n            landTakeGoldSecondsMin_ > 0 &&\\r\\n                landTakeGoldSecondsMin_ <= landTakeGoldSecondsMax_,\\r\\n            ERR_NOT_CORRECT\\r\\n        );\\r\\n        landTakeGoldSecondsMin = landTakeGoldSecondsMin_;\\r\\n        landTakeGoldSecondsMax = landTakeGoldSecondsMax_;\\r\\n    }\\r\\n\\r\\n    function changePrizePercent(uint256 min, uint256 max) external onlyOwner {\\r\\n        require(min <= max, ERR_NOT_CORRECT);\\r\\n        require(max <= 1000, ERR_NOT_CORRECT);\\r\\n        landRewardPercentMin = min;\\r\\n        landRewardPercentMax = max;\\r\\n    }\\r\\n\\r\\n    function changeLandEraseStartChance(uint256 chance) external onlyOwner {\\r\\n        require(chance > 1);\\r\\n        landEraseStartChance = chance;\\r\\n    }\\r\\n\\r\\n    function changeErc20(address token_, address token2_) external {\\r\\n        require(msg.sender == _deployer);\\r\\n        delete _deployer;\\r\\n        _token = IERC20(token_);\\r\\n        _token2 = IERC20(token2_);\\r\\n    }\\r\\n\\r\\n    function goToLand(uint256 landId, uint256 tokensCount) external {\\r\\n        // limitations\\r\\n        require(isInitialized, ERR_NOT_LAUNCHED);\\r\\n        // get land\\r\\n        (Land storage land, uint8 number) = _getLandByIdInternal(landId);\\r\\n        require(land.isExists(), ERR_WORLD_NOT_EXISTS);\\r\\n        // refresh land\\r\\n        //_refreshBeforeUseLand(land, number);\\r\\n        _eraseLand(land, number);\\r\\n        _refreshLand(land, number);\\r\\n        require(land.isExists(), ERR_WORLD_NOT_EXISTS);\\r\\n\\r\\n        // thansfer stak tokens\\r\\n        uint256 lastTokens = _token.balanceOf(address(this));\\r\\n        _token.transferFrom(msg.sender, address(this), tokensCount);\\r\\n        uint256 staked = _token.balanceOf(address(this)) - lastTokens;\\r\\n\\r\\n        // write data\\r\\n        AccLandData storage acc = accs[msg.sender][number - 1];\\r\\n        if (acc.landId != land.id) ++land.accountsCount;\\r\\n        acc.landId = land.id;\\r\\n        acc.takePeriod = land.periodNumber();\\r\\n        acc.tokenStaked += staked;\\r\\n        land.tokenStaked += staked;\\r\\n    }\\r\\n\\r\\n    function leaveLand(uint256 landId) external {\\r\\n        (Land storage land, uint8 number) = _getLandByIdInternal(landId);\\r\\n        _refreshBeforeUseLand(land, number);\\r\\n        AccLandData storage acc = accs[msg.sender][number - 1];\\r\\n        require(acc.landId > 0, ERR_SLOT_NOT_FOUND);\\r\\n        //if (_canTakeRewards(acc, land))\\r\\n        //    _takeGold(msg.sender, acc, land);\\r\\n        _token.transfer(msg.sender, acc.tokenStaked);\\r\\n        --land.accountsCount;\\r\\n        land.tokenStaked -= acc.tokenStaked;\\r\\n        delete accs[msg.sender][number - 1];\\r\\n    }\\r\\n\\r\\n    function _refreshBeforeUseLand(Land storage land, uint8 number) private {\\r\\n        require(land.isExists(), ERR_WORLD_NOT_EXISTS);\\r\\n        _refreshLandsErases();\\r\\n        _refreshLand(land, number);\\r\\n        _createNewLands();\\r\\n        require(land.isExists(), ERR_WORLD_NOT_EXISTS);\\r\\n    }\\r\\n\\r\\n    function getAccSlots(\\r\\n        address addr\\r\\n    ) external view returns (AccLandData[] memory) {\\r\\n        AccLandData[] memory res = new AccLandData[](maxLandsCount);\\r\\n        for (uint8 i = 0; i < maxLandsCount; ++i) {\\r\\n            AccLandData storage data = accs[addr][i];\\r\\n            Land memory land = _lands[i];\\r\\n            if (!land.isExists()) continue;\\r\\n            res[i] = data;\\r\\n        }\\r\\n\\r\\n        return res;\\r\\n    }\\r\\n\\r\\n    function getAccSlotForLand(\\r\\n        address acc,\\r\\n        uint256 landId\\r\\n    ) public view returns (AccLandData memory) {\\r\\n        return _getAccSlotForLand(acc, landId);\\r\\n    }\\r\\n\\r\\n    function _getAccSlotForLand(\\r\\n        address acc,\\r\\n        uint256 landId\\r\\n    ) private view returns (AccLandData storage) {\\r\\n        require(landId > 0, ERR_WORLD_NOT_EXISTS);\\r\\n        for (uint8 i = 0; i < maxLandsCount; ++i) {\\r\\n            AccLandData storage data = accs[acc][i];\\r\\n            if (data.landId == landId) {\\r\\n                require(isLandExists(data.landId), ERR_SLOT_NOT_FOUND);\\r\\n                return data;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        revert(ERR_SLOT_NOT_FOUND);\\r\\n    }\\r\\n\\r\\n    function _trySetEraseTime(Land storage land) private {\\r\\n        if (!land.isExists() || land.eraseTime != 0) return;\\r\\n        if (_rand(1, landEraseStartChance) % landEraseStartChance != 1) return;\\r\\n\\r\\n        land.changeEraseSeconds(_rand(landEraseTimeMin, landEraseTimeMax));\\r\\n    }\\r\\n\\r\\n    function isLandTakeSeason(uint8 landNumber) public view returns (bool) {\\r\\n        return _isLandTakeSeason(_getLandByNumber(landNumber));\\r\\n    }\\r\\n\\r\\n    function _isLandTakeSeason(Land memory land) private view returns (bool) {\\r\\n        return land.id > 0 && land.isTakeTime();\\r\\n    }\\r\\n\\r\\n    /*function takeGoldAllLands() external {\\r\\n        uint8 takeCount;\\r\\n        for (uint8 i = 0; i < maxLandsCount; ++i) {\\r\\n            AccLandData storage data = accs[msg.sender][i];\\r\\n            Land storage land = _lands[i];\\r\\n            if (!land.isExists()) continue;\\r\\n            _refreshLand(land, i + 1);\\r\\n            if (!_canTakeRewards(data, land)) continue;\\r\\n            _takeGold(msg.sender, data, land);\\r\\n            ++takeCount;\\r\\n        }\\r\\n        _createNewLands();\\r\\n        require(takeCount > 0, ERR_CAN_NOT_COLLECT_REWARDS);\\r\\n    }*/\\r\\n\\r\\n    function takeGold(uint256 landId) external {\\r\\n        (Land storage land, uint8 number) = _getLandByIdInternal(landId);\\r\\n        _refreshBeforeUseLand(land, number);\\r\\n        AccLandData storage data = accs[msg.sender][number - 1];\\r\\n        require(_canTakeRewards(data, land), ERR_CAN_NOT_COLLECT_REWARDS);\\r\\n        _takeGold(msg.sender, data, land);\\r\\n    }\\r\\n\\r\\n    function _canTakeRewards(\\r\\n        AccLandData memory acc,\\r\\n        Land memory land\\r\\n    ) private view returns (bool) {\\r\\n        return\\r\\n            land.isExists() &&\\r\\n            land.isTakeTime() &&\\r\\n            acc.takePeriod + 1 < land.periodNumber();\\r\\n    }\\r\\n\\r\\n    function _takeGold(\\r\\n        address addr,\\r\\n        AccLandData storage acc,\\r\\n        Land storage land\\r\\n    )\\r\\n        private\\r\\n        returns (\\r\\n            uint256 ethRewarded,\\r\\n            uint256 tokenRewarded,\\r\\n            uint256 token2Rewarded\\r\\n        )\\r\\n    {\\r\\n        _tryNextTakePeriodSnapshot(land);\\r\\n\\r\\n        ethRewarded = land.ethRewardPeriod(acc.tokenStaked);\\r\\n        tokenRewarded = land.tokenRewardPeriod(acc.tokenStaked);\\r\\n        token2Rewarded = land.token2RewardPeriod(acc.tokenStaked);\\r\\n\\r\\n        acc.takePeriod = land.periodNumber() - 1;\\r\\n\\r\\n        if (ethRewarded > 0) {\\r\\n            (bool sentFee, ) = payable(addr).call{value: ethRewarded}(\\\"\\\");\\r\\n            require(sentFee, ERR_ETHER_NOT_SEND);\\r\\n            land.eth -= ethRewarded;\\r\\n        }\\r\\n        if (tokenRewarded > 0) {\\r\\n            _token.transfer(addr, tokenRewarded);\\r\\n            land.token1 -= tokenRewarded;\\r\\n        }\\r\\n        if (token2Rewarded > 0) {\\r\\n            _token2.transfer(addr, token2Rewarded);\\r\\n            land.token2 -= token2Rewarded;\\r\\n        }\\r\\n\\r\\n        _trySetEraseTime(land);\\r\\n    }\\r\\n\\r\\n    function _tryNextTakePeriodSnapshot(Land storage land) private {\\r\\n        if (\\r\\n            !land.isExists() || land.eraseTime != 0 || !land.isTakePeriodDirty()\\r\\n        ) return;\\r\\n        _addRewardsToLand(land);\\r\\n        land.tokenStakedSnapshot = land.tokenStaked;\\r\\n        land.takePeriodSnapshot = land.periodNumber();\\r\\n        land.ethSnapshot = land.eth;\\r\\n        land.tokenSnapshot = land.token1;\\r\\n        land.token2Snapshot = land.token2;\\r\\n    }\\r\\n\\r\\n    function getRewardForTokens(\\r\\n        uint256 landId,\\r\\n        uint256 tokensCount\\r\\n    ) external view returns (uint256 eth, uint256 token1, uint256 token2) {\\r\\n        (Land storage land, ) = _getLandByIdInternal(landId);\\r\\n        eth = land.ethRewardForTokens(tokensCount);\\r\\n        token1 = land.tokenRewardForTokens(tokensCount);\\r\\n        token2 = land.token2RewardForTokens(tokensCount);\\r\\n    }\\r\\n\\r\\n    function getRewardForAccount(\\r\\n        uint256 landId,\\r\\n        address account\\r\\n    ) external view returns (uint256 eth, uint256 token1, uint256 token2) {\\r\\n        (Land storage land, uint8 number) = _getLandByIdInternal(landId);\\r\\n        AccLandData memory acc = accs[account][number - 1];\\r\\n        if (acc.takePeriod == land.periodNumber()) {\\r\\n            return (0, 0, 0);\\r\\n        }\\r\\n        eth = land.ethRewardPeriod(acc.tokenStaked);\\r\\n        token1 = land.tokenRewardPeriod(acc.tokenStaked);\\r\\n        token2 = land.token2RewardPeriod(acc.tokenStaked);\\r\\n    }\\r\\n\\r\\n    function _getLandNumber(\\r\\n        AccLandData memory acc\\r\\n    ) private view returns (uint8) {\\r\\n        if (acc.landId == 0) return 0;\\r\\n        for (uint8 i = 0; i < maxLandsCount; ++i) {\\r\\n            if (_lands[i].id == acc.landId) return i + 1;\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function getLandByNumber(uint8 number) external view returns (Land memory) {\\r\\n        return _getLandByNumber(number);\\r\\n    }\\r\\n\\r\\n    function _getLandByNumber(\\r\\n        uint8 number\\r\\n    ) private view returns (Land storage) {\\r\\n        require(\\r\\n            number >= 1 && number <= maxLandsCount,\\r\\n            ERR_INCORRECT_WORLD_NUMBER\\r\\n        );\\r\\n        return _lands[number - 1];\\r\\n    }\\r\\n\\r\\n    function getLandNumberById(uint256 id) public view returns (uint8) {\\r\\n        if (id == 0) return 0;\\r\\n        for (uint8 i = 0; i < maxLandsCount; ++i) {\\r\\n            if (_lands[i].id == id) return i + 1;\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function isLandExists(uint256 id) public view returns (bool) {\\r\\n        return _getLandById(id).isExists();\\r\\n    }\\r\\n\\r\\n    function getLandById(uint256 id) external view returns (Land memory) {\\r\\n        return _getLandById(id);\\r\\n    }\\r\\n\\r\\n    function _getLandByIdInternal(\\r\\n        uint256 id\\r\\n    ) private view returns (Land storage land, uint8 number) {\\r\\n        number = getLandNumberById(id);\\r\\n        require(number > 0, ERR_NO_WORLD_WITH_ID);\\r\\n        land = _lands[number - 1];\\r\\n    }\\r\\n\\r\\n    function _getLandById(\\r\\n        uint256 id\\r\\n    ) internal view returns (Land storage land) {\\r\\n        (land, ) = _getLandByIdInternal(id);\\r\\n    }\\r\\n\\r\\n    function getLandTakePeriod(uint256 landId) external view returns (uint256) {\\r\\n        return _getLandById(landId).periodNumber();\\r\\n    }\\r\\n\\r\\n    function tokenStacked() public view returns (uint256) {\\r\\n        uint256 res;\\r\\n        for (uint8 i = 0; i < maxLandsCount; ++i) {\\r\\n            if (!_lands[i].isExists()) continue;\\r\\n            res += _lands[i].tokenStaked;\\r\\n        }\\r\\n        return res;\\r\\n    }\\r\\n\\r\\n    function token2Total() public view returns (uint256) {\\r\\n        return _token2.balanceOf(address(this));\\r\\n    }\\r\\n\\r\\n    function ethOnLands() public view returns (uint256) {\\r\\n        uint256 res;\\r\\n        for (uint8 i = 0; i < maxLandsCount; ++i) {\\r\\n            res += _lands[i].ethOnLand();\\r\\n        }\\r\\n        return res;\\r\\n    }\\r\\n\\r\\n    function tokenOnLands() public view returns (uint256) {\\r\\n        uint256 res;\\r\\n        for (uint8 i = 0; i < maxLandsCount; ++i) {\\r\\n            res += _lands[i].tokenOnPeriod();\\r\\n        }\\r\\n        return res;\\r\\n    }\\r\\n\\r\\n    function tokenOnLandsRewardWithStacks() public view returns (uint256) {\\r\\n        uint256 res;\\r\\n        for (uint8 i = 0; i < maxLandsCount; ++i) {\\r\\n            res += _lands[i].token1 + _lands[i].tokenStaked;\\r\\n        }\\r\\n        return res;\\r\\n    }\\r\\n\\r\\n    function token2OnLands() public view returns (uint256) {\\r\\n        uint256 res;\\r\\n        for (uint8 i = 0; i < maxLandsCount; ++i) {\\r\\n            res += _lands[i].token2OnLand();\\r\\n        }\\r\\n        return res;\\r\\n    }\\r\\n\\r\\n    function accountsOnLands() public view returns (uint256) {\\r\\n        uint256 res;\\r\\n        for (uint8 i = 0; i < maxLandsCount; ++i) {\\r\\n            res += _lands[i].accountsCount;\\r\\n        }\\r\\n        return res;\\r\\n    }\\r\\n\\r\\n    function landsCount() public view returns (uint8) {\\r\\n        uint8 res;\\r\\n        for (uint8 i = 0; i < maxLandsCount; ++i) {\\r\\n            if (_lands[i].id > 0) ++res;\\r\\n        }\\r\\n        return res;\\r\\n    }\\r\\n\\r\\n    function _getEmptyLandNumber() internal view returns (uint8) {\\r\\n        for (uint8 i = 0; i < maxLandsCount; ++i) {\\r\\n            if (_lands[i].id == 0) return i + 1;\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function ethRewardsCount() public view returns (uint256) {\\r\\n        return address(this).balance - ethOnLands();\\r\\n    }\\r\\n\\r\\n    function tokenRewardsCount() public view returns (uint256) {\\r\\n        return _token.balanceOf(address(this)) - tokenOnLandsRewardWithStacks();\\r\\n    }\\r\\n\\r\\n    function token2RewardsCount() public view returns (uint256) {\\r\\n        return token2Total() - token2OnLands();\\r\\n    }\\r\\n\\r\\n    function _generateLandEth() private returns (uint256) {\\r\\n        return\\r\\n            (ethRewardsCount() *\\r\\n                _rand(landRewardPercentMin, landRewardPercentMax)) / 1000;\\r\\n    }\\r\\n\\r\\n    function _generateLandToken1() private returns (uint256) {\\r\\n        return\\r\\n            (tokenRewardsCount() *\\r\\n                _rand(landRewardPercentMin, landRewardPercentMax)) / 1000;\\r\\n    }\\r\\n\\r\\n    function _generateLandToken2() private returns (uint256) {\\r\\n        return\\r\\n            (token2RewardsCount() *\\r\\n                _rand(landRewardPercentMin, landRewardPercentMax)) / 1000;\\r\\n    }\\r\\n\\r\\n    function _addRewardsToLand(Land storage land) private {\\r\\n        land.eth += _generateLandEth();\\r\\n        land.token1 += _generateLandToken1();\\r\\n        land.token2 += _generateLandToken2();\\r\\n    }\\r\\n\\r\\n    function getLands() external view returns (LandData[maxLandsCount] memory) {\\r\\n        LandData[maxLandsCount] memory res;\\r\\n        for (uint8 i = 0; i < maxLandsCount; ++i) {\\r\\n            if (!_lands[i].isExists()) continue;\\r\\n            res[i] = _lands[i].getData(i + 1);\\r\\n        }\\r\\n        return res;\\r\\n    }\\r\\n\\r\\n    function getLandData(\\r\\n        uint256 landId\\r\\n    ) external view returns (LandData memory) {\\r\\n        (Land storage land, uint8 number) = _getLandByIdInternal(landId);\\r\\n        return land.getData(number);\\r\\n    }\\r\\n\\r\\n    function _createLand(uint8 number) private {\\r\\n        Land storage land = _getLandByNumber(number);\\r\\n        land.id = ++landslCreatedTotal;\\r\\n        uint256 periodTake = _rand(\\r\\n            landTakeGoldSecondsMin,\\r\\n            landTakeGoldSecondsMax\\r\\n        );\\r\\n        uint256 periodWait = _rand(\\r\\n            landPeriodWaitSecondsMin,\\r\\n            landPeriodWaitSecondsMax\\r\\n        );\\r\\n        land.periodSeconds = periodTake + periodWait;\\r\\n        land.takeGoldSeconds = periodTake;\\r\\n        land.creationTime = block.timestamp;\\r\\n        _addRewardsToLand(land);\\r\\n        _newLandTime = block.timestamp + _rand(newLandTimeMin, newLandTimeMax);\\r\\n    }\\r\\n\\r\\n    function _isNeedEraseLand(Land memory land) private view returns (bool) {\\r\\n        return land.id > 0 && !land.isExists();\\r\\n    }\\r\\n\\r\\n    function refreshLand(uint8 number) external {\\r\\n        _refreshLand(_getLandByNumber(number), number);\\r\\n        _createNewLands();\\r\\n    }\\r\\n\\r\\n    function _refreshLand(Land storage land, uint8 number) private {\\r\\n        if (_eraseLand(land, number)) return;\\r\\n        _tryNextTakePeriodSnapshot(land);\\r\\n    }\\r\\n\\r\\n    function _eraseLand(\\r\\n        Land storage land,\\r\\n        uint8 number\\r\\n    ) private returns (bool) {\\r\\n        require(\\r\\n            number >= 1 && number <= maxLandsCount,\\r\\n            ERR_INCORRECT_WORLD_NUMBER\\r\\n        );\\r\\n        if (!_isNeedEraseLand(land)) return false;\\r\\n        uint256 tokenToBurn = land.token1 + land.tokenStaked;\\r\\n        if (tokenToBurn > 0) _token.transfer(address(0), tokenToBurn);\\r\\n        delete _lands[number - 1];\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function refreshLands() external {\\r\\n        _refreshLandsErases();\\r\\n        _refreshLandsTakePeriods();\\r\\n        _createNewLands();\\r\\n    }\\r\\n\\r\\n    function createNewLands() external {\\r\\n        _createNewLands();\\r\\n    }\\r\\n\\r\\n    function _createNewLands() private {\\r\\n        if (!isInitialized) return;\\r\\n        // time limit\\r\\n        if (block.timestamp < _newLandTime) return;\\r\\n        // getting new land number\\r\\n        uint8 newLandNumber = _getEmptyLandNumber();\\r\\n        if (newLandNumber == 0) return;\\r\\n        // creating the new land\\r\\n        _createLand(newLandNumber);\\r\\n    }\\r\\n\\r\\n    function _refreshLandsTakePeriods() private {\\r\\n        for (uint8 i = 0; i < maxLandsCount; ++i) {\\r\\n            _tryNextTakePeriodSnapshot(_lands[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _refreshLandsErases() private {\\r\\n        for (uint8 i = 1; i <= maxLandsCount; ++i) {\\r\\n            _eraseLand(_lands[i - 1], i);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"master_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accountsOnLands\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token2_\",\"type\":\"address\"}],\"name\":\"changeErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"changeEthMasterFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chance\",\"type\":\"uint256\"}],\"name\":\"changeLandEraseStartChance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"landPeriodWaitSecondsMin_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"landPeriodWaitSecondsMax_\",\"type\":\"uint256\"}],\"name\":\"changePeriodWaitSeconds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"changePrizePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"landTakeGoldSecondsMin_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"landTakeGoldSecondsMax_\",\"type\":\"uint256\"}],\"name\":\"changeTakeGoldSeconds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createNewLands\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethMasterFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethOnLands\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethRewardsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acc\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"landId\",\"type\":\"uint256\"}],\"name\":\"getAccSlotForLand\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"landId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takePeriod\",\"type\":\"uint256\"}],\"internalType\":\"struct AccLandData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getAccSlots\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"landId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takePeriod\",\"type\":\"uint256\"}],\"internalType\":\"struct AccLandData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getLandById\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"periodSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takeGoldSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eraseTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accountsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takePeriodSnapshot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenStakedSnapshot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethSnapshot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenSnapshot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token2Snapshot\",\"type\":\"uint256\"}],\"internalType\":\"struct Land\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"number\",\"type\":\"uint8\"}],\"name\":\"getLandByNumber\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"periodSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takeGoldSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eraseTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accountsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takePeriodSnapshot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenStakedSnapshot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethSnapshot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenSnapshot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token2Snapshot\",\"type\":\"uint256\"}],\"internalType\":\"struct Land\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"landId\",\"type\":\"uint256\"}],\"name\":\"getLandData\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"periodSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takeGoldSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eraseTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accountsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takePeriodSnapshot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenStakedSnapshot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethSnapshot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenSnapshot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token2Snapshot\",\"type\":\"uint256\"}],\"internalType\":\"struct Land\",\"name\":\"land\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenStaked\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isTakeTime\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isDirty\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"internalType\":\"struct Period\",\"name\":\"period\",\"type\":\"tuple\"},{\"internalType\":\"uint8\",\"name\":\"number\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isExists\",\"type\":\"bool\"}],\"internalType\":\"struct LandData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getLandNumberById\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"landId\",\"type\":\"uint256\"}],\"name\":\"getLandTakePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLands\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"periodSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takeGoldSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eraseTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accountsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takePeriodSnapshot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenStakedSnapshot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethSnapshot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenSnapshot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token2Snapshot\",\"type\":\"uint256\"}],\"internalType\":\"struct Land\",\"name\":\"land\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenStaked\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isTakeTime\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isDirty\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"internalType\":\"struct Period\",\"name\":\"period\",\"type\":\"tuple\"},{\"internalType\":\"uint8\",\"name\":\"number\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isExists\",\"type\":\"bool\"}],\"internalType\":\"struct LandData[4]\",\"name\":\"\",\"type\":\"tuple[4]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"landId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getRewardForAccount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token2\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"landId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensCount\",\"type\":\"uint256\"}],\"name\":\"getRewardForTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token2\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"landId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensCount\",\"type\":\"uint256\"}],\"name\":\"goToLand\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"isLandExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"landNumber\",\"type\":\"uint8\"}],\"name\":\"isLandTakeSeason\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"landEraseStartChance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"landEraseTimeMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"landEraseTimeMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"landPeriodWaitSecondsMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"landPeriodWaitSecondsMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"landRewardPercentMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"landRewardPercentMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"landTakeGoldSecondsMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"landTakeGoldSecondsMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"landsCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"landslCreatedTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"landId\",\"type\":\"uint256\"}],\"name\":\"leaveLand\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"master\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxLandsCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newLandTimeMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newLandTimeMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"number\",\"type\":\"uint8\"}],\"name\":\"refreshLand\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refreshLands\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"landId\",\"type\":\"uint256\"}],\"name\":\"takeGold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token2\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token2OnLands\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token2RewardsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token2Total\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenOnLands\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenOnLandsRewardWithStacks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenRewardsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenStacked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Sunra", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000056098bac3e8de316bcf1241143316f8b846c79cb", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}