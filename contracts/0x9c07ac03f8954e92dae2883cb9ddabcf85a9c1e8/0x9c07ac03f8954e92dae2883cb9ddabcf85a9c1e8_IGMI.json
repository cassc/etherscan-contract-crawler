{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/CarpetBomb.sol\": {\r\n      \"content\": \"/* SPDX-License-Identifier: MIT */\\n/**\\n *\\n *\\n *\\n * \\\"we're gonna make it\\\"? fuck yall, I'M gonna make it\\n *\\n *\\n * https://igmi.tech\\n *\\n *\\n * @title IGMI - good traders may profit, but only one buyer is gonna make it.\\n *\\n * @notice\\n * Increase your balanace above qualifying tiers to earn entries for the prize, decrease your balance below those tiers to lose them.\\n * Once the timeframe has elapsed, only one current entrant will win the entire LP.\\n *\\n * IMPORTANT: THE ABILITY TO TRADE THIS TOKEN WILL END WHEN A WINNER IS REQUESTED.\\n *\\n * @notice\\n * ONE ENTRY - 500 tokens (500 * 10 ** 18) // .05%\\n * TWO ENTRIES - 1_000 tokens (1_000 * 10 ** 18) // .1%\\n * THREE ENTRIES - 1_500 tokens (1_500 * 10 ** 18) // .15%\\n * FOUR ENTRIES - 2_000 tokens (2_000 * 10 ** 18) // .2%\\n * FIVE ENTRIES - 2_500 tokens (2_500 * 10 ** 18) // .25%\\n * SEVEN ENTRIES - 3_500 tokens (3_500 * 10 ** 18) // .35%\\n * TEN ENTRIES - 5_000 tokens (5_000 * 10 ** 18) // .5%\\n *\\n * @notice\\n * DETAILS:\\n * After 24 hours, owner will close trading permanently and request a random number off-chain.\\n * The random number is automatically used to find a random user by their entry index.\\n * When the winner is found, liquidity is completely pulled by the contract, and the winning user gets ALL of the ETH pulled from the liquidity pool.\\n * You are free to swap in and out of the pool, earning and losing entries as you wish, until that point.\\n * Exit the game and take your profits, or risk it for a chance at the big prize. Are you gonna make it?\\n *\\n * NOTE: The contract owner is permanently incapable of pulling liquidity for themself.\\n */\\n\\npragma solidity ^0.8.20;\\n\\nimport {VRFV2WrapperConsumerBase} from \\\"@chainlink/v0.8/vrf/VRFV2WrapperConsumerBase.sol\\\";\\nimport {IUniswapV2Pair} from \\\"@uniswap-core/interfaces/IUniswapV2Pair.sol\\\";\\nimport {IUniswapV2Router02} from \\\"@uniswap-periphery/interfaces/IUniswapV2Router02.sol\\\";\\nimport {IUniswapV2Factory} from \\\"@uniswap-core/interfaces/IUniswapV2Factory.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function balanceOf(address holder) external returns (uint256);\\n}\\n\\ncontract IGMI is ERC20, Ownable, VRFV2WrapperConsumerBase {\\n    /*//////////////////////////////////////////////////////////////\\n                                 STRUCTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @dev comments on structs denote the bit size of the element\\n     */\\n\\n    /**\\n     * @dev struct assigned to all users\\n     * @param buy user's buy block\\n     * @param exemptfee sets user exempt from fees\\n     * @param exemptlimit sets user exempt from limits\\n     * @param index the user's entry index (represents the user in the global entries)\\n     */\\n    struct USER {\\n        uint256 buy; // 32\\n        uint256 exemptfee; // 8\\n        uint256 exemptlimit; // 8\\n        uint256 index; // 24\\n    }\\n\\n    /**\\n     * @dev struct which stores values used in transfer checks\\n     * @param changeblock the block on which trading begins\\n     * @param limitsblock the block after which limits are no longer checked\\n     * @param standardmode when enabled, there are no fees, restrictions, or entry logging\\n     * @param feesenabled when enabled, fees are taken\\n     * @param cooldown the minimum block count that must pass before a user can perform another transfer\\n     * @param eoatransfers when enabled, wallet-to-wallet transfers (externally-owned addresses, EOAs) are allowed\\n     */\\n    struct CHECKS {\\n        uint256 changeblock; // 32\\n        uint256 limitsblock; // 32\\n        uint256 standardmode; // 8\\n        uint256 feesenabled; // 8\\n        uint256 cooldown; // 8\\n        uint256 eoatransfers; // 8\\n    }\\n\\n    /**\\n     * @dev struct which stores fee values\\n     * @param feebuy fee on buy\\n     * @param feesell fee on sell\\n     * @param feeliq fee for liquidity on both buys and sells\\n     */\\n    struct FEES {\\n        uint256 feebuy; // 8\\n        uint256 feesell; // 8\\n        uint256 feeliq; // 8\\n    }\\n\\n    /**\\n     * @dev struct which stores max amounts at the 0th decimal (1 vs. 1 * 1e18)\\n     * @param maxtx max transaction amount for non-exempt users within the limits window\\n     * @param maxbal max balance for non-exempt users within the limits window\\n     */\\n    struct MAX {\\n        uint256 maxtx; // 16\\n        uint256 maxbal; // 24\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 CONSTANTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    // minimum amount of tokens held to qualify for corresponding entry counts\\n    uint256 private constant ONE_ENTRY = 500 * 1e18;\\n    uint256 private constant TWO_ENTRIES = 1_000 * 1e18;\\n    uint256 private constant THREE_ENTRIES = 1_500 * 1e18;\\n    uint256 private constant FOUR_ENTRIES = 2_000 * 1e18;\\n    uint256 private constant FIVE_ENTRIES = 2_500 * 1e18;\\n    uint256 private constant SEVEN_ENTRIES = 3_500 * 1e18;\\n    uint256 private constant TEN_ENTRIES = 5_000 * 1e18;\\n\\n    uint256 private constant DECIMAL_MULTIPLIER = 1e18;\\n    uint256 private constant ROLL_IN_PROGRESS = 9999999;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @dev\\n     * this uint256 holds these values in this order: CHECKS, FEES, MAX, currentUserIndex, currentEntryIndex\\n     * see getAllData()\\n     */\\n    uint256 private data_;\\n\\n    uint128 public _randomResult;\\n    uint48 public _closeLimitBlock;\\n    uint48 public _closedAtTimestamp;\\n    uint32 public _linkFee;\\n    uint256 public _pureRandomNumber;\\n\\n    // general user storage\\n    mapping(address => uint256) private _users;\\n    // individual user entry tracking\\n    mapping(address => uint256) private _userEntries;\\n    // entries 'array'\\n    mapping(uint256 => uint256) private _allEntries;\\n    // user index matching\\n    mapping(uint256 => address) private _indexUser;\\n\\n    address private immutable WETH;\\n    IUniswapV2Router02 public immutable ROUTER;\\n\\n    address private _pair;\\n    address private _wrapper;\\n    address public _winner;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event FeesUpdated(uint256 buy, uint256 sell, uint256 liq);\\n    event MaxUpdated(uint256 maxtx, uint256 maxbal);\\n    event FeesToggled(bool feesenabled);\\n    event StandardModeToggled(bool standardmode);\\n    event EOATransfersToggled(bool eoatransfers);\\n    event LimitBlockReduced(uint256 newblock);\\n    event CooldownReduced(uint256 newcooldown);\\n    event LinkFeeUpdated(uint256 newfee);\\n    event LiqBoosted(address token, uint256 amount);\\n    event EntriesGained(address user, uint256 amount);\\n    event EntriesLost(address user, uint256 amount);\\n    event DiceRolled(uint256 indexed requestId);\\n    event DiceLanded(uint256 indexed requestId, uint256 indexed result);\\n    event SentToWinner(address _holder);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 ERRORS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    error sendToZero();\\n    error notOpen();\\n    error alreadyOpen();\\n    error vrfCallbackNotComplete();\\n    error closeConditionsUnmet();\\n    error notAuthorized();\\n    error exceedMaxBalance();\\n    error belowMinBalance();\\n    error exceedMaxTx();\\n    error valueTooLow();\\n    error valueTooHigh();\\n    error txCooldown();\\n    error noEOAtoEOATransfers();\\n    error failedToSendETH();\\n    error castOverflow(uint256 value, uint256 bytecount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address router_, address linkAddress, address wrapperAddress)\\n        payable\\n        ERC20(\\\"IGMI\\\", \\\"IGMI\\\")\\n        VRFV2WrapperConsumerBase(linkAddress, wrapperAddress)\\n    {\\n        _wrapper = wrapperAddress;\\n        _setUserData(address(this), 0, 1, 1, 0);\\n        _setUserData(msg.sender, 0, 1, 1, 0);\\n        _mint(address(this), 1_000_000 * DECIMAL_MULTIPLIER);\\n        ROUTER = IUniswapV2Router02(router_);\\n        WETH = ROUTER.WETH();\\n        _linkFee = uint32(1_000_000);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            STANDARD LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    receive() external payable {}\\n\\n    // ERC20 override\\n    function _transfer(address sender, address recipient, uint256 amount) internal override {\\n        uint256 data = data_;\\n        CHECKS memory checks = _getChecksData(data);\\n        USER memory senderData = _getUserData(_users[sender]);\\n        USER memory recipientData = _getUserData(_users[recipient]);\\n        // common conditions for no fee/limit transfers\\n        if (\\n            sender == address(this) // mid-swap\\n                || checks.standardmode != 0 // no fees, no restrictions for anyone\\n                || (senderData.exemptfee != 0 && senderData.exemptlimit != 0) // token contract, owner, or, after trading close, the router\\n                || (recipientData.exemptfee != 0 && recipientData.exemptlimit != 0) // token contract, owner, or, after trading close, the router\\n        ) {\\n            super._transfer(sender, recipient, amount);\\n\\n            // fee/limit logic\\n        } else {\\n            // check if trading is open\\n            if (checks.changeblock == 0) {\\n                revert notOpen();\\n            }\\n\\n            bool buy;\\n            address pair = _pair;\\n            MAX memory max = _getMaxData(data);\\n            FEES memory fees = _getFeesData(data);\\n            USER memory origData = _getUserData(_users[tx.origin]);\\n\\n            // ------BUY------ //\\n            if (pair == sender) {\\n                // buy restrictions\\n                if (recipientData.exemptlimit == 0) {\\n                    // restrictions - launch window\\n                    if (checks.limitsblock > block.number) {\\n                        if (block.number < checks.changeblock + 2) {\\n                            // first two blocks get 20% buy fees\\n                            fees.feebuy = 10;\\n                            fees.feeliq = 10;\\n                        }\\n                        if (amount > max.maxtx * DECIMAL_MULTIPLIER) {\\n                            revert exceedMaxTx();\\n                        }\\n                        if ((balanceOf(recipient) + amount) > max.maxbal * DECIMAL_MULTIPLIER) {\\n                            revert exceedMaxBalance();\\n                        }\\n                        // cooldown\\n                        unchecked {\\n                            if (\\n                                recipientData.buy + checks.cooldown > block.number\\n                                    || origData.buy + checks.cooldown > block.number\\n                            ) {\\n                                revert txCooldown();\\n                            }\\n                        }\\n                        // 10% buy first 10 minutes\\n                        fees.feebuy = 7;\\n                        fees.feeliq = 3;\\n                    }\\n                    // set user's buy block\\n                    recipientData.buy = block.number;\\n\\n                    // update user buy block if they have previously bought (this is otherwise handled in _checkEligibility)\\n                    if (recipientData.index != 0) {\\n                        _setUserData(\\n                            recipient,\\n                            recipientData.buy,\\n                            recipientData.exemptfee,\\n                            recipientData.exemptlimit,\\n                            recipientData.index\\n                        );\\n                    }\\n\\n                    _checkEligibility(\\n                        recipient, recipientData, amount, data, fees, true, checks.feesenabled != 0 ? true : false\\n                    );\\n\\n                    // assigning a buy block to tx.origin\\n                    if (tx.origin != recipient && checks.limitsblock > block.number) {\\n                        _setUserData(\\n                            tx.origin,\\n                            recipientData.buy,\\n                            recipientData.exemptfee,\\n                            recipientData.exemptlimit,\\n                            recipientData.index\\n                        );\\n                    }\\n                }\\n\\n                buy = true;\\n            } else {\\n                // ------SELL------ //\\n                if (pair == recipient) {\\n                    // restrictions - permanent\\n                    if (senderData.exemptlimit == 0 && checks.cooldown != 0) {\\n                        unchecked {\\n                            if (\\n                                senderData.buy + checks.cooldown > block.number\\n                                    || origData.buy + checks.cooldown > block.number\\n                            ) {\\n                                revert txCooldown();\\n                            }\\n                        }\\n                    }\\n\\n                    _checkEligibility(\\n                        sender, senderData, amount, data, fees, false, checks.feesenabled != 0 ? true : false\\n                    );\\n\\n                    uint256 contractBalance = balanceOf(address(this));\\n                    // only attempt to sell an amount that uniswap shouldnt complain about (INSUFFICIENT_OUTPUT_AMOUNT)\\n                    if (contractBalance > ONE_ENTRY) {\\n                        // perform fee swap for maximum 5% price impact\\n                        uint256 priceImpactLimiter = (balanceOf(recipient) * 5) / 100;\\n                        _nestedSwap(contractBalance > priceImpactLimiter ? priceImpactLimiter : (contractBalance - 1));\\n                    }\\n                }\\n            }\\n\\n            // take fees on swaps to/from pair only, and perform final transfer\\n            if (\\n                checks.feesenabled != 0\\n                    && (\\n                        ((recipientData.exemptfee == 0) && pair == sender)\\n                            || ((senderData.exemptfee == 0) && pair == recipient)\\n                    )\\n            ) {\\n                _collectAndTransfer(sender, recipient, amount, buy, fees);\\n\\n                // EOA to EOA transfer (no fees)\\n            } else {\\n                // if recipient is not exempt from limits, assign highest limit between sender and recipient to recipient\\n                if (pair != sender && pair != recipient) {\\n                    // if EOA to EOA transfers are disabled, revert\\n                    if (checks.eoatransfers == 0) revert noEOAtoEOATransfers();\\n                    if (recipientData.exemptfee == 0 && recipientData.buy < senderData.buy) {\\n                        recipientData.buy = senderData.buy;\\n                    }\\n\\n                    // check if sender loses entries\\n                    _checkEligibility(sender, senderData, amount, data, fees, false, false);\\n\\n                    // check if recipient gains entries\\n                    _checkEligibility(recipient, recipientData, amount, data, fees, true, false);\\n                }\\n\\n                super._transfer(sender, recipient, amount);\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        PRIVATE/INTERNAL WRITE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @dev\\n     * use this function to take fees and perform the final transfer\\n     * although this function is only used once, it's separated due to stack-too-deep error\\n     * @param sender the address of the sender\\n     * @param recipient the address of the recipient\\n     * @param amount the amount being sent\\n     * @param buy whether or not this is a buy\\n     * @param fees the FEES struct\\n     */\\n    function _collectAndTransfer(address sender, address recipient, uint256 amount, bool buy, FEES memory fees)\\n        private\\n    {\\n        (uint256 fee, uint256 liqFee) = buy ? (fees.feebuy, fees.feeliq) : (fees.feesell, fees.feeliq);\\n        uint256 collection = (amount * fee) / 100;\\n        uint256 liq = (amount * liqFee) / 100;\\n        uint256 remainder = amount - collection - liq;\\n        if (buy) {\\n            // on buy, keep liq fee amount in the pair\\n            super._transfer(sender, recipient, remainder);\\n        } else {\\n            // ensures liq fee tokens are not counted as part of the amountIn\\n            if (liq != 0) {\\n                super._transfer(sender, recipient, liq);\\n                IUniswapV2Pair(recipient).sync();\\n            }\\n            super._transfer(sender, recipient, remainder);\\n        }\\n        if (collection != 0) {\\n            super._transfer(sender, address(this), collection);\\n        }\\n    }\\n\\n    function _nestedSwap(uint256 amount) private {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = WETH;\\n        ROUTER.swapExactTokensForETHSupportingFeeOnTransferTokens(amount, 0, path, address(this), block.timestamp);\\n    }\\n\\n    /**\\n     * @dev\\n     * this function determines if user will gain or lose entries for this transaction, and adds/removes them accordingly\\n     * this function also sets all data for this user and assigns them an index if they are receiving tokens for the first time\\n     * @param user address of the user being checked\\n     * @param userData the user's USER struct\\n     * @param amount the amount being sent\\n     * @param data the global data_ value, sent through memory\\n     * @param buy used to determine whether we should check if user is gaining or losing entries\\n     */\\n    function _checkEligibility(\\n        address user,\\n        USER memory userData,\\n        uint256 amount,\\n        uint256 data,\\n        FEES memory fees,\\n        bool buy,\\n        bool checkFees\\n    ) private {\\n        uint256 entriesCount = _getUserEntryCount(user);\\n        uint256 eligibleCount;\\n\\n        // balance is increasing\\n        if (buy) {\\n            if (checkFees) {\\n                if (fees.feebuy != 0 && fees.feeliq != 0) {\\n                    eligibleCount = getEligibleCount(\\n                        balanceOf(user) + (amount - ((amount * fees.feebuy) / 100) - ((amount * fees.feeliq) / 100))\\n                    );\\n                } else if (fees.feebuy != 0 && fees.feeliq == 0) {\\n                    eligibleCount = getEligibleCount(balanceOf(user) + (amount - ((amount * fees.feebuy) / 100)));\\n                } else if (fees.feebuy == 0 && fees.feeliq != 0) {\\n                    eligibleCount = getEligibleCount(balanceOf(user) + (amount - ((amount * fees.feeliq) / 100)));\\n                } else {\\n                    // feebuy == 0 && feeliq == 0, but feesell != 0\\n                    eligibleCount = getEligibleCount(balanceOf(user) + amount);\\n                }\\n                // EOA to EOA transfer\\n            } else {\\n                eligibleCount = getEligibleCount(balanceOf(user) + amount);\\n            }\\n\\n            uint256 userIndex = userData.index;\\n            uint256 newUserIndex = userData.index;\\n\\n            // store user and assign an index if not yet assigned (first buy)\\n            if (userIndex == 0) {\\n                userIndex = _getCurrentUserIndex(data);\\n                newUserIndex = userIndex;\\n                _setUserData(user, userData.buy, userData.exemptfee, userData.exemptlimit, userIndex);\\n                _indexUser[userIndex] = user;\\n                unchecked {\\n                    ++newUserIndex;\\n                }\\n            }\\n\\n            // skip remaining logic and only update userIndex if user is new and entry count is unchanged\\n            if ((eligibleCount == 0 || eligibleCount == entriesCount) && userIndex != newUserIndex) {\\n                _setCurrentUserIndex(data, newUserIndex);\\n                return;\\n            }\\n\\n            if (eligibleCount > entriesCount) {\\n                uint256 entryIndex = _getCurrentEntryIndex(data);\\n                // add user entries to the user's entries 'array'\\n                (uint256 newEntriesAmount) = _addEntriesToUserEntries(user, eligibleCount - entriesCount, entryIndex);\\n\\n                // add user entries to the total entries 'array'\\n                uint256 newEntryIndex = _addEntriesToAllEntries(userIndex, newEntriesAmount, entryIndex);\\n\\n                if (userIndex != newUserIndex) {\\n                    // update both current user index and entry index if adding a qualifying user on this buy\\n                    _setCurrentIndeces(data, newUserIndex, newEntryIndex);\\n                } else {\\n                    // only update entry index\\n                    _setCurrentEntryIndex(data, newEntryIndex);\\n                }\\n\\n                emit EntriesGained(user, eligibleCount - entriesCount);\\n            }\\n            // balance is decreasing\\n        } else {\\n            // avoid underflow\\n            if (balanceOf(user) < amount) return;\\n\\n            eligibleCount = getEligibleCount(balanceOf(user) - amount);\\n\\n            if (eligibleCount < entriesCount) {\\n                uint256 subAmount = entriesCount - eligibleCount;\\n                uint24[] memory removedEntries = new uint24[](subAmount);\\n\\n                // remove user entries from the user's entries 'array'\\n                removedEntries = _removeEntriesFromUserEntries(user, subAmount);\\n\\n                // remove user entries from the total entries 'array'\\n                _removeEntriesFromAllEntries(removedEntries);\\n\\n                emit EntriesLost(user, subAmount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev\\n     * this function iteratively adds entries to the _allEntries mapping\\n     * the _allEntries mapping is treated as an object which contains sequential arrays of 10 numbers each.\\n     * entries are stored as such: _allEntries[0] = [0,1,2,3,4,5,6,7,8,9], _allEntries[1] = [10,11,12,13,14,15,16,17,18,19], etc.\\n     * we can use division and modulo on a given entry index to always find the key of the 'array' it's in, and its position in that 'array'\\n     * note that 24 in the following function represents the maximum bit size of an index.\\n     * @param indexUser the index of the user being assigned entries\\n     * @param entryCount the number of entries to assign this user\\n     * @param currentEntryIndex the next entry index to assign a user\\n     * @return currentEntryIndex the new value of currentEntryIndex, after adding entries\\n     */\\n    function _addEntriesToAllEntries(uint256 indexUser, uint256 entryCount, uint256 currentEntryIndex)\\n        private\\n        returns (uint256)\\n    {\\n        uint256 currentKey;\\n        unchecked {\\n            currentKey = currentEntryIndex / 10;\\n        }\\n        uint256 currentBitObject = _allEntries[currentKey];\\n\\n        for (uint256 i; i < entryCount;) {\\n            // retrieve key of current bit object\\n            uint256 key;\\n            unchecked {\\n                key = currentEntryIndex / 10;\\n            }\\n\\n            // determine position within that bit object\\n            // ex. currentPosition = 35\\n            // key = 35 / 10 = 3\\n            // position within bit object = 35 % (3 * 10) = 5\\n            // cannot modulo by 0, so just use currentPosition if key is 0\\n            uint256 position;\\n            unchecked {\\n                position = currentEntryIndex > 9 ? currentEntryIndex % (key * 10) : currentEntryIndex;\\n            }\\n\\n            // determine starting position\\n            // ex. position within bit object is 2\\n            // startingPosition = 24 (length) * 2 = 48\\n            uint256 startingPosition;\\n            unchecked {\\n                startingPosition = 24 * position;\\n            }\\n\\n            if (startingPosition != 0) {\\n                currentBitObject |= indexUser << startingPosition;\\n            } else {\\n                currentBitObject = indexUser << startingPosition;\\n            }\\n\\n            // update storage if at the end of the uint, or the loop is complete\\n            unchecked {\\n                if (position == 9 || i + 1 == entryCount) {\\n                    _allEntries[key] = currentBitObject;\\n                }\\n\\n                ++currentEntryIndex;\\n                ++i;\\n            }\\n        }\\n        // return new entry index, to be stored in calling function\\n        return currentEntryIndex;\\n    }\\n\\n    /**\\n     * @dev adds entries to a user's entries 'array'\\n     * @param user the address of the user\\n     * @param addAmount the amount of entries to add\\n     * @param currentEntryIndex the global current entry index, which was not affected by this function\\n     * @return addAmount the amount of entries added\\n     */\\n    function _addEntriesToUserEntries(address user, uint256 addAmount, uint256 currentEntryIndex)\\n        private\\n        returns (uint256)\\n    {\\n        uint256 currentBitObject = _userEntries[user];\\n        // get the next entry position\\n        (, uint256 nextEntryPosition) = _getCurrentEntryCountAndNextEntryPosition(currentBitObject);\\n\\n        // although a 10th entry means the next entry bit position is 240 (24 * 10),\\n        // nextEntryPosition doesn't get a final 24 added to it in _getCurrentEntryCountAndNextEntryPosition() before the loop ends.\\n        // this would matter if we had a tier that qualifies for 9 entries, but we don't, so it doesn't.\\n        // it's cheaper not to perform that check and addition.\\n        if (nextEntryPosition == 216) return (addAmount);\\n\\n        for (uint256 i; i < addAmount;) {\\n            currentBitObject |= currentEntryIndex << nextEntryPosition;\\n            unchecked {\\n                ++currentEntryIndex;\\n                ++i;\\n            }\\n            if (nextEntryPosition == 216) {\\n                // ensure we don't attempt to add more entries than will fit (216 means user is in the 10-entry tier already)\\n                break;\\n            }\\n            unchecked {\\n                nextEntryPosition += 24;\\n            }\\n        }\\n        _userEntries[user] = currentBitObject;\\n        return (addAmount);\\n    }\\n\\n    /**\\n     * @dev this function accepts an array of entries to find and remove from the global entries 'array'\\n     * @param entries an array of entries to remove\\n     */\\n    function _removeEntriesFromAllEntries(uint24[] memory entries) private {\\n        uint256 entriesLength = entries.length;\\n        uint256 previousKey;\\n        uint256 currentBitObject;\\n        for (uint256 i; i < entriesLength;) {\\n            uint256 entry = entries[i];\\n            uint256 currentKey;\\n\\n            // get the key for the current entry\\n            unchecked {\\n                currentKey = entry / 10;\\n            }\\n            if (i == 0) {\\n                currentBitObject = _allEntries[currentKey];\\n            }\\n            if (i != 0 && previousKey != currentKey) {\\n                // store previous changes\\n                _allEntries[previousKey] = currentBitObject;\\n                // get current key's 'bit object' and store it to memory\\n                currentBitObject = _allEntries[currentKey];\\n            }\\n\\n            // determine position within that bit object\\n            // cannot modulo by 0, so just use currentPosition if key is 0\\n            uint256 position;\\n            unchecked {\\n                position = entry > 9 ? entry % (currentKey * 10) : entry;\\n            }\\n            uint256 startingPosition;\\n            unchecked {\\n                startingPosition = 24 * position;\\n            }\\n            // update the bit object by removing this entry\\n            currentBitObject = _clearBits(currentBitObject, startingPosition, 24);\\n\\n            // retain the updated bit object in memory, unless this is the last iteration of the loop\\n            unchecked {\\n                if (i + 1 == entriesLength) {\\n                    _allEntries[currentKey] = currentBitObject;\\n                }\\n                previousKey = currentKey;\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev this function removes entries from a user's entries 'array', starting at the most recently-added entry\\n     * @param user the address of the user to remove entries from\\n     * @param subAmount the amount of entries to remove\\n     * @return removedEntries the entries that were removed, which now must be removed from the global entries 'array'\\n     */\\n    function _removeEntriesFromUserEntries(address user, uint256 subAmount) private returns (uint24[] memory) {\\n        // get existing entry count\\n        uint256 entryCount = _getUserEntryCount(user);\\n        // get the user's bit object\\n        uint256 entriesBits = _userEntries[user];\\n        // initialize array of entries being removed\\n        uint24[] memory removedEntries = new uint24[](subAmount);\\n        // start bitPosition at the user's last entry\\n        uint256 bitPosition = (entryCount * 24);\\n        // add entries being removed to memory array and find starting point for mask\\n        for (uint256 i; i < subAmount;) {\\n            // move to the beginning of entry's bit space\\n            unchecked {\\n                bitPosition -= 24;\\n            }\\n            removedEntries[i] = uint24(entriesBits >> bitPosition);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        // update the bit object by removing this entry\\n        _userEntries[user] = _clearBits(entriesBits, bitPosition, (24 * subAmount));\\n\\n        // return an array of the user's removed entries to remove from the total entries\\n        return removedEntries;\\n    }\\n\\n    /**\\n     * @dev\\n     * sets the entire global data_ value at once\\n     * the bitSize array holds the size of each sequential element to ensure they are put in the right position\\n     * @param tempData an array of all of the values in the global data_ value. they are as follows, with corresponding bit size:\\n     * @dev uint256 changeblock, // 32\\n     * @dev uint256 limitsblock, // 32\\n     * @dev uint256 standardmode, // 8\\n     * @dev uint256 feesenabled, // 8\\n     * @dev uint256 cooldown, // 8\\n     * @dev uint256 feebuy, // 8\\n     * @dev uint256 feesell, // 8\\n     * @dev uint256 feeliq, // 8\\n     * @dev uint256 maxtx, // 16\\n     * @dev uint256 maxbal, // 24\\n     * @dev uint256 userIndex, // 24\\n     * @dev uint256 entryIndex, // 24\\n     */\\n    function _setData(uint256[13] memory tempData) private {\\n        uint256 length = tempData.length;\\n        uint256 shift;\\n        uint256 data;\\n        uint8[13] memory bitSize = [32, 32, 8, 8, 8, 8, 8, 8, 8, 16, 24, 24, 24]; // bit size for each element\\n        require(length == 13);\\n        for (uint256 i; i < length;) {\\n            _overflowCheck(tempData[i], bitSize[i]);\\n            data |= tempData[i] << shift;\\n            unchecked {\\n                shift += bitSize[i];\\n                ++i;\\n            }\\n        }\\n        data_ = data;\\n    }\\n\\n    /**\\n     * @dev sets data assigned to a user\\n     * @param user the address of the user\\n     * @param buy the user's buy block\\n     * @param exemptfee whether or not the user is exempt from fees (0 is false, 1 is true)\\n     * @param exemptlimit whether or not the user is exempt from limits (0 is false, 1 is true)\\n     * @param index the user's index, used when giving them entries\\n     */\\n    function _setUserData(\\n        address user,\\n        uint256 buy, // 32\\n        uint256 exemptfee, // 8\\n        uint256 exemptlimit, // 8\\n        uint256 index // 24\\n    ) private {\\n        _overflowCheck(buy, 32);\\n        uint256 data = buy;\\n        _overflowCheck(exemptfee, 8);\\n        data |= exemptfee << 32;\\n        _overflowCheck(exemptlimit, 8);\\n        data |= exemptlimit << 40;\\n        _overflowCheck(index, 24);\\n        data |= index << 48;\\n        _users[user] = data;\\n    }\\n\\n    /**\\n     * @dev sets just the CHECKS struct in the global data_ value\\n     * @param changeblock the block on which trading begins\\n     * @param limitsblock the block after which limits are no longer checked\\n     * @param standardmode when enabled, there are no fees, restrictions, or entry logging\\n     * @param feesenabled when enabled, fees are taken\\n     * @param cooldown the minimum block count that must pass before a user can perform another transfer\\n     * @param eoatransfers when enabled, allow transfers from one EOA to another (wallet to wallet)\\n     */\\n    function _setChecksData(\\n        uint256 changeblock, // 32\\n        uint256 limitsblock, // 32\\n        uint256 standardmode, // 8\\n        uint256 feesenabled, // 8\\n        uint256 cooldown, // 8\\n        uint256 eoatransfers // 8\\n    ) private {\\n        uint256 data = _clearBits(data_, 0, 96);\\n        _overflowCheck(changeblock, 32);\\n        data |= changeblock << 0;\\n        _overflowCheck(limitsblock, 32);\\n        data |= limitsblock << 32;\\n        _overflowCheck(standardmode, 8);\\n        data |= standardmode << 64;\\n        _overflowCheck(feesenabled, 8);\\n        data |= feesenabled << 72;\\n        _overflowCheck(cooldown, 8);\\n        data |= cooldown << 80;\\n        _overflowCheck(eoatransfers, 8);\\n        data |= eoatransfers << 88;\\n        data_ = data;\\n    }\\n\\n    /**\\n     * @dev sets the changeblock to 0 to halt trading\\n     */\\n    function _setChecksDataCloseTrading() private {\\n        data_ = _clearBits(data_, 0, 32);\\n    }\\n\\n    /**\\n     * @dev sets just the FEES struct in the global data_ value\\n     * @param feebuy fee on buy\\n     * @param feesell fee on sell\\n     * @param feeliq fee for liquidity on both buys and sells\\n     */\\n    function _setFeesData(\\n        uint256 feebuy, // 8\\n        uint256 feesell, // 8\\n        uint256 feeliq // 8\\n    ) private {\\n        uint256 data = _clearBits(data_, 96, 24);\\n        _overflowCheck(feebuy, 8);\\n        data |= feebuy << 96;\\n        _overflowCheck(feesell, 8);\\n        data |= feesell << 104;\\n        _overflowCheck(feeliq, 8);\\n        data |= feeliq << 112;\\n        data_ = data;\\n    }\\n\\n    /**\\n     * @dev sets just the MAX struct in the global data_ value\\n     * @param maxtx max transaction amount for non-exempt users within the limits window\\n     * @param maxbal max balance for non-exempt users within the limits window\\n     */\\n    function _setMaxData(\\n        uint256 maxtx, // 16\\n        uint256 maxbal // 24\\n    ) private {\\n        uint256 data = _clearBits(data_, 120, 40);\\n        _overflowCheck(maxtx, 16);\\n        data |= maxtx << 120;\\n        _overflowCheck(maxbal, 24);\\n        data |= maxbal << 136;\\n        data_ = data;\\n    }\\n\\n    /**\\n     * @dev sets the next user index\\n     * @param data the global data_ value\\n     * @param index the next user index to assign a user\\n     */\\n    function _setCurrentUserIndex(uint256 data, uint256 index) private {\\n        data = _clearBits(data, 160, 24);\\n        _overflowCheck(index, 24);\\n        data |= index << 160;\\n        data_ = data;\\n    }\\n\\n    /**\\n     * @dev sets the next entry index\\n     * @param data the global data_ value\\n     * @param index the next entry index to assign a user\\n     */\\n    function _setCurrentEntryIndex(uint256 data, uint256 index) private {\\n        data = _clearBits(data, 184, 24);\\n        _overflowCheck(index, 24);\\n        data |= index << 184;\\n        data_ = data;\\n    }\\n\\n    /**\\n     * @dev sets both the next user index and the next entry index\\n     * @param data the global data_ value\\n     * @param userIndex the next index to assign a user\\n     * @param entryIndex the next entry index to assign a user\\n     */\\n    function _setCurrentIndeces(uint256 data, uint256 userIndex, uint256 entryIndex) private {\\n        data = _clearBits(data, 160, 48);\\n        _overflowCheck(userIndex, 24);\\n        data |= userIndex << 160;\\n        _overflowCheck(entryIndex, 24);\\n        data |= entryIndex << 184;\\n        data_ = data;\\n    }\\n\\n    /**\\n     * @dev sets a user exempt from fees, limits, or both\\n     * @param userAddress the address of the user\\n     * @param exemptfee whether or not the user is exempt from fees (0 is false, 1 is true)\\n     * @param exemptlimit whether or not the user is exempt from limits (0 is false, 1 is true)\\n     */\\n    function _setUserExempt(address userAddress, bool exemptfee, bool exemptlimit) private {\\n        USER memory user = _getUserData(_users[userAddress]);\\n        uint256 fee = exemptfee ? uint256(1) : 0;\\n        uint256 limit = exemptlimit ? uint256(1) : 0;\\n        _setUserData(userAddress, user.buy, fee, limit, user.index);\\n    }\\n\\n    /**\\n     * @dev\\n     * this function is run as the result of a callback from the VRF coordinator\\n     * we are taking the huge random number we get back, and getting a random entry index <= the total number of entries recorded\\n     * @param _requestId the id created by the original request\\n     * @param _randomWords the random number\\n     */\\n    function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal override {\\n        uint256 finalIndex = _getCurrentEntryIndex(data_);\\n        unchecked {\\n            --finalIndex; // last entry index assigned is one less than current value of currentEntryIndex\\n        }\\n        _pureRandomNumber = _randomWords[0];\\n\\n        uint128 randomResult = uint128(_pureRandomNumber % (finalIndex));\\n        _randomResult = randomResult;\\n        emit DiceLanded(_requestId, uint256(randomResult));\\n\\n        // perform an encodeCall so that the values above can get set successfully even if this function call fails\\n        // it is possible for this function to fail if it consumes more gas than the coordinator expects it to\\n        // in that case, dev will run the external sendToWinner function and pay the gas themself\\n        (bool success,) = address(this).call(abi.encodeCall(this.sendToWinner, (uint256(randomResult), finalIndex)));\\n        success;\\n    }\\n\\n    /**\\n     * @dev\\n     * first, we attempt to get a winner at the previously-defined winner entry index\\n     * if there is no user index at this position (because the user that was here sold and lost this entry),\\n     * we iterate up through the entries looking for a user index that is not 0\\n     * if there are none above this point, we go back to the original winner entry index and iterate down\\n     * we do not accept any circumstance in which the user index is 0, as this index is not assigned to anyone.\\n     * when we find a winner, we pull all liquidity and send the winner all of the ETH.\\n     * @param randomResult the currently-selected random entry index\\n     * @param finalIndex the very last recorded entry index (used for finding a new entry if the selected index has no entrant)\\n     */\\n    function _sendToWinner(uint256 randomResult, uint256 finalIndex) private {\\n        uint256 winnerIndex = randomResult;\\n        address winner;\\n        (, winner) = _getEntrantIdAndAddressAtIndex(winnerIndex);\\n        // if address at this index is unassigned (sold their entry), find the next entry index assigned to a user\\n        if (winner == address(0)) {\\n            // if not at the end of the entry list, increment through entries\\n            if (winnerIndex < finalIndex) {\\n                uint256 diff = finalIndex - winnerIndex;\\n                for (uint256 i; i < diff;) {\\n                    unchecked {\\n                        ++winnerIndex;\\n                    }\\n                    (, winner) = _getEntrantIdAndAddressAtIndex(winnerIndex);\\n                    if (winner != address(0)) {\\n                        break;\\n                    }\\n                    unchecked {\\n                        ++i;\\n                    }\\n                }\\n            }\\n            // contingency for reaching the end of the list - decrement from originally-selected entry index\\n            if (winner == address(0) && winnerIndex == finalIndex) {\\n                winnerIndex = randomResult;\\n                for (uint256 i; i < randomResult;) {\\n                    unchecked {\\n                        --winnerIndex;\\n                    }\\n                    (, winner) = _getEntrantIdAndAddressAtIndex(winnerIndex);\\n                    if (winner != address(0)) {\\n                        break;\\n                    }\\n                    unchecked {\\n                        ++i;\\n                    }\\n                }\\n            }\\n            require(winner != address(0));\\n            _randomResult = uint128(winnerIndex);\\n        }\\n\\n        _winner = winner;\\n        IERC20(_pair).approve(address(ROUTER), type(uint256).max);\\n        (, uint256 lpEth) = ROUTER.removeLiquidityETH(\\n            address(this), IERC20(_pair).balanceOf(address(this)), 0, 0, address(this), block.timestamp\\n        );\\n        (bool sent,) = winner.call{value: lpEth}(\\\"\\\");\\n        require(sent, \\\"Failed to send!\\\");\\n        emit SentToWinner(winner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        PRIVATE/INTERNAL VIEW/PURE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @dev checks amount qualifies for entries\\n     * @param amount amount being transferred\\n     * @return entryCount the amount of entries this amount qualifies for\\n     */\\n    function getEligibleCount(uint256 amount) private pure returns (uint256) {\\n        if (amount < ONE_ENTRY) {\\n            return 0;\\n        } else if (amount < TWO_ENTRIES) {\\n            return 1;\\n        } else if (amount < THREE_ENTRIES) {\\n            return 2;\\n        } else if (amount < FOUR_ENTRIES) {\\n            return 3;\\n        } else if (amount < FIVE_ENTRIES) {\\n            return 4;\\n        } else if (amount < SEVEN_ENTRIES) {\\n            return 5;\\n        } else if (amount < TEN_ENTRIES) {\\n            return 7;\\n        } else {\\n            return 10;\\n        }\\n    }\\n\\n    /**\\n     * @param user address of the user being checked\\n     * @param position the position of the entry being retrieved in the user's entries 'array' (0 through 9, 10 total possible positions)\\n     * @return entryId the entry id at that position\\n     */\\n    function _getUserEntries(address user, uint256 position) private view returns (uint24) {\\n        require(position < 10, \\\"Out of range\\\");\\n        uint256 bitPosition = position * 24;\\n        uint256 bitObj = _userEntries[user];\\n\\n        uint24 entryId = uint24(bitObj >> bitPosition);\\n        return (entryId);\\n    }\\n\\n    /**\\n     * @param user address of the user being checked\\n     * @return count the amount of entries user has\\n     */\\n    function _getUserEntryCount(address user) private view returns (uint256) {\\n        uint256 currentBitObject = _userEntries[user];\\n        // get the current entry count\\n        (uint256 count,) = _getCurrentEntryCountAndNextEntryPosition(currentBitObject);\\n        return count;\\n    }\\n\\n    /**\\n     * @dev performs bit masking. see comments in function for step-by-step description of behavior\\n     * @param bitObject the bits to be manipulated\\n     * @param startingPosition the position within the bits to start the mask\\n     * @param bitSize the total bit size to mask from the starting position\\n     * @return clearedBits the original bit 'object' with the targeted bit space cleared\\n     */\\n    function _clearBits(uint256 bitObject, uint256 startingPosition, uint256 bitSize)\\n        private\\n        pure\\n        returns (uint256 clearedBits)\\n    {\\n        uint256 mask = ~(uint256(2 ** bitSize - 1) << startingPosition); // set all 1s for the length of the bit space (as in a uint24), shift it left x bits to make it the appropriate entry, and then invert it to set those bits to zero\\n        // ex. mask = 11110001111\\n        clearedBits = bitObject & mask; // takes the existing bits and overwrites with the new 0 value bits\\n            // ex. currentBits = 10110110110\\n            // ex. new value = 10110000110\\n    }\\n\\n    /**\\n     * @dev\\n     * the _allEntries mapping is treated as an object which contains sequential arrays of 10 numbers each.\\n     * entries are stored as such: _allEntries[0] = [0,1,2,3,4,5,6,7,8,9], _allEntries[1] = [10,11,12,13,14,15,16,17,18,19], etc.\\n     * we can use division and modulo on a given entry index to always find the key of the 'array' its in, and its position in that 'array'\\n     * note that 24 in the following function represents the maximum bit size of an index.\\n     * @param index the entry index\\n     * @return userIndex the user index at that entry position\\n     * @return userAddress the address of the user with that userIndex\\n     */\\n    function _getEntrantIdAndAddressAtIndex(uint256 index) private view returns (uint24, address) {\\n        uint256 key = index / 10;\\n        uint256 position = index > 9 ? index % (key * 10) : index;\\n        uint256 bitPosition = position * 24;\\n        uint256 bitObj = _allEntries[key];\\n\\n        uint24 userIndex = uint24(bitObj >> bitPosition);\\n        return (userIndex, _indexUser[userIndex]);\\n    }\\n\\n    /**\\n     * @dev this function finds the existing entry count of a user, and the bit space after their most recently recorded entry\\n     * @param bitObject the entries bit 'object' of the user\\n     * @return count the amount of entries the user already has\\n     * @return nextEntryPosition the bit position where the next entry can be inserted\\n     */\\n    function _getCurrentEntryCountAndNextEntryPosition(uint256 bitObject)\\n        private\\n        pure\\n        returns (uint256 count, uint256 nextEntryPosition)\\n    {\\n        for (; count < 10;) {\\n            uint24 entry;\\n            nextEntryPosition = count * 24;\\n            entry = uint24(bitObject >> nextEntryPosition);\\n            if (entry == 0) {\\n                break;\\n            }\\n            unchecked {\\n                ++count;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev returns all of the values in the global data_ value\\n     * @param data the global data_ value\\n     * @return checks the CHECKS struct\\n     * @return fees the FEES struct\\n     * @return max the MAX struct\\n     * @return currentUserIndex the next user index to be assigned to a user\\n     * @return currentEntryIndex the next entry index to be assigned to a user\\n     */\\n    function _getAllData(uint256 data)\\n        private\\n        pure\\n        returns (\\n            CHECKS memory checks,\\n            FEES memory fees,\\n            MAX memory max,\\n            uint256 currentUserIndex,\\n            uint256 currentEntryIndex\\n        )\\n    {\\n        checks.changeblock = uint256(uint32(data));\\n        checks.limitsblock = uint256(uint32(data >> 32));\\n        checks.standardmode = uint256(uint8(data >> 64));\\n        checks.feesenabled = uint256(uint8(data >> 72));\\n        checks.cooldown = uint256(uint8(data >> 80));\\n        checks.eoatransfers = uint256(uint8(data >> 88));\\n        fees.feebuy = uint256(uint8(data >> 96));\\n        fees.feesell = uint256(uint8(data >> 104));\\n        fees.feeliq = uint256(uint8(data >> 112));\\n        max.maxtx = uint256(uint16(data >> 120));\\n        max.maxbal = uint256(uint24(data >> 136));\\n        currentUserIndex = uint256(uint24(data >> 160));\\n        currentEntryIndex = uint256(uint24(data >> 184));\\n    }\\n\\n    function _getUserData(uint256 user) private pure returns (USER memory user_) {\\n        user_.buy = uint256(uint32(user));\\n        user_.exemptfee = uint256(uint8(user >> 32));\\n        user_.exemptlimit = uint256(uint8(user >> 40));\\n        user_.index = uint256(uint24(user >> 48));\\n    }\\n\\n    function _getChecksData(uint256 data) private pure returns (CHECKS memory checks) {\\n        checks.changeblock = uint256(uint32(data));\\n        checks.limitsblock = uint256(uint32(data >> 32));\\n        checks.standardmode = uint256(uint8(data >> 64));\\n        checks.feesenabled = uint256(uint8(data >> 72));\\n        checks.cooldown = uint256(uint8(data >> 80));\\n        checks.eoatransfers = uint256(uint8(data >> 88));\\n    }\\n\\n    function _getFeesData(uint256 data) private pure returns (FEES memory fees) {\\n        fees.feebuy = uint256(uint8(data >> 96));\\n        fees.feesell = uint256(uint8(data >> 104));\\n        fees.feeliq = uint256(uint8(data >> 112));\\n    }\\n\\n    function _getMaxData(uint256 data) private pure returns (MAX memory max) {\\n        max.maxtx = uint256(uint16(data >> 120));\\n        max.maxbal = uint256(uint24(data >> 136));\\n    }\\n\\n    function _getCurrentUserIndex(uint256 data) private pure returns (uint256) {\\n        return uint256(uint24(data >> 160));\\n    }\\n\\n    function _getCurrentEntryIndex(uint256 data) private pure returns (uint256) {\\n        return uint256(uint24(data >> 184));\\n    }\\n\\n    function _overflowCheck(uint256 value, uint256 bytecount) private pure {\\n        //checks if value fits in target uint type\\n\\n        if (value >= uint256(1 << bytecount)) {\\n            revert castOverflow(uint256(value), uint256(bytecount));\\n        }\\n    }\\n\\n    function _hasCode(address _address) private view returns (bool) {\\n        return _address.code.length != 0;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EXTERNAL VIEW\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function getUserData(address user) external view returns (USER memory user_) {\\n        return _getUserData(_users[user]);\\n    }\\n\\n    function getUserEntryCount(address sender) external view returns (uint256) {\\n        return _getUserEntryCount(sender);\\n    }\\n\\n    function getAllUserEntries(address user) external view returns (uint24[] memory) {\\n        uint256 bitObj = _userEntries[user];\\n        uint24[] memory entries = new uint24[](10);\\n        for (uint256 i; i < 10;) {\\n            uint256 bitPosition = i * 24;\\n            entries[i] = uint24(bitObj >> bitPosition);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return entries;\\n    }\\n\\n    function getAllData()\\n        external\\n        view\\n        returns (\\n            CHECKS memory checks,\\n            FEES memory fees,\\n            MAX memory max,\\n            uint256 currentUserIndex,\\n            uint256 currentEntryIndex\\n        )\\n    {\\n        return _getAllData(data_);\\n    }\\n\\n    function getEntryMinimums() external pure returns (uint256[] memory) {\\n        uint256[] memory entries = new uint256[](7);\\n        entries[0] = ONE_ENTRY;\\n        entries[1] = TWO_ENTRIES;\\n        entries[2] = THREE_ENTRIES;\\n        entries[3] = FOUR_ENTRIES;\\n        entries[4] = FIVE_ENTRIES;\\n        entries[5] = SEVEN_ENTRIES;\\n        entries[6] = TEN_ENTRIES;\\n        return entries;\\n    }\\n\\n    function getWETH() external view returns (address) {\\n        return WETH;\\n    }\\n\\n    function getPair() external view returns (address) {\\n        return _pair;\\n    }\\n\\n    function getIndexUser(uint256 index) external view returns (address) {\\n        return _indexUser[index];\\n    }\\n\\n    function getEntrantIdAndAddressAtIndex(uint256 index) external view returns (uint24, address) {\\n        return _getEntrantIdAndAddressAtIndex(index);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EXTERNAL WRITE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function deploy(uint48 duration) public payable onlyOwner {\\n        // can only be deployed once\\n        if (_pair != address(0)) {\\n            revert alreadyOpen();\\n        }\\n\\n        // close limit must exceed one hour\\n        if (duration <= 300) {\\n            // (60 minutes * 60 seconds) / 12 seconds per block = 300\\n            revert valueTooLow();\\n        }\\n\\n        _approve(address(this), address(ROUTER), type(uint256).max);\\n        ROUTER.addLiquidityETH{value: address(this).balance}(\\n            address(this), balanceOf(address(this)) - 1, 0, 0, address(this), block.timestamp\\n        );\\n        address factory = ROUTER.factory();\\n        address pair = IUniswapV2Factory(factory).getPair(WETH, address(this));\\n        _setUserData(pair, 0, 1, 0, 0);\\n        _pair = pair;\\n        _closeLimitBlock = uint48(block.number + duration);\\n\\n        // userIndex must start at 1, as 0 needs to mean 'no user'\\n        // entryIndex must start at 1 for edge case in which first user adds to existing entries with multiple buys\\n        uint256[13] memory data = [\\n            block.number, // launch block\\n            block.number + 50, // limits window ((~12-second block time * 50) / 60 seconds) = ~10 minutes\\n            0, // standard mode\\n            1, // fees enabled\\n            3, // min blocks for cooldown\\n            1, // allow EOA to EOA transfers\\n            4, // buy fee\\n            4, // sell fee\\n            1, // liq fee\\n            6_000, // max tx - (fee + liq fee + amount for ten entries) * 1.2 (120%) to try and account for price action\\n            10_000, // max balance\\n            1, // userIndex\\n            1 // entryIndex\\n        ];\\n        _setData(data);\\n    }\\n\\n    /**\\n     * @dev\\n     * closes trading by setting launch block to 0, performs a final price-impact-limited contract swap,\\n     * and requests a random number from chainlink VRF\\n     * this can only be done if trading is open, if it has not already been successfully run, and the specified time has passed (24 hours)\\n     */\\n    function closeTradingAndRollDice() external onlyOwner returns (uint256 requestId) {\\n        CHECKS memory checks = _getChecksData(data_);\\n        uint256 currentEntryIndex = _getCurrentEntryIndex(data_);\\n        if (\\n            checks.changeblock == 0 // not launched, or this has been run already\\n                || _closedAtTimestamp != 0 // this has been run already\\n                || block.number < uint256(_closeLimitBlock) // timeframe has not elapsed\\n                || currentEntryIndex == 1 // no entries have been registered yet\\n        ) {\\n            revert closeConditionsUnmet();\\n        }\\n\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n        // only attempt to sell an amount that uniswap shouldnt complain about (INSUFFICIENT_OUTPUT_AMOUNT)\\n        if (contractTokenBalance > ONE_ENTRY) {\\n            // perform final fee swap\\n            uint256 impactSell = (balanceOf(_pair) * 20) / 100;\\n            if (contractTokenBalance > impactSell) {\\n                contractTokenBalance = impactSell;\\n            }\\n            _nestedSwap(contractTokenBalance - 1);\\n        }\\n\\n        uint256 contractETHBalance = address(this).balance;\\n\\n        // don't require the fee transfer to succeed. dev can collect fees on their own later, if necessary\\n        if (contractETHBalance != 0) {\\n            (bool success,) = owner().call{value: address(this).balance}(\\\"\\\");\\n            success;\\n        }\\n\\n        // for display purposes\\n        _closedAtTimestamp = uint48(block.timestamp);\\n\\n        // reset changeblock to zero, halting trading\\n        _setChecksDataCloseTrading();\\n\\n        // exempt router from limits for the liquidity removal\\n        _setUserData(address(ROUTER), 0, 1, 1, 0);\\n        requestId = requestRandomness(uint32(_linkFee), uint16(3), uint32(1)); // actual gas cost is roughly 300_000\\n        _randomResult = uint128(ROLL_IN_PROGRESS);\\n        emit DiceRolled(requestId);\\n    }\\n\\n    /**\\n     * @dev\\n     * this function is external as a contingency for the possible scenario in which this function fails when executed in the VRF callback.\\n     * ideally, this is not needed, but better to be safe than sorry.\\n     * because this function is used internally, and we are using memory values in order to minimize gas, it must accept parameters.\\n     * if this function is called externally by owner,\\n     * whatever parameters they provided are ignored, and correct ones are pulled from existing contract logic\\n     * this eliminates unnecessary work to retrieve correct values, and prevents exploitation by the owner\\n     * @param randomResult the random index set in fulfillRandomWords (pass 0 when calling as owner)\\n     * @param currentEntryIndex the final entry index assigned to a user before trading closed (pass 0 when calling as owner)\\n     */\\n    function sendToWinner(uint256 randomResult, uint256 currentEntryIndex) external {\\n        if (msg.sender != address(this) && msg.sender != address(_wrapper) && msg.sender != owner()) {\\n            revert notAuthorized();\\n        }\\n\\n        if (msg.sender == owner()) {\\n            // cannot be run if random result was not already requested and received\\n            if (_closedAtTimestamp == 0 || _randomResult == ROLL_IN_PROGRESS || _randomResult == 0) {\\n                revert vrfCallbackNotComplete();\\n            }\\n\\n            // when owner is the caller, ignore the values they passed and get the correct ones\\n            // this prevents exploitation by owner to assign winner to whomever they want\\n\\n            // if owner can successfully call this function, we have already received a random number and set the random winner index\\n            randomResult = _randomResult;\\n            currentEntryIndex = _getCurrentEntryIndex(data_);\\n            unchecked {\\n                --currentEntryIndex; // last entry index assigned is one less than current value of currentEntryIndex\\n            }\\n        }\\n\\n        // run the actual winner selection and payout logic\\n        _sendToWinner(randomResult, currentEntryIndex);\\n    }\\n\\n    function setUserExempt(address userAddress, bool exemptfee, bool exemptlimit) external onlyOwner {\\n        // cannot alter significant contracts externally\\n        if (userAddress == _pair || userAddress == address(ROUTER) || userAddress == address(this)) {\\n            revert notAuthorized();\\n        }\\n        _setUserExempt(userAddress, exemptfee, exemptlimit);\\n    }\\n\\n    function updateMax(uint256 maxTx, uint256 maxBalance) external onlyOwner {\\n        MAX memory currentMax = _getMaxData(data_);\\n        CHECKS memory currentChecks = _getChecksData(data_);\\n\\n        if (currentChecks.changeblock != 0) {\\n            // neither value can be reduced\\n            if (maxTx < currentMax.maxtx || maxBalance < currentMax.maxbal) {\\n                revert valueTooLow();\\n            }\\n        }\\n\\n        _setMaxData(maxTx, maxBalance);\\n        emit MaxUpdated(maxTx, maxBalance);\\n    }\\n\\n    function updateFees(uint256 buy, uint256 sell, uint256 liq) external onlyOwner {\\n        if (((buy + liq) > 10) || ((sell + liq) > 10)) {\\n            revert valueTooHigh();\\n        }\\n        _setFeesData(buy, sell, liq);\\n        emit FeesUpdated(buy, sell, liq);\\n    }\\n\\n    function reduceLimitBlock(uint256 newBlock) external onlyOwner {\\n        // once this block has passed, max tx, max balance, and buy cooldown are ignored\\n        CHECKS memory checks = _getChecksData(data_);\\n        uint256 oldBlock = checks.limitsblock;\\n\\n        if (newBlock > oldBlock) {\\n            revert valueTooHigh();\\n        }\\n        _setChecksData(\\n            checks.changeblock, newBlock, checks.standardmode, checks.feesenabled, checks.cooldown, checks.eoatransfers\\n        );\\n        emit LimitBlockReduced(newBlock);\\n    }\\n\\n    function reduceCooldown(uint256 newCooldown) external onlyOwner {\\n        // the number of blocks that must pass before user can perform another tx\\n        CHECKS memory checks = _getChecksData(data_);\\n        uint256 oldCooldown = checks.cooldown;\\n\\n        if (newCooldown > oldCooldown) {\\n            revert valueTooHigh();\\n        }\\n        _setChecksData(\\n            checks.changeblock,\\n            checks.limitsblock,\\n            checks.standardmode,\\n            checks.feesenabled,\\n            newCooldown,\\n            checks.eoatransfers\\n        );\\n        emit CooldownReduced(newCooldown);\\n    }\\n\\n    function toggleStandardMode() external onlyOwner {\\n        // standard mode eliminates all custom transfer logic\\n        CHECKS memory checks = _getChecksData(data_);\\n\\n        uint256 standardmode = checks.standardmode != 0 ? 0 : uint256(1);\\n        require(standardmode != uint256(checks.standardmode), \\\"same value\\\");\\n        _setChecksData(\\n            checks.changeblock,\\n            checks.limitsblock,\\n            standardmode,\\n            checks.feesenabled,\\n            checks.cooldown,\\n            checks.eoatransfers\\n        );\\n\\n        if (standardmode != 0) {\\n            emit StandardModeToggled(true);\\n        } else {\\n            emit StandardModeToggled(false);\\n        }\\n    }\\n\\n    function toggleFees() external onlyOwner {\\n        CHECKS memory checks = _getChecksData(data_);\\n\\n        uint256 feesenabled = checks.feesenabled != 0 ? 0 : uint256(1);\\n        require(feesenabled != uint256(checks.feesenabled), \\\"same value\\\");\\n        _setChecksData(\\n            checks.changeblock,\\n            checks.limitsblock,\\n            checks.standardmode,\\n            feesenabled,\\n            checks.cooldown,\\n            checks.eoatransfers\\n        );\\n\\n        if (feesenabled != 0) {\\n            emit FeesToggled(true);\\n        } else {\\n            emit FeesToggled(false);\\n        }\\n    }\\n\\n    function toggleEOATransfers() external onlyOwner {\\n        // enable or disable transferring tokens between user-owned wallets\\n        // NOTE: this has no effect on buying or selling\\n        CHECKS memory checks = _getChecksData(data_);\\n\\n        uint256 eoatransfers = checks.eoatransfers != 0 ? 0 : uint256(1);\\n        require(eoatransfers != uint256(checks.eoatransfers), \\\"same value\\\");\\n        _setChecksData(\\n            checks.changeblock,\\n            checks.limitsblock,\\n            checks.standardmode,\\n            checks.feesenabled,\\n            checks.cooldown,\\n            eoatransfers\\n        );\\n\\n        if (eoatransfers != 0) {\\n            emit EOATransfersToggled(true);\\n        } else {\\n            emit EOATransfersToggled(false);\\n        }\\n    }\\n\\n    function manualDistribute(address recipient, uint256 amount) external onlyOwner {\\n        if (recipient == address(0)) {\\n            revert sendToZero();\\n        }\\n        bool sent;\\n        // send entire ETH balance\\n        if (amount == 0) {\\n            (sent,) = recipient.call{value: address(this).balance}(\\\"\\\");\\n            if (!sent) {\\n                revert failedToSendETH();\\n            }\\n        }\\n        require(_pair != recipient, \\\"Use addToPair instead.\\\");\\n        uint256 amountInFinney = amount * 1e15;\\n        (sent,) = recipient.call{value: (amountInFinney)}(\\\"\\\"); // sending 1 ETH = '1000', .1 ETH = '100', .01 ETH = '10'\\n        if (!sent) {\\n            revert failedToSendETH();\\n        }\\n    }\\n\\n    function addToPair(uint256 amount) external onlyOwner {\\n        if (_pair == address(0)) {\\n            revert notOpen();\\n        }\\n        uint256 amountInFinney = amount * 1e15;\\n        IWETH(WETH).deposit{value: amountInFinney}(); // sending 1 ETH = '1000', .1 ETH = '100', .01 ETH = '10'\\n        bool sent = IWETH(WETH).transfer(_pair, IWETH(WETH).balanceOf(address(this)));\\n        if (!sent) {\\n            revert failedToSendETH();\\n        }\\n        IUniswapV2Pair(_pair).sync();\\n        emit LiqBoosted(WETH, amountInFinney);\\n    }\\n\\n    /**\\n     * @dev\\n     * This value is used by Chainlink to determine how much gas the callback function is allowed to consume.\\n     * it has no effect on users or swaps.\\n     */\\n    function updateLinkFee(uint256 newValue) external onlyOwner {\\n        // this function is only needed in case the dev needs to increase the gas cost of the callback function\\n        if (newValue < _linkFee) {\\n            revert valueTooLow();\\n        }\\n        _linkFee = uint32(newValue);\\n        emit LinkFeeUpdated(newValue);\\n    }\\n\\n    function recoverLink() external onlyOwner {\\n        // can only reclaim unused LINK after winner has received payout\\n        require(_winner != address(0));\\n        LINK.transfer(owner(), LINK.balanceOf(address(this)));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/chainlink/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"../interfaces/VRFV2WrapperInterface.sol\\\";\\n\\n/** *******************************************************************************\\n * @notice Interface for contracts using VRF randomness through the VRF V2 wrapper\\n * ********************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Create VRF V2 requests without the need for subscription management. Rather than creating\\n * @dev and funding a VRF V2 subscription, a user can use this wrapper to create one off requests,\\n * @dev paying up front rather than at fulfillment.\\n *\\n * @dev Since the price is determined using the gas price of the request transaction rather than\\n * @dev the fulfillment transaction, the wrapper charges an additional premium on callback gas\\n * @dev usage, in addition to some extra overhead costs associated with the VRFV2Wrapper contract.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFV2WrapperConsumerBase. The consumer must be funded\\n * @dev with enough LINK to make the request, otherwise requests will revert. To request randomness,\\n * @dev call the 'requestRandomness' function with the desired VRF parameters. This function handles\\n * @dev paying for the request based on the current pricing.\\n *\\n * @dev Consumers must implement the fullfillRandomWords function, which will be called during\\n * @dev fulfillment with the randomness result.\\n */\\nabstract contract VRFV2WrapperConsumerBase {\\n  LinkTokenInterface internal immutable LINK;\\n  VRFV2WrapperInterface internal immutable VRF_V2_WRAPPER;\\n\\n  /**\\n   * @param _link is the address of LinkToken\\n   * @param _vrfV2Wrapper is the address of the VRFV2Wrapper contract\\n   */\\n  constructor(address _link, address _vrfV2Wrapper) {\\n    LINK = LinkTokenInterface(_link);\\n    VRF_V2_WRAPPER = VRFV2WrapperInterface(_vrfV2Wrapper);\\n  }\\n\\n  /**\\n   * @dev Requests randomness from the VRF V2 wrapper.\\n   *\\n   * @param _callbackGasLimit is the gas limit that should be used when calling the consumer's\\n   *        fulfillRandomWords function.\\n   * @param _requestConfirmations is the number of confirmations to wait before fulfilling the\\n   *        request. A higher number of confirmations increases security by reducing the likelihood\\n   *        that a chain re-org changes a published randomness outcome.\\n   * @param _numWords is the number of random words to request.\\n   *\\n   * @return requestId is the VRF V2 request ID of the newly created randomness request.\\n   */\\n  function requestRandomness(\\n    uint32 _callbackGasLimit,\\n    uint16 _requestConfirmations,\\n    uint32 _numWords\\n  ) internal returns (uint256 requestId) {\\n    LINK.transferAndCall(\\n      address(VRF_V2_WRAPPER),\\n      VRF_V2_WRAPPER.calculateRequestPrice(_callbackGasLimit),\\n      abi.encode(_callbackGasLimit, _requestConfirmations, _numWords)\\n    );\\n    return VRF_V2_WRAPPER.lastRequestId();\\n  }\\n\\n  /**\\n   * @notice fulfillRandomWords handles the VRF V2 wrapper response. The consuming contract must\\n   * @notice implement it.\\n   *\\n   * @param _requestId is the VRF V2 request ID.\\n   * @param _randomWords is the randomness result.\\n   */\\n  function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal virtual;\\n\\n  function rawFulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) external {\\n    require(msg.sender == address(VRF_V2_WRAPPER), \\\"only VRF V2 wrapper can fulfill\\\");\\n    fulfillRandomWords(_requestId, _randomWords);\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"lib/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface LinkTokenInterface {\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n  function approve(address spender, uint256 value) external returns (bool success);\\n\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  function decimals() external view returns (uint8 decimalPlaces);\\n\\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\n\\n  function increaseApproval(address spender, uint256 subtractedValue) external;\\n\\n  function name() external view returns (string memory tokenName);\\n\\n  function symbol() external view returns (string memory tokenSymbol);\\n\\n  function totalSupply() external view returns (uint256 totalTokensIssued);\\n\\n  function transfer(address to, uint256 value) external returns (bool success);\\n\\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\\n\\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"lib/chainlink/contracts/src/v0.8/interfaces/VRFV2WrapperInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFV2WrapperInterface {\\n  /**\\n   * @return the request ID of the most recent VRF V2 request made by this wrapper. This should only\\n   * be relied option within the same transaction that the request was made.\\n   */\\n  function lastRequestId() external view returns (uint256);\\n\\n  /**\\n   * @notice Calculates the price of a VRF request with the given callbackGasLimit at the current\\n   * @notice block.\\n   *\\n   * @dev This function relies on the transaction gas price which is not automatically set during\\n   * @dev simulation. To estimate the price at a specific gas price, use the estimatePrice function.\\n   *\\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\\n   */\\n  function calculateRequestPrice(uint32 _callbackGasLimit) external view returns (uint256);\\n\\n  /**\\n   * @notice Estimates the price of a VRF request with a specific gas limit and gas price.\\n   *\\n   * @dev This is a convenience function that can be called in simulation to better understand\\n   * @dev pricing.\\n   *\\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\\n   * @param _requestGasPriceWei is the gas price in wei used for the estimation.\\n   */\\n  function estimateRequestPrice(uint32 _callbackGasLimit, uint256 _requestGasPriceWei) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@chainlink/=lib/chainlink/contracts/src/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"@permit2/=lib/permit2/src/\",\r\n      \"@solmate/=lib/solmate/src/\",\r\n      \"@uniswap-core-local/=lib/v2-core/local-contracts/\",\r\n      \"@uniswap-core/=lib/v2-core/contracts/\",\r\n      \"@uniswap-lib-local/=lib/solidity-lib/local-contracts/\",\r\n      \"@uniswap-periphery-local/=lib/v2-periphery/local-contracts/\",\r\n      \"@uniswap-periphery/=lib/v2-periphery/contracts/\",\r\n      \"chainlink/=lib/chainlink/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"permit2/=lib/permit2/\",\r\n      \"solidity-lib/=lib/solidity-lib/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"sstore2/=lib/sstore2/contracts/\",\r\n      \"v2-core/=lib/v2-core/\",\r\n      \"v2-periphery/=lib/v2-periphery/\",\r\n      \"lib/forge-std:ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/openzeppelin-contracts:ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/openzeppelin-contracts:erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"lib/openzeppelin-contracts:forge-std/=lib/openzeppelin-contracts/lib/forge-std/src/\",\r\n      \"lib/openzeppelin-contracts:openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"lib/permit2:ds-test/=lib/permit2/lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/permit2:forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/\",\r\n      \"lib/permit2:forge-std/=lib/permit2/lib/forge-std/src/\",\r\n      \"lib/permit2:openzeppelin-contracts/=lib/permit2/lib/openzeppelin-contracts/\",\r\n      \"lib/permit2:solmate/=lib/permit2/lib/solmate/\",\r\n      \"lib/solmate:ds-test/=lib/solmate/lib/ds-test/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"linkAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wrapperAddress\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"alreadyOpen\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"belowMinBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bytecount\",\"type\":\"uint256\"}],\"name\":\"castOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"closeConditionsUnmet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"exceedMaxBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"exceedMaxTx\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"failedToSendETH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"noEOAtoEOATransfers\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"notAuthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"notOpen\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"sendToZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"txCooldown\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"valueTooHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"valueTooLow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"vrfCallbackNotComplete\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newcooldown\",\"type\":\"uint256\"}],\"name\":\"CooldownReduced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"name\":\"DiceLanded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"DiceRolled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"eoatransfers\",\"type\":\"bool\"}],\"name\":\"EOATransfersToggled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EntriesGained\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EntriesLost\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"feesenabled\",\"type\":\"bool\"}],\"name\":\"FeesToggled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liq\",\"type\":\"uint256\"}],\"name\":\"FeesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newblock\",\"type\":\"uint256\"}],\"name\":\"LimitBlockReduced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newfee\",\"type\":\"uint256\"}],\"name\":\"LinkFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LiqBoosted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxtx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxbal\",\"type\":\"uint256\"}],\"name\":\"MaxUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"SentToWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"standardmode\",\"type\":\"bool\"}],\"name\":\"StandardModeToggled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ROUTER\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_closeLimitBlock\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_closedAtTimestamp\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_linkFee\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pureRandomNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_randomResult\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_winner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addToPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeTradingAndRollDice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint48\",\"name\":\"duration\",\"type\":\"uint48\"}],\"name\":\"deploy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"changeblock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitsblock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"standardmode\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feesenabled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldown\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eoatransfers\",\"type\":\"uint256\"}],\"internalType\":\"struct IGMI.CHECKS\",\"name\":\"checks\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"feebuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feesell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeliq\",\"type\":\"uint256\"}],\"internalType\":\"struct IGMI.FEES\",\"name\":\"fees\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"maxtx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxbal\",\"type\":\"uint256\"}],\"internalType\":\"struct IGMI.MAX\",\"name\":\"max\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"currentUserIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentEntryIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAllUserEntries\",\"outputs\":[{\"internalType\":\"uint24[]\",\"name\":\"\",\"type\":\"uint24[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getEntrantIdAndAddressAtIndex\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEntryMinimums\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getIndexUser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exemptfee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exemptlimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"internalType\":\"struct IGMI.USER\",\"name\":\"user_\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"getUserEntryCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"manualDistribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverLink\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCooldown\",\"type\":\"uint256\"}],\"name\":\"reduceCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBlock\",\"type\":\"uint256\"}],\"name\":\"reduceLimitBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"randomResult\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentEntryIndex\",\"type\":\"uint256\"}],\"name\":\"sendToWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exemptfee\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"exemptlimit\",\"type\":\"bool\"}],\"name\":\"setUserExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleEOATransfers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleStandardMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liq\",\"type\":\"uint256\"}],\"name\":\"updateFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"updateLinkFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBalance\",\"type\":\"uint256\"}],\"name\":\"updateMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "IGMI", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca0000000000000000000000005a861794b927983406fce1d062e00b9368d97df6", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}