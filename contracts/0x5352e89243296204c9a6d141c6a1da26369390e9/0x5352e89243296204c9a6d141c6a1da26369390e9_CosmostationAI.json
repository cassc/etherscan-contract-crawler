{"SourceCode": "/**\r\nWebsite     : https://cosmostationai.com/\r\nTelegram    : https://t.me/CosmostationAI\r\nTwitter     : https://x.com/CosmostationAI\r\n/*\r\n\r\n*/\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.18;\r\n\r\n\r\ninterface IERC20 {\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    \r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n    \r\n}\r\n\r\n\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; \r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\nlibrary Address {\r\n    \r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    \r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    \r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    \r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n    \r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    \r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n    \r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n    \r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                 assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n\r\n    // Set original owner\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor () {\r\n        _owner = 0x4BcCeed8f03cDd09E35A5C9e8b18ef083d1A95a8;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    // Return current owner\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    // Restrict function to contract owner only \r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    // Renounce ownership of the contract \r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    // Transfer the contract to to a new owner\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n\r\ncontract CosmostationAI is Context, IERC20, Ownable { \r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n\r\n    // Tracking status of wallets\r\n    mapping (address => uint256) private _tOwned;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    mapping (address => bool) public _isExcludedFromFee; \r\n\r\n\r\n    address payable public contract_creators = payable(0xF9d3d5Fe35B8d849aD9BC1B9aE5209202d676CFA);\r\n    address payable public Wallet_Burn = payable(0x000000000000000000000000000000000000dEaD); \r\n    address payable public Wallet_zero = payable(0x0000000000000000000000000000000000000000); \r\n\r\n\r\n    string private _name = \"Cosmostation AI\"; \r\n    string private _symbol = \"CAI\";  \r\n    uint8 private _decimals = 18;\r\n    uint256 private _tTotal = 50000000 * 10**18;\r\n    uint256 private _tFeeTotal;\r\n\r\n    // Counter for liquify trigger\r\n    uint8 private txCount = 0;\r\n    uint8 private swapTrigger = 3; \r\n\r\n\r\n    uint256 private maxPossibleFee = 90; \r\n\r\n\r\n    // Setting the initial fees\r\n    uint256 private _TotalFee = 80;\r\n    uint256 public _buyFee = 40;\r\n    uint256 public _sellFee = 40;\r\n\r\n\r\n    // 'Previous fees' are used to keep track of fee settings when removing and restoring fees\r\n    uint256 private _previousTotalFee = _TotalFee; \r\n    uint256 private _previousBuyFee = _buyFee; \r\n    uint256 private _previousSellFee = _sellFee; \r\n\r\n\r\n    // Max wallet holding (2% at launch)\r\n    uint256 public _maxWalletToken = _tTotal.mul(2).div(100);\r\n    uint256 private _previousMaxWalletToken = _maxWalletToken;\r\n\r\n\r\n    // Maximum transaction amount (2% at launch)\r\n    uint256 public _maxTxAmount = _tTotal.mul(2).div(100); \r\n    uint256 private _previousMaxTxAmount = _maxTxAmount;\r\n\r\n\r\n    IUniswapV2Router02 public uniswapV2Router;\r\n    address public uniswapV2Pair;\r\n    bool public inSwapAndLiquify;\r\n    bool public swapAndLiquifyEnabled = true;\r\n    \r\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\r\n    event SwapAndLiquify(\r\n        uint256 tokensSwapped,\r\n        uint256 ethReceived,\r\n        uint256 tokensIntoLiqudity\r\n        \r\n    );\r\n    \r\n    // Prevent processing while already processing! \r\n    modifier lockTheSwap {\r\n        inSwapAndLiquify = true;\r\n        _;\r\n        inSwapAndLiquify = false;\r\n    }\r\n\r\n      \r\n    constructor () {\r\n        _tOwned[owner()] = _tTotal;\r\n        \r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); \r\n        \r\n        \r\n        // Create pair address for PancakeSwap\r\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\r\n            .createPair(address(this), _uniswapV2Router.WETH());\r\n        uniswapV2Router = _uniswapV2Router;\r\n        _isExcludedFromFee[owner()] = true;\r\n        _isExcludedFromFee[address(this)] = true;\r\n        _isExcludedFromFee[contract_creators] = true;\r\n        \r\n        emit Transfer(address(0), owner(), _tTotal);\r\n    }\r\n\r\n\r\n \r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _tTotal;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _tOwned[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n\r\n \r\n    // Set a wallet address so that it does not have to pay transaction fees\r\n    function excludeFromFee(address account) public onlyOwner {\r\n        _isExcludedFromFee[account] = true;\r\n    }\r\n    \r\n    // Set a wallet address so that it has to pay transaction fees\r\n    function includeInFee(address account) public onlyOwner {\r\n        _isExcludedFromFee[account] = false;\r\n    }\r\n\r\n\r\n\r\n\r\n    function setFeesTax_CAI (uint256 Buy_Fee, uint256 Sell_Fee) external onlyOwner() {\r\n\r\n        require((Buy_Fee + Sell_Fee) <= maxPossibleFee, \"Fee is too high!\");\r\n        _sellFee = Sell_Fee;\r\n        _buyFee = Buy_Fee;\r\n\r\n    }\r\n\r\n\r\n\r\n    // Update main wallet\r\n    function ChangeWalletFee(address payable wallet) public onlyOwner() {\r\n        contract_creators = wallet;\r\n        _isExcludedFromFee[contract_creators] = true;\r\n    }\r\n\r\n\r\n    \r\n    // Toggle on and off to auto process tokens to ETH wallet \r\n    function SetSwapEnabled(bool true_or_false) public onlyOwner {\r\n        swapAndLiquifyEnabled = true_or_false;\r\n        emit SwapAndLiquifyEnabledUpdated(true_or_false);\r\n    }\r\n\r\n    // This will set the number of transactions required before the 'swapAndLiquify' function triggers\r\n    function SetNumberOfTransactions(uint8 number_of_transactions) public onlyOwner {\r\n        swapTrigger = number_of_transactions;\r\n    }\r\n    \r\n\r\n\r\n    // This function is required so that the contract can receive ETH from pancakeswap\r\n    receive() external payable {}\r\n\r\n    bool public noFeeToTransfer = true;\r\n\r\n    function SetTransfersExceptFees(bool true_or_false) external onlyOwner {\r\n        noFeeToTransfer = true_or_false;\r\n    }\r\n\r\n    \r\n\r\n    // Set the Max transaction amount (percent of total supply)\r\n    function SetMaxTransaction_CAI(uint256 maxTxPercent_x100) external onlyOwner() {\r\n        _maxTxAmount = _tTotal*maxTxPercent_x100/10000;\r\n    }    \r\n    \r\n    // Set the maximum wallet holding (percent of total supply)\r\n     function SetMaxWallet_CAI(uint256 maxWallPercent_x100) external onlyOwner() {\r\n        _maxWalletToken = _tTotal*maxWallPercent_x100/10000;\r\n    }\r\n\r\n\r\n\r\n    // Remove all fees\r\n    function removeAllFee() private {\r\n        if(_TotalFee == 0 && _buyFee == 0 && _sellFee == 0) return;\r\n\r\n\r\n        _previousBuyFee = _buyFee; \r\n        _previousSellFee = _sellFee; \r\n        _previousTotalFee = _TotalFee;\r\n        _buyFee = 0;\r\n        _sellFee = 0;\r\n        _TotalFee = 0;\r\n\r\n    }\r\n    \r\n    // Restore all fees\r\n    function restoreAllFee() private {\r\n    \r\n    _TotalFee = _previousTotalFee;\r\n    _buyFee = _previousBuyFee; \r\n    _sellFee = _previousSellFee; \r\n\r\n    }\r\n\r\n\r\n    // Approve a wallet to sell tokens\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n\r\n        require(owner != address(0) && spender != address(0), \"ERR: zero address\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) private {\r\n        \r\n\r\n        // Limit wallet total\r\n        if (to != owner() &&\r\n            to != contract_creators &&\r\n            to != address(this) &&\r\n            to != uniswapV2Pair &&\r\n            to != Wallet_Burn &&\r\n            from != owner()){\r\n            uint256 heldTokens = balanceOf(to);\r\n            require((heldTokens + amount) <= _maxWalletToken,\"You are trying to buy too many tokens. You have reached the limit for one wallet.\");}\r\n\r\n\r\n        // Limit the maximum number of tokens that can be bought or sold in one transaction\r\n        if (from != owner() && to != owner())\r\n            require(amount <= _maxTxAmount, \"You are trying to buy more than the max transaction limit.\");\r\n\r\n\r\n\r\n\r\n        // SwapAndLiquify is triggered after every X transactions - this number can be adjusted using swapTrigger\r\n\r\n        if(\r\n            txCount >= swapTrigger && \r\n            !inSwapAndLiquify &&\r\n            from != uniswapV2Pair &&\r\n            swapAndLiquifyEnabled \r\n            )\r\n        {  \r\n            \r\n            txCount = 0;\r\n            uint256 contractTokenBalance = balanceOf(address(this));\r\n            if(contractTokenBalance > _maxTxAmount) {contractTokenBalance = _maxTxAmount;}\r\n            if(contractTokenBalance > 0){\r\n            swapAndLiquify(contractTokenBalance);\r\n        }\r\n        }\r\n\r\n\r\n      \r\n\r\n        \r\n        bool takeFee = true;\r\n         \r\n        if(_isExcludedFromFee[from] || _isExcludedFromFee[to] || (noFeeToTransfer && from != uniswapV2Pair && to != uniswapV2Pair)){\r\n            takeFee = false;\r\n        } else if (from == uniswapV2Pair){_TotalFee = _buyFee;} else if (to == uniswapV2Pair){_TotalFee = _sellFee;}\r\n        \r\n        _tokenTransfer(from,to,amount,takeFee);\r\n    }\r\n\r\n\r\n\r\n    // Send ETH to external wallet\r\n    function sendToWallet(address payable wallet, uint256 amount) private {\r\n            wallet.transfer(amount);\r\n        }\r\n\r\n\r\n    // Processing tokens from contract\r\n    function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {\r\n        \r\n        swapTokensForBNB(contractTokenBalance);\r\n        uint256 contractBNB = address(this).balance;\r\n        sendToWallet(contract_creators,contractBNB);\r\n    }\r\n\r\n\r\n    // Manual Token Process Trigger - Enter the percent of the tokens that you'd like to send to process\r\n    function TokenProcessTrigger (uint256 percent_Of_Tokens_To_Process) public onlyOwner {\r\n        // Do not trigger if already in swap\r\n        require(!inSwapAndLiquify, \"Currently processing, try later.\"); \r\n        if (percent_Of_Tokens_To_Process > 100){percent_Of_Tokens_To_Process == 100;}\r\n        uint256 tokensOnContract = balanceOf(address(this));\r\n        uint256 sendTokens = tokensOnContract*percent_Of_Tokens_To_Process/100;\r\n        swapAndLiquify(sendTokens);\r\n    }\r\n\r\n\r\n    // Swapping tokens for ETH using Uniswap \r\n    function swapTokensForBNB(uint256 tokenAmount) private {\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, \r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n\r\n    // Remove random tokens from the contract and send to a wallet\r\n    function RemoveTokens(address random_Token_Address, address send_to_wallet, uint256 number_of_tokens) public onlyOwner returns(bool _sent){\r\n        require(random_Token_Address != address(this), \"Can not remove native token\");\r\n        uint256 randomBalance = IERC20(random_Token_Address).balanceOf(address(this));\r\n        if (number_of_tokens > randomBalance){number_of_tokens = randomBalance;}\r\n        _sent = IERC20(random_Token_Address).transfer(send_to_wallet, number_of_tokens);\r\n    }\r\n\r\n\r\n\r\n    // Set new router and make the new pair address\r\n    function SetNewRouterAndMakePair_CAI(address newRouter) public onlyOwner() {\r\n        IUniswapV2Router02 _newPCSRouter = IUniswapV2Router02(newRouter);\r\n        uniswapV2Pair = IUniswapV2Factory(_newPCSRouter.factory()).createPair(address(this), _newPCSRouter.WETH());\r\n        uniswapV2Router = _newPCSRouter;\r\n    }\r\n   \r\n    // Set new router\r\n    function setNewRouterAddress_CAI(address newRouter) public onlyOwner() {\r\n        IUniswapV2Router02 _newPCSRouter = IUniswapV2Router02(newRouter);\r\n        uniswapV2Router = _newPCSRouter;\r\n    }\r\n    \r\n    // Set new address - This will be the 'Cake LP' address for the token pairing\r\n    function SetNewPairAddress_CAI(address newPair) public onlyOwner() {\r\n        uniswapV2Pair = newPair;\r\n    }\r\n\r\n    // Check if token transfer needs to process fees\r\n    function _tokenTransfer(address sender, address recipient, uint256 amount,bool takeFee) private {\r\n        \r\n        \r\n        if(!takeFee){\r\n            removeAllFee();\r\n            } else {\r\n                txCount++;\r\n            }\r\n            _transferTokens(sender, recipient, amount);\r\n        \r\n        if(!takeFee)\r\n            restoreAllFee();\r\n    }\r\n\r\n    // Redistributing tokens and adding the fee to the contract address\r\n    function _transferTokens(address sender, address recipient, uint256 tAmount) private {\r\n        (uint256 tTransferAmount, uint256 tDev) = _getValues(tAmount);\r\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\r\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\r\n        _tOwned[address(this)] = _tOwned[address(this)].add(tDev);   \r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n\r\n    // Calculating the fee in tokens\r\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256) {\r\n        uint256 tDev = tAmount*_TotalFee/100;\r\n        uint256 tTransferAmount = tAmount.sub(tDev);\r\n        return (tTransferAmount, tDev);\r\n    }\r\n\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapAndLiquifyEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"ChangeWalletFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"random_Token_Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"send_to_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"number_of_tokens\",\"type\":\"uint256\"}],\"name\":\"RemoveTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_sent\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTxPercent_x100\",\"type\":\"uint256\"}],\"name\":\"SetMaxTransaction_CAI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxWallPercent_x100\",\"type\":\"uint256\"}],\"name\":\"SetMaxWallet_CAI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPair\",\"type\":\"address\"}],\"name\":\"SetNewPairAddress_CAI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"SetNewRouterAndMakePair_CAI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"number_of_transactions\",\"type\":\"uint8\"}],\"name\":\"SetNumberOfTransactions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"SetSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"SetTransfersExceptFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent_Of_Tokens_To_Process\",\"type\":\"uint256\"}],\"name\":\"TokenProcessTrigger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Wallet_Burn\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Wallet_zero\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contract_creators\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inSwapAndLiquify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"noFeeToTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Buy_Fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Sell_Fee\",\"type\":\"uint256\"}],\"name\":\"setFeesTax_CAI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"setNewRouterAddress_CAI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CosmostationAI", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a39e47a5198930c79ca605adb2a5e377379cca60e13ceaf4cc76bbf41a915e3b"}