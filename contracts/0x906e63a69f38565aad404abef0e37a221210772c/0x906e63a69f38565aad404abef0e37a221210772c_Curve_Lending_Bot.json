{"SourceCode": "#pragma version 0.3.10\r\n#pragma optimize gas\r\n#pragma evm-version shanghai\r\n\"\"\"\r\n@title Curve Lending Bot\r\n@license Apache 2.0\r\n@author Volume.finance\r\n\"\"\"\r\nstruct FeeData:\r\n    refund_wallet: address\r\n    gas_fee: uint256\r\n    service_fee_collector: address\r\n    service_fee: uint256\r\n\r\nstruct SwapInfo:\r\n    route: address[9]\r\n    swap_params: uint256[3][4]\r\n    amount: uint256\r\n    pools: address[4]\r\n    expected: uint256\r\n\r\ninterface ControllerFactory:\r\n    def get_controller(collateral: address) -> address: view\r\n\r\ninterface Controller:\r\n    def create_loan(collateral: uint256, debt: uint256, N: uint256): payable\r\n    def add_collateral(collateral: uint256): payable\r\n    def remove_collateral(collateral: uint256): nonpayable\r\n    def borrow_more(collateral: uint256, debt: uint256): payable\r\n    def repay(_d_debt: uint256): nonpayable\r\n    def health(user: address) -> int256: view\r\n    def loan_exists(user: address) -> bool: view\r\n    def user_state(user: address) -> uint256[4]: view\r\n\r\ninterface ERC20:\r\n    def transferFrom(_from: address, _to: address, _value: uint256) -> bool: nonpayable\r\n    def transfer(_to: address, _value: uint256) -> bool: nonpayable\r\n    def decimals() -> uint256: view\r\n    def approve(_spender: address, _value: uint256) -> bool: nonpayable\r\n    def balanceOf(_from: address) -> uint256: view\r\n\r\ninterface WrappedEth:\r\n    def withdraw(amount: uint256): nonpayable\r\n\r\ninterface Factory:\r\n    def fee_data() -> FeeData: view\r\n    def create_loan_event(collateral: address, collateral_amount: uint256, lend_amount: uint256, debt: uint256, withdraw_amount: uint256, health_threshold: int256, expire: uint256, repayable: bool): nonpayable\r\n    def add_collateral_event(collateral: address, collateral_amount: uint256, lend_amount: uint256): nonpayable\r\n    def repay_event(collateral: address, input_amount: uint256, repay_amount: uint256): nonpayable\r\n    def remove_collateral_event(collateral: address, collateral_amount: uint256, withdraw_amount: uint256): nonpayable\r\n    def withdraw_event(collateral: address, withdraw_amount: uint256): nonpayable\r\n    def borrow_more_event(collateral: address, lend_amount: uint256, withdraw_amount: uint256): nonpayable\r\n    def bot_start_event(collateral: address, health_threshold: int256, expire: uint256, repayable: bool): nonpayable\r\n\r\ninterface CurveSwapRouter:\r\n    def exchange_multiple(\r\n        _route: address[9],\r\n        _swap_params: uint256[3][4],\r\n        _amount: uint256,\r\n        _expected: uint256,\r\n        _pools: address[4]=[ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS],\r\n        _receiver: address=msg.sender\r\n    ) -> uint256: payable\r\n\r\nDENOMINATOR: constant(uint256) = 10000\r\nMAX_SIZE: constant(uint256) = 8\r\nVETH: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\nFACTORY: immutable(address)\r\nCONTROLLER_FACTORY: immutable(address)\r\nOWNER: immutable(address)\r\nWETH: immutable(address)\r\ncrvUSD: immutable(address)\r\nROUTER: immutable(address)\r\n\r\n@external\r\ndef __init__(controller_factory: address, weth: address, crv_usd: address, owner: address, router: address):\r\n    FACTORY = msg.sender\r\n    CONTROLLER_FACTORY = controller_factory\r\n    WETH = weth\r\n    crvUSD = crv_usd\r\n    OWNER = owner\r\n    ROUTER = router\r\n\r\n@internal\r\ndef _safe_approve(_token: address, _to: address, _value: uint256):\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        _abi_encode(_to, _value, method_id=method_id(\"approve(address,uint256)\")),\r\n        max_outsize=32\r\n    )  # dev: failed approve\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool) # dev: failed approve\r\n\r\n@internal\r\ndef _safe_transfer(_token: address, _to: address, _value: uint256):\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        _abi_encode(_to, _value, method_id=method_id(\"transfer(address,uint256)\")),\r\n        max_outsize=32\r\n    )  # dev: failed approve\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool) # dev: failed approve\r\n\r\n@internal\r\ndef _safe_transfer_from(_token: address, _from: address, _to: address, _value: uint256):\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        _abi_encode(_from, _to, _value, method_id=method_id(\"transferFrom(address,address,uint256)\")),\r\n        max_outsize=32\r\n    )  # dev: failed transferFrom\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool) # dev: failed transferFrom\r\n\r\n@external\r\n@payable\r\n@nonreentrant('lock')\r\ndef create_loan(collateral: address, collateral_amount: uint256, lend_amount: uint256, debt: uint256, withdraw_amount: uint256, N: uint256, health_threshold: int256, expire: uint256, repayable: bool):\r\n    assert msg.sender == OWNER, \"Unauthorized\"\r\n    controller: address = ControllerFactory(CONTROLLER_FACTORY).get_controller(collateral)\r\n    fee_data: FeeData = Factory(FACTORY).fee_data()\r\n    fee_amount: uint256 = unsafe_div(collateral_amount * fee_data.service_fee, DENOMINATOR)\r\n    _lend_amount: uint256 = lend_amount\r\n    if _lend_amount > collateral_amount - fee_amount:\r\n        _lend_amount = unsafe_sub(collateral_amount, fee_amount)\r\n    if collateral == WETH:\r\n        assert msg.value >= collateral_amount, \"Insufficient ETH\"\r\n        if msg.value > collateral_amount:\r\n            send(OWNER, unsafe_sub(msg.value, collateral_amount))\r\n        if fee_amount > 0:\r\n            send(fee_data.service_fee_collector, fee_amount)\r\n        Controller(controller).create_loan(_lend_amount, debt, N, value=_lend_amount)\r\n    else:\r\n        self._safe_transfer_from(collateral, OWNER, self, collateral_amount)\r\n        if fee_amount > 0:\r\n            self._safe_transfer(collateral, fee_data.service_fee_collector, fee_amount)\r\n        self._safe_approve(collateral, controller, _lend_amount)\r\n        Controller(controller).create_loan(_lend_amount, debt, N)\r\n    if withdraw_amount > 0:\r\n        ERC20(crvUSD).transfer(OWNER, withdraw_amount)\r\n    Factory(FACTORY).create_loan_event(collateral, collateral_amount, lend_amount, debt, withdraw_amount, health_threshold, expire, repayable)\r\n\r\n@external\r\n@payable\r\n@nonreentrant('lock')\r\ndef add_collateral_with_swap(swap_infos: DynArray[SwapInfo, MAX_SIZE], lend_amount: uint256):\r\n    assert msg.sender == OWNER, \"Unauthorized\"\r\n    collateral_amount: uint256 = 0\r\n    for swap_info in swap_infos:\r\n        amount: uint256 = swap_info.amount\r\n        assert amount > 0, \"Insufficient deposit\"\r\n        if swap_info.route[0] == VETH:\r\n            assert msg.value >= amount, \"Insufficient deposit\"\r\n        else:\r\n            last_index: uint256 = 0\r\n            for i in range(4):\r\n                last_index = unsafe_sub(8, unsafe_add(i, i))\r\n                if swap_info.route[last_index] != empty(address):\r\n                    break\r\n                assert swap_info.route[last_index] == VETH, \"Wrong path\"\r\n            self._safe_approve(swap_info.route[0], ROUTER, amount)\r\n            amount = CurveSwapRouter(ROUTER).exchange_multiple(swap_info.route, swap_info.swap_params, amount, swap_info.expected, swap_info.pools, self)\r\n        collateral_amount += amount\r\n    assert collateral_amount > 0, \"Insufficient lend\"\r\n    controller: address = ControllerFactory(CONTROLLER_FACTORY).get_controller(WETH)\r\n    fee_data: FeeData = Factory(FACTORY).fee_data()\r\n    if fee_data.service_fee > 0:\r\n        service_fee_amount: uint256 = unsafe_div(collateral_amount * fee_data.service_fee, DENOMINATOR)\r\n        if service_fee_amount > 0:\r\n            send(fee_data.service_fee_collector, service_fee_amount)\r\n    if lend_amount > 0:\r\n        assert self.balance >= lend_amount, \"Insufficient balance\"\r\n    Controller(controller).add_collateral(lend_amount, value=lend_amount)\r\n    Factory(FACTORY).add_collateral_event(WETH, collateral_amount, lend_amount)\r\n\r\n@external\r\n@payable\r\n@nonreentrant('lock')\r\ndef add_collateral(collateral: address, collateral_amount: uint256, lend_amount: uint256):\r\n    assert msg.sender == OWNER or msg.sender == FACTORY, \"Unauthorized\"\r\n    controller: address = ControllerFactory(CONTROLLER_FACTORY).get_controller(collateral)\r\n    fee_data: FeeData = Factory(FACTORY).fee_data()\r\n    if collateral == WETH:\r\n        if collateral_amount > 0 and fee_data.service_fee > 0:\r\n            send(fee_data.service_fee_collector, unsafe_div(collateral_amount * fee_data.service_fee, DENOMINATOR))\r\n        if lend_amount > 0:\r\n            assert self.balance >= lend_amount, \"Insufficient balance\"\r\n            Controller(controller).add_collateral(lend_amount, value=lend_amount)\r\n    else:\r\n        if collateral_amount > 0:\r\n            self._safe_transfer_from(collateral, OWNER, self, collateral_amount)\r\n            if fee_data.service_fee > 0:\r\n                self._safe_transfer(collateral, fee_data.service_fee_collector, unsafe_div(collateral_amount * fee_data.service_fee, DENOMINATOR))\r\n        if lend_amount > 0:\r\n            assert ERC20(collateral).balanceOf(self) >= lend_amount, \"Insufficient balance\"\r\n            self._safe_approve(collateral, controller, lend_amount)\r\n            Controller(controller).add_collateral(lend_amount)\r\n    if msg.sender == FACTORY:\r\n        assert self.balance >= fee_data.gas_fee, \"Insufficient gas fee\"\r\n        send(fee_data.refund_wallet, fee_data.gas_fee)\r\n    else:\r\n        Factory(FACTORY).add_collateral_event(collateral, collateral_amount, lend_amount)\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef remove_collateral(collateral: address, collateral_amount: uint256, withdraw_amount: uint256):\r\n    assert msg.sender == OWNER, \"Unauthorized\"\r\n    controller: address = ControllerFactory(CONTROLLER_FACTORY).get_controller(collateral)\r\n    if collateral_amount > 0:\r\n        Controller(controller).remove_collateral(collateral_amount)\r\n    if withdraw_amount > 0:\r\n        if collateral == WETH:\r\n            send(OWNER, withdraw_amount)\r\n        else:\r\n            self._safe_transfer(collateral, OWNER, withdraw_amount)\r\n    Factory(FACTORY).remove_collateral_event(collateral, collateral_amount, withdraw_amount)\r\n\r\n@external\r\n@payable\r\ndef borrow_more(collateral: address, collateral_amount: uint256, lend_amount: uint256, debt: uint256, withdraw_amount: uint256):\r\n    assert msg.sender == OWNER, \"Unauthorized\"\r\n    controller: address = ControllerFactory(CONTROLLER_FACTORY).get_controller(collateral)\r\n    if collateral == WETH:\r\n        Controller(controller).borrow_more(lend_amount, debt, value=lend_amount)\r\n    else:\r\n        self._safe_transfer_from(collateral, OWNER, self, collateral_amount)\r\n        self._safe_approve(collateral, controller, lend_amount)\r\n        Controller(controller).borrow_more(lend_amount, debt)\r\n    ERC20(crvUSD).transfer(OWNER, withdraw_amount)\r\n    Factory(FACTORY).borrow_more_event(collateral, lend_amount, withdraw_amount)\r\n\r\n@external\r\ndef repay(collateral: address, input_amount: uint256, repay_amount: uint256):\r\n    assert msg.sender == OWNER or msg.sender == FACTORY, \"Unauthorized\"\r\n    assert input_amount > 0 or repay_amount > 0, \"Wrong amount\"\r\n    fee_data: FeeData = Factory(FACTORY).fee_data()\r\n    if msg.sender == OWNER and input_amount > 0:\r\n        ERC20(crvUSD).transferFrom(OWNER, self, input_amount)\r\n    controller: address = ControllerFactory(CONTROLLER_FACTORY).get_controller(collateral)\r\n    if repay_amount > 0:\r\n        state: uint256[4] = Controller(controller).user_state(self)\r\n        assert repay_amount < state[2], \"Cancel not allowed\"\r\n        ERC20(crvUSD).approve(controller, repay_amount)\r\n        Controller(controller).repay(repay_amount)\r\n    if msg.sender == FACTORY:\r\n        assert self.balance >= fee_data.gas_fee, \"Insufficient gas fee\"\r\n        send(fee_data.refund_wallet, fee_data.gas_fee)\r\n    else:\r\n        Factory(FACTORY).repay_event(collateral, input_amount, repay_amount)\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef cancel(collateral: address):\r\n    assert msg.sender == OWNER, \"Unauthorized\"\r\n    controller: address = ControllerFactory(CONTROLLER_FACTORY).get_controller(collateral)\r\n    state: uint256[4] = Controller(controller).user_state(self)\r\n    crv_usd_balance: uint256 = ERC20(crvUSD).balanceOf(self)\r\n    if crv_usd_balance < state[2]:\r\n        crv_usd_balance = unsafe_sub(state[2], crv_usd_balance)\r\n        ERC20(crvUSD).transferFrom(OWNER, self, crv_usd_balance)\r\n    ERC20(crvUSD).approve(controller, state[2])\r\n    Controller(controller).repay(state[2])\r\n    if collateral == WETH:\r\n        WrappedEth(WETH).withdraw(state[0])\r\n        send(OWNER, state[0])\r\n    else:\r\n        self._safe_transfer(collateral, OWNER, state[1])\r\n\r\n@external\r\ndef withdraw_crvusd(amount: uint256):\r\n    assert msg.sender == OWNER, \"Unauthorized\"\r\n    ERC20(crvUSD).transfer(OWNER, amount)\r\n    Factory(FACTORY).withdraw_event(crvUSD, amount)\r\n\r\n@external\r\ndef bot_restart(collateral: address, health_threshold: int256, expire: uint256, repayable: bool):\r\n    Factory(FACTORY).bot_start_event(collateral, health_threshold, expire, repayable)\r\n\r\n@external\r\n@view\r\ndef health(collateral: address) -> int256:\r\n    controller: address = ControllerFactory(CONTROLLER_FACTORY).get_controller(collateral)\r\n    return Controller(controller).health(self)\r\n\r\n@external\r\n@view\r\ndef loan_exists(collateral: address) -> bool:\r\n    controller: address = ControllerFactory(CONTROLLER_FACTORY).get_controller(collateral)\r\n    return Controller(controller).loan_exists(self)\r\n\r\n@external\r\n@view\r\ndef state(collateral: address) -> uint256[4]:\r\n    controller: address = ControllerFactory(CONTROLLER_FACTORY).get_controller(collateral)\r\n    return Controller(controller).user_state(self)\r\n\r\n@external\r\n@payable\r\ndef __default__():\r\n    pass", "ABI": "[{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"controller_factory\",\"type\":\"address\"},{\"name\":\"weth\",\"type\":\"address\"},{\"name\":\"crv_usd\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"router\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"create_loan\",\"inputs\":[{\"name\":\"collateral\",\"type\":\"address\"},{\"name\":\"collateral_amount\",\"type\":\"uint256\"},{\"name\":\"lend_amount\",\"type\":\"uint256\"},{\"name\":\"debt\",\"type\":\"uint256\"},{\"name\":\"withdraw_amount\",\"type\":\"uint256\"},{\"name\":\"N\",\"type\":\"uint256\"},{\"name\":\"health_threshold\",\"type\":\"int256\"},{\"name\":\"expire\",\"type\":\"uint256\"},{\"name\":\"repayable\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"add_collateral_with_swap\",\"inputs\":[{\"name\":\"swap_infos\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"route\",\"type\":\"address[9]\"},{\"name\":\"swap_params\",\"type\":\"uint256[3][4]\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"pools\",\"type\":\"address[4]\"},{\"name\":\"expected\",\"type\":\"uint256\"}]},{\"name\":\"lend_amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"add_collateral\",\"inputs\":[{\"name\":\"collateral\",\"type\":\"address\"},{\"name\":\"collateral_amount\",\"type\":\"uint256\"},{\"name\":\"lend_amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_collateral\",\"inputs\":[{\"name\":\"collateral\",\"type\":\"address\"},{\"name\":\"collateral_amount\",\"type\":\"uint256\"},{\"name\":\"withdraw_amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"borrow_more\",\"inputs\":[{\"name\":\"collateral\",\"type\":\"address\"},{\"name\":\"collateral_amount\",\"type\":\"uint256\"},{\"name\":\"lend_amount\",\"type\":\"uint256\"},{\"name\":\"debt\",\"type\":\"uint256\"},{\"name\":\"withdraw_amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"repay\",\"inputs\":[{\"name\":\"collateral\",\"type\":\"address\"},{\"name\":\"input_amount\",\"type\":\"uint256\"},{\"name\":\"repay_amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"cancel\",\"inputs\":[{\"name\":\"collateral\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw_crvusd\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"bot_restart\",\"inputs\":[{\"name\":\"collateral\",\"type\":\"address\"},{\"name\":\"health_threshold\",\"type\":\"int256\"},{\"name\":\"expire\",\"type\":\"uint256\"},{\"name\":\"repayable\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"health\",\"inputs\":[{\"name\":\"collateral\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"loan_exists\",\"inputs\":[{\"name\":\"collateral\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"state\",\"inputs\":[{\"name\":\"collateral\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"}]},{\"stateMutability\":\"payable\",\"type\":\"fallback\"}]", "ContractName": "Curve Lending Bot", "CompilerVersion": "vyper:0.3.10", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "000000000000000000000000c9332fdcb1c491dcc683bae86fe3cb70360738bc000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000f939e0a03fb07f59a73314e73794be0e57ac1b4e0000000000000000000000009fc09a1d181f45aa424e1ca7267c15e87e691bdd00000000000000000000000099a58482bd75cbab83b27ec03ca68ff489b5788f", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": ""}