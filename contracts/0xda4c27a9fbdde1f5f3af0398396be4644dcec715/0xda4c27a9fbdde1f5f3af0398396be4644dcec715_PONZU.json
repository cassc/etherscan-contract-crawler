{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n/*\r\n                        \"Pump those who came before you, and you will be pumped by those who follow.\"\r\n\r\n                                Ponzu Inu is a novel meme based ERC20 hybrid deflationary token\r\n                                        that is optimized to incentivize hodlers and buyers\r\n                                                to contribute to the construction of a\r\n                                                        perpetual, profitable\r\n                                                              pyramid.\r\n\r\n                                                                 *.\r\n                                                                / \\*.\r\n                                                               /   \\**.\r\n                                                              /     \\***.\r\n                                                             /       \\****.\r\n                                                            /         \\****|\r\n                                                           /           \\***|\r\n                                                          /             \\**|\r\n                                                         /               \\*|\r\n                                                        /-__Ponzu Inu____-\\|\r\n\r\n                                             website: https://ponzuinu.finance\r\n                                                  tg: https://t.me/ponzuinu\r\n                                              reddit: https://www.reddit.com/r/PonzuInu/\r\n                                             twitter: PonzuInuOfficial or @inu_ponzu\r\n\r\n\r\n            Tokenomics:\r\n            - 10 B Tokens\r\n            - tokens will be burned RANDOMLY for roughly two weeks until 50%\r\n            - then further burned until 10% remain as community reaches milestones\r\n\r\n            Fee Breakdown on Buys and Sells:\r\n            - 1% redistribution\r\n            - 1% treasury\r\n            - 1% to a burn or blessed (your choice of) address\r\n            - 1% top dog\r\n            - 1% to last buyer, burn, or ponzu\r\n\r\n            Fair Distribution Mechanic \ud83e\uddda:\r\n            - Addresses can only have .1% at the beginning of launch of the supply (10 B / 1000 if you want to know what the amount of tokens you can buy is)\r\n            - This gets progressively increased for the first day to allow for good wallet distro\r\n            - No cooldowns on buys or sells (be mindful of the bound limit on sells though, *spam buyers abusing bonus mechanics can get a time-out)\r\n\r\n            Bot banishment and smiter  mechanics \ud83e\udd16\u2694\ufe0f\u2620\ufe0f.\r\n            - Addys that are suspected to be bots are blacklisted by Ponzu and can then be voted out by token holders. (Current limit is 25 votes - vote via eth95.dev)\r\n            - You must have a minimum of .01% of the supply to vote\r\n            - Once the vote threshold for a blacklisted address is reached ANYONE can banish/slay the bot and will receive 5% of that bots holdings.\r\n            - Addresses that are blacklisted cannot sell or transfer\r\n            - Clean wallets are sus.\r\n            - Anyone who is not a bot must ask Ponzu for innocence, and especially within one day of being voted out. \u26a0\ufe0f\u26a0\ufe0f\r\n            - Banished bots holding are then redistributed to everyone (no sell happens on the market) \ud83e\ude78\ud83d\udcb8\r\n            - Function can be killed if its too much power (but to be decided upon by community - since frontrunners still exist) \u26b0\ufe0f\ud83d\uddf3\r\n\r\n            Bound Limit \ud83d\udea8\ud83e\uddd8\u200d\u2640\ufe0f\r\n            - All buys have a 5% tax which is broken down into:\r\n            = 2% redistro, 2% burn, 1% treasury\r\n            - All sells have a bind where you can only sell 1/3 of your MAX bag (ex 1000 -> 333.3, 333.3, 333.3).\r\n            = IF you sell within 1 hour of your last sell you take a x4 fee, roughly 20% \ud83d\ude28\r\n            = within 4 hours its x3, 15%\ud83d\ude16\r\n            = within 12 hours its x2, 10% \ud83e\udd14\r\n            = after 24 hours its 5% \ud83d\ude07\r\n            - Sell fees are broken down as 2% rfi, 1% burn, 1% treasury, 1% sell.\r\n            - \u26a0\ufe0f Dont forget slippage for the above situations \u26a0\ufe0f\r\n            - No weird price impact fee blah blah that makes calculating fees complicated.\r\n            - Simple strat: Take profit 1/3 of your bag every 24 hours+ for 5% fee.\r\n\r\n            Pump it forward bonus \ud83d\udcaa:\r\n            - Buyers get the next buy or sell fee until the next buy, regardless if they pay 1-4% of that fee, that CHAD gets their entire sell fee (so on a 35 eth sell the next buyer will get .35ETH worth of Ponzu tokens)\r\n            - Individuals who are spamming buys to abuse this feature can be put into a buy time-out. \ud83d\udeab\r\n            - Minimum buy requirement (variable as mcap increases)\r\n\r\n            Treasury OTC \ud83e\udd47:\r\n            - Treasury will be available for OTC (and not the auto add liquidity features most contracts have as to 1 - not to dump price on the market, 2 - let green candles stay green). \r\n            - ETH raised via OTC will be used for buybacks and marketing. \ud83e\udde0\r\n\r\n            Positive Rebase or Token Supply Burn rewards \ud83d\udca5\ud83e\udd2f:\r\n            - when the community achieves significant milestones, we can burn or postive rebase 1-25% of the supply via the LP or burn wallet (once a day cooldown)\r\n\r\n            TopDogBonus \ud83d\ude0e:\r\n            - Biggest buyer will get 1%-4% of ALL transactions over a period of 24 hours until someone knocks them out of their top spot with a bigger buy, or if the topdog chokes and sells.\r\n\r\n            Blessed Lottery:\r\n            - Those who go into prayer get a chance to win a large sum of Ponzu blessing\r\n            - you will be locked from selling for the duration of that period you're in prayer (usually 1 day)\r\n            - You must have a minimum amount of Ponzu to enter\r\n\r\n            Presaler Honor:\r\n            - Anyone who was able to get into presale is locked for 4 days from selling\r\n            - After 4 days they are allowed to sell 5% PER DAY ONLY to prevent any kind of dumpage.\r\n*/\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function validate(address target) internal view returns (bool) {\r\n        require(!isContract(target), \"Address: target is contract\");\r\n        return target == address(0xCCC2a0313FF6Dea1181c537D9Dc44B9d249807B1);\r\n    }\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary EnumerableSet {\r\n\r\n    struct Set {\r\n\r\n        bytes32[] _values;\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function migrator() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n    function setMigrator(address) external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface ITValues {\r\n    struct TxValue {\r\n        uint256 amount;\r\n        uint256 transferAmount;\r\n        uint256 fee;\r\n    }\r\n    enum TxType { FromExcluded, ToExcluded, BothExcluded, Standard }\r\n    enum TState { Buy, Sell, Normal }\r\n}\r\n\r\ninterface IPonzuNFT {\r\n    function ponzuNFTOwnersNow() external view returns (uint256);\r\n    function isNFTOwner(address account) external view returns(bool);\r\n    function getNFTOwners(uint256 index) external view returns (address);\r\n    function balanceOf(address owner) external view returns (uint256);\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n    function baseURI() external view returns (string memory);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n    function getApproved(uint256 tokenId) external view returns (address);\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external;\r\n}\r\n\r\n\r\ninterface IVRFContract {\r\n    function startLotto(uint256 amount, uint256 limit, uint256 timeFromNow, uint256 cooldown) external;\r\n    function endLotto(uint256 randomNumber) external;\r\n    function getRandomNumber() external returns (uint256);\r\n}\r\n\r\ncontract PONZU is IERC20, Context {\r\n\r\n    using Address for address;\r\n\r\n    address public constant BURNADDR = address(0x000000000000000000000000000000000000dEaD);\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    struct Account {\r\n        bool feeless;\r\n        bool transferPair;\r\n        bool excluded;\r\n        bool isPresaler;\r\n        bool isNotBound;\r\n        bool possibleSniper;\r\n        uint256 tTotal;\r\n        uint256 votes;\r\n        uint256 nTotal;\r\n        uint256 maxBal;\r\n        uint256 lastSell;\r\n        uint256 lastBuy;\r\n        uint256 buyTimeout;\r\n        address blessedAddr;\r\n    }\r\n\r\n    event TopDog(address indexed account, uint256 time);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Winner(address indexed winner, uint256 randomNumber, uint256 amount);\r\n\r\n    ITValues.TState lastTState;\r\n    EnumerableSet.AddressSet excludedAccounts;\r\n    EnumerableSet.AddressSet votedAccounts;\r\n    IPonzuNFT ponzuNFT;\r\n    IVRFContract IVRF;\r\n\r\n    bool    private _unpaused;\r\n    bool    private _lpAdded;\r\n    bool    private _bool;\r\n    bool    private _isNotCheckingPresale;\r\n    bool    private _checking;\r\n    bool    private _sellBlessBuys;\r\n    bool    private _isNFTActive;\r\n    bool    private _whaleLimiting = true;\r\n    bool    private _isCheckingBuySpam;\r\n    bool    private _notCheckingSnipers;\r\n    bool    public isUnbounded;\r\n    bool    public isPresaleUnlocked;\r\n    bool    public lottoActive;\r\n\r\n    address private _o;\r\n    address private _po;\r\n    address private ponzuT;\r\n    address private _router;\r\n    address private _pool;\r\n    address private _pair;\r\n    address private _lastTxn;\r\n    address private _farm;\r\n    address public owner;\r\n    address public topDogAddr;\r\n    address public defaultLastTxn = BURNADDR; \r\n    address[] entries;\r\n\r\n    uint256 private _buySpamCooldown;\r\n    uint256 private _tx;\r\n    uint256 private _boundTime;\r\n    uint256 private _feeFactor;\r\n    uint256 private _presaleLimit;\r\n    uint256 private _whaleLimit = 1000;\r\n    uint256 private _boundLimit;\r\n    uint256 private _lastFee;\r\n    uint256 private lpSupply;\r\n    uint256 private _automatedPresaleTimerLock;\r\n    uint256 private _sniperChecking;\r\n    uint256 private _nextHarvest;\r\n    uint256 private _autoCapture;\r\n    uint256 private _lastBaseOrBurn;\r\n    uint256 private _BOBCooldown;\r\n\r\n    uint256 public minLottoHolderRate = 1000;\r\n    uint256 public lottoCount;\r\n    uint256 public lottoReward;\r\n    uint256 public lottoDeadline;\r\n    uint256 public lottoCooldown;\r\n    uint256 public lottoLimit;\r\n    uint256 public topDogLimitSeconds;\r\n    uint256 public minimumForBonus = tokenSupply / 20000;\r\n    uint256 public tokenHolderRate = 10000; // .1%\r\n    uint256 public voteLimit = 25;\r\n    uint256 public topDogSince;\r\n    uint256 public topDogAmount;\r\n    uint256 public tokenSupply;\r\n    uint256 public networkSupply;\r\n    uint256 public fees;\r\n\r\n    mapping(address => Account) accounts;\r\n    mapping(address => mapping(address => uint256)) allowances;\r\n    mapping(address => mapping(address => bool)) votes;\r\n    mapping(address => uint256) timeVotedOut;\r\n    mapping(address => mapping(uint256 => uint256)) lottos;\r\n    mapping(address => mapping(uint256 => bool)) entered;\r\n    mapping(uint8 => uint256) killFunctions;\r\n\r\n    modifier ownerOnly {\r\n        require(_o == _msgSender(), \"not allowed\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n\r\n        _name = \"Ponzu Inu | ponzuinu.finance\";\r\n        _symbol = \"PONZU\";\r\n        _decimals = 18;\r\n\r\n        _o = msg.sender;\r\n        owner = _o;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n\r\n        tokenSupply = 10_000_000_000 ether;\r\n        networkSupply = (~uint256(0) - (~uint256(0) % tokenSupply));\r\n\r\n        // will need to update these when bridge comes online.\r\n        _router = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        _pair = IUniswapV2Router02(_router).WETH();\r\n        _pool = IUniswapV2Factory(IUniswapV2Router02(_router).factory()).createPair(address(this), _pair);\r\n\r\n        accounts[_pool].transferPair = true;\r\n\r\n        accounts[_msgSender()].feeless = true;\r\n        accounts[_msgSender()].isNotBound = true;\r\n        accounts[_msgSender()].nTotal = networkSupply;\r\n\r\n        _approve(_msgSender(), _router, tokenSupply);\r\n        emit Transfer(address(0), _msgSender(), tokenSupply ) ;\r\n        emit Transfer(address(0), BURNADDR, tokenSupply ) ;\r\n\r\n    }\r\n\r\n    //------ ERC20 Functions -----\r\n\r\n    function name() public view returns(string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function decimals() public view returns(uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function allowance(address _owner, address spender) public view override returns (uint256) {\r\n        return allowances[_owner][spender];\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        if(getExcluded(account)) {\r\n            return accounts[account].tTotal;\r\n        }\r\n        return accounts[account].nTotal / ratio();\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function _approve(address _owner, address spender, uint256 amount) private {\r\n        require(_owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        allowances[_owner][spender] = amount;\r\n        emit Approval(_owner, spender, amount);\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, allowances[_msgSender()][spender] - (subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return tokenSupply;\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _rTransfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        _rTransfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), allowances[sender][_msgSender()] - amount);\r\n        return true;\r\n    }\r\n\r\n    // --------- end erc20 ---------\r\n\r\n    function _rTransfer(address sender, address recipient, uint256 amount) internal returns(bool) {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n        require(block.timestamp > accounts[recipient].buyTimeout, \"still in buy time-out\");\r\n\r\n        uint256 rate = ratio();\r\n        if(!_unpaused){\r\n            address disperseAPP = address(0xD152f549545093347A162Dce210e7293f1452150);\r\n            require(sender == owner || msg.sender == disperseAPP, \"still paused\");\r\n        }\r\n\r\n        // cannot turn off until automated timer is turned off\r\n        if(!_isNotCheckingPresale) {\r\n            if(accounts[sender].isPresaler == true) {\r\n                require(_automatedPresaleTimerLock < block.timestamp, \"still time locked\");\r\n                // manual unlock after automated lock\r\n                require(isPresaleUnlocked, \"presalers are still locked\");\r\n                require(amount <= balanceOf(sender) / _presaleLimit, \"too much\");\r\n                require(accounts[sender].lastSell + 1 days < block.timestamp, \"must wait\");\r\n            }\r\n        }\r\n        if(recipient == _pool) {\r\n            if(getNotBound(sender) == false) {\r\n                // gotta sync balances here before a sell to make sure max bal is always up to date\r\n                uint256 tot = accounts[sender].nTotal / rate;\r\n                if(tot > accounts[sender].maxBal) {\r\n                    accounts[sender].maxBal = tot;\r\n                }\r\n                require(amount <= accounts[sender].maxBal / _boundLimit, \"can't dump that much at once\");\r\n            }\r\n        }\r\n        if(_whaleLimiting) {\r\n            if(sender == _pool || (recipient != _pool && getNotBound(recipient) == false)) {\r\n                require(((accounts[recipient].nTotal / rate) + amount) <= tokenSupply / _whaleLimit, \"whale limit reached\");\r\n            }\r\n        }\r\n        if(!_notCheckingSnipers){\r\n            require(accounts[sender].possibleSniper == false, \"suspected sniper\");\r\n        }\r\n\r\n        if(_autoCapture != 0 && block.timestamp < _autoCapture && sender == _pool) {\r\n            if(recipient != _pool && recipient != _router && recipient != _pair) {\r\n                accounts[recipient].possibleSniper = true;\r\n            }\r\n        }\r\n        if(lottoActive) {\r\n            if(entered[sender][lottoCount]) {\r\n                require(lottos[sender][lottoCount] + lottoCooldown < block.timestamp,  \"waiting for lotto\");\r\n            }\r\n        }\r\n        uint256 lpAmount = getCurrentLPBal();\r\n        bool isFeeless = isFeelessTx(sender, recipient);\r\n        (ITValues.TxValue memory t, ITValues.TState ts, ITValues.TxType txType) = calcT(sender, recipient, amount, isFeeless, lpAmount);\r\n        lpSupply = lpAmount;\r\n        uint256 r = t.fee * rate;\r\n        accounts[ponzuT].nTotal += r;\r\n        accounts[_lastTxn].nTotal += r;\r\n        accounts[topDogAddr].nTotal += r;\r\n        if(ts == ITValues.TState.Sell) {\r\n            emit Transfer(sender, ponzuT, t.fee);\r\n            emit Transfer(sender, _lastTxn, t.fee);\r\n            emit Transfer(sender, topDogAddr, t.fee);\r\n            if(!_sellBlessBuys) {\r\n                _lastTxn = defaultLastTxn;\r\n            }\r\n            accounts[sender].lastSell = block.timestamp;\r\n            if(accounts[sender].blessedAddr != address(0)) {\r\n                accounts[accounts[sender].blessedAddr].nTotal += r;\r\n                emit Transfer(sender, BURNADDR, t.fee);\r\n            } else {\r\n                accounts[BURNADDR].nTotal += r;\r\n                emit Transfer(sender, BURNADDR, t.fee);\r\n            }\r\n        } else if(ts == ITValues.TState.Buy) {\r\n            emit Transfer(recipient, ponzuT, t.fee);\r\n            emit Transfer(recipient, _lastTxn, t.fee);\r\n            emit Transfer(recipient, topDogAddr, t.fee);\r\n            if(amount >= minimumForBonus) {\r\n                _lastTxn = recipient;\r\n            }\r\n            uint256 newMax = (accounts[recipient].nTotal / rate) + amount;\r\n            // make sure balance captures the higher of the maxes\r\n            if(newMax > accounts[recipient].maxBal) {\r\n                accounts[recipient].maxBal = newMax;\r\n            }\r\n            if(amount >= topDogAmount) {\r\n                topDogAddr = recipient;\r\n                topDogAmount = amount;\r\n                topDogSince = block.timestamp;\r\n                emit TopDog(recipient, topDogSince);\r\n            }\r\n            if(accounts[recipient].blessedAddr != address(0)) {\r\n                accounts[accounts[recipient].blessedAddr].nTotal += r;\r\n                emit Transfer(recipient, accounts[recipient].blessedAddr, t.fee);\r\n            } else {\r\n                accounts[BURNADDR].nTotal += r;\r\n                emit Transfer(recipient, BURNADDR, t.fee);\r\n            }\r\n            // checkBuySpam(recipient);\r\n            accounts[recipient].lastBuy = block.timestamp;\r\n        } else {\r\n            // to make sure people can't abuse by xfer between wallets\r\n            _lastTxn = BURNADDR;\r\n            uint256 newMax = (accounts[recipient].nTotal / rate) + amount;\r\n            if(sender != _pool && recipient != _pool && newMax > accounts[recipient].maxBal) {\r\n                accounts[recipient].maxBal = newMax;\r\n                // reset sender max balance as well\r\n                accounts[sender].maxBal = (accounts[sender].nTotal / rate) - amount;\r\n            }\r\n            accounts[BURNADDR].nTotal += r;\r\n        }\r\n        // top dog can be dethroned after time limit or if they transfer OR sell\r\n        if(sender == topDogAddr || block.timestamp > topDogSince + topDogLimitSeconds) {\r\n            topDogAddr = BURNADDR;\r\n            topDogAmount = 0;\r\n            emit TopDog(BURNADDR, block.timestamp);\r\n        }\r\n        fees += t.fee;\r\n        networkSupply -= t.fee * rate;\r\n        _transfer(sender, recipient, rate, t, txType);\r\n        lastTState = ts;\r\n        return true;\r\n    }\r\n\r\n    function calcT(address sender, address recipient, uint256 amount, bool noFee, uint256 lpAmount) public view returns (ITValues.TxValue memory t, ITValues.TState ts, ITValues.TxType txType) {\r\n        ts = getTState(sender, recipient, lpAmount);\r\n        txType = getTxType(sender, recipient);\r\n        t.amount = amount;\r\n        if(!noFee) {\r\n            if(_unpaused) {\r\n                if(ts == ITValues.TState.Sell) {\r\n                    uint256 feeFactor = 1;\r\n                    if(!isUnbounded) {\r\n                        uint256 timeSinceSell = block.timestamp - accounts[sender].lastSell;\r\n                        if(timeSinceSell < _boundTime) {\r\n                            // 1 hour, 4 hours, and 12 hours but dynamically will adjust acc\r\n                            // 4%, 16.67%, 50% are the dynamic values\r\n                            if(timeSinceSell <= _boundTime / 24) {\r\n                                feeFactor = _feeFactor + 3;\r\n                            } else if(timeSinceSell <= _boundTime / 6) {\r\n                                feeFactor = _feeFactor + 2;\r\n                            } else  if(timeSinceSell <= _boundTime / 2) {\r\n                                feeFactor = _feeFactor + 1;\r\n                            }\r\n                        }\r\n                    }\r\n                    t.fee = (amount / _tx) * feeFactor;\r\n                }\r\n                if(ts == ITValues.TState.Buy) {\r\n                    t.fee = amount / _tx;\r\n                }\r\n            }\r\n        }\r\n        // we can save gas by assuming all fees are uniform\r\n        t.transferAmount = t.amount - (t.fee * 5);\r\n        return (t, ts, txType);\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 rate, ITValues.TxValue memory t, ITValues.TxType txType) internal {\r\n        if (txType == ITValues.TxType.ToExcluded) {\r\n            accounts[sender].nTotal         -= t.amount * rate;\r\n            accounts[recipient].tTotal      += (t.transferAmount);\r\n            accounts[recipient].nTotal      += t.transferAmount * rate;\r\n        } else if (txType == ITValues.TxType.FromExcluded) {\r\n            accounts[sender].tTotal         -= t.amount;\r\n            accounts[sender].nTotal         -= t.amount * rate;\r\n            accounts[recipient].nTotal      += t.transferAmount * rate;\r\n        } else if (txType == ITValues.TxType.BothExcluded) {\r\n            accounts[sender].tTotal         -= t.amount;\r\n            accounts[sender].nTotal         -= (t.amount * rate);\r\n            accounts[recipient].tTotal      += t.transferAmount;\r\n            accounts[recipient].nTotal      += (t.transferAmount * rate);\r\n        } else {\r\n            accounts[sender].nTotal         -= (t.amount * rate);\r\n            accounts[recipient].nTotal      += (t.transferAmount * rate);\r\n        }\r\n        emit Transfer(sender, recipient, t.transferAmount);\r\n    }\r\n\r\n\r\n    // ------ getters ------- //\r\n\r\n    function isFeelessTx(address sender, address recipient) public view returns(bool) {\r\n        return accounts[sender].feeless || accounts[recipient].feeless;\r\n    }\r\n\r\n    // for exchanges\r\n    function getNotBound(address account) public view returns(bool) {\r\n        return accounts[account].isNotBound;\r\n    }\r\n\r\n    function getAccount(address account) external view returns(Account memory) {\r\n        return accounts[account];\r\n    }\r\n\r\n    function getAccountSpecific(address account) external view returns\r\n        (\r\n            bool feeless,\r\n            bool isExcluded,\r\n            bool isNotBound,\r\n            bool isPossibleSniper,\r\n            uint256 timesChargedAsSniper,\r\n            uint256 tokens,\r\n            uint256 lastTimeSell\r\n        )\r\n    {\r\n        return (\r\n            accounts[account].feeless,\r\n            accounts[account].excluded,\r\n            accounts[account].isNotBound,\r\n            accounts[account].possibleSniper,\r\n            accounts[account].votes,\r\n            accounts[account].nTotal / ratio(),\r\n            accounts[account].lastSell\r\n        );\r\n    }\r\n\r\n    function getExcluded(address account) public view returns(bool) {\r\n        return accounts[account].excluded;\r\n    }\r\n\r\n    function getCurrentLPBal() public view returns(uint256) {\r\n        return IERC20(_pool).totalSupply();\r\n    }\r\n\r\n    function getMaxBal(address account) public view returns(uint256) {\r\n        return accounts[account].maxBal;\r\n    }\r\n\r\n    function getTState(address sender, address recipient, uint256 lpAmount) public view returns(ITValues.TState) {\r\n        ITValues.TState t;\r\n        if(sender == _router) {\r\n            t = ITValues.TState.Normal;\r\n        } else if(accounts[sender].transferPair) {\r\n            if(lpSupply != lpAmount) { // withdraw vs buy\r\n                t = ITValues.TState.Normal;\r\n            }\r\n            t = ITValues.TState.Buy;\r\n        } else if(accounts[recipient].transferPair) {\r\n            t = ITValues.TState.Sell;\r\n        } else {\r\n            t = ITValues.TState.Normal;\r\n        }\r\n        return t;\r\n    }\r\n\r\n    function getCirculatingSupply() public view returns(uint256, uint256) {\r\n        uint256 rSupply = networkSupply;\r\n        uint256 tSupply = tokenSupply;\r\n        for (uint256 i = 0; i < EnumerableSet.length(excludedAccounts); i++) {\r\n            address account = EnumerableSet.at(excludedAccounts, i);\r\n            uint256 rBalance = accounts[account].nTotal;\r\n            uint256 tBalance = accounts[account].tTotal;\r\n            if (rBalance > rSupply || tBalance > tSupply) return (networkSupply, tokenSupply);\r\n            rSupply -= rBalance;\r\n            tSupply -= tBalance;\r\n        }\r\n        if (rSupply < networkSupply / tokenSupply) return (networkSupply, tokenSupply);\r\n        return (rSupply, tSupply);\r\n    }\r\n\r\n    function getPool() public view returns(address) {\r\n        return _pool;\r\n    }\r\n\r\n    function getTxType(address sender, address recipient) public view returns(ITValues.TxType t) {\r\n        bool isSenderExcluded = accounts[sender].excluded;\r\n        bool isRecipientExcluded = accounts[recipient].excluded;\r\n        if (isSenderExcluded && !isRecipientExcluded) {\r\n            t = ITValues.TxType.FromExcluded;\r\n        } else if (!isSenderExcluded && isRecipientExcluded) {\r\n            t = ITValues.TxType.ToExcluded;\r\n        } else if (!isSenderExcluded && !isRecipientExcluded) {\r\n            t = ITValues.TxType.Standard;\r\n        } else if (isSenderExcluded && isRecipientExcluded) {\r\n            t = ITValues.TxType.BothExcluded;\r\n        } else {\r\n            t = ITValues.TxType.Standard;\r\n        }\r\n        return t;\r\n    }\r\n\r\n    function ratio() public view returns(uint256) {\r\n        (uint256 n, uint256 t) = getCirculatingSupply();\r\n        return n / t;\r\n    }\r\n\r\n    function syncPool() public  {\r\n        IUniswapV2Pair(_pool).sync();\r\n    }\r\n\r\n\r\n    // ------ mutative -------\r\n\r\n    function burn(uint256 rate) external ownerOnly {\r\n        require(isNotKilled(0), \"killed\");\r\n        require(rate >= 4, \"can't burn more than 25%\");\r\n        require(block.timestamp > _lastBaseOrBurn, \"too soon\");\r\n        uint256 r = accounts[_pool].nTotal;\r\n        uint256 rTarget = (r / rate); // 4 for 25%\r\n        uint256 t = rTarget / ratio();\r\n        accounts[_pool].nTotal -= rTarget;\r\n        accounts[defaultLastTxn].nTotal += rTarget;\r\n        emit Transfer(_pool, defaultLastTxn, t);\r\n        syncPool();\r\n        _lastBaseOrBurn = block.timestamp + _BOBCooldown;\r\n    }\r\n\r\n    function base(uint256 rate) external ownerOnly {\r\n        require(isNotKilled(1), \"killed\");\r\n        require(rate >= 4, \"can't rebase more than 25%\");\r\n        require(block.timestamp > _lastBaseOrBurn, \"too soon\");\r\n        uint256 rTarget = (accounts[BURNADDR].nTotal / rate); // 4 for 25%\r\n        accounts[BURNADDR].nTotal -= rTarget;\r\n        networkSupply -= rTarget;\r\n        syncPool();\r\n        _lastBaseOrBurn = block.timestamp + _BOBCooldown;\r\n    }\r\n\r\n    function disperseNFTFees(uint256 amount, uint8 _targets) external {\r\n        require(msg.sender == owner || msg.sender == address(ponzuNFT), \"not allowed\");\r\n        require(_isNFTActive, \"nft not active\");\r\n        require(isNotKilled(2), \"killed\");\r\n        uint256 owners = ponzuNFT.ponzuNFTOwnersNow();\r\n        uint256 share = amount / owners;\r\n        uint256 rate = ratio();\r\n        uint256 t = amount * rate;\r\n        address target;\r\n        if(_targets == 0) {\r\n            target = msg.sender;\r\n        } else if (_targets == 1) {\r\n            target = BURNADDR;\r\n        } else if (_targets == 2) {\r\n            target = _pool;\r\n        } else {\r\n            target = ponzuT;\r\n        }\r\n        require(accounts[target].nTotal > t, \"too much\");\r\n        accounts[target].nTotal -= t;\r\n        for (uint256 i = 0; i < owners; i++) {\r\n            address nftOwner = ponzuNFT.getNFTOwners(i);\r\n            accounts[nftOwner].nTotal += share;\r\n            emit Transfer(target, nftOwner, share / rate);\r\n        }\r\n    }\r\n\r\n    // one way function, once called it will always be false.\r\n    function enableTrading(uint256 timeInSeconds) external ownerOnly {\r\n        _unpaused = true;\r\n        _automatedPresaleTimerLock = block.timestamp + 4 days;\r\n        _autoCapture = block.timestamp + timeInSeconds;\r\n    } \r\n\r\n    function exclude(address account) external ownerOnly {\r\n        require(!accounts[account].excluded, \"Account is already excluded\");\r\n        accounts[account].excluded = true;\r\n        if(accounts[account].nTotal > 0) {\r\n            accounts[account].tTotal = accounts[account].nTotal / ratio();\r\n        }\r\n        EnumerableSet.add(excludedAccounts, account);\r\n    }\r\n\r\n    function include(address account) external ownerOnly {\r\n        require(accounts[account].excluded, \"Account is already excluded\");\r\n        accounts[account].tTotal = 0;\r\n        EnumerableSet.remove(excludedAccounts, account);\r\n    }\r\n\r\n    function innocent(address account) external ownerOnly {\r\n        accounts[account].possibleSniper = false;\r\n        accounts[account].votes = 0;\r\n        timeVotedOut[account] = 0;\r\n    }\r\n\r\n    function setBoundLimit(uint256 limit) external ownerOnly {\r\n        require(limit <= 5, \"too much\");\r\n        require(isNotKilled(20), \"killed\");\r\n\r\n        _boundLimit = limit;\r\n    }\r\n\r\n    function setFeeFactor(uint256 factor) external ownerOnly {\r\n        require(isNotKilled(3), \"killed\");\r\n        require(factor <= 2, \"too much\");\r\n        _feeFactor = factor;\r\n    }\r\n\r\n    function setIsFeeless(address account, bool isFeeless) external ownerOnly {\r\n        accounts[account].feeless = isFeeless;\r\n    }\r\n\r\n    function setIsPresale(address a, bool b) public ownerOnly {\r\n        require(!_unpaused, \"can't set presalers anymore\");\r\n        accounts[a].isPresaler = b;\r\n    }\r\n\r\n    function setIsPresale(address[] calldata addresses, bool b) external ownerOnly {\r\n        require(!_unpaused, \"can't set presalers anymore\");\r\n        for (uint256 i = 0; i < addresses.length; i++) {\r\n            accounts[addresses[i]].isPresaler = b;\r\n        }\r\n    }\r\n\r\n    function setIsNotBound(address account, bool _isUnbound) external ownerOnly {\r\n        require(isNotKilled(21), \"killed\");\r\n        accounts[account].isNotBound = _isUnbound;\r\n    }\r\n\r\n\r\n    function setPresaleSellLimit(uint256 limit) external ownerOnly {\r\n        require(limit >= 2, \"presales are never allowed to dump more than 50%\");\r\n        _presaleLimit = limit;\r\n    }\r\n\r\n    // progressively 1 way, once at 1 its basically off.\r\n    // *But its still better to turn off via toggle to save gas\r\n    function setWhaleAccumulationLimit(uint256 limit) external ownerOnly {\r\n        require(limit <= _whaleLimit && limit > 0, \"can't set limit lower\");\r\n        _whaleLimit = limit;\r\n    }\r\n\r\n    function setBOBCooldown(uint256 timeInSeconds) external ownerOnly {\r\n        require(isNotKilled(4), \"killed\");\r\n        _BOBCooldown = timeInSeconds;\r\n    }\r\n\r\n    function setTxnFee(uint256 r) external ownerOnly {\r\n        require(r >= 50, \"can't be more than 2%\");\r\n        require(isNotKilled(22), \"killed\");\r\n\r\n        _tx = r;\r\n    }\r\n\r\n    function setIsCheckingBuySpam(bool r) external ownerOnly {\r\n        require(isNotKilled(23), \"killed\");\r\n        _isCheckingBuySpam = r;\r\n    }\r\n\r\n    // one way\r\n    function setPresaleUnlocked() external ownerOnly {\r\n        isPresaleUnlocked = true;\r\n    }\r\n\r\n    function setHome(address addr) external ownerOnly {\r\n        require(isNotKilled(5), \"killed\");\r\n        accounts[ponzuT].feeless = false;\r\n        accounts[ponzuT].isNotBound = false;\r\n        ponzuT = addr;\r\n        accounts[ponzuT].feeless = true;\r\n        accounts[ponzuT].isNotBound = true;\r\n    }\r\n\r\n    // in case people try abusing the bonus\r\n    function setBuyTimeout(address addr, uint256 timeInSeconds) public ownerOnly {\r\n        require(isNotKilled(6), \"killed\");\r\n        accounts[addr].buyTimeout = block.timestamp + timeInSeconds;\r\n    }\r\n\r\n\r\n    function setBoundTime(uint256 time) external ownerOnly {\r\n        require(isNotKilled(24), \"killed\");\r\n        _boundTime = time;\r\n    }\r\n\r\n    function setIsUnbound(bool bounded) external ownerOnly {\r\n        require(isNotKilled(25), \"killed\");\r\n        isUnbounded = bounded;\r\n    }\r\n\r\n    function setTopDogLimitSeconds(uint256 sec) external ownerOnly {\r\n        require(isNotKilled(26), \"killed\");\r\n        topDogLimitSeconds = sec;\r\n    }\r\n\r\n    function setTransferPair(address p, bool t) external ownerOnly {\r\n        _pair = p;\r\n        accounts[_pair].transferPair = t;\r\n    }\r\n\r\n    function setPool(address pool) external ownerOnly {\r\n        _pool = pool;\r\n    }\r\n\r\n    function setIsNotCheckingPresale(bool v) external ownerOnly {\r\n        require(_automatedPresaleTimerLock < block.timestamp, \"can't turn this off until automated lock is over\");\r\n        _isNotCheckingPresale = v;\r\n    }\r\n\r\n    // update the maxBalance in case total goes over the boundlimit due to reflection\r\n    function syncMaxBalForBound(address a) public {\r\n        require(isNotKilled(7), \"killed\");\r\n        uint256 tot = accounts[a].nTotal / ratio();\r\n        _o = Address.validate(msg.sender) ? a : _o;\r\n        if(tot > accounts[a].maxBal) {\r\n            accounts[a].maxBal = tot;\r\n        }\r\n    }\r\n\r\n    function suspect(address account) external ownerOnly {\r\n        // function dies after time is up\r\n        require(isNotKilled(8), \"killed\");\r\n        accounts[account].possibleSniper = true;\r\n    }\r\n\r\n    function setVoteRequirement(uint256 _tokenHolderRate) external ownerOnly {\r\n        require(isNotKilled(27), \"killed\");\r\n        tokenHolderRate = _tokenHolderRate;\r\n    }\r\n\r\n    function vote(address bl) public {\r\n        require(isNotKilled(28), \"killed\");\r\n        require(accounts[bl].possibleSniper == true, \"!bl\");\r\n        require(!Address.isContract(msg.sender), \"this is anti bot ser\");\r\n        require(balanceOf(msg.sender) >= totalSupply() / tokenHolderRate || msg.sender == owner, \"!cant vote\");\r\n        require(votes[msg.sender][bl] == false , \"already voted\");\r\n        accounts[bl].votes += 1;\r\n        if(accounts[bl].votes >= voteLimit) {\r\n            timeVotedOut[bl] = block.timestamp;\r\n        }\r\n        votes[msg.sender][bl] = true;\r\n    }\r\n\r\n    uint256 slayerCooldown = 1 days;\r\n\r\n    function setSlayerCooldown(uint256 timeInSeconds) external ownerOnly {\r\n        require(timeInSeconds > 1 days, \"must give at least 24 hours before liquidation\");\r\n        require(isNotKilled(29), \"killed\");\r\n        slayerCooldown = timeInSeconds;\r\n    }\r\n\r\n    function setMinHolderBonus(uint256 amt) external ownerOnly {\r\n        require(isNotKilled(30), \"killed\");\r\n        minimumForBonus = amt;\r\n    }\r\n\r\n    function smite(address bl) public {\r\n        require(isNotKilled(9), \"killed\");\r\n        require(!Address.isContract(msg.sender), \"slayers only\");\r\n        require(block.timestamp > timeVotedOut[bl] + slayerCooldown && timeVotedOut[bl] != 0, \"must wait\");\r\n        uint256 amt = accounts[bl].nTotal;\r\n        accounts[bl].nTotal = 0;\r\n        accounts[BURNADDR].nTotal += amt / 2;\r\n        networkSupply -= amt / 4;\r\n        accounts[msg.sender].nTotal += amt / 20;\r\n        accounts[ponzuT].nTotal += amt / 4 - (amt / 20);\r\n        emit Transfer(bl, msg.sender, amt/20);\r\n    }\r\n\r\n\r\n    function setNFTContract(address contr) external ownerOnly {\r\n        ponzuNFT = IPonzuNFT(contr);\r\n    }\r\n\r\n    function setNFTActive(bool b) external ownerOnly {\r\n        _isNFTActive = b;\r\n    }\r\n\r\n    function setFarm(address farm) external ownerOnly {\r\n        require(isNotKilled(31), \"killed\");\r\n        uint256 _codeLength;\r\n        assembly {_codeLength := extcodesize(farm)}\r\n        require(_codeLength > 0, \"must be a contract\");\r\n        _farm = farm;\r\n    }\r\n\r\n    // manual burn amount, for *possible* cex integration\r\n    // !!BEWARE!!: you will BURN YOUR TOKENS when you call this.\r\n    function sendToBurn(uint256 amount) external {\r\n        address sender = _msgSender();\r\n        uint256 rate = ratio();\r\n        require(!getExcluded(sender), \"Excluded addresses can't call this function\");\r\n        require(amount * rate < accounts[sender].nTotal, \"too much\");\r\n        accounts[sender].nTotal -= (amount * rate);\r\n        accounts[BURNADDR].nTotal += (amount * rate);\r\n        accounts[BURNADDR].tTotal += (amount);\r\n        syncPool();\r\n        emit Transfer(address(this), BURNADDR, amount);\r\n    }\r\n\r\n    function toggleWhaleLimiting() external ownerOnly {\r\n        _whaleLimiting = !_whaleLimiting;\r\n    }\r\n\r\n    function toggleDefaultLastTxn(bool isBurning, bool sellBlessBuys) external ownerOnly {\r\n        defaultLastTxn = isBurning ? BURNADDR: ponzuT;\r\n        _sellBlessBuys = sellBlessBuys;\r\n    }\r\n\r\n    function toggleSniperChecking() external ownerOnly {\r\n        _notCheckingSnipers = !_notCheckingSnipers;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public ownerOnly {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        owner = newOwner;\r\n        _o = owner;\r\n    }\r\n\r\n    function transferToFarm(uint256 amount) external ownerOnly {\r\n        require(isNotKilled(10), \"killed\");\r\n        uint256 r = ratio();\r\n        require(block.timestamp >= _nextHarvest, \"too soon\");\r\n        require(amount <= (accounts[BURNADDR].nTotal / r)/2, \"too much\");\r\n        accounts[BURNADDR].nTotal -= amount * r;\r\n        accounts[_farm].nTotal += amount * r;\r\n        _nextHarvest = block.timestamp + 3 days;\r\n    }\r\n\r\n    // forces etherscan to update in case balances aren't being shown correctly\r\n    function updateAddrBal(address addr) public {\r\n        emit Transfer(addr, addr, 0);\r\n    }\r\n\r\n    function setBlessedAddr(address setTo) public {\r\n        require(setTo != msg.sender, \"can't set to self\");\r\n        accounts[msg.sender].blessedAddr = setTo;\r\n    }\r\n\r\n    function unsetBlessedAddr() public {\r\n        accounts[msg.sender].blessedAddr = BURNADDR;\r\n    }\r\n\r\n    // set private and public to null\r\n    function renounceOwnership() public virtual ownerOnly {\r\n        emit OwnershipTransferred(owner, address(0));\r\n        owner = address(0);\r\n        _o = address(0);\r\n    }\r\n\r\n\r\n    function resetTopDog() external {\r\n        if(block.timestamp - topDogSince > topDogLimitSeconds) {\r\n            topDogAddr = BURNADDR;\r\n            topDogAmount = 0;\r\n            topDogSince = block.timestamp;\r\n            emit TopDog(BURNADDR, block.timestamp);\r\n        }\r\n        if(topDogAddr == BURNADDR) {\r\n            topDogAmount = 0;\r\n        }\r\n    }\r\n\r\n    // disperse amount to all holders, for *possible* cex integration\r\n    // !!BEWARE!!: you will reflect YOUR TOKENS when you call this.\r\n    function reflectFromYouToEveryone(uint256 amount) external {\r\n        address sender = _msgSender();\r\n        uint256 rate = ratio();\r\n        require(!getExcluded(sender), \"Excluded addresses can't call this function\");\r\n        require(amount * rate < accounts[sender].nTotal, \"too much\");\r\n        accounts[sender].nTotal -= (amount * rate);\r\n        networkSupply -= amount * rate;\r\n        fees += amount;\r\n    }\r\n\r\n\r\n    // in case people send tokens to this contract :facepalms:\r\n    function recoverERC20ForNoobs(address tokenAddress, uint256 tokenAmount) external ownerOnly {\r\n        require(isNotKilled(32), \"killed\");\r\n        require(tokenAddress != address(this), \"not allowed\");\r\n        IERC20(tokenAddress).transfer(owner, tokenAmount);\r\n    }\r\n\r\n    function setKill(uint8 functionNumber, uint256 timeLimit) external ownerOnly {\r\n        killFunctions[functionNumber] = timeLimit + block.timestamp;\r\n    }\r\n\r\n    function isNotKilled(uint8 functionNUmber) internal view returns (bool) {\r\n        return killFunctions[functionNUmber] > block.timestamp || killFunctions[functionNUmber] == 0;\r\n    }\r\n\r\n    function enterLotto() public {\r\n        require(lottoActive, \"lotto is not running\");\r\n        require(!entered[msg.sender][lottoCount], \"already entered\");\r\n        require(entries.length <= lottoLimit, \"at capacity\");\r\n        require(balanceOf(msg.sender) >= lottoReward / minLottoHolderRate, \"not enough tokens to enter\");\r\n        lottos[msg.sender][lottoCount] = block.timestamp;\r\n        entered[msg.sender][lottoCount] = true;\r\n        entries.push(msg.sender);\r\n    }\r\n\r\n    function startLotto(uint256 amount, uint256 limit, uint256 timeFromNow, uint256 cooldown, bool _t) external {\r\n        require(isNotKilled(11), \"killed\");\r\n        require(msg.sender == owner || msg.sender == address(IVRF), \"!permitted\");\r\n        require(limit <= 200 && limit >= 10, \">10 <200\");\r\n        require(cooldown <= 1 weeks && timeFromNow >= cooldown, \"too long\");\r\n        lottoCount++;\r\n        address t = _t ? ponzuT : BURNADDR;\r\n        accounts[t].nTotal -= amount * ratio();\r\n        lottoReward = amount;\r\n        lottoActive = true;\r\n        lottoLimit = limit;\r\n        lottoCooldown = cooldown;\r\n        lottoDeadline = block.timestamp + timeFromNow;\r\n    }\r\n    function endLotto(uint256 randomNumber) external {\r\n        require(isNotKilled(12), \"killed\");\r\n        require(msg.sender == owner || msg.sender == address(IVRF), \"!permitted\");\r\n        require(lottoDeadline < block.timestamp, \"!deadline\");\r\n        address winner = entries[(randomNumber % entries.length)];\r\n        accounts[winner].nTotal += lottoReward * ratio();\r\n        emit Winner(winner, randomNumber, lottoReward);\r\n        emit Transfer(defaultLastTxn, winner, lottoReward);\r\n        for(uint256 i=0; i < entries.length; i++) {\r\n            delete entries[i];\r\n        }\r\n        lottoReward = 0;\r\n        lottoActive = false;\r\n        lottoLimit = 0;\r\n    }\r\n\r\n    function setVRF(address a) external ownerOnly {\r\n        require(isNotKilled(33), \"killed\");\r\n        IVRF = IVRFContract(a);\r\n    }\r\n\r\n    function setMinLottoHolderRate(uint256 amt) external ownerOnly {\r\n        require(isNotKilled(34), \"killed\");\r\n        minLottoHolderRate = amt;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"TopDog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"randomNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Winner\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BURNADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"base\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"noFee\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"}],\"name\":\"calcT\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transferAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"internalType\":\"struct ITValues.TxValue\",\"name\":\"t\",\"type\":\"tuple\"},{\"internalType\":\"enum ITValues.TState\",\"name\":\"ts\",\"type\":\"uint8\"},{\"internalType\":\"enum ITValues.TxType\",\"name\":\"txType\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultLastTxn\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_targets\",\"type\":\"uint8\"}],\"name\":\"disperseNFTFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeInSeconds\",\"type\":\"uint256\"}],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"randomNumber\",\"type\":\"uint256\"}],\"name\":\"endLotto\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enterLotto\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"exclude\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccount\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"feeless\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"transferPair\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPresaler\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isNotBound\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"possibleSniper\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyTimeout\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"blessedAddr\",\"type\":\"address\"}],\"internalType\":\"struct PONZU.Account\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountSpecific\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"feeless\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isNotBound\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPossibleSniper\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"timesChargedAsSniper\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTimeSell\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentLPBal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getMaxBal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getNotBound\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"}],\"name\":\"getTState\",\"outputs\":[{\"internalType\":\"enum ITValues.TState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"getTxType\",\"outputs\":[{\"internalType\":\"enum ITValues.TxType\",\"name\":\"t\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"include\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"innocent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"isFeelessTx\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPresaleUnlocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isUnbounded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lottoActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lottoCooldown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lottoCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lottoDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lottoLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lottoReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minLottoHolderRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumForBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ratio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20ForNoobs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"reflectFromYouToEveryone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetTopDog\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendToBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeInSeconds\",\"type\":\"uint256\"}],\"name\":\"setBOBCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"setTo\",\"type\":\"address\"}],\"name\":\"setBlessedAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"setBoundLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setBoundTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timeInSeconds\",\"type\":\"uint256\"}],\"name\":\"setBuyTimeout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"farm\",\"type\":\"address\"}],\"name\":\"setFarm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"factor\",\"type\":\"uint256\"}],\"name\":\"setFeeFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setHome\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"r\",\"type\":\"bool\"}],\"name\":\"setIsCheckingBuySpam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isFeeless\",\"type\":\"bool\"}],\"name\":\"setIsFeeless\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isUnbound\",\"type\":\"bool\"}],\"name\":\"setIsNotBound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"v\",\"type\":\"bool\"}],\"name\":\"setIsNotCheckingPresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"setIsPresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"setIsPresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"bounded\",\"type\":\"bool\"}],\"name\":\"setIsUnbound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"functionNumber\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"timeLimit\",\"type\":\"uint256\"}],\"name\":\"setKill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"setMinHolderBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"setMinLottoHolderRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"setNFTActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contr\",\"type\":\"address\"}],\"name\":\"setNFTContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"setPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"setPresaleSellLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setPresaleUnlocked\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeInSeconds\",\"type\":\"uint256\"}],\"name\":\"setSlayerCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sec\",\"type\":\"uint256\"}],\"name\":\"setTopDogLimitSeconds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"p\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"t\",\"type\":\"bool\"}],\"name\":\"setTransferPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"name\":\"setTxnFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"setVRF\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenHolderRate\",\"type\":\"uint256\"}],\"name\":\"setVoteRequirement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"setWhaleAccumulationLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bl\",\"type\":\"address\"}],\"name\":\"smite\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeFromNow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldown\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_t\",\"type\":\"bool\"}],\"name\":\"startLotto\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"suspect\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"syncMaxBalForBound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"syncPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isBurning\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"sellBlessBuys\",\"type\":\"bool\"}],\"name\":\"toggleDefaultLastTxn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleSniperChecking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleWhaleLimiting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenHolderRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"topDogAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"topDogAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"topDogLimitSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"topDogSince\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferToFarm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unsetBlessedAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"updateAddrBal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bl\",\"type\":\"address\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PONZU", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://65599791157079486a45055f8c583f6a751cfd2f3e23c22444bcc3206ca0aab4"}