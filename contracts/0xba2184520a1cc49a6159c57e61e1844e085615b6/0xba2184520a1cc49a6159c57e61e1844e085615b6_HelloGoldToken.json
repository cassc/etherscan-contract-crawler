{"SourceCode": "pragma solidity ^0.4.11;\r\n\r\n\r\ncontract DoNotDeployThisGetTheRightOneCosParityPutsThisOnTop {\r\n    uint256 nothing;\r\n\r\n    function DoNotDeployThisGetTheRightOneCosParityPutsThisOnTop() {\r\n        nothing = 27;\r\n    }\r\n}\r\n\r\n\r\n//*************** Ownable\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    \r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n//***********Pausible\r\n\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS paused\r\n   */\r\n  modifier whenNotPaused() {\r\n    require (!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS NOT paused\r\n   */\r\n  modifier whenPaused {\r\n    require (paused) ;\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused returns (bool) {\r\n    paused = true;\r\n    Pause();\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused returns (bool) {\r\n    paused = false;\r\n    Unpause();\r\n    return true;\r\n  }\r\n}\r\n\r\n//*************ERC20\r\n\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n//*************** SafeMath\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n}\r\n\r\n//**************** StandardToken\r\n\r\ncontract StandardToken is ERC20, SafeMath {\r\n\r\n  /**\r\n   * @dev Fix for the ERC20 short address attack.\r\n   */\r\n  modifier onlyPayloadSize(uint size) {\r\n     require(msg.data.length >= size + 4);\r\n     _;\r\n  }\r\n\r\n  mapping(address => uint) balances;\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32)  returns (bool success){\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) returns (bool success) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met\r\n    // if (_value > _allowance) throw;\r\n\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\ncontract GBT {\r\n  function parentChange(address,uint);\r\n  function parentFees(address);\r\n  function setHGT(address _hgt);\r\n}\r\n\r\n//************ HELLOGOLDTOKEN\r\n\r\ncontract HelloGoldToken is ERC20, SafeMath, Pausable, StandardToken {\r\n\r\n  string public name;\r\n  string public symbol;\r\n  uint8  public decimals;\r\n\r\n  GBT  goldtoken;\r\n  \r\n\r\n  function setGBT(address gbt_) onlyOwner {\r\n    goldtoken = GBT(gbt_);\r\n  }\r\n\r\n  function GBTAddress() constant returns (address) {\r\n    return address(goldtoken);\r\n  }\r\n\r\n  function HelloGoldToken(address _reserve) {\r\n    name = \"HelloGold Token\";\r\n    symbol = \"HGT\";\r\n    decimals = 8;\r\n \r\n    totalSupply = 1 * 10 ** 9 * 10 ** uint256(decimals);\r\n    balances[_reserve] = totalSupply;\r\n  }\r\n\r\n\r\n  function parentChange(address _to) internal {\r\n    require(address(goldtoken) != 0x0);\r\n    goldtoken.parentChange(_to,balances[_to]);\r\n  }\r\n  function parentFees(address _to) internal {\r\n    require(address(goldtoken) != 0x0);\r\n    goldtoken.parentFees(_to);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success){\r\n    parentFees(_from);\r\n    parentFees(_to);\r\n    success = super.transferFrom(_from,_to,_value);\r\n    parentChange(_from);\r\n    parentChange(_to);\r\n    return;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) whenNotPaused returns (bool success)  {\r\n    parentFees(msg.sender);\r\n    parentFees(_to);\r\n    success = super.transfer(_to,_value);\r\n    parentChange(msg.sender);\r\n    parentChange(_to);\r\n    return;\r\n  }\r\n\r\n  function approve(address _spender, uint _value) whenNotPaused returns (bool success)  {\r\n    return super.approve(_spender,_value);\r\n  }\r\n}\r\n\r\n//********* GOLDFEES ************************\r\n\r\ncontract GoldFees is SafeMath,Ownable {\r\n    // e.g. if rate = 0.0054\r\n    //uint rateN = 9999452055;\r\n    uint rateN = 9999452054794520548;\r\n    uint rateD = 19;\r\n    uint public maxDays;\r\n    uint public maxRate;\r\n\r\n    \r\n    function GoldFees() {\r\n        calcMax();\r\n    }\r\n\r\n    function calcMax() {\r\n        maxDays = 1;\r\n        maxRate = rateN;\r\n        \r\n        \r\n        uint pow = 2;\r\n        do {\r\n            uint newN = rateN ** pow;\r\n            if (newN / maxRate != maxRate) {\r\n                maxDays = pow / 2;\r\n                break;\r\n            }\r\n            maxRate = newN;\r\n            pow *= 2;\r\n        } while (pow < 2000);\r\n        \r\n    }\r\n\r\n    function updateRate(uint256 _n, uint256 _d) onlyOwner{\r\n        rateN = _n;\r\n        rateD = _d;\r\n        calcMax();\r\n    }\r\n    \r\n    function rateForDays(uint256 numDays) constant returns (uint256 rate) {\r\n        if (numDays <= maxDays) {\r\n            uint r = rateN ** numDays;\r\n            uint d = rateD * numDays;\r\n            if (d > 18) {\r\n                uint div =  10 ** (d-18);\r\n                rate = r / div;\r\n            } else {\r\n                div = 10 ** (18 - d);\r\n                rate = r * div;\r\n            }\r\n        } else {\r\n            uint256 md1 = numDays / 2;\r\n            uint256 md2 = numDays - md1;\r\n             uint256 r2;\r\n\r\n            uint256 r1 = rateForDays(md1);\r\n            if (md1 == md2) {\r\n                r2 = r1;\r\n            } else {\r\n                r2 = rateForDays(md2);\r\n            }\r\n           \r\n\r\n            //uint256 r1 = rateForDays(maxDays);\r\n            //uint256 r2 = rateForDays(numDays-maxDays);\r\n            rate  = safeMul( r1 , r2)  / 10 ** 18;\r\n        }\r\n        return; \r\n        \r\n    }\r\n\r\n    uint256 constant public UTC2MYT = 1483200000;\r\n\r\n    function wotDay(uint256 time) returns (uint256) {\r\n        return (time - UTC2MYT) / (1 days);\r\n    }\r\n\r\n    // minimum fee is 1 unless same day\r\n    function calcFees(uint256 start, uint256 end, uint256 startAmount) constant returns (uint256 amount, uint256 fee) {\r\n        if (startAmount == 0) return;\r\n        uint256 numberOfDays = wotDay(end) - wotDay(start);\r\n        if (numberOfDays == 0) {\r\n            amount = startAmount;\r\n            return;\r\n        }\r\n        amount = (rateForDays(numberOfDays) * startAmount) / (1 ether);\r\n        if ((fee == 0) && (amount !=  0)) amount--;\r\n        fee = safeSub(startAmount,amount);\r\n    }\r\n}\r\n\r\n//******************** GoldBackedToken\r\n\r\ncontract GoldBackedToken is Ownable, SafeMath, ERC20, Pausable {\r\n\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n  event DeductFees(address indexed owner,uint256 amount);\r\n\r\n  event TokenMinted(address destination, uint256 amount);\r\n  event TokenBurned(address source, uint256 amount);\r\n  \r\n\tstring public name = \"HelloGold Gold Backed Token\";\r\n\tstring public symbol = \"GBT\";\r\n\tuint256 constant public  decimals = 18;  // same as ETH\r\n\tuint256 constant public  hgtDecimals = 8;\r\n\t\t\r\n\tuint256 constant public allocationPool = 1 *  10**9 * 10**hgtDecimals;      // total HGT holdings\r\n\tuint256\tconstant public\tmaxAllocation  = 38 * 10**5 * 10**decimals;\t\t\t// max GBT that can ever ever be given out\r\n\tuint256\t         public\ttotAllocation;\t\t\t// amount of GBT so far\r\n\t\r\n\taddress\t\t\t public feeCalculator;\r\n\taddress\t\t     public HGT;\t\t\t\t\t// HGT contract address\r\n\r\n\r\n\r\n\tfunction setFeeCalculator(address newFC) onlyOwner {\r\n\t\tfeeCalculator = newFC;\r\n\t}\r\n\r\n\r\n\tfunction calcFees(uint256 from, uint256 to, uint256 amount) returns (uint256 val, uint256 fee) {\r\n\t\treturn GoldFees(feeCalculator).calcFees(from,to,amount);\r\n\t}\r\n\r\n\tfunction GoldBackedToken(address feeCalc) {\r\n\t\tfeeCalculator = feeCalc;\r\n\t}\r\n\r\n    struct allocation { \r\n        uint256     amount;\r\n        uint256     date;\r\n    }\r\n\t\r\n\tallocation[]   public allocationsOverTime;\r\n\tallocation[]   public currentAllocations;\r\n\r\n\tfunction currentAllocationLength() constant returns (uint256) {\r\n\t\treturn currentAllocations.length;\r\n\t}\r\n\r\n\tfunction aotLength() constant returns (uint256) {\r\n\t\treturn allocationsOverTime.length;\r\n\t}\r\n\r\n\t\r\n    struct Balance {\r\n        uint256 amount;                 // amount through update or transfer\r\n        uint256 lastUpdated;            // DATE last updated\r\n        uint256 nextAllocationIndex;    // which allocationsOverTime record contains next update\r\n        uint256 allocationShare;        // the share of allocationPool that this holder gets (means they hold HGT)\r\n    }\r\n\r\n\t/*Creates an array with all balances*/\r\n\tmapping (address => Balance) public balances;\r\n\tmapping (address => mapping (address => uint)) allowed;\r\n\t\r\n\tfunction update(address where) internal {\r\n        uint256 pos;\r\n\t\tuint256 fees;\r\n\t\tuint256 val;\r\n        (val,fees,pos) = updatedBalance(where);\r\n\t    balances[where].nextAllocationIndex = pos;\r\n\t    balances[where].amount = val;\r\n        balances[where].lastUpdated = now;\r\n\t}\r\n\t\r\n\tfunction updatedBalance(address where) constant public returns (uint val, uint fees, uint pos) {\r\n\t\tuint256 c_val;\r\n\t\tuint256 c_fees;\r\n\t\tuint256 c_amount;\r\n\r\n\t\t(val, fees) = calcFees(balances[where].lastUpdated,now,balances[where].amount);\r\n\r\n\t    pos = balances[where].nextAllocationIndex;\r\n\t\tif ((pos < currentAllocations.length) &&  (balances[where].allocationShare != 0)) {\r\n\r\n\t\t\tc_amount = currentAllocations[balances[where].nextAllocationIndex].amount * balances[where].allocationShare / allocationPool;\r\n\r\n\t\t\t(c_val,c_fees)   = calcFees(currentAllocations[balances[where].nextAllocationIndex].date,now,c_amount);\r\n\r\n\t\t} \r\n\r\n\t    val  += c_val;\r\n\t\tfees += c_fees;\r\n\t\tpos   = currentAllocations.length;\r\n\t}\r\n\r\n    function balanceOf(address where) constant returns (uint256 val) {\r\n        uint256 fees;\r\n\t\tuint256 pos;\r\n        (val,fees,pos) = updatedBalance(where);\r\n        return ;\r\n    }\r\n\r\n\tevent Allocation(uint256 amount, uint256 date);\r\n\tevent FeeOnAllocation(uint256 fees, uint256 date);\r\n\r\n\tevent PartComplete();\r\n\tevent StillToGo(uint numLeft);\r\n\tuint256 public partPos;\r\n\tuint256 public partFees;\r\n\tuint256 partL;\r\n\tallocation[]   public partAllocations;\r\n\r\n\tfunction partAllocationLength() constant returns (uint) {\r\n\t\treturn partAllocations.length;\r\n\t}\r\n\r\n\tfunction addAllocationPartOne(uint newAllocation,uint numSteps) onlyOwner{\r\n\t\tuint256 thisAllocation = newAllocation;\r\n\r\n\t\trequire(totAllocation < maxAllocation);\t\t// cannot allocate more than this;\r\n\r\n\t\tif (currentAllocations.length > partAllocations.length) {\r\n\t\t\tpartAllocations = currentAllocations;\r\n\t\t}\r\n\r\n\t\tif (totAllocation + thisAllocation > maxAllocation) {\r\n\t\t\tthisAllocation = maxAllocation - totAllocation;\r\n\t\t\tlog0(\"max alloc reached\");\r\n\t\t}\r\n\t\ttotAllocation += thisAllocation;\r\n\r\n\t\tAllocation(thisAllocation,now);\r\n\r\n        allocation memory newDiv;\r\n        newDiv.amount = thisAllocation;\r\n        newDiv.date = now;\r\n\t\t// store into history\r\n\t    allocationsOverTime.push(newDiv);\r\n\t\t// add this record to the end of currentAllocations\r\n\t\tpartL = partAllocations.push(newDiv);\r\n\t\t// update all other records with calcs from last record\r\n\t\tif (partAllocations.length < 2) { // no fees to consider\r\n\t\t\tPartComplete();\r\n\t\t\tcurrentAllocations = partAllocations;\r\n\t\t\tFeeOnAllocation(0,now);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t//\r\n\t\t// The only fees that need to be collected are the fees on location zero.\r\n\t\t// Since they are the last calculated = they come out with the break\r\n\t\t//\r\n\t\tfor (partPos = partAllocations.length - 2; partPos >= 0; partPos-- ){\r\n\t\t\t(partAllocations[partPos].amount,partFees) = calcFees(partAllocations[partPos].date,now,partAllocations[partPos].amount);\r\n\r\n\t\t\tpartAllocations[partPos].amount += partAllocations[partL - 1].amount;\r\n\t\t\tpartAllocations[partPos].date    = now;\r\n\t\t\tif ((partPos == 0) || (partPos == partAllocations.length-numSteps)){\r\n\t\t\t\tbreak; \r\n\t\t\t}\r\n\t\t}\r\n\t\tif (partPos != 0) {\r\n\t\t\tStillToGo(partPos);\r\n\t\t\treturn; // not done yet\r\n\t\t}\r\n\t\tPartComplete();\r\n\t\tFeeOnAllocation(partFees,now);\r\n\t\tcurrentAllocations = partAllocations;\r\n\t}\r\n\r\n\tfunction addAllocationPartTwo(uint numSteps) onlyOwner {\r\n\t\trequire(numSteps > 0);\r\n\t\trequire(partPos > 0);\r\n\t\tfor (uint i = 0; i < numSteps; i++ ){\r\n\t\t\tpartPos--;\r\n\t\t\t(partAllocations[partPos].amount,partFees) = calcFees(partAllocations[partPos].date,now,partAllocations[partPos].amount);\r\n\r\n\t\t\tpartAllocations[partPos].amount += partAllocations[partL - 1].amount;\r\n\t\t\tpartAllocations[partPos].date    = now;\r\n\t\t\tif (partPos == 0) {\r\n\t\t\t\tbreak; \r\n\t\t\t}\r\n\t\t}\r\n\t\tif (partPos != 0) {\r\n\t\t\tStillToGo(partPos);\r\n\t\t\treturn; // not done yet\r\n\t\t}\r\n\t\tPartComplete();\r\n\t\tFeeOnAllocation(partFees,now);\r\n\t\tcurrentAllocations = partAllocations;\r\n\t}\r\n\r\n\r\n\tfunction setHGT(address _hgt) onlyOwner {\r\n\t\tHGT = _hgt;\r\n\t}\r\n\r\n\tfunction parentFees(address where) whenNotPaused {\r\n\t\trequire(msg.sender == HGT);\r\n\t    update(where);\t\t\r\n\t}\r\n\t\r\n\tfunction parentChange(address where, uint newValue) whenNotPaused { // called when HGT balance changes\r\n\t\trequire(msg.sender == HGT);\r\n\t    balances[where].allocationShare = newValue;\r\n\t}\r\n\t\r\n\t/* send GBT */\r\n\tfunction transfer(address _to, uint256 _value) whenNotPaused returns (bool ok) {\r\n\t    update(msg.sender);              // Do this to ensure sender has enough funds.\r\n\t\tupdate(_to); \r\n\r\n        balances[msg.sender].amount = safeSub(balances[msg.sender].amount, _value);\r\n        balances[_to].amount = safeAdd(balances[_to].amount, _value);\r\n\r\n\t\tTransfer(msg.sender, _to, _value); //Notify anyone listening that this transfer took place\r\n        return true;\r\n\t}\r\n\r\n\tfunction transferFrom(address _from, address _to, uint _value) whenNotPaused returns (bool success) {\r\n\t\tvar _allowance = allowed[_from][msg.sender];\r\n\r\n\t    update(_from);              // Do this to ensure sender has enough funds.\r\n\t\tupdate(_to); \r\n\r\n\t\tbalances[_to].amount = safeAdd(balances[_to].amount, _value);\r\n\t\tbalances[_from].amount = safeSub(balances[_from].amount, _value);\r\n\t\tallowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n\t\tTransfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n  \tfunction approve(address _spender, uint _value) whenNotPaused returns (bool success) {\r\n\t\trequire((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n    \tallowed[msg.sender][_spender] = _value;\r\n    \tApproval(msg.sender, _spender, _value);\r\n    \treturn true;\r\n  \t}\r\n\r\n  \tfunction allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    \treturn allowed[_owner][_spender];\r\n  \t}\r\n\r\n\t// Minting Functions \r\n\taddress public authorisedMinter;\r\n\r\n\tfunction setMinter(address minter) onlyOwner {\r\n\t\tauthorisedMinter = minter;\r\n\t}\r\n\t\r\n\tfunction mintTokens(address destination, uint256 amount) {\r\n\t\trequire(msg.sender == authorisedMinter);\r\n\t\tupdate(destination);\r\n\t\tbalances[destination].amount = safeAdd(balances[destination].amount, amount);\r\n\t\tbalances[destination].lastUpdated = now;\r\n\t\tbalances[destination].nextAllocationIndex = currentAllocations.length;\r\n\t\tTokenMinted(destination,amount);\r\n\t}\r\n\r\n\tfunction burnTokens(address source, uint256 amount) {\r\n\t\trequire(msg.sender == authorisedMinter);\r\n\t\tupdate(source);\r\n\t\tbalances[source].amount = safeSub(balances[source].amount,amount);\r\n\t\tbalances[source].lastUpdated = now;\r\n\t\tbalances[source].nextAllocationIndex = currentAllocations.length;\r\n\t\tTokenBurned(source,amount);\r\n\t}\r\n}\r\n\r\n//**************** HelloGoldSale\r\n\r\ncontract HelloGoldSale is Pausable, SafeMath {\r\n\r\n  uint256 public decimals = 8;\r\n\r\n  uint256 public startDate = 1503892800;      // Monday, August 28, 2017 12:00:00 PM GMT+08:00\r\n  uint256 public endDate   = 1504497600;      // Monday, September 4, 2017 12:00:00 PM GMT+08:00\r\n\r\n  uint256 tranchePeriod = 1 weeks;\r\n\r\n  // address of HGT Token. HGT must Approve this contract to disburse 300M tokens\r\n  HelloGoldToken          token;\r\n\r\n  uint256 constant MaxCoinsR1      = 180 * 10**6 * 10**8;   // 180M HGT\r\n  uint256 public coinsRemaining    = 180 * 10**6 * 10**8; \r\n  uint256 coinsPerTier             =  20 * 10**6 * 10**8;   // 20M HGT\r\n  uint256 public coinsLeftInTier   =  20 * 10**6 * 10**8;\r\n\r\n  uint256 public minimumCap        =  0;   // 40M HGT\r\n\r\n  uint256 numTiers                  = 5;\r\n  uint16  public tierNo;\r\n  uint256 public preallocCoins;   // used for testing against cap (inc placement)\r\n  uint256 public purchasedCoins;  // used for testing against tier pricing\r\n  uint256 public ethRaised;\r\n  uint256 public personalMax        = 10 * 1 ether;     // max ether per person during public sale\r\n  uint256 public contributors;\r\n\r\n  address public cs;\r\n  address public multiSig;\r\n  address public HGT_Reserve;\r\n  \r\n  struct csAction  {\r\n      bool        passedKYC;\r\n      bool        blocked;\r\n  }\r\n\r\n  /* This creates an array with all balances */\r\n  mapping (address => csAction) public permissions;\r\n  mapping (address => uint256)  public deposits;\r\n\r\n  modifier MustBeEnabled(address x) {\r\n      require (!permissions[x].blocked) ;\r\n      require (permissions[x].passedKYC) ;\r\n      \r\n      _;\r\n  }\r\n\r\n  function HelloGoldSale(address _cs, address _hgt, address _multiSig, address _reserve) {\r\n    cs          = _cs;\r\n    token       = HelloGoldToken(_hgt);\r\n    multiSig    = _multiSig;\r\n    HGT_Reserve = _reserve;\r\n  }\r\n\r\n  // We only expect to use this to set/reset the start of the contract under exceptional circumstances\r\n  function setStart(uint256 when_) onlyOwner {\r\n      startDate = when_;\r\n      endDate = when_ + tranchePeriod;\r\n  }\r\n\r\n  modifier MustBeCs() {\r\n      require (msg.sender == cs) ;\r\n      \r\n      _;\r\n  }\r\n\r\n\r\n  // 1 ether = N HGT tokens \r\n  uint256[5] public hgtRates = [1248900000000,1196900000000,1144800000000,1092800000000,1040700000000];\r\n                      \r\n\r\n    /* Approve the account for operation */\r\n    function approve(address user) MustBeCs {\r\n        permissions[user].passedKYC = true;\r\n    }\r\n    \r\n    function block(address user) MustBeCs {\r\n        permissions[user].blocked = true;\r\n    }\r\n\r\n    function unblock(address user) MustBeCs {\r\n         permissions[user].blocked = false;\r\n    }\r\n\r\n    function newCs(address newCs) onlyOwner {\r\n        cs = newCs;\r\n    }\r\n\r\n    function setPeriod(uint256 period_) onlyOwner {\r\n        require (!funding()) ;\r\n        tranchePeriod = period_;\r\n        endDate = startDate + tranchePeriod;\r\n        if (endDate < now + tranchePeriod) {\r\n            endDate = now + tranchePeriod;\r\n        }\r\n    }\r\n\r\n    function when()  constant returns (uint256) {\r\n        return now;\r\n    }\r\n\r\n  function funding() constant returns (bool) {     \r\n    if (paused) return false;               // frozen\r\n    if (now < startDate) return false;      // too early\r\n    if (now > endDate) return false;        // too late\r\n    if (coinsRemaining == 0) return false;  // no more coins\r\n    if (tierNo >= numTiers ) return false;  // passed end of top tier. Tiers start at zero\r\n    return true;\r\n  }\r\n\r\n  function success() constant returns (bool succeeded) {\r\n    if (coinsRemaining == 0) return true;\r\n    bool complete = (now > endDate) ;\r\n    bool didOK = (coinsRemaining <= (MaxCoinsR1 - minimumCap)); // not even 40M Gone?? Aargh.\r\n    succeeded = (complete && didOK)  ;  // (out of steam but enough sold) \r\n    return ;\r\n  }\r\n\r\n  function failed() constant returns (bool didNotSucceed) {\r\n    bool complete = (now > endDate  );\r\n    bool didBad = (coinsRemaining > (MaxCoinsR1 - minimumCap));\r\n    didNotSucceed = (complete && didBad);\r\n    return;\r\n  }\r\n\r\n  \r\n  function () payable MustBeEnabled(msg.sender) whenNotPaused {    \r\n    createTokens(msg.sender,msg.value);\r\n  }\r\n\r\n  function linkCoin(address coin) onlyOwner {\r\n    token = HelloGoldToken(coin);\r\n  }\r\n\r\n  function coinAddress() constant returns (address) {\r\n      return address(token);\r\n  }\r\n\r\n  // hgtRates in whole tokens per ETH\r\n  // max individual contribution in whole ETH\r\n  function setHgtRates(uint256 p0,uint256 p1,uint256 p2,uint256 p3,uint256 p4, uint256 _max ) onlyOwner {\r\n              require (now < startDate) ;\r\n              hgtRates[0]   = p0 * 10**8;\r\n              hgtRates[1]   = p1 * 10**8;\r\n              hgtRates[2]   = p2 * 10**8;\r\n              hgtRates[3]   = p3 * 10**8;\r\n              hgtRates[4]   = p4 * 10**8;\r\n              personalMax = _max * 1 ether;           // max ETH per person\r\n  }\r\n\r\n  \r\n  event Purchase(address indexed buyer, uint256 level,uint256 value, uint256 tokens);\r\n  event Reduction(string msg, address indexed buyer, uint256 wanted, uint256 allocated);\r\n  \r\n  function createTokens(address recipient, uint256 value) private {\r\n    uint256 totalTokens;\r\n    uint256 hgtRate;\r\n    require (funding()) ;\r\n    require (value > 1 finney) ;\r\n    require (deposits[recipient] < personalMax);\r\n\r\n    uint256 maxRefund = 0;\r\n    if ((deposits[msg.sender] + value) > personalMax) {\r\n        maxRefund = deposits[msg.sender] + value - personalMax;\r\n        value -= maxRefund;\r\n        log0(\"maximum funds exceeded\");\r\n    }  \r\n\r\n    uint256 val = value;\r\n\r\n    ethRaised = safeAdd(ethRaised,value);\r\n    if (deposits[recipient] == 0) contributors++;\r\n    \r\n    \r\n    do {\r\n      hgtRate = hgtRates[tierNo];                 // hgtRate must include the 10^8\r\n      uint tokens = safeMul(val, hgtRate);      // (val in eth * 10^18) * #tokens per eth\r\n      tokens = safeDiv(tokens, 1 ether);      // val is in ether, msg.value is in wei\r\n   \r\n      if (tokens <= coinsLeftInTier) {\r\n        uint256 actualTokens = tokens;\r\n        uint refund = 0;\r\n        if (tokens > coinsRemaining) { //can't sell desired # tokens\r\n            Reduction(\"in tier\",recipient,tokens,coinsRemaining);\r\n            actualTokens = coinsRemaining;\r\n            refund = safeSub(tokens, coinsRemaining ); // refund amount in tokens\r\n            refund = safeDiv(refund*1 ether,hgtRate );  // refund amount in ETH\r\n            // need a refund mechanism here too\r\n            coinsRemaining = 0;\r\n            val = safeSub( val,refund);\r\n        } else {\r\n            coinsRemaining  = safeSub(coinsRemaining,  actualTokens);\r\n        }\r\n        purchasedCoins  = safeAdd(purchasedCoins, actualTokens);\r\n\r\n        totalTokens = safeAdd(totalTokens,actualTokens);\r\n\r\n        require (token.transferFrom(HGT_Reserve, recipient,totalTokens)) ;\r\n\r\n        Purchase(recipient,tierNo,val,actualTokens); // event\r\n\r\n        deposits[recipient] = safeAdd(deposits[recipient],val); // in case of refund - could pull off etherscan\r\n        refund += maxRefund;\r\n        if (refund > 0) {\r\n            ethRaised = safeSub(ethRaised,refund);\r\n            recipient.transfer(refund);\r\n        }\r\n        if (coinsRemaining <= (MaxCoinsR1 - minimumCap)){ // has passed success criteria\r\n            if (!multiSig.send(this.balance)) {                // send funds to HGF\r\n                log0(\"cannot forward funds to owner\");\r\n            }\r\n        }\r\n        coinsLeftInTier = safeSub(coinsLeftInTier,actualTokens);\r\n        if ((coinsLeftInTier == 0) && (coinsRemaining != 0)) { // exact sell out of non final tier\r\n            coinsLeftInTier = coinsPerTier;\r\n            tierNo++;\r\n            endDate = now + tranchePeriod;\r\n        }\r\n        return;\r\n      }\r\n      // check that coinsLeftInTier >= coinsRemaining\r\n\r\n      uint256 coins2buy = min256(coinsLeftInTier , coinsRemaining); \r\n\r\n      endDate = safeAdd( now, tranchePeriod);\r\n      // Have bumped levels - need to modify end date here\r\n      purchasedCoins = safeAdd(purchasedCoins, coins2buy);  // give all coins remaining in this tier\r\n      totalTokens    = safeAdd(totalTokens,coins2buy);\r\n      coinsRemaining = safeSub(coinsRemaining,coins2buy);\r\n\r\n      uint weiCoinsLeftInThisTier = safeMul(coins2buy,1 ether);\r\n      uint costOfTheseCoins = safeDiv(weiCoinsLeftInThisTier, hgtRate);  // how much did that cost?\r\n\r\n      Purchase(recipient, tierNo,costOfTheseCoins,coins2buy); // event\r\n\r\n      deposits[recipient] = safeAdd(deposits[recipient],costOfTheseCoins);\r\n      val    = safeSub(val,costOfTheseCoins);\r\n      tierNo = tierNo + 1;\r\n      coinsLeftInTier = coinsPerTier;\r\n    } while ((val > 0) && funding());\r\n\r\n    // escaped because we passed the end of the universe.....\r\n    // so give them their tokens\r\n    require (token.transferFrom(HGT_Reserve, recipient,totalTokens)) ;\r\n\r\n    if ((val > 0) || (maxRefund > 0)){\r\n        Reduction(\"finished crowdsale, returning \",recipient,value,totalTokens);\r\n        // return the remainder !\r\n        recipient.transfer(val+maxRefund); // if you can't return the balance, abort whole process\r\n    }\r\n    if (!multiSig.send(this.balance)) {\r\n        ethRaised = safeSub(ethRaised,this.balance);\r\n        log0(\"cannot send at tier jump\");\r\n    }\r\n  }\r\n  \r\n  function allocatedTokens(address grantee, uint256 numTokens) onlyOwner {\r\n    require (now < startDate) ;\r\n    if (numTokens < coinsRemaining) {\r\n        coinsRemaining = safeSub(coinsRemaining, numTokens);\r\n       \r\n    } else {\r\n        numTokens = coinsRemaining;\r\n        coinsRemaining = 0;\r\n    }\r\n    preallocCoins = safeAdd(preallocCoins,numTokens);\r\n    require (token.transferFrom(HGT_Reserve,grantee,numTokens));\r\n  }\r\n\r\n  function withdraw() { // it failed. Come and get your ether.\r\n      if (failed()) {\r\n          if (deposits[msg.sender] > 0) {\r\n              uint256 val = deposits[msg.sender];\r\n              deposits[msg.sender] = 0;\r\n              msg.sender.transfer(val);\r\n          }\r\n      }\r\n  }\r\n\r\n  function complete() onlyOwner {  // this should not have to be called. Extreme measures.\r\n      if (success()) {\r\n          uint256 val = this.balance;\r\n          if (val > 0) {\r\n            if (!multiSig.send(val)) {\r\n                log0(\"cannot withdraw\");\r\n            } else {\r\n                log0(\"funds withdrawn\");\r\n            }\r\n          } else {\r\n              log0(\"nothing to withdraw\");\r\n          }\r\n      }\r\n  }\r\n\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GBTAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gbt_\",\"type\":\"address\"}],\"name\":\"setGBT\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_reserve\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "HelloGoldToken", "CompilerVersion": "v0.4.15+commit.bbb8e64f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c03281af336e2c25b41ff893a0e6ce1a932b23af", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://30e9b8ba2700c1618c855aa1f995bd948086b561fd83600668a189da268856fa"}