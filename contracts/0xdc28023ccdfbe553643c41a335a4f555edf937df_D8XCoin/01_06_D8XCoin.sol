// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import { ConcreteERC20 } from "./ConcreteERC20.sol";
import { Equity } from "./Equity.sol";
import { ID8XCoin } from "./ID8XCoin.sol";

contract D8XCoin is Equity {
    event PortalTraversal(
        bool isLeaving,
        uint256 amount,
        address wallet,
        uint256 totalAmountTraversedOut,
        uint256 totalSupply
    );
    event ChangeInitiated(string name, address from, address to);
    event ChangeExecuted(string name, address from, address to);
    address public portal;
    address public janusGuardian;
    address public newGuardian;
    address public newPortal;
    uint32 public timeLockStart;
    uint32 public immutable timeLockSeconds;
    uint256 public constant TOTALAMOUNT = 1e25; //10,000,000 * 1e18

    /**
     *
     * @param _epochDurationSec    epoch duration in seconds; e.g.,
     *                             7*24*60*60 ~ 7 days
     * @param _portal              address of portal contract
     * @param _timeLockSeconds     time lock for changes
     * @param _homeChain           if homechain, then mint
     */
    constructor(
        uint256 _epochDurationSec,
        address _portal,
        uint32 _timeLockSeconds,
        uint256 _homeChain
    ) Equity(_epochDurationSec) {
        require(_portal != address(0), "zero addr");
        janusGuardian = msg.sender;
        portal = _portal;
        timeLockSeconds = _timeLockSeconds;
        if (block.chainid != _homeChain) {
            // nothing minted on this chain
            // amount available is zero
            _totalLeftThroughPortal = TOTALAMOUNT;
            _totalSupply = TOTALAMOUNT;
        } else {
            // total amount is available on homechain
            _mint(msg.sender, TOTALAMOUNT);
        }
    }

    function name() external pure override returns (string memory) {
        return "D8X V1";
    }

    function symbol() external pure override returns (string memory) {
        return "D8X";
    }

    /**
     * Portal in some amount. Only portals can execute
     * From-address is generated by portal contract and
     * encodes chain-id in hex format (left zero padded)
     * @param _amount amount to be transferred
     * @param _from id for emitting chain in address-format
     * @param _wallet token receiver address
     */
    function portalIn(uint256 _amount, address _from, address _wallet) external {
        require(msg.sender == portal, "only portal");
        _beforeTokenTransfer(address(0), _wallet, _amount);
        _totalLeftThroughPortal -= _amount;
        _balances[_wallet] += _amount;
        emit Transfer(_from, _wallet, _amount);
    }

    /**
     * Portal out some amount, only portals can execute
     * To-address is generated by portal contract and
     * encodes chain-id in hex format (left zero padded)
     * @param _amount amount to be transferred
     * @param _wallet origination wallet
     * @param _to id for receiving chain in address-format
     */
    function portalOut(uint256 _amount, address _wallet, address _to) external {
        require(msg.sender == portal, "only portal");
        require(_balances[_wallet] >= _amount, "amt not available");
        _beforeTokenTransfer(_wallet, address(0), _amount);
        _balances[_wallet] -= _amount;
        _totalLeftThroughPortal += _amount;
        emit Transfer(_wallet, _to, _amount);
    }

    function changeOfTheGuard(address _newGuardian) external {
        require(msg.sender == janusGuardian, "only guardian");
        // slither-disable-next-line incorrect-equality
        require(timeLockStart == 0, "change queued");
        require(_newGuardian != address(0), "zero addr");
        newGuardian = _newGuardian;
        timeLockStart = uint32(block.timestamp);
        emit ChangeInitiated("guardian", janusGuardian, _newGuardian);
    }

    function replacePortal(address _newPortal) external {
        require(msg.sender == janusGuardian, "only guardian");
        if (_newPortal == address(0)) {
            // emergency halt
            emit ChangeExecuted("portal", portal, newPortal);
            portal = _newPortal;
            return;
        }
        // slither-disable-next-line incorrect-equality
        require(timeLockStart == 0, "change queued");
        newPortal = _newPortal;
        timeLockStart = uint32(block.timestamp);
        emit ChangeInitiated("portal", portal, _newPortal);
    }

    function executeTimeLocked() external {
        require(block.timestamp - timeLockStart >= timeLockSeconds, "timelock");
        if (newGuardian != address(0)) {
            emit ChangeExecuted("guardian", janusGuardian, newGuardian);
            janusGuardian = newGuardian;
            newGuardian = address(0);
        } else {
            emit ChangeExecuted("portal", portal, newPortal);
            portal = newPortal;
            newPortal = address(0);
        }
        timeLockStart = 0;
    }
}