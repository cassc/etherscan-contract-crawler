{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/create2/OwnableCreate2Deployer.sol\": {\r\n      \"content\": \"// Copyright Immutable Pty Ltd 2018 - 2024\\n// SPDX-License-Identifier: Apache 2.0\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {Deployer} from \\\"@axelar-gmp-sdk-solidity/contracts/deploy/Deployer.sol\\\";\\nimport {Create2} from \\\"@axelar-gmp-sdk-solidity/contracts/deploy/Create2.sol\\\";\\n\\n/**\\n * @title OwnableCreate2Deployer\\n * @notice Deploys and initializes contracts using the `CREATE2` opcode. The contract exposes two functions, {deploy} and {deployAndInit}.\\n *         {deploy} deploys a contract using the `CREATE2` opcode, and {deployAndInit} additionally initializes the contract using provided data.\\n *         The latter offers a way of ensuring that the constructor arguments do not affect the deployment address.\\n *\\n * @dev This contract extends the {Deployer} contract from the Axelar SDK, by adding basic access control to the deployment functions.\\n *      The contract has an owner, which is the only entity that can deploy new contracts.\\n *\\n * @dev The contract deploys a contract with the same bytecode, salt, and sender to the same address.\\n *      The address where the contract will be deployed can be found using {deployedAddress}.\\n */\\ncontract OwnableCreate2Deployer is Ownable, Create2, Deployer {\\n    constructor(address owner) Ownable() {\\n        transferOwnership(owner);\\n    }\\n\\n    /**\\n     * @dev Deploys a contract using the `CREATE2` opcode.\\n     *      This function is called by {deploy} and {deployAndInit} external functions in the {Deployer} contract.\\n     *      This function can only be called by the owner of this contract, hence the external {deploy} and {deployAndInit} functions can only be called by the owner.\\n     *      The address where the contract will be deployed can be found using the {deployedAddress} function.\\n     * @param bytecode The bytecode of the contract to be deployed\\n     * @param deploySalt A salt which is a hash of the salt provided by the sender and the sender's address.\\n     * @return The address of the deployed contract\\n     */\\n    function _deploy(bytes memory bytecode, bytes32 deploySalt) internal override onlyOwner returns (address) {\\n        return _create2(bytecode, deploySalt);\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} or {deployAndInit}.\\n     *      This function is called by the {deployedAddress} external functions in the {Deployer} contract.\\n     * @param bytecode The bytecode of the contract to be deployed\\n     * @param deploySalt A salt which is a hash of the sender's address and the `salt` provided by the sender, when calling the {deployedAddress} function.\\n     * @return The predicted deployment address of the contract\\n     */\\n    function _deployedAddress(bytes memory bytecode, bytes32 deploySalt) internal view override returns (address) {\\n        return _create2Address(bytecode, deploySalt);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/axelar-gmp-sdk-solidity/contracts/deploy/Deployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IDeployer } from '../interfaces/IDeployer.sol';\\nimport { SafeNativeTransfer } from '../libs/SafeNativeTransfer.sol';\\n\\n/**\\n * @title Deployer Contract\\n * @notice This contract is responsible for deploying and initializing new contracts using\\n * a deployment method, such as `CREATE2` or `CREATE3`.\\n */\\nabstract contract Deployer is IDeployer {\\n    using SafeNativeTransfer for address;\\n\\n    /**\\n     * @notice Deploys a contract using a deployment method defined by derived contracts.\\n     * @dev The address where the contract will be deployed can be known in\\n     * advance via {deployedAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already by the same `msg.sender`.\\n     *\\n     * @param bytecode The bytecode of the contract to be deployed\\n     * @param salt A salt to influence the contract address\\n     * @return deployedAddress_ The address of the deployed contract\\n     */\\n    // slither-disable-next-line locked-ether\\n    function deploy(bytes memory bytecode, bytes32 salt) external payable returns (address deployedAddress_) {\\n        bytes32 deploySalt = keccak256(abi.encode(msg.sender, salt));\\n        deployedAddress_ = _deployedAddress(bytecode, deploySalt);\\n\\n        if (msg.value > 0) {\\n            // slither-disable-next-line unused-return\\n            deployedAddress_.safeNativeTransfer(msg.value);\\n        }\\n\\n        deployedAddress_ = _deploy(bytecode, deploySalt);\\n\\n        emit Deployed(deployedAddress_, msg.sender, salt, keccak256(bytecode));\\n    }\\n\\n    /**\\n     * @notice Deploys a contract using a deployment method defined by derived contracts and initializes it.\\n     * @dev The address where the contract will be deployed can be known in advance\\n     * via {deployedAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already by the same `msg.sender`.\\n     * - `init` is used to initialize the deployed contract as an option to not have the\\n     *    constructor args affect the address derived by `CREATE2`.\\n     *\\n     * @param bytecode The bytecode of the contract to be deployed\\n     * @param salt A salt to influence the contract address\\n     * @param init Init data used to initialize the deployed contract\\n     * @return deployedAddress_ The address of the deployed contract\\n     */\\n    // slither-disable-next-line locked-ether\\n    function deployAndInit(\\n        bytes memory bytecode,\\n        bytes32 salt,\\n        bytes calldata init\\n    ) external payable returns (address deployedAddress_) {\\n        bytes32 deploySalt = keccak256(abi.encode(msg.sender, salt));\\n        deployedAddress_ = _deployedAddress(bytecode, deploySalt);\\n\\n        if (msg.value > 0) {\\n            // slither-disable-next-line unused-return\\n            deployedAddress_.safeNativeTransfer(msg.value);\\n        }\\n\\n        deployedAddress_ = _deploy(bytecode, deploySalt);\\n\\n        emit Deployed(deployedAddress_, msg.sender, salt, keccak256(bytecode));\\n\\n        (bool success, ) = deployedAddress_.call(init);\\n        if (!success) revert DeployInitFailed();\\n    }\\n\\n    /**\\n     * @notice Returns the address where a contract will be stored if deployed via {deploy} or {deployAndInit} by `sender`.\\n     * @dev Any change in the `bytecode` (except for `CREATE3`), `sender`, or `salt` will result in a new deployed address.\\n     * @param bytecode The bytecode of the contract to be deployed\\n     * @param sender The address that will deploy the contract via the deployment method\\n     * @param salt The salt that will be used to influence the contract address\\n     * @return deployedAddress_ The address that the contract will be deployed to\\n     */\\n    function deployedAddress(\\n        bytes memory bytecode,\\n        address sender,\\n        bytes32 salt\\n    ) public view returns (address) {\\n        bytes32 deploySalt = keccak256(abi.encode(sender, salt));\\n        return _deployedAddress(bytecode, deploySalt);\\n    }\\n\\n    function _deploy(bytes memory bytecode, bytes32 deploySalt) internal virtual returns (address);\\n\\n    function _deployedAddress(bytes memory bytecode, bytes32 deploySalt) internal view virtual returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/axelar-gmp-sdk-solidity/contracts/deploy/Create2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IDeploy } from '../interfaces/IDeploy.sol';\\nimport { ContractAddress } from '../libs/ContractAddress.sol';\\n\\n/**\\n * @title Create2 contract\\n * @notice This contract can be used to deploy a contract with a deterministic address that depends on\\n * the contract bytecode, deployer address, and deployment salt.\\n */\\ncontract Create2 is IDeploy {\\n    using ContractAddress for address;\\n\\n    /**\\n     * @notice Deploys a new contract using the `CREATE2` method.\\n     * @dev This function deploys the contract using `CREATE2` opcode.\\n     * @param bytecode The bytecode of the contract to be deployed\\n     * @param deploySalt A salt to influence the contract address\\n     * @return deployed The address of the deployed contract\\n     */\\n    function _create2(bytes memory bytecode, bytes32 deploySalt) internal returns (address deployed) {\\n        deployed = _create2Address(bytecode, deploySalt);\\n\\n        if (bytecode.length == 0) revert EmptyBytecode();\\n        if (deployed.isContract()) revert AlreadyDeployed();\\n\\n        assembly {\\n            deployed := create2(0, add(bytecode, 32), mload(bytecode), deploySalt)\\n        }\\n\\n        if (deployed == address(0)) revert DeployFailed();\\n    }\\n\\n    /**\\n     * @notice Computes the deployed address that will result from the `CREATE2` method.\\n     * @param bytecode The bytecode of the contract to be deployed\\n     * @param deploySalt A salt to influence the contract address\\n     * @return address The deterministic contract address if it was deployed\\n     */\\n    function _create2Address(bytes memory bytecode, bytes32 deploySalt) internal view returns (address) {\\n        return\\n            address(\\n                uint160(\\n                    uint256(\\n                        keccak256(\\n                            abi.encodePacked(\\n                                hex'ff',\\n                                address(this),\\n                                deploySalt,\\n                                keccak256(bytecode) // init code hash\\n                            )\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/axelar-gmp-sdk-solidity/contracts/interfaces/IDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IDeploy } from './IDeploy.sol';\\n\\n/**\\n * @title IDeployer Interface\\n * @notice This interface defines the contract responsible for deploying and optionally initializing new contracts\\n *  via a specified deployment method.\\n */\\ninterface IDeployer is IDeploy {\\n    error DeployInitFailed();\\n\\n    event Deployed(address indexed deployedAddress, address indexed sender, bytes32 indexed salt, bytes32 bytecodeHash);\\n\\n    /**\\n     * @notice Deploys a contract using a deployment method defined by derived contracts.\\n     * @param bytecode The bytecode of the contract to be deployed\\n     * @param salt A salt to influence the contract address\\n     * @return deployedAddress_ The address of the deployed contract\\n     */\\n    function deploy(bytes memory bytecode, bytes32 salt) external payable returns (address deployedAddress_);\\n\\n    /**\\n     * @notice Deploys a contract using a deployment method defined by derived contracts and initializes it.\\n     * @param bytecode The bytecode of the contract to be deployed\\n     * @param salt A salt to influence the contract address\\n     * @param init Init data used to initialize the deployed contract\\n     * @return deployedAddress_ The address of the deployed contract\\n     */\\n    function deployAndInit(\\n        bytes memory bytecode,\\n        bytes32 salt,\\n        bytes calldata init\\n    ) external payable returns (address deployedAddress_);\\n\\n    /**\\n     * @notice Returns the address where a contract will be stored if deployed via {deploy} or {deployAndInit} by `sender`.\\n     * @param bytecode The bytecode of the contract\\n     * @param sender The address that will deploy the contract\\n     * @param salt The salt that will be used to influence the contract address\\n     * @return deployedAddress_ The address that the contract will be deployed to\\n     */\\n    function deployedAddress(\\n        bytes calldata bytecode,\\n        address sender,\\n        bytes32 salt\\n    ) external view returns (address deployedAddress_);\\n}\\n\"\r\n    },\r\n    \"lib/axelar-gmp-sdk-solidity/contracts/libs/SafeNativeTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nerror NativeTransferFailed();\\n\\n/*\\n * @title SafeNativeTransfer\\n * @dev This library is used for performing safe native value transfers in Solidity by utilizing inline assembly.\\n */\\nlibrary SafeNativeTransfer {\\n    /*\\n     * @notice Perform a native transfer to a given address.\\n     * @param receiver The recipient address to which the amount will be sent.\\n     * @param amount The amount of native value to send.\\n     * @throws NativeTransferFailed error if transfer is not successful.\\n     */\\n    function safeNativeTransfer(address receiver, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            success := call(gas(), receiver, amount, 0, 0, 0, 0)\\n        }\\n\\n        if (!success) revert NativeTransferFailed();\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/axelar-gmp-sdk-solidity/contracts/interfaces/IDeploy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IDeploy Interface\\n * @notice This interface defines the errors for a contract that is responsible for deploying new contracts.\\n */\\ninterface IDeploy {\\n    error EmptyBytecode();\\n    error AlreadyDeployed();\\n    error DeployFailed();\\n}\\n\"\r\n    },\r\n    \"lib/axelar-gmp-sdk-solidity/contracts/libs/ContractAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary ContractAddress {\\n    function isContract(address contractAddress) internal view returns (bool) {\\n        bytes32 existingCodeHash = contractAddress.codehash;\\n\\n        // https://eips.ethereum.org/EIPS/eip-1052\\n        // keccak256('') == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\\n        return\\n            existingCodeHash != bytes32(0) &&\\n            existingCodeHash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@axelar-gmp-sdk-solidity/=lib/axelar-gmp-sdk-solidity/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"axelar-gmp-sdk-solidity/=lib/axelar-gmp-sdk-solidity/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyDeployed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DeployFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DeployInitFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyBytecode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NativeTransferFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"deployedAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"bytecodeHash\",\"type\":\"bytes32\"}],\"name\":\"Deployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployedAddress_\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"init\",\"type\":\"bytes\"}],\"name\":\"deployAndInit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployedAddress_\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"deployedAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OwnableCreate2Deployer", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000dda0d9448ebe3ea43afece5fa6401f5795c19333", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}