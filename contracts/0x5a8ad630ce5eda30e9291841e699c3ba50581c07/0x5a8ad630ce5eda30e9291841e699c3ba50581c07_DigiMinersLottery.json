{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n// File: @openzeppelin/contracts/utils/Strings.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n  bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n  uint8 private constant _ADDRESS_LENGTH = 20;\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n   */\r\n  function toString(uint256 value) internal pure returns (string memory) {\r\n    // Inspired by OraclizeAPI's implementation - MIT licence\r\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n    if (value == 0) {\r\n      return \"0\";\r\n    }\r\n    uint256 temp = value;\r\n    uint256 digits;\r\n    while (temp != 0) {\r\n      digits++;\r\n      temp /= 10;\r\n    }\r\n    bytes memory buffer = new bytes(digits);\r\n    while (value != 0) {\r\n      digits -= 1;\r\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n      value /= 10;\r\n    }\r\n    return string(buffer);\r\n  }\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n   */\r\n  function toHexString(uint256 value) internal pure returns (string memory) {\r\n    if (value == 0) {\r\n      return \"0x00\";\r\n    }\r\n    uint256 temp = value;\r\n    uint256 length = 0;\r\n    while (temp != 0) {\r\n      length++;\r\n      temp >>= 8;\r\n    }\r\n    return toHexString(value, length);\r\n  }\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n   */\r\n  function toHexString(\r\n    uint256 value,\r\n    uint256 length\r\n  ) internal pure returns (string memory) {\r\n    bytes memory buffer = new bytes(2 * length + 2);\r\n    buffer[0] = \"0\";\r\n    buffer[1] = \"x\";\r\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n      buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n      value >>= 4;\r\n    }\r\n    require(value == 0, \"Strings: hex length insufficient\");\r\n    return string(buffer);\r\n  }\r\n\r\n  /**\r\n   * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\r\n   */\r\n  function toHexString(address addr) internal pure returns (string memory) {\r\n    return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/cryptography/ECDSA.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n  enum RecoverError {\r\n    NoError,\r\n    InvalidSignature,\r\n    InvalidSignatureLength,\r\n    InvalidSignatureS,\r\n    InvalidSignatureV\r\n  }\r\n\r\n  function _throwError(RecoverError error) private pure {\r\n    if (error == RecoverError.NoError) {\r\n      return; // no error: do nothing\r\n    } else if (error == RecoverError.InvalidSignature) {\r\n      revert(\"ECDSA: invalid signature\");\r\n    } else if (error == RecoverError.InvalidSignatureLength) {\r\n      revert(\"ECDSA: invalid signature length\");\r\n    } else if (error == RecoverError.InvalidSignatureS) {\r\n      revert(\"ECDSA: invalid signature 's' value\");\r\n    } else if (error == RecoverError.InvalidSignatureV) {\r\n      revert(\"ECDSA: invalid signature 'v' value\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address that signed a hashed message (`hash`) with\r\n   * `signature` or error string. This address can then be used for verification purposes.\r\n   *\r\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n   * this function rejects them by requiring the `s` value to be in the lower\r\n   * half order, and the `v` value to be either 27 or 28.\r\n   *\r\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n   * verification to be secure: it is possible to craft signatures that\r\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n   * this is by receiving a hash of the original message (which may otherwise\r\n   * be too long), and then calling {toEthSignedMessageHash} on it.\r\n   *\r\n   * Documentation for signature generation:\r\n   * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\r\n   * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\r\n   *\r\n   * _Available since v4.3._\r\n   */\r\n  function tryRecover(\r\n    bytes32 hash,\r\n    bytes memory signature\r\n  ) internal pure returns (address, RecoverError) {\r\n    if (signature.length == 65) {\r\n      bytes32 r;\r\n      bytes32 s;\r\n      uint8 v;\r\n      // ecrecover takes the signature parameters, and the only way to get them\r\n      // currently is to use assembly.\r\n      /// @solidity memory-safe-assembly\r\n      assembly {\r\n        r := mload(add(signature, 0x20))\r\n        s := mload(add(signature, 0x40))\r\n        v := byte(0, mload(add(signature, 0x60)))\r\n      }\r\n      return tryRecover(hash, v, r, s);\r\n    } else {\r\n      return (address(0), RecoverError.InvalidSignatureLength);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address that signed a hashed message (`hash`) with\r\n   * `signature`. This address can then be used for verification purposes.\r\n   *\r\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n   * this function rejects them by requiring the `s` value to be in the lower\r\n   * half order, and the `v` value to be either 27 or 28.\r\n   *\r\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n   * verification to be secure: it is possible to craft signatures that\r\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n   * this is by receiving a hash of the original message (which may otherwise\r\n   * be too long), and then calling {toEthSignedMessageHash} on it.\r\n   */\r\n  function recover(\r\n    bytes32 hash,\r\n    bytes memory signature\r\n  ) internal pure returns (address) {\r\n    (address recovered, RecoverError error) = tryRecover(hash, signature);\r\n    _throwError(error);\r\n    return recovered;\r\n  }\r\n\r\n  /**\r\n   * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\r\n   *\r\n   * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\r\n   *\r\n   * _Available since v4.3._\r\n   */\r\n  function tryRecover(\r\n    bytes32 hash,\r\n    bytes32 r,\r\n    bytes32 vs\r\n  ) internal pure returns (address, RecoverError) {\r\n    bytes32 s = vs &\r\n      bytes32(\r\n        0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\r\n      );\r\n    uint8 v = uint8((uint256(vs) >> 255) + 27);\r\n    return tryRecover(hash, v, r, s);\r\n  }\r\n\r\n  /**\r\n   * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\r\n   *\r\n   * _Available since v4.2._\r\n   */\r\n  function recover(\r\n    bytes32 hash,\r\n    bytes32 r,\r\n    bytes32 vs\r\n  ) internal pure returns (address) {\r\n    (address recovered, RecoverError error) = tryRecover(hash, r, vs);\r\n    _throwError(error);\r\n    return recovered;\r\n  }\r\n\r\n  /**\r\n   * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\r\n   * `r` and `s` signature fields separately.\r\n   *\r\n   * _Available since v4.3._\r\n   */\r\n  function tryRecover(\r\n    bytes32 hash,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) internal pure returns (address, RecoverError) {\r\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n    // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\r\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n    //\r\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n    // these malleable signatures as well.\r\n    if (\r\n      uint256(s) >\r\n      0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\r\n    ) {\r\n      return (address(0), RecoverError.InvalidSignatureS);\r\n    }\r\n    if (v != 27 && v != 28) {\r\n      return (address(0), RecoverError.InvalidSignatureV);\r\n    }\r\n\r\n    // If the signature is valid (and not malleable), return the signer address\r\n    address signer = ecrecover(hash, v, r, s);\r\n    if (signer == address(0)) {\r\n      return (address(0), RecoverError.InvalidSignature);\r\n    }\r\n\r\n    return (signer, RecoverError.NoError);\r\n  }\r\n\r\n  /**\r\n   * @dev Overload of {ECDSA-recover} that receives the `v`,\r\n   * `r` and `s` signature fields separately.\r\n   */\r\n  function recover(\r\n    bytes32 hash,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) internal pure returns (address) {\r\n    (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\r\n    _throwError(error);\r\n    return recovered;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n   * produces hash corresponding to the one signed with the\r\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\r\n   * JSON-RPC method as part of EIP-191.\r\n   *\r\n   * See {recover}.\r\n   */\r\n  function toEthSignedMessageHash(\r\n    bytes32 hash\r\n  ) internal pure returns (bytes32) {\r\n    // 32 is the length in bytes of hash,\r\n    // enforced by the type signature above\r\n    return\r\n      keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an Ethereum Signed Message, created from `s`. This\r\n   * produces hash corresponding to the one signed with the\r\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\r\n   * JSON-RPC method as part of EIP-191.\r\n   *\r\n   * See {recover}.\r\n   */\r\n  function toEthSignedMessageHash(\r\n    bytes memory s\r\n  ) internal pure returns (bytes32) {\r\n    return\r\n      keccak256(\r\n        abi.encodePacked(\r\n          \"\\x19Ethereum Signed Message:\\n\",\r\n          Strings.toString(s.length),\r\n          s\r\n        )\r\n      );\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an Ethereum Signed Typed Data, created from a\r\n   * `domainSeparator` and a `structHash`. This produces hash corresponding\r\n   * to the one signed with the\r\n   * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\r\n   * JSON-RPC method as part of EIP-712.\r\n   *\r\n   * See {recover}.\r\n   */\r\n  function toTypedDataHash(\r\n    bytes32 domainSeparator,\r\n    bytes32 structHash\r\n  ) internal pure returns (bytes32) {\r\n    return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n  }\r\n}\r\n\r\n// File: digiminer.sol\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n  /**\r\n   * @dev Returns true if this contract implements the interface defined by\r\n   * `interfaceId`. See the corresponding\r\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n   * to learn more about how these ids are created.\r\n   *\r\n   * This function call must use less than 30 000 gas.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n  /**\r\n   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n   */\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 indexed tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n   */\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed approved,\r\n    uint256 indexed tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n   */\r\n  event ApprovalForAll(\r\n    address indexed owner,\r\n    address indexed operator,\r\n    bool approved\r\n  );\r\n\r\n  /**\r\n   * @dev Returns the number of tokens in ``owner``'s account.\r\n   */\r\n  function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n  /**\r\n   * @dev Returns the owner of the `tokenId` token.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must exist.\r\n   */\r\n  function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n  /**\r\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must exist and be owned by `from`.\r\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function safeTransferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId,\r\n    bytes calldata data\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must exist and be owned by `from`.\r\n   * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n  /**\r\n   * @dev Transfers `tokenId` token from `from` to `to`.\r\n   *\r\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must be owned by `from`.\r\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n  /**\r\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n   * The approval is cleared when the token is transferred.\r\n   *\r\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The caller must own the token or be an approved operator.\r\n   * - `tokenId` must exist.\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address to, uint256 tokenId) external;\r\n\r\n  /**\r\n   * @dev Approve or remove `operator` as an operator for the caller.\r\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The `operator` cannot be the caller.\r\n   *\r\n   * Emits an {ApprovalForAll} event.\r\n   */\r\n  function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n  /**\r\n   * @dev Returns the account approved for `tokenId` token.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must exist.\r\n   */\r\n  function getApproved(\r\n    uint256 tokenId\r\n  ) external view returns (address operator);\r\n\r\n  /**\r\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n   *\r\n   * See {setApprovalForAll}\r\n   */\r\n  function isApprovedForAll(\r\n    address owner,\r\n    address operator\r\n  ) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/interfaces/IERC721.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns (address) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes calldata) {\r\n    return msg.data;\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev Initializes the contract setting the deployer as the initial owner.\r\n   */\r\n  constructor() {\r\n    _transferOwnership(_msgSender());\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    _checkOwner();\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view virtual returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if the sender is not the owner.\r\n   */\r\n  function _checkOwner() internal view virtual {\r\n    require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n  }\r\n\r\n  /**\r\n   * @dev Leaves the contract without owner. It will not be possible to call\r\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n   *\r\n   * NOTE: Renouncing ownership will leave the contract without an owner,\r\n   * thereby removing any functionality that is only available to the owner.\r\n   */\r\n  function renounceOwnership() public virtual onlyOwner {\r\n    _transferOwnership(address(0));\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Internal function without access restriction.\r\n   */\r\n  function _transferOwnership(address newOwner) internal virtual {\r\n    address oldOwner = _owner;\r\n    _owner = newOwner;\r\n    emit OwnershipTransferred(oldOwner, newOwner);\r\n  }\r\n}\r\n\r\n// File: digiminer.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\r\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint256` (`UintSet`) are supported.\r\n *\r\n * [WARNING]\r\n * ====\r\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\r\n * unusable.\r\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\r\n *\r\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\r\n * array of EnumerableSet.\r\n * ====\r\n */\r\nlibrary EnumerableSet {\r\n  // To implement this library for multiple types with as little code\r\n  // repetition as possible, we write it in terms of a generic Set type with\r\n  // bytes32 values.\r\n  // The Set implementation uses private functions, and user-facing\r\n  // implementations (such as AddressSet) are just wrappers around the\r\n  // underlying Set.\r\n  // This means that we can only create new EnumerableSets for types that fit\r\n  // in bytes32.\r\n\r\n  struct Set {\r\n    // Storage of set values\r\n    bytes32[] _values;\r\n    // Position of the value in the `values` array, plus 1 because index 0\r\n    // means a value is not in the set.\r\n    mapping(bytes32 => uint256) _indexes;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a value to a set. O(1).\r\n   *\r\n   * Returns true if the value was added to the set, that is if it was not\r\n   * already present.\r\n   */\r\n  function _add(Set storage set, bytes32 value) private returns (bool) {\r\n    if (!_contains(set, value)) {\r\n      set._values.push(value);\r\n      // The value is stored at length-1, but we add 1 to all indexes\r\n      // and use 0 as a sentinel value\r\n      set._indexes[value] = set._values.length;\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n   *\r\n   * Returns true if the value was removed from the set, that is if it was\r\n   * present.\r\n   */\r\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n    // We read and store the value's index to prevent multiple reads from the same storage slot\r\n    uint256 valueIndex = set._indexes[value];\r\n\r\n    if (valueIndex != 0) {\r\n      // Equivalent to contains(set, value)\r\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n      // This modifies the order of the array, as noted in {at}.\r\n\r\n      uint256 toDeleteIndex = valueIndex - 1;\r\n      uint256 lastIndex = set._values.length - 1;\r\n\r\n      if (lastIndex != toDeleteIndex) {\r\n        bytes32 lastValue = set._values[lastIndex];\r\n\r\n        // Move the last value to the index where the value to delete is\r\n        set._values[toDeleteIndex] = lastValue;\r\n        // Update the index for the moved value\r\n        set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\r\n      }\r\n\r\n      // Delete the slot where the moved value was stored\r\n      set._values.pop();\r\n\r\n      // Delete the index for the deleted slot\r\n      delete set._indexes[value];\r\n\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the value is in the set. O(1).\r\n   */\r\n  function _contains(\r\n    Set storage set,\r\n    bytes32 value\r\n  ) private view returns (bool) {\r\n    return set._indexes[value] != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of values on the set. O(1).\r\n   */\r\n  function _length(Set storage set) private view returns (uint256) {\r\n    return set._values.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value stored at position `index` in the set. O(1).\r\n   *\r\n   * Note that there are no guarantees on the ordering of values inside the\r\n   * array, and it may change when more values are added or removed.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `index` must be strictly less than {length}.\r\n   */\r\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n    return set._values[index];\r\n  }\r\n\r\n  /**\r\n   * @dev Return the entire set in an array\r\n   *\r\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n   */\r\n  function _values(Set storage set) private view returns (bytes32[] memory) {\r\n    return set._values;\r\n  }\r\n\r\n  // Bytes32Set\r\n\r\n  struct Bytes32Set {\r\n    Set _inner;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a value to a set. O(1).\r\n   *\r\n   * Returns true if the value was added to the set, that is if it was not\r\n   * already present.\r\n   */\r\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n    return _add(set._inner, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n   *\r\n   * Returns true if the value was removed from the set, that is if it was\r\n   * present.\r\n   */\r\n  function remove(\r\n    Bytes32Set storage set,\r\n    bytes32 value\r\n  ) internal returns (bool) {\r\n    return _remove(set._inner, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the value is in the set. O(1).\r\n   */\r\n  function contains(\r\n    Bytes32Set storage set,\r\n    bytes32 value\r\n  ) internal view returns (bool) {\r\n    return _contains(set._inner, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of values in the set. O(1).\r\n   */\r\n  function length(Bytes32Set storage set) internal view returns (uint256) {\r\n    return _length(set._inner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value stored at position `index` in the set. O(1).\r\n   *\r\n   * Note that there are no guarantees on the ordering of values inside the\r\n   * array, and it may change when more values are added or removed.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `index` must be strictly less than {length}.\r\n   */\r\n  function at(\r\n    Bytes32Set storage set,\r\n    uint256 index\r\n  ) internal view returns (bytes32) {\r\n    return _at(set._inner, index);\r\n  }\r\n\r\n  /**\r\n   * @dev Return the entire set in an array\r\n   *\r\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n   */\r\n  function values(\r\n    Bytes32Set storage set\r\n  ) internal view returns (bytes32[] memory) {\r\n    bytes32[] memory store = _values(set._inner);\r\n    bytes32[] memory result;\r\n\r\n    /// @solidity memory-safe-assembly\r\n    assembly {\r\n      result := store\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  // AddressSet\r\n\r\n  struct AddressSet {\r\n    Set _inner;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a value to a set. O(1).\r\n   *\r\n   * Returns true if the value was added to the set, that is if it was not\r\n   * already present.\r\n   */\r\n  function add(AddressSet storage set, address value) internal returns (bool) {\r\n    return _add(set._inner, bytes32(uint256(uint160(value))));\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n   *\r\n   * Returns true if the value was removed from the set, that is if it was\r\n   * present.\r\n   */\r\n  function remove(\r\n    AddressSet storage set,\r\n    address value\r\n  ) internal returns (bool) {\r\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the value is in the set. O(1).\r\n   */\r\n  function contains(\r\n    AddressSet storage set,\r\n    address value\r\n  ) internal view returns (bool) {\r\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of values in the set. O(1).\r\n   */\r\n  function length(AddressSet storage set) internal view returns (uint256) {\r\n    return _length(set._inner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value stored at position `index` in the set. O(1).\r\n   *\r\n   * Note that there are no guarantees on the ordering of values inside the\r\n   * array, and it may change when more values are added or removed.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `index` must be strictly less than {length}.\r\n   */\r\n  function at(\r\n    AddressSet storage set,\r\n    uint256 index\r\n  ) internal view returns (address) {\r\n    return address(uint160(uint256(_at(set._inner, index))));\r\n  }\r\n\r\n  /**\r\n   * @dev Return the entire set in an array\r\n   *\r\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n   */\r\n  function values(\r\n    AddressSet storage set\r\n  ) internal view returns (address[] memory) {\r\n    bytes32[] memory store = _values(set._inner);\r\n    address[] memory result;\r\n\r\n    /// @solidity memory-safe-assembly\r\n    assembly {\r\n      result := store\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  // UintSet\r\n\r\n  struct UintSet {\r\n    Set _inner;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a value to a set. O(1).\r\n   *\r\n   * Returns true if the value was added to the set, that is if it was not\r\n   * already present.\r\n   */\r\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n    return _add(set._inner, bytes32(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n   *\r\n   * Returns true if the value was removed from the set, that is if it was\r\n   * present.\r\n   */\r\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n    return _remove(set._inner, bytes32(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the value is in the set. O(1).\r\n   */\r\n  function contains(\r\n    UintSet storage set,\r\n    uint256 value\r\n  ) internal view returns (bool) {\r\n    return _contains(set._inner, bytes32(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of values in the set. O(1).\r\n   */\r\n  function length(UintSet storage set) internal view returns (uint256) {\r\n    return _length(set._inner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value stored at position `index` in the set. O(1).\r\n   *\r\n   * Note that there are no guarantees on the ordering of values inside the\r\n   * array, and it may change when more values are added or removed.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `index` must be strictly less than {length}.\r\n   */\r\n  function at(\r\n    UintSet storage set,\r\n    uint256 index\r\n  ) internal view returns (uint256) {\r\n    return uint256(_at(set._inner, index));\r\n  }\r\n\r\n  /**\r\n   * @dev Return the entire set in an array\r\n   *\r\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n   */\r\n  function values(\r\n    UintSet storage set\r\n  ) internal view returns (uint256[] memory) {\r\n    bytes32[] memory store = _values(set._inner);\r\n    uint256[] memory result;\r\n\r\n    /// @solidity memory-safe-assembly\r\n    assembly {\r\n      result := store\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n  // Booleans are more expensive than uint256 or any type that takes up a full\r\n  // word because each write operation emits an extra SLOAD to first read the\r\n  // slot's contents, replace the bits taken up by the boolean, and then write\r\n  // back. This is the compiler's defense against contract upgrades and\r\n  // pointer aliasing, and it cannot be disabled.\r\n\r\n  // The values being non-zero value makes deployment a bit more expensive,\r\n  // but in exchange the refund on every call to nonReentrant will be lower in\r\n  // amount. Since refunds are capped to a percentage of the total\r\n  // transaction's gas, it is best to keep them low in cases like this one, to\r\n  // increase the likelihood of the full refund coming into effect.\r\n  uint256 private constant _NOT_ENTERED = 1;\r\n  uint256 private constant _ENTERED = 2;\r\n\r\n  uint256 private _status;\r\n\r\n  constructor() {\r\n    _status = _NOT_ENTERED;\r\n  }\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * Calling a `nonReentrant` function from another `nonReentrant`\r\n   * function is not supported. It is possible to prevent this from happening\r\n   * by making the `nonReentrant` function external, and making it call a\r\n   * `private` function that does the actual work.\r\n   */\r\n  modifier nonReentrant() {\r\n    // On the first call to nonReentrant, _notEntered will be true\r\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n    // Any calls to nonReentrant after this point will fail\r\n    _status = _ENTERED;\r\n\r\n    _;\r\n\r\n    // By storing the original value once again, a refund is triggered (see\r\n    // https://eips.ethereum.org/EIPS/eip-2200)\r\n    _status = _NOT_ENTERED;\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n   *\r\n   * _Available since v3.4._\r\n   */\r\n  function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    uint256 c = a + b;\r\n    if (c < a) return (false, 0);\r\n    return (true, c);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n   *\r\n   * _Available since v3.4._\r\n   */\r\n  function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    if (b > a) return (false, 0);\r\n    return (true, a - b);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n   *\r\n   * _Available since v3.4._\r\n   */\r\n  function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n    if (a == 0) return (true, 0);\r\n    uint256 c = a * b;\r\n    if (c / a != b) return (false, 0);\r\n    return (true, c);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n   *\r\n   * _Available since v3.4._\r\n   */\r\n  function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    if (b == 0) return (false, 0);\r\n    return (true, a / b);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n   *\r\n   * _Available since v3.4._\r\n   */\r\n  function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    if (b == 0) return (false, 0);\r\n    return (true, a % b);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the addition of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `+` operator.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - Addition cannot overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"SafeMath: subtraction overflow\");\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     \r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) return 0;\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers, reverting on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0, \"SafeMath: division by zero\");\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * reverting when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0, \"SafeMath: modulo by zero\");\r\n    return a % b;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n   * message unnecessarily. For custom revert reasons use {trySub}.\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n   * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b > 0, errorMessage);\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * reverting with custom message when dividing by zero.\r\n   *\r\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n   * message unnecessarily. For custom revert reasons use {tryMod}.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b > 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n\r\nlibrary TransferHelper {\r\n  function safeApprove(address token, address to, uint256 value) internal {\r\n    // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n    (bool success, bytes memory data) = token.call(\r\n      abi.encodeWithSelector(0x095ea7b3, to, value)\r\n    );\r\n    require(\r\n      success && (data.length == 0 || abi.decode(data, (bool))),\r\n      \"TransferHelper::safeApprove: approve failed\"\r\n    );\r\n  }\r\n\r\n  function safeTransfer(address token, address to, uint256 value) internal {\r\n    // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n    (bool success, bytes memory data) = token.call(\r\n      abi.encodeWithSelector(0xa9059cbb, to, value)\r\n    );\r\n    require(\r\n      success && (data.length == 0 || abi.decode(data, (bool))),\r\n      \"TransferHelper::safeTransfer: transfer failed\"\r\n    );\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    address token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n    (bool success, bytes memory data) = token.call(\r\n      abi.encodeWithSelector(0x23b872dd, from, to, value)\r\n    );\r\n    require(\r\n      success && (data.length == 0 || abi.decode(data, (bool))),\r\n      \"TransferHelper::transferFrom: transferFrom failed\"\r\n    );\r\n  }\r\n\r\n  function safeTransferETH(address to, uint256 value) internal {\r\n    (bool success, ) = to.call{value: value}(new bytes(0));\r\n    require(success, \"TransferHelper::safeTransferETH: ETH transfer failed\");\r\n  }\r\n}\r\n\r\ncontract DigiMinersLottery is Ownable, ReentrancyGuard {\r\n  using SafeMath for uint256;\r\n  using ECDSA for bytes32;\r\n\r\n  address private signerWallet;\r\n  address private MinerToken;\r\n\r\n  struct LotteryRound {\r\n    uint256 RoundId; //round id\r\n    uint256 startTime; //startTime of lottery\r\n    uint256 endTime; //endTime of lottery\r\n    uint256 ticketsSold; //tickets sold in this round\r\n    uint256 priceClaimed;\r\n  }\r\n\r\n  struct Ticket {\r\n    address holder; //owner of the ticket (non transferrable)\r\n    Ores winningOre;\r\n  }\r\n\r\n  /* Contract address of DIGI NFT */\r\n  IERC721 public DIGI_NFT;\r\n\r\n  /* Current Round of Lottery */\r\n  uint256 public LotteryRounds;\r\n\r\n  /* Price for Each Ticket */\r\n  uint256 public immutable ticketPrice = 2000 ether;\r\n\r\n  // The mask of the lower 160 bits for addresses.\r\n  uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\r\n\r\n  // The `PURCHASE` event signature is given by:\r\n  //\"TicketPurchased(uint256,uint256,address)\".\r\n  bytes32 private constant _PURCHASE_EVENT_SIGNATURE =\r\n    0x94c5953e15f54d38b82a662bdd5739fc91af3a23d3ef7e67269dfaeee71a813c;\r\n\r\n  /* Winning Amount*/\r\n  uint256 public constant Vortexia = 100000 ether;\r\n  uint256 public constant Diamond = 20000 ether;\r\n  uint256 public constant Gold = 4000 ether;\r\n  uint256 public constant Emerald = 2000 ether;\r\n  uint256 public constant Bronze = 400 ether;\r\n  uint256 public constant Iron = 200 ether;\r\n\r\n  address public manager;\r\n\r\n  struct BulkClaim {\r\n    uint256 roundId;\r\n    uint256[] ticketIds;\r\n  }\r\n\r\n  struct TicketClaimed {\r\n    uint256 ticketId;\r\n    address holder;\r\n    Ores winningOre;\r\n    bool claimed;\r\n  }\r\n  enum Ores {\r\n    Vortexia,\r\n    Diamond,\r\n    Gold,\r\n    Emerald,\r\n    Bronze,\r\n    Iron\r\n  }\r\n  /* \r\n    Mapping of Lottery round to nft id which returns uint256 to check how many tickets an NFT has bought;\r\n    */\r\n  mapping(uint256 => mapping(uint256 => uint256)) public nftUsed;\r\n\r\n  mapping(Ores => uint256) public price;\r\n  /* Ticket counter for each round of NFT */\r\n  mapping(uint256 => LotteryRound) public RoundDetails;\r\n\r\n  /* Mapping of Lottery round to its winning key */\r\n  mapping(uint256 => uint256) public winningKey;\r\n\r\n  mapping(uint256 => mapping(uint256 => Ticket)) public TicketKey;\r\n\r\n  mapping(uint256 => mapping(uint256 => bool)) public claimed;\r\n\r\n  mapping(Ores => uint256) private Distributelimit;\r\n\r\n  mapping(uint256 => Ores) private checkore;\r\n\r\n  mapping(uint256 => mapping(Ores => uint256)) private claimCounter;\r\n\r\n  event WinningClaimed(uint256 indexed roundId, address indexed wallet);\r\n\r\n  /* Ticket Fees is not correct */\r\n  error BadFees();\r\n\r\n  /* Not owner of the NFT */\r\n  error NotOwner();\r\n\r\n  /* Fake Signature */\r\n  error FakeSignature();\r\n\r\n  /* NFT used enough */\r\n  error nftConsumed();\r\n\r\n  /* Lottery has ended */\r\n  error LotteryEnded();\r\n\r\n  /* All tickets sold */\r\n  error TicketsSold();\r\n\r\n  /* Not holder of ticket */\r\n  error NotHolder();\r\n\r\n  /* Ticket Claimed */\r\n\r\n  error AlreadyClaimed();\r\n\r\n  /* Caller is contract */\r\n  error ContractCall();\r\n\r\n  /* Round not ended */\r\n  error RoundNotEnded();\r\n\r\n  constructor() {\r\n    price[Ores.Vortexia] = Vortexia;\r\n    price[Ores.Diamond] = Diamond;\r\n    price[Ores.Gold] = Gold;\r\n    price[Ores.Emerald] = Emerald;\r\n    price[Ores.Bronze] = Bronze;\r\n    price[Ores.Iron] = Iron;\r\n\r\n    checkore[0] = Ores.Vortexia;\r\n    checkore[1] = Ores.Diamond;\r\n    checkore[2] = Ores.Gold;\r\n    checkore[3] = Ores.Emerald;\r\n    checkore[4] = Ores.Bronze;\r\n    checkore[5] = Ores.Iron;\r\n\r\n    Distributelimit[Ores.Vortexia] = 194;\r\n    Distributelimit[Ores.Diamond] = 583;\r\n    Distributelimit[Ores.Gold] = 3110;\r\n    Distributelimit[Ores.Emerald] = 15554;\r\n    Distributelimit[Ores.Bronze] = 19442;\r\n    Distributelimit[Ores.Iron] = 38888;\r\n    startRound(block.timestamp, block.timestamp + 7 days);\r\n    signerWallet = 0xd2149d74486e2C1b1c8d5a35984835F2b6184f5C;\r\n    DIGI_NFT = IERC721(0xEcA22C0FD4ac62D81a5633eB547e6797C9579462);\r\n    MinerToken = 0x712b4608a8b565BCA365D49A4c26d669Ce6CEE08;\r\n  }\r\n\r\n  function isContract(address _addr) private view returns (bool) {\r\n    uint32 size;\r\n    assembly {\r\n      size := extcodesize(_addr)\r\n    }\r\n    return (size > 0);\r\n  }\r\n\r\n  modifier callerIsWallet() {\r\n    if (isContract(_msgSender()) && msg.sender == tx.origin)\r\n      revert ContractCall();\r\n    _;\r\n  }\r\n\r\n  modifier onlyAuth() {\r\n    require(msg.sender == manager || msg.sender == owner(), \"Not Auth\");\r\n    _;\r\n  }\r\n\r\n  function setManager(address manager_) public onlyOwner {\r\n    manager = manager_;\r\n  }\r\n\r\n  function random() private view returns (uint) {\r\n    return\r\n      uint(\r\n        keccak256(\r\n          abi.encodePacked(block.difficulty, block.timestamp, block.number)\r\n        )\r\n      ) % 10 ** 10;\r\n  }\r\n\r\n  function getTicketDetails(\r\n    uint256 roundId,\r\n    uint256 ticketId\r\n  ) public view returns (Ticket memory) {\r\n    return TicketKey[roundId][ticketId];\r\n  }\r\n\r\n  function changeSignerwallet(address _signerWallet) public onlyOwner {\r\n    signerWallet = _signerWallet;\r\n  }\r\n\r\n  function setMinerToken(address _minerToken) public onlyOwner {\r\n    MinerToken = _minerToken;\r\n  }\r\n\r\n  function getMinerToken() public view returns (address) {\r\n    return MinerToken;\r\n  }\r\n\r\n  function getPrice(Ores ore) public view returns (uint256) {\r\n    return price[ore];\r\n  }\r\n\r\n  function currentRound() public view returns (uint256) {\r\n    return LotteryRounds;\r\n  }\r\n\r\n  function startRound(uint256 startTime, uint256 endTime) public onlyOwner {\r\n    require(\r\n      block.timestamp > RoundDetails[currentRound()].endTime,\r\n      \"DIGI: Last Round has not ended\"\r\n    );\r\n    LotteryRounds++;\r\n    RoundDetails[LotteryRounds] = LotteryRound(\r\n      LotteryRounds,\r\n      startTime,\r\n      endTime,\r\n      0,\r\n      0\r\n    );\r\n    setKey();\r\n  }\r\n\r\n  function startRoundbyManager(\r\n    uint256 startTime,\r\n    uint256 endTime\r\n  ) public onlyAuth {\r\n    require(\r\n      block.timestamp > RoundDetails[currentRound()].endTime,\r\n      \"DIGI: Last Round has not ended\"\r\n    );\r\n    LotteryRounds++;\r\n    RoundDetails[LotteryRounds] = LotteryRound(\r\n      LotteryRounds,\r\n      startTime,\r\n      endTime,\r\n      0,\r\n      0\r\n    );\r\n    setKey();\r\n  }\r\n\r\n  function setDIGI_NFT(IERC721 nft_) public onlyOwner {\r\n    DIGI_NFT = nft_;\r\n  }\r\n\r\n  function buyTickets(\r\n    bytes calldata signature,\r\n    uint256 quantity,\r\n    uint256 tokenIdHolding,\r\n    uint256 multiplier\r\n  ) public callerIsWallet nonReentrant {\r\n    TransferHelper.safeTransferFrom(\r\n      MinerToken,\r\n      _msgSender(),\r\n      address(this),\r\n      ticketPrice.mul(quantity)\r\n    );\r\n    if (msg.sender != DIGI_NFT.ownerOf(tokenIdHolding)) revert NotOwner();\r\n\r\n    uint256 roundId = currentRound();\r\n\r\n    if (\r\n      checkSign(\r\n        signature,\r\n        quantity,\r\n        tokenIdHolding,\r\n        multiplier,\r\n        _msgSender(),\r\n        roundId\r\n      ) != signerWallet\r\n    ) revert FakeSignature();\r\n\r\n    nftUsed[roundId][tokenIdHolding] += quantity;\r\n\r\n    if (nftUsed[roundId][tokenIdHolding] > 10) revert nftConsumed();\r\n\r\n    LotteryRound storage round = RoundDetails[roundId];\r\n\r\n    if (round.endTime < block.timestamp) revert LotteryEnded();\r\n\r\n    uint256 startTicketIndex = round.ticketsSold + 1;\r\n    round.ticketsSold += quantity;\r\n\r\n    uint256 winningKey_ = getWinningKey(roundId);\r\n\r\n    address buyer = _msgSender();\r\n\r\n    for (uint256 i = 0; i < quantity; ) {\r\n      uint256 ticketId = startTicketIndex + i;\r\n      uint256 ticketKey = getTicketKey(ticketId);\r\n      Ores winningOre = getWinningOre(\r\n        winningKey_,\r\n        roundId,\r\n        ticketKey,\r\n        multiplier\r\n      );\r\n      TicketKey[roundId][ticketId] = Ticket(buyer, winningOre);\r\n      emitPurchase(ticketId, roundId, buyer);\r\n      unchecked {\r\n        ++claimCounter[roundId][winningOre];\r\n        ++i;\r\n      }\r\n    }\r\n  }\r\n\r\n  function emitPurchase(\r\n    uint256 ticketId,\r\n    uint256 roundId,\r\n    address buyer\r\n  ) internal {\r\n    assembly {\r\n      // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\r\n      buyer := and(buyer, _BITMASK_ADDRESS)\r\n      // Emit the `Transfer` event.\r\n      log4(\r\n        0, // Start of data (0, since no data).\r\n        0, // End of data (0, since no data).\r\n        _PURCHASE_EVENT_SIGNATURE, // Signature.\r\n        ticketId, // `startTicketId(0)`.\r\n        roundId, // `to`.\r\n        buyer // `tokenId`.\r\n      )\r\n    }\r\n  }\r\n\r\n  function checkSign(\r\n    bytes calldata signature,\r\n    uint256 quantity,\r\n    uint256 tokenIdHolding,\r\n    uint256 multipler,\r\n    address wallet,\r\n    uint256 roundId\r\n  ) private pure returns (address) {\r\n    return\r\n      keccak256(\r\n        abi.encodePacked(\r\n          \"\\x19Ethereum Signed Message:\\n32\",\r\n          getSignData(quantity, tokenIdHolding, multipler, wallet, roundId)\r\n        )\r\n      ).recover(signature);\r\n  }\r\n\r\n  function getSignData(\r\n    uint256 quantity,\r\n    uint256 tokenIdHolding,\r\n    uint256 multiplier,\r\n    address wallet,\r\n    uint256 roundId\r\n  ) public pure returns (bytes32) {\r\n    return (\r\n      keccak256(\r\n        abi.encodePacked(\r\n          keccak256(abi.encodePacked(wallet)),\r\n          keccak256(\r\n            abi.encodePacked(quantity, tokenIdHolding, multiplier, roundId)\r\n          )\r\n        )\r\n      )\r\n    );\r\n  }\r\n\r\n  function setKey() private {\r\n    uint256 roundId = currentRound();\r\n    uint256 key = random(); /* will use chainlink in real contract */\r\n    winningKey[roundId] = key;\r\n  }\r\n\r\n  function distributionLimit(Ores ore) public view returns (uint256) {\r\n    return Distributelimit[ore];\r\n  }\r\n\r\n  function SetdistributionLimit(Ores ore, uint256 limit) public onlyOwner {\r\n    Distributelimit[ore] = limit;\r\n  }\r\n\r\n  function checkDistribution(\r\n    uint256 roundId,\r\n    Ores ore\r\n  ) public view returns (uint256) {\r\n    return claimCounter[roundId][ore];\r\n  }\r\n\r\n  function getTicketKey(uint256 ticketId) private view returns (uint256) {\r\n    return\r\n      uint(\r\n        keccak256(\r\n          abi.encodePacked(\r\n            msg.sender,\r\n            ticketId,\r\n            block.timestamp,\r\n            block.difficulty,\r\n            block.number\r\n          )\r\n        )\r\n      ) % 10 ** 7;\r\n  }\r\n\r\n  function getWinningKey(uint256 roundId) public view returns (uint256) {\r\n    return winningKey[roundId];\r\n  }\r\n\r\n  function getTicketWinning(\r\n    uint256 roundId,\r\n    uint256 ticketId\r\n  ) public view returns (Ores ore) {\r\n    return TicketKey[roundId][ticketId].winningOre;\r\n  }\r\n\r\n  function getTicketHolding(\r\n    address wallet,\r\n    uint256 roundId\r\n  ) public view returns (TicketClaimed[] memory) {\r\n    uint256 len;\r\n    for (uint256 i = 1; i < RoundDetails[roundId].ticketsSold; i++) {\r\n      address holder = TicketKey[roundId][i].holder;\r\n      if (holder == wallet) {\r\n        len++;\r\n      }\r\n    }\r\n\r\n    TicketClaimed[] memory tickets = new TicketClaimed[](len);\r\n    uint256 index;\r\n    for (uint256 i = 1; i < RoundDetails[roundId].ticketsSold; i++) {\r\n      address holder = TicketKey[roundId][i].holder;\r\n      if (holder == wallet) {\r\n        tickets[index] = TicketClaimed(\r\n          i,\r\n          TicketKey[roundId][i].holder,\r\n          TicketKey[roundId][i].winningOre,\r\n          claimed[roundId][i]\r\n        );\r\n        index++;\r\n      }\r\n    }\r\n    return tickets;\r\n  }\r\n\r\n  function getWinningOre(\r\n    uint256 winningKey_,\r\n    uint256 roundId,\r\n    uint256 TicketKey_,\r\n    uint256 multiplier\r\n  ) private view returns (Ores Ore) {\r\n    // Ores previousOre = Ores.Iron; //starting from lowest\r\n    uint256 mlResult = 99999;\r\n    for (uint256 i = 1; i <= multiplier; ) {\r\n      uint256 multiplierResult = ticketKeyFactory(TicketKey_, i).add(\r\n        winningKey_\r\n      ) % 10 ** 5;\r\n      if (mlResult > multiplierResult) {\r\n        mlResult = multiplierResult;\r\n      }\r\n      unchecked {\r\n        ++i;\r\n      }\r\n    }\r\n    Ores previousOre = _getWinningOre(roundId, mlResult);\r\n    return previousOre;\r\n  }\r\n\r\n  function getOreNew(uint256 num) public pure returns (Ores ore) {\r\n    require(num <= 100000, \"INVALID\");\r\n    if (45000 <= num && num <= 100000) {\r\n      return Ores.Iron;\r\n    }\r\n    if (10000 <= num && num < 45000) {\r\n      return Ores.Bronze;\r\n    }\r\n    if (4500 <= num && num < 10000) {\r\n      return Ores.Emerald;\r\n    }\r\n    if (800 <= num && num < 4500) {\r\n      return Ores.Gold;\r\n    }\r\n    if (200 <= num && num < 800) {\r\n      return Ores.Diamond;\r\n    }\r\n    if (0 <= num && num < 200) {\r\n      return Ores.Vortexia;\r\n    }\r\n  }\r\n\r\n  function _getWinningOre(\r\n    uint256 roundId,\r\n    uint256 number\r\n  ) private view returns (Ores) {\r\n    Ores ore = getOreNew(number);\r\n    uint256 nextNum;\r\n    if (OreclaimAvailable(roundId, ore) == true) {\r\n      return ore;\r\n    } else {\r\n      nextNum = nextOre(roundId);\r\n    }\r\n    return numberToOre(nextNum);\r\n  }\r\n\r\n  function nextOre(uint256 roundId) private view returns (uint256 num) {\r\n    for (uint256 i = 5; i >= 0; ) {\r\n      if (claimAvailable(roundId, i)) {\r\n        return i;\r\n      }\r\n      unchecked {\r\n        ++i;\r\n      }\r\n    }\r\n  }\r\n\r\n  function oreToNumber(Ores ore) public pure returns (uint256 num) {\r\n    return uint256(ore);\r\n  }\r\n\r\n  function numberToOre(uint256 number) public view returns (Ores ore) {\r\n    return checkore[number];\r\n  }\r\n\r\n  function claimAvailable(\r\n    uint256 roundId,\r\n    uint256 ore\r\n  ) private view returns (bool) {\r\n    Ores ore_ = numberToOre(ore);\r\n    if (Distributelimit[ore_] > claimCounter[roundId][ore_]) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function OreclaimAvailable(\r\n    uint256 roundId,\r\n    Ores ore_\r\n  ) private view returns (bool) {\r\n    if (Distributelimit[ore_] > claimCounter[roundId][ore_]) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function ticketKeyFactory(\r\n    uint256 ticketKey,\r\n    uint256 multiplier\r\n  ) public pure returns (uint256) {\r\n    return (ticketKey.add(multiplier));\r\n  }\r\n\r\n  function claimAllWinning(\r\n    uint256 roundId,\r\n    uint256[] calldata ticketIds\r\n  ) public nonReentrant callerIsWallet {\r\n    _claim(roundId, ticketIds);\r\n  }\r\n\r\n  function bulkClaim(\r\n    BulkClaim[] calldata data\r\n  ) public nonReentrant callerIsWallet {\r\n    for (uint256 i = 0; i < data.length; ++i) {\r\n      uint256 roundId = data[i].roundId;\r\n      _claim(roundId, data[i].ticketIds);\r\n    }\r\n  }\r\n\r\n  function _claim(uint256 roundId, uint256[] calldata ticketIds) private {\r\n    if (roundId == currentRound()) revert RoundNotEnded();\r\n    uint256 totalWinning;\r\n    for (uint256 i = 0; i < ticketIds.length; i++) {\r\n      uint256 winning = preClaim(roundId, ticketIds[i]);\r\n      totalWinning += winning;\r\n    }\r\n    LotteryRound storage round = RoundDetails[roundId];\r\n    round.priceClaimed += totalWinning;\r\n    TransferHelper.safeTransfer(MinerToken, _msgSender(), totalWinning);\r\n    emit WinningClaimed(totalWinning, _msgSender());\r\n  }\r\n\r\n  function preClaim(\r\n    uint256 roundId,\r\n    uint256 ticketId\r\n  ) private returns (uint256) {\r\n    Ticket storage ticket = TicketKey[roundId][ticketId];\r\n    if (claimed[roundId][ticketId] == true) revert AlreadyClaimed();\r\n    claimed[roundId][ticketId] = true;\r\n    if (ticket.holder != _msgSender()) revert NotHolder();\r\n    uint256 winning = getPrice(ticket.winningOre);\r\n    return winning;\r\n  }\r\n\r\n  function withdraw(uint256 amount) external onlyOwner {\r\n    TransferHelper.safeTransferETH(owner(), amount);\r\n  }\r\n\r\n  function withdrawToken(address token, uint256 amount) external onlyOwner {\r\n    TransferHelper.safeTransfer(token, owner(), amount);\r\n  }\r\n\r\n  receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadFees\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ContractCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FakeSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LotteryEnded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotHolder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoundNotEnded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TicketsSold\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"nftConsumed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"WinningClaimed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Bronze\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DIGI_NFT\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Diamond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Emerald\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Gold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Iron\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LotteryRounds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"RoundDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"RoundId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ticketsSold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceClaimed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum DigiMinersLottery.Ores\",\"name\":\"ore\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"SetdistributionLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"TicketKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"enum DigiMinersLottery.Ores\",\"name\":\"winningOre\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Vortexia\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ticketIds\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DigiMinersLottery.BulkClaim[]\",\"name\":\"data\",\"type\":\"tuple[]\"}],\"name\":\"bulkClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenIdHolding\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"}],\"name\":\"buyTickets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signerWallet\",\"type\":\"address\"}],\"name\":\"changeSignerwallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"enum DigiMinersLottery.Ores\",\"name\":\"ore\",\"type\":\"uint8\"}],\"name\":\"checkDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ticketIds\",\"type\":\"uint256[]\"}],\"name\":\"claimAllWinning\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum DigiMinersLottery.Ores\",\"name\":\"ore\",\"type\":\"uint8\"}],\"name\":\"distributionLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinerToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"getOreNew\",\"outputs\":[{\"internalType\":\"enum DigiMinersLottery.Ores\",\"name\":\"ore\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum DigiMinersLottery.Ores\",\"name\":\"ore\",\"type\":\"uint8\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenIdHolding\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getSignData\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ticketId\",\"type\":\"uint256\"}],\"name\":\"getTicketDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"enum DigiMinersLottery.Ores\",\"name\":\"winningOre\",\"type\":\"uint8\"}],\"internalType\":\"struct DigiMinersLottery.Ticket\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getTicketHolding\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ticketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"enum DigiMinersLottery.Ores\",\"name\":\"winningOre\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"}],\"internalType\":\"struct DigiMinersLottery.TicketClaimed[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ticketId\",\"type\":\"uint256\"}],\"name\":\"getTicketWinning\",\"outputs\":[{\"internalType\":\"enum DigiMinersLottery.Ores\",\"name\":\"ore\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getWinningKey\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nftUsed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"numberToOre\",\"outputs\":[{\"internalType\":\"enum DigiMinersLottery.Ores\",\"name\":\"ore\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum DigiMinersLottery.Ores\",\"name\":\"ore\",\"type\":\"uint8\"}],\"name\":\"oreToNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum DigiMinersLottery.Ores\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"nft_\",\"type\":\"address\"}],\"name\":\"setDIGI_NFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager_\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minerToken\",\"type\":\"address\"}],\"name\":\"setMinerToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"startRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"startRoundbyManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ticketKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"}],\"name\":\"ticketKeyFactory\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ticketPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"winningKey\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DigiMinersLottery", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f5d9bf890d38ab21fddab6148dcb666d63cbf936782b227c1663dfa2bc94f8da"}