{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/D3MJob.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Copyright (C) 2021 Dai Foundation\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\npragma solidity 0.8.13;\\n\\nimport {IJob} from \\\"./interfaces/IJob.sol\\\";\\n\\ninterface SequencerLike {\\n    function isMaster(bytes32 network) external view returns (bool);\\n}\\n\\ninterface IlkRegistryLike {\\n    function list() external view returns (bytes32[] memory);\\n}\\n\\ninterface VatLike {\\n    function urns(bytes32, address) external view returns (uint256, uint256);\\n}\\n\\ninterface D3MHubLike {\\n    function vat() external view returns (VatLike);\\n    function pool(bytes32) external view returns (address);\\n    function exec(bytes32) external;\\n}\\n\\n/// @title Trigger D3M updates based on threshold\\ncontract D3MJob is IJob {\\n\\n    uint256 constant internal BPS = 10 ** 4;\\n    \\n    SequencerLike public immutable sequencer;\\n    IlkRegistryLike public immutable ilkRegistry;\\n    D3MHubLike public immutable hub;\\n    VatLike public immutable vat;\\n    uint256 public immutable threshold;             // Threshold deviation to kick off exec [BPS]\\n    uint256 public immutable ttl;                   // Cooldown before you can call exec again [seconds]\\n\\n    mapping (bytes32 => uint256) public expiry;     // Timestamp of when exec is allowed again\\n\\n    // --- Errors ---\\n    error NotMaster(bytes32 network);\\n    error Cooldown(bytes32 ilk, uint256 expiry);\\n    error ShouldNotTrigger(bytes32 ilk, uint256 part, uint256 nart);\\n\\n    // --- Events ---\\n    event Work(bytes32 indexed network);\\n\\n    constructor(address _sequencer, address _ilkRegistry, address _hub, uint256 _threshold, uint256 _ttl) {\\n        sequencer = SequencerLike(_sequencer);\\n        ilkRegistry = IlkRegistryLike(_ilkRegistry);\\n        hub = D3MHubLike(_hub);\\n        vat = hub.vat();\\n        threshold = _threshold;\\n        ttl = _ttl;\\n    }\\n\\n    function shouldTrigger(uint256 part, uint256 nart) internal view returns (bool) {\\n        if (part == 0 && nart != 0) return true;    // From zero to non-zero\\n        if (part != 0 && nart == 0) return true;    // From non-zero to zero\\n        if (part == 0 && nart == 0) return false;   // No change at zero\\n\\n        // Check if the delta is above the threshold\\n        uint256 delta = nart * BPS / part;\\n        if (delta < BPS) delta = BPS * BPS / delta; // Flip decreases to increase\\n\\n        return delta >= (BPS + threshold);\\n    }\\n\\n    function work(bytes32 network, bytes calldata args) external override {\\n        if (!sequencer.isMaster(network)) revert NotMaster(network);\\n\\n        bytes32 ilk = abi.decode(args, (bytes32));\\n        uint256 _expiry = expiry[ilk];\\n        if (block.timestamp < _expiry) revert Cooldown(ilk, _expiry);\\n        address pool = hub.pool(ilk);\\n        (, uint256 part) = vat.urns(ilk, pool);\\n\\n        hub.exec(ilk);\\n\\n        (, uint256 nart) = vat.urns(ilk, pool);\\n        if (!shouldTrigger(part, nart)) revert ShouldNotTrigger(ilk, part, nart);\\n        \\n        expiry[ilk] = block.timestamp + ttl;\\n\\n        emit Work(network);\\n    }\\n\\n    function workable(bytes32 network) external override returns (bool, bytes memory) {\\n        if (!sequencer.isMaster(network)) return (false, bytes(\\\"Network is not master\\\"));\\n\\n        bytes32[] memory ilks = ilkRegistry.list();\\n        for (uint256 i = 0; i < ilks.length; i++) {\\n            bytes memory args = abi.encode(ilks[i]);\\n            try this.work(network, args) {\\n                // Found a valid execution\\n                return (true, args);\\n            } catch {\\n                // For some reason this errored -- carry on\\n            }\\n        }\\n\\n        return (false, bytes(\\\"No ilks ready\\\"));\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IJob.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Copyright (C) 2021 Dai Foundation\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\npragma solidity >=0.8.0;\\n\\n/// @title Maker Keeper Network Job\\n/// @notice A job represents an independant unit of work that can be done by a keeper\\ninterface IJob {\\n\\n    /// @notice Executes this unit of work\\n    /// @dev Should revert iff workable() returns canWork of false\\n    /// @param network The name of the external keeper network\\n    /// @param args Custom arguments supplied to the job, should be copied from workable response\\n    function work(bytes32 network, bytes calldata args) external;\\n\\n    /// @notice Ask this job if it has a unit of work available\\n    /// @dev This should never revert, only return false if nothing is available\\n    /// @dev This should normally be a view, but sometimes that's not possible\\n    /// @param network The name of the external keeper network\\n    /// @return canWork Returns true if a unit of work is available\\n    /// @return args The custom arguments to be provided to work() or an error string if canWork is false\\n    function workable(bytes32 network) external returns (bool canWork, bytes memory args);\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/dss-test/lib/forge-std/lib/ds-test/src/\",\r\n      \"dss-interfaces/=lib/dss-test/lib/dss-interfaces/src/\",\r\n      \"dss-test/=lib/dss-test/src/\",\r\n      \"forge-std/=lib/dss-test/lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sequencer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ilkRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_hub\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ttl\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"Cooldown\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"network\",\"type\":\"bytes32\"}],\"name\":\"NotMaster\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"part\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nart\",\"type\":\"uint256\"}],\"name\":\"ShouldNotTrigger\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"network\",\"type\":\"bytes32\"}],\"name\":\"Work\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"expiry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hub\",\"outputs\":[{\"internalType\":\"contract D3MHubLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ilkRegistry\",\"outputs\":[{\"internalType\":\"contract IlkRegistryLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencer\",\"outputs\":[{\"internalType\":\"contract SequencerLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"threshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ttl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vat\",\"outputs\":[{\"internalType\":\"contract VatLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"network\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"args\",\"type\":\"bytes\"}],\"name\":\"work\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"network\",\"type\":\"bytes32\"}],\"name\":\"workable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "D3MJob", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000238b4e35daed6100c6162fae4510261f88996ec90000000000000000000000005a464c28d19848f44199d003bef5ecc87d090f8700000000000000000000000012f36cdea3a28c35ac8c6cc71d9265c17c74a27f00000000000000000000000000000000000000000000000000000000000001f40000000000000000000000000000000000000000000000000000000000000258", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}