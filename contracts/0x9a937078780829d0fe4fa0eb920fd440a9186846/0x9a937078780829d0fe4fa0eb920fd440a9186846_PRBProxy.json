{"SourceCode": "// SPDX-License-Identifier: Unlicense\r\npragma solidity >=0.8.4;\r\n\r\n/// @title IPRBProxy\r\n/// @author Paul Razvan Berg\r\n/// @notice Proxy contract to compose transactions on owner's behalf.\r\ninterface IPRBProxy {\r\n    /// EVENTS ///\r\n\r\n    event Execute(address indexed target, bytes data, bytes response);\r\n\r\n    event TransferOwnership(address indexed oldOwner, address indexed newOwner);\r\n\r\n    /// PUBLIC CONSTANT FUNCTIONS ///\r\n\r\n    /// @notice Returns a boolean flag that indicates whether the envoy has permission to call the given target\r\n    /// contract and function selector.\r\n    function getPermission(\r\n        address envoy,\r\n        address target,\r\n        bytes4 selector\r\n    ) external view returns (bool);\r\n\r\n    /// @notice The address of the owner account or contract.\r\n    function owner() external view returns (address);\r\n\r\n    /// @notice How much gas to reserve for running the remainder of the \"execute\" function after the DELEGATECALL.\r\n    /// @dev This prevents the proxy from becoming unusable if EVM opcode gas costs change in the future.\r\n    function minGasReserve() external view returns (uint256);\r\n\r\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\r\n\r\n    /// @notice Delegate calls to the target contract by forwarding the call data. Returns the data it gets back,\r\n    /// including when the contract call reverts with a reason or custom error.\r\n    ///\r\n    /// @dev Requirements:\r\n    /// - The caller must be either an owner or an envoy.\r\n    /// - `target` must be a deployed contract.\r\n    /// - The owner cannot be changed during the DELEGATECALL.\r\n    ///\r\n    /// @param target The address of the target contract.\r\n    /// @param data Function selector plus ABI encoded data.\r\n    /// @return response The response received from the target contract.\r\n    function execute(address target, bytes calldata data) external payable returns (bytes memory response);\r\n\r\n    /// @notice Gives or takes a permission from an envoy to call the given target contract and function selector\r\n    /// on behalf of the owner.\r\n    /// @dev It is not an error to reset a permission on the same (envoy,target,selector) tuple multiple types.\r\n    ///\r\n    /// Requirements:\r\n    /// - The caller must be the owner.\r\n    ///\r\n    /// @param envoy The address of the envoy account.\r\n    /// @param target The address of the target contract.\r\n    /// @param selector The 4 byte function selector on the target contract.\r\n    /// @param permission The boolean permission to set.\r\n    function setPermission(\r\n        address envoy,\r\n        address target,\r\n        bytes4 selector,\r\n        bool permission\r\n    ) external;\r\n\r\n    /// @notice Transfers the owner of the contract to a new account.\r\n    /// @dev Requirements:\r\n    /// - The caller must be the owner.\r\n    /// @param newOwner The address of the new owner account.\r\n    function transferOwnership(address newOwner) external;\r\n}// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\r\n\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\r\n\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\r\n\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n    /**\r\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\r\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\r\n     *\r\n     * NOTE: To accept the transfer, this must return\r\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n     * (i.e. 0xf23a6e61, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param id The ID of the token being transferred\r\n     * @param value The amount of tokens being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\r\n     * been updated.\r\n     *\r\n     * NOTE: To accept the transfer(s), this must return\r\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n     * (i.e. 0xbc197c81, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n}\r\n\r\n/**\r\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\r\n *\r\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\r\n * stuck.\r\n *\r\n * @dev _Available since v3.1._\r\n */\r\ncontract ERC1155Holder is ERC1155Receiver {\r\n    function onERC1155Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address,\r\n        uint256[] memory,\r\n        uint256[] memory,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n}// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\r\n\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n/**\r\n * @dev Implementation of the {IERC721Receiver} interface.\r\n *\r\n * Accepts all token transfers.\r\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\r\n */\r\ncontract ERC721Holder is IERC721Receiver {\r\n    /**\r\n     * @dev See {IERC721Receiver-onERC721Received}.\r\n     *\r\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n/// @notice Emitted when the caller is not the owner.\r\nerror PRBProxy__ExecutionNotAuthorized(address owner, address caller, address target, bytes4 selector);\r\n\r\n/// @notice Emitted when execution reverted with no reason.\r\nerror PRBProxy__ExecutionReverted();\r\n\r\n/// @notice Emitted when the caller is not the owner.\r\nerror PRBProxy__NotOwner(address owner, address caller);\r\n\r\n/// @notice Emitted when the owner is changed during the DELEGATECALL.\r\nerror PRBProxy__OwnerChanged(address originalOwner, address newOwner);\r\n\r\n/// @notice Emitted when passing an EOA or an undeployed contract as the target.\r\nerror PRBProxy__TargetInvalid(address target);\r\n\r\n/// @title PRBProxy\r\n/// @author Paul Razvan Berg\r\ncontract PRBProxy is IPRBProxy, ERC1155Holder, ERC721Holder {\r\n    /// PUBLIC STORAGE ///\r\n\r\n    /// @inheritdoc IPRBProxy\r\n    address public override owner;\r\n\r\n    /// @inheritdoc IPRBProxy\r\n    uint256 public override minGasReserve;\r\n\r\n    /// INTERNAL STORAGE ///\r\n\r\n    /// @notice Maps envoys to target contracts to function selectors to boolean flags.\r\n    mapping(address => mapping(address => mapping(bytes4 => bool))) internal permissions;\r\n\r\n    /// CONSTRUCTOR ///\r\n\r\n    constructor() {\r\n        minGasReserve = 5_000;\r\n        owner = msg.sender;\r\n        emit TransferOwnership(address(0), msg.sender);\r\n    }\r\n\r\n    /// FALLBACK FUNCTION ///\r\n\r\n    /// @dev Called when Ether is sent and the call data is empty.\r\n    receive() external payable {}\r\n\r\n    /// PUBLIC CONSTANT FUNCTIONS ///\r\n\r\n    /// @inheritdoc IPRBProxy\r\n    function getPermission(\r\n        address envoy,\r\n        address target,\r\n        bytes4 selector\r\n    ) external view override returns (bool) {\r\n        return permissions[envoy][target][selector];\r\n    }\r\n\r\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\r\n\r\n    /// @inheritdoc IPRBProxy\r\n    function execute(address target, bytes calldata data) external payable override returns (bytes memory response) {\r\n        // Check that the caller is either the owner or an envoy.\r\n        if (owner != msg.sender) {\r\n            bytes4 selector;\r\n            assembly {\r\n                selector := calldataload(data.offset)\r\n            }\r\n            if (!permissions[msg.sender][target][selector]) {\r\n                revert PRBProxy__ExecutionNotAuthorized(owner, msg.sender, target, selector);\r\n            }\r\n        }\r\n\r\n        // Check that the target is a valid contract.\r\n        if (target.code.length == 0) {\r\n            revert PRBProxy__TargetInvalid(target);\r\n        }\r\n\r\n        // Save the owner address in memory. This local variable cannot be modified during the DELEGATECALL.\r\n        address owner_ = owner;\r\n\r\n        // Reserve some gas to ensure that the function has enough to finish the execution.\r\n        uint256 stipend = gasleft() - minGasReserve;\r\n\r\n        // Delegate call to the target contract.\r\n        bool success;\r\n        (success, response) = target.delegatecall{ gas: stipend }(data);\r\n\r\n        // Check that the owner has not been changed.\r\n        if (owner_ != owner) {\r\n            revert PRBProxy__OwnerChanged(owner_, owner);\r\n        }\r\n\r\n        // Log the execution.\r\n        emit Execute(target, data, response);\r\n\r\n        // Check if the call was successful or not.\r\n        if (!success) {\r\n            // If there is return data, the call reverted with a reason or a custom error.\r\n            if (response.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(response)\r\n                    revert(add(32, response), returndata_size)\r\n                }\r\n            } else {\r\n                revert PRBProxy__ExecutionReverted();\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IPRBProxy\r\n    function setPermission(\r\n        address envoy,\r\n        address target,\r\n        bytes4 selector,\r\n        bool permission\r\n    ) external override {\r\n        if (owner != msg.sender) {\r\n            revert PRBProxy__NotOwner(owner, msg.sender);\r\n        }\r\n        permissions[envoy][target][selector] = permission;\r\n    }\r\n\r\n    /// @inheritdoc IPRBProxy\r\n    function transferOwnership(address newOwner) external override {\r\n        address oldOwner = owner;\r\n        if (oldOwner != msg.sender) {\r\n            revert PRBProxy__NotOwner(oldOwner, msg.sender);\r\n        }\r\n        owner = newOwner;\r\n        emit TransferOwnership(oldOwner, newOwner);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"PRBProxy__ExecutionNotAuthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PRBProxy__ExecutionReverted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"PRBProxy__NotOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"originalOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"PRBProxy__OwnerChanged\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"PRBProxy__TargetInvalid\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"}],\"name\":\"Execute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"TransferOwnership\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"envoy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"getPermission\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minGasReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"envoy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"},{\"internalType\":\"bool\",\"name\":\"permission\",\"type\":\"bool\"}],\"name\":\"setPermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PRBProxy", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "8000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://40baae7ba7d17a7154c2408661b75cada84bdd2dbfcadd8f3fe3bd34c5af3fe7"}