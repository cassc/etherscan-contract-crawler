/*
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKkx0KKKKKOdlkXKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKd..,oxdxd,  'kKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKXO,    ....    cKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK0:  .,'..,;'. cKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK0: 'xKO;,OXO; ,kXKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKXk' .lxl..;ol. .lKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKO:.  .  .     .lxxOKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK0d;'.        .....;oxkkk0KKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK0x'             ..''.,dKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK0:              ,xO:.:0KKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKc .;' .;. .:'  .cdc.:0KKKKKKKKKKKKKKKK
KKKKKKKKKKKKK00000000000000KKKKKKKKKKKKKKK00000000000000KK0KKd'..;. ':. ck;.......l0KKKKKKKKKKKKKKKK
KKKKKKKKKKKKKo,''''''''''',xKKKKKKKKKKKKKd,''''''''''''ckdodoc;;::;,:c;;lo:;;cl:;cddddx0KKKKKKKKKKKK
KKKKKKKKKKKKXx'............c0KKKKKKKKKKK0:.............oOollllllllllllllooooooooooooood0XKKKKKKKKKKK
KKKKKKKKKKKKKKc........... ,OXKKKKKKKKKXk' ...........:00olllllllllllllllloooooooooooox0KKKKKKKKKKKK
KKKKKKKKKKKKKXk, ...........dXKKKKKKKKKKo........... 'xX0ollllllllllllllloooooooooooookKKKKKKKKKKKKK
KKKKKKKKKKKKKKKl............:0XKKKKKKKK0;............lKK0dllllllllllllloloooooooooooookKKKKKKKKKKKKK
KKKKKKKKKKKKKKXO,...........'kXKKKKKKKKd. ..........,kKK0dclllllllllllxOkOOOkkkkkkkkkk0KKKKKKKKKKKKK
KKKKKKKKKKKKKKKKo. ........ .lKKKKKKKX0;.........  .oKKK0dcllllllllllokKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKO;...........,OXKKKKKKo............:0XKK0dlllllllllllokKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKd. ..........oKKKKKXO;..........':xKKKK0dlllllllllllokKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKK0:...........:0XKKKKo...........lOKKKKK0dlllllllllllodxxxxxxxxxxxxOKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKx.......... .xKKKXO,..........,OXXKKKKKxlllllllllllllllllooooooookKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKK0c...........c0KKKo. ....... .dKKKKKKKKxlllllllllllllloloooooooooOKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKk' ........ ,kKKk,........ .:0KKKKKKKKxlllllllllllllloooooooooodOKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKl...........oKKl......... 'xXKKKKKKKKkllllllllllllllllloooooood0XKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKk, .........;Ok, .........lKKKKKKKKKKklllllllllllodxxxxxxxxxxxkKXKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKo...........ol..........;OKKKKKKKKKKkllllllllllloOKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKXO;......................dKKKKKKKKKKKxllllllllllloOKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKo.....................c0KKKKKKKKKKKxllllllllllloOKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKO;.................. 'kXKKKKKKKKKK0dllllllllllloOKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKd. .................oKKKKKKKKKKKK0dlllllllllllokKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKK0:.................;OKKKKKKKKKKKK0dllllllllllllkKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKXx'...............'dKKKKKKKKKKKKKOolllllllllollkKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKkxxxxxxxxxxxxxxxkKKKKKKKKKKKKKKKOOOOOOOOOOOOO0KKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
*/

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "./AccessControlV.sol";

contract VeeFriendsV2 is
    ERC721,
    IERC721Enumerable,
    ReentrancyGuard,
    AccessControlV
{
    string private baseUri;
    uint256 private currentIndex;

    struct InventoryTypeConfig {
        uint256 price;
        uint256 firstId;
        uint256 numTokens;
        uint256 numMinted;
        bool isActive;
    }
    mapping(string => InventoryTypeConfig) public inventoryTypeConfig;

    mapping(uint256 => uint256) internal indexTokenMap;

    uint256 constant MAX_TOKEN_SUPPLY = 55555;

    address payable public royaltyAddress;
    uint256 public royaltyBps;

    constructor(
        string memory initialBaseUri,
        string memory contractName,
        string memory contractSymbol
    ) ERC721(contractName, contractSymbol) {
        setBaseURI(initialBaseUri);
        royaltyAddress = payable(msg.sender);
        royaltyBps = 655;
    }

    function setInventoryTypeConfig(
        string memory inventoryType,
        uint256 price,
        uint256 firstId,
        uint256 numTokens
    ) public onlyRole(DEFAULT_ADMIN_ROLE) {
        require(currentIndex < MAX_TOKEN_SUPPLY, "All minted");
        require(
            inventoryTypeConfig[inventoryType].numMinted == 0,
            "Inv type minting"
        );

        inventoryTypeConfig[inventoryType] = InventoryTypeConfig(
            price,
            firstId,
            numTokens,
            0,
            false
        );
    }

    function setInventoryTypeNumTokens(
        string memory inventoryType,
        uint256 numTokens
    ) public onlyRole(DEFAULT_ADMIN_ROLE) {
        require(currentIndex < MAX_TOKEN_SUPPLY, "All minted");
        require(
            inventoryTypeConfig[inventoryType].numMinted <
                inventoryTypeConfig[inventoryType].numTokens,
            "Inv type sold out"
        );
        require(
            inventoryTypeConfig[inventoryType].numMinted <= numTokens,
            "Minted must be less then or equal total"
        );
        inventoryTypeConfig[inventoryType].numTokens = numTokens;
    }

    function setInventoryTypeActiveFlag(
        string memory inventoryType,
        bool isActive
    ) public onlyRole(DEFAULT_ADMIN_ROLE) {
        inventoryTypeConfig[inventoryType].isActive = isActive;
    }

    function submitOrder(
        string memory orderId,
        string memory inventoryType,
        uint256 quantity
    ) public payable nonReentrant {
        require(
            inventoryTypeConfig[inventoryType].isActive,
            "Inv type is not active"
        );
        require(
            inventoryTypeConfig[inventoryType].price * quantity < msg.value,
            "Incorrect price"
        );

        address payable nextMinter = _selectNextMinter();
        addressMintCount[nextMinter]++;
        nextMinter.transfer(msg.value);

        emit OrderSubmitted(
            orderId,
            inventoryType,
            quantity,
            _msgSender(),
            msg.value,
            nextMinter,
            _msgData()
        );
    }

    function setBaseURI(string memory newBaseUri)
        public
        onlyRole(DEFAULT_ADMIN_ROLE)
        returns (string memory)
    {
        require(bytes(newBaseUri).length > 0, "Invalid baseUrl");

        baseUri = newBaseUri;
        return baseUri;
    }

    function _baseURI() internal view override returns (string memory) {
        return baseUri;
    }

    function setDropRoyalties(
        address payable newRoyaltyAddress,
        uint256 newRoyaltyBps
    ) public onlyRole(DEFAULT_ADMIN_ROLE) {
        royaltyAddress = newRoyaltyAddress;
        royaltyBps = newRoyaltyBps;
    }

    function getFeeRecipients(uint256)
        public
        view
        returns (address payable[] memory)
    {
        address payable[] memory result = new address payable[](1);
        result[0] = royaltyAddress;
        return result;
    }

    function getFeeBps(uint256) public view returns (uint256[] memory) {
        uint256[] memory result = new uint256[](1);
        result[0] = royaltyBps;
        return result;
    }

    function mintBatch(
        address buyer,
        string memory orderId,
        string memory inventoryType,
        uint256[] memory tokenIds
    ) public onlyRole(MINTER_ROLE) nonReentrant {
        uint256 updatedIndex = currentIndex;

        require(
            updatedIndex + tokenIds.length <= MAX_TOKEN_SUPPLY,
            "None left to mint batch"
        );
        require(
            inventoryTypeConfig[inventoryType].isActive,
            "Inv type is not active"
        );
        require(
            inventoryTypeConfig[inventoryType].numMinted + tokenIds.length <=
                inventoryTypeConfig[inventoryType].numTokens,
            "None left in inv to mint batch"
        );

        uint256 index;
        for (index = 0; index < tokenIds.length; index++) {
            uint256 tokenId = tokenIds[index];

            require(
                inventoryTypeConfig[inventoryType].firstId <= tokenId,
                "Token id is not in inv"
            );
            require(
                tokenId <
                    inventoryTypeConfig[inventoryType].firstId +
                        inventoryTypeConfig[inventoryType].numTokens,
                "Token id is not in inv"
            );
            require(!_exists(tokenId), "Token already minted");

            _safeMint(buyer, tokenId);
        }

        for (index = 0; index < tokenIds.length; index++) {
            updatedIndex++;
            uint256 tokenId = tokenIds[index];
            indexTokenMap[updatedIndex - 1] = tokenId;
            inventoryTypeConfig[inventoryType].numMinted++;
        }

        currentIndex = updatedIndex;
    }

    function totalSupply() public view returns (uint256) {
        return currentIndex;
    }

    function tokenOfOwnerByIndex(address _owner, uint256 index)
        external
        view
        returns (uint256)
    {
        uint256 balance = balanceOf(_owner);
        require(index < balance, "Owner index out of bounds");

        uint256[] memory ownerTokens = _tokensOfOwner(_owner);
        require(
            balance == ownerTokens.length,
            "Unable to get token of owner by index"
        );

        return ownerTokens[index];
    }

    function tokenByIndex(uint256 index) external view returns (uint256) {
        require(index < totalSupply(), "Global index out of bounds");
        return indexTokenMap[index];
    }

    function tokensOfOwner(address _owner)
        external
        view
        returns (uint256[] memory ownerTokens)
    {
        return _tokensOfOwner(_owner);
    }

    function _tokensOfOwner(address _owner)
        internal
        view
        returns (uint256[] memory ownerTokens)
    {
        uint256 tokenCount = balanceOf(_owner);

        if (tokenCount == 0) {
            return new uint256[](0);
        } else {
            uint256[] memory result = new uint256[](tokenCount);
            uint256 resultIndex = 0;
            uint256 total = totalSupply();

            uint256 index;
            for (index = 0; index < total; index++) {
                uint256 tokenId = indexTokenMap[index];
                if (ownerOf(tokenId) == _owner) {
                    result[resultIndex] = tokenId;
                    resultIndex++;
                }
            }

            return result;
        }
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, IERC165, AccessControl)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

    function withdraw() public onlyRole(DEFAULT_ADMIN_ROLE) nonReentrant {
        uint256 amount = address(this).balance;
        require(amount > 0, "no balance");
        Address.sendValue(payable(msg.sender), amount);
    }

    event OrderSubmitted(
        string indexed orderId,
        string inventoryType,
        uint256 quantity,
        address buyer,
        uint256 price,
        address minter,
        bytes data
    );
}