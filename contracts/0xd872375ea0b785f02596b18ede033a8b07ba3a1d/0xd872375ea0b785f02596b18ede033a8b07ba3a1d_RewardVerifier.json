{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/verifiers/RewardVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nlibrary Pairing {\\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n\\n    struct G1Point {\\n        uint256 X;\\n        uint256 Y;\\n    }\\n\\n    // Encoding of field elements is: X[0] * z + X[1]\\n    struct G2Point {\\n        uint256[2] X;\\n        uint256[2] Y;\\n    }\\n\\n    /*\\n     * @return The negation of p, i.e. p.plus(p.negate()) should be zero\\n     */\\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\\n        // The prime q in the base field F_q for G1\\n        if (p.X == 0 && p.Y == 0) {\\n            return G1Point(0, 0);\\n        } else {\\n            return G1Point(p.X, PRIME_Q - (p.Y % PRIME_Q));\\n        }\\n    }\\n\\n    /*\\n     * @return r the sum of two points of G1\\n     */\\n    function plus(\\n        G1Point memory p1,\\n        G1Point memory p2\\n    ) internal view returns (G1Point memory r) {\\n        uint256[4] memory input = [\\n            p1.X, p1.Y,\\n            p2.X, p2.Y\\n        ];\\n        bool success;\\n\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\\n            // Use \\\"invalid\\\" to make gas estimation work\\n            switch success case 0 { invalid() }\\n        }\\n\\n        require(success, \\\"pairing-add-failed\\\");\\n    }\\n\\n    /*\\n     * @return r the product of a point on G1 and a scalar, i.e.\\n     *         p == p.scalarMul(1) and p.plus(p) == p.scalarMul(2) for all\\n     *         points p.\\n     */\\n    function scalarMul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\\n        uint256[3] memory input = [p.X, p.Y, s];\\n        bool success;\\n\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\\n            // Use \\\"invalid\\\" to make gas estimation work\\n            switch success case 0 { invalid() }\\n        }\\n\\n        require(success, \\\"pairing-mul-failed\\\");\\n    }\\n\\n    /* @return The result of computing the pairing check\\n     *         e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\\n     *         For example,\\n     *         pairing([P1(), P1().negate()], [P2(), P2()]) should return true.\\n     */\\n    function pairing(\\n        G1Point memory a1,\\n        G2Point memory a2,\\n        G1Point memory b1,\\n        G2Point memory b2,\\n        G1Point memory c1,\\n        G2Point memory c2,\\n        G1Point memory d1,\\n        G2Point memory d2\\n    ) internal view returns (bool) {\\n        uint256[24] memory input = [\\n            a1.X, a1.Y, a2.X[0], a2.X[1], a2.Y[0], a2.Y[1],\\n            b1.X, b1.Y, b2.X[0], b2.X[1], b2.Y[0], b2.Y[1],\\n            c1.X, c1.Y, c2.X[0], c2.X[1], c2.Y[0], c2.Y[1],\\n            d1.X, d1.Y, d2.X[0], d2.X[1], d2.Y[0], d2.Y[1]\\n        ];\\n        uint256[1] memory out;\\n        bool success;\\n\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            success := staticcall(sub(gas(), 2000), 8, input, mul(24, 0x20), out, 0x20)\\n            // Use \\\"invalid\\\" to make gas estimation work\\n            switch success case 0 { invalid() }\\n        }\\n\\n        require(success, \\\"pairing-opcode-failed\\\");\\n        return out[0] != 0;\\n    }\\n}\\n\\ncontract RewardVerifier {\\n    uint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n    using Pairing for *;\\n\\n    struct VerifyingKey {\\n        Pairing.G1Point alfa1;\\n        Pairing.G2Point beta2;\\n        Pairing.G2Point gamma2;\\n        Pairing.G2Point delta2;\\n        Pairing.G1Point[13] IC;\\n    }\\n\\n    function verifyingKey() internal pure returns (VerifyingKey memory vk) {\\n        vk.alfa1 = Pairing.G1Point(uint256(16039702465141526120850792834969313298418056812611510850825123584305748850161), uint256(19241284746314462835543196050553119424535317912098545655582929597274275369361));\\n        vk.beta2 = Pairing.G2Point([uint256(3336767758215559640516611203321301470327731141161240526177868793995396335026), uint256(4904933086130749884949153518526779796800814013346803149557666542219777533391)], [uint256(6205619877854586575812045986472918044530694741817230303152687674691942198155), uint256(13325725893865776488991089096764513239128355200672659431316246428270688499861)]);\\n        vk.gamma2 = Pairing.G2Point([uint256(1500191988347403435220354487207247208598059467779990431166375167307110402863), uint256(18156684396312035874614961411468290978375863710611878660998827508369876518873)], [uint256(5815312237998246614925949050349923391959940672823499426250851638332248557964), uint256(8867845422450407463950317747220950112692624337616305066608831894874189016734)]);\\n        vk.delta2 = Pairing.G2Point([uint256(9707615360976773817795362293290380552940208099108240394651906851024006938345), uint256(20661619789630516778941288638674776366100052386599186247367896491738745560261)], [uint256(9633211799145849631472261759796497784186182373135178386214325156389161762079), uint256(14750180010381351323291981718149293286584410074752492276585817187236347829048)]);\\n        vk.IC[0] = Pairing.G1Point(uint256(19092799488349265772355633789370885689183765136249755508157115748922624254915), uint256(5725758807290658767928545259114950967485716781803802857745061265794237694003));\\n        vk.IC[1] = Pairing.G1Point(uint256(1658797158265165146302956423595851362529042046144273698600462005278776069216), uint256(7053449963305117873064047573561716884606767007994113528595435081062236376535));\\n        vk.IC[2] = Pairing.G1Point(uint256(14880615175008808863030175725086171630257208548782875756963056568320795374285), uint256(20674455042748698195392090874345460699297675291105378675680273778503343845970));\\n        vk.IC[3] = Pairing.G1Point(uint256(8134534379509454583096011882236043395069729951276135656813144188829419608067), uint256(2778075429853321495375121276396188393465903729967471689393514758824346179020));\\n        vk.IC[4] = Pairing.G1Point(uint256(17342272751528404286828156174971213549868238129941873082237729624811849047576), uint256(17508363345233339960066380244673881424500772680846968556068914880104471612542));\\n        vk.IC[5] = Pairing.G1Point(uint256(3500105726360049134160784838140096634611481770931036431525108524254242753184), uint256(8704144235019503238680095442637299050510187963903223288552224274399977937623));\\n        vk.IC[6] = Pairing.G1Point(uint256(18070957616243133333412413138733472814610352786555614773017315400552968826120), uint256(5072398890416045481275238223660393327905508729956737023288179099718787831725));\\n        vk.IC[7] = Pairing.G1Point(uint256(18461507278509245488653119100051339761129919042466610311937951903300596773375), uint256(15316902460005288104980244876506811633249194698230415682741381948526661779405));\\n        vk.IC[8] = Pairing.G1Point(uint256(13385484458179354765994545379187484522605857596564965554154886095645519318675), uint256(19411662003143768092181371875747633409064884329204276242104321471438710139714));\\n        vk.IC[9] = Pairing.G1Point(uint256(2334552605081923364977590548173508530516865408156755437077918343841846883958), uint256(21663935704375940250637142118655522951258077240014204021734107778714264537988));\\n        vk.IC[10] = Pairing.G1Point(uint256(2793335900459976410545768743108087713495396060512136674887146175528244652275), uint256(13196353583577665039405161285323527822956687712360834330281529495195738470609));\\n        vk.IC[11] = Pairing.G1Point(uint256(7185886617370158543506797921865581835857222313705594241855529938389896030811), uint256(14077924578438462285368630108946423620378844605612171504991428312379571696119));\\n        vk.IC[12] = Pairing.G1Point(uint256(17513052857377679395782122940410033523763033753432732496378181534845526906058), uint256(4398729926649650362924800490087580738645675443595278530259624514008764785746));\\n\\n    }\\n\\n    /*\\n     * @returns Whether the proof is valid given the hardcoded verifying key\\n     *          above and the public inputs\\n     */\\n    function verifyProof(\\n        bytes memory proof,\\n        uint256[12] memory input\\n    ) public view returns (bool) {\\n        uint256[8] memory p = abi.decode(proof, (uint256[8]));\\n        for (uint8 i = 0; i < p.length; i++) {\\n            // Make sure that each element in the proof is less than the prime q\\n            require(p[i] < PRIME_Q, \\\"verifier-proof-element-gte-prime-q\\\");\\n        }\\n        Pairing.G1Point memory proofA = Pairing.G1Point(p[0], p[1]);\\n        Pairing.G2Point memory proofB = Pairing.G2Point([p[2], p[3]], [p[4], p[5]]);\\n        Pairing.G1Point memory proofC = Pairing.G1Point(p[6], p[7]);\\n\\n        VerifyingKey memory vk = verifyingKey();\\n        // Compute the linear combination vkX\\n        Pairing.G1Point memory vkX = vk.IC[0];\\n        for (uint256 i = 0; i < input.length; i++) {\\n            // Make sure that every input is less than the snark scalar field\\n            require(input[i] < SNARK_SCALAR_FIELD, \\\"verifier-input-gte-snark-scalar-field\\\");\\n            vkX = Pairing.plus(vkX, Pairing.scalarMul(vk.IC[i + 1], input[i]));\\n        }\\n\\n        return Pairing.pairing(\\n            Pairing.negate(proofA),\\n            proofB,\\n            vk.alfa1,\\n            vk.beta2,\\n            vkX,\\n            vk.gamma2,\\n            proofC,\\n            vk.delta2\\n        );\\n    }\\n}\\n\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"internalType\":\"uint256[12]\",\"name\":\"input\",\"type\":\"uint256[12]\"}],\"name\":\"verifyProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RewardVerifier", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "istanbul", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}