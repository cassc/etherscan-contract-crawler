{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Family.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n\\nhttps://t.me/FAMILYETHPORTAL\\n\\nhttps://x.com/familytokeneth\\n\\nhttps://family-token.net\\n                                                                                                                                     \\n*/\\n\\n\\npragma solidity ^0.8.17;\\n\\nlibrary Address{\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return payable(msg.sender);\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this;\\n        return msg.data;\\n    }\\n}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\ninterface IERC20 {\\n\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface IFactory{\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n}\\n\\ninterface IRouter {\\n    function factory() external pure returns (address);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function WETH() external pure returns (address);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline) external;\\n}\\n\\ncontract Family is Context, IERC20, Ownable {\\n\\n    using Address for address payable;\\n\\n    IRouter public router;\\n    address public pair;\\n    \\n    mapping (address => uint256) private _tOwned;\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n    mapping (address => bool) public _isExcludedFromFee;\\n    mapping (address => bool) public _isExcludedFromMaxBalance;\\n\\n    uint8 private constant _decimals = 9; \\n    uint256 private _tTotal = 1_000_000_000 * (10**_decimals);\\n    uint256 public swapThreshold = 10_000_000 * (10**_decimals); \\n    uint256 public maxTxAmount = 20_000_000 * (10**_decimals);\\n    uint256 public maxWallet =  20_000_000 * (10**_decimals);\\n\\n    string private constant _name = \\\"Family\\\"; \\n    string private constant _symbol = \\\"FAMILY\\\";\\n\\n    uint8 public buyTax = 25; \\n    uint8 public sellTax = 40;\\n\\n    address private marketingWallet = 0x8Bf4Eb9c7B53f799A55F5B08459779Fa16b9dCf3; \\n    \\n    bool public enableTrading = false;\\n    bool private swapping;\\n    modifier lockTheSwap {\\n        swapping = true;\\n        _;\\n        swapping = false;\\n    }   \\n\\n    event SwapAndLiquify();\\n    event TaxesChanged();\\n\\n    constructor () {\\n        _tOwned[_msgSender()] = _tTotal;\\n\\n        IRouter _router = IRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); \\n        address _pair = IFactory(_router.factory()).createPair(address(this), _router.WETH());\\n        router = _router; pair = _pair;\\n       \\n        _approve(address(this), address(router), ~uint256(0));\\n        \\n        _isExcludedFromFee[owner()] = true;\\n        _isExcludedFromFee[address(this)] = true;\\n        _isExcludedFromFee[marketingWallet] = true;\\n\\n        _isExcludedFromMaxBalance[owner()] = true;\\n        _isExcludedFromMaxBalance[address(this)] = true;\\n        _isExcludedFromMaxBalance[marketingWallet] = true;\\n        _isExcludedFromMaxBalance[pair] = true;\\n        \\n        emit Transfer(address(0), _msgSender(), _tTotal);\\n    }\\n\\n    function name() public pure returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public pure returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public pure returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n        return _tTotal;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _tOwned[account];\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\\n        return true;\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) private {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n    \\n    receive() external payable {}\\n\\n    function openTrading() external onlyOwner{\\n        require(!enableTrading,\\\"Can only be opened once\\\");\\n        enableTrading = true;\\n    }\\n\\n    function setContractTaxes(uint8 buyTax_, uint8 sellTax_) external onlyOwner{\\n        require(buyTax_ <= 35 && sellTax_<= 99, \\\"Taxes can't exceed the limit.\\\");\\n        buyTax = buyTax_; sellTax = sellTax_;\\n        emit TaxesChanged();\\n    }\\n\\n    function setContractLimits(uint maxTX_EXACT, uint maxWallet_EXACT) public onlyOwner{\\n        uint pointFiveSupply = (_tTotal * 5 / 1000) / (10**_decimals);\\n        require(maxTX_EXACT >= pointFiveSupply && maxWallet_EXACT >= pointFiveSupply, \\\"Invalid Settings\\\");\\n        maxTxAmount = maxTX_EXACT * (10**_decimals);\\n        maxWallet = maxWallet_EXACT * (10**_decimals);\\n    }\\n\\n    function setSwapSettings(uint swapThreshold_EXACT) public onlyOwner{\\n        swapThreshold = swapThreshold_EXACT * (10**_decimals);\\n    }\\n\\n    function setExcludedFromLimits(address account,bool isExcluded) public onlyOwner{\\n        _isExcludedFromMaxBalance[account] = isExcluded;\\n    }\\n\\n    function setExcludedFromTaxes(address account, bool isExcluded) public onlyOwner{\\n        _isExcludedFromFee[account] = isExcluded;\\n    }\\n\\n    function manualSwap() external lockTheSwap{\\n        require(msg.sender == marketingWallet);\\n        uint256 tokenBalance = balanceOf(address(this));\\n        if(tokenBalance > 0){\\n            uint256 ethSwapped = swapTokensForETH(tokenBalance);\\n            if(ethSwapped > 0)\\n                payable(marketingWallet).transfer(ethSwapped);\\n        }\\n        if (address(this).balance > 0)\\n            payable(marketingWallet).sendValue(address(this).balance);\\n    }\\n\\n    function _preTransferCheck(address from,address to,uint256 amount) internal{\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(amount > 0, \\\"Transfer amount must be greater than zero\\\");\\n        require(amount <= maxTxAmount || _isExcludedFromMaxBalance[from], \\\"Transfer amount exceeds the _maxTxAmount.\\\");\\n\\n        if(!enableTrading)\\n            require(_isExcludedFromMaxBalance[from] && from != pair);\\n\\n        if(!_isExcludedFromMaxBalance[to])\\n            require(balanceOf(to) + amount <= maxWallet, \\\"Transfer amount exceeds the maxWallet.\\\");\\n        \\n        if (balanceOf(address(this)) >= swapThreshold && !swapping && enableTrading && from != pair && from != owner() && to != owner())\\n            swapAndLiquify();\\n    }\\n\\n    function _getTaxValues(uint amount, address from, bool isSell) private returns(uint256){\\n        uint256 taxedTokens = amount * buyTax / 100;\\n        if(isSell)\\n            taxedTokens = amount * sellTax / 100;\\n\\n        if (taxedTokens > 0){\\n            _tOwned[address(this)] += taxedTokens;\\n            emit Transfer (from, address(this), taxedTokens);\\n        }\\n        return (amount - taxedTokens);\\n    }\\n\\n    function _transfer(address from,address to,uint256 amount) private {\\n        _preTransferCheck(from, to, amount);\\n        _tOwned[from] -= amount;\\n        uint256 transferAmount = amount;\\n        if(!_isExcludedFromFee[from] && !_isExcludedFromFee[to]){\\n            transferAmount = _getTaxValues(amount, from, to == pair);\\n        }\\n        _tOwned[to] += transferAmount;\\n        emit Transfer(from, to, transferAmount);\\n    }\\n\\n    function swapAndLiquify() private lockTheSwap{\\n\\n        uint256 tokensForMarketing = swapThreshold * 100 / 100;\\n        uint256 tokensForLiquidity = swapThreshold * 0 / 100;\\n        \\n        if(tokensForMarketing > 0){\\n            uint256 ethSwapped = swapTokensForETH(tokensForMarketing);\\n            if(ethSwapped > 0)\\n                payable(marketingWallet).transfer(ethSwapped);\\n        }\\n\\n        if(tokensForLiquidity > 0){\\n            uint half = tokensForLiquidity / 2;\\n            uint otherHalf = tokensForLiquidity - half;\\n            uint balAutoLP = swapTokensForETH(half);\\n            if (balAutoLP > 0)\\n                addLiquidity(otherHalf, balAutoLP);\\n        }\\n\\n        if (address(this).balance > 0)\\n            payable(marketingWallet).sendValue(address(this).balance);\\n        \\n        emit SwapAndLiquify();\\n\\n    }\\n\\n    function swapTokensForETH(uint256 tokenAmount) private returns (uint256) {\\n        uint256 initialBalance = address(this).balance;\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = router.WETH();\\n\\n        _approve(address(this), address(router), tokenAmount);\\n\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n        return (address(this).balance - initialBalance);\\n    }\\n\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\n        _approve(address(this), address(router), tokenAmount);\\n\\n        (,uint256 ethFromLiquidity,) = router.addLiquidityETH {value: ethAmount} (\\n            address(this),\\n            tokenAmount,\\n            0,\\n            0,\\n            marketingWallet,\\n            block.timestamp\\n        );\\n        \\n        if (ethAmount - ethFromLiquidity > 0)\\n            payable(marketingWallet).sendValue (ethAmount - ethFromLiquidity);\\n    }\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TaxesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedFromMaxBalance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTax\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTax\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTX_EXACT\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWallet_EXACT\",\"type\":\"uint256\"}],\"name\":\"setContractLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"buyTax_\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sellTax_\",\"type\":\"uint8\"}],\"name\":\"setContractTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"setExcludedFromLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"setExcludedFromTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"swapThreshold_EXACT\",\"type\":\"uint256\"}],\"name\":\"setSwapSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Family", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}