{"SourceCode": "// File: contracts/upgradeable-Bridge/IronVestPreCheck.sol\r\n\r\n\r\n\r\npragma solidity 0.8.17;\r\n\r\n/// @author The ferrum network.\r\n/// @title This is a vesting contract named as IronVest.\r\n/// @dev This contract is upgradeable please use a framework i.e truffle or hardhat for deploying it.\r\n/// @notice This contract contains the power of accesscontrol.\r\n/// There are two different vesting defined in the contract with different functionalities.\r\n/// Have fun reading it. Hopefully it's bug-free. God Bless.\r\ncontract IronVestPreCheck {\r\n\r\n    /// @dev Only callable by vester.\r\n    /// @param _vestingEndTime : Vesting end time should be greater than current time.\r\n    /// @param _usersAddresses : Length of _usersAddresses and _userAlloc must be equal.\r\n    /// @param _userAlloc : Just for checking length.\r\n    /// @notice it is a precheck for new vesting.\r\n    function preAddVesting(\r\n        uint256 _vestingEndTime,\r\n        address[] memory _usersAddresses,\r\n        uint256[] memory _userAlloc\r\n    ) external view {\r\n        require(\r\n            _usersAddresses.length == _userAlloc.length,\r\n            \"IIronVest Array : Length of _usersAddresses And _userAlloc Must Be Equal\"\r\n        );\r\n        require(\r\n            _vestingEndTime > block.timestamp,\r\n            \"IIronVest : Vesting End Time Should Be Greater Than Current Time\"\r\n        );\r\n    }\r\n\r\n    /// @dev Only callable by vester.\r\n    /// @param _vestingEndTime : Vesting time should be greater than _cliffVestingEndTime.\r\n    /// @param _cliffVestingEndTime : Cliff vesting time must Be greater than cliff period.\r\n    /// @param _cliffPeriodEndTime : cliff period should must be grater than block.timestamp .\r\n    /// @param _cliffPercentage10000 : Cliff percentage should be less than 50%.\r\n    /// @param _usersAddresses : Length of _usersAddresses and _userAlloc must be equal.\r\n    /// @param _usersAlloc : Checking Length.\r\n    /// @notice it is a precheck for new vesting with cliff.\r\n    function preAddCliffVesting(\r\n        uint256 _vestingEndTime,\r\n        uint256 _cliffVestingEndTime,\r\n        uint256 _cliffPeriodEndTime,\r\n        uint256 _cliffPercentage10000,\r\n        address[] memory _usersAddresses,\r\n        uint256[] memory _usersAlloc\r\n    ) external view {\r\n        require(\r\n            _cliffVestingEndTime < _vestingEndTime,\r\n            \"IIronVest : Cliff Vesting End Time Must Be Lesser Than Vesting Time\"\r\n        );\r\n        require(\r\n            _cliffVestingEndTime > _cliffPeriodEndTime,\r\n            \"IIronVest : Cliff Vesting Time Must Be Greater Than Cliff Period\"\r\n        );\r\n        require(\r\n            _cliffPeriodEndTime > block.timestamp,\r\n            \"IIronVest : Cliff Vesting Time Must Be Lesser Than Vesting Time\"\r\n        );\r\n\r\n        require(\r\n            _cliffPercentage10000 <= 5000,\r\n            \"Percentage : Percentage Should Be less Than 50%\"\r\n        );\r\n        require(\r\n            _usersAddresses.length == _usersAlloc.length,\r\n            \"IIronVest Array : Length of _usersAddresses And _userAlloc Must Be Equal\"\r\n        );\r\n    }\r\n\r\n    /// @dev Only callable by owner.\r\n    /// @param _poolId : Pool Id should be less than _vestingPoolSize.\r\n    /// @param _deprecatedAddress : Deprecated Address and Updated Address Shouldn't be The Same.\r\n    /// @param _updatedAddress : Shouldn't be the zero address.\r\n    /// @notice This function used as precheck whenever a person lose their address which has pool allocation.\r\n    function preUpdateBeneficiaryAddress(\r\n        uint256 _poolId,\r\n        address _deprecatedAddress,\r\n        address _updatedAddress,\r\n        uint256 _vestingPoolSize\r\n    ) external pure {\r\n        require(_vestingPoolSize > _poolId, \"Pool Id : Invalid _poolId\");\r\n        require(\r\n            _updatedAddress != _deprecatedAddress,\r\n            \"PreCheck : Deprecated Address and Updated Address Shouldn't be The Same\"\r\n        );\r\n        require(\r\n            _updatedAddress != address(0x00) &&\r\n                _deprecatedAddress != address(0x00),\r\n            \"PreCheck: Invalid Address\"\r\n        );\r\n    }\r\n\r\n    /// @dev For splititng signature.\r\n    /// @param _sig : signature provided signed by signer\r\n    /// @return r : First 32 bytes stores the length of the signature.\r\n    /// @return s : add(sig, 32) = pointer of sig + 32\r\n    /// effectively, skips first 32 bytes of signature.\r\n    /// @return v : mload(p) loads next 32 bytes starting\r\n    /// at the memory address p into memory.\r\n    function splitSignature(bytes memory _sig)\r\n        external\r\n        pure\r\n        returns (\r\n            bytes32 r,\r\n            bytes32 s,\r\n            uint8 v\r\n        )\r\n    {\r\n        require(_sig.length == 65, \"invalid signature length\");\r\n\r\n        assembly {\r\n            /// First 32 bytes stores the length of the signature\r\n\r\n            /// add(_sig, 32) = pointer of _sig + 32\r\n            /// effectively, skips first 32 bytes of signature\r\n\r\n            /// mload(p) loads next 32 bytes starting at the memory address p into memory\r\n\r\n            /// first 32 bytes, after the length prefix\r\n            r := mload(add(_sig, 32))\r\n            /// second 32 bytes\r\n            s := mload(add(_sig, 64))\r\n            /// final byte (first byte of the next 32 bytes)\r\n            v := byte(0, mload(add(_sig, 96)))\r\n        }\r\n\r\n        /// implicitly return (r, s, v)\r\n    }\r\n\r\n    /// @dev Verify and recover signer from salt and signature.\r\n    /// @param _salt : A hash value which contains concatenated hash of different values.\r\n    /// @param _v : mload(p) loads next 32 bytes starting at the memory address p into memory.\r\n    /// @param _r : First 32 bytes stores the length of the signature.\r\n    /// @param _s : add(sig, 32) = pointer of sig + 32 effectively, skips first 32 bytes of signature.\r\n    /// @return signerAddress : Return the address of signer.\r\n    function verifyMessage(\r\n        bytes32 _salt,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external pure returns (address signerAddress) {\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 prefixedHashMessage = keccak256(\r\n            abi.encodePacked(prefix, _salt)\r\n        );\r\n        address _signerAddress = ecrecover(prefixedHashMessage, _v, _r, _s);\r\n        return _signerAddress;\r\n    }\r\n\r\n    /// @dev create a message hash by concatincating the values.\r\n    /// @param _poolName : Pool name.\r\n    /// @param _tokenAddress : Vesting token address .\r\n    /// @param _keyHash : key hash value generated by our backend to stop replay attack.\r\n    /// also a chain Id so that a user can't replay the hash any other chain.\r\n    /// @return returning keccak hash of concate values.\r\n    function messageHash(\r\n        string memory _poolName,\r\n        address _tokenAddress,\r\n        bytes memory _keyHash\r\n    ) external view returns (bytes32) {\r\n        bytes32 hash = keccak256(\r\n            abi.encodePacked(_poolName, _tokenAddress, _keyHash, block.chainid)\r\n        );\r\n        return hash;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_poolName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_keyHash\",\"type\":\"bytes\"}],\"name\":\"messageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vestingEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cliffVestingEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cliffPeriodEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cliffPercentage10000\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_usersAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_usersAlloc\",\"type\":\"uint256[]\"}],\"name\":\"preAddCliffVesting\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vestingEndTime\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_usersAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_userAlloc\",\"type\":\"uint256[]\"}],\"name\":\"preAddVesting\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_deprecatedAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_updatedAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_vestingPoolSize\",\"type\":\"uint256\"}],\"name\":\"preUpdateBeneficiaryAddress\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"splitSignature\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"verifyMessage\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"signerAddress\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "IronVestPreCheck", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f2ea535fb5561e3581ee5be28183f07eca5d1720edd17dab82992592d0402e6b"}