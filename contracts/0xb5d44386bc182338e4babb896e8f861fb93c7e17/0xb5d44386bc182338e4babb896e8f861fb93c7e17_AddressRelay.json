{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/AddressRelay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.18;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IAddressRelay, Implementation} from \\\"./interfaces/IAddressRelay.sol\\\";\\nimport {IERC165} from \\\"./interfaces/IERC165.sol\\\";\\nimport {IERC173} from \\\"./interfaces/IERC173.sol\\\";\\n\\n/**\\n * @author Created by HeyMint Launchpad https://join.heymint.xyz\\n * @notice This contract contains the base logic for ERC-721A tokens deployed with HeyMint\\n */\\ncontract AddressRelay is IAddressRelay, Ownable {\\n    mapping(bytes4 => address) public selectorToImplAddress;\\n    mapping(bytes4 => bool) public supportedInterfaces;\\n    bytes4[] selectors;\\n    address[] implAddresses;\\n    address public fallbackImplAddress;\\n    bool public relayFrozen;\\n\\n    constructor() {\\n        supportedInterfaces[0x01ffc9a7] = true; // IERC165\\n        supportedInterfaces[0x7f5828d0] = true; // IERC173\\n        supportedInterfaces[0xd9b67a26] = true; // ERC-1155\\n        supportedInterfaces[0x0e89341c] = true; // ERC1155MetadataURI\\n        supportedInterfaces[0x2a55205a] = true; // IERC2981\\n    }\\n\\n    /**\\n     * @notice Permanently freezes the relay so no more selectors can be added or removed\\n     */\\n    function freezeRelay() external onlyOwner {\\n        relayFrozen = true;\\n    }\\n\\n    /**\\n     * @notice Adds or updates selectors and their implementation addresses\\n     * @param _selectors The selectors to add or update\\n     * @param _implAddress The implementation address the selectors will point to\\n     */\\n    function addOrUpdateSelectors(\\n        bytes4[] memory _selectors,\\n        address _implAddress\\n    ) external onlyOwner {\\n        require(!relayFrozen, \\\"RELAY_FROZEN\\\");\\n        for (uint256 i = 0; i < _selectors.length; i++) {\\n            bytes4 selector = _selectors[i];\\n            selectorToImplAddress[selector] = _implAddress;\\n            selectors.push(selector);\\n        }\\n        bool implAddressExists = false;\\n        for (uint256 i = 0; i < implAddresses.length; i++) {\\n            if (implAddresses[i] == _implAddress) {\\n                implAddressExists = true;\\n                break;\\n            }\\n        }\\n        if (!implAddressExists) {\\n            implAddresses.push(_implAddress);\\n        }\\n    }\\n\\n    /**\\n     * @notice Removes selectors\\n     * @param _selectors The selectors to remove\\n     */\\n    function removeSelectors(bytes4[] memory _selectors) external onlyOwner {\\n        require(!relayFrozen, \\\"RELAY_FROZEN\\\");\\n        for (uint256 i = 0; i < _selectors.length; i++) {\\n            bytes4 selector = _selectors[i];\\n            delete selectorToImplAddress[selector];\\n            uint256 selectorsLen = selectors.length;\\n            for (uint256 j = 0; j < selectorsLen; j++) {\\n                if (selectors[j] == selector) {\\n                    if (j != selectorsLen - 1) {\\n                        // if not last element, copy last to deleted element's slot\\n                        selectors[j] = selectors[selectorsLen - 1];\\n                    }\\n                    // pop last element\\n                    selectors.pop();\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Removes an implementation address and all the selectors that point to it\\n     * @param _implAddress The implementation address to remove\\n     */\\n    function removeImplAddressAndAllSelectors(\\n        address _implAddress\\n    ) external onlyOwner {\\n        require(!relayFrozen, \\\"RELAY_FROZEN\\\");\\n        for (uint256 i = 0; i < implAddresses.length; i++) {\\n            if (implAddresses[i] == _implAddress) {\\n                // this just sets the value to 0, but doesn't remove it from the array\\n                delete implAddresses[i];\\n                break;\\n            }\\n        }\\n        for (uint256 i = 0; i < selectors.length; i++) {\\n            if (selectorToImplAddress[selectors[i]] == _implAddress) {\\n                delete selectorToImplAddress[selectors[i]];\\n                delete selectors[i];\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the implementation address for a given function selector\\n     * @param _functionSelector The function selector to get the implementation address for\\n     */\\n    function getImplAddress(\\n        bytes4 _functionSelector\\n    ) external view returns (address) {\\n        address implAddress = selectorToImplAddress[_functionSelector];\\n        if (implAddress == address(0)) {\\n            implAddress = fallbackImplAddress;\\n        }\\n        require(implAddress != address(0), \\\"Function does not exist\\\");\\n        return implAddress;\\n    }\\n\\n    /**\\n     * @notice Returns the implementation address for a given function selector. Throws an error if function does not exist.\\n     * @param _functionSelector The function selector to get the implementation address for\\n     */\\n    function getImplAddressNoFallback(\\n        bytes4 _functionSelector\\n    ) external view returns (address) {\\n        address implAddress = selectorToImplAddress[_functionSelector];\\n        require(implAddress != address(0), \\\"Function does not exist\\\");\\n        return implAddress;\\n    }\\n\\n    /**\\n     * @notice Returns all the implementation addresses and the selectors they support\\n     * @return impls_ An array of Implementation structs\\n     */\\n    function getAllImplAddressesAndSelectors()\\n        external\\n        view\\n        returns (Implementation[] memory)\\n    {\\n        uint256 trueImplAddressCount = 0;\\n        uint256 implAddressesLength = implAddresses.length;\\n        for (uint256 i = 0; i < implAddressesLength; i++) {\\n            if (implAddresses[i] != address(0)) {\\n                trueImplAddressCount++;\\n            }\\n        }\\n        Implementation[] memory impls = new Implementation[](\\n            trueImplAddressCount\\n        );\\n        for (uint256 i = 0; i < implAddressesLength; i++) {\\n            if (implAddresses[i] == address(0)) {\\n                continue;\\n            }\\n            address implAddress = implAddresses[i];\\n            bytes4[] memory selectors_;\\n            uint256 selectorCount = 0;\\n            uint256 selectorsLength = selectors.length;\\n            for (uint256 j = 0; j < selectorsLength; j++) {\\n                if (selectorToImplAddress[selectors[j]] == implAddress) {\\n                    selectorCount++;\\n                }\\n            }\\n            selectors_ = new bytes4[](selectorCount);\\n            uint256 selectorIndex = 0;\\n            for (uint256 j = 0; j < selectorsLength; j++) {\\n                if (selectorToImplAddress[selectors[j]] == implAddress) {\\n                    selectors_[selectorIndex] = selectors[j];\\n                    selectorIndex++;\\n                }\\n            }\\n            impls[i] = Implementation(implAddress, selectors_);\\n        }\\n        return impls;\\n    }\\n\\n    /**\\n     * @notice Return all the function selectors associated with an implementation address\\n     * @param _implAddress The implementation address to get the selectors for\\n     */\\n    function getSelectorsForImplAddress(\\n        address _implAddress\\n    ) external view returns (bytes4[] memory) {\\n        uint256 selectorCount = 0;\\n        uint256 selectorsLength = selectors.length;\\n        for (uint256 i = 0; i < selectorsLength; i++) {\\n            if (selectorToImplAddress[selectors[i]] == _implAddress) {\\n                selectorCount++;\\n            }\\n        }\\n        bytes4[] memory selectorArr = new bytes4[](selectorCount);\\n        uint256 selectorIndex = 0;\\n        for (uint256 i = 0; i < selectorsLength; i++) {\\n            if (selectorToImplAddress[selectors[i]] == _implAddress) {\\n                selectorArr[selectorIndex] = selectors[i];\\n                selectorIndex++;\\n            }\\n        }\\n        return selectorArr;\\n    }\\n\\n    /**\\n     * @notice Sets the fallback implementation address to use when a function selector is not found\\n     * @param _fallbackAddress The fallback implementation address\\n     */\\n    function setFallbackImplAddress(\\n        address _fallbackAddress\\n    ) external onlyOwner {\\n        require(!relayFrozen, \\\"RELAY_FROZEN\\\");\\n        fallbackImplAddress = _fallbackAddress;\\n    }\\n\\n    /**\\n     * @notice Updates the supported interfaces\\n     * @param _interfaceId The interface ID to update\\n     * @param _supported Whether the interface is supported or not\\n     */\\n    function updateSupportedInterfaces(\\n        bytes4 _interfaceId,\\n        bool _supported\\n    ) external onlyOwner {\\n        supportedInterfaces[_interfaceId] = _supported;\\n    }\\n\\n    /**\\n     * @notice Returns whether the interface is supported or not\\n     * @param _interfaceId The interface ID to check\\n     */\\n    function supportsInterface(\\n        bytes4 _interfaceId\\n    ) external view returns (bool) {\\n        return supportedInterfaces[_interfaceId];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAddressRelay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nstruct Implementation {\\n    address implAddress;\\n    bytes4[] selectors;\\n}\\n\\ninterface IAddressRelay {\\n    /**\\n     * @notice Returns the fallback implementation address\\n     */\\n    function fallbackImplAddress() external returns (address);\\n\\n    /**\\n     * @notice Adds or updates selectors and their implementation addresses\\n     * @param _selectors The selectors to add or update\\n     * @param _implAddress The implementation address the selectors will point to\\n     */\\n    function addOrUpdateSelectors(\\n        bytes4[] memory _selectors,\\n        address _implAddress\\n    ) external;\\n\\n    /**\\n     * @notice Removes selectors\\n     * @param _selectors The selectors to remove\\n     */\\n    function removeSelectors(bytes4[] memory _selectors) external;\\n\\n    /**\\n     * @notice Removes an implementation address and all the selectors that point to it\\n     * @param _implAddress The implementation address to remove\\n     */\\n    function removeImplAddressAndAllSelectors(address _implAddress) external;\\n\\n    /**\\n     * @notice Returns the implementation address for a given function selector\\n     * @param _functionSelector The function selector to get the implementation address for\\n     */\\n    function getImplAddress(\\n        bytes4 _functionSelector\\n    ) external view returns (address implAddress_);\\n\\n    /**\\n     * @notice Returns all the implementation addresses and the selectors they support\\n     * @return impls_ An array of Implementation structs\\n     */\\n    function getAllImplAddressesAndSelectors()\\n        external\\n        view\\n        returns (Implementation[] memory impls_);\\n\\n    /**\\n     * @notice Return all the fucntion selectors associated with an implementation address\\n     * @param _implAddress The implementation address to get the selectors for\\n     */\\n    function getSelectorsForImplAddress(\\n        address _implAddress\\n    ) external view returns (bytes4[] memory selectors_);\\n\\n    /**\\n     * @notice Sets the fallback implementation address to use when a function selector is not found\\n     * @param _fallbackAddress The fallback implementation address\\n     */\\n    function setFallbackImplAddress(address _fallbackAddress) external;\\n\\n    /**\\n     * @notice Updates the supported interfaces\\n     * @param _interfaceId The interface ID to update\\n     * @param _supported Whether the interface is supported or not\\n     */\\n    function updateSupportedInterfaces(\\n        bytes4 _interfaceId,\\n        bool _supported\\n    ) external;\\n\\n    /**\\n     * @notice Returns whether the interface is supported or not\\n     * @param _interfaceId The interface ID to check\\n     */\\n    function supportsInterface(\\n        bytes4 _interfaceId\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC173.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\n/// @title ERC-173 Contract Ownership Standard\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\n/* is ERC165 */\\ninterface IERC173 {\\n    /// @dev This emits when ownership of a contract changes.\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /// @notice Get the address of the owner\\n    /// @return owner_ The address of the owner.\\n    function owner() external view returns (address owner_);\\n\\n    /// @notice Set the address of the new owner of the contract\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\n    /// @param _newOwner The address of the new owner of the contract\\n    function transferOwnership(address _newOwner) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"_selectors\",\"type\":\"bytes4[]\"},{\"internalType\":\"address\",\"name\":\"_implAddress\",\"type\":\"address\"}],\"name\":\"addOrUpdateSelectors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fallbackImplAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"freezeRelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllImplAddressesAndSelectors\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"implAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct Implementation[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_functionSelector\",\"type\":\"bytes4\"}],\"name\":\"getImplAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_functionSelector\",\"type\":\"bytes4\"}],\"name\":\"getImplAddressNoFallback\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implAddress\",\"type\":\"address\"}],\"name\":\"getSelectorsForImplAddress\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relayFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implAddress\",\"type\":\"address\"}],\"name\":\"removeImplAddressAndAllSelectors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"_selectors\",\"type\":\"bytes4[]\"}],\"name\":\"removeSelectors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"selectorToImplAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fallbackAddress\",\"type\":\"address\"}],\"name\":\"setFallbackImplAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"supportedInterfaces\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"},{\"internalType\":\"bool\",\"name\":\"_supported\",\"type\":\"bool\"}],\"name\":\"updateSupportedInterfaces\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AddressRelay", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}