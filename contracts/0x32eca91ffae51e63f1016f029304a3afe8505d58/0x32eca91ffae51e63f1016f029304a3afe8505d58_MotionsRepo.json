{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/comps/books/roa/IInvestmentAgreement.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"../../../lib/SwapsRepo.sol\\\";\\nimport \\\"../../../lib/DealsRepo.sol\\\";\\n\\nimport \\\"../../common/components/ISigPage.sol\\\";\\n\\ninterface IInvestmentAgreement is ISigPage {\\n\\n    //##################\\n    //##    Event     ##\\n    //##################\\n\\n    event AddDeal(uint indexed seqOfDeal);\\n\\n    event ClearDealCP(\\n        uint256 indexed seq,\\n        bytes32 indexed hashLock,\\n        uint indexed closingDeadline\\n    );\\n\\n    event CloseDeal(uint256 indexed seq, string indexed hashKey);\\n\\n    event TerminateDeal(uint256 indexed seq);\\n    \\n    event CreateSwap(uint seqOfDeal, bytes32 snOfSwap);\\n\\n    event PayOffSwap(uint seqOfDeal, uint seqOfSwap, uint msgValue);\\n\\n    event TerminateSwap(uint seqOfDeal, uint seqOfSwap);\\n\\n    event PayOffApprovedDeal(uint seqOfDeal, uint msgValue);\\n\\n    //##################\\n    //##  Write I/O  ##\\n    //##################\\n\\n    // ======== InvestmentAgreement ========\\n\\n    function addDeal(\\n        bytes32 sn,\\n        uint buyer,\\n        uint groupOfBuyer,\\n        uint paid,\\n        uint par\\n    ) external;\\n\\n    function regDeal(DealsRepo.Deal memory deal) external returns(uint16 seqOfDeal);\\n\\n    function delDeal(uint256 seq) external;\\n\\n    function lockDealSubject(uint256 seq) external returns (bool flag);\\n\\n    function releaseDealSubject(uint256 seq) external returns (bool flag);\\n\\n    function clearDealCP( uint256 seq, bytes32 hashLock, uint closingDeadline) external;\\n\\n    function closeDeal(uint256 seq, string memory hashKey)\\n        external returns (bool flag);\\n\\n    function directCloseDeal(uint256 seq) external returns (bool flag);\\n\\n    function terminateDeal(uint256 seqOfDeal) external returns(bool);\\n\\n    function takeGift(uint256 seq) external returns(bool);\\n\\n    function finalizeIA() external;\\n\\n    // ==== Swap ====\\n\\n    function createSwap (\\n        uint seqOfMotion,\\n        uint seqOfDeal,\\n        uint paidOfTarget,\\n        uint seqOfPledge,\\n        uint caller\\n    ) external returns(SwapsRepo.Swap memory swap);\\n\\n    function payOffSwap(\\n        uint seqOfMotion,\\n        uint seqOfDeal,\\n        uint seqOfSwap,\\n        uint msgValue,\\n        uint centPrice\\n    ) external returns(SwapsRepo.Swap memory swap);\\n\\n    function terminateSwap(\\n        uint seqOfMotion,\\n        uint seqOfDeal,\\n        uint seqOfSwap\\n    ) external returns (SwapsRepo.Swap memory swap);\\n\\n    function payOffApprovedDeal(\\n        uint seqOfDeal,\\n        uint msgValue,\\n        // uint centPrice,\\n        uint caller\\n    ) external returns (bool flag);\\n\\n    function requestPriceDiff(\\n        uint seqOfDeal,\\n        uint seqOfShare\\n    ) external;\\n\\n    //  #####################\\n    //  ##     \u67e5\u8be2\u63a5\u53e3     ##\\n    //  #####################\\n\\n    // ======== InvestmentAgreement ========\\n    function getTypeOfIA() external view returns (uint8);\\n\\n    // function counterOfDeal() external view returns (uint16);\\n\\n    // function counterOfClosedDeal() external view returns (uint16);\\n\\n    // function isDeal(uint256 seq) external view returns (bool);\\n\\n    function getDeal(uint256 seq) external view returns (DealsRepo.Deal memory);\\n\\n    function getSeqList() external view returns (uint[] memory);\\n\\n    // ==== Swap ====\\n\\n    // function counterOfSwaps(uint seqOfDeal)\\n    //     external view returns (uint16);\\n\\n    // function sumPaidOfTarget(uint seqOfDeal)\\n    //     external view returns (uint64);\\n\\n    function getSwap(uint seqOfDeal, uint256 seqOfSwap)\\n        external view returns (SwapsRepo.Swap memory);\\n\\n    function getAllSwaps(uint seqOfDeal)\\n        external view returns (SwapsRepo.Swap[] memory);\\n\\n    function allSwapsClosed(uint seqOfDeal)\\n        external view returns (bool);\\n\\n    function checkValueOfSwap(uint seqOfDeal, uint seqOfSwap)\\n        external view returns(uint);\\n\\n    function checkValueOfDeal(uint seqOfDeal)\\n        external view returns (uint);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/comps/books/roc/IShareholdersAgreement.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"../../common/components/ISigPage.sol\\\";\\nimport \\\"../../../lib/EnumerableSet.sol\\\";\\nimport \\\"../../../lib/DocsRepo.sol\\\";\\n\\ninterface IShareholdersAgreement is ISigPage {\\n\\n    enum TitleOfTerm {\\n        ZeroPoint,\\n        AntiDilution,   // 1\\n        LockUp,         // 2\\n        DragAlong,      // 3\\n        TagAlong,       // 4\\n        Options         // 5\\n    }\\n\\n    // ==== Rules ========\\n\\n/*\\n    |  Seq  |        Type       |    Abb       |            Description                     |       \\n    |    0  |  GovernanceRule   |     GR       | Board Constitution and General Rules of GM | \\n    |    1  |  VotingRuleOfGM   |     CI       | VR for Capital Increase                    |\\n    |    2  |                   |   SText      | VR for External Share Transfer             |\\n    |    3  |                   |   STint      | VR for Internal Share Transfer             |\\n    |    4  |                   |    1+3       | VR for CI & STint                          |\\n    |    5  |                   |    2+3       | VR for SText & STint                       |\\n    |    6  |                   |   1+2+3      | VR for CI & SText & STint                  |\\n    |    7  |                   |    1+2       | VR for CI & SText                          |\\n    |    8  |                   |   SHA        | VR for Update SHA                          |\\n    |    9  |                   |  O-Issue-GM  | VR for Ordinary Issues of GeneralMeeting   |\\n    |   10  |                   |  S-Issue-GM  | VR for Special Issues Of GeneralMeeting    |\\n    |   11  | VotingRuleOfBoard |     CI       | VR for Capital Increase                    |\\n    |   12  |                   |   SText      | VR for External Share Transfer             |\\n    |   13  |                   |   STint      | VR for Internal Share Transfer             |\\n    |   14  |                   |    1+3       | VR for CI & STint                          |\\n    |   15  |                   |    2+3       | VR for SText & STint                       |\\n    |   16  |                   |   1+2+3      | VR for CI & SText & STint                  |\\n    |   17  |                   |    1+2       | VR for CI & SText                          |\\n    |   18  |                   |   SHA        | VR for Update SHA                          |\\n    |   19  |                   |  O-Issue-B   | VR for Ordinary Issues Of Board            |\\n    |   20  |                   |  S-Issue-B   | VR for Special Issues Of Board             |\\n    |   21  | UnilateralDecision| UniDecPower  | UnilateralDicisionPowerWithoutVoting       |\\n    ...\\n\\n    |  256  | PositionAllocateRule |   PA Rule   | Management Positions' Allocation Rules    |\\n    ...\\n\\n    |  512  | FirstRefusalRule  |  FR for CI...| FR rule for Investment Deal                |\\n    ...\\n\\n    |  768  | GroupUpdateOrder  |  GroupUpdate | Grouping Members as per their relationship |\\n    ...\\n\\n*/\\n\\n    struct TermsRepo {\\n        // title => body\\n        mapping(uint256 => address) terms;\\n        EnumerableSet.UintSet seqList;\\n    }\\n\\n    struct RulesRepo {\\n        // seq => rule\\n        mapping(uint256 => bytes32) rules;\\n        EnumerableSet.UintSet seqList;\\n    }\\n\\n    //##################\\n    //##  Write I/O   ##\\n    //##################\\n\\n    function createTerm(uint typeOfDoc, uint version) external;\\n\\n    function removeTerm(uint typeOfDoc) external;\\n\\n    function addRule(bytes32 rule) external;\\n\\n    function removeRule(uint256 seq) external;\\n\\n    function initDefaultRules() external;\\n\\n    function finalizeSHA() external;\\n\\n    //##################\\n    //##    \u8bfb\u63a5\u53e3    ##\\n    //##################\\n\\n    // ==== Terms ====\\n\\n    function hasTitle(uint256 title) external view returns (bool);\\n\\n    function qtyOfTerms() external view returns (uint256);\\n\\n    function getTitles() external view returns (uint256[] memory);\\n\\n    function getTerm(uint256 title) external view returns (address);\\n\\n    // ==== Rules ====\\n    \\n    function hasRule(uint256 seq) external view returns (bool);\\n\\n    function qtyOfRules() external view returns (uint256);\\n\\n    function getRules() external view returns (uint256[] memory);\\n\\n    function getRule(uint256 seq) external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/comps/books/rod/IRegisterOfDirectors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"../../common/components/IMeetingMinutes.sol\\\";\\n\\nimport \\\"../../../lib/OfficersRepo.sol\\\";\\n\\ninterface IRegisterOfDirectors {\\n\\n    //###################\\n    //##    events    ##\\n    //##################\\n\\n    event AddPosition(bytes32 indexed snOfPos);\\n\\n    event RemovePosition(uint256 indexed seqOfPos);\\n\\n    event TakePosition(uint256 indexed seqOfPos, uint256 indexed caller);\\n\\n    event QuitPosition(uint256 indexed seqOfPos, uint256 indexed caller);\\n\\n    event RemoveOfficer(uint256 indexed seqOfPos);\\n\\n    // event ProposeMotionToBoard(uint256 indexed seqOfMotion, uint256 indexed caller);\\n\\n    // event ExecAction(uint256 indexed contents, bool success);\\n\\n    //##################\\n    //##  Write I/O  ##\\n    //##################\\n\\n    function createPosition(bytes32 snOfPos) external;\\n\\n    function updatePosition(OfficersRepo.Position memory pos) external;\\n\\n    function removePosition(uint256 seqOfPos) external;\\n\\n    function takePosition (uint256 seqOfPos, uint caller) external;\\n\\n    function quitPosition (uint256 seqOfPos, uint caller) external; \\n\\n    function removeOfficer (uint256 seqOfPos) external;\\n\\n    //##################\\n    //##    \u8bfb\u63a5\u53e3    ##\\n    //##################\\n    \\n    // ==== Positions ====\\n\\n    function posExist(uint256 seqOfPos) external view returns (bool);\\n\\n    function isOccupied(uint256 seqOfPos) external view returns (bool);\\n\\n    function getPosition(uint256 seqOfPos) external view \\n        returns (OfficersRepo.Position memory);\\n\\n    // ==== Managers ====\\n\\n    function isManager(uint256 acct) external view returns (bool);\\n\\n    function getNumOfManagers() external view returns (uint256);    \\n\\n    function getManagersList() external view returns (uint256[] memory);\\n\\n    function getManagersPosList() external view returns(uint[] memory);\\n\\n    // function getManagersFullPosInfo() external view \\n    //     returns(OfficersRepo.Position[] memory);\\n\\n    // ==== Directors ====\\n\\n    function isDirector(uint256 acct) external view returns (bool);\\n\\n    function getNumOfDirectors() external view returns (uint256);\\n\\n    function getDirectorsList() external view \\n        returns (uint256[] memory);\\n\\n    function getDirectorsPosList() external view \\n        returns (uint256[] memory);\\n\\n    // function getDirectorsFullPosInfo() external view \\n    //     returns(OfficersRepo.Position[] memory);        \\n\\n    // ==== Executives ====\\n    \\n    function hasPosition(uint256 acct, uint256 seqOfPos)\\n        external view returns(bool);\\n\\n    function getPosInHand(uint256 acct) \\n        external view returns (uint256[] memory);\\n\\n    function getFullPosInfoInHand(uint acct) \\n        external view returns (OfficersRepo.Position[] memory);\\n\\n    function hasTitle(uint acct, uint title) \\n        external returns (bool flag);\\n\\n    function hasNominationRight(uint seqOfPos, uint acct) \\n        external view returns (bool);\\n\\n    // ==== seatsCalculator ====\\n\\n    // function getBoardSeatsQuota(uint256 acct) external view \\n    //     returns(uint256);\\n\\n    function getBoardSeatsOccupied(uint acct) external view \\n        returns (uint256);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/comps/books/rom/IRegisterOfMembers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"../../../lib/Checkpoints.sol\\\";\\n// import \\\"../../../lib/EnumerableSet.sol\\\"; \\nimport \\\"../../../lib/MembersRepo.sol\\\";\\nimport \\\"../../../lib/SharesRepo.sol\\\";\\nimport \\\"../../../lib/TopChain.sol\\\";\\n\\ninterface IRegisterOfMembers {\\n    //##################\\n    //##    Event     ##\\n    //##################\\n\\n    event SetVoteBase(bool indexed basedOnPar);\\n\\n    event CapIncrease(uint indexed votingWeight, uint indexed paid, uint indexed par);\\n\\n    event CapDecrease(uint indexed votingWeight, uint indexed paid, uint indexed par);\\n\\n    event SetMaxQtyOfMembers(uint indexed max);\\n\\n    event SetMinVoteRatioOnChain(uint indexed min);\\n\\n    event SetAmtBase(bool indexed basedOnPar);\\n\\n    event AddMember(uint256 indexed acct, uint indexed qtyOfMembers);\\n\\n    event AddShareToMember(uint indexed seqOfShare, uint indexed acct);\\n\\n    event RemoveShareFromMember(uint indexed seqOfShare, uint indexed acct);\\n\\n    event ChangeAmtOfMember(\\n        uint indexed acct,\\n        uint indexed paid,\\n        uint indexed par,\\n        uint clean,\\n        bool increase\\n    );\\n\\n    event AddMemberToGroup(uint indexed acct, uint indexed root);\\n\\n    event RemoveMemberFromGroup(uint256 indexed acct, uint256 indexed root);\\n\\n    event ChangeGroupRep(uint256 indexed orgRep, uint256 indexed newRep);\\n\\n    //##################\\n    //##  Write I/O  ##\\n    //##################\\n\\n    function setMaxQtyOfMembers(uint max) external;\\n\\n    function setMinVoteRatioOnChain(uint min) external;\\n\\n    function setVoteBase(bool _basedOnPar) external;\\n\\n    function capIncrease(\\n        uint votingWeight, \\n        uint paid, \\n        uint par, \\n        bool isIncrease\\n    ) external;\\n\\n    function addMember(uint256 acct) external;\\n\\n    function addShareToMember(\\n        SharesRepo.Share memory share\\n    ) external;\\n\\n    function removeShareFromMember(\\n        SharesRepo.Share memory share\\n    ) external;\\n\\n    function increaseAmtOfMember(\\n        uint acct,\\n        uint votingWeight,\\n        uint deltaPaid,\\n        uint deltaPar,\\n        uint deltaClean,\\n        bool isIncrease\\n    ) external ;\\n\\n    function addMemberToGroup(uint acct, uint root) external;\\n\\n    function removeMemberFromGroup(uint256 acct) external;\\n\\n    // ##############\\n    // ##   Read   ##\\n    // ##############\\n\\n    function isMember(uint256 acct) external view returns (bool);\\n\\n    function qtyOfMembers() external view returns (uint);\\n\\n    function membersList() external view returns (uint256[] memory);\\n\\n    function sortedMembersList() external view returns (uint256[] memory);\\n\\n    function qtyOfTopMembers() external view returns (uint);\\n\\n    function topMembersList() external view returns (uint[] memory);\\n\\n    // ---- Cap & Equity ----\\n\\n    function ownersEquity() \\n        external view \\n        returns(Checkpoints.Checkpoint memory);\\n\\n    function capAtDate(uint date)\\n        external view\\n        returns (Checkpoints.Checkpoint memory);\\n\\n   function equityOfMember(uint256 acct)\\n        external view\\n        returns (Checkpoints.Checkpoint memory);\\n\\n    function equityAtDate(uint acct, uint date) \\n        external view returns(Checkpoints.Checkpoint memory);\\n\\n    function votesInHand(uint256 acct)\\n        external view returns (uint64);\\n\\n    function votesAtDate(uint256 acct, uint date)\\n        external view\\n        returns (uint64);\\n\\n    function votesHistory(uint acct)\\n        external view \\n        returns (Checkpoints.Checkpoint[] memory);\\n\\n    // ---- ShareNum ----\\n\\n    function qtyOfSharesInHand(uint acct)\\n        external view returns(uint);\\n    \\n    function sharesInHand(uint256 acct)\\n        external view\\n        returns (uint[] memory);\\n\\n    // ---- Class ---- \\n\\n    function qtyOfSharesInClass(uint acct, uint class)\\n        external view returns(uint);\\n\\n    function sharesInClass(uint256 acct, uint class)\\n        external view returns (uint[] memory);\\n\\n    function isClassMember(uint256 acct, uint class)\\n        external view returns(bool);\\n\\n    function classesBelonged(uint acct)\\n        external view returns(uint[] memory);\\n\\n    function qtyOfClassMember(uint class)\\n        external view returns(uint);\\n\\n    function getMembersOfClass(uint class)\\n        external view returns(uint256[] memory);\\n \\n    // ---- TopChain ----\\n\\n    function basedOnPar() external view returns (bool);\\n\\n    function maxQtyOfMembers() external view returns (uint32);\\n\\n    function minVoteRatioOnChain() external view returns (uint32);\\n\\n    function totalVotes() external view returns (uint64);\\n\\n    function controllor() external view returns (uint40);\\n\\n    function tailOfChain() external view returns (uint40);\\n\\n    function headOfQueue() external view returns (uint40);\\n\\n    function tailOfQueue() external view returns (uint40);\\n\\n    // ==== group ====\\n\\n    function groupRep(uint256 acct) external view returns (uint40);\\n\\n    function votesOfGroup(uint256 acct) external view returns (uint64);\\n\\n    function deepOfGroup(uint256 acct) external view returns (uint256);\\n\\n    function membersOfGroup(uint256 acct)\\n        external view\\n        returns (uint256[] memory);\\n\\n    function qtyOfGroupsOnChain() external view returns (uint32);\\n\\n    function qtyOfGroups() external view returns (uint256);\\n\\n    function affiliated(uint256 acct1, uint256 acct2)\\n        external view\\n        returns (bool);\\n\\n    // ==== snapshot ====\\n\\n    function getSnapshot() external view returns (TopChain.Node[] memory, TopChain.Para memory);\\n}\\n\"\r\n    },\r\n    \"contracts/comps/books/ros/IRegisterOfShares.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"../../../lib/SharesRepo.sol\\\";\\nimport \\\"../../../lib/LockersRepo.sol\\\";\\n\\nimport \\\"../rom/IRegisterOfMembers.sol\\\";\\n\\ninterface IRegisterOfShares {\\n\\n    //##################\\n    //##    Event     ##\\n    //##################\\n\\n    event IssueShare(bytes32 indexed shareNumber, uint indexed paid, uint indexed par);\\n\\n    event PayInCapital(uint256 indexed seqOfShare, uint indexed amount);\\n\\n    event SubAmountFromShare(uint256 indexed seqOfShare, uint indexed paid, uint indexed par);\\n\\n    event DeregisterShare(uint256 indexed seqOfShare);\\n\\n    // event UpdateStateOfShare(uint256 indexed seqOfShare, uint indexed state);\\n\\n    event UpdatePriceOfPaid(uint indexed seqOfShare, uint indexed newPrice);\\n\\n    event UpdatePaidInDeadline(uint256 indexed seqOfShare, uint indexed paidInDeadline);\\n\\n    event DecreaseCleanPaid(uint256 indexed seqOfShare, uint indexed paid);\\n\\n    event IncreaseCleanPaid(uint256 indexed seqOfShare, uint indexed paid);\\n\\n    event SetPayInAmt(bytes32 indexed headSn, bytes32 indexed hashLock);\\n\\n    event WithdrawPayInAmt(uint indexed seqOfShare, uint indexed amount);\\n\\n    event IncreaseEquityOfClass(bool indexed isIncrease, uint indexed class, uint indexed amt);\\n\\n    //##################\\n    //##  Write I/O  ##\\n    //##################\\n\\n    function issueShare(bytes32 shareNumber, uint payInDeadline, uint paid, uint par) external;\\n\\n    function addShare(SharesRepo.Share memory share) external;\\n\\n    function setPayInAmt(uint seqOfShare, uint amt, uint expireDate, bytes32 hashLock) external;\\n\\n    function requestPaidInCapital(bytes32 hashLock, string memory hashKey) external;\\n\\n    function withdrawPayInAmt(bytes32 hashLock, uint seqOfShare) external;\\n\\n    function payInCapital(uint seqOfShare, uint amt) external;\\n\\n    function transferShare(\\n        uint256 seqOfShare,\\n        uint paid,\\n        uint par,\\n        uint to,\\n        uint priceOfPaid,\\n        uint priceOfPar\\n    ) external;\\n\\n    function decreaseCapital(uint256 seqOfShare, uint paid, uint par) external;\\n\\n    // ==== CleanPaid ====\\n\\n    function decreaseCleanPaid(uint256 seqOfShare, uint paid) external;\\n\\n    function increaseCleanPaid(uint256 seqOfShare, uint paid) external;\\n\\n    // ==== State & PaidInDeadline ====\\n\\n    // function updateStateOfShare(uint256 seqOfShare, uint state) external;\\n    function updatePriceOfPaid(uint seqOfShare, uint newPrice) external;\\n\\n    function updatePaidInDeadline(uint256 seqOfShare, uint paidInDeadline) external;\\n\\n    // ==== EquityOfClass ====\\n\\n    function increaseEquityOfClass(\\n        bool isIncrease,\\n        uint classOfShare,\\n        uint deltaPaid,\\n        uint deltaPar,\\n        uint deltaCleanPaid\\n    ) external;\\n\\n    // ##################\\n    // ##   \u67e5\u8be2\u63a5\u53e3   ##\\n    // ##################\\n\\n    function counterOfShares() external view returns (uint32);\\n\\n    function counterOfClasses() external view returns (uint16);\\n\\n    // ==== SharesRepo ====\\n\\n    function isShare(\\n        uint256 seqOfShare\\n    ) external view returns (bool);\\n\\n    function getShare(\\n        uint256 seqOfShare\\n    ) external view returns (\\n        SharesRepo.Share memory\\n    );\\n\\n    function getQtyOfShares() external view returns (uint);\\n\\n    function getSeqListOfShares() external view returns (uint[] memory);\\n\\n    function getSharesList() external view returns (SharesRepo.Share[] memory);\\n\\n    // ---- Class ----    \\n\\n    function getQtyOfSharesInClass(\\n        uint classOfShare\\n    ) external view returns (uint);\\n\\n    function getSeqListOfClass(\\n        uint classOfShare\\n    ) external view returns (uint[] memory);\\n\\n    function getInfoOfClass(\\n        uint classOfShare\\n    ) external view returns (SharesRepo.Share memory);\\n\\n    function getSharesOfClass(\\n        uint classOfShare\\n    ) external view returns (SharesRepo.Share[] memory);\\n\\n    // ==== PayInCapital ====\\n\\n    function getLocker(\\n        bytes32 hashLock\\n    ) external view returns (LockersRepo.Locker memory);\\n\\n    function getLocksList() external view returns (bytes32[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/comps/common/components/IMeetingMinutes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"../../../lib/BallotsBox.sol\\\";\\nimport \\\"../../../lib/MotionsRepo.sol\\\";\\nimport \\\"../../../lib/RulesParser.sol\\\";\\nimport \\\"../../../lib/DelegateMap.sol\\\";\\n\\ninterface IMeetingMinutes {\\n\\n    //##################\\n    //##    events    ##\\n    //##################\\n\\n    event CreateMotion(bytes32 indexed snOfMotion, uint256 indexed contents);\\n\\n    event ProposeMotionToGeneralMeeting(uint256 indexed seqOfMotion, uint256 indexed proposer);\\n\\n    event ProposeMotionToBoard(uint256 indexed seqOfMotion, uint256 indexed proposer);\\n\\n    event EntrustDelegate(uint256 indexed seqOfMotion, uint256 indexed delegate, uint256 indexed principal);\\n\\n    event CastVoteInGeneralMeeting(uint256 indexed seqOfMotion, uint256 indexed caller, uint indexed attitude, bytes32 sigHash);    \\n\\n    event CastVoteInBoardMeeting(uint256 indexed seqOfMotion, uint256 indexed caller, uint indexed attitude, bytes32 sigHash);    \\n\\n    event VoteCounting(uint256 indexed seqOfMotion, uint8 indexed result);            \\n\\n    event ExecResolution(uint256 indexed seqOfMotion, uint256 indexed caller);\\n\\n    //#################\\n    //##  Write I/O  ##\\n    //#################\\n\\n    // function addMotion(\\n    //     MotionsRepo.Head memory head,\\n    //     uint256 contents\\n    // ) external returns (uint64);\\n\\n    function nominateOfficer(\\n        uint256 seqOfPos,\\n        uint seqOfVR,\\n        uint canidate,\\n        uint nominator\\n    ) external returns(uint64);\\n\\n    function createMotionToRemoveOfficer(\\n        uint256 seqOfPos,\\n        uint seqOfVR,\\n        uint nominator    \\n    ) external returns(uint64);\\n\\n    function createMotionToApproveDoc(\\n        uint doc,\\n        uint seqOfVR,\\n        uint executor,\\n        uint proposer    \\n    ) external returns(uint64);\\n\\n    function createMotionToDistributeProfits(\\n        uint amt,\\n        uint expireDate,\\n        uint seqOfVR,\\n        uint executor,\\n        uint proposer\\n    ) external returns (uint64);\\n\\n    function createMotionToTransferFund(\\n        address to,\\n        bool isCBP,\\n        uint amt,\\n        uint expireDate,\\n        uint seqOfVR,\\n        uint executor,\\n        uint proposer\\n    ) external returns (uint64);\\n\\n    function createAction(\\n        uint seqOfVR,\\n        address[] memory targets,\\n        uint256[] memory values,\\n        bytes[] memory params,\\n        bytes32 desHash,\\n        uint executor,\\n        uint proposer\\n    ) external returns(uint64);\\n\\n    function proposeMotionToGeneralMeeting(\\n        uint256 seqOfMotion,\\n        uint proposer\\n    ) external;\\n\\n    function proposeMotionToBoard (\\n        uint seqOfMotion,\\n        uint caller\\n    ) external;\\n\\n    function entrustDelegate(\\n        uint256 seqOfMotion,\\n        uint delegate, \\n        uint principal\\n    ) external;\\n\\n    // ==== Vote ====\\n\\n    function castVoteInGeneralMeeting(\\n        uint256 seqOfMotion,\\n        uint attitude,\\n        bytes32 sigHash,\\n        uint256 caller\\n    ) external;\\n\\n    function castVoteInBoardMeeting(\\n        uint256 seqOfMotion,\\n        uint attitude,\\n        bytes32 sigHash,\\n        uint256 caller\\n    ) external;\\n\\n    // ==== UpdateVoteResult ====\\n\\n    function voteCounting(bool flag0, uint256 seqOfMotion, MotionsRepo.VoteCalBase memory base) \\n        external returns(uint8);\\n\\n    // ==== ExecResolution ====\\n\\n    function execResolution(uint256 seqOfMotion, uint256 contents, uint caller)\\n        external;\\n\\n    function distributeProfits(\\n        uint amt,\\n        uint expireDate,\\n        uint seqOfMotion,\\n        uint caller\\n    ) external;\\n\\n    function transferFund(\\n        address to,\\n        bool isCBP,\\n        uint amt,\\n        uint expireDate,\\n        uint seqOfMotion,\\n        uint caller\\n    ) external;\\n\\n    function execAction(\\n        uint seqOfVR,\\n        address[] memory targets,\\n        uint256[] memory values,\\n        bytes[] memory params,\\n        bytes32 desHash,\\n        uint256 seqOfMotion,\\n        uint caller\\n    ) external returns(uint contents);\\n\\n    //################\\n    //##    Read    ##\\n    //################\\n\\n\\n    // ==== Motions ====\\n\\n    function isProposed(uint256 seqOfMotion) external view returns (bool);\\n\\n    function voteStarted(uint256 seqOfMotion) external view returns (bool);\\n\\n    function voteEnded(uint256 seqOfMotion) external view returns (bool);\\n\\n    // ==== Delegate ====\\n\\n    function getVoterOfDelegateMap(uint256 seqOfMotion, uint256 acct)\\n        external view returns (DelegateMap.Voter memory);\\n\\n    function getDelegateOf(uint256 seqOfMotion, uint acct)\\n        external view returns (uint);\\n\\n    // function getLeavesWeightAtDate(\\n    //     uint256 seqOfMotion, \\n    //     uint caller,\\n    //     uint baseDate\\n    // ) external view returns(DelegateMap.LeavesInfo memory info);\\n\\n    // function getLeavesHeadcountOfDirectors(\\n    //     uint256 seqOfMotion, \\n    //     uint caller\\n    // ) external view returns(uint32 head);\\n\\n    // ==== motion ====\\n\\n    function getMotion(uint256 seqOfMotion)\\n        external view returns (MotionsRepo.Motion memory motion);\\n\\n    // ==== voting ====\\n\\n    function isVoted(uint256 seqOfMotion, uint256 acct) external view returns (bool);\\n\\n    function isVotedFor(\\n        uint256 seqOfMotion,\\n        uint256 acct,\\n        uint atti\\n    ) external view returns (bool);\\n\\n    function getCaseOfAttitude(uint256 seqOfMotion, uint atti)\\n        external view returns (BallotsBox.Case memory );\\n\\n    function getBallot(uint256 seqOfMotion, uint256 acct)\\n        external view returns (BallotsBox.Ballot memory);\\n\\n    function isPassed(uint256 seqOfMotion) external view returns (bool);\\n\\n    function getSeqList() external view returns (uint[] memory);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/comps/common/components/ISigPage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"../../../lib/ArrayUtils.sol\\\";\\nimport \\\"../../../lib/EnumerableSet.sol\\\";\\nimport \\\"../../../lib/SigsRepo.sol\\\";\\n\\ninterface ISigPage {\\n\\n    event CirculateDoc();\\n\\n    // event SetTiming (bool indexed initPage, uint indexed signingDays, uint indexed closingDays);\\n\\n    //##################\\n    //##   Write I/O  ##\\n    //##################\\n\\n    function circulateDoc() external;\\n\\n    function setTiming(bool initPage, uint signingDays, uint closingDays) external;\\n\\n    function addBlank(bool initPage, bool beBuyer, uint256 seqOfDeal, uint256 acct)\\n        external;\\n\\n    function removeBlank(bool initPage, uint256 seqOfDeal, uint256 acct)\\n        external;\\n\\n    function signDoc(bool initPage, uint256 caller, bytes32 sigHash) \\n        external;    \\n\\n    function regSig(uint256 signer, uint sigDate, bytes32 sigHash)\\n        external returns(bool flag);\\n\\n    //##################\\n    //##   read I/O   ##\\n    //##################\\n\\n    function getParasOfPage(bool initPage) external view \\n        returns (SigsRepo.Signature memory);\\n\\n    function circulated() external view returns(bool);\\n\\n    function established() external view\\n        returns (bool flag);\\n\\n    function getCirculateDate() external view returns(uint48);\\n\\n    function getSigningDays() external view returns(uint16);\\n\\n    function getClosingDays() external view returns(uint16);\\n\\n    function getSigDeadline() external view returns(uint48);\\n\\n    function getClosingDeadline() external view returns(uint48);\\n\\n    function isBuyer(bool initPage, uint256 acct)\\n        external view returns(bool flag);\\n\\n    function isSeller(bool initPage, uint256 acct)\\n        external view returns(bool flag);\\n\\n    function isParty(uint256 acct)\\n        external view returns(bool flag);\\n\\n    function isInitSigner(uint256 acct)\\n        external view returns (bool flag);\\n\\n\\n    function isSigner(uint256 acct)\\n        external view returns (bool flag);\\n\\n    function getBuyers(bool initPage)\\n        external view returns (uint256[] memory buyers);\\n\\n    function getSellers(bool initPage)\\n        external view returns (uint256[] memory sellers);\\n\\n    function getParties() external view\\n        returns (uint256[] memory parties);\\n\\n    function getSigOfParty(bool initParty, uint256 acct) external view\\n        returns (\\n            uint256[] memory seqOfDeals, \\n            SigsRepo.Signature memory sig,\\n            bytes32 sigHash\\n        );\\n\\n    function getSigsOfPage(bool initPage) external view\\n        returns (\\n            SigsRepo.Signature[] memory sigsOfBuyer, \\n            SigsRepo.Signature[] memory sigsOfSeller\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ArrayUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nlibrary ArrayUtils {\\n\\n    function merge(uint256[] memory arrA, uint256[] memory arrB)\\n        public pure returns(uint256[] memory)\\n    {\\n        uint256[] memory arrC = new uint256[](arrA.length + arrB.length);\\n        uint256 lenC;\\n\\n        (arrC, lenC) = filter(arrA, arrC, 0);\\n        (arrC, lenC) = filter(arrB, arrC, lenC);\\n\\n        return resize(arrC, lenC);\\n    }\\n\\n    function filter(uint256[] memory arrA, uint256[] memory arrC, uint256 lenC) \\n        public pure returns(uint256[] memory, uint256)\\n    {\\n        uint256 lenA = arrA.length;\\n        uint256 i;\\n        \\n        while (i < lenA) {\\n        \\n            uint256 j;\\n            while (j < lenC){\\n                if (arrA[i] == arrC[j]) break;\\n                j++;\\n            }\\n\\n            if (j == lenC) {\\n                arrC[lenC] = arrA[i];\\n                lenC++;\\n            }\\n\\n            i++;\\n        }\\n\\n        return (arrC, lenC);\\n    }\\n\\n    function refine(uint256[] memory arrA) \\n        public pure returns(uint256[] memory)\\n    {\\n        uint256[] memory arrB = new uint256[](arrA.length);        \\n        uint256 lenB;\\n        (arrB, lenB) = filter(arrA, arrB, 0);\\n\\n        return resize(arrB, lenB);\\n    }\\n\\n    function resize(uint256[] memory arrA, uint256 len)\\n        public pure returns(uint256[] memory)\\n    {\\n        uint256[] memory output = new uint256[](len);\\n\\n        while (len > 0) {\\n            output[len - 1] = arrA[len - 1];\\n            len--;\\n        }\\n        // assembly {\\n        //     output := arrA\\n        // }\\n        return output;\\n    }\\n\\n\\n    function combine(uint256[] memory arrA, uint256[] memory arrB)\\n        public pure returns (uint256[] memory)\\n    {\\n        uint256 lenA = arrA.length;\\n        uint256 lenB = arrB.length;\\n        uint256 i;\\n\\n        uint256[] memory arrC = new uint256[](lenA + lenB);\\n\\n        for (i = 0; i < lenA; i++) arrC[i] = arrA[i];\\n        for (i = 0; i < lenB; i++) arrC[lenA + i] = arrB[i];\\n\\n        return arrC;\\n    }\\n\\n    function minus(uint256[] memory arrA, uint256[] memory arrB)\\n        public pure returns (uint256[] memory)\\n    {\\n        uint256 lenA = arrA.length;\\n        uint256 lenB = arrB.length;\\n\\n        uint256[] memory arrC = new uint256[](lenA);\\n\\n        uint256 pointer;\\n\\n        while (lenA > 0) {\\n            bool flag = false;\\n            lenB = arrB.length;\\n            \\n            while (lenB > 0) {\\n                if (arrB[lenB - 1] == arrA[lenA - 1]) {\\n                    flag = true;\\n                    break;\\n                }\\n                lenB--;\\n            }\\n\\n            if (!flag) {\\n                arrC[pointer] = arrA[lenA - 1];\\n                pointer++;\\n            }\\n\\n            lenA--;\\n        }\\n\\n        return resize(arrC, pointer);\\n    }\\n\\n    function fullyCoveredBy(uint256[] memory arrA, uint256[] memory arrB)\\n        public pure returns (bool)\\n    {\\n        uint256[] memory arrAr = refine(arrA);\\n        uint256[] memory arrBr = refine(arrB);\\n\\n        uint256 lenA = arrAr.length;\\n        uint256 lenB = arrBr.length;\\n\\n        while (lenA > 0) {\\n            uint256 i;\\n            while (i < lenB) {\\n                if (arrBr[i] == arrAr[lenA-1]) break;\\n                i++;\\n            }\\n            if (i==lenB) return false;\\n            lenA--;\\n        }\\n\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/BallotsBox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nlibrary BallotsBox {\\n\\n    enum AttitudeOfVote {\\n        All,\\n        Support,\\n        Against,\\n        Abstain\\n    }\\n\\n    struct Ballot {\\n        uint40 acct;\\n        uint8 attitude;\\n        uint32 head;\\n        uint64 weight;\\n        uint48 sigDate;\\n        uint64 blocknumber;\\n        bytes32 sigHash;\\n        uint[] principals;\\n    }\\n\\n    struct Case {\\n        uint32 sumOfHead;\\n        uint64 sumOfWeight;\\n        uint256[] voters;\\n        uint256[] principals;\\n    }\\n\\n    struct Box {\\n        mapping(uint256 => Case) cases;\\n        mapping(uint256 => Ballot) ballots;\\n    }\\n\\n    // #################\\n    // ##    Write    ##\\n    // #################\\n\\n    function castVote(\\n        Box storage box,\\n        uint acct,\\n        uint attitude,\\n        uint head,\\n        uint weight,\\n        bytes32 sigHash,\\n        uint[] memory principals\\n    ) public returns (bool flag) {\\n        // uint40 voter = uint40(acct);        \\n        require(\\n            attitude == uint8(AttitudeOfVote.Support) ||\\n                attitude == uint8(AttitudeOfVote.Against) ||\\n                attitude == uint8(AttitudeOfVote.Abstain),\\n            \\\"BB.CV: attitude overflow\\\"\\n        );\\n\\n        Ballot storage b = box.ballots[acct];\\n\\n        if (b.sigDate == 0) {\\n            box.ballots[acct] = Ballot({\\n                acct: uint40(acct),\\n                attitude: uint8(attitude),\\n                head: uint32(head),\\n                weight: uint64(weight),\\n                sigDate: uint48(block.timestamp),\\n                blocknumber: uint64(block.number),\\n                sigHash: sigHash,\\n                principals: principals\\n            });\\n\\n            // Case storage c = box.cases[attitude];\\n\\n            // c.sumOfHead += b.head;\\n            // c.sumOfWeight += b.weight;\\n            // c.voters.push(acct);\\n\\n            // c = box.cases[uint8(AttitudeOfVote.All)];\\n\\n            // c.sumOfHead += b.head;\\n            // c.sumOfWeight += b.weight;\\n            // c.voters.push(acct);\\n\\n            _pushToCase(box.cases[attitude], b);\\n            _pushToCase(box.cases[uint8(AttitudeOfVote.All)], b);\\n\\n            flag = true;\\n        }\\n    }\\n\\n    function _pushToCase(Case storage c, Ballot memory b) private {\\n            c.sumOfHead += b.head;\\n            c.sumOfWeight += b.weight;\\n            c.voters.push(b.acct);\\n            \\n            uint len = b.principals.length;\\n            while (len > 0) {\\n                c.principals.push(b.principals[len - 1]);\\n                len--;\\n            }\\n    }\\n\\n\\n    // #################\\n    // ##    Read     ##\\n    // #################\\n\\n    function isVoted(Box storage box, uint256 acct) \\n        public view returns (bool) \\n    {\\n        return box.ballots[acct].sigDate > 0;\\n    }\\n\\n    function isVotedFor(\\n        Box storage box,\\n        uint256 acct,\\n        uint256 atti\\n    ) public view returns (bool) {\\n        return box.ballots[acct].attitude == atti;\\n    }\\n\\n    function getCaseOfAttitude(Box storage box, uint256 atti)\\n        public view returns (Case memory )\\n    {\\n        return box.cases[atti];\\n    }\\n\\n    function getBallot(Box storage box, uint256 acct)\\n        public view returns (Ballot memory)\\n    {\\n        return box.ballots[acct];\\n    }\\n\\n\\n\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Checkpoints.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nlibrary Checkpoints {\\n\\n    struct Checkpoint {\\n        uint48 timestamp;\\n        uint16 votingWeight;\\n        uint64 paid;\\n        uint64 par;\\n        uint64 cleanPaid;\\n    }\\n\\n    struct History {\\n        // checkpoints[0].timestamp : counter\\n        mapping (uint256 => Checkpoint) checkpoints;\\n    }\\n\\n    //##################\\n    //##  Write I/O  ##\\n    //##################\\n\\n    function push(\\n        History storage self,\\n        uint weight,\\n        uint paid,\\n        uint par,\\n        uint cleanPaid\\n    ) public {\\n\\n        uint256 pos = counterOfPoints(self);\\n\\n        uint48 timestamp = uint48 (block.timestamp);\\n\\n        Checkpoint memory point = Checkpoint({\\n            timestamp: timestamp,\\n            votingWeight: uint16(weight),\\n            paid: uint64(paid),\\n            par: uint64(par),\\n            cleanPaid: uint64(cleanPaid)\\n        });\\n\\n        if (self.checkpoints[pos].timestamp == timestamp) {\\n            self.checkpoints[pos] = point;\\n        } else {\\n            self.checkpoints[pos+1] = point;\\n            _increaseCounter(self);\\n        }\\n    }\\n\\n    function _increaseCounter(History storage self)\\n        public\\n    {\\n        self.checkpoints[0].timestamp++;\\n    }\\n\\n    //##################\\n    //##    \u8bfb\u63a5\u53e3    ##\\n    //##################\\n\\n    function counterOfPoints(History storage self)\\n        public view returns (uint256)\\n    {\\n        return self.checkpoints[0].timestamp;\\n    }\\n\\n    function latest(History storage self)\\n        public view returns (Checkpoint memory point)\\n    {\\n        point = self.checkpoints[counterOfPoints(self)];\\n    }\\n\\n    function _average(uint256 a, uint256 b) private pure returns (uint256) {\\n        return (a & b) + ((a ^ b) >> 1);\\n    }\\n\\n    function getAtDate(History storage self, uint256 timestamp)\\n        public view returns (Checkpoint memory point)\\n    {\\n        require(\\n            timestamp <= block.timestamp,\\n            \\\"Checkpoints: block not yet mined\\\"\\n        );\\n\\n        uint256 high = counterOfPoints(self) + 1;\\n        uint256 low = 1;\\n        while (low < high) {\\n            uint256 mid = _average(low, high);\\n            if (self.checkpoints[mid].timestamp > timestamp) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        if (high > 1) point = self.checkpoints[high - 1];\\n    }\\n\\n    function pointsOfHistory(History storage self)\\n        public view returns (Checkpoint[] memory) \\n    {\\n        uint256 len = counterOfPoints(self);\\n\\n        Checkpoint[] memory output = new Checkpoint[](len);\\n\\n        while (len > 0) {\\n            output[len-1] = self.checkpoints[len];\\n            len--;\\n        }\\n\\n        return output;\\n    }\\n    \\n}\\n\"\r\n    },\r\n    \"contracts/lib/DealsRepo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"./EnumerableSet.sol\\\";\\nimport \\\"./MotionsRepo.sol\\\";\\nimport \\\"./SwapsRepo.sol\\\";\\nimport \\\"./SharesRepo.sol\\\";\\n\\nimport \\\"../comps/common/components/IMeetingMinutes.sol\\\";\\nimport \\\"../comps/books/ros/IRegisterOfShares.sol\\\";\\n\\n\\nlibrary DealsRepo {\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using SwapsRepo for SwapsRepo.Repo;\\n\\n    // _deals[0].head {\\n    //     seqOfDeal: counterOfClosedDeal;\\n    //     preSeq: counterOfDeal;\\n    //     typeOfDeal: typeOfIA;\\n    // }    \\n\\n    enum TypeOfDeal {\\n        ZeroPoint,\\n        CapitalIncrease,\\n        ShareTransferExt,\\n        ShareTransferInt,\\n        PreEmptive,\\n        TagAlong,\\n        DragAlong,\\n        FirstRefusal,\\n        FreeGift\\n    }\\n\\n    enum TypeOfIA {\\n        ZeroPoint,\\n        CapitalIncrease,\\n        ShareTransferExt,\\n        ShareTransferInt,\\n        CI_STint,\\n        SText_STint,\\n        CI_SText_STint,\\n        CI_SText\\n    }\\n\\n    enum StateOfDeal {\\n        Drafting,\\n        Locked,\\n        Cleared,\\n        Closed,\\n        Terminated\\n    }\\n\\n    struct Head {\\n        uint8 typeOfDeal;\\n        uint16 seqOfDeal;\\n        uint16 preSeq;\\n        uint16 classOfShare;\\n        uint32 seqOfShare;\\n        uint40 seller;\\n        uint32 priceOfPaid;\\n        uint32 priceOfPar;\\n        uint48 closingDeadline;\\n        uint16 votingWeight;\\n    }\\n\\n    struct Body {\\n        uint40 buyer;\\n        uint40 groupOfBuyer;\\n        uint64 paid;\\n        uint64 par;\\n        uint8 state;\\n        uint16 para;\\n        uint16 argu;\\n        bool flag;\\n    }\\n\\n    struct Deal {\\n        Head head;\\n        Body body;\\n        bytes32 hashLock;\\n    }\\n\\n    struct Repo {\\n        mapping(uint256 => Deal) deals;\\n        mapping(uint256 => SwapsRepo.Repo) swaps;\\n        //seqOfDeal => seqOfShare => bool\\n        mapping(uint => mapping(uint => bool)) priceDiffRequested;\\n        EnumerableSet.UintSet seqList;\\n    }\\n\\n    //##################\\n    //##   Modifier   ##\\n    //##################\\n\\n    modifier onlyCleared(Repo storage repo, uint256 seqOfDeal) {\\n        require(\\n            repo.deals[seqOfDeal].body.state == uint8(StateOfDeal.Cleared),\\n            \\\"DR.mf.OC: wrong stateOfDeal\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier dealExist(Repo storage repo, uint seqOfDeal) {\\n        require(isDeal(repo, seqOfDeal), \\\"DR.mf.dealExist: not\\\");\\n        _;\\n    }\\n\\n    //#################\\n    //##  Write I/O  ##\\n    //#################\\n\\n    function snParser(bytes32 sn) public pure returns(Head memory head) {\\n        uint _sn = uint(sn);\\n\\n        head = Head({\\n            typeOfDeal: uint8(_sn >> 248),\\n            seqOfDeal: uint16(_sn >> 232),\\n            preSeq: uint16(_sn >> 216),\\n            classOfShare: uint16(_sn >> 200),\\n            seqOfShare: uint32(_sn >> 168),\\n            seller: uint40(_sn >> 128),\\n            priceOfPaid: uint32(_sn >> 96),\\n            priceOfPar: uint32(_sn >> 64),\\n            closingDeadline: uint48(_sn >> 16),\\n            votingWeight: uint16(_sn) \\n        });\\n\\n    } \\n\\n    function codifyHead(Head memory head) public pure returns(bytes32 sn) {\\n        bytes memory _sn = abi.encodePacked(\\n                            head.typeOfDeal,\\n                            head.seqOfDeal,\\n                            head.preSeq,\\n                            head.classOfShare,\\n                            head.seqOfShare,\\n                            head.seller,\\n                            head.priceOfPaid,\\n                            head.priceOfPaid,\\n                            head.closingDeadline,\\n                            head.votingWeight);        \\n        assembly {\\n            sn := mload(add(_sn, 0x20))\\n        }\\n    }\\n\\n    function addDeal(\\n        Repo storage repo,\\n        bytes32 sn,\\n        uint buyer,\\n        uint groupOfBuyer,\\n        uint paid,\\n        uint par\\n    ) public returns (uint16 seqOfDeal)  {\\n\\n        Deal memory deal;\\n\\n        deal.head = snParser(sn);\\n\\n        deal.body.buyer = uint40(buyer);\\n        deal.body.groupOfBuyer = uint40(groupOfBuyer);\\n        deal.body.paid = uint64(paid);\\n        deal.body.par = uint64(par);\\n\\n        seqOfDeal = regDeal(repo, deal);\\n    }\\n\\n    function regDeal(Repo storage repo, Deal memory deal) \\n        public returns(uint16 seqOfDeal) \\n    {\\n        require(deal.body.par > 0, \\\"DR.RD: zero par\\\");\\n        require(deal.body.par >= deal.body.paid, \\\"DR.RD: paid overflow\\\");\\n\\n        // if (!repo.seqList.contains(deal.head.seqOfDeal)) {\\n        deal.head.seqOfDeal = _increaseCounterOfDeal(repo);\\n        repo.seqList.add(deal.head.seqOfDeal);\\n        // }\\n        repo.deals[deal.head.seqOfDeal] = Deal({\\n            head: deal.head,\\n            body: deal.body,\\n            hashLock: bytes32(0)\\n        });\\n        seqOfDeal = deal.head.seqOfDeal;\\n    }\\n\\n    function _increaseCounterOfDeal(Repo storage repo) private returns(uint16 seqOfDeal){\\n        repo.deals[0].head.preSeq++;\\n        seqOfDeal = repo.deals[0].head.preSeq;\\n    }\\n\\n    function delDeal(Repo storage repo, uint256 seqOfDeal) public returns (bool flag) {\\n        if (repo.seqList.remove(seqOfDeal)) {\\n            delete repo.deals[seqOfDeal];\\n            repo.deals[0].head.preSeq--;\\n            flag = true;\\n        }\\n    }\\n\\n    function lockDealSubject(Repo storage repo, uint256 seqOfDeal) public returns (bool flag) {\\n        if (repo.deals[seqOfDeal].body.state == uint8(StateOfDeal.Drafting)) {\\n            repo.deals[seqOfDeal].body.state = uint8(StateOfDeal.Locked);\\n            flag = true;\\n        }\\n    }\\n\\n    function releaseDealSubject(Repo storage repo, uint256 seqOfDeal) public returns (bool flag)\\n    {\\n        uint8 state = repo.deals[seqOfDeal].body.state;\\n\\n        if ( state < uint8(StateOfDeal.Closed) ) {\\n\\n            repo.deals[seqOfDeal].body.state = uint8(StateOfDeal.Drafting);\\n            flag = true;\\n\\n        } else if (state == uint8(StateOfDeal.Terminated)) {\\n\\n            flag = true;            \\n        }\\n    }\\n\\n    function clearDealCP(\\n        Repo storage repo,\\n        uint256 seqOfDeal,\\n        bytes32 hashLock,\\n        uint closingDeadline\\n    ) public {\\n        Deal storage deal = repo.deals[seqOfDeal];\\n\\n        require(deal.body.state == uint8(StateOfDeal.Locked), \\n            \\\"IA.CDCP: wrong Deal state\\\");\\n\\n        deal.body.state = uint8(StateOfDeal.Cleared);\\n        deal.hashLock = hashLock;\\n\\n        if (closingDeadline > 0) {\\n            if (block.timestamp < closingDeadline) \\n                deal.head.closingDeadline = uint48(closingDeadline);\\n            else revert (\\\"IA.clearDealCP: updated closingDeadline not FUTURE time\\\");\\n        }\\n    }\\n\\n    function closeDeal(Repo storage repo, uint256 seqOfDeal, string memory hashKey)\\n        public onlyCleared(repo, seqOfDeal) returns (bool flag)\\n    {\\n        require(\\n            repo.deals[seqOfDeal].hashLock == keccak256(bytes(hashKey)),\\n            \\\"IA.closeDeal: hashKey NOT correct\\\"\\n        );\\n\\n        return _closeDeal(repo, seqOfDeal);\\n    }\\n\\n    function directCloseDeal(Repo storage repo, uint seqOfDeal) \\n        public returns (bool flag) \\n    {\\n        require(repo.deals[seqOfDeal].body.state == uint8(StateOfDeal.Locked), \\n            \\\"IA.directCloseDeal: wrong state of deal\\\");\\n        \\n        return _closeDeal(repo, seqOfDeal);\\n    }\\n\\n    function _closeDeal(Repo storage repo, uint seqOfDeal)\\n        private returns(bool flag) \\n    {\\n    \\n        Deal storage deal = repo.deals[seqOfDeal];\\n\\n        require(\\n            block.timestamp < deal.head.closingDeadline,\\n            \\\"IA.closeDeal: MISSED closing date\\\"\\n        );\\n\\n        deal.body.state = uint8(StateOfDeal.Closed);\\n\\n        _increaseCounterOfClosedDeal(repo);\\n\\n        flag = (counterOfDeal(repo) == counterOfClosedDeal(repo));\\n    }\\n\\n    function terminateDeal(Repo storage repo, uint256 seqOfDeal) public returns(bool flag){\\n        Body storage body = repo.deals[seqOfDeal].body;\\n\\n        require(body.state == uint8(StateOfDeal.Locked) ||\\n            body.state == uint8(StateOfDeal.Cleared)\\n            , \\\"DR.TD: wrong stateOfDeal\\\");\\n\\n        body.state = uint8(StateOfDeal.Terminated);\\n\\n        _increaseCounterOfClosedDeal(repo);\\n        flag = (counterOfDeal(repo) == counterOfClosedDeal(repo));\\n    }\\n\\n    function takeGift(Repo storage repo, uint256 seqOfDeal)\\n        public returns (bool flag)\\n    {\\n        Deal storage deal = repo.deals[seqOfDeal];\\n\\n        require(\\n            deal.head.typeOfDeal == uint8(TypeOfDeal.FreeGift),\\n            \\\"not a gift deal\\\"\\n        );\\n\\n        require(\\n            repo.deals[deal.head.preSeq].body.state == uint8(StateOfDeal.Closed),\\n            \\\"Capital Increase not closed\\\"\\n        );\\n\\n        require(deal.body.state == uint8(StateOfDeal.Locked), \\\"wrong state\\\");\\n\\n        deal.body.state = uint8(StateOfDeal.Closed);\\n\\n        _increaseCounterOfClosedDeal(repo);\\n        flag = (counterOfDeal(repo) == counterOfClosedDeal(repo));\\n    }\\n\\n    function _increaseCounterOfClosedDeal(Repo storage repo) private {\\n        repo.deals[0].head.seqOfDeal++;\\n    }\\n\\n    function calTypeOfIA(Repo storage repo) public {\\n        uint[3] memory types;\\n\\n        uint[] memory seqList = repo.seqList.values();\\n        uint len = seqList.length;\\n        \\n        while (len > 0) {\\n            uint typeOfDeal = repo.deals[seqList[len-1]].head.typeOfDeal;\\n            len--;\\n\\n            if (typeOfDeal == 1) {\\n                if (types[0] == 0) types[0] = 1;\\n                continue;\\n            } else if (typeOfDeal == 2) {\\n                if (types[1] == 0) types[1] = 2;\\n                continue;\\n            } else if (typeOfDeal == 3) {\\n                if (types[2] == 0) types[2] = 3;\\n                continue;\\n            }\\n        }\\n\\n        uint8 sum = uint8(types[0] + types[1] + types[2]);\\n        repo.deals[0].head.typeOfDeal = (sum == 3)\\n                ? (types[2] == 0)\\n                    ? 7\\n                    : 3\\n                : sum;\\n    }\\n\\n    // ==== Swap ====\\n\\n    function createSwap(\\n        Repo storage repo,\\n        uint seqOfMotion,\\n        uint seqOfDeal,\\n        uint paidOfTarget,\\n        uint seqOfPledge,\\n        uint caller,\\n        IRegisterOfShares _ros,\\n        IMeetingMinutes _gmm\\n    ) public returns(SwapsRepo.Swap memory swap) {\\n        Deal storage deal = repo.deals[seqOfDeal];\\n\\n        require(caller == deal.head.seller, \\n            \\\"DR.createSwap: not seller\\\");\\n\\n        require(deal.body.state == uint8(StateOfDeal.Terminated),\\n            \\\"DR.createSwap: wrong state\\\");\\n\\n        MotionsRepo.Motion memory motion = \\n            _gmm.getMotion(seqOfMotion);\\n\\n        require(\\n            motion.body.state == uint8(MotionsRepo.StateOfMotion.Rejected_ToBuy),\\n            \\\"DR.createSwap: NO need to buy\\\"\\n        );\\n\\n        require(block.timestamp < motion.body.voteEndDate + \\n            uint48(motion.votingRule.execDaysForPutOpt) * 86400, \\n            \\\"DR.createSwap: missed deadline\\\");\\n\\n\\n        swap = SwapsRepo.Swap({\\n            seqOfSwap: 0,\\n            seqOfPledge: uint32(seqOfPledge),\\n            paidOfPledge: 0,\\n            seqOfTarget: deal.head.seqOfShare,\\n            paidOfTarget: uint64(paidOfTarget),\\n            priceOfDeal: deal.head.priceOfPaid,\\n            isPutOpt: true,\\n            state: uint8(SwapsRepo.StateOfSwap.Issued)\\n        });\\n\\n        SharesRepo.Head memory headOfPledge = _ros.getShare(swap.seqOfPledge).head;\\n\\n        require(_gmm.getBallot(seqOfMotion, _gmm.getDelegateOf(seqOfMotion, \\n            headOfPledge.shareholder)).attitude == 2,\\n            \\\"DR.createSwap: not vetoer\\\");\\n\\n        require (deal.body.paid >= repo.swaps[seqOfDeal].sumPaidOfTarget() +\\n            swap.paidOfTarget, \\\"DR.createSwap: paidOfTarget overflow\\\");\\n\\n        swap.paidOfPledge = (swap.priceOfDeal - _ros.getShare(swap.seqOfTarget).head.priceOfPaid) * \\n            swap.paidOfTarget / headOfPledge.priceOfPaid;\\n\\n        return repo.swaps[seqOfDeal].regSwap(swap);\\n    }\\n\\n    function payOffSwap(\\n        Repo storage repo,\\n        uint seqOfMotion,\\n        uint seqOfDeal,\\n        uint seqOfSwap,\\n        uint msgValue,\\n        uint centPrice,\\n        IMeetingMinutes _gmm\\n    ) public returns(SwapsRepo.Swap memory){\\n\\n        MotionsRepo.Motion memory motion = _gmm.getMotion(seqOfMotion);\\n\\n        require(block.timestamp < motion.body.voteEndDate + \\n            uint48(motion.votingRule.execDaysForPutOpt) * 86400, \\n            \\\"DR.payOffSwap: missed deadline\\\");\\n \\n        return repo.swaps[seqOfDeal].payOffSwap(seqOfSwap, msgValue, centPrice);\\n    }\\n\\n    function terminateSwap(\\n        Repo storage repo,\\n        uint seqOfMotion,\\n        uint seqOfDeal,\\n        uint seqOfSwap,\\n        IMeetingMinutes _gmm\\n    ) public returns (SwapsRepo.Swap memory){\\n\\n        MotionsRepo.Motion memory motion = _gmm.getMotion(seqOfMotion);\\n\\n        require(block.timestamp >= motion.body.voteEndDate + \\n            uint48(motion.votingRule.execDaysForPutOpt) * 86400, \\n            \\\"DR.terminateSwap: still in exec period\\\");\\n\\n        return repo.swaps[seqOfDeal].terminateSwap(seqOfSwap);\\n    }\\n\\n    function payOffApprovedDeal(\\n        Repo storage repo,\\n        uint seqOfDeal,\\n        // uint msgValue,\\n        // uint centPrice,\\n        uint caller\\n    ) public returns (bool flag){\\n\\n        Deal storage deal = repo.deals[seqOfDeal];\\n\\n        require(deal.head.typeOfDeal != uint8(TypeOfDeal.FreeGift),\\n            \\\"DR.payApprDeal: free gift\\\");\\n\\n        require(caller == deal.body.buyer,\\n            \\\"DR.payApprDeal: not buyer\\\");\\n\\n        require(deal.body.state == uint8(StateOfDeal.Locked) ||\\n            deal.body.state == uint8(StateOfDeal.Cleared) , \\n            \\\"DR.payApprDeal: wrong state\\\");\\n\\n        require(block.timestamp < deal.head.closingDeadline,\\n            \\\"DR.payApprDeal: missed closingDeadline\\\");\\n\\n        // require((uint(deal.body.paid) * deal.head.priceOfPaid + \\n        //     uint(deal.body.par - deal.body.paid) * deal.head.priceOfPar) * \\n        //     centPrice / 100 <= msgValue, \\\"DR.payApprDeal: insufficient msgValue\\\");\\n\\n        deal.body.state = uint8(StateOfDeal.Closed);\\n\\n        _increaseCounterOfClosedDeal(repo);\\n\\n        flag = (counterOfDeal(repo) == counterOfClosedDeal(repo));\\n    }\\n\\n    function requestPriceDiff(\\n        Repo storage repo,\\n        uint seqOfDeal,\\n        uint seqOfShare\\n    ) public dealExist(repo, seqOfDeal) {\\n        require(!repo.priceDiffRequested[seqOfDeal][seqOfShare],\\n            \\\"DR.requestPriceDiff: already requested\\\");\\n        repo.priceDiffRequested[seqOfDeal][seqOfShare] = true;      \\n    }\\n\\n\\n    //  ################################\\n    //  ##       \u67e5\u8be2\u63a5\u53e3              ##\\n    //  ###############################\\n\\n    function getTypeOfIA(Repo storage repo) external view returns (uint8) {\\n        return repo.deals[0].head.typeOfDeal;\\n    }\\n\\n    function counterOfDeal(Repo storage repo) public view returns (uint16) {\\n        return repo.deals[0].head.preSeq;\\n    }\\n\\n    function counterOfClosedDeal(Repo storage repo) public view returns (uint16) {\\n        return repo.deals[0].head.seqOfDeal;\\n    }\\n\\n    function isDeal(Repo storage repo, uint256 seqOfDeal) public view returns (bool) {\\n        return repo.seqList.contains(seqOfDeal);\\n    }\\n\\n    // function getHeadOfDeal(Repo storage repo, uint256 seq) \\n    //     external view dealExist(repo, seq) returns (Head memory)\\n    // {\\n    //     return repo.deals[seq].head;\\n    // }\\n\\n    // function getBodyOfDeal(Repo storage repo,  uint256 seq) \\n    //     external view dealExist(repo, seq) returns (Body memory)\\n    // {\\n    //     return repo.deals[seq].body;\\n    // }\\n\\n    // function getHashLockOfDeal(Repo storage repo, uint256 seq) \\n    //     external view dealExist(repo, seq) returns (bytes32)\\n    // {\\n    //     return repo.deals[seq].hashLock;\\n    // }\\n    \\n    function getDeal(Repo storage repo, uint256 seq) \\n        external view dealExist(repo, seq) returns (Deal memory)\\n    {\\n        return repo.deals[seq];\\n    }\\n\\n    function getSeqList(Repo storage repo) external view returns (uint[] memory) {\\n        return repo.seqList.values();\\n    }\\n    \\n    // ==== Swap ====\\n\\n    function counterOfSwaps(Repo storage repo, uint seqOfDeal)\\n        public view returns (uint16)\\n    {\\n        return repo.swaps[seqOfDeal].counterOfSwaps();\\n    }\\n\\n    function sumPaidOfTarget(Repo storage repo, uint seqOfDeal)\\n        public view returns (uint64)\\n    {\\n        return repo.swaps[seqOfDeal].sumPaidOfTarget();\\n    }\\n\\n    function isSwap(Repo storage repo, uint seqOfDeal, uint256 seqOfSwap)\\n        public view returns (bool)\\n    {\\n        return repo.swaps[seqOfDeal].isSwap(seqOfSwap);\\n    }\\n\\n    function getSwap(Repo storage repo, uint seqOfDeal, uint256 seqOfSwap)\\n        public view returns (SwapsRepo.Swap memory)\\n    {\\n        return repo.swaps[seqOfDeal].getSwap(seqOfSwap);\\n    }\\n\\n    function getAllSwaps(Repo storage repo, uint seqOfDeal)\\n        public view returns (SwapsRepo.Swap[] memory )\\n    {\\n        return repo.swaps[seqOfDeal].getAllSwaps();\\n    }\\n\\n    function allSwapsClosed(Repo storage repo, uint seqOfDeal)\\n        public view returns (bool)\\n    {\\n        return repo.swaps[seqOfDeal].allSwapsClosed();\\n    }\\n\\n    // ==== Value Calculation ==== \\n\\n    function checkValueOfSwap(\\n        Repo storage repo,\\n        uint seqOfDeal,\\n        uint seqOfSwap,\\n        uint centPrice\\n    ) public view dealExist(repo, seqOfDeal) returns (uint) {\\n        return repo.swaps[seqOfDeal].checkValueOfSwap(seqOfSwap, centPrice);\\n    }\\n\\n    function checkValueOfDeal(\\n        Repo storage repo, \\n        uint seqOfDeal, \\n        uint centPrice\\n    ) public view returns (uint) {\\n        Deal memory deal = repo.deals[seqOfDeal];\\n\\n        return (uint(deal.body.paid * deal.head.priceOfPaid) + \\n            uint((deal.body.par - deal.body.paid) * deal.head.priceOfPar)) *\\n            centPrice / 100;\\n    }    \\n}\\n\"\r\n    },\r\n    \"contracts/lib/DelegateMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"../comps/books/rom/IRegisterOfMembers.sol\\\";\\nimport \\\"../comps/books/rod/IRegisterOfDirectors.sol\\\";\\n\\nlibrary DelegateMap {\\n\\n    struct LeavesInfo {\\n        uint64 weight;\\n        uint32 emptyHead;\\n    }\\n\\n    struct Voter {\\n        uint40 delegate;\\n        uint64 weight;\\n        uint64 repWeight;\\n        uint32 repHead;\\n        uint[] principals;\\n    }\\n\\n    struct Map {\\n        mapping(uint256 => Voter) voters;\\n    }\\n\\n    // #################\\n    // ##    Write    ##\\n    // #################\\n\\n    function entrustDelegate(\\n        Map storage map,\\n        uint principal,\\n        uint delegate,\\n        uint weight\\n    ) public returns (bool flag) {\\n        require(principal != 0, \\\"DM.ED: zero principal\\\");\\n        require(delegate != 0, \\\"DM.ED: zero delegate\\\");\\n        require(principal != delegate,\\\"DM.ED: self delegate\\\");\\n\\n        if (map.voters[principal].delegate == 0 && \\n            map.voters[delegate].delegate == 0) \\n        {\\n            Voter storage p = map.voters[principal];\\n            Voter storage d = map.voters[delegate];\\n\\n            p.delegate = uint40(delegate);\\n            p.weight = uint64(weight);\\n\\n            d.repHead += (p.repHead + 1);\\n            d.repWeight += (p.repWeight + p.weight);\\n\\n            d.principals.push(uint40(principal));\\n            _consolidatePrincipals(p.principals, d);\\n\\n            flag = true;\\n        }\\n    }\\n\\n    function _consolidatePrincipals(uint[] memory principals, Voter storage d) private {\\n        uint len = principals.length;\\n\\n        while (len > 0) {\\n            d.principals.push(principals[len-1]);\\n            len--;\\n        }        \\n    }\\n\\n    // #################\\n    // ##    Read     ##\\n    // #################\\n\\n    function getDelegateOf(Map storage map, uint acct)\\n        public\\n        view\\n        returns (uint d)\\n    {\\n        while (acct > 0) {\\n            d = acct;\\n            acct = map.voters[d].delegate;\\n        }\\n    }\\n\\n    function updateLeavesWeightAtDate(Map storage map, uint256 acct, uint baseDate, IRegisterOfMembers _rom)\\n        public\\n    {\\n        LeavesInfo memory info;\\n        Voter storage voter = map.voters[acct];\\n\\n        uint[] memory leaves = voter.principals;\\n        uint256 len = leaves.length;\\n\\n        while (len > 0) {\\n            uint64 w = _rom.votesAtDate(acct, baseDate);\\n            if (w > 0) {\\n                info.weight += w;\\n            } else {\\n                info.emptyHead++;\\n            }\\n            len--;\\n        }\\n        \\n        voter.weight = _rom.votesAtDate(acct, baseDate);\\n        voter.repWeight = info.weight;\\n        voter.repHead = uint32(leaves.length) - info.emptyHead;\\n    }\\n\\n    function updateLeavesHeadcountOfDirectors(Map storage map, uint256 acct, IRegisterOfDirectors _rod) \\n        public \\n    {\\n        uint[] memory leaves = map.voters[acct].principals;\\n        uint256 len = leaves.length;\\n\\n        uint32 repHead;        \\n        while (len > 0) {\\n            if (_rod.isDirector(acct)) repHead++;\\n            len--;\\n        }\\n\\n        map.voters[acct].repHead = repHead;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/DocsRepo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nlibrary DocsRepo {\\n    \\n    struct Head {\\n        uint32 typeOfDoc;\\n        uint32 version;\\n        uint64 seqOfDoc;\\n        uint40 author;\\n        uint40 creator;\\n        uint48 createDate;\\n    }\\n \\n    struct Body {\\n        uint64 seq;\\n        address addr;\\n    }\\n\\n    struct Doc {\\n        Head head;\\n        address body;\\n    }\\n\\n    struct Repo {\\n        // typeOfDoc => version => seqOfDoc => Body\\n        mapping(uint256 => mapping(uint256 => mapping(uint256 => Body))) bodies;\\n        mapping(address => Head) heads;\\n    }\\n\\n    //##################\\n    //##  Write I/O   ##\\n    //##################\\n\\n    function snParser(bytes32 sn) public pure returns(Head memory head) {\\n        uint _sn = uint(sn);\\n\\n        head.typeOfDoc = uint32(_sn >> 224);\\n        head.version = uint32(_sn >> 192);\\n        head.seqOfDoc = uint64(_sn >> 128);\\n        head.author = uint40(_sn >> 88);\\n    }\\n\\n    function codifyHead(Head memory head) public pure returns(bytes32 sn) {\\n        bytes memory _sn = abi.encodePacked(\\n                            head.typeOfDoc,\\n                            head.version,\\n                            head.seqOfDoc,\\n                            head.author,\\n                            head.creator,\\n                            head.createDate);  \\n        assembly {\\n            sn := mload(add(_sn, 0x20))\\n        }\\n    }\\n\\n    function setTemplate(\\n        Repo storage repo,\\n        uint typeOfDoc, \\n        address body,\\n        uint author,\\n        uint caller\\n    ) public returns (Head memory head) {\\n        head.typeOfDoc = uint32(typeOfDoc);\\n        head.author = uint40(author);\\n        head.creator = uint40(caller);\\n\\n        require(body != address(0), \\\"DR.setTemplate: zero address\\\");\\n        require(head.typeOfDoc > 0, \\\"DR.setTemplate: zero typeOfDoc\\\");\\n        if (head.typeOfDoc > counterOfTypes(repo))\\n            head.typeOfDoc = _increaseCounterOfTypes(repo);\\n\\n        require(head.author > 0, \\\"DR.setTemplate: zero author\\\");\\n        require(head.creator > 0, \\\"DR.setTemplate: zero creator\\\");\\n        // if (counterOfVersions(repo, typeOfDoc) > 0)\\n        //     require( repo.heads[repo.bodies[head.typeOfDoc][1][0].addr].creator \\n        //         == head.creator, \\\"DR.setTemplate: not Template creator\\\");\\n\\n        head.version = _increaseCounterOfVersions(repo, head.typeOfDoc);\\n        head.createDate = uint48(block.timestamp);\\n\\n        repo.bodies[head.typeOfDoc][head.version][0].addr = body;\\n        repo.heads[body] = head;\\n    }\\n\\n    function createDoc(\\n        Repo storage repo, \\n        bytes32 snOfDoc,\\n        uint creator\\n    ) public returns (Doc memory doc)\\n    {\\n        doc.head = snParser(snOfDoc);\\n        doc.head.creator = uint40(creator);\\n\\n        require(doc.head.typeOfDoc > 0, \\\"DR.createDoc: zero typeOfDoc\\\");\\n        require(doc.head.version > 0, \\\"DR.createDoc: zero version\\\");\\n        require(doc.head.creator > 0, \\\"DR.createDoc: zero creator\\\");\\n\\n        address temp = repo.bodies[doc.head.typeOfDoc][doc.head.version][0].addr;\\n        require(temp != address(0), \\\"DR.createDoc: template not ready\\\");\\n\\n        doc.head.author = repo.heads[temp].author;\\n        doc.head.seqOfDoc = _increaseCounterOfDocs(repo, doc.head.typeOfDoc, doc.head.version);            \\n        doc.head.createDate = uint48(block.timestamp);\\n\\n        doc.body = _createClone(temp);\\n\\n        repo.bodies[doc.head.typeOfDoc][doc.head.version][doc.head.seqOfDoc].addr = doc.body;\\n        repo.heads[doc.body] = doc.head;\\n\\n    }\\n\\n    function transferIPR(\\n        Repo storage repo,\\n        uint typeOfDoc,\\n        uint version,\\n        uint transferee,\\n        uint caller \\n    ) public {\\n        require (caller == getAuthor(repo, typeOfDoc, version),\\n            \\\"DR.transferIPR: not author\\\");\\n        repo.heads[repo.bodies[typeOfDoc][version][0].addr].author = uint40(transferee);\\n    }\\n\\n    function _increaseCounterOfTypes(Repo storage repo) \\n        private returns(uint32) \\n    {\\n        repo.bodies[0][0][0].seq++;\\n        return uint32(repo.bodies[0][0][0].seq);\\n    }\\n\\n    function _increaseCounterOfVersions(\\n        Repo storage repo, \\n        uint256 typeOfDoc\\n    ) private returns(uint32) {\\n        repo.bodies[typeOfDoc][0][0].seq++;\\n        return uint32(repo.bodies[typeOfDoc][0][0].seq);\\n    }\\n\\n    function _increaseCounterOfDocs(\\n        Repo storage repo, \\n        uint256 typeOfDoc, \\n        uint256 version\\n    ) private returns(uint64) {\\n        repo.bodies[typeOfDoc][version][0].seq++;\\n        return repo.bodies[typeOfDoc][version][0].seq;\\n    }\\n\\n    // ==== CloneFactory ====\\n\\n/*\\nThe MIT License (MIT)\\nCopyright (c) 2018 Murray Software, LLC.\\nPermission is hereby granted, free of charge, to any person obtaining\\na copy of this software and associated documentation files (the\\n\\\"Software\\\"), to deal in the Software without restriction, including\\nwithout limitation the rights to use, copy, modify, merge, publish,\\ndistribute, sublicense, and/or sell copies of the Software, and to\\npermit persons to whom the Software is furnished to do so, subject to\\nthe following conditions:\\nThe above copyright notice and this permission notice shall be included\\nin all copies or substantial portions of the Software.\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n*/\\n//solhint-disable max-line-length\\n//solhint-disable no-inline-assembly\\n\\n\\n    function _createClone(address temp) private returns (address result) {\\n        bytes20 tempBytes = bytes20(temp);\\n        assembly {\\n            let clone := mload(0x40)\\n            mstore(\\n                clone,\\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\\n            )\\n            mstore(add(clone, 0x14), tempBytes)\\n            mstore(\\n                add(clone, 0x28),\\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\\n            )\\n            result := create(0, clone, 0x37)\\n        }\\n    }\\n\\n    function _isClone(address temp, address query)\\n        private view returns (bool result)\\n    {\\n        bytes20 tempBytes = bytes20(temp);\\n        assembly {\\n            let clone := mload(0x40)\\n            mstore(\\n                clone,\\n                0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000\\n            )\\n            mstore(add(clone, 0xa), tempBytes)\\n            mstore(\\n                add(clone, 0x1e),\\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\\n            )\\n\\n            let other := add(clone, 0x40)\\n            extcodecopy(query, other, 0, 0x2d)\\n            result := and(\\n                eq(mload(clone), mload(other)),\\n                eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\\n            )\\n        }\\n    }\\n\\n    //##################\\n    //##   read I/O   ##\\n    //##################\\n\\n\\n    function counterOfTypes(Repo storage repo) public view returns(uint32) {\\n        return uint32(repo.bodies[0][0][0].seq);\\n    }\\n\\n    function counterOfVersions(Repo storage repo, uint typeOfDoc) public view returns(uint32) {\\n        return uint32(repo.bodies[uint32(typeOfDoc)][0][0].seq);\\n    }\\n\\n    function counterOfDocs(Repo storage repo, uint typeOfDoc, uint version) public view returns(uint64) {\\n        return repo.bodies[uint32(typeOfDoc)][uint32(version)][0].seq;\\n    }\\n\\n    function getAuthor(\\n        Repo storage repo,\\n        uint typeOfDoc,\\n        uint version\\n    ) public view returns(uint40) {\\n        address temp = repo.bodies[typeOfDoc][version][0].addr;\\n        require(temp != address(0), \\\"getAuthor: temp not exist\\\");\\n\\n        return repo.heads[temp].author;\\n    }\\n\\n    function getAuthorByBody(\\n        Repo storage repo,\\n        address body\\n    ) public view returns(uint40) {\\n        Head memory head = getHeadByBody(repo, body);\\n        return getAuthor(repo, head.typeOfDoc, head.version);\\n    }\\n\\n    function docExist(Repo storage repo, address body) public view returns(bool) {\\n        Head memory head = repo.heads[body];\\n        if (   body == address(0) \\n            || head.typeOfDoc == 0 \\n            || head.version == 0 \\n            || head.seqOfDoc == 0\\n        ) return false;\\n   \\n        return repo.bodies[head.typeOfDoc][head.version][head.seqOfDoc].addr == body;\\n    }\\n\\n    function getHeadByBody(\\n        Repo storage repo,\\n        address body\\n    ) public view returns (Head memory ) {\\n        return repo.heads[body];\\n    }\\n\\n\\n    function getDoc(\\n        Repo storage repo,\\n        bytes32 snOfDoc\\n    ) public view returns(Doc memory doc) {\\n        doc.head = snParser(snOfDoc);\\n\\n        doc.body = repo.bodies[doc.head.typeOfDoc][doc.head.version][doc.head.seqOfDoc].addr;\\n        doc.head = repo.heads[doc.body];\\n    }\\n\\n    function getVersionsList(\\n        Repo storage repo,\\n        uint typeOfDoc\\n    ) public view returns(Doc[] memory)\\n    {\\n        uint32 len = counterOfVersions(repo, typeOfDoc);\\n        Doc[] memory out = new Doc[](len);\\n\\n        while (len > 0) {\\n            Head memory head;\\n            head.typeOfDoc = uint32(typeOfDoc);\\n            head.version = len;\\n\\n            out[len - 1] = getDoc(repo, codifyHead(head));\\n            len--;\\n        }\\n\\n        return out;\\n    }\\n\\n    function getDocsList(\\n        Repo storage repo,\\n        bytes32 snOfDoc\\n    ) public view returns(Doc[] memory) {\\n        Head memory head = snParser(snOfDoc);\\n                \\n        uint64 len = counterOfDocs(repo, head.typeOfDoc, head.version);\\n        Doc[] memory out = new Doc[](len);\\n\\n        while (len > 0) {\\n            head.seqOfDoc = len;\\n            out[len - 1] = getDoc(repo, codifyHead(head));\\n            len--;\\n        }\\n\\n        return out;\\n    }\\n\\n    function verifyDoc(\\n        Repo storage repo, \\n        bytes32 snOfDoc\\n    ) public view returns(bool) {\\n        Head memory head = snParser(snOfDoc);\\n\\n        address temp = repo.bodies[head.typeOfDoc][head.version][0].addr;\\n        address target = repo.bodies[head.typeOfDoc][head.version][head.seqOfDoc].addr;\\n\\n        return _isClone(temp, target);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/lib/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.8;\\n\\nlibrary EnumerableSet {\\n    struct Set {\\n        bytes32[] _values;\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                set._values[toDeleteIndex] = lastValue;\\n                set._indexes[lastValue] = valueIndex;\\n            }\\n\\n            delete set._values[lastIndex];\\n            set._values.pop();\\n\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function _contains(Set storage set, bytes32 value)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    function _at(Set storage set, uint256 index)\\n        private\\n        view\\n        returns (bytes32)\\n    {\\n        return set._values[index];\\n    }\\n\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    //======== Bytes32Set ========\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    function add(Bytes32Set storage set, bytes32 value)\\n        public\\n        returns (bool)\\n    {\\n        return _add(set._inner, value);\\n    }\\n\\n    function remove(Bytes32Set storage set, bytes32 value)\\n        public\\n        returns (bool)\\n    {\\n        return _remove(set._inner, value);\\n    }\\n\\n    function contains(Bytes32Set storage set, bytes32 value)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return _contains(set._inner, value);\\n    }\\n\\n    function length(Bytes32Set storage set) public view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function at(Bytes32Set storage set, uint256 index)\\n        public\\n        view\\n        returns (bytes32)\\n    {\\n        return _at(set._inner, index);\\n    }\\n\\n    function values(Bytes32Set storage set)\\n        public\\n        view\\n        returns (bytes32[] memory)\\n    {\\n        return _values(set._inner);\\n    }\\n\\n    //======== AddressSet ========\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    function add(AddressSet storage set, address value)\\n        public\\n        returns (bool)\\n    {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function remove(AddressSet storage set, address value)\\n        public\\n        returns (bool)\\n    {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function contains(AddressSet storage set, address value)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function length(AddressSet storage set) public view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function at(AddressSet storage set, uint256 index)\\n        public\\n        view\\n        returns (address)\\n    {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    function values(AddressSet storage set)\\n        public\\n        view\\n        returns (address[] memory)\\n    {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    //======== UintSet ========\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    function add(UintSet storage set, uint256 value) public returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    function remove(UintSet storage set, uint256 value)\\n        public\\n        returns (bool)\\n    {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) public view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function at(UintSet storage set, uint256 index)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    function values(UintSet storage set)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/LockersRepo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"./EnumerableSet.sol\\\";\\n\\nlibrary LockersRepo {\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n    struct Head {\\n        uint40 from;\\n        uint40 to;\\n        uint48 expireDate;\\n        uint128 value;\\n    }\\n    struct Body {\\n        address counterLocker;\\n        bytes payload;\\n    }\\n    struct Locker {\\n        Head head;\\n        Body body;\\n    }\\n\\n    struct Repo {\\n        // hashLock => locker\\n        mapping (bytes32 => Locker) lockers;\\n        EnumerableSet.Bytes32Set snList;\\n    }\\n\\n    //#################\\n    //##    Write    ##\\n    //#################\\n\\n    function headSnParser(bytes32 sn) public pure returns (Head memory head) {\\n        uint _sn = uint(sn);\\n        \\n        head = Head({\\n            from: uint40(_sn >> 216),\\n            to: uint40(_sn >> 176),\\n            expireDate: uint48(_sn >> 128),\\n            value: uint128(_sn)\\n        });\\n    }\\n\\n    function codifyHead(Head memory head) public pure returns (bytes32 headSn) {\\n        bytes memory _sn = abi.encodePacked(\\n                            head.from,\\n                            head.to,\\n                            head.expireDate,\\n                            head.value);\\n        assembly {\\n            headSn := mload(add(_sn, 0x20))\\n        }\\n    }\\n\\n    function lockPoints(\\n        Repo storage repo,\\n        Head memory head,\\n        bytes32 hashLock\\n    ) public {\\n        Body memory body;\\n        lockConsideration(repo, head, body, hashLock);        \\n    }\\n\\n    function lockConsideration(\\n        Repo storage repo,\\n        Head memory head,\\n        Body memory body,\\n        bytes32 hashLock\\n    ) public {       \\n        if (repo.snList.add(hashLock)) {            \\n            Locker storage locker = repo.lockers[hashLock];      \\n            locker.head = head;\\n            locker.body = body;\\n        } else revert (\\\"LR.lockConsideration: occupied\\\");\\n    }\\n\\n    function pickupPoints(\\n        Repo storage repo,\\n        bytes32 hashLock,\\n        string memory hashKey,\\n        uint caller\\n    ) public returns(Head memory head) {\\n        \\n        bytes memory key = bytes(hashKey);\\n\\n        require(hashLock == keccak256(key),\\n            \\\"LR.pickupPoints: wrong key\\\");\\n\\n        Locker storage locker = repo.lockers[hashLock];\\n\\n        require(block.timestamp < locker.head.expireDate, \\n            \\\"LR.pickupPoints: locker expired\\\");\\n\\n        bool flag = true;\\n\\n        if (locker.body.counterLocker != address(0)) {\\n            require(locker.head.to == caller, \\n                \\\"LR.pickupPoints: wrong caller\\\");\\n\\n            uint len = key.length;\\n            bytes memory zero = new bytes(32 - (len % 32));\\n\\n            bytes memory payload = abi.encodePacked(locker.body.payload, len, key, zero);\\n            (flag, ) = locker.body.counterLocker.call(payload);\\n        }\\n\\n        if (flag) {\\n            head = locker.head;\\n            delete repo.lockers[hashLock];\\n            repo.snList.remove(hashLock);\\n        }\\n    }\\n\\n    function withdrawDeposit(\\n        Repo storage repo,\\n        bytes32 hashLock,\\n        uint256 caller\\n    ) public returns(Head memory head) {\\n\\n        Locker memory locker = repo.lockers[hashLock];\\n\\n        require(block.timestamp >= locker.head.expireDate, \\n            \\\"LR.withdrawDeposit: locker not expired\\\");\\n\\n        require(locker.head.from == caller, \\n            \\\"LR.withdrawDeposit: wrong caller\\\");\\n\\n        if (repo.snList.remove(hashLock)) {\\n            head = locker.head;\\n            delete repo.lockers[hashLock];\\n        } revert (\\\"LR.withdrawDeposit: locker not exist\\\");\\n    }\\n\\n    //#################\\n    //##    Read     ##\\n    //#################\\n\\n    function getHeadOfLocker(\\n        Repo storage repo,\\n        bytes32 hashLock\\n    ) public view returns (Head memory head) {\\n        return repo.lockers[hashLock].head;\\n    }\\n\\n    function getLocker(\\n        Repo storage repo,\\n        bytes32 hashLock\\n    ) public view returns (Locker memory) {\\n        return repo.lockers[hashLock];\\n    }\\n\\n    function getSnList(\\n        Repo storage repo\\n    ) public view returns (bytes32[] memory ) {\\n        return repo.snList.values();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/MembersRepo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"./Checkpoints.sol\\\";\\nimport \\\"./EnumerableSet.sol\\\";\\nimport \\\"./SharesRepo.sol\\\";\\nimport \\\"./TopChain.sol\\\";\\n\\nlibrary MembersRepo {\\n    using Checkpoints for Checkpoints.History;\\n    // using EnumerableSet for EnumerableSet.Bytes32Set;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    // using SharesRepo for SharesRepo.Head;\\n    using TopChain for TopChain.Chain;\\n\\n    struct Member {\\n        Checkpoints.History votesInHand;\\n        // class => seqList\\n        mapping(uint => EnumerableSet.UintSet) sharesOfClass;\\n        EnumerableSet.UintSet classesBelonged;\\n    }\\n\\n    /*\\n        members[0] {\\n            votesInHand: ownersEquity;\\n        }\\n    */\\n\\n    /* Node[0] {\\n        prev: tail;\\n        next: head;\\n        ptr: pending;\\n        amt: pending;\\n        sum: totalVotes;\\n        cat: basedOnPar;\\n    } */\\n\\n    struct Repo {\\n        TopChain.Chain chain;\\n        mapping(uint256 => Member) members;\\n        // class => membersList\\n        mapping(uint => EnumerableSet.UintSet) membersOfClass;\\n    }\\n\\n    //###############\\n    //##  Modifer  ##\\n    //###############\\n\\n    modifier memberExist(\\n        Repo storage repo,\\n        uint acct\\n    ) {\\n        require(isMember(repo, acct),\\n            \\\"MR.memberExist: not\\\");\\n        _;\\n    }\\n\\n    //##################\\n    //##  Write I/O  ##\\n    //##################\\n\\n    // ==== Zero Node Setting ====\\n\\n    function setVoteBase(\\n        Repo storage repo, \\n        bool _basedOnPar\\n    ) public returns (bool flag) {\\n\\n        if (repo.chain.basedOnPar() != _basedOnPar) {\\n            uint256[] memory members = \\n                repo.membersOfClass[0].values();\\n            uint256 len = members.length;\\n\\n            while (len > 0) {\\n                uint256 cur = members[len - 1];\\n\\n                Checkpoints.Checkpoint memory cp = \\n                    repo.members[cur].votesInHand.latest();\\n\\n                if (cp.paid != cp.par) {\\n                    if (_basedOnPar)\\n                        repo.chain.increaseAmt(cur, (cp.par - cp.paid) * cp.votingWeight / 100, true);\\n                    else repo.chain.increaseAmt(cur, (cp.par - cp.paid) * cp.votingWeight / 100, false);\\n                }\\n\\n                len--;\\n            }\\n\\n            repo.chain.setVoteBase(_basedOnPar);\\n\\n            flag = true;\\n        }\\n    }\\n\\n    // ==== Member ====\\n\\n    function addMember(\\n        Repo storage repo, \\n        uint acct\\n    ) public returns (bool flag) {\\n        if (repo.membersOfClass[0].add(acct)) {\\n            repo.chain.addNode(acct);\\n            flag = true;\\n        }\\n    }\\n\\n    function delMember(\\n        Repo storage repo, \\n        uint acct\\n    ) public {\\n        repo.chain.delNode(acct);\\n\\n        uint[] memory classes = \\n            repo.members[acct].classesBelonged.values();\\n        uint len = classes.length;\\n        \\n        while (len > 0) {\\n            repo.membersOfClass[classes[len - 1]].remove(acct);\\n            len--;\\n        }\\n\\n        repo.membersOfClass[0].remove(acct);\\n\\n        delete repo.members[acct];\\n    }\\n\\n    function addShareToMember(\\n        Repo storage repo,\\n        SharesRepo.Head memory head\\n    ) public {\\n\\n        Member storage member = repo.members[head.shareholder];\\n\\n        if (member.sharesOfClass[0].add(head.seqOfShare)\\n            && member.sharesOfClass[head.class].add(head.seqOfShare)\\n            && member.classesBelonged.add(head.class))\\n                repo.membersOfClass[head.class].add(head.shareholder);\\n    }\\n\\n    function removeShareFromMember(\\n        Repo storage repo,\\n        SharesRepo.Head memory head\\n    ) public {\\n\\n        Member storage member = \\n            repo.members[head.shareholder];\\n        \\n        if (member.sharesOfClass[head.class].remove(head.seqOfShare)\\n            && member.sharesOfClass[0].remove(head.seqOfShare)) {\\n\\n            if(member.sharesOfClass[head.class].length() == 0) {\\n                repo.membersOfClass[head.class].remove(head.shareholder);\\n                member.classesBelonged.remove(head.class);\\n            }\\n        }\\n\\n    }\\n\\n    function increaseAmtOfMember(\\n        Repo storage repo,\\n        uint acct,\\n        uint votingWeight,\\n        uint deltaPaid,\\n        uint deltaPar,\\n        uint deltaClean,\\n        bool isIncrease\\n    ) public {\\n\\n        if (deltaPaid > 0 || deltaPar > 0 ) {\\n\\n            uint deltaAmt = repo.chain.basedOnPar() \\n                ? deltaPar \\n                : deltaPaid;\\n\\n            repo.chain.increaseAmt(\\n                acct, \\n                deltaAmt * votingWeight / 100, \\n                isIncrease\\n            );\\n        }\\n\\n        Checkpoints.Checkpoint memory cp = \\n            repo.members[acct].votesInHand.latest();\\n\\n        if (cp.votingWeight != votingWeight)\\n            cp.votingWeight = _calWeight(\\n                repo, \\n                cp, \\n                votingWeight, \\n                deltaPaid, \\n                deltaPar, \\n                isIncrease\\n            );\\n\\n        if (isIncrease) {\\n            cp.paid += uint64(deltaPaid);\\n            cp.par += uint64(deltaPar);\\n            cp.cleanPaid += uint64(deltaClean);\\n        } else {\\n            cp.paid -= uint64(deltaPaid);\\n            cp.par -= uint64(deltaPar);\\n            cp.cleanPaid -= uint64(deltaClean);\\n        }\\n\\n        repo.members[acct].votesInHand.push(\\n            cp.votingWeight, \\n            cp.paid, \\n            cp.par, \\n            cp.cleanPaid\\n        );\\n    }\\n\\n    function increaseAmtOfCap(\\n        Repo storage repo,\\n        uint votingWeight,\\n        uint deltaPaid,\\n        uint deltaPar,\\n        bool isIncrease\\n    ) public {\\n        Checkpoints.Checkpoint memory cp = \\n            repo.members[0].votesInHand.latest();\\n\\n        if (cp.votingWeight != votingWeight)\\n            cp.votingWeight = _calWeight(\\n                repo, \\n                cp, \\n                votingWeight, \\n                deltaPaid, \\n                deltaPar, \\n                isIncrease\\n            );\\n\\n        if (isIncrease) {\\n            cp.paid += uint64(deltaPaid);\\n            cp.par += uint64(deltaPar);\\n        } else {\\n            cp.paid -= uint64(deltaPaid);\\n            cp.par -= uint64(deltaPar);\\n        }\\n\\n        updateOwnersEquity(repo, cp);\\n\\n        if (repo.chain.basedOnPar() && deltaPar > 0) {\\n            repo.chain.increaseTotalVotes(deltaPar * votingWeight / 100, isIncrease);\\n        } else if (!repo.chain.basedOnPar() && deltaPaid > 0) {\\n            repo.chain.increaseTotalVotes(deltaPaid * votingWeight / 100, isIncrease);\\n        }\\n    }\\n\\n    function _calWeight(\\n        Repo storage repo,\\n        Checkpoints.Checkpoint memory cp,\\n        uint votingWeight,\\n        uint deltaPaid,\\n        uint deltaPar,\\n        bool isIncrease\\n    ) private view returns(uint16 output) {\\n        \\n        if (isIncrease) {\\n            output = repo.chain.basedOnPar()\\n                ? uint16(((cp.votingWeight * cp.par + votingWeight * deltaPar) * 100 / (cp.par + deltaPar) + 50) / 100)\\n                : uint16(((cp.votingWeight * cp.paid + votingWeight * deltaPaid) * 100 / (cp.paid + deltaPaid) + 50) / 100);\\n        } else {\\n            output = repo.chain.basedOnPar()\\n                ? uint16(((cp.votingWeight * cp.par - votingWeight * deltaPar) * 100 / (cp.par - deltaPar) + 50) / 100)\\n                : uint16(((cp.votingWeight * cp.paid - votingWeight * deltaPaid) * 100 / (cp.paid - deltaPaid) + 50) / 100);            \\n        }\\n    }\\n\\n    // ==== Zero Node Setting ====\\n\\n    function updateOwnersEquity(\\n        Repo storage repo,\\n        Checkpoints.Checkpoint memory cp\\n    ) public {\\n        repo.members[0].votesInHand.push(cp.votingWeight, cp.paid, cp.par, cp.cleanPaid);\\n    }\\n\\n    //##################\\n    //##    \u8bfb\u63a5\u53e3    ##\\n    //##################\\n\\n    // ==== member ====\\n\\n    function isMember(\\n        Repo storage repo,\\n        uint acct\\n    ) public view returns(bool) {\\n        return repo.membersOfClass[0].contains(acct);\\n    }\\n    \\n    function qtyOfMembers(\\n        Repo storage repo\\n    ) public view returns(uint) {\\n        return repo.membersOfClass[0].length();\\n    }\\n\\n    function membersList(\\n        Repo storage repo\\n    ) public view returns(uint[] memory) {\\n        return repo.membersOfClass[0].values();\\n    }\\n\\n    // ---- Votes ----\\n\\n    function ownersEquity(\\n        Repo storage repo\\n    ) public view returns(Checkpoints.Checkpoint memory) {\\n        return repo.members[0].votesInHand.latest();\\n    }\\n\\n    function capAtDate(\\n        Repo storage repo,\\n        uint date\\n    ) public view returns(Checkpoints.Checkpoint memory) {\\n        return repo.members[0].votesInHand.getAtDate(date);\\n    }\\n\\n    function equityOfMember(\\n        Repo storage repo,\\n        uint acct\\n    ) public view memberExist(repo, acct) returns(\\n        Checkpoints.Checkpoint memory\\n    ) {\\n        return repo.members[acct].votesInHand.latest();\\n    }\\n\\n    function equityAtDate(\\n        Repo storage repo,\\n        uint acct,\\n        uint date\\n    ) public view memberExist(repo, acct) returns(\\n        Checkpoints.Checkpoint memory\\n    ) {\\n        return repo.members[acct].votesInHand.getAtDate(date);\\n    }\\n\\n    function votesAtDate(\\n        Repo storage repo,\\n        uint256 acct,\\n        uint date\\n    ) public view returns (uint64) {\\n        Checkpoints.Checkpoint memory cp = repo.members[acct].votesInHand.getAtDate(date);\\n        \\n        return repo.chain.basedOnPar() \\n                ? (cp.par * cp.votingWeight + 50) / 100 \\n                : (cp.paid * cp.votingWeight + 50) / 100;\\n    }\\n\\n    function votesHistory(\\n        Repo storage repo,\\n        uint acct\\n    ) public view memberExist(repo, acct) \\n        returns (Checkpoints.Checkpoint[] memory) \\n    {\\n        return repo.members[acct].votesInHand.pointsOfHistory();\\n    }\\n\\n    // ---- Class ----\\n\\n    function isClassMember(\\n        Repo storage repo, \\n        uint256 acct, \\n        uint class\\n    ) public view memberExist(repo, acct) returns (bool flag) {\\n        return repo.members[acct].classesBelonged.contains(class);\\n    }\\n\\n    function classesBelonged(\\n        Repo storage repo, \\n        uint256 acct\\n    ) public view memberExist(repo, acct) returns (uint[] memory) {\\n        return repo.members[acct].classesBelonged.values();\\n    }\\n\\n    function qtyOfClassMember(\\n        Repo storage repo, \\n        uint class\\n    ) public view returns(uint256) {\\n        return repo.membersOfClass[class].length();\\n    }\\n\\n    function getMembersOfClass(\\n        Repo storage repo, \\n        uint class\\n    ) public view returns(uint256[] memory) {\\n        return repo.membersOfClass[class].values();\\n    }\\n\\n    // ---- Share ----\\n\\n    function qtyOfSharesInHand(\\n        Repo storage repo, \\n        uint acct\\n    ) public view memberExist(repo, acct) returns(uint) {\\n        return repo.members[acct].sharesOfClass[0].length();\\n    }\\n\\n    function sharesInHand(\\n        Repo storage repo, \\n        uint acct\\n    ) public view memberExist(repo, acct) returns(uint[] memory) {\\n        return repo.members[acct].sharesOfClass[0].values();\\n    }\\n\\n    function qtyOfSharesInClass(\\n        Repo storage repo, \\n        uint acct,\\n        uint class\\n    ) public view memberExist(repo, acct) returns(uint) {\\n        require(isClassMember(repo, acct, class), \\n            \\\"MR.qtyOfSharesInClass: not class member\\\");\\n        return repo.members[acct].sharesOfClass[class].length();\\n    }\\n\\n    function sharesInClass(\\n        Repo storage repo, \\n        uint acct,\\n        uint class\\n    ) public view memberExist(repo, acct) returns(uint[] memory) {\\n        require(isClassMember(repo, acct, class),\\n            \\\"MR.sharesInClass: not class member\\\");\\n        return repo.members[acct].sharesOfClass[class].values();\\n    }\\n\\n\\n\\n}\\n\"\r\n    },\r\n    \"contracts/lib/MotionsRepo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"./BallotsBox.sol\\\";\\nimport \\\"./DelegateMap.sol\\\";\\nimport \\\"./EnumerableSet.sol\\\";\\nimport \\\"./RulesParser.sol\\\";\\n\\nimport \\\"../comps/books/roc/IShareholdersAgreement.sol\\\";\\n\\nlibrary MotionsRepo {\\n    using BallotsBox for BallotsBox.Box;\\n    using DelegateMap for DelegateMap.Map;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using RulesParser for bytes32;\\n\\n    enum TypeOfMotion {\\n        ZeroPoint,\\n        ElectOfficer,\\n        RemoveOfficer,\\n        ApproveDoc,\\n        ApproveAction,\\n        TransferFund,\\n        DistributeProfits\\n    }\\n\\n    enum StateOfMotion {\\n        ZeroPoint,          // 0\\n        Created,            // 1\\n        Proposed,           // 2\\n        Passed,             // 3\\n        Rejected,           // 4\\n        Rejected_NotToBuy,  // 5\\n        Rejected_ToBuy,     // 6\\n        Executed            // 7\\n    }\\n\\n    struct Head {\\n        uint16 typeOfMotion;\\n        uint64 seqOfMotion;\\n        uint16 seqOfVR;\\n        uint40 creator;\\n        uint40 executor;\\n        uint48 createDate;        \\n        uint32 data;\\n    }\\n\\n    struct Body {\\n        uint40 proposer;\\n        uint48 proposeDate;\\n        uint48 shareRegDate;\\n        uint48 voteStartDate;\\n        uint48 voteEndDate;\\n        uint16 para;\\n        uint8 state;\\n    }\\n\\n    struct Motion {\\n        Head head;\\n        Body body;\\n        RulesParser.VotingRule votingRule;\\n        uint contents;\\n    }\\n\\n    struct Record {\\n        DelegateMap.Map map;\\n        BallotsBox.Box box;        \\n    }\\n\\n    struct VoteCalBase {\\n        uint32 totalHead;\\n        uint64 totalWeight;\\n        uint32 supportHead;\\n        uint64 supportWeight;\\n        uint16 attendHeadRatio;\\n        uint16 attendWeightRatio;\\n        uint16 para;\\n        uint8 state;            \\n        bool unaniConsent;\\n    }\\n\\n    struct Repo {\\n        mapping(uint256 => Motion) motions;\\n        mapping(uint256 => Record) records;\\n        EnumerableSet.UintSet seqList;\\n    }\\n\\n    //#################\\n    //##  Write I/O  ##\\n    //#################\\n\\n    // ==== snParser ====\\n\\n    function snParser (bytes32 sn) public pure returns(Head memory head) {\\n        uint _sn = uint(sn);\\n\\n        head = Head({\\n            typeOfMotion: uint16(_sn >> 240),\\n            seqOfMotion: uint64(_sn >> 176),\\n            seqOfVR: uint16(_sn >> 160),\\n            creator: uint40(_sn >> 120),\\n            executor: uint40(_sn >> 80),\\n            createDate: uint48(_sn >> 32),\\n            data: uint32(_sn)\\n        });\\n    }\\n\\n    function codifyHead(Head memory head) public pure returns(bytes32 sn) {\\n        bytes memory _sn = abi.encodePacked(\\n                            head.typeOfMotion,\\n                            head.seqOfMotion,\\n                            head.seqOfVR,\\n                            head.creator,\\n                            head.executor,\\n                            head.createDate,\\n                            head.data);  \\n        assembly {\\n            sn := mload(add(_sn, 0x20))\\n        }\\n    } \\n    \\n    // ==== addMotion ====\\n\\n    function addMotion(\\n        Repo storage repo,\\n        Head memory head,\\n        uint256 contents\\n    ) public returns (Head memory) {\\n\\n        require(head.typeOfMotion > 0, \\\"MR.CM: zero typeOfMotion\\\");\\n        require(head.seqOfVR > 0, \\\"MR.CM: zero seqOfVR\\\");\\n        require(head.creator > 0, \\\"MR.CM: zero caller\\\");\\n\\n        if (!repo.seqList.contains(head.seqOfMotion)) {\\n            head.seqOfMotion = _increaseCounterOfMotion(repo);\\n            head.createDate = uint48(block.timestamp);\\n            repo.seqList.add(head.seqOfMotion);\\n        }\\n    \\n        Motion storage m = repo.motions[head.seqOfMotion];\\n\\n        m.head = head;\\n        m.contents = contents;\\n        m.body.state = uint8(StateOfMotion.Created);\\n\\n        return head;\\n    } \\n\\n    function _increaseCounterOfMotion (Repo storage repo) private returns (uint64 seq) {\\n        repo.motions[0].head.seqOfMotion++;\\n        seq = repo.motions[0].head.seqOfMotion;\\n    }\\n\\n    // ==== entrustDelegate ====\\n\\n    function entrustDelegate(\\n        Repo storage repo,\\n        uint256 seqOfMotion,\\n        uint delegate,\\n        uint principal,\\n        IRegisterOfMembers _rom,\\n        IRegisterOfDirectors _rod\\n    ) public returns (bool flag) {\\n        Motion storage m = repo.motions[seqOfMotion];\\n\\n        require(m.body.state == uint8(StateOfMotion.Created) ||\\n            m.body.state == uint8(StateOfMotion.Proposed) , \\n            \\\"MR.EntrustDelegate: wrong state\\\");\\n\\n        if (_rom.isMember(delegate) && _rom.isMember(principal)) {\\n            uint64 weight;\\n            if (m.body.shareRegDate > 0 && block.timestamp >= m.body.shareRegDate) \\n                weight = _rom.votesAtDate(principal, m.body.shareRegDate);    \\n            return repo.records[seqOfMotion].map.entrustDelegate(principal, delegate, weight);\\n        } else if (_rod.isDirector(delegate) && _rod.isDirector(principal)) {\\n            return repo.records[seqOfMotion].map.entrustDelegate(principal, delegate, 0);\\n        } else revert (\\\"MR.entrustDelegate: not both Members or Directors\\\");        \\n    }\\n\\n    // ==== propose ====\\n\\n    function proposeMotionToGeneralMeeting(\\n        Repo storage repo,\\n        uint256 seqOfMotion,\\n        IShareholdersAgreement _sha,\\n        IRegisterOfMembers _rom,\\n        IRegisterOfDirectors _rod,\\n        uint caller\\n    ) public {\\n\\n        RulesParser.GovernanceRule memory gr =\\n            _sha.getRule(0).governanceRuleParser();\\n\\n        require(_memberProposalRightCheck(repo, seqOfMotion, gr, caller, _rom) ||\\n            _directorProposalRightCheck(repo, seqOfMotion, caller, gr.proposeHeadRatioOfDirectorsInGM, _rod),\\n            \\\"MR.PMTGM: has no proposalRight\\\");\\n\\n        _proposeMotion(repo, seqOfMotion, _sha, caller);\\n    } \\n\\n    function _proposeMotion(\\n        Repo storage repo,\\n        uint seqOfMotion,\\n        IShareholdersAgreement _sha,\\n        uint caller\\n    ) private {\\n\\n        require(caller > 0, \\\"MR.PM: zero caller\\\");\\n\\n        require(repo.records[seqOfMotion].map.voters[caller].delegate == 0,\\n            \\\"MR.PM: entrused delegate\\\");\\n\\n        Motion storage m = repo.motions[seqOfMotion];\\n        require(m.body.state == uint8(StateOfMotion.Created), \\n            \\\"MR.PM: wrong state\\\");\\n\\n        RulesParser.VotingRule memory vr = \\n            _sha.getRule(m.head.seqOfVR).votingRuleParser();\\n\\n        uint48 timestamp = uint48(block.timestamp);\\n\\n        Body memory body = Body({\\n            proposer: uint40(caller),\\n            proposeDate: timestamp,\\n            shareRegDate: timestamp + uint48(vr.invExitDays) * 86400,\\n            voteStartDate: timestamp + uint48(vr.invExitDays + vr.votePrepareDays) * 86400,\\n            voteEndDate: timestamp + uint48(vr.invExitDays + vr.votePrepareDays + vr.votingDays) * 86400,\\n            para: 0,\\n            state: uint8(StateOfMotion.Proposed)\\n        });\\n\\n        m.body = body;\\n        m.votingRule = vr;\\n    }\\n\\n    function _memberProposalRightCheck(\\n        Repo storage repo,\\n        uint seqOfMotion,\\n        RulesParser.GovernanceRule memory gr,\\n        uint caller,\\n        IRegisterOfMembers _rom\\n    ) private returns(bool) {\\n        if (!_rom.isMember(caller)) return false;\\n\\n        Motion memory motion = repo.motions[seqOfMotion];\\n        if (motion.head.typeOfMotion == uint8(TypeOfMotion.ApproveDoc) ||\\n            motion.head.typeOfMotion == uint8(TypeOfMotion.ElectOfficer))\\n            return true;\\n\\n        uint totalVotes = _rom.totalVotes();\\n\\n        if (gr.proposeWeightRatioOfGM > 0 &&\\n            _rom.votesInHand(caller) * 10000 / totalVotes >= gr.proposeWeightRatioOfGM)\\n                return true;\\n\\n        Record storage r = repo.records[seqOfMotion];\\n        r.map.updateLeavesWeightAtDate(caller, uint48(block.timestamp), _rom);\\n\\n        DelegateMap.Voter memory voter = r.map.voters[caller];\\n\\n\\n        if (gr.proposeWeightRatioOfGM > 0 && \\n            (voter.weight + voter.repWeight) * 10000 / totalVotes >= gr.proposeWeightRatioOfGM)\\n                return true;\\n\\n        if (gr.proposeHeadRatioOfMembers > 0 &&\\n            (voter.repHead + 1) * 10000 / _rom.qtyOfMembers() >= \\n                gr.proposeHeadRatioOfMembers)\\n                    return true;\\n        \\n        return false;\\n    }\\n\\n    function _directorProposalRightCheck(\\n        Repo storage repo,\\n        uint seqOfMotion,\\n        uint caller,\\n        uint16 proposalThreshold,\\n        IRegisterOfDirectors _rod\\n    ) private returns (bool) {\\n        if (!_rod.isDirector(caller)) return false;\\n\\n        uint totalHead = _rod.getNumOfDirectors();\\n        repo.records[seqOfMotion].map.updateLeavesHeadcountOfDirectors(caller, _rod);\\n\\n        if (proposalThreshold > 0 &&\\n            (repo.records[seqOfMotion].map.voters[caller].repHead + 1) * 10000 / totalHead >=\\n                proposalThreshold)\\n                    return true;\\n\\n        return false;\\n    } \\n\\n    function proposeMotionToBoard(\\n        Repo storage repo,\\n        uint256 seqOfMotion,\\n        IShareholdersAgreement _sha,\\n        IRegisterOfDirectors _rod,\\n        uint caller\\n    ) public {\\n\\n        RulesParser.GovernanceRule memory gr = \\n            _sha.getRule(0).governanceRuleParser();\\n\\n        require(\\n            _directorProposalRightCheck(\\n                repo, seqOfMotion, caller, \\n                gr.proposeHeadRatioOfDirectorsInBoard, \\n                _rod\\n            ),\\n            \\\"MR.PMTB: has no proposalRight\\\");\\n\\n        _proposeMotion(repo, seqOfMotion, _sha, caller);\\n    } \\n\\n    // ==== vote ====\\n\\n    function castVoteInGeneralMeeting(\\n        Repo storage repo,\\n        uint256 seqOfMotion,\\n        uint256 acct,\\n        uint attitude,\\n        bytes32 sigHash,\\n        IRegisterOfMembers _rom\\n    ) public {\\n\\n        require(_rom.isMember(acct), \\\"MR.castVoteInGM: not Member\\\");\\n\\n        Motion storage m = repo.motions[seqOfMotion];\\n        Record storage r = repo.records[seqOfMotion];\\n        DelegateMap.Voter storage voter = r.map.voters[acct];\\n\\n        r.map.updateLeavesWeightAtDate(acct, m.body.shareRegDate, _rom);\\n\\n        _castVote(repo, seqOfMotion, acct, attitude, voter.repHead + 1, voter.weight + voter.repWeight, sigHash);\\n    }\\n\\n    function castVoteInBoardMeeting(\\n        Repo storage repo,\\n        uint256 seqOfMotion,\\n        uint256 acct,\\n        uint attitude,\\n        bytes32 sigHash,\\n        IRegisterOfDirectors _rod\\n    ) public {\\n        require(_rod.isDirector(acct), \\\"MR.CVBM: not Director\\\");\\n\\n        Record storage r = repo.records[seqOfMotion];\\n\\n        DelegateMap.Voter storage voter = r.map.voters[acct];\\n\\n        r.map.updateLeavesHeadcountOfDirectors(acct, _rod);\\n\\n        _castVote(repo, seqOfMotion, acct, attitude, voter.repHead + 1, 0, sigHash);\\n    }\\n\\n    function _castVote(\\n        Repo storage repo,\\n        uint256 seqOfMotion,\\n        uint256 acct,\\n        uint attitude,\\n        uint headcount,\\n        uint weight,\\n        bytes32 sigHash\\n    ) private {\\n        require(seqOfMotion > 0, \\\"MR.CV: zero seqOfMotion\\\");\\n        require(voteStarted(repo, seqOfMotion), \\\"MR.CV: vote not started\\\");\\n        require(!voteEnded(repo, seqOfMotion), \\\"MR.CV: vote is Ended\\\");\\n\\n        Record storage r = repo.records[seqOfMotion];\\n        DelegateMap.Voter storage voter = r.map.voters[acct];\\n\\n        require(voter.delegate == 0, \\n            \\\"MR.CV: entrusted delegate\\\");\\n\\n        r.box.castVote(acct, attitude, headcount, weight, sigHash, voter.principals);\\n    }\\n\\n\\n    // ==== counting ====\\n\\n    function voteCounting(\\n        Repo storage repo,\\n        bool flag0,\\n        uint256 seqOfMotion,\\n        VoteCalBase memory base\\n    ) public returns (uint8) {\\n\\n        Motion storage m = repo.motions[seqOfMotion];\\n        Record storage r = repo.records[seqOfMotion];\\n\\n        require (m.body.state == uint8(StateOfMotion.Proposed) , \\\"MR.VT: wrong state\\\");\\n        require (voteEnded(repo, seqOfMotion), \\\"MR.VT: vote not ended yet\\\");\\n\\n        bool flag1 = m.votingRule.headRatio == 0;\\n        bool flag2 = m.votingRule.amountRatio == 0;\\n\\n        bool flag = (flag1 && flag2);\\n\\n        if (!flag && flag0 && !_isVetoed(r, m.votingRule.vetoers[0]) &&\\n            !_isVetoed(r, m.votingRule.vetoers[1])) {\\n            flag1 = flag1 ? true : base.totalHead > 0\\n                ? ((r.box.cases[uint8(BallotsBox.AttitudeOfVote.Support)]\\n                    .sumOfHead + base.supportHead) * 10000) /\\n                    base.totalHead >\\n                    m.votingRule.headRatio\\n                : base.unaniConsent \\n                    ? true\\n                    : false;\\n\\n            flag2 = flag2 ? true : base.totalWeight > 0\\n                ? ((r.box.cases[uint8(BallotsBox.AttitudeOfVote.Support)]\\n                    .sumOfWeight + base.supportWeight) * 10000) /\\n                    base.totalWeight >\\n                    m.votingRule.amountRatio\\n                : base.unaniConsent\\n                    ? true\\n                    : false;\\n        }\\n\\n        m.body.state =  flag || (flag0 && flag1 && flag2) \\n                ? uint8(MotionsRepo.StateOfMotion.Passed) \\n                : m.votingRule.againstShallBuy \\n                    ? uint8(MotionsRepo.StateOfMotion.Rejected_ToBuy)\\n                    : uint8(MotionsRepo.StateOfMotion.Rejected_NotToBuy);\\n\\n        return m.body.state;\\n    }\\n\\n    function _isVetoed(Record storage r, uint256 vetoer)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return vetoer > 0 && (r.box.ballots[vetoer].sigDate == 0 ||\\n            r.box.ballots[vetoer].attitude != uint8(BallotsBox.AttitudeOfVote.Support));\\n    }\\n\\n    // ==== ExecResolution ====\\n\\n    function execResolution(\\n        Repo storage repo,\\n        uint256 seqOfMotion,\\n        uint256 contents,\\n        uint executor\\n    ) public {\\n        Motion storage m = repo.motions[seqOfMotion];\\n        require (m.contents == contents, \\n            \\\"MR.execResolution: wrong contents\\\");\\n        require (m.body.state == uint8(StateOfMotion.Passed), \\n            \\\"MR.execResolution: wrong state\\\");\\n        require (m.head.executor == uint40(executor), \\\"MR.ER: not executor\\\");\\n\\n        m.body.state = uint8(StateOfMotion.Executed);\\n    }\\n    \\n    //#################\\n    //##    Read     ##\\n    //#################\\n\\n    // ==== VoteState ====\\n\\n    function isProposed(Repo storage repo, uint256 seqOfMotion)\\n        public view returns (bool)\\n    {\\n        return repo.motions[seqOfMotion].body.state == uint8(StateOfMotion.Proposed);\\n    }\\n\\n    function voteStarted(Repo storage repo, uint256 seqOfMotion)\\n        public view returns (bool)\\n    {\\n        return isProposed(repo, seqOfMotion) && \\n            repo.motions[seqOfMotion].body.voteStartDate <= block.timestamp;\\n    }\\n\\n    function voteEnded(Repo storage repo, uint256 seqOfMotion)\\n        public view returns (bool)\\n    {\\n        return isProposed(repo, seqOfMotion) && \\n            repo.motions[seqOfMotion].body.voteEndDate <= block.timestamp;\\n    }\\n\\n    // ==== Delegate ====\\n\\n    function getVoterOfDelegateMap(Repo storage repo, uint256 seqOfMotion, uint256 acct)\\n        public view returns (DelegateMap.Voter memory)\\n    {\\n        return repo.records[seqOfMotion].map.voters[acct];\\n    }\\n\\n    function getDelegateOf(Repo storage repo, uint256 seqOfMotion, uint acct)\\n        public view returns (uint)\\n    {\\n        return repo.records[seqOfMotion].map.getDelegateOf(acct);\\n    }\\n\\n    // function getLeavesWeightAtDate(\\n    //     Repo storage repo, \\n    //     uint256 seqOfMotion, \\n    //     uint acct,\\n    //     uint baseDate, \\n    //     IRegisterOfMembers _rom\\n    // ) public view returns(uint64 weight)\\n    // {\\n    //     repo.records[seqOfMotion].map.updateLeavesWeightAtDate(acct, baseDate, _rom);\\n\\n    //     DelegateMap.Voter storage voter = repo.records[seqOfMotion].map.voters[acct];\\n\\n    //     weight = voter.weight + voter.repWeight;\\n    // }\\n\\n    // function getLeavesHeadcountOfDirectors(\\n    //     Repo storage repo, \\n    //     uint256 seqOfMotion, \\n    //     uint acct,\\n    //     IRegisterOfDirectors _rod\\n    // ) public view returns(uint32 head)\\n    // {\\n    //     repo.records[seqOfMotion].map.updateLeavesHeadcountOfDirectors(acct, _rod);\\n\\n    //     DelegateMap.Voter storage voter = repo.records[seqOfMotion].map.voters[acct];\\n\\n    //     head = voter.repHead + 1;\\n    // }\\n\\n\\n    // ==== motion ====\\n\\n    function getMotion(Repo storage repo, uint256 seqOfMotion)\\n        public view returns (Motion memory motion)\\n    {\\n        motion = repo.motions[seqOfMotion];\\n    }\\n\\n    // ==== voting ====\\n\\n    function isVoted(Repo storage repo, uint256 seqOfMotion, uint256 acct) \\n        public view returns (bool) \\n    {\\n        return repo.records[seqOfMotion].box.isVoted(acct);\\n    }\\n\\n    function isVotedFor(\\n        Repo storage repo,\\n        uint256 seqOfMotion,\\n        uint256 acct,\\n        uint256 atti\\n    ) public view returns (bool) {\\n        return repo.records[seqOfMotion].box.isVotedFor(acct, atti);\\n    }\\n\\n    function getCaseOfAttitude(Repo storage repo, uint256 seqOfMotion, uint256 atti)\\n        public view returns (BallotsBox.Case memory )\\n    {\\n        return repo.records[seqOfMotion].box.getCaseOfAttitude(atti);\\n    }\\n\\n    function getBallot(Repo storage repo, uint256 seqOfMotion, uint256 acct)\\n        public view returns (BallotsBox.Ballot memory)\\n    {\\n        return repo.records[seqOfMotion].box.getBallot(acct);\\n    }\\n\\n    function isPassed(Repo storage repo, uint256 seqOfMotion) public view returns (bool) {\\n        return repo.motions[seqOfMotion].body.state == uint8(MotionsRepo.StateOfMotion.Passed);\\n    }\\n\\n    // ==== snList ====\\n\\n    function getSeqList(Repo storage repo) public view returns (uint[] memory) {\\n        return repo.seqList.values();\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/lib/OfficersRepo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"./EnumerableSet.sol\\\";\\nimport \\\"../comps/books/rom/IRegisterOfMembers.sol\\\";\\n\\nlibrary OfficersRepo {\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n\\n    enum TitleOfOfficers {\\n        ZeroPoint,\\n        Shareholder,\\n        Chairman,\\n        ViceChairman,\\n        ManagingDirector,\\n        Director,\\n        CEO,\\n        CFO,\\n        COO,\\n        CTO,\\n        President,\\n        VicePresident,\\n        Supervisor,\\n        SeniorManager,\\n        Manager,\\n        ViceManager      \\n    }\\n\\n    struct Position {\\n        uint16 title;\\n        uint16 seqOfPos;\\n        uint40 acct;\\n        uint40 nominator;\\n        uint48 startDate;\\n        uint48 endDate;\\n        uint16 seqOfVR;\\n        uint16 titleOfNominator;\\n        uint16 argu;\\n    }\\n\\n    struct Group {\\n        // seqList\\n        EnumerableSet.UintSet posList;\\n        // acctList\\n        EnumerableSet.UintSet acctList;\\n    }\\n\\n    struct Repo {\\n        //seqOfPos => Position\\n        mapping(uint => Position)  positions;\\n        // acct => seqOfPos\\n        mapping(uint => EnumerableSet.UintSet) posInHand;\\n        Group directors;\\n        Group managers;\\n    }\\n\\n    //#################\\n    //##   Modifier  ##\\n    //#################\\n\\n    modifier isVacant(Repo storage repo, uint256 seqOfPos) {\\n        require(!isOccupied(repo, seqOfPos), \\n            \\\"OR.mf.IV: position occupied\\\");\\n        _;\\n    }\\n\\n    //#################\\n    //##    Write    ##\\n    //#################\\n\\n    // ==== snParser ====\\n\\n    function snParser(bytes32 sn) public pure returns (Position memory position) {\\n        uint _sn = uint(sn);\\n\\n        position = Position({\\n            title: uint16(_sn >> 240),\\n            seqOfPos: uint16(_sn >> 224),\\n            acct: uint40(_sn >> 184),\\n            nominator: uint40(_sn >> 144),\\n            startDate: uint48(_sn >> 96),\\n            endDate: uint48(_sn >> 48),\\n            seqOfVR: uint16(_sn >> 32),\\n            titleOfNominator: uint16(_sn >> 16),\\n            argu: uint16(_sn)\\n        });\\n    }\\n\\n    function codifyPosition(Position memory position) public pure returns (bytes32 sn) {\\n        bytes memory _sn = abi.encodePacked(\\n                            position.title,\\n                            position.seqOfPos,\\n                            position.acct,\\n                            position.nominator,\\n                            position.startDate,\\n                            position.endDate,\\n                            position.seqOfVR,\\n                            position.titleOfNominator,\\n                            position.argu);  \\n        assembly {\\n            sn := mload(add(_sn, 0x20))\\n        }                \\n    }\\n\\n    // ======== Setting ========\\n\\n    function createPosition (Repo storage repo, bytes32 snOfPos) \\n        public \\n    {\\n        Position memory pos = snParser(snOfPos);\\n        addPosition(repo, pos);\\n    }\\n\\n    function addPosition(\\n        Repo storage repo,\\n        Position memory pos\\n    ) public {\\n        require (pos.title > uint8(TitleOfOfficers.Shareholder), \\\"OR.addPosition: title overflow\\\");\\n        require (pos.seqOfPos > 0, \\\"OR.addPosition: zero seqOfPos\\\");\\n        require (pos.titleOfNominator > 0, \\\"OR.addPosition: zero titleOfNominator\\\");\\n        require (pos.endDate > pos.startDate, \\\"OR.addPosition: endDate <= startDate\\\");\\n        require (pos.endDate > block.timestamp, \\\"OR.addPosition: endDate not future\\\");\\n\\n        Position storage p = repo.positions[pos.seqOfPos];\\n        \\n        if (p.seqOfPos == 0) {\\n            if (pos.title <= uint8(TitleOfOfficers.Director)) \\n                repo.directors.posList.add(pos.seqOfPos);\\n            else repo.managers.posList.add(pos.seqOfPos); \\n        } else require (p.seqOfPos == pos.seqOfPos,\\n            \\\"OR.addPosition: remove pos first\\\");\\n\\n        repo.positions[pos.seqOfPos] = pos;\\n    }\\n\\n    function removePosition(Repo storage repo, uint256 seqOfPos) \\n        public isVacant(repo, seqOfPos) returns (bool flag)\\n    {\\n        if (repo.directors.posList.remove(seqOfPos) ||\\n            repo.managers.posList.remove(seqOfPos)) \\n        {\\n            delete repo.positions[seqOfPos];\\n            flag = true;\\n        }\\n    }\\n\\n    function takePosition (\\n        Repo storage repo,\\n        uint256 seqOfPos,\\n        uint acct\\n    ) public returns (bool flag) {\\n        require (seqOfPos > 0, \\\"OR.takePosition: zero seqOfPos\\\");\\n        require (acct > 0, \\\"OR.takePosition: zero acct\\\");\\n        \\n        Position storage pos = repo.positions[seqOfPos];\\n\\n        if (repo.directors.posList.contains(seqOfPos))\\n            repo.directors.acctList.add(acct);\\n        else if (repo.managers.posList.contains(seqOfPos))\\n            repo.managers.acctList.add(acct);\\n        else revert(\\\"OR.takePosition: pos not exist\\\");\\n\\n        pos.acct = uint40(acct);\\n        pos.startDate = uint48(block.timestamp);\\n\\n        repo.posInHand[acct].add(seqOfPos);\\n\\n        flag = true;\\n    }\\n\\n    function quitPosition(\\n        Repo storage repo, \\n        uint256 seqOfPos,\\n        uint acct\\n    ) public returns (bool flag)\\n    {\\n        Position memory pos = repo.positions[seqOfPos];\\n        require(acct == pos.acct, \\n            \\\"OR.quitPosition: not the officer\\\");\\n        flag = vacatePosition(repo, seqOfPos);\\n    }\\n\\n    function vacatePosition (\\n        Repo storage repo,\\n        uint seqOfPos\\n    ) public returns (bool flag)\\n    {\\n        Position storage pos = repo.positions[seqOfPos];\\n\\n        uint acct = pos.acct;\\n        require (acct > 0, \\\"OR.vacatePosition: empty pos\\\");\\n\\n        if (repo.posInHand[acct].remove(seqOfPos)) {\\n            pos.acct = 0;\\n\\n            if (pos.title <= uint8(TitleOfOfficers.Director))\\n                repo.directors.acctList.remove(acct);\\n            else if (repo.posInHand[acct].length() == 0) {\\n                repo.managers.acctList.remove(acct);\\n            }\\n                \\n            flag = true;\\n        }        \\n    }\\n\\n    //##################\\n    //##    \u8bfb\u63a5\u53e3    ##\\n    //##################\\n\\n    // ==== Positions ====\\n\\n    function posExist(Repo storage repo, uint256 seqOfPos) public view returns (bool flag) {\\n        flag = repo.positions[seqOfPos].endDate > block.timestamp;\\n    } \\n\\n    function isOccupied(Repo storage repo, uint256 seqOfPos) public view returns (bool flag) {\\n        flag = repo.positions[seqOfPos].acct > 0;\\n    }\\n\\n    function getPosition(Repo storage repo, uint256 seqOfPos) public view returns (Position memory pos) {\\n        pos = repo.positions[seqOfPos];\\n    }\\n\\n    function getFullPosInfo(Repo storage repo, uint[] memory pl) \\n        public view returns(Position[] memory) \\n    {\\n        uint256 len = pl.length;\\n        Position[] memory ls = new Position[](len);\\n\\n        while (len > 0) {\\n            ls[len-1] = repo.positions[pl[len-1]];\\n            len--;\\n        }\\n\\n        return ls;        \\n    }\\n\\n    // ==== Managers ====\\n\\n    function isManager(Repo storage repo, uint256 acct) public view returns (bool flag) {\\n        flag = repo.managers.acctList.contains(acct);\\n    }\\n\\n    function getNumOfManagers(Repo storage repo) public view returns (uint256 num) {\\n        num = repo.managers.acctList.length();\\n    }\\n\\n    function getManagersList(Repo storage repo) public view returns (uint256[] memory ls) {\\n        ls = repo.managers.acctList.values();\\n    }\\n\\n    function getManagersPosList(Repo storage repo) public view returns(uint[] memory list) {\\n        list = repo.managers.posList.values();\\n    }\\n\\n    function getManagersFullPosInfo(Repo storage repo) public view \\n        returns(Position[] memory output) \\n    {\\n        uint[] memory pl = repo.managers.posList.values();\\n        output = getFullPosInfo(repo, pl);\\n    }\\n\\n    // ==== Directors ====\\n\\n    function isDirector(Repo storage repo, uint256 acct) \\n        public view returns (bool flag) \\n    {\\n        flag = repo.directors.acctList.contains(acct);\\n    }\\n\\n    function getNumOfDirectors(Repo storage repo) public view \\n        returns (uint256 num) \\n    {\\n        num = repo.directors.acctList.length();\\n    }\\n\\n    function getDirectorsList(Repo storage repo) public view \\n        returns (uint256[] memory ls) \\n    {\\n        ls = repo.directors.acctList.values();\\n    }\\n\\n    function getDirectorsPosList(Repo storage repo) public view \\n        returns (uint256[] memory ls) \\n    {\\n        ls = repo.directors.posList.values();\\n    }\\n\\n    function getDirectorsFullPosInfo(Repo storage repo) public view \\n        returns(Position[] memory output) \\n    {\\n        uint[] memory pl = repo.directors.posList.values();\\n        output = getFullPosInfo(repo, pl);\\n    }\\n\\n    // ==== Executives ====\\n\\n    function hasPosition(Repo storage repo, uint256 acct, uint256 seqOfPos) \\n        public view returns (bool flag) \\n    {\\n        flag = repo.posInHand[acct].contains(seqOfPos);\\n    }\\n\\n    function getPosInHand(Repo storage repo, uint256 acct) \\n        public view returns (uint256[] memory ls) \\n    {\\n        ls = repo.posInHand[acct].values();\\n    }\\n\\n    function getFullPosInfoInHand(Repo storage repo, uint acct) \\n        public view returns (Position[] memory output) \\n    {\\n        uint256[] memory pl = repo.posInHand[acct].values();\\n        output = getFullPosInfo(repo, pl);\\n    }\\n\\n    function hasTitle(Repo storage repo, uint acct, uint title, IRegisterOfMembers _rom)\\n        public view returns (bool)\\n    {\\n        if (title == uint8(TitleOfOfficers.Shareholder))\\n            return _rom.isMember(acct);\\n\\n        if (title == uint8(TitleOfOfficers.Director))\\n            return isDirector(repo, acct);\\n        \\n        Position[] memory list = getFullPosInfoInHand(repo, acct);\\n        uint len = list.length;\\n        while (len > 0) {\\n            if (list[len-1].title == uint16(title))\\n                return true;\\n            len --;\\n        }\\n        return false;\\n    }\\n\\n    function hasNominationRight(Repo storage repo, uint seqOfPos, uint acct, IRegisterOfMembers _rom)\\n        public view returns (bool)\\n    {\\n        Position memory pos = repo.positions[seqOfPos];\\n        if (pos.endDate <= block.timestamp) return false;\\n        else if (pos.nominator == 0)\\n            return hasTitle(repo, acct, pos.titleOfNominator, _rom);\\n        else return (pos.nominator == acct);\\n    }\\n\\n    // ==== seatsCalculator ====\\n\\n    function getBoardSeatsQuota(Repo storage repo, uint256 acct) public view \\n        returns (uint256 quota)\\n    {\\n        uint[] memory pl = repo.directors.posList.values();\\n        uint256 len = pl.length;\\n        while (len > 0) {\\n            Position memory pos = repo.positions[pl[len-1]];\\n            if (pos.nominator == acct) quota++;\\n            len--;\\n        }       \\n    }\\n\\n    function getBoardSeatsOccupied(Repo storage repo, uint acct) public view \\n        returns (uint256 num)\\n    {\\n        uint256[] memory dl = repo.directors.acctList.values();\\n        uint256 lenOfDL = dl.length;\\n\\n        while (lenOfDL > 0) {\\n            uint256[] memory pl = repo.posInHand[dl[lenOfDL-1]].values();\\n            uint256 lenOfPL = pl.length;\\n\\n            while(lenOfPL > 0) {\\n                Position memory pos = repo.positions[pl[lenOfPL-1]];\\n                if ( pos.title <= uint8(TitleOfOfficers.Director)) { \\n                    if (pos.nominator == acct) num++;\\n                    break;\\n                }\\n                lenOfPL--;\\n            }\\n\\n            lenOfDL--;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/RulesParser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nlibrary RulesParser {\\n\\n    // ======== GovernanceRule ========\\n\\n    // bytes32 public constant SHA_INIT_GR = \\n    //     bytes32(uint(0x0000000000000000010000000000000000000000000000000000000000000000));\\n\\n    struct GovernanceRule {\\n        uint32 fundApprovalThreshold; \\n        bool basedOnPar;\\n        uint16 proposeWeightRatioOfGM; \\n        uint16 proposeHeadRatioOfMembers; \\n        uint16 proposeHeadRatioOfDirectorsInGM;\\n        uint16 proposeHeadRatioOfDirectorsInBoard;\\n        uint16 maxQtyOfMembers;\\n        uint16 quorumOfGM;  \\n        uint8 maxNumOfDirectors;\\n        uint16 tenureMonOfBoard;\\n        uint16 quorumOfBoardMeeting;\\n        uint48 establishedDate;    \\n        uint8 businessTermInYears;\\n        uint8 typeOfComp;\\n        uint16 minVoteRatioOnChain;\\n    }\\n\\n    function governanceRuleParser(bytes32 sn) public pure returns (GovernanceRule memory rule) {\\n        uint _sn = uint(sn);\\n\\n        rule = GovernanceRule({\\n            fundApprovalThreshold: uint32(_sn >> 224),\\n            basedOnPar: uint8(_sn >> 216) == 1,\\n            proposeWeightRatioOfGM: uint16(_sn >> 200),\\n            proposeHeadRatioOfMembers: uint16(_sn >> 184),\\n            proposeHeadRatioOfDirectorsInGM: uint16(_sn >> 168),\\n            proposeHeadRatioOfDirectorsInBoard: uint16(_sn >> 152),\\n            maxQtyOfMembers: uint16(_sn >> 136),\\n            quorumOfGM: uint16(_sn >> 120),\\n            maxNumOfDirectors: uint8(_sn >> 112),\\n            tenureMonOfBoard: uint16(_sn >> 96),\\n            quorumOfBoardMeeting: uint16(_sn >> 80),\\n            establishedDate: uint48(_sn >> 32),\\n            businessTermInYears: uint8(_sn >> 24),\\n            typeOfComp: uint8(_sn >> 16),\\n            minVoteRatioOnChain: uint16(_sn)\\n        });\\n    }\\n\\n    // ---- VotingRule ----\\n\\n    // bytes32 public constant SHA_INIT_VR = \\n    //     bytes32(uint(0x00080c080100001a0b0000010000000000000100000000000000000000000000));\\n\\n    struct VotingRule{\\n        uint16 seqOfRule;\\n        uint8 qtyOfSubRule;\\n        uint8 seqOfSubRule;\\n        uint8 authority;\\n        uint16 headRatio;\\n        uint16 amountRatio;\\n        bool onlyAttendance;\\n        bool impliedConsent;\\n        bool partyAsConsent;\\n        bool againstShallBuy;\\n        uint8 frExecDays;\\n        uint8 dtExecDays;\\n        uint8 dtConfirmDays;\\n        uint8 invExitDays;\\n        uint8 votePrepareDays;\\n        uint8 votingDays;\\n        uint8 execDaysForPutOpt;\\n        uint40[2] vetoers;\\n        uint16 para;\\n    }\\n\\n    function votingRuleParser(bytes32 sn) public pure returns (VotingRule memory rule) {\\n        uint _sn = uint(sn);\\n\\n        rule = VotingRule({\\n            seqOfRule: uint16(_sn >> 240),\\n            qtyOfSubRule: uint8(_sn >> 232),\\n            seqOfSubRule: uint8(_sn >> 224),\\n            authority: uint8(_sn >> 216),\\n            headRatio: uint16(_sn >> 200),\\n            amountRatio: uint16(_sn >> 184),\\n            onlyAttendance: uint8(_sn >> 176) == 1,\\n            impliedConsent: uint8(_sn >> 168) == 1,\\n            partyAsConsent: uint8(_sn >> 160) == 1,\\n            againstShallBuy: uint8(_sn >> 152) == 1,\\n            frExecDays: uint8(_sn >> 144),\\n            dtExecDays: uint8(_sn >> 136),\\n            dtConfirmDays: uint8(_sn >> 128),\\n            invExitDays: uint8(_sn >> 120),\\n            votePrepareDays: uint8(_sn >> 112),\\n            votingDays: uint8(_sn >> 104),\\n            execDaysForPutOpt: uint8(_sn >> 96),\\n            vetoers: [uint40(_sn >> 56), uint40(_sn >> 16)],\\n            para: uint16(_sn)            \\n        });\\n    }\\n\\n    // ---- BoardSeatsRule ----\\n\\n/*\\n    1: Chairman;\\n    2: ViceChairman;\\n    3: Director;\\n    ...\\n*/\\n\\n    struct PositionAllocateRule {\\n        uint16 seqOfRule;\\n        uint8 qtyOfSubRule;\\n        uint8 seqOfSubRule; \\n        bool removePos; \\n        uint16 seqOfPos;\\n        uint16 titleOfPos;  \\n        uint40 nominator;   \\n        uint16 titleOfNominator;    \\n        uint16 seqOfVR; \\n        uint48 endDate;\\n        uint16 para;    \\n        uint16 argu;\\n        uint32 data;\\n    }\\n\\n    function positionAllocateRuleParser(bytes32 sn) public pure returns(PositionAllocateRule memory rule) {\\n        uint _sn = uint(sn);\\n\\n        rule = PositionAllocateRule({\\n            seqOfRule: uint16(_sn >> 240), \\n            qtyOfSubRule: uint8(_sn >> 232),\\n            seqOfSubRule: uint8(_sn >> 224), \\n            removePos: uint8(_sn >> 216) == 1,\\n            seqOfPos: uint16(_sn >> 200),\\n            titleOfPos: uint16(_sn >> 184),  \\n            nominator: uint40(_sn >> 144),   \\n            titleOfNominator: uint16(_sn >> 128),    \\n            seqOfVR: uint16(_sn >> 112), \\n            endDate: uint48(_sn >> 64),\\n            para: uint16(_sn >> 48),    \\n            argu: uint16(_sn >> 32),\\n            data: uint32(_sn)\\n        });\\n\\n    }\\n\\n    // ---- FirstRefusal Rule ----\\n\\n    struct FirstRefusalRule {\\n        uint16 seqOfRule;\\n        uint8 qtyOfSubRule;\\n        uint8 seqOfSubRule;\\n        uint8 typeOfDeal;\\n        bool membersEqual;\\n        bool proRata;\\n        bool basedOnPar;\\n        uint40[4] rightholders;\\n        uint16 para;\\n        uint16 argu;        \\n    }\\n\\n    function firstRefusalRuleParser(bytes32 sn) public pure returns(FirstRefusalRule memory rule) {\\n        uint _sn = uint(sn);\\n\\n        rule = FirstRefusalRule({\\n            seqOfRule: uint16(_sn >> 240),\\n            qtyOfSubRule: uint8(_sn >> 232),\\n            seqOfSubRule: uint8(_sn >> 224),\\n            typeOfDeal: uint8(_sn >> 216),\\n            membersEqual: uint8(_sn >> 208) == 1,\\n            proRata: uint8(_sn >> 200) == 1,\\n            basedOnPar: uint8(_sn >> 192) == 1,\\n            rightholders: [uint40(_sn >> 152), uint40(_sn >> 112), uint40(_sn >> 72), uint40(_sn >> 32)],\\n            para: uint16(_sn >> 16),\\n            argu: uint16(_sn)                    \\n        });\\n    }\\n\\n    // ---- GroupUpdateOrder ----\\n\\n    struct GroupUpdateOrder {\\n        uint16 seqOfRule;\\n        uint8 qtyOfSubRule;\\n        uint8 seqOfSubRule;\\n        bool addMember;\\n        uint40 groupRep;\\n        uint40[4] members;\\n        uint16 para;        \\n    }\\n\\n    function groupUpdateOrderParser(bytes32 sn) public pure returns(GroupUpdateOrder memory order) {\\n        uint _sn = uint(sn);\\n        \\n        order = GroupUpdateOrder({\\n            seqOfRule: uint16(_sn >> 240),\\n            qtyOfSubRule: uint8(_sn >> 232),\\n            seqOfSubRule: uint8(_sn >> 224),\\n            addMember: uint8(_sn >> 216) == 1,\\n            groupRep: uint40(_sn >> 176),\\n            members: [\\n                uint40(_sn >> 136),\\n                uint40(_sn >> 96),\\n                uint40(_sn >> 56),\\n                uint40(_sn >> 16)\\n            ],\\n            para: uint16(_sn)\\n        });\\n    }    \\n\\n    // ---- ListingRule ----\\n\\n    struct ListingRule {\\n        uint16 seqOfRule;\\n        uint16 titleOfIssuer;\\n        uint16 classOfShare;\\n        uint64 maxTotalPar;\\n        uint16 titleOfVerifier;\\n        uint16 maxQtyOfInvestors;\\n        uint32 ceilingPrice;\\n        uint32 floorPrice;\\n        uint16 lockupDays;\\n        uint16 offPrice;\\n        uint16 votingWeight;\\n    }\\n\\n    function listingRuleParser(bytes32 sn) public pure returns(ListingRule memory rule) {\\n        uint _sn = uint(sn);\\n        \\n        rule = ListingRule({\\n            seqOfRule: uint16(_sn >> 240),\\n            titleOfIssuer: uint16(_sn >> 224),\\n            classOfShare: uint16(_sn >> 208),\\n            maxTotalPar: uint64(_sn >> 144),\\n            titleOfVerifier: uint16(_sn >> 128), \\n            maxQtyOfInvestors: uint16(_sn >> 112),\\n            ceilingPrice: uint32(_sn >> 80),\\n            floorPrice: uint32(_sn >> 48),\\n            lockupDays: uint16(_sn >> 32),\\n            offPrice: uint16(_sn >> 16),\\n            votingWeight: uint16(_sn)\\n        });\\n    }    \\n\\n    // ======== LinkRule ========\\n\\n    struct LinkRule {\\n        uint48 triggerDate;\\n        uint16 effectiveDays;\\n        uint8 triggerType;  \\n        uint16 shareRatioThreshold;\\n        uint32 rate;\\n        bool proRata;\\n        uint16 seq;\\n        uint16 para;\\n        uint16 argu;\\n        uint16 ref;\\n        uint64 data;\\n    }\\n\\n    function linkRuleParser(bytes32 sn) public pure returns (LinkRule memory rule) {\\n        uint _sn = uint(sn);\\n\\n        rule = LinkRule({\\n            triggerDate: uint48(_sn >> 208),\\n            effectiveDays: uint16(_sn >> 192),\\n            triggerType: uint8(_sn >> 184),  \\n            shareRatioThreshold: uint16(_sn >> 168),\\n            rate: uint32(_sn >> 136),\\n            proRata: uint8(_sn >> 128) == 1,\\n            seq: uint16(_sn >> 112),\\n            para: uint16(_sn >> 96),\\n            argu: uint16(_sn >> 80),\\n            ref: uint16(_sn >> 64),\\n            data: uint64(_sn)\\n        });\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/lib/SharesRepo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"./EnumerableSet.sol\\\";\\n\\nlibrary SharesRepo {\\n    using EnumerableSet for EnumerableSet.UintSet;\\n\\n    struct Head {\\n        uint16 class; // \u80a1\u7968\u7c7b\u522b/\u8f6e\u6b21\u7f16\u53f7\\n        uint32 seqOfShare; // \u80a1\u7968\u5e8f\u5217\u53f7\\n        uint32 preSeq; // \u524d\u5e8f\u80a1\u7968\u5e8f\u5217\u53f7\uff08\u80a1\u8f6c\u65f6\u539f\u6807\u7684\u80a1\u5e8f\u5217\u53f7\uff09\\n        uint48 issueDate; // \u80a1\u7968\u7b7e\u53d1\u65e5\u671f\uff08\u79d2\u65f6\u95f4\u6233\uff09\\n        uint40 shareholder; // \u80a1\u4e1c\u4ee3\u7801\\n        uint32 priceOfPaid; // \u53d1\u884c\u4ef7\u683c\uff08\u5b9e\u7f34\u51fa\u8d44\u4ef7\uff09\\n        uint32 priceOfPar; // \u53d1\u884c\u4ef7\u683c\uff08\u8ba4\u7f34\u51fa\u8d44\u4ef7\uff09\\n        uint16 votingWeight; // \u8868\u51b3\u6743\u91cd\uff08\u767e\u5206\u70b9\uff09\\n        uint8 argu;\\n    }\\n\\n    struct Body {\\n        uint48 payInDeadline; // \u51fa\u8d44\u671f\u9650\uff08\u79d2\u65f6\u95f4\u6233\uff09\\n        uint64 paid; // \u5b9e\u7f34\u51fa\u8d44\\n        uint64 par; // \u8ba4\u7f34\u51fa\u8d44\uff08\u6ce8\u518c\u8d44\u672c\u9762\u503c\uff09\\n        uint64 cleanPaid; // \u6e05\u6d01\u5b9e\u7f34\u51fa\u8d44\uff08\u6263\u9664\u51fa\u8d28\u3001\u8fdc\u671f\u3001\u9500\u552e\u8981\u7ea6\u91d1\u989d\uff09\\n        uint8 state;\\n        uint8 para;\\n    }\\n\\n    //Share \u80a1\u7968\\n    struct Share {\\n        Head head; //\u51fa\u8d44\u8bc1\u660e\u4e66\u7f16\u53f7\uff08\u80a1\u7968\u7f16\u53f7\uff09\\n        Body body;\\n    }\\n\\n    struct Class{\\n        Share info;\\n        EnumerableSet.UintSet seqList;\\n    }\\n\\n    struct Repo {\\n        // seqOfClass => Class\\n        mapping(uint256 => Class) classes;\\n        // seqOfShare => Share\\n        mapping(uint => Share) shares;\\n    }\\n\\n    //####################\\n    //##    Modifier    ##\\n    //####################\\n\\n    modifier shareExist(\\n        Repo storage repo,\\n        uint seqOfShare\\n    ) {\\n        require(isShare(repo, seqOfShare),\\n            \\\"SR.shareExist: not\\\");\\n        _;\\n    }\\n\\n    //#################\\n    //##    Write    ##\\n    //#################\\n\\n    function snParser(bytes32 sn) public pure returns(Head memory head)\\n    {\\n        uint _sn = uint(sn);\\n        \\n        head = Head({\\n            class: uint16(_sn >> 240),\\n            seqOfShare: uint32(_sn >> 208),\\n            preSeq: uint32(_sn >> 176),\\n            issueDate: uint48(_sn >> 128),\\n            shareholder: uint40(_sn >> 88),\\n            priceOfPaid: uint32(_sn >> 56),\\n            priceOfPar: uint32(_sn >> 24),\\n            votingWeight: uint16(_sn >> 8),\\n            argu: uint8(_sn)\\n        });\\n    }\\n\\n    function codifyHead(Head memory head) public pure returns (bytes32 sn)\\n    {\\n        bytes memory _sn = \\n            abi.encodePacked(\\n                head.class, \\n                head.seqOfShare, \\n                head.preSeq, \\n                head.issueDate, \\n                head.shareholder, \\n                head.priceOfPaid, \\n                head.priceOfPar, \\n                head.votingWeight, \\n                head.argu\\n            );\\n\\n        assembly {\\n            sn := mload(add(_sn, 0x20))\\n        }\\n\\n    }\\n\\n    // ==== issue/regist share ====\\n\\n    function createShare(\\n        bytes32 sharenumber, \\n        uint payInDeadline, \\n        uint paid, \\n        uint par\\n    ) public pure returns (Share memory share) {\\n\\n        share.head = snParser(sharenumber);\\n\\n        share.body = Body({\\n            payInDeadline: uint48(payInDeadline),\\n            paid: uint64(paid),\\n            par: uint64(par),\\n            cleanPaid: uint64(paid),\\n            state: 0,\\n            para: 0\\n        });\\n    }\\n\\n    function addShare(Repo storage repo, Share memory share)\\n        public returns(Share memory newShare) \\n    {\\n        newShare = regShare(repo, share);\\n\\n        Share storage info = repo.classes[newShare.head.class].info;\\n\\n        if (info.head.issueDate == 0) \\n            repo.classes[newShare.head.class].info.head = \\n                newShare.head;\\n    }\\n\\n    function regShare(Repo storage repo, Share memory share)\\n        public returns(Share memory)\\n    {\\n        require(share.head.class > 0, \\\"SR.regShare: zero class\\\");\\n        require(share.body.par > 0, \\\"SR.regShare: zero par\\\");\\n        require(share.body.par >= share.body.paid, \\\"SR.regShare: paid overflow\\\");\\n        require(share.head.issueDate <= block.timestamp, \\\"SR.regShare: future issueDate\\\");\\n        require(share.head.issueDate <= share.body.payInDeadline, \\\"SR.regShare: issueDate later than payInDeadline\\\");\\n        require(share.head.shareholder > 0, \\\"SR.regShare: zero shareholder\\\");\\n        require(share.head.votingWeight > 0, \\\"SR.regShare: zero votingWeight\\\");\\n\\n        if (share.head.class > counterOfClasses(repo))\\n            share.head.class = _increaseCounterOfClasses(repo);\\n\\n        Class storage class = repo.classes[share.head.class];\\n\\n        if (!class.seqList.contains(share.head.seqOfShare)) {\\n            share.head.seqOfShare = _increaseCounterOfShares(repo);\\n                        \\n            if (share.head.issueDate == 0)\\n                share.head.issueDate = uint48(block.timestamp);\\n\\n            class.seqList.add(share.head.seqOfShare);\\n            repo.classes[0].seqList.add(share.head.seqOfShare);\\n        }\\n\\n        repo.shares[share.head.seqOfShare] = share;\\n\\n        return share;\\n    }\\n\\n    // ==== counters ====\\n\\n    function _increaseCounterOfShares(\\n        Repo storage repo\\n    ) private returns(uint32) {\\n\\n        Head storage h = repo.shares[0].head;\\n\\n        do {\\n            unchecked {\\n                h.seqOfShare++;                \\n            }\\n        } while (isShare(repo, h.seqOfShare) || \\n            h.seqOfShare == 0);\\n\\n        return h.seqOfShare;\\n    }\\n\\n    function _increaseCounterOfClasses(Repo storage repo) \\n        private returns(uint16)\\n    {\\n        repo.shares[0].head.class++;\\n        return repo.shares[0].head.class;\\n    }\\n\\n    // ==== amountChange ====\\n\\n    function payInCapital(\\n        Repo storage repo,\\n        uint seqOfShare,\\n        uint amt\\n    ) public shareExist(repo, seqOfShare) {\\n\\n        Share storage share = repo.shares[seqOfShare];\\n\\n        uint64 deltaPaid = uint64(amt);\\n\\n        require(deltaPaid > 0, \\\"SR.payInCap: zero amt\\\");\\n\\n        require(block.timestamp <= share.body.payInDeadline, \\n            \\\"SR.payInCap: missed deadline\\\");\\n\\n        require(share.body.paid + deltaPaid <= share.body.par, \\n            \\\"SR.payInCap: amt overflow\\\");\\n\\n        share.body.paid += deltaPaid;\\n        share.body.cleanPaid += deltaPaid;\\n\\n    }\\n\\n    function subAmtFromShare(\\n        Repo storage repo,\\n        uint seqOfShare,\\n        uint paid, \\n        uint par\\n    ) public shareExist(repo, seqOfShare) {\\n\\n        Share storage share = repo.shares[seqOfShare];\\n        Class storage class = repo.classes[share.head.class];\\n\\n        uint64 deltaPaid = uint64(paid);\\n        uint64 deltaPar = uint64(par);\\n\\n        require(deltaPar > 0, \\\"SR.subAmt: zero par\\\");\\n        require(share.body.cleanPaid >= deltaPaid, \\\"SR.subAmt: insufficient cleanPaid\\\");\\n\\n        if (deltaPar == share.body.par) {            \\n            class.seqList.remove(seqOfShare);\\n            repo.classes[0].seqList.remove(seqOfShare);\\n            delete repo.shares[seqOfShare];\\n        } else {\\n            share.body.paid -= deltaPaid;\\n            share.body.par -= deltaPar;\\n            share.body.cleanPaid -= deltaPaid;\\n\\n            require(share.body.par >= share.body.paid,\\n                \\\"SR.subAmt: result paid overflow\\\");\\n        }\\n    }\\n\\n    function increaseCleanPaid(\\n        Repo storage repo,\\n        bool isIncrease,\\n        uint seqOfShare,\\n        uint paid\\n    ) public shareExist(repo, seqOfShare) {\\n\\n        Share storage share = repo.shares[seqOfShare];\\n\\n        uint64 deltaClean = uint64(paid);\\n\\n        require(deltaClean > 0, \\\"SR.incrClean: zero amt\\\");\\n\\n        if (isIncrease && share.body.cleanPaid + deltaClean <= share.body.paid) \\n            share.body.cleanPaid += deltaClean;\\n        else if(!isIncrease && share.body.cleanPaid >= deltaClean)\\n            share.body.cleanPaid -= deltaClean;\\n        else revert(\\\"SR.incrClean: clean overflow\\\");\\n    }\\n\\n    // ---- EquityOfClass ----\\n\\n    function increaseEquityOfClass(\\n        Repo storage repo,\\n        bool isIncrease,\\n        uint classOfShare,\\n        uint deltaPaid,\\n        uint deltaPar,\\n        uint deltaCleanPaid\\n    ) public {\\n\\n        Body storage equity = repo.classes[classOfShare].info.body;\\n\\n        if (isIncrease) {\\n            equity.paid += uint64(deltaPaid);\\n            equity.par += uint64(deltaPar);\\n            equity.cleanPaid += uint64(deltaCleanPaid);\\n        } else {\\n            equity.paid -= uint64(deltaPaid);\\n            equity.par -= uint64(deltaPar);\\n            equity.cleanPaid -= uint64(deltaCleanPaid);            \\n        }\\n    }\\n\\n    function updatePriceOfPaid(\\n        Repo storage repo,\\n        uint seqOfShare,\\n        uint newPrice\\n    ) public shareExist(repo, seqOfShare) {\\n        Share storage share = repo.shares[seqOfShare];\\n        share.head.priceOfPaid = uint32(newPrice);\\n    }\\n\\n    function updatePayInDeadline(\\n        Repo storage repo,\\n        uint seqOfShare,\\n        uint deadline\\n    ) public shareExist(repo, seqOfShare) {\\n\\n        Share storage share = repo.shares[seqOfShare];\\n\\n        uint48 newLine = uint48(deadline);\\n\\n        require (block.timestamp < newLine, \\n            \\\"SR.updatePayInDeadline: not future\\\");\\n\\n        share.body.payInDeadline = newLine;\\n    }\\n\\n    //####################\\n    //##    Read I/O    ##\\n    //####################\\n\\n    // ---- Counter ----\\n\\n    function counterOfShares(\\n        Repo storage repo\\n    ) public view returns(uint32) {\\n        return repo.shares[0].head.seqOfShare;\\n    }\\n\\n    function counterOfClasses(\\n        Repo storage repo\\n    ) public view returns(uint16) {\\n        return repo.shares[0].head.class;\\n    }\\n\\n    // ---- Share ----\\n\\n    function isShare(\\n        Repo storage repo, \\n        uint seqOfShare\\n    ) public view returns(bool) {\\n        return repo.shares[seqOfShare].head.issueDate > 0;\\n    }\\n\\n    function getShare(\\n        Repo storage repo, \\n        uint seqOfShare\\n    ) public view shareExist(repo, seqOfShare) returns (\\n        Share memory\\n    ) {\\n        return repo.shares[seqOfShare];\\n    }\\n\\n    function getQtyOfShares(\\n        Repo storage repo\\n    ) public view returns(uint) {\\n        return repo.classes[0].seqList.length();\\n    }\\n\\n    function getSeqListOfShares(\\n        Repo storage repo\\n    ) public view returns(uint[] memory) {\\n        return repo.classes[0].seqList.values();\\n    }\\n\\n    function getSharesList(\\n        Repo storage repo\\n    ) public view returns(Share[] memory) {\\n        uint[] memory seqList = repo.classes[0].seqList.values();\\n        return _getShares(repo, seqList);\\n    }\\n\\n    // ---- Class ----    \\n\\n    function getQtyOfSharesInClass(\\n        Repo storage repo, \\n        uint classOfShare\\n    ) public view returns (uint) {\\n        return repo.classes[classOfShare].seqList.length();\\n    }\\n\\n    function getSeqListOfClass(\\n        Repo storage repo, \\n        uint classOfShare\\n    ) public view returns (uint[] memory) {\\n        return repo.classes[classOfShare].seqList.values();\\n    }\\n\\n    function getInfoOfClass(\\n        Repo storage repo,\\n        uint classOfShare\\n    ) public view returns (Share memory) {\\n        return repo.classes[classOfShare].info;\\n    }\\n\\n    function getSharesOfClass(\\n        Repo storage repo, \\n        uint classOfShare\\n    ) public view returns (Share[] memory) {\\n        uint[] memory seqList = \\n            repo.classes[classOfShare].seqList.values();\\n        return _getShares(repo, seqList);\\n    }\\n\\n    function _getShares(\\n        Repo storage repo,\\n        uint[] memory seqList\\n    ) private view returns(Share[] memory list) {\\n\\n        uint len = seqList.length;\\n        list = new Share[](len);\\n\\n        while(len > 0) {\\n            list[len - 1] = repo.shares[seqList[len - 1]];\\n            len--;\\n        }\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/lib/SigsRepo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"./EnumerableSet.sol\\\";\\n\\nlibrary SigsRepo {\\n    using EnumerableSet for EnumerableSet.UintSet;\\n\\n    struct Signature {\\n        uint40 signer;\\n        uint48 sigDate;\\n        uint64 blocknumber;\\n        bool flag;\\n        uint16 para;\\n        uint16 arg;\\n        uint16 seq;\\n        uint16 attr;\\n        uint32 data;\\n    }\\n\\n    struct Blank{\\n        EnumerableSet.UintSet seqOfDeals;\\n        Signature sig;\\n        bytes32 sigHash;\\n    }\\n\\n    // blanks[0].sig {\\n    //     sigDate: circulateDate;\\n    //     flag: established;\\n    //     para: counterOfBlanks;\\n    //     arg: counterOfSigs;\\n    //     seq: signingDays;\\n    //     attr: closingDays;\\n    // }\\n\\n    struct Page {\\n        // party => Blank\\n        mapping(uint256 => Blank) blanks;\\n        EnumerableSet.UintSet buyers;\\n        EnumerableSet.UintSet sellers;\\n    }\\n\\n    //###################\\n    //##    \u8bbe\u7f6e\u63a5\u53e3    ##\\n    //###################\\n\\n    function circulateDoc(\\n        Page storage p\\n    ) public {\\n        p.blanks[0].sig.sigDate = uint48(block.timestamp);\\n    }\\n\\n    function setTiming(\\n        Page storage p,\\n        uint signingDays,\\n        uint closingDays\\n    ) public {\\n        // require(!circulated(p), \\\"SR.SD: doc already circulated\\\");\\n        p.blanks[0].sig.seq = uint16(signingDays);\\n        p.blanks[0].sig.attr = uint16(closingDays);\\n    }\\n\\n    function addBlank(\\n        Page storage p,\\n        bool beBuyer,\\n        uint256 seq,\\n        uint256 acct\\n    ) public {\\n        require (seq > 0, \\\"SR.AB: zero seq\\\");\\n        require (acct > 0, \\\"SR.AB: zero acct\\\");\\n\\n        \\n        if (beBuyer) {\\n            require(!p.sellers.contains(acct), \\\"SR.AB: seller intends to buy\\\");\\n            p.buyers.add(acct);\\n        } else {\\n            require(!p.buyers.contains(acct), \\\"SR.AB: buyer intends to sell\\\");\\n            p.sellers.add(acct);\\n        }\\n\\n        if (p.blanks[uint40(acct)].seqOfDeals.add(uint16(seq)))\\n            _increaseCounterOfBlanks(p);\\n    }\\n\\n    function removeBlank(\\n        Page storage p,\\n        uint256 seq,\\n        uint256 acct\\n    ) public {\\n        if (p.buyers.contains(acct) || p.sellers.contains(acct)) {\\n            if (p.blanks[acct].seqOfDeals.remove(seq))\\n                _decreaseCounterOfBlanks(p);\\n\\n            if (p.blanks[acct].seqOfDeals.length() == 0) {\\n                delete p.blanks[acct]; \\n                p.buyers.remove(acct) || p.sellers.remove(acct);\\n            }\\n        }\\n    }\\n\\n    function signDoc(Page storage p, uint256 acct, bytes32 sigHash) \\n        public \\n    {\\n        require(block.timestamp < getSigDeadline(p) ||\\n            getSigningDays(p) == 0,\\n            \\\"SR.SD: missed sigDeadline\\\");\\n\\n        require(!established(p),\\n            \\\"SR.SD: Doc already established\\\");\\n\\n        if ((p.buyers.contains(acct) || p.sellers.contains(acct)) &&\\n            p.blanks[acct].sig.sigDate == 0) {\\n\\n            Signature storage sig = p.blanks[acct].sig;\\n\\n            sig.signer = uint40(acct);\\n            sig.sigDate = uint48(block.timestamp);\\n            sig.blocknumber = uint64(block.number);\\n\\n            p.blanks[acct].sigHash = sigHash;\\n\\n            _increaseCounterOfSigs(p, p.blanks[acct].seqOfDeals.length());\\n        }\\n    }\\n\\n    function regSig(Page storage p, uint256 acct, uint sigDate, bytes32 sigHash)\\n        public returns (bool flag)\\n    {\\n        require(block.timestamp < getSigDeadline(p),\\n            \\\"SR.RS: missed sigDeadline\\\");\\n\\n        require(!established(p),\\n            \\\"SR.regSig: Doc already established\\\");\\n\\n        if (p.buyers.contains(acct) || p.sellers.contains(acct)) {\\n\\n            Signature storage sig = p.blanks[acct].sig;\\n\\n            sig.signer = uint40(acct);\\n            sig.sigDate = uint48(sigDate);\\n            sig.blocknumber = uint64(block.number);\\n\\n            p.blanks[acct].sigHash = sigHash;\\n\\n            _increaseCounterOfSigs(p, 1);\\n\\n            flag = true;\\n        }\\n\\n    }\\n\\n    function _increaseCounterOfBlanks(Page storage p) private {\\n        p.blanks[0].sig.para++;\\n    }\\n\\n    function _decreaseCounterOfBlanks(Page storage p) private {\\n        p.blanks[0].sig.para--;\\n    }\\n\\n    function _increaseCounterOfSigs(Page storage p, uint qtyOfDeals) private {\\n        p.blanks[0].sig.arg += uint16(qtyOfDeals);\\n    }\\n\\n    //####################\\n    //##    \u67e5\u8be2\u63a5\u53e3     ##\\n    //####################\\n\\n    function circulated(Page storage p) public view returns (bool)\\n    {\\n        return p.blanks[0].sig.sigDate > 0;\\n    }\\n\\n    function established(Page storage p) public view returns (bool)\\n    {\\n        // return p.blanks[0].sig.flag;\\n        return counterOfBlanks(p) > 0 \\n            && counterOfBlanks(p) == counterOfSigs(p);\\n    }\\n\\n    function counterOfBlanks(Page storage p) public view returns(uint16) {\\n        return p.blanks[0].sig.para;\\n    }\\n\\n    function counterOfSigs(Page storage p) public view returns(uint16) {\\n        return p.blanks[0].sig.arg;\\n    }\\n\\n    function getCirculateDate(Page storage p) public view returns(uint48) {\\n        return p.blanks[0].sig.sigDate;\\n    }\\n\\n    function getSigningDays(Page storage p) public view returns(uint16) {\\n        return p.blanks[0].sig.seq;\\n    }\\n\\n    function getClosingDays(Page storage p) public view returns(uint16) {\\n        return p.blanks[0].sig.attr;\\n    }\\n\\n    function getSigDeadline(Page storage p) public view returns(uint48) {\\n        return p.blanks[0].sig.sigDate + uint48(p.blanks[0].sig.seq) * 86400; \\n    }\\n\\n    function getClosingDeadline(Page storage p) public view returns(uint48) {\\n        return p.blanks[0].sig.sigDate + uint48(p.blanks[0].sig.attr) * 86400; \\n    }\\n\\n    function isSigner(Page storage p, uint256 acct) \\n        public view returns (bool) \\n    {\\n        return p.blanks[acct].sig.signer > 0;\\n    }\\n\\n    function sigOfParty(Page storage p, uint256 acct) public view\\n        returns (\\n            uint256[] memory seqOfDeals, \\n            Signature memory sig,\\n            bytes32 sigHash\\n        ) \\n    {\\n        seqOfDeals = p.blanks[acct].seqOfDeals.values();\\n        sig = p.blanks[acct].sig;\\n        sigHash = p.blanks[acct].sigHash;\\n    }\\n\\n    function sigsOfPage(Page storage p) public view\\n        returns (\\n            Signature[] memory sigsOfBuyer, \\n            Signature[]memory sigsOfSeller\\n        )\\n    {\\n        sigsOfBuyer = sigsOfSide(p, p.buyers);\\n        sigsOfSeller = sigsOfSide(p, p.sellers);\\n    }\\n\\n    function sigsOfSide(Page storage p, EnumerableSet.UintSet storage partiesOfSide) \\n        public view\\n        returns (Signature[] memory)\\n    {\\n        uint256[] memory parties = partiesOfSide.values();\\n        uint256 len = parties.length;\\n\\n        Signature[] memory sigs = new Signature[](len);\\n\\n        while (len > 0) {\\n            sigs[len-1] = p.blanks[parties[len-1]].sig;\\n            len--;\\n        }\\n\\n        return sigs;\\n    }\\n\\n\\n}\\n\"\r\n    },\r\n    \"contracts/lib/SwapsRepo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nlibrary SwapsRepo {\\n\\n    enum StateOfSwap {\\n        Pending,    \\n        Issued,\\n        Closed,\\n        Terminated\\n    }\\n\\n    struct Swap {\\n        uint16 seqOfSwap;\\n        uint32 seqOfPledge;\\n        uint64 paidOfPledge;\\n        uint32 seqOfTarget;\\n        uint64 paidOfTarget;\\n        uint32 priceOfDeal;\\n        bool isPutOpt;\\n        uint8 state;\\n    }\\n\\n    struct Repo {\\n        // seqOfSwap => Swap\\n        mapping(uint256 => Swap) swaps;\\n    }\\n\\n    // ###############\\n    // ##  Modifier ##\\n    // ###############\\n\\n    modifier swapExist(Repo storage repo, uint seqOfSwap) {\\n        require (isSwap(repo, seqOfSwap), \\\"SR.swapExist: not\\\");\\n        _;\\n    }\\n\\n    // ###############\\n    // ## Write I/O ##\\n    // ###############\\n\\n    // ==== cofify / parser ====\\n\\n    function codifySwap(Swap memory swap) public pure returns (bytes32 sn) {\\n        bytes memory _sn = abi.encodePacked(\\n                            swap.seqOfSwap,\\n                            swap.seqOfPledge,\\n                            swap.paidOfPledge,\\n                            swap.seqOfTarget,\\n                            swap.paidOfTarget,\\n                            swap.priceOfDeal,\\n                            swap.isPutOpt,\\n                            swap.state);\\n        assembly {\\n            sn := mload(add(_sn, 0x20))\\n        }\\n    }\\n\\n    function regSwap(\\n        Repo storage repo,\\n        Swap memory swap\\n    ) public returns(Swap memory) {\\n\\n        require(swap.seqOfTarget * swap.paidOfTarget * swap.seqOfPledge > 0,\\n            \\\"SWR.regSwap: zero para\\\");\\n\\n        swap.seqOfSwap = _increaseCounter(repo);\\n\\n        repo.swaps[swap.seqOfSwap] = swap;\\n        repo.swaps[0].paidOfTarget += swap.paidOfTarget;\\n\\n        return swap;\\n    }\\n\\n    function payOffSwap(\\n        Repo storage repo,\\n        uint seqOfSwap,\\n        uint msgValue,\\n        uint centPrice\\n    ) public returns (Swap memory ) {\\n\\n        Swap storage swap = repo.swaps[seqOfSwap];\\n\\n        require(swap.state == uint8(StateOfSwap.Issued), \\n            \\\"SWR.payOffSwap: wrong state\\\");\\n\\n        require (uint(swap.paidOfTarget) * uint(swap.priceOfDeal) * centPrice / 100 <= msgValue, \\\"SWR.payOffSwap: insufficient amt\\\");\\n\\n        swap.state = uint8(StateOfSwap.Closed);\\n\\n        return swap;\\n    }\\n\\n    function terminateSwap(\\n        Repo storage repo,\\n        uint seqOfSwap\\n    ) public returns (Swap memory){\\n\\n        Swap storage swap = repo.swaps[seqOfSwap];\\n\\n        require(swap.state == uint8(StateOfSwap.Issued), \\n            \\\"SWR.terminateSwap: wrong state\\\");\\n\\n        swap.state = uint8(StateOfSwap.Terminated);\\n\\n        return swap;\\n    }\\n\\n    // ==== Counter ====\\n\\n    function _increaseCounter(Repo storage repo) private returns(uint16) {\\n        repo.swaps[0].seqOfSwap++;\\n        return repo.swaps[0].seqOfSwap;\\n    } \\n\\n    // ################\\n    // ##  \u67e5\u8be2\u63a5\u53e3   ##\\n    // ################\\n\\n    function counterOfSwaps(Repo storage repo)\\n        public view returns (uint16)\\n    {\\n        return repo.swaps[0].seqOfSwap;\\n    }\\n\\n    function sumPaidOfTarget(Repo storage repo)\\n        public view returns (uint64)\\n    {\\n        return repo.swaps[0].paidOfTarget;\\n    }\\n\\n    function isSwap(Repo storage repo, uint256 seqOfSwap)\\n        public view returns (bool)\\n    {\\n        return seqOfSwap <= counterOfSwaps(repo);\\n    }\\n\\n    function getSwap(Repo storage repo, uint256 seqOfSwap)\\n        public view swapExist(repo, seqOfSwap) returns (Swap memory)\\n    {\\n        return repo.swaps[seqOfSwap];\\n    }\\n\\n    function checkValueOfSwap(\\n        Repo storage repo,\\n        uint seqOfSwap,\\n        uint centPrice\\n    ) public view returns (uint) {\\n        Swap memory swap = getSwap(repo, seqOfSwap);\\n        return uint(swap.paidOfTarget) * uint(swap.priceOfDeal) * centPrice / 100;\\n    }\\n\\n    function getAllSwaps(Repo storage repo)\\n        public view returns (Swap[] memory )\\n    {\\n        uint256 len = counterOfSwaps(repo);\\n        Swap[] memory swaps = new Swap[](len);\\n\\n        while (len > 0) {\\n            swaps[len-1] = repo.swaps[len];\\n            len--;\\n        }\\n        return swaps;\\n    }\\n\\n    function allSwapsClosed(Repo storage repo)\\n        public view returns (bool)\\n    {\\n        uint256 len = counterOfSwaps(repo);\\n        while (len > 0) {\\n            if (repo.swaps[len].state < uint8(StateOfSwap.Closed))\\n                return false;\\n            len--;\\n        }\\n\\n        return true;        \\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/TopChain.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"../comps/books/roa/IInvestmentAgreement.sol\\\";\\n\\nimport \\\"./DealsRepo.sol\\\";\\n\\nlibrary TopChain {\\n\\n    enum CatOfNode {\\n        IndepMemberInQueue, // 0\\n        GroupRepInQueue,    // 1\\n        GroupMember,        // 2\\n        IndepMemberOnChain, // 3 \\n        GroupRepOnChain     // 4\\n    }\\n\\n    struct Node {\\n        uint40 prev;\\n        uint40 next;\\n        uint40 ptr;\\n        uint64 amt;\\n        uint64 sum;\\n        uint8 cat;\\n    }\\n\\n    struct Para {\\n        uint40 tail;\\n        uint40 head;\\n        uint32 maxQtyOfMembers;\\n        uint16 minVoteRatioOnChain;\\n        uint32 qtyOfSticks;\\n        uint32 qtyOfBranches;\\n        uint32 qtyOfMembers;\\n        uint16 para;\\n        uint16 argu;\\n    }\\n\\n    struct Chain {\\n        // usrNo => Node\\n        mapping(uint256 => Node) nodes;\\n        Para para;\\n    }\\n\\n    /* Node[0] {\\n        prev: tail;\\n        next: head;\\n        ptr: pending;\\n        amt: pending;\\n        sum: totalVotes;\\n        cat: basedOnPar;\\n    } */\\n\\n    //#################\\n    //##   Modifier  ##\\n    //#################\\n\\n    modifier memberExist(Chain storage chain, uint256 acct) {\\n        require(isMember(chain, acct), \\\"TC.memberExist: acct not member\\\");\\n        _;\\n    }\\n\\n    //#################\\n    //##  Write I/O  ##\\n    //#################\\n    \\n    // ==== Options ====\\n\\n    function setMaxQtyOfMembers(Chain storage chain, uint max) public {\\n        chain.para.maxQtyOfMembers = uint32(max);\\n    }\\n\\n    function setMinVoteRatioOnChain(Chain storage chain, uint min) public {\\n        require(min < 5000, \\\"minVoteRatioOnChain: overflow\\\");\\n        chain.para.minVoteRatioOnChain = uint16(min);\\n    }\\n\\n    function setVoteBase(\\n        Chain storage chain, \\n        bool _basedOnPar\\n    ) public {\\n        chain.nodes[0].cat = _basedOnPar ? 1 : 0;\\n    }\\n\\n    // ==== Node ====\\n\\n    function addNode(Chain storage chain, uint acct) public {\\n\\n        require(acct > 0, \\\"TC.addNode: zero acct\\\");\\n\\n        Node storage n = chain.nodes[acct];\\n\\n        if (n.ptr == 0) {\\n            require( maxQtyOfMembers(chain) == 0 ||\\n                qtyOfMembers(chain) < maxQtyOfMembers(chain),\\n                \\\"TC.addNode: no vacance\\\"\\n            );\\n\\n            n.ptr = uint40(acct);\\n\\n            _appendToQueue(chain, n, n.ptr);\\n            _increaseQtyOfMembers(chain);\\n        }\\n    }\\n\\n    function delNode(Chain storage chain, uint acct) public {\\n        _carveOut(chain, acct);\\n        delete chain.nodes[acct];\\n        _decreaseQtyOfMembers(chain);        \\n    }\\n\\n    // ==== ChangeAmt ====\\n\\n    function increaseTotalVotes(\\n        Chain storage chain,\\n        uint deltaAmt, \\n        bool isIncrease\\n    ) public {\\n        uint40 amt = uint40(deltaAmt);\\n        if (isIncrease) _increaseTotalVotes(chain, amt);\\n        else _decreaseTotalVotes(chain, amt);\\n    }\\n\\n    function increaseAmt(\\n        Chain storage chain, \\n        uint256 acct, \\n        uint deltaAmt, \\n        bool isIncrease\\n    ) public memberExist(chain, acct) {\\n\\n        uint64 amt = uint64(deltaAmt);\\n\\n        Node storage n = chain.nodes[acct];\\n\\n        if (isIncrease) {\\n            n.amt += amt;\\n            n.sum += amt;\\n        } else {\\n            n.amt -= amt;\\n            n.sum -= amt;\\n        }\\n\\n        if (n.cat == uint8(CatOfNode.GroupMember)) {\\n\\n            Node storage r = chain.nodes[n.ptr];\\n\\n            if (isIncrease) {\\n\\n                r.sum += amt;\\n                \\n                if (r.cat == uint8(CatOfNode.GroupRepOnChain)) \\n                    _move(chain, n.ptr, isIncrease);\\n                else if (_onChainTest(chain, r))\\n                    _upChainAndMove(chain, r, n.ptr);\\n\\n            } else {\\n\\n                r.sum -= amt;\\n                \\n                if (r.cat == uint8(CatOfNode.GroupRepOnChain)) {\\n\\n                    if (!_onChainTest(chain, r)) \\n                        _offChain(chain, r, n.ptr);\\n                    else _move(chain, n.ptr, isIncrease);\\n\\n                }\\n            }\\n\\n        } else if (_isOnChain(n)) {\\n\\n            if (isIncrease) _move(chain, n.ptr, isIncrease);\\n            else {\\n                if (!_onChainTest(chain, n)) \\n                    _offChain(chain, n, n.ptr);\\n                else _move(chain, n.ptr, isIncrease);\\n            }\\n        \\n        } else if(isIncrease && _onChainTest(chain, n))\\n            _upChainAndMove(chain, n, n.ptr);\\n\\n    }\\n\\n    // ==== Grouping ====\\n\\n    function top2Sub(\\n        Chain storage chain,\\n        uint256 acct,\\n        uint256 root\\n    ) public memberExist(chain, root) {\\n\\n        Node storage n = chain.nodes[acct];\\n        Node storage r = chain.nodes[root];\\n\\n        require(acct != root, \\\"TC.T2S: self grouping\\\");\\n        require(_isIndepMember(n), \\\"TC.T2S: not indepMember\\\");\\n        require(_notGroupMember(r), \\\"TC.T2S: leaf as root\\\");\\n\\n        _carveOut(chain, n.ptr);\\n        _vInsert(chain, n.ptr, uint40(root));\\n    }\\n\\n    function sub2Top(Chain storage chain, uint256 acct) public {\\n\\n        Node storage n = chain.nodes[acct];\\n        require(_isInGroup(n), \\\"TC.S2T: not in a branch\\\");\\n\\n        _carveOut(chain, acct);\\n\\n        n.sum = n.amt;\\n        n.ptr = uint40(acct);\\n\\n        if (_onChainTest(chain, n)) _upChainAndMove(chain, n, n.ptr);\\n        else _appendToQueue(chain, n, n.ptr);\\n    }\\n\\n    // ==== CarveOut ====\\n\\n    function _branchOff(Chain storage chain, uint256 root) private {\\n        Node storage r = chain.nodes[root];\\n\\n        if (_isOnChain(r)) {\\n\\n            chain.nodes[r.next].prev = r.prev;\\n            chain.nodes[r.prev].next = r.next;\\n\\n            _decreaseQtyOfBranches(chain);\\n\\n        } else {\\n\\n            if (r.prev > 0 && r.next > 0) {\\n                chain.nodes[r.next].prev = r.prev;\\n                chain.nodes[r.prev].next = r.next;\\n            }else if (r.prev == 0 && r.next == 0) {\\n                chain.para.tail = 0;\\n                chain.para.head = 0;\\n            }else if (r.next == 0) {\\n                chain.para.tail = r.prev;\\n                chain.nodes[r.prev].next = 0;\\n            } else if (r.prev == 0) {\\n                chain.nodes[r.next].prev = 0;\\n                chain.para.head = r.next;\\n            }\\n\\n            _decreaseQtyOfSticks(chain);\\n\\n        }\\n    }\\n\\n    function _carveOut(Chain storage chain, uint acct)\\n        private\\n        memberExist(chain, acct)\\n    {\\n        Node storage n = chain.nodes[acct];\\n\\n        if (_isIndepMember(n)) {\\n\\n            _branchOff(chain, acct);\\n        \\n        } else if (_isGroupRep(n)) {\\n\\n            if (n.cat == uint8(CatOfNode.GroupRepOnChain) || (n.prev > 0 && n.next > 0)) {\\n\\n                chain.nodes[n.prev].next = n.ptr;\\n                chain.nodes[n.next].prev = n.ptr;\\n\\n            } else {\\n\\n                if (n.prev == 0 && n.next == 0) {\\n                    chain.para.tail = n.ptr;\\n                    chain.para.head = n.ptr;\\n                } else if (n.next == 0) {\\n                    chain.para.tail = n.ptr;\\n                    chain.nodes[n.prev].next = n.ptr;\\n                } else if (n.prev == 0) {\\n                    chain.nodes[n.next].prev = n.ptr;\\n                    chain.para.head = n.ptr;\\n                }\\n\\n            }\\n\\n            Node storage d = chain.nodes[n.ptr];\\n\\n            d.ptr = d.next;\\n            d.prev = n.prev;\\n            d.next = n.next;\\n\\n            if (d.ptr > 0) {\\n                uint40 cur = d.ptr;\\n                while (cur > 0) {\\n                    chain.nodes[cur].ptr = n.ptr;\\n                    cur = chain.nodes[cur].next;\\n                }\\n                d.cat = n.cat;\\n            } else {\\n                d.ptr = n.ptr;\\n                d.cat = n.cat == uint8(CatOfNode.GroupRepInQueue) \\n                    ? uint8(CatOfNode.IndepMemberInQueue) \\n                    : uint8(CatOfNode.IndepMemberOnChain);\\n            }\\n\\n            d.sum = n.sum - n.amt;\\n\\n            _offChainCheck(chain, d, n.ptr);\\n\\n        } else if (_isGroupMember(n)) {\\n\\n            Node storage u = chain.nodes[n.prev];\\n\\n            if (n.next > 0) chain.nodes[n.next].prev = n.prev;\\n\\n            if (u.cat == uint8(CatOfNode.GroupMember)) u.next = n.next;\\n            else if (n.next > 0) {\\n                u.ptr = n.next;\\n            } else {\\n                u.ptr = n.ptr;\\n                u.cat = u.cat == uint8(CatOfNode.GroupRepInQueue) \\n                    ? uint8(CatOfNode.IndepMemberInQueue) \\n                    : uint8(CatOfNode.IndepMemberOnChain);\\n            }\\n\\n            Node storage r = chain.nodes[n.ptr];\\n\\n            r.sum -= n.amt;\\n\\n            _offChainCheck(chain, r, n.ptr);\\n\\n        }\\n    }\\n\\n    function _offChainCheck(\\n        Chain storage chain,\\n        Node storage r,\\n        uint40 acct\\n    ) private {\\n        if (_isOnChain(r)) {\\n            if (_onChainTest(chain, r)) _move(chain, acct, false);\\n            else _offChain(chain, r, acct);                \\n        }\\n    }\\n\\n    // ==== Insert ====\\n\\n    function _hInsert(\\n        Chain storage chain,\\n        uint acct,\\n        uint prev,\\n        uint next\\n    ) private {\\n        Node storage n = chain.nodes[acct];\\n\\n        chain.nodes[prev].next = uint40(acct);\\n        n.prev = uint40(prev);\\n\\n        chain.nodes[next].prev = uint40(acct);\\n        n.next = uint40(next);\\n    }\\n\\n    function _vInsert(\\n        Chain storage chain,\\n        uint40 acct,\\n        uint40 root\\n    ) private {\\n        Node storage n = chain.nodes[acct];\\n        Node storage r = chain.nodes[root];\\n\\n        if (_isIndepMember(r)) {\\n            r.cat = r.cat == uint8(CatOfNode.IndepMemberInQueue) \\n                ? uint8(CatOfNode.GroupRepInQueue) \\n                : uint8(CatOfNode.GroupRepOnChain);\\n            n.next = 0;\\n        } else if (_isGroupRep(r)) {\\n            n.next = r.ptr;\\n            chain.nodes[n.next].prev = acct;\\n        }\\n\\n        n.prev = root;\\n        n.ptr = root;\\n\\n        n.cat = uint8(CatOfNode.GroupMember);\\n\\n        r.ptr = acct;\\n        r.sum += n.amt;\\n\\n        if (_isOnChain(r)) _move(chain, root, true);\\n        else if (_onChainTest(chain, r)) {\\n            _upChainAndMove(chain, r, root);\\n        }\\n    }\\n\\n    // ==== Move ====\\n\\n    function _move(\\n        Chain storage chain,\\n        uint acct,\\n        bool increase\\n    ) private {\\n        Node storage n = chain.nodes[acct];\\n\\n        (uint256 prev, uint256 next) = getPos(\\n            chain,\\n            n.sum,\\n            n.prev,\\n            n.next,\\n            increase\\n        );\\n\\n        if (next != n.next || prev != n.prev) {\\n            _branchOff(chain, acct); \\n            _hInsert(chain, acct, prev, next);\\n        }\\n    }\\n\\n    // ==== Chain & Queue ====\\n\\n    function _appendToQueue(\\n        Chain storage chain,\\n        Node storage n,\\n        uint40 acct\\n    ) private {\\n\\n        if (chain.para.qtyOfSticks > 0) {\\n            chain.nodes[chain.para.tail].next = acct;\\n        } else {\\n            chain.para.head = acct;\\n        }\\n\\n        n.prev = chain.para.tail;\\n        n.next = 0;\\n\\n        chain.para.tail = acct;\\n\\n        if (_isOnChain(n)) n.cat -= 3;\\n\\n        _increaseQtyOfSticks(chain);\\n    }\\n\\n    function _appendToChain(\\n        Chain storage chain,\\n        Node storage n,\\n        uint40 acct\\n    ) private {\\n        n.prev = chain.nodes[0].prev;\\n        chain.nodes[n.prev].next = acct;\\n        chain.nodes[0].prev = acct;\\n        n.next = 0;\\n\\n        if (_isInQueue(n)) n.cat += 3;\\n\\n        _increaseQtyOfBranches(chain);\\n    }\\n\\n    function _onChainTest(\\n        Chain storage chain,\\n        Node storage r\\n    ) private view returns(bool) {\\n        return uint(r.sum) * 10000 >= uint(totalVotes(chain)) * minVoteRatioOnChain(chain);\\n    }\\n\\n    function _upChainAndMove(\\n        Chain storage chain,\\n        Node storage n,\\n        uint40 acct\\n    ) private {\\n        _trimChain(chain);\\n        _branchOff(chain, acct);\\n        _appendToChain(chain, n, acct);\\n        _move(chain, acct, true);\\n\\n    }\\n\\n    function _trimChain(\\n        Chain storage chain\\n    ) private {\\n\\n        uint40 cur = chain.nodes[0].prev;\\n        \\n        while (cur > 0) {\\n            Node storage t = chain.nodes[cur];\\n            uint40 prev = t.prev;\\n            if (!_onChainTest(chain, t))\\n                _offChain(chain, t, cur);\\n            else break;\\n            cur = prev;\\n        }\\n    }\\n\\n    function _offChain(\\n        Chain storage chain,\\n        Node storage n,\\n        uint40 acct\\n    ) private {\\n        _branchOff(chain, acct);\\n        _appendToQueue(chain, n, acct);                            \\n    }\\n\\n    // ---- Categories Of Node ----\\n\\n    function _isOnChain(\\n        Node storage n\\n    ) private view returns (bool) {\\n        return n.cat > 2;\\n    }\\n\\n    function _isInQueue(\\n        Node storage n\\n    ) private view returns (bool) {\\n        return n.cat < 2;\\n    }\\n\\n    function _isIndepMember(\\n        Node storage n\\n    ) private view returns (bool) {\\n        return n.cat % 3 == 0;\\n    }\\n\\n    function _isInGroup(\\n        Node storage n\\n    ) private view returns (bool) {\\n        return n.cat % 3 > 0;\\n    }\\n\\n    function _isGroupRep(\\n        Node storage n\\n    ) private view returns (bool) {\\n        return n.cat % 3 == 1;\\n    }\\n\\n    function _isGroupMember(\\n        Node storage n\\n    ) private view returns (bool) {\\n        return n.cat == uint8(CatOfNode.GroupMember);\\n    }\\n\\n    function _notGroupMember(\\n        Node storage n\\n    ) private view returns (bool) {\\n        return n.cat % 3 < 2;\\n    }\\n\\n    // ==== setting ====\\n\\n    function _increaseQtyOfBranches(Chain storage chain) private {\\n        chain.para.qtyOfBranches++;\\n    }\\n\\n    function _increaseQtyOfMembers(Chain storage chain) private {\\n        chain.para.qtyOfMembers++;\\n    }\\n\\n    function _increaseQtyOfSticks(Chain storage chain) private {\\n        chain.para.qtyOfSticks++;\\n    }\\n\\n    function _increaseTotalVotes(Chain storage chain, uint64 deltaAmt) private {\\n        chain.nodes[0].sum += deltaAmt;\\n    }\\n\\n    function _decreaseQtyOfBranches(Chain storage chain) private {\\n        chain.para.qtyOfBranches--;\\n    }\\n\\n    function _decreaseQtyOfMembers(Chain storage chain) private {\\n        chain.para.qtyOfMembers--;\\n    }\\n\\n    function _decreaseQtyOfSticks(Chain storage chain) private {\\n        chain.para.qtyOfSticks--;\\n    }\\n\\n    function _decreaseTotalVotes(Chain storage chain, uint64 deltaAmt) private {\\n        chain.nodes[0].sum -= deltaAmt;\\n    }\\n\\n    //##################\\n    //##    \u8bfb\u63a5\u53e3    ##\\n    //##################\\n\\n    function isMember(Chain storage chain, uint256 acct)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return chain.nodes[acct].ptr != 0;\\n    }\\n\\n    // ==== Zero Node ====\\n\\n    function tail(Chain storage chain) public view returns (uint40) {\\n        return chain.nodes[0].prev;\\n    }\\n\\n    function head(Chain storage chain) public view returns (uint40) {\\n        return chain.nodes[0].next;\\n    }\\n\\n    function totalVotes(Chain storage chain) public view returns (uint64) {\\n        return chain.nodes[0].sum;\\n    }\\n\\n    function basedOnPar(Chain storage chain) public view returns (bool) {\\n        return chain.nodes[0].cat == 1;\\n    }\\n\\n    // ---- Para ----\\n\\n    function headOfQueue(Chain storage chain)\\n        public\\n        view\\n        returns (uint40)\\n    {\\n        return  chain.para.head;\\n    }\\n\\n    function tailOfQueue(Chain storage chain)\\n        public\\n        view\\n        returns (uint40)\\n    {\\n        return  chain.para.tail;\\n    }\\n\\n    function maxQtyOfMembers(Chain storage chain)\\n        public\\n        view\\n        returns (uint32)\\n    {\\n        return chain.para.maxQtyOfMembers; \\n    }\\n\\n    function minVoteRatioOnChain(Chain storage chain)\\n        public\\n        view\\n        returns (uint16)\\n    {\\n        uint16 min = chain.para.minVoteRatioOnChain;\\n        return min > 0 ? min : 500; \\n    }\\n\\n    function qtyOfBranches(Chain storage chain) public view returns (uint32) {\\n        return chain.para.qtyOfBranches;\\n    }\\n\\n    function qtyOfGroups(Chain storage chain) public view returns (uint32) {\\n        return chain.para.qtyOfBranches + chain.para.qtyOfSticks;\\n    }\\n\\n    function qtyOfTopMembers(Chain storage chain) \\n        public view \\n        returns(uint qty) \\n    {\\n        uint cur = chain.nodes[0].next;\\n\\n        while(cur > 0) {\\n            qty++;\\n            cur = nextNode(chain, cur);\\n        }\\n    }\\n\\n    function qtyOfMembers(Chain storage chain) public view returns (uint32) {\\n        return chain.para.qtyOfMembers;\\n    }\\n\\n    // ==== locate position ====\\n\\n    function getPos(\\n        Chain storage chain,\\n        uint256 amount,\\n        uint256 prev,\\n        uint256 next,\\n        bool increase\\n    ) public view returns (uint256, uint256) {\\n        if (increase)\\n            while (prev > 0 && chain.nodes[prev].sum < amount) {\\n                next = prev;\\n                prev = chain.nodes[prev].prev;\\n            }\\n        else\\n            while (next > 0 && chain.nodes[next].sum > amount) {\\n                prev = next;\\n                next = chain.nodes[next].next;\\n            }\\n\\n        return (prev, next);\\n    }\\n\\n    function nextNode(Chain storage chain, uint256 acct)\\n        public view returns (uint256 next)\\n    {\\n        Node storage n = chain.nodes[acct];\\n\\n        if (_isIndepMember(n)) {\\n            next = n.next;\\n        } else if (_isGroupRep(n)) {\\n            next = n.ptr;\\n        } else if (_isGroupMember(n)) {\\n            next = (n.next > 0) ? n.next : chain.nodes[n.ptr].next;\\n        }\\n    }\\n\\n    function getNode(Chain storage chain, uint256 acct)\\n        public view returns (Node memory n)\\n    {\\n        n = chain.nodes[acct];\\n    }\\n\\n    // ==== group ====\\n\\n    function rootOf(Chain storage chain, uint256 acct)\\n        public\\n        view\\n        memberExist(chain, acct)\\n        returns (uint40 group)\\n    {\\n        Node storage n = chain.nodes[acct];\\n        group = (n.cat == uint8(CatOfNode.GroupMember)) ? n.ptr : uint40(acct) ;\\n    }\\n\\n    function deepOfBranch(Chain storage chain, uint256 acct)\\n        public\\n        view\\n        memberExist(chain, acct)\\n        returns (uint256 deep)\\n    {\\n        Node storage n = chain.nodes[acct];\\n\\n        if (_isIndepMember(n)) deep = 1;\\n        else if (_isGroupRep(n)) deep = _deepOfBranch(chain, acct);\\n        else deep = _deepOfBranch(chain, n.ptr);\\n    }\\n\\n    function _deepOfBranch(Chain storage chain, uint256 root)\\n        private\\n        view\\n        returns (uint256 deep)\\n    {\\n        deep = 1;\\n\\n        uint40 next = chain.nodes[root].ptr;\\n\\n        while (next > 0) {\\n            deep++;\\n            next = chain.nodes[next].next;\\n        }\\n    }\\n\\n    function votesOfGroup(Chain storage chain, uint256 acct)\\n        public\\n        view\\n        returns (uint64 votes)\\n    {\\n        uint256 group = rootOf(chain, acct);\\n        votes = chain.nodes[group].sum;\\n    }\\n\\n    function membersOfGroup(Chain storage chain, uint256 acct)\\n        public\\n        view\\n        returns (uint256[] memory list)\\n    {\\n        uint256 cur = rootOf(chain, acct);\\n        uint256 len = deepOfBranch(chain, acct);\\n\\n        list = new uint256[](len);\\n        uint256 i = 0;\\n\\n        while (i < len) {\\n            list[i] = cur;\\n            cur = nextNode(chain, cur);\\n            i++;\\n        }\\n    }\\n\\n    function affiliated(\\n        Chain storage chain,\\n        uint256 acct1,\\n        uint256 acct2\\n    )\\n        public\\n        view\\n        memberExist(chain, acct1)\\n        memberExist(chain, acct2)\\n        returns (bool)\\n    {\\n        Node storage n1 = chain.nodes[acct1];\\n        Node storage n2 = chain.nodes[acct2];\\n\\n        return n1.ptr == n2.ptr || n1.ptr == acct2 || n2.ptr == acct1;\\n    }\\n\\n    // ==== members ====\\n\\n    function topMembersList(Chain storage chain)\\n        public view\\n        returns (uint256[] memory list)\\n    {\\n        uint256 len = qtyOfTopMembers(chain);\\n        list = new uint[](len);\\n\\n        len = 0;\\n        uint cur = chain.nodes[0].next;\\n\\n        _seqListOfQueue(chain, list, cur, len);\\n    }\\n\\n    function sortedMembersList(Chain storage chain)\\n        public\\n        view\\n        returns (uint256[] memory list)\\n    {\\n        uint256 len = qtyOfMembers(chain);\\n        list = new uint[](len);\\n\\n        uint cur = chain.nodes[0].next;\\n        len = 0;\\n\\n        len = _seqListOfQueue(chain, list, cur, len);\\n\\n        cur = chain.para.head;\\n        _seqListOfQueue(chain, list, cur, len);\\n    }\\n\\n    function _seqListOfQueue(\\n        Chain storage chain,\\n        uint[] memory list,\\n        uint cur,\\n        uint i\\n    ) private view returns (uint) {\\n        while (cur > 0) {\\n            list[i] = cur;\\n            cur = nextNode(chain, cur);\\n            i++;\\n        }\\n        return i;\\n    }\\n\\n    // ==== Backup / Restore ====\\n\\n    function getSnapshot(Chain storage chain)\\n        public view\\n        returns (Node[] memory list, Para memory para)\\n    {\\n        para = chain.para;\\n\\n        uint256 len = qtyOfMembers(chain);\\n        list = new Node[](len + 1);\\n\\n        list[0] = chain.nodes[0];\\n\\n        uint256 cur = chain.nodes[0].next;\\n        len = 1;\\n        len = _backupNodes(chain, list, cur, len);\\n\\n        cur = para.head;\\n        _backupNodes(chain, list, cur, len);\\n    }\\n\\n    function _backupNodes(\\n        Chain storage chain,\\n        Node[] memory list,\\n        uint cur,\\n        uint i\\n    ) private view returns (uint) {\\n        while (cur > 0) {\\n            list[i] = chain.nodes[cur];\\n            cur = nextNode(chain, cur);\\n            i++;\\n        }\\n        return i;\\n    }\\n\\n    function restoreChain(\\n        Chain storage chain, \\n        Node[] memory list, \\n        Para memory para\\n    ) public {\\n\\n        chain.nodes[0] = list[0];\\n        chain.para = para;\\n\\n        uint256 cur = list[0].next;\\n        uint256 i = 1;\\n        i = _restoreNodes(chain, list, cur, i);\\n\\n        cur = para.head;\\n        _restoreNodes(chain, list, cur, i);\\n    }\\n\\n    function _restoreNodes(\\n        Chain storage chain,\\n        Node[] memory list,\\n        uint cur,\\n        uint i\\n    ) private returns (uint) {\\n        while (cur > 0) {\\n            chain.nodes[cur] = list[i];\\n            cur = nextNode(chain, cur);\\n            i++;\\n        }\\n        return i;\\n    }\\n\\n    // ==== MockDeals ====\\n\\n    function mockDealsOfIA(\\n        Chain storage chain,\\n        IInvestmentAgreement _ia\\n    ) public {\\n        uint[] memory seqList = _ia.getSeqList();\\n\\n        uint256 len = seqList.length;\\n\\n        while (len > 0) {\\n            DealsRepo.Deal memory deal = _ia.getDeal(seqList[len-1]);\\n\\n            uint64 amount = basedOnPar(chain) ? deal.body.par : deal.body.paid;\\n\\n            if (deal.head.seller > 0) {\\n                mockDealOfSell(chain, deal.head.seller, amount);\\n            }\\n\\n            mockDealOfBuy(chain, deal.body.buyer, deal.body.groupOfBuyer, amount);\\n\\n            len--;\\n        }\\n    }\\n\\n    function mockDealOfSell(\\n        Chain storage chain, \\n        uint256 seller, \\n        uint amount\\n    ) public {\\n        increaseAmt(chain, seller, amount, false);\\n        \\n        if (chain.nodes[seller].amt == 0)\\n            delNode(chain, seller);\\n    }\\n\\n    function mockDealOfBuy(\\n        Chain storage chain, \\n        uint256 buyer, \\n        uint256 group,\\n        uint amount\\n    ) public {\\n        addNode(chain, buyer);\\n\\n        increaseAmt(chain, buyer, amount, true);\\n\\n        if (rootOf(chain, buyer) != group)\\n            top2Sub(chain, buyer, group);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/lib/BallotsBox.sol\": {\r\n        \"BallotsBox\": \"0xa6a902791e6ba1f9288dfd9969c51890419bf903\"\r\n      },\r\n      \"contracts/lib/DelegateMap.sol\": {\r\n        \"DelegateMap\": \"0x75f49b5fd95850fb70e8cf0d1e0d7619b2d42552\"\r\n      },\r\n      \"contracts/lib/EnumerableSet.sol\": {\r\n        \"EnumerableSet\": \"0xc4f24b69792ff96f0316fab2d7df198af8033930\"\r\n      },\r\n      \"contracts/lib/RulesParser.sol\": {\r\n        \"RulesParser\": \"0x442719360abe969b6243d8b309cc59b51f54e184\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"typeOfMotion\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"seqOfMotion\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"seqOfVR\",\"type\":\"uint16\"},{\"internalType\":\"uint40\",\"name\":\"creator\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"executor\",\"type\":\"uint40\"},{\"internalType\":\"uint48\",\"name\":\"createDate\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"data\",\"type\":\"uint32\"}],\"internalType\":\"struct MotionsRepo.Head\",\"name\":\"head\",\"type\":\"tuple\"}],\"name\":\"codifyHead\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"sn\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sn\",\"type\":\"bytes32\"}],\"name\":\"snParser\",\"outputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"typeOfMotion\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"seqOfMotion\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"seqOfVR\",\"type\":\"uint16\"},{\"internalType\":\"uint40\",\"name\":\"creator\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"executor\",\"type\":\"uint40\"},{\"internalType\":\"uint48\",\"name\":\"createDate\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"data\",\"type\":\"uint32\"}],\"internalType\":\"struct MotionsRepo.Head\",\"name\":\"head\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "MotionsRepo", "CompilerVersion": "v0.8.8+commit.dddeac2f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}