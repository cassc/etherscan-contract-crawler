{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/NFTSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.13;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\\\";\\r\\nimport \\\"./NFTSwapAbstract.sol\\\";\\r\\n\\r\\ncontract NFTSwap is Ownable, Pausable, ERC721Holder, ERC1155Holder {\\r\\n\\r\\n    using Counters for Counters.Counter;\\r\\n\\r\\n    enum SwapStatus  {Open, Completed, Canceled, Expired}\\r\\n    enum DAppType {Undefined, ERC721, ERC1155, ERC20, NetworkValue}\\r\\n\\r\\n    struct SwapItem {\\r\\n        address dApp;\\r\\n        DAppType dAppType;\\r\\n        uint256[] tokenIds;\\r\\n        uint256[] tokenAmounts;\\r\\n        bytes data;\\r\\n    }\\r\\n\\r\\n    struct SwapOrder {\\r\\n        uint256 id;\\r\\n        uint256 start;\\r\\n        uint256 end;\\r\\n        uint256 expiration;\\r\\n        uint256 fee;\\r\\n        uint256 feePaid;\\r\\n        address addressOne;\\r\\n        address addressTwo;\\r\\n        SwapStatus status;\\r\\n        SwapItem[] addressOneItems;\\r\\n        SwapItem[] addressTwoItems;\\r\\n    }\\r\\n\\r\\n    mapping(uint256 => SwapOrder)swapOrders;\\r\\n    mapping(address => uint256[])swapAddresses;\\r\\n\\r\\n    uint256 private _fee;\\r\\n    Counters.Counter private _orderId;\\r\\n    uint256 private _swapBalance;\\r\\n\\r\\n    //Event\\r\\n    event SwapOrderEvent(uint256 orderId, SwapStatus status);\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    //Interface received\\r\\n    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\\r\\n        return interfaceID == type(IERC721).interfaceId || interfaceID == type(IERC1155).interfaceId;\\r\\n    }\\r\\n\\r\\n    //Create swap order\\r\\n    function creatSwapOrder(address addressTwo, SwapItem[] memory swapOneItems, SwapItem[] memory swapTwoItems, uint256 expirationSec) public payable whenNotPaused returns (uint256){\\r\\n        require(swapOneItems.length > 0, \\\"AIe0\\\");\\r\\n        require(swapTwoItems.length > 0, \\\"BIe0\\\");\\r\\n        require(msg.sender != addressTwo, \\\"OeT\\\");\\r\\n\\r\\n        _orderId.increment();\\r\\n\\r\\n        swapOrders[_orderId.current()].id = _orderId.current();\\r\\n        swapOrders[_orderId.current()].start = block.timestamp;\\r\\n        swapOrders[_orderId.current()].end = 0;\\r\\n        if (expirationSec > 0) {\\r\\n            swapOrders[_orderId.current()].expiration = block.timestamp + expirationSec;\\r\\n        } else {\\r\\n            swapOrders[_orderId.current()].expiration = 0;\\r\\n        }\\r\\n\\r\\n        uint256 swapNetworkValue = msg.value;\\r\\n        swapOrders[_orderId.current()].fee = getFee();\\r\\n        swapOrders[_orderId.current()].addressOne = msg.sender;\\r\\n        swapOrders[_orderId.current()].addressTwo = addressTwo;\\r\\n        swapOrders[_orderId.current()].status = SwapStatus.Open;\\r\\n\\r\\n        uint256 i = 0;\\r\\n\\r\\n        for (i = 0; i < swapOneItems.length; i++) {\\r\\n            require(swapOneItems[i].dAppType != DAppType.Undefined, \\\"DU\\\");\\r\\n            swapOrders[_orderId.current()].addressOneItems.push(swapOneItems[i]);\\r\\n            if (swapOneItems[i].dAppType == DAppType.ERC721) {\\r\\n                ERC721Interface(swapOneItems[i].dApp).safeTransferFrom(msg.sender, address(this), swapOneItems[i].tokenIds[0], swapOneItems[i].data);\\r\\n            } else if (swapOneItems[i].dAppType == DAppType.ERC1155) {\\r\\n                ERC1155Interface(swapOneItems[i].dApp).safeBatchTransferFrom(msg.sender, address(this), swapOneItems[i].tokenIds, swapOneItems[i].tokenAmounts, swapOneItems[i].data);\\r\\n            } else if (swapOneItems[i].dAppType == DAppType.ERC20) {\\r\\n                ERC20Interface(swapOneItems[i].dApp).transferFrom(msg.sender, address(this), swapOneItems[i].tokenAmounts[0]);\\r\\n            } else if (swapOneItems[i].dAppType == DAppType.NetworkValue) {\\r\\n                require(swapNetworkValue >= swapOneItems[i].tokenAmounts[0], \\\"VltS\\\");\\r\\n                swapNetworkValue -= swapOneItems[i].tokenAmounts[0];\\r\\n                _swapBalance += swapOneItems[i].tokenAmounts[0];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (swapOrders[_orderId.current()].fee > 0) {\\r\\n            if (swapNetworkValue > 0) {\\r\\n                if (swapOrders[_orderId.current()].fee > swapNetworkValue) {\\r\\n                    swapOrders[_orderId.current()].feePaid = swapNetworkValue;\\r\\n                    swapNetworkValue -= swapOrders[_orderId.current()].feePaid;\\r\\n                } else {\\r\\n                    swapOrders[_orderId.current()].feePaid = swapOrders[_orderId.current()].fee;\\r\\n                    swapNetworkValue -= swapOrders[_orderId.current()].fee;\\r\\n                }\\r\\n            } else {\\r\\n                swapOrders[_orderId.current()].feePaid = 0;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        require(swapNetworkValue == 0, \\\"VN0\\\");\\r\\n\\r\\n        for (i = 0; i < swapTwoItems.length; i++) {\\r\\n            require(swapTwoItems[i].dAppType != DAppType.Undefined, \\\"DU\\\");\\r\\n            swapOrders[_orderId.current()].addressTwoItems.push(swapTwoItems[i]);\\r\\n        }\\r\\n\\r\\n        swapAddresses[msg.sender].push(_orderId.current());\\r\\n        if (addressTwo != address(0)) {\\r\\n            swapAddresses[addressTwo].push(_orderId.current());\\r\\n        }\\r\\n\\r\\n        emit SwapOrderEvent(_orderId.current(), SwapStatus.Open);\\r\\n\\r\\n        return _orderId.current();\\r\\n    }\\r\\n\\r\\n    //Complete\\r\\n    function completeSwapOrder(uint256 orderId) public payable returns (bool){\\r\\n        require(swapOrders[orderId].status == SwapStatus.Open, \\\"NO\\\");\\r\\n        require(swapOrders[orderId].addressTwo == msg.sender || swapOrders[orderId].addressTwo == address(0), \\\"NA\\\");\\r\\n\\r\\n        if (swapOrders[orderId].expiration >= block.timestamp || swapOrders[orderId].expiration == 0) {\\r\\n\\r\\n            swapOrders[orderId].end = block.timestamp;\\r\\n\\r\\n            uint256 swapNetworkValue = msg.value;\\r\\n            if (swapOrders[orderId].fee > 0 && swapOrders[orderId].fee > swapOrders[orderId].feePaid) {\\r\\n                uint256 fpv = (swapOrders[orderId].fee - swapOrders[orderId].feePaid);\\r\\n                require(swapNetworkValue >= fpv, \\\"VFltS\\\");\\r\\n                swapOrders[orderId].feePaid += fpv;\\r\\n                swapNetworkValue -= fpv;\\r\\n            }\\r\\n\\r\\n            if (swapOrders[orderId].addressTwo == address(0)) {\\r\\n                swapAddresses[msg.sender].push(swapOrders[orderId].id);\\r\\n            }\\r\\n\\r\\n            swapOrders[orderId].addressTwo = msg.sender;\\r\\n            swapOrders[orderId].status = SwapStatus.Completed;\\r\\n\\r\\n            uint256 i;\\r\\n\\r\\n            for (i = 0; i < swapOrders[orderId].addressTwoItems.length; i++) {\\r\\n                if (swapOrders[orderId].addressTwoItems[i].dAppType == DAppType.ERC721) {\\r\\n                    ERC721Interface(swapOrders[orderId].addressTwoItems[i].dApp).safeTransferFrom(msg.sender, swapOrders[orderId].addressOne, swapOrders[orderId].addressTwoItems[i].tokenIds[0], swapOrders[orderId].addressTwoItems[i].data);\\r\\n                } else if (swapOrders[orderId].addressTwoItems[i].dAppType == DAppType.ERC1155) {\\r\\n                    ERC1155Interface(swapOrders[orderId].addressTwoItems[i].dApp).safeBatchTransferFrom(msg.sender, swapOrders[orderId].addressOne, swapOrders[orderId].addressTwoItems[i].tokenIds, swapOrders[orderId].addressTwoItems[i].tokenAmounts, swapOrders[orderId].addressTwoItems[i].data);\\r\\n                } else if (swapOrders[orderId].addressTwoItems[i].dAppType == DAppType.ERC20) {\\r\\n                    ERC20Interface(swapOrders[orderId].addressTwoItems[i].dApp).transferFrom(msg.sender, swapOrders[orderId].addressOne, swapOrders[orderId].addressTwoItems[i].tokenAmounts[0]);\\r\\n                } else if (swapOrders[orderId].addressTwoItems[i].dAppType == DAppType.NetworkValue) {\\r\\n                    require(swapNetworkValue >= swapOrders[orderId].addressTwoItems[i].tokenAmounts[0], \\\"VltS\\\");\\r\\n                    payable(swapOrders[orderId].addressOne).transfer(swapOrders[orderId].addressTwoItems[i].tokenAmounts[0]);\\r\\n                    swapNetworkValue -= swapOrders[orderId].addressTwoItems[i].tokenAmounts[0];\\r\\n                }\\r\\n            }\\r\\n\\r\\n            require(swapNetworkValue == 0, \\\"VN0\\\");\\r\\n\\r\\n            for (i = 0; i < swapOrders[orderId].addressOneItems.length; i++) {\\r\\n                if (swapOrders[orderId].addressOneItems[i].dAppType == DAppType.ERC721) {\\r\\n                    ERC721Interface(swapOrders[orderId].addressOneItems[i].dApp).safeTransferFrom(address(this), swapOrders[orderId].addressTwo, swapOrders[orderId].addressOneItems[i].tokenIds[0], swapOrders[orderId].addressOneItems[i].data);\\r\\n                } else if (swapOrders[orderId].addressOneItems[i].dAppType == DAppType.ERC1155) {\\r\\n                    ERC1155Interface(swapOrders[orderId].addressOneItems[i].dApp).safeBatchTransferFrom(address(this), swapOrders[orderId].addressTwo, swapOrders[orderId].addressOneItems[i].tokenIds, swapOrders[orderId].addressOneItems[i].tokenAmounts, swapOrders[orderId].addressOneItems[i].data);\\r\\n                } else if (swapOrders[orderId].addressOneItems[i].dAppType == DAppType.ERC20) {\\r\\n                    ERC20Interface(swapOrders[orderId].addressOneItems[i].dApp).transfer(swapOrders[orderId].addressTwo, swapOrders[orderId].addressOneItems[i].tokenAmounts[0]);\\r\\n                } else if (swapOrders[orderId].addressOneItems[i].dAppType == DAppType.NetworkValue) {\\r\\n                    payable(swapOrders[orderId].addressTwo).transfer(swapOrders[orderId].addressOneItems[i].tokenAmounts[0]);\\r\\n                    _swapBalance -= swapOrders[orderId].addressOneItems[i].tokenAmounts[0];\\r\\n                }\\r\\n            }\\r\\n\\r\\n            emit SwapOrderEvent(orderId, SwapStatus.Completed);\\r\\n\\r\\n            return true;\\r\\n        } else {\\r\\n            swapOrders[orderId].status = SwapStatus.Expired;\\r\\n\\r\\n            emit SwapOrderEvent(orderId, SwapStatus.Expired);\\r\\n\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //Cancel\\r\\n    function cancelSwapOrder(uint256 orderId) public payable returns (bool){\\r\\n        require(swapOrders[orderId].status == SwapStatus.Open || swapOrders[orderId].status == SwapStatus.Expired, \\\"C\\\");\\r\\n        require(swapOrders[orderId].addressOne == msg.sender, \\\"NC\\\");\\r\\n\\r\\n        swapOrders[orderId].status = SwapStatus.Canceled;\\r\\n        swapOrders[orderId].end = block.timestamp;\\r\\n\\r\\n        uint256 swapNetworkValue = msg.value;\\r\\n        if (swapOrders[orderId].fee > 0 && swapOrders[orderId].fee > swapOrders[orderId].feePaid) {\\r\\n            uint256 fpv = (swapOrders[orderId].fee - swapOrders[orderId].feePaid);\\r\\n            require(swapNetworkValue >= fpv, \\\"VFltS\\\");\\r\\n            swapOrders[orderId].feePaid += fpv;\\r\\n            swapNetworkValue -= fpv;\\r\\n        }\\r\\n        require(swapNetworkValue == 0, \\\"VN0\\\");\\r\\n\\r\\n        uint256 i;\\r\\n\\r\\n        for (i = 0; i < swapOrders[orderId].addressOneItems.length; i++) {\\r\\n            if (swapOrders[orderId].addressOneItems[i].dAppType == DAppType.ERC721) {\\r\\n                ERC721Interface(swapOrders[orderId].addressOneItems[i].dApp).safeTransferFrom(address(this), swapOrders[orderId].addressOne, swapOrders[orderId].addressOneItems[i].tokenIds[0], swapOrders[orderId].addressOneItems[i].data);\\r\\n            } else if (swapOrders[orderId].addressOneItems[i].dAppType == DAppType.ERC1155) {\\r\\n                ERC1155Interface(swapOrders[orderId].addressOneItems[i].dApp).safeBatchTransferFrom(address(this), swapOrders[orderId].addressOne, swapOrders[orderId].addressOneItems[i].tokenIds, swapOrders[orderId].addressOneItems[i].tokenAmounts, swapOrders[orderId].addressOneItems[i].data);\\r\\n            } else if (swapOrders[orderId].addressOneItems[i].dAppType == DAppType.ERC20) {\\r\\n                ERC20Interface(swapOrders[orderId].addressOneItems[i].dApp).transfer(swapOrders[orderId].addressOne, swapOrders[orderId].addressOneItems[i].tokenAmounts[0]);\\r\\n            } else if (swapOrders[orderId].addressOneItems[i].dAppType == DAppType.NetworkValue) {\\r\\n                payable(swapOrders[orderId].addressOne).transfer(swapOrders[orderId].addressOneItems[i].tokenAmounts[0]);\\r\\n                _swapBalance -= swapOrders[orderId].addressOneItems[i].tokenAmounts[0];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit SwapOrderEvent(orderId, SwapStatus.Canceled);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    //Order info\\r\\n    function getOrderById(uint256 orderId) public view returns (SwapOrder memory){\\r\\n        return swapOrders[orderId];\\r\\n    }\\r\\n\\r\\n    function getOrderIdsByAddress(address addressIndex) public view returns (uint256[] memory){\\r\\n        return swapAddresses[addressIndex];\\r\\n    }\\r\\n\\r\\n    function getOrderCount() public view returns (uint256){\\r\\n        return _orderId.current();\\r\\n    }\\r\\n\\r\\n    //Fee\\r\\n    function getFee() public view returns (uint256){\\r\\n        return _fee;\\r\\n    }\\r\\n\\r\\n    function setFee(uint256 newFee) public onlyOwner {\\r\\n        _fee = newFee;\\r\\n    }\\r\\n\\r\\n    //System\\r\\n    function switchPause() public onlyOwner {\\r\\n        if (paused()) {\\r\\n            _unpause();\\r\\n        } else {\\r\\n            _pause();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getFeeBalance() internal view returns (uint256) {\\r\\n        return address(this).balance > _swapBalance ? address(this).balance - _swapBalance : 0;\\r\\n    }\\r\\n\\r\\n    function getWithdrawBalance(address payable recipient, uint256 amounts) public onlyOwner {\\r\\n        require(recipient != address(0), \\\"WB0\\\");\\r\\n        uint256 maxAmount = _getFeeBalance();\\r\\n        if (amounts == 0 || maxAmount < amounts) {\\r\\n            recipient.transfer(maxAmount);\\r\\n        } else {\\r\\n            recipient.transfer(amounts);\\r\\n        }\\r\\n    }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/NFTSwapAbstract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.12;\\r\\npragma abicoder v2;\\r\\n\\r\\nabstract contract ERC721Interface {\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external virtual;\\r\\n}\\r\\n\\r\\nabstract contract ERC1155Interface {\\r\\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external virtual;\\r\\n}\\r\\n\\r\\nabstract contract ERC20Interface {\\r\\n    function transfer(address recipient, uint256 amount) external virtual returns (bool);\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual returns (bool);\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721Holder is IERC721Receiver {\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Receiver.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC1155Receiver.sol\\\";\\n\\n/**\\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\\n *\\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\\n * stuck.\\n *\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155Holder is ERC1155Receiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum NFTSwap.SwapStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"SwapOrderEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"cancelSwapOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"completeSwapOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressTwo\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"dApp\",\"type\":\"address\"},{\"internalType\":\"enum NFTSwap.DAppType\",\"name\":\"dAppType\",\"type\":\"uint8\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct NFTSwap.SwapItem[]\",\"name\":\"swapOneItems\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"dApp\",\"type\":\"address\"},{\"internalType\":\"enum NFTSwap.DAppType\",\"name\":\"dAppType\",\"type\":\"uint8\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct NFTSwap.SwapItem[]\",\"name\":\"swapTwoItems\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"expirationSec\",\"type\":\"uint256\"}],\"name\":\"creatSwapOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"getOrderById\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feePaid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addressOne\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addressTwo\",\"type\":\"address\"},{\"internalType\":\"enum NFTSwap.SwapStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"dApp\",\"type\":\"address\"},{\"internalType\":\"enum NFTSwap.DAppType\",\"name\":\"dAppType\",\"type\":\"uint8\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct NFTSwap.SwapItem[]\",\"name\":\"addressOneItems\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"dApp\",\"type\":\"address\"},{\"internalType\":\"enum NFTSwap.DAppType\",\"name\":\"dAppType\",\"type\":\"uint8\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct NFTSwap.SwapItem[]\",\"name\":\"addressTwoItems\",\"type\":\"tuple[]\"}],\"internalType\":\"struct NFTSwap.SwapOrder\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOrderCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressIndex\",\"type\":\"address\"}],\"name\":\"getOrderIdsByAddress\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amounts\",\"type\":\"uint256\"}],\"name\":\"getWithdrawBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"switchPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "NFTSwap", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}