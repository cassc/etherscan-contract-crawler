{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/oracles/UniswapV3PriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.4;\\n\\nimport \\\"@prb/contracts/access/Ownable.sol\\\";\\nimport \\\"@prb/contracts/token/erc20/IErc20.sol\\\";\\n\\nimport \\\"./IUniswapV3PriceFeed.sol\\\";\\nimport \\\"../external/chainlink/IAggregatorV3.sol\\\";\\nimport \\\"../external/uniswap/interfaces/IUniswapV3Pool.sol\\\";\\nimport \\\"../external/uniswap/libraries/TickMath.sol\\\";\\nimport \\\"../external/uniswap/libraries/FullMath.sol\\\";\\n\\n/// @title UniswapV3PriceFeed\\n/// @author Hifi\\n/// @dev Although the contract is production-ready, it has not been audited for security vulnerabilities. Use at your own risk.\\ncontract UniswapV3PriceFeed is\\n    Ownable, // one dependency\\n    IUniswapV3PriceFeed // one dependency\\n{\\n    /// PUBLIC STORAGE ///\\n\\n    /// @inheritdoc IUniswapV3PriceFeed\\n    IErc20 public immutable override baseAsset;\\n\\n    /// @inheritdoc IUniswapV3PriceFeed\\n    int256 public override maxPrice;\\n\\n    /// @inheritdoc IUniswapV3PriceFeed\\n    IUniswapV3Pool public immutable override pool;\\n\\n    /// @inheritdoc IUniswapV3PriceFeed\\n    IErc20 public immutable override quoteAsset;\\n\\n    /// @inheritdoc IUniswapV3PriceFeed\\n    uint32 public immutable override twapInterval;\\n\\n    /// INTERNAL STORAGE ///\\n\\n    /// @dev The Uniswap V3 pool's token0.\\n    IErc20 internal immutable token0;\\n\\n    /// @dev The ERC20 decimals of \\\"token0\\\".\\n    uint8 internal immutable token0Decimals;\\n\\n    /// @dev The Uniswap V3 pool's token1.\\n    IErc20 internal immutable token1;\\n\\n    /// @dev The ERC20 decimals of \\\"token1\\\".\\n    uint8 internal immutable token1Decimals;\\n\\n    /// CONSTRUCTOR ///\\n\\n    /// @notice Instantiates the UniswapV3PriceFeed contract.\\n    /// @param pool_ The address of the Uniswap V3 pool.\\n    /// @param quoteAsset_ The address of the quote asset for price calculation.\\n    /// @param twapInterval_ The time window for the TWAP calculation.\\n    /// @param maxPrice_ The maximum price for the price feed.\\n    constructor(\\n        IUniswapV3Pool pool_,\\n        IErc20 quoteAsset_,\\n        uint32 twapInterval_,\\n        int256 maxPrice_\\n    ) {\\n        quoteAsset = quoteAsset_;\\n\\n        token0 = IErc20(pool_.token0());\\n        token1 = IErc20(pool_.token1());\\n\\n        // Ensure the quote asset is in the provided pool\\n        if (quoteAsset != token0 && quoteAsset != token1) {\\n            revert IUniswapV3PriceFeed__QuoteAssetNotInPool(quoteAsset);\\n        }\\n\\n        baseAsset = quoteAsset == token1 ? token0 : token1;\\n        pool = pool_;\\n\\n        // Fetch the pool cardinality and most recent observation index.\\n        (, , uint16 index, uint16 cardinality, , , ) = pool.slot0();\\n\\n        // Ensure the oldest pool observation is initialized and satisfies the TWAP interval.\\n        // The next observation at index + 1 is the oldest observation in the ring buffer.\\n        (uint32 oldestAvailableAge, , , bool initialized) = pool.observations((index + 1) % cardinality);\\n\\n        // If the next observation is not initialized, all observations of higher indices are also not initialized.\\n        // Therefore, revert to index 0 to find the oldest initialized observation.\\n        if (!initialized) (oldestAvailableAge, , , ) = pool.observations(0);\\n\\n        // Calculate the available TWAP interval.\\n        uint256 availableTwapInterval = block.timestamp - oldestAvailableAge;\\n\\n        // Calculate the minimum cardinality, assuming 12.5 second block times.\\n        uint16 minimumCardinality = uint16((twapInterval_ * 10) / 125);\\n\\n        // Ensure the available TWAP interval and cardinality satisfy the TWAP criteria.\\n        if (availableTwapInterval < twapInterval_ || cardinality < minimumCardinality) {\\n            revert IUniswapV3PriceFeed__TwapCriteriaNotSatisfied();\\n        }\\n\\n        // Ensure the max price is not less than or equal to zero.\\n        if (maxPrice_ <= 0) revert IUniswapV3PriceFeed__MaxPriceLessThanOrEqualToZero();\\n\\n        token0Decimals = token0.decimals();\\n        token1Decimals = token1.decimals();\\n        twapInterval = twapInterval_;\\n        maxPrice = maxPrice_;\\n    }\\n\\n    /// PUBLIC CONSTANT FUNCTIONS ///\\n\\n    /// @inheritdoc IAggregatorV3\\n    function decimals() external pure override returns (uint8) {\\n        return 8;\\n    }\\n\\n    /// @inheritdoc IAggregatorV3\\n    function description() external view override returns (string memory) {\\n        return string.concat(baseAsset.symbol(), \\\" / \\\", quoteAsset.symbol());\\n    }\\n\\n    /// @inheritdoc IAggregatorV3\\n    function version() external pure override returns (uint256) {\\n        return 1;\\n    }\\n\\n    /// @inheritdoc IAggregatorV3\\n    function getRoundData(uint80 roundId_)\\n        external\\n        view\\n        override\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        )\\n    {\\n        return (roundId_, getPriceInternal(), 0, 0, 0);\\n    }\\n\\n    /// @inheritdoc IAggregatorV3\\n    function latestRoundData()\\n        external\\n        view\\n        override\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        )\\n    {\\n        return (0, getPriceInternal(), 0, block.timestamp, 0);\\n    }\\n\\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\\n\\n    /// @inheritdoc IUniswapV3PriceFeed\\n    function setMaxPrice(int256 maxPrice_) external override onlyOwner {\\n        if (maxPrice_ <= 0) revert IUniswapV3PriceFeed__MaxPriceLessThanOrEqualToZero();\\n        maxPrice = maxPrice_;\\n    }\\n\\n    /// INTERNAL CONSTANT FUNCTIONS ///\\n\\n    /// @dev Returns Chainlink-compatible price data from the Uniswap V3 pool. If the quote asset is token1,\\n    /// the formula used is:\\n    ///\\n    ///          sqrtPriceX96^2\\n    /// price = ----------------\\n    ///               Q192\\n    ///\\n    /// Otherwise, the formula is:\\n    ///\\n    ///               Q192\\n    /// price = ----------------\\n    ///          sqrtPriceX96^2\\n    ///\\n    /// @dev See OracleLibrary.sol in the Uniswap V3 periphery for more details:\\n    /// https://github.com/Uniswap/v3-periphery/blob/v1.3.0/contracts/libraries/OracleLibrary.sol\\n    ///\\n    /// @return price The Chainlink-compatible price of the other asset in terms of the quote asset.\\n    function getPriceInternal() internal view returns (int256 price) {\\n        uint32[] memory secondsAgo = new uint32[](2);\\n        secondsAgo[0] = twapInterval;\\n        secondsAgo[1] = 0;\\n\\n        (int56[] memory tickCumulatives, ) = pool.observe(secondsAgo);\\n        int24 tick = int24((tickCumulatives[1] - tickCumulatives[0]) / int32(twapInterval));\\n        uint160 sqrtPriceX96 = TickMath.getSqrtRatioAtTick(tick);\\n\\n        if (quoteAsset == token1) {\\n            // Calculate the Chainlink-compatible price of token0 in terms of token1\\n            price = int256(\\n                FullMath.mulDiv(sqrtPriceX96, sqrtPriceX96, (1 << 192) / 10**(8 + token0Decimals)) / 10**token1Decimals\\n            );\\n        } else {\\n            // Calculate the Chainlink-compatible price of token1 in terms of token0\\n            price = int256(FullMath.mulDiv(sqrtPriceX96, sqrtPriceX96, (1 << 192) / 10**(8 + token0Decimals)));\\n            if (price == 0) return int256(10**(16 + token1Decimals));\\n            price = int256(10**(16 + token1Decimals)) / price;\\n        }\\n        if (price > maxPrice) return maxPrice;\\n        if (price == 0) return 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"@prb/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\nimport \\\"./IOwnable.sol\\\";\\n\\n/// @notice Emitted when the caller is not the owner.\\nerror Ownable__NotOwner(address owner, address caller);\\n\\n/// @notice Emitted when setting the owner to the zero address.\\nerror Ownable__OwnerZeroAddress();\\n\\n/// @title Ownable\\n/// @author Paul Razvan Berg\\ncontract Ownable is IOwnable {\\n    /// PUBLIC STORAGE ///\\n\\n    /// @inheritdoc IOwnable\\n    address public override owner;\\n\\n    /// MODIFIERS ///\\n\\n    /// @notice Throws if called by any account other than the owner.\\n    modifier onlyOwner() {\\n        if (owner != msg.sender) {\\n            revert Ownable__NotOwner(owner, msg.sender);\\n        }\\n        _;\\n    }\\n\\n    /// CONSTRUCTOR ///\\n\\n    /// @notice Initializes the contract setting the deployer as the initial owner.\\n    constructor() {\\n        address msgSender = msg.sender;\\n        owner = msgSender;\\n        emit TransferOwnership(address(0), msgSender);\\n    }\\n\\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\\n\\n    /// @inheritdoc IOwnable\\n    function _renounceOwnership() public virtual override onlyOwner {\\n        emit TransferOwnership(owner, address(0));\\n        owner = address(0);\\n    }\\n\\n    /// @inheritdoc IOwnable\\n    function _transferOwnership(address newOwner) public virtual override onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert Ownable__OwnerZeroAddress();\\n        }\\n        emit TransferOwnership(owner, newOwner);\\n        owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@prb/contracts/token/erc20/IErc20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\n/// @title IErc20\\n/// @author Paul Razvan Berg\\n/// @notice Implementation for the Erc20 standard.\\n///\\n/// We have followed general OpenZeppelin guidelines: functions revert instead of returning\\n/// `false` on failure. This behavior is nonetheless conventional and does not conflict with\\n/// the with the expectations of Erc20 applications.\\n///\\n/// Additionally, an {Approval} event is emitted on calls to {transferFrom}. This allows\\n/// applications to reconstruct the allowance for all accounts just by listening to said\\n/// events. Other implementations of the Erc may not emit these events, as it isn't\\n/// required by the specification.\\n///\\n/// Finally, the non-standard {decreaseAllowance} and {increaseAllowance} functions have been\\n/// added to mitigate the well-known issues around setting allowances.\\n///\\n/// @dev Forked from OpenZeppelin\\n/// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/token/ERC20/ERC20.sol\\ninterface IErc20 {\\n    /// EVENTS ///\\n\\n    /// @notice Emitted when an approval happens.\\n    /// @param owner The address of the owner of the tokens.\\n    /// @param spender The address of the spender.\\n    /// @param amount The maximum amount that can be spent.\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /// @notice Emitted when a transfer happens.\\n    /// @param from The account sending the tokens.\\n    /// @param to The account receiving the tokens.\\n    /// @param amount The amount of tokens transferred.\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /// CONSTANT FUNCTIONS ///\\n\\n    /// @notice Returns the remaining number of tokens that `spender` will be allowed to spend\\n    /// on behalf of `owner` through {transferFrom}. This is zero by default.\\n    ///\\n    /// @dev This value changes when {approve} or {transferFrom} are called.\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /// @notice Returns the amount of tokens owned by `account`.\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Returns the number of decimals used to get its user representation.\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Returns the name of the token.\\n    function name() external view returns (string memory);\\n\\n    /// @notice Returns the symbol of the token, usually a shorter version of the name.\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Returns the amount of tokens in existence.\\n    function totalSupply() external view returns (uint256);\\n\\n    /// NON-CONSTANT FUNCTIONS ///\\n\\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    ///\\n    /// @dev Emits an {Approval} event.\\n    ///\\n    /// IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may\\n    /// use both the old and the new allowance by unfortunate transaction ordering. One possible solution\\n    /// to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired\\n    /// value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - `spender` cannot be the zero address.\\n    ///\\n    /// @return a boolean value indicating whether the operation succeeded.\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /// @notice Atomically decreases the allowance granted to `spender` by the caller.\\n    ///\\n    /// @dev Emits an {Approval} event indicating the updated allowance.\\n    ///\\n    /// This is an alternative to {approve} that can be used as a mitigation for problems described\\n    /// in {Erc20Interface-approve}.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - `spender` cannot be the zero address.\\n    /// - `spender` must have allowance for the caller of at least `subtractedAmount`.\\n    function decreaseAllowance(address spender, uint256 subtractedAmount) external returns (bool);\\n\\n    /// @notice Atomically increases the allowance granted to `spender` by the caller.\\n    ///\\n    /// @dev Emits an {Approval} event indicating the updated allowance.\\n    ///\\n    /// This is an alternative to {approve} that can be used as a mitigation for the problems described above.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - `spender` cannot be the zero address.\\n    function increaseAllowance(address spender, uint256 addedAmount) external returns (bool);\\n\\n    /// @notice Moves `amount` tokens from the caller's account to `recipient`.\\n    ///\\n    /// @dev Emits a {Transfer} event.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - `recipient` cannot be the zero address.\\n    /// - The caller must have a balance of at least `amount`.\\n    ///\\n    /// @return a boolean value indicating whether the operation succeeded.\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /// @notice Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount`\\n    /// `is then deducted from the caller's allowance.\\n    ///\\n    /// @dev Emits a {Transfer} event and an {Approval} event indicating the updated allowance. This is\\n    /// not required by the Erc. See the note at the beginning of {Erc20}.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - `sender` and `recipient` cannot be the zero address.\\n    /// - `sender` must have a balance of at least `amount`.\\n    /// - The caller must have approed `sender` to spent at least `amount` tokens.\\n    ///\\n    /// @return a boolean value indicating whether the operation succeeded.\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/oracles/IUniswapV3PriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.4;\\n\\nimport \\\"@prb/contracts/token/erc20/IErc20.sol\\\";\\nimport \\\"../external/chainlink/IAggregatorV3.sol\\\";\\nimport \\\"../external/uniswap/interfaces/IUniswapV3Pool.sol\\\";\\n\\n/// @title IUniswapV3PriceFeed\\n/// @author Hifi\\n/// @notice Chainlink-compatible price feed for Uniswap V3 pools.\\ninterface IUniswapV3PriceFeed is IAggregatorV3 {\\n    /// CUSTOM ERRORS ///\\n\\n    /// @notice Emitted when the quote asset is not in the pool.\\n    error IUniswapV3PriceFeed__QuoteAssetNotInPool(IErc20 quoteAsset);\\n\\n    /// @notice Emitted when the TWAP criteria is not satisfied.\\n    error IUniswapV3PriceFeed__TwapCriteriaNotSatisfied();\\n\\n    /// @notice Emitted when the max price is less than or equal to zero.\\n    error IUniswapV3PriceFeed__MaxPriceLessThanOrEqualToZero();\\n\\n    /// CONSTANT FUNCTIONS ///\\n\\n    /// @notice The base asset for price calculations.\\n    function baseAsset() external view returns (IErc20);\\n\\n    /// @notice The upper price band for the price feed.\\n    function maxPrice() external view returns (int256);\\n\\n    /// @notice The Uniswap V3 pool.\\n    function pool() external view returns (IUniswapV3Pool);\\n\\n    /// @notice The quote asset for price calculations.\\n    function quoteAsset() external view returns (IErc20);\\n\\n    /// @notice The time window for the TWAP calculation.\\n    function twapInterval() external view returns (uint32);\\n\\n    /// NON-CONSTANT FUNCTIONS ///\\n\\n    /// @notice Updates the max price.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - The caller must be the owner.\\n    /// - The new max price must be greater than zero.\\n    ///\\n    /// @param maxPrice_ The new max price.\\n    function setMaxPrice(int256 maxPrice_) external;\\n}\\n\"\r\n    },\r\n    \"contracts/external/chainlink/IAggregatorV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/// @title IAggregatorV3\\n/// @author Hifi\\n/// @dev Forked from Chainlink\\n/// https://github.com/smartcontractkit/chainlink/blob/v1.2.0/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\ninterface IAggregatorV3 {\\n    function decimals() external view returns (uint8);\\n\\n    function description() external view returns (string memory);\\n\\n    function version() external view returns (uint256);\\n\\n    /// getRoundData and latestRoundData should both raise \\\"No data present\\\" if they do not have\\n    /// data to report, instead of returning unset values which could be misinterpreted as\\n    /// actual reported values.\\n    function getRoundData(uint80 _roundId)\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/external/uniswap/interfaces/IUniswapV3Pool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.4;\\n\\n/// @title IUniswapV3Pool\\n/// @author Hifi\\n/// @dev Forked from Uniswap\\n/// https://github.com/Uniswap/v3-core/blob/v1.0.0/contracts/interfaces/IUniswapV3Factory.sol\\ninterface IUniswapV3Pool {\\n    function factory() external view returns (address);\\n\\n    function fee() external view returns (uint24);\\n\\n    function initialize(uint160 sqrtPriceX96) external;\\n\\n    function maxLiquidityPerTick() external view returns (uint128);\\n\\n    function observe(uint32[] calldata secondsAgos)\\n        external\\n        view\\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\\n\\n    function observations(uint256 index)\\n        external\\n        view\\n        returns (\\n            uint32 blockTimestamp,\\n            int56 tickCumulative,\\n            uint160 secondsPerLiquidityCumulativeX128,\\n            bool initialized\\n        );\\n\\n    function slot0()\\n        external\\n        view\\n        returns (\\n            uint160 sqrtPriceX96,\\n            int24 tick,\\n            uint16 observationIndex,\\n            uint16 observationCardinality,\\n            uint16 observationCardinalityNext,\\n            uint8 feeProtocol,\\n            bool unlocked\\n        );\\n\\n    function tickSpacing() external view returns (int24);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/external/uniswap/libraries/TickMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// solhint-disable code-complexity, max-line-length, no-inline-assembly, var-name-mixedcase\\npragma solidity ^0.8.4;\\n\\n/// @title TickMath\\n/// @author Hifi\\n/// @dev Forked from Euler\\n/// https://github.com/euler-xyz/euler-contracts/blob/dfaa7788b17ac7c2a826a3ed242d7181998a778f/contracts/vendor/TickMath.sol\\nlibrary TickMath {\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n    int24 internal constant MIN_TICK = -887272;\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\n    /// at the given tick\\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\\n        unchecked {\\n            uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\\n            require(absTick <= uint256(int256(MAX_TICK)), \\\"T\\\");\\n\\n            uint256 ratio = absTick & 0x1 != 0\\n                ? 0xfffcb933bd6fad37aa2d162d1a594001\\n                : 0x100000000000000000000000000000000;\\n            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n            if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n            // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n            // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n            // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\\n        }\\n    }\\n\\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n    /// ever return.\\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\n        unchecked {\\n            // second inequality must be < because the price can never reach the price at the max tick\\n            require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, \\\"R\\\");\\n            uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n            uint256 r = ratio;\\n            uint256 msb = 0;\\n\\n            assembly {\\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(5, gt(r, 0xFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(4, gt(r, 0xFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(3, gt(r, 0xFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(2, gt(r, 0xF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(1, gt(r, 0x3))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := gt(r, 0x1)\\n                msb := or(msb, f)\\n            }\\n\\n            if (msb >= 128) r = ratio >> (msb - 127);\\n            else r = ratio << (127 - msb);\\n\\n            int256 log_2 = (int256(msb) - 128) << 64;\\n\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(63, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(62, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(61, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(60, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(59, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(58, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(57, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(56, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(55, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(54, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(53, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(52, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(51, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(50, f))\\n            }\\n\\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\\n\\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\n\\n            tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/uniswap/libraries/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// solhint-disable max-line-length, no-inline-assembly, reason-string\\npragma solidity ^0.8.4;\\n\\n/// @title FullMath\\n/// @author Hifi\\n/// @dev Forked from Euler\\n/// https://github.com/euler-xyz/euler-contracts/blob/dfaa7788b17ac7c2a826a3ed242d7181998a778f/contracts/vendor/FullMath.sol\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = a * b\\n            // Compute the product mod 2**256 and mod 2**256 - 1\\n            // then use the Chinese Remainder Theorem to reconstruct\\n            // the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2**256 + prod0\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(a, b, not(0))\\n                prod0 := mul(a, b)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division\\n            if (prod1 == 0) {\\n                require(denominator > 0);\\n                assembly {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n\\n            // Make sure the result is less than 2**256.\\n            // Also prevents denominator == 0\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\n            // Compute remainder using mulmod\\n            uint256 remainder;\\n            assembly {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number\\n            assembly {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator\\n            // Compute largest power of two divisor of denominator.\\n            // Always >= 1.\\n            uint256 twos = denominator & (~denominator + 1);\\n\\n            // Divide denominator by power of two\\n            assembly {\\n                denominator := div(denominator, twos)\\n            }\\n\\n            // Divide [prod1 prod0] by the factors of two\\n            assembly {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos.\\n            // If twos is zero, then it becomes one\\n            assembly {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2**256\\n            // Now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the precoditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            result = mulDiv(a, b, denominator);\\n            if (mulmod(a, b, denominator) > 0) {\\n                require(result < type(uint256).max);\\n                result++;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@prb/contracts/access/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\n/// @title IOwnable\\n/// @author Paul Razvan Berg\\n/// @notice Contract module that provides a basic access control mechanism, where there is an\\n/// account (an owner) that can be granted exclusive access to specific functions.\\n///\\n/// By default, the owner account will be the one that deploys the contract. This can later be\\n/// changed with {transfer}.\\n///\\n/// This module is used through inheritance. It will make available the modifier `onlyOwner`,\\n/// which can be applied to your functions to restrict their use to the owner.\\n///\\n/// @dev Forked from OpenZeppelin\\n/// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/access/Ownable.sol\\ninterface IOwnable {\\n    /// EVENTS ///\\n\\n    /// @notice Emitted when ownership is transferred.\\n    /// @param oldOwner The address of the old owner.\\n    /// @param newOwner The address of the new owner.\\n    event TransferOwnership(address indexed oldOwner, address indexed newOwner);\\n\\n    /// NON-CONSTANT FUNCTIONS ///\\n\\n    /// @notice Leaves the contract without owner, so it will not be possible to call `onlyOwner`\\n    /// functions anymore.\\n    ///\\n    /// WARNING: Doing this will leave the contract without an owner, thereby removing any\\n    /// functionality that is only available to the owner.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - The caller must be the owner.\\n    function _renounceOwnership() external;\\n\\n    /// @notice Transfers the owner of the contract to a new account (`newOwner`). Can only be\\n    /// called by the current owner.\\n    /// @param newOwner The account of the new owner.\\n    function _transferOwnership(address newOwner) external;\\n\\n    /// CONSTANT FUNCTIONS ///\\n\\n    /// @notice The address of the owner account or contract.\\n    /// @return The address of the owner.\\n    function owner() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000,\r\n      \"details\": {\r\n        \"yul\": true\r\n      }\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IUniswapV3Pool\",\"name\":\"pool_\",\"type\":\"address\"},{\"internalType\":\"contract IErc20\",\"name\":\"quoteAsset_\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"twapInterval_\",\"type\":\"uint32\"},{\"internalType\":\"int256\",\"name\":\"maxPrice_\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"IUniswapV3PriceFeed__MaxPriceLessThanOrEqualToZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract IErc20\",\"name\":\"quoteAsset\",\"type\":\"address\"}],\"name\":\"IUniswapV3PriceFeed__QuoteAssetNotInPool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IUniswapV3PriceFeed__TwapCriteriaNotSatisfied\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"Ownable__NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Ownable__OwnerZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"TransferOwnership\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"_transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseAsset\",\"outputs\":[{\"internalType\":\"contract IErc20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId_\",\"type\":\"uint80\"}],\"name\":\"getRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"contract IUniswapV3Pool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quoteAsset\",\"outputs\":[{\"internalType\":\"contract IErc20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"maxPrice_\",\"type\":\"int256\"}],\"name\":\"setMaxPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"twapInterval\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "UniswapV3PriceFeed", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000ed16fc66ca042aacd5292ea9a64fde7afb7c233c000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000000000000000000000000000000000000000a39300000000000000000000000000000000000000000000000000000004a817c800", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}