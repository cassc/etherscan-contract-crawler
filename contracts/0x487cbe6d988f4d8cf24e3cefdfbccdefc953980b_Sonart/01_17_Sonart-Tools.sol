// SPDX-License-Identifier: MIT
/**
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
░██████╗░█████╗░███╗░░██╗░█████╗░██████╗░████████╗░░░░░░
██╔════╝██╔══██╗████╗░██║██╔══██╗██╔══██╗╚══██╔══╝░░░░░░
╚█████╗░██║░░██║██╔██╗██║███████║██████╔╝░░░██║░░░░░░░░░
░╚═══██╗██║░░██║██║╚████║██╔══██║██╔══██╗░░░██║░░░░░░░░░
██████╔╝╚█████╔╝██║░╚███║██║░░██║██║░░██║░░░██║░░░░░░░░░
╚═════╝░░╚════╝░╚═╝░░╚══╝╚═╝░░╚═╝╚═╝░░╚═╝░░░╚═╝░░░░░░░░░
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
 *
 * @title Sonart-tools ERC721 Contract
 * @author Elfoly
 * @dev Inherits the OpenZeppelin ERC721 implentation
 */
pragma solidity >=0.7.0 <0.9.0;
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol"; 
import "./DefaultOperatorFilterer.sol";

contract Sonart is ERC721, Ownable, DefaultOperatorFilterer {
  using Strings for uint256;
  /**
   * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number
   * of elements in a mapping, issuing ERC721 ids, or counting request ids.
   * @notice Used to keep track of minted nfts
   */
  using Counters for Counters.Counter;
  Counters.Counter private supply;
  /** 
   * @dev This is some variables stored, 
   * that will be used for generating nft
   * @notice `uriPrefix` Where the nft metadata are stored 
   * `contractURI` used for royalties
   */
  string public uriPrefix = "ipfs://bafybeic6owddccwlym3gcxu2fkomayyhkjy7xamf6sr7mdgjtaphsst26a/";
  string public uriSuffix = ".json";
  string public contractURI;

  /**
   *@dev this is used to map and track each wallet mint
   *@notice Used to make each wallet mint once from Goldlist 
   */
  mapping(address => uint256) public mintedWallets;
  
  //Pricing and supply
  uint256 public maxSupply = 5000;
  uint256 public Public_cost = 0.15 ether;
  uint256 public Whitelist_cost = 0.09 ether;
  uint256 public Goldlist_cost = 0.05 ether;
  
  ///@dev _root used at Merkleproof for whitelist validation 
  bytes32 public Goldlist_root;
  bytes32 public Whitelist_root;



  /**
   * @dev this checks if minting is pause
   * @return `true` by default 
   */ 
  bool public isWLPaused = true;
  bool public isGLPaused = true;
  bool public isPublicMintpaused = true;




  constructor() ERC721("Sonart", "ST") {
   contractURI = "https://ipfs.io/ipfs/bafybeiehmmhh2tnheqz3nmafpcvf3uwxvvu4qm34xok5yxgyzgzvah4yre/contractURI.json";
   Goldlist_root = 0x105dc2e0b909599b382458f528479118751d4201b56a0c04523c1978bdb3b215;
   Whitelist_root = 0x5f1fb32dd41fba5de0f7cf133a19d6a1ca4998aa0d31f797f532df6936d7a210;
  }
  

  function CurrentSupply() public view returns (uint256) {
    return supply.current();
    ///@returns current Minted supply 
  }

  /**
   * @notice Whitelist mint function
   * @param proof is a generated bytes32 created By the Minting dapp from msg.sender
   * will be discussed later...
   * @param _mintAmount The amount of tokens the minter will receive
   */
  function WhitelistMint(uint256 _mintAmount, bytes32[] memory proof) public payable {
    require(supply.current() + _mintAmount <= maxSupply, "Sold out!");
    require(!isWLPaused, "Whitelist Mint is Closed!");
    require(isWhitelisted(proof, keccak256(abi.encodePacked(msg.sender))), "Not Whitelisted");
    require(msg.value >= (Whitelist_cost * _mintAmount), "Insufficient funds!");
    _mintLoop(msg.sender, _mintAmount);
    /**
     * @dev if all the above requirements are satisfied 
     * the mint will go through _mintloop()
     */
  }

  /**
   * @notice Goldlist mint function
   * @dev this function acts like whitelist
   */
  function GoldlistMint( bytes32[] memory proof) public payable {
    uint256 _mintAmount = 1 ;
    require(supply.current() + _mintAmount <= maxSupply, "Sold out!");
    require(!isGLPaused, "Goldlist Mint is Closed!");
    require(isGoldlisted(proof, keccak256(abi.encodePacked(msg.sender))), "Not Goldlisted");
    require(msg.value >= (Goldlist_cost * _mintAmount), "Insufficient funds!");
    require(mintedWallets[msg.sender] < 1, "Only one per wallet !");
    mintedWallets[msg.sender]++;
    _mintLoop(msg.sender, _mintAmount);
  }

  /**
   * @notice This function checks if the minter is whitelisted or not
   * @param leaf is the hashed value of msg.sender by keccak256
   * @dev This function Inherits MerkleProof library  
   * It basically takes proof which is create from msg.sender address
   * at the minting dapp,takes leaf, and root
   * Root is a bytes32 which is created by a array of whitelisted wallets 
   *
   * See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol for more info
   */

  function isWhitelisted(bytes32[] memory proof, bytes32 leaf) public view returns (bool) {
    return MerkleProof.verify(proof, Whitelist_root, leaf);
    ///@returns boolean true if whitelisted otherwise false
  }

  function isGoldlisted(bytes32[] memory proof, bytes32 leaf) public view returns (bool) {
    return MerkleProof.verify(proof, Goldlist_root, leaf);
  }


  ///@notice public Mint Function
  function PublicMint(uint256 _mintAmount) public payable {
    require(supply.current() + _mintAmount <= maxSupply, "Sold out!");
    require(!isPublicMintpaused, "Public Mint is Closed!");
    require(msg.value >= (Public_cost * _mintAmount) , "Insufficient funds!");
    _mintLoop(msg.sender, _mintAmount);
  }
  /**
   *@notice Owner Mint Function
   *Can only be called by the owner of the contract
   *@param _receiver the receiver of the nft
   */
  function mintForOwner(uint256 _mintAmount, address _receiver) public onlyOwner {
    require(supply.current() + _mintAmount <= maxSupply, "Max supply exceeded!");
    _mintLoop(_receiver, _mintAmount);
  }

  //checks if the wallet inserted has any nft tokens
  function walletOfOwner(address _owner) public view returns (uint256[] memory) {
    uint256 ownerTokenCount = balanceOf(_owner);
    uint256[] memory ownedTokenIds = new uint256[](ownerTokenCount);
    uint256 currentTokenId = 1;
    uint256 ownedTokenIndex = 0;

    while (ownedTokenIndex < ownerTokenCount && currentTokenId <= maxSupply) {
      address currentTokenOwner = ownerOf(currentTokenId);

      if (currentTokenOwner == _owner) {
        ownedTokenIds[ownedTokenIndex] = currentTokenId;

        ownedTokenIndex++;
      }

      currentTokenId++;
    }

    return ownedTokenIds;
  }
  
  function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {
    require(_exists(_tokenId),"ERC721Metadata: URI query for nonexistent token");
    string memory currentBaseURI = _baseURI();
    return bytes(currentBaseURI).length > 0 ? string(abi.encodePacked(currentBaseURI, _tokenId.toString(), uriSuffix)) : "";
    /// @return token metadata url
  }

  
  /**
   *@notice Works as a reveal mechanism
   *As its used to change the nft metadata
   */
  function setUriPrefix(string memory _uriPrefix) public onlyOwner {
    uriPrefix = _uriPrefix;
  }

  /**
   * @notice Used to open or close sales 
   * @dev this function can only be called by the owner
   */ 
  function setIsWLPaused(bool _state) public onlyOwner {
    isWLPaused = _state;
  }

  function setIsGLPaused(bool _state) public onlyOwner {
    isGLPaused = _state;
  }
  
  function setIsPublicMintpaused(bool _state) public onlyOwner {
    isPublicMintpaused = _state;
  }

  function setGLroot(bytes32 _root) public onlyOwner {
      Goldlist_root = _root;
  }

  function setWLroot(bytes32 __root) public onlyOwner {
      Whitelist_root = __root;
  }


  function _baseURI() internal view virtual override returns (string memory) {
    return uriPrefix;
  ///@return the metadata base url
  }

  function supportsInterface(bytes4 interfaceId) public view override(ERC721) returns (bool) {
    return super.supportsInterface(interfaceId);
  }
  
  ///@notice basically used to withdraw funds from the contract
  function withdraw() public onlyOwner {
    (bool os, ) = payable(owner()).call{value: address(this).balance}("");
    require(os);
  }

  //handles mint Functions 
  function _mintLoop(address _receiver, uint256 _mintAmount) internal {
    for (uint256 i = 0; i < _mintAmount; i++) {
      supply.increment();
      _safeMint(_receiver, supply.current());
    }
  }


  /**
   * @dev This is the new opensea tool to enforce royalties on-chain
   * @notice Used to force royalties on sales
   */
  function transferFrom(address from, address to, uint256 tokenId) public override onlyAllowedOperator(from) {
    super.transferFrom(from, to, tokenId);
  }

  function safeTransferFrom(address from, address to, uint256 tokenId) public override onlyAllowedOperator(from) {
    super.safeTransferFrom(from, to, tokenId);
  }

  function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public override onlyAllowedOperator(from){
    super.safeTransferFrom(from, to, tokenId, data);
  }
}