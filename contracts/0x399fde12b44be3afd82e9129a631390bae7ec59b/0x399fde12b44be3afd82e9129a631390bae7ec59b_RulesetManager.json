{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC1155/ERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"./extensions/IERC1155MetadataURI.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\n    using Address for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping(uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    constructor(string memory uri_) {\\n        _setURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) public view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: address zero is not a valid owner\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not token owner or approved\\\"\\n        );\\n        _safeTransferFrom(from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not token owner or approved\\\"\\n        );\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n        _balances[id][to] += amount;\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n            _balances[id][to] += amount;\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _balances[id][to] += amount;\\n        emit TransferSingle(operator, address(0), to, id, amount);\\n\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] += amounts[i];\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `from`\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `from` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n\\n        emit TransferSingle(operator, from, address(0), id, amount);\\n\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n        }\\n\\n        emit TransferBatch(operator, from, address(0), ids, amounts);\\n\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC1155: setting approval status for self\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non-ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\n                bytes4 response\\n            ) {\\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non-ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/extensions/ERC1155Supply.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC1155.sol\\\";\\n\\n/**\\n * @dev Extension of ERC1155 that adds tracking of total supply per id.\\n *\\n * Useful for scenarios where Fungible and Non-fungible tokens have to be\\n * clearly identified. Note: While a totalSupply of 1 might mean the\\n * corresponding is an NFT, there is no guarantees that no other token with the\\n * same id are not going to be minted.\\n */\\nabstract contract ERC1155Supply is ERC1155 {\\n    mapping(uint256 => uint256) private _totalSupply;\\n\\n    /**\\n     * @dev Total amount of tokens in with a given id.\\n     */\\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\\n        return _totalSupply[id];\\n    }\\n\\n    /**\\n     * @dev Indicates whether any token exist with a given id, or not.\\n     */\\n    function exists(uint256 id) public view virtual returns (bool) {\\n        return ERC1155Supply.totalSupply(id) > 0;\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_beforeTokenTransfer}.\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        if (from == address(0)) {\\n            for (uint256 i = 0; i < ids.length; ++i) {\\n                _totalSupply[ids[i]] += amounts[i];\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            for (uint256 i = 0; i < ids.length; ++i) {\\n                uint256 id = ids[i];\\n                uint256 amount = amounts[i];\\n                uint256 supply = _totalSupply[id];\\n                require(supply >= amount, \\\"ERC1155: burn amount exceeds totalSupply\\\");\\n                unchecked {\\n                    _totalSupply[id] = supply - amount;\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20.sol\\\";\\nimport \\\"../../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        _spendAllowance(account, _msgSender(), amount);\\n        _burn(account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Carbon21.sol\": {\r\n      \"content\": \"/* \\n *   Carbon21 Project - For real Diamond Hands\\n *\\n *   Learn more: https://carbon21.io\\n */\\n\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\\\";\\n\\ncontract Carbon21 is ERC20, ERC20Burnable {\\n    uint256 public originalSupply;\\n\\n    event Burn(address indexed burner, uint256 amount);\\n\\n    constructor() ERC20(\\\"Carbon21\\\", \\\"C21\\\") {\\n        originalSupply = 210e6 * 10**decimals(); // Initial supply of 210 million $C21\\n        _mint(msg.sender, originalSupply);\\n    }\\n\\n    function burn(uint256 amount) public virtual override {\\n        super.burn(amount);\\n        emit Burn(_msgSender(), amount);\\n    }\\n\\n    function burnFrom(address account, uint256 amount) public virtual override {\\n        super.burnFrom(account, amount);\\n        emit Burn(account, amount);\\n    }\\n}\"\r\n    },\r\n    \"contracts/DiamondCollection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./Carbon21.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/IERC2981.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\ncontract DiamondCollection is ERC1155Supply, Ownable, IERC2981 {\\n    using Strings for uint256;\\n\\n    // Tokens\\n    address public carbon21Address;\\n    address public tokenAddress;\\n\\n    // Roles\\n    address public minter;\\n    address public scientists;\\n\\n    //collection details\\n    string public name;\\n    string public externalURI;\\n    string public symbol;\\n    uint256 public lockPercentage;\\n    uint256 public burnAmount = 0;\\n    string public imageURI;\\n    uint256 public minLockDuration = 172800; // 30 days\\n    uint256 public maxLockDuration = 1051200; // 6 months\\n    uint256 public cardMaxSupply = 100001;\\n    uint256 public cardMinSupply = 20;\\n    bool public isDirectory = true;\\n    uint256 public maxRoyalty = 500;\\n\\n    enum ValidationStatus { Waiting, Accepted, Refused }\\n    \\n    struct Blueprint {\\n        uint256 nftId;\\n        address creator;\\n        string creatorName;\\n        uint256 maxSupply;\\n        uint256 minted;\\n        string name;\\n        string description;\\n        string fileExtension;\\n        string animationFileExtension;\\n        bool locked;\\n    }\\n\\n    struct BlueprintProperties {\\n        uint256 startDate;\\n        uint256 endDate;\\n        uint256 creationDate;\\n        uint256 ruleSetId;\\n        uint256 price;\\n        uint256 royaltyFee;\\n        address royaltyRecipient;\\n        ValidationStatus validationStatus;\\n    }\\n\\n    struct BlueprintAttributes {\\n        mapping(string => string) attributes;\\n        mapping(string => uint256) numericAttributes;\\n        mapping(string => string) numericDisplayTypes;\\n        mapping(string => uint256) numericMaxValues;\\n        string[] attributeKeys;\\n        string[] numericAttributeKeys;\\n    }\\n\\n    mapping(uint256 => Blueprint) public blueprints;\\n    mapping(uint256 => BlueprintProperties) public blueprintProperties;\\n    mapping(uint256 => BlueprintAttributes) private blueprintAttributes;\\n    mapping(uint256 => uint256) public tokenIdToBlueprintId;\\n    uint256 public blueprintCount = 0;\\n    uint256 public nftCount = 0;\\n\\n    event BlueprintCreated(uint256 blueprintId, address creator, uint256 price, uint256 maxSupply);\\n    event BlueprintUpdated(uint256 indexed _blueprintId);\\n    event BlueprintValidated(uint256 blueprintId, uint256 nftId, ValidationStatus status);\\n    event BlueprintRefused(uint256 blueprintId, ValidationStatus status);\\n    event NFTMinted(address indexed to, uint256 tokenId, uint256 amount);\\n    event PermanentURI(string _uri, uint256 indexed _tokenId);\\n\\n    modifier onlyMinter() {\\n        require(msg.sender == minter, \\\"Caller is not the minter\\\");\\n        _;\\n    }\\n\\n    modifier onlyScientists() {\\n        require(msg.sender == scientists, \\\"Caller is not the scientists\\\");\\n        _;\\n    }\\n\\n    modifier isUnlocked(uint256 blueprintId) {\\n        require(blueprints[blueprintId].locked == false, \\\"Blueprint is locked and can't be changed\\\");\\n        _;\\n    }\\n\\n    constructor(address _tokenAddress, string memory _imageURI, uint256 _lockPercentage, string memory _name, string memory _symbol) ERC1155(\\\"\\\") {\\n        tokenAddress = _tokenAddress;\\n        lockPercentage = _lockPercentage;\\n        name = _name;\\n        symbol = _symbol;\\n        imageURI = _imageURI;\\n        externalURI = \\\"https://carbon21.io/collection/original/\\\";\\n        carbon21Address = 0x2C642Cd3beD9b4e4EEEc493611779f13efB502F1;\\n\\n        // Initiate Minter and Scientists Roles to contract deployer\\n        minter = msg.sender;\\n        scientists = msg.sender;\\n\\n        // Initiate the Genesis Card without the mapping\\n        blueprints[0].nftId = 0;\\n        blueprints[0].creator = 0x082e8a9dA4397bc24ac22FAD57CD7063DC1cd58B;\\n        blueprints[0].creatorName = \\\"Onigiri\\\";\\n        blueprints[0].maxSupply = type(uint256).max;\\n        blueprints[0].minted = 1;\\n        blueprints[0].name = \\\"The Community\\\";\\n        blueprints[0].description = \\\"A memecoin is defined by its community. This card allows owners to become scientist and accept blueprints in the directory.\\\";\\n        blueprints[0].fileExtension = \\\".jpg\\\";\\n        blueprints[0].animationFileExtension = '';\\n        blueprints[0].locked = false;\\n        \\n        // Properties\\n        blueprintProperties[0].price = 0;\\n        blueprintProperties[0].ruleSetId = 0;\\n        blueprintProperties[0].creationDate = block.timestamp;\\n        blueprintProperties[0].startDate = 1700514000;\\n        blueprintProperties[0].endDate = type(uint256).max;\\n        blueprintProperties[0].royaltyFee = 0;\\n        blueprintProperties[0].royaltyRecipient = 0x082e8a9dA4397bc24ac22FAD57CD7063DC1cd58B;\\n        blueprintProperties[0].validationStatus = ValidationStatus.Accepted;\\n\\n        // Now set the attributes for the Genesis Card\\n        blueprintAttributes[0].attributes[\\\"Type\\\"] = \\\"Genesis\\\";\\n        blueprintAttributes[0].attributeKeys.push(\\\"Type\\\");\\n\\n        tokenIdToBlueprintId[0] = 0;\\n        _mint(msg.sender, 0, 1, \\\"\\\");\\n    }\\n\\n    function setLockPercentage(uint256 _lockPercentage) external onlyScientists {\\n        lockPercentage = _lockPercentage;\\n    }\\n\\n    function createBlueprint(\\n        address _creator,\\n        string memory _creatorName,\\n        uint256 _price,\\n        uint256 _maxSupply,\\n        uint256 _startDate,\\n        uint256 _endDate,\\n        uint256 _ruleSetId,\\n        string memory _name,\\n        string memory _description,\\n        string memory _fileExtension\\n    ) external {\\n        require(_startDate < _endDate || _endDate == 0, \\\"Start date should be before end date\\\");\\n        require( _maxSupply < cardMaxSupply && _maxSupply > cardMinSupply, \\\"Supply should be in the collection range\\\");\\n\\n        if (_creator != address(0)) {\\n            _creator = msg.sender;\\n        }\\n\\n        blueprintCount++;\\n        uint256 id = blueprintCount;\\n\\n        Blueprint storage newBlueprint = blueprints[id];\\n        newBlueprint.creator = _creator;\\n        newBlueprint.creatorName = _creatorName;\\n        newBlueprint.maxSupply = _maxSupply;\\n        newBlueprint.name = _name;\\n        newBlueprint.description = _description;\\n        newBlueprint.fileExtension = _fileExtension;\\n        newBlueprint.animationFileExtension = _fileExtension;\\n        newBlueprint.locked = false;\\n        \\n        BlueprintProperties storage properties = blueprintProperties[id];\\n        properties.ruleSetId = _ruleSetId;\\n        properties.startDate = _startDate == 0 ? block.timestamp : _startDate;\\n        properties.endDate = _endDate == 0 ? type(uint256).max : _endDate;\\n        properties.creationDate = block.timestamp;\\n        properties.price = _price;\\n        properties.royaltyRecipient = _creator;\\n        properties.validationStatus = ValidationStatus.Waiting;\\n\\n        if (burnAmount > 0) {\\n            Carbon21 carbonContract = Carbon21(carbon21Address);\\n            carbonContract.burnFrom(msg.sender, burnAmount);\\n        }\\n\\n        emit BlueprintCreated(blueprintCount, _creator, _price, _maxSupply);\\n    }\\n\\n    function lockBlueprint(uint256 _blueprintId) external {\\n        require(_blueprintId <= blueprintCount, \\\"Blueprint does not exist\\\");\\n        require(blueprintProperties[_blueprintId].validationStatus == ValidationStatus.Accepted, \\\"Can't lock a non-validated blueprint\\\");\\n        require(blueprints[_blueprintId].locked == false, \\\"Blueprint already locked\\\");\\n        require(msg.sender == blueprints[_blueprintId].creator, \\\"Only the creator can lock the blueprint\\\");\\n\\n        blueprints[_blueprintId].locked = true;\\n        emit PermanentURI(uri(blueprints[_blueprintId].nftId), blueprints[_blueprintId].nftId);\\n    }\\n\\n    function updateBlueprintSupply(uint256 _blueprintId, uint256 _maxSupply) external isUnlocked(_blueprintId) {\\n        checkBlueprintRequirementsForUpdate(_blueprintId, false, false);\\n        blueprints[_blueprintId].maxSupply = _maxSupply;\\n        emitBlueprintUpdated(_blueprintId);\\n    }\\n\\n    function updateBlueprintMintRules(uint256 _blueprintId, uint256 _ruleSetId) external isUnlocked(_blueprintId) {\\n        checkBlueprintRequirementsForUpdate(_blueprintId, true, false);\\n        blueprintProperties[_blueprintId].ruleSetId = _ruleSetId;\\n        emitBlueprintUpdated(_blueprintId);\\n    }\\n\\n    function updateMintTime(uint256 _blueprintId, uint256 _startDate, uint256 _endDate) external isUnlocked(_blueprintId) {\\n        checkBlueprintRequirementsForUpdate(_blueprintId, true, false);\\n        if(_startDate != 0) blueprintProperties[_blueprintId].startDate = _startDate;\\n        if(_endDate != 0) blueprintProperties[_blueprintId].endDate = _endDate;\\n        emitBlueprintUpdated(_blueprintId);\\n    }\\n\\n    function updateBlueprintPrice(uint256 _blueprintId, uint256 _price) external isUnlocked(_blueprintId) {\\n        checkBlueprintRequirementsForUpdate(_blueprintId, false, false);\\n        blueprintProperties[_blueprintId].price = _price;\\n        emitBlueprintUpdated(_blueprintId);\\n    }\\n\\n    function updateBlueprintInfo(uint256 _blueprintId, string memory _name, string memory _description, string memory _fileExtension, string memory _animationFileExtension) external isUnlocked(_blueprintId) {\\n        checkBlueprintRequirementsForUpdate(_blueprintId, false, true);\\n        blueprints[_blueprintId].name = _name;\\n        blueprints[_blueprintId].description = _description;\\n        blueprints[_blueprintId].fileExtension = _fileExtension;\\n        blueprints[_blueprintId].animationFileExtension = _animationFileExtension;\\n        emitBlueprintUpdated(_blueprintId);\\n    }\\n\\n    function setRoyalty(uint256 tokenId, address recipient, uint256 amount) public {\\n        uint256 _blueprintId = getBlueprintId(tokenId);\\n        checkBlueprintRequirementsForUpdate(_blueprintId, false, true);\\n        require(amount <= maxRoyalty, \\\"Royalty fee will exceed salePrice\\\");\\n        require(recipient != address(0), \\\"Recipient should be present\\\");\\n\\n        blueprintProperties[_blueprintId].royaltyFee = amount;\\n        blueprintProperties[_blueprintId].royaltyRecipient = recipient;\\n    }\\n\\n    function setBlueprintAttributes(\\n        uint256 _blueprintId,\\n        string[] memory stringAttributeKeys,\\n        string[] memory attributeValues,\\n        string[] memory numericAttributeKeys,\\n        uint256[] memory numericAttributeValues,\\n        uint256[] memory numericAttributeMaxValues,\\n        string[] memory numericAttributeDisplayTypes\\n    ) external isUnlocked(_blueprintId) {\\n        checkBlueprintRequirementsForUpdate(_blueprintId, false, true);\\n        require(stringAttributeKeys.length == attributeValues.length, \\\"String keys and values mismatch\\\");\\n        require(numericAttributeKeys.length == numericAttributeValues.length, \\\"Numeric keys and values mismatch\\\");\\n        require(numericAttributeKeys.length == numericAttributeDisplayTypes.length, \\\"Display types mismatch\\\");\\n        require(numericAttributeKeys.length == numericAttributeMaxValues.length, \\\"Max values mismatch\\\");\\n\\n        BlueprintAttributes storage attributes = blueprintAttributes[_blueprintId];\\n        // Clear existing attributes if they exist\\n        if (attributes.attributeKeys.length > 0 || attributes.numericAttributeKeys.length > 0) {\\n            for (uint i = 0; i < attributes.attributeKeys.length; i++) {\\n                delete attributes.attributes[attributes.attributeKeys[i]];\\n            }\\n            delete attributes.attributeKeys;\\n\\n            for (uint i = 0; i < attributes.numericAttributeKeys.length; i++) {\\n                delete attributes.numericAttributes[attributes.numericAttributeKeys[i]];\\n                delete attributes.numericDisplayTypes[attributes.numericAttributeKeys[i]];\\n                delete attributes.numericMaxValues[attributes.numericAttributeKeys[i]];\\n            }\\n            delete attributes.numericAttributeKeys;\\n        }\\n\\n        // Set or update string attributes\\n        for (uint i = 0; i < stringAttributeKeys.length; i++) {\\n            attributes.attributes[stringAttributeKeys[i]] = attributeValues[i];\\n            attributes.attributeKeys.push(stringAttributeKeys[i]);\\n        }\\n\\n        // Set or update numeric attributes\\n        for (uint i = 0; i < numericAttributeKeys.length; i++) {\\n            attributes.numericAttributes[numericAttributeKeys[i]] = numericAttributeValues[i];\\n            attributes.numericDisplayTypes[numericAttributeKeys[i]] = numericAttributeDisplayTypes[i];\\n            attributes.numericMaxValues[numericAttributeKeys[i]] = numericAttributeMaxValues[i];\\n            attributes.numericAttributeKeys.push(numericAttributeKeys[i]);\\n        }\\n        emitBlueprintUpdated(_blueprintId);\\n    }\\n\\n    function checkBlueprintRequirementsForUpdate(uint256 _blueprintId, bool scientistsAllowed, bool allowedAfterValidation) internal view {\\n        require(_blueprintId <= blueprintCount, \\\"Blueprint does not exist\\\");\\n        if (scientistsAllowed == false) {\\n            require((msg.sender == blueprints[_blueprintId].creator), \\\"Only the creator can modify blueprint\\\");\\n        } else {\\n            require((msg.sender == blueprints[_blueprintId].creator) || (msg.sender == scientists), \\\"Only the creator or scientists can modify blueprint\\\");\\n        }\\n        if (allowedAfterValidation) {\\n            require(blueprintProperties[_blueprintId].validationStatus != ValidationStatus.Refused, \\\"Can't modify a refused blueprint\\\");\\n        } else {\\n            require(blueprintProperties[_blueprintId].validationStatus == ValidationStatus.Waiting, \\\"Can only be changed for blueprints in validation process\\\");\\n        }\\n    }\\n\\n    function emitBlueprintUpdated(uint256 _blueprintId) internal {\\n        emit BlueprintUpdated(_blueprintId);\\n        \\n        if (blueprintProperties[_blueprintId].validationStatus == ValidationStatus.Accepted) {\\n            uint256 tokenId = blueprints[_blueprintId].nftId;\\n            string memory newUri = uri(blueprints[_blueprintId].nftId);\\n            emit URI(newUri, tokenId);\\n        }\\n    }\\n\\n    function validateBlueprint(uint256 _blueprintId) external onlyScientists {\\n        require(_blueprintId <= blueprintCount, \\\"Blueprint does not exist\\\");\\n        require(blueprintProperties[_blueprintId].validationStatus == ValidationStatus.Waiting, \\\"Blueprint is not pending approval\\\");\\n\\n        nftCount++;\\n        blueprints[_blueprintId].nftId = nftCount;\\n        tokenIdToBlueprintId[nftCount] = _blueprintId;\\n\\n        blueprintProperties[_blueprintId].validationStatus = ValidationStatus.Accepted;\\n        emit BlueprintValidated(_blueprintId, blueprints[_blueprintId].nftId, ValidationStatus.Accepted);\\n    }\\n\\n    function refuseBlueprint(uint256 _blueprintId) external onlyScientists {\\n        require(_blueprintId <= blueprintCount, \\\"Blueprint does not exist\\\");\\n        require(blueprintProperties[_blueprintId].validationStatus == ValidationStatus.Waiting, \\\"Blueprint is not pending approval\\\");\\n\\n        blueprintProperties[_blueprintId].validationStatus = ValidationStatus.Refused;\\n        emit BlueprintRefused(_blueprintId, ValidationStatus.Refused);\\n    }\\n\\n    function getBlueprint(uint256 _blueprintId) external view returns (\\n        address creator,\\n        uint256 price,\\n        uint256 maxSupply,\\n        uint256 startDate,\\n        uint256 endDate,\\n        uint256 minted,\\n        uint256 ruleSetId,\\n        ValidationStatus validationStatus\\n    ) {\\n        require(_blueprintId <= blueprintCount, \\\"Blueprint does not exist\\\");\\n        Blueprint memory blueprint = blueprints[_blueprintId];\\n        BlueprintProperties memory properties = blueprintProperties[_blueprintId];\\n        return (\\n            blueprint.creator,\\n            properties.price,\\n            blueprint.maxSupply,\\n            properties.startDate,\\n            properties.endDate,\\n            blueprint.minted,\\n            properties.ruleSetId,\\n            properties.validationStatus\\n        );\\n    }\\n\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        override\\n        returns (address, uint256)\\n    {\\n        uint256 _blueprintId = getBlueprintId(tokenId);\\n        uint256 royaltyAmount = (salePrice * blueprintProperties[_blueprintId].royaltyFee) / 10000;\\n        return (blueprintProperties[_blueprintId].royaltyRecipient, royaltyAmount);\\n    }\\n\\n    function mint(address to, uint256 tokenId, uint256 amount) external onlyMinter {\\n        uint256 _blueprintId = getBlueprintId(tokenId);\\n        require(blueprintProperties[_blueprintId].validationStatus == ValidationStatus.Accepted, \\\"TokenId does not correspond to an accepted blueprint\\\");\\n        require((block.timestamp >= blueprintProperties[_blueprintId].startDate) && (block.timestamp <= blueprintProperties[_blueprintId].endDate), \\\"Minting period not active\\\");\\n        require(blueprints[_blueprintId].minted + amount <= blueprints[_blueprintId].maxSupply, \\\"Exceeds max supply\\\");\\n\\n        blueprints[_blueprintId].minted += amount;\\n\\n        _mint(to, tokenId, amount, \\\"\\\");\\n        emit NFTMinted(to, tokenId, amount);\\n        emit BlueprintUpdated(_blueprintId);\\n    }\\n\\n    function uri(uint256 tokenId) public view override returns (string memory) {\\n        uint256 blueprintId = getBlueprintId(tokenId);\\n\\n        string memory baseURI = string(abi.encodePacked(imageURI, blueprintId.toString(), blueprints[blueprintId].fileExtension));\\n        \\n        return string(abi.encodePacked(\\n            '{\\\"name\\\": \\\"', blueprints[blueprintId].name,\\n            '\\\", \\\"description\\\": \\\"', blueprints[blueprintId].description,\\n            '\\\", \\\"image\\\": \\\"', baseURI,\\n            getAnimation(blueprintId),\\n            '\\\", \\\"external_url\\\": \\\"', externalURI, tokenId.toString(),\\n            '\\\", \\\"attributes\\\": [',\\n            getAttributes(blueprintId),\\n            getSeriesAndCard(tokenId),\\n            getSupplyInfo(blueprintId, tokenId),\\n            getImportantDates(blueprintId),\\n            '{\\\"trait_type\\\":\\\"Artist\\\",\\\"value\\\":\\\"', blueprints[blueprintId].creatorName,'\\\"}'\\n            ']}'\\n        ));\\n    }\\n\\n    function getImportantDates(uint256 blueprintId) internal view returns (string memory) {\\n        string memory importantDates = '';\\n        if (blueprintProperties[blueprintId].endDate != type(uint256).max && blueprintProperties[blueprintId].endDate > block.timestamp) {\\n            importantDates = string(abi.encodePacked(importantDates, '{\\\"trait_type\\\":\\\"Minting Ends\\\",\\\"display_type\\\": \\\"date\\\",\\\"value\\\":', blueprintProperties[blueprintId].endDate.toString(),'},'));\\n        }\\n        importantDates = string(abi.encodePacked(importantDates, '{\\\"trait_type\\\":\\\"Creation\\\",\\\"display_type\\\": \\\"date\\\",\\\"value\\\":', blueprintProperties[blueprintId].creationDate.toString(),'},'));\\n        return importantDates;\\n    }\\n\\n    function getSupplyInfo(uint256 blueprintId, uint256 tokenId) internal view returns (string memory) {\\n        string memory supplyInformations = '';\\n        supplyInformations =  string(abi.encodePacked(supplyInformations,'{\\\"trait_type\\\":\\\"Supply\\\",\\\"value\\\":\\\"', totalSupply(tokenId).toString(),'\\\"},'));\\n        if (blueprintId == 0) {\\n            return string(abi.encodePacked(supplyInformations,'{\\\"trait_type\\\":\\\"Max Supply\\\",\\\"value\\\":\\\"Infinite\\\"},'));\\n        }\\n        return string(abi.encodePacked(supplyInformations, '{\\\"trait_type\\\":\\\"Minted\\\",\\\"display_type\\\":\\\"number\\\",\\\"value\\\":', blueprints[blueprintId].minted.toString(),',\\\"max_value\\\":', blueprints[blueprintId].maxSupply.toString(),'},'));\\n    }\\n\\n    function getAnimation(uint256 blueprintId) internal view returns (string memory) {\\n        string memory animationURI = '';\\n        if (bytes( blueprints[blueprintId].animationFileExtension).length > 0) {\\n            animationURI = string(abi.encodePacked('\\\", \\\"animation_url\\\": \\\"', imageURI, blueprintId.toString(),  blueprints[blueprintId].animationFileExtension));\\n        }\\n        return animationURI;\\n    }\\n\\n    function getAttributes(uint256 blueprintId) public view returns (string memory) {\\n        string memory attributes = '';\\n        for (uint i = 0; i < blueprintAttributes[blueprintId].attributeKeys.length; i++) {\\n            string memory key = blueprintAttributes[blueprintId].attributeKeys[i];\\n            string memory value = blueprintAttributes[blueprintId].attributes[key];\\n            attributes = string(abi.encodePacked(attributes, '{\\\"trait_type\\\":\\\"', key, '\\\",\\\"value\\\":\\\"', value, '\\\"},'));\\n        }\\n        for (uint i = 0; i < blueprintAttributes[blueprintId].numericAttributeKeys.length; i++) {\\n            string memory key = blueprintAttributes[blueprintId].numericAttributeKeys[i];\\n            uint256 value = blueprintAttributes[blueprintId].numericAttributes[key];\\n            string memory displayType = blueprintAttributes[blueprintId].numericDisplayTypes[key];\\n            uint256 maxValue = blueprintAttributes[blueprintId].numericMaxValues[key];\\n            attributes = string(abi.encodePacked(attributes, '{\\\"trait_type\\\":\\\"', key, '\\\",\\\"value\\\":', value.toString(), ',\\\"max_value\\\":', maxValue.toString(),  ',\\\"display_type\\\":\\\"', displayType, '\\\"},'));\\n        }\\n        return attributes;\\n    }\\n\\n    function getSeriesAndCard(uint256 tokenId) internal view returns (string memory) {\\n        if (tokenId == 0 || isDirectory == false) {\\n            return \\\"\\\";\\n        }\\n\\n        uint256 series = (tokenId - 1) / 50 + 1;\\n        uint256 card = (tokenId - 1) % 50 + 1;\\n\\n        // Convert the numbers to strings\\n        string memory seriesStr = series.toString();\\n        string memory cardStr = card.toString();\\n        if(bytes(seriesStr).length == 1) seriesStr = string(abi.encodePacked('0', seriesStr));\\n        if(bytes(cardStr).length == 1) cardStr = string(abi.encodePacked('0', cardStr));\\n\\n        return string(abi.encodePacked('{\\\"trait_type\\\":\\\"Series\\\",\\\"value\\\":\\\"', seriesStr,'\\\"}, {\\\"trait_type\\\":\\\"Card\\\",\\\"value\\\":\\\"', cardStr, '\\\"},'));\\n    }\\n\\n    function getBlueprintId(uint256 tokenId) public view returns (uint256) {\\n        if (tokenId == 0) {\\n            return 0;\\n        }\\n        require(tokenIdToBlueprintId[tokenId] != 0, \\\"Invalid tokenId or blueprintId not set\\\");\\n        return tokenIdToBlueprintId[tokenId];\\n    }\\n\\n    // Scientists setters functions\\n    function activateDirectory(bool _isDirectory) external onlyScientists {\\n        isDirectory = _isDirectory;\\n    }\\n    function changeLockDuration(uint256 _maxLockDuration, uint256 _minLockDuration) external onlyScientists {\\n        require(_maxLockDuration > _minLockDuration, \\\"Max lock duration should be greater than min lock duration\\\");\\n        maxLockDuration = _maxLockDuration;\\n        minLockDuration = _minLockDuration;\\n    }\\n    function setSupplyBoundaries(uint256 _cardMinSupply, uint256 _cardMaxSupply) external onlyScientists {\\n        require(_cardMaxSupply > _cardMinSupply, \\\"Max supply should be greater than min supply\\\");\\n        cardMaxSupply = _cardMaxSupply;\\n        cardMinSupply = _cardMinSupply;\\n    }\\n    function setURIs(string memory _imageURI, string memory _externalURI) external onlyScientists {\\n        imageURI = _imageURI;\\n        externalURI = _externalURI;\\n    }\\n    function setBurnAmount(uint256 _burnAmount) external onlyScientists {\\n        burnAmount = _burnAmount;\\n    }\\n    function setMaxRoyalty(uint256 _maxRoyalty) external onlyScientists {\\n        require(_maxRoyalty <= 10000, \\\"Max royalty should be lower than 10000\\\");\\n        maxRoyalty = _maxRoyalty;\\n    }\\n\\n    // Owner setters functions\\n    function setMinter(address _minter) external onlyOwner {\\n        minter = _minter;\\n    }\\n    function setScientists(address _scientists) external onlyOwner {\\n        scientists = _scientists;\\n    }\\n}\"\r\n    },\r\n    \"contracts/LockerRoom.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./Carbon21.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\ninterface ITokenDetails {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n}\\n\\ncontract LockerRoom is Ownable, ReentrancyGuard {\\n    struct Locker {\\n        uint256 amount;\\n        uint256 lockUntil;\\n    }\\n\\n    address public lockerManager;\\n\\n    mapping(address => mapping(address => Locker[])) public lockers;\\n    mapping(address => address[]) public usersLockingToken;\\n    address[] public registeredTokens;\\n\\n    event TokensLocked(address indexed user, address indexed tokenAddress, uint256 amount, uint256 lockTime, uint256 lockerIndex);\\n    event LockTimeAndTokensAdded(address indexed user, address indexed tokenAddress, uint256 additionalAmount, uint256 addedTime, uint256 lockerIndex);\\n    event TokensWithdrawn(address indexed user, address indexed tokenAddress, uint256 amount, uint256 lockerIndex);\\n    event TokensBurnt(address indexed user, address indexed tokenAddress, uint256 amount, uint256 lockerIndex);\\n    event TokenRegistered(address indexed tokenAddress);\\n\\n    modifier onlyLockerManager() {\\n        require(msg.sender == lockerManager, \\\"Caller is not the LockerManager\\\");\\n        _;\\n    }\\n\\n    constructor() {\\n        lockerManager = msg.sender;\\n    }\\n\\n    function registerToken(address tokenAddress) external onlyLockerManager {\\n        require(!isRegistered(tokenAddress), \\\"Token already registered\\\");\\n        registeredTokens.push(tokenAddress);\\n        emit TokenRegistered(tokenAddress);\\n    }\\n\\n    function changeLockerManager(address newLockerManager) external onlyOwner {\\n        lockerManager = newLockerManager;\\n    }\\n\\n    function getRegisteredTokens() external view returns (address[] memory, string[] memory, string[] memory) {\\n        string[] memory names = new string[](registeredTokens.length);\\n        string[] memory symbols = new string[](registeredTokens.length);\\n\\n        for (uint256 i = 0; i < registeredTokens.length; i++) {\\n            ITokenDetails token = ITokenDetails(registeredTokens[i]);\\n            names[i] = token.name();\\n            symbols[i] = token.symbol();\\n        }\\n\\n        return (registeredTokens, names, symbols);\\n    }\\n\\n    function isRegistered(address tokenAddress) public view returns (bool) {\\n        for (uint256 i = 0; i < registeredTokens.length; i++) {\\n            if (registeredTokens[i] == tokenAddress) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function userAlreadyLockingToken(address tokenAddress, address user) internal view returns (bool) {\\n        address[] memory users = usersLockingToken[tokenAddress];\\n        for (uint256 i = 0; i < users.length; i++) {\\n            if (users[i] == user) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function lockTokens(address tokenAddress, address minterAddress, uint256 amount, uint256 lockTimeInBlocks) external returns (uint256, uint256) {\\n        require(amount > 0, \\\"Amount should be greater than 0\\\");\\n        require(isRegistered(tokenAddress), \\\"Token not registered\\\");\\n        IERC20 token = IERC20(tokenAddress);\\n        require(token.transferFrom(minterAddress, address(this), amount), \\\"Transfer failed\\\");\\n\\n        Locker memory newLocker;\\n        newLocker.amount = amount;\\n        newLocker.lockUntil = block.number + lockTimeInBlocks;\\n\\n        lockers[minterAddress][tokenAddress].push(newLocker);\\n\\n        if (!userAlreadyLockingToken(tokenAddress, minterAddress)) {\\n            usersLockingToken[tokenAddress].push(minterAddress);\\n        }\\n        emit TokensLocked(minterAddress, tokenAddress, amount, lockTimeInBlocks, lockers[minterAddress][tokenAddress].length - 1);\\n\\n        return (newLocker.amount, lockTimeInBlocks);\\n    }\\n\\n    function addLockAndTime(address tokenAddress, address minterAddress, uint256 additionalAmount, uint256 additionalBlocks, uint256 lockerIndex) external returns (uint256 newAmount, uint256 newLockTime) {\\n        require(lockerIndex < lockers[minterAddress][tokenAddress].length, \\\"Invalid locker index\\\");\\n        Locker storage locker = lockers[minterAddress][tokenAddress][lockerIndex];\\n        require(locker.amount > 0, \\\"No tokens locked\\\");\\n        IERC20 token = IERC20(tokenAddress);\\n        \\n        // If additionalAmount is greater than 0, transfer the tokens and add to the locker's amount\\n        if (additionalAmount > 0) {\\n            require(token.transferFrom(minterAddress, address(this), additionalAmount), \\\"Transfer failed\\\");\\n            locker.amount += additionalAmount;\\n        }\\n\\n        // Adjust the lock time\\n        if (locker.lockUntil < block.number) {\\n            locker.lockUntil = block.number + additionalBlocks;\\n        } else {\\n            locker.lockUntil += additionalBlocks;\\n        }\\n\\n        emit LockTimeAndTokensAdded(minterAddress, tokenAddress, additionalAmount, additionalBlocks, lockerIndex);\\n\\n        return (locker.amount, (locker.lockUntil - block.number));\\n    }\\n\\n    function withdrawAllFrom(address tokenAddress) external nonReentrant {\\n        require(isRegistered(tokenAddress), \\\"Token not registered\\\");\\n        \\n        uint256 totalAmount = 0;\\n        for (uint256 i = 0; i < lockers[msg.sender][tokenAddress].length; i++) {\\n            if (block.number > lockers[msg.sender][tokenAddress][i].lockUntil) {\\n                totalAmount += lockers[msg.sender][tokenAddress][i].amount;\\n                lockers[msg.sender][tokenAddress][i] = Locker(0, 0);\\n            }\\n        }\\n\\n        require(totalAmount > 0, \\\"No tokens to withdraw\\\");\\n        \\n        IERC20 token = IERC20(tokenAddress);\\n        require(token.transfer(msg.sender, totalAmount), \\\"Transfer failed\\\");\\n\\n        emit TokensWithdrawn(msg.sender, tokenAddress, totalAmount, 0); // Using 0 as index because we are not withdrawing from a specific locker\\n    }\\n\\n    function withdrawLocker(address tokenAddress, uint256 lockerIndex) external nonReentrant {\\n        require(lockerIndex < lockers[msg.sender][tokenAddress].length, \\\"Invalid locker index\\\");\\n        Locker storage locker = lockers[msg.sender][tokenAddress][lockerIndex];\\n        require(locker.amount > 0, \\\"Locker already emptied\\\");\\n        require(block.number > locker.lockUntil, \\\"Tokens are still locked\\\");\\n        \\n        uint256 amount = locker.amount;\\n        locker.amount = 0;\\n        locker.lockUntil = 0;\\n\\n        IERC20 token = IERC20(tokenAddress);\\n        require(token.transfer(msg.sender, amount), \\\"Transfer failed\\\");\\n\\n        emit TokensWithdrawn(msg.sender, tokenAddress, amount, lockerIndex);\\n    }\\n\\n    function burnLocker(address tokenAddress, uint256 lockerIndex) external nonReentrant {\\n        require(lockerIndex < lockers[msg.sender][tokenAddress].length, \\\"Invalid locker index\\\");\\n        Locker storage locker = lockers[msg.sender][tokenAddress][lockerIndex];\\n        require(locker.amount > 0, \\\"Locker already emptied\\\");\\n        \\n        uint256 amount = locker.amount;\\n        locker.amount = 0;\\n        locker.lockUntil = 0;\\n\\n        Carbon21 token = Carbon21(tokenAddress);\\n        token.burn(amount);\\n\\n        emit TokensBurnt(msg.sender, tokenAddress, amount, lockerIndex);\\n    }\\n\\n    function getLockersFrom(address userAddress) external view returns (address[] memory tokens, uint256[] memory amounts, uint256[] memory lockDurations) {\\n        uint256 count = 0;\\n        for (uint256 j = 0; j < registeredTokens.length; j++) {\\n            count += lockers[userAddress][registeredTokens[j]].length;\\n        }\\n\\n        tokens = new address[](count);\\n        amounts = new uint256[](count);\\n        lockDurations = new uint256[](count);\\n\\n        uint256 index = 0;\\n        for (uint256 j = 0; j < registeredTokens.length; j++) {\\n            address tokenAddress = registeredTokens[j];\\n            for (uint256 i = 0; i < lockers[userAddress][tokenAddress].length; i++) {\\n                tokens[index] = tokenAddress;\\n                amounts[index] = lockers[userAddress][tokenAddress][i].amount;\\n                lockDurations[index] = lockers[userAddress][tokenAddress][i].lockUntil > block.number\\n                    ? lockers[userAddress][tokenAddress][i].lockUntil - block.number\\n                    : 0;\\n                index++;\\n            }\\n        }\\n        return (tokens, amounts, lockDurations);\\n    }\\n\\n    function getLocked(address tokenAddress) external view returns (uint256) {\\n        return _getLockedAtBlock(tokenAddress, block.number);\\n    }\\n\\n    function getLockedAtBlock(address tokenAddress, uint256 _blockNumber) external view returns (uint256) {\\n        return _getLockedAtBlock(tokenAddress, _blockNumber);\\n    }\\n\\n    function _getLockedAtBlock(address tokenAddress, uint256 _blockNumber) internal view returns (uint256) {\\n        uint256 totalLocked = 0;\\n        \\n        address[] memory users = usersLockingToken[tokenAddress];\\n        for (uint256 j = 0; j < users.length; j++) {\\n            address userAddress = users[j];\\n            for (uint256 i = 0; i < lockers[userAddress][tokenAddress].length; i++) {\\n                if(lockers[userAddress][tokenAddress][i].lockUntil > _blockNumber) {\\n                    totalLocked += lockers[userAddress][tokenAddress][i].amount;\\n                }\\n            }\\n        }\\n        \\n        return totalLocked;\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/RulesetManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./DiamondCollection.sol\\\";\\nimport \\\"./LockerRoom.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract RulesetManager is Ownable {\\n\\tmapping(address => mapping(uint256 => mapping(address => uint256))) private lastMintTime;\\n\\tmapping(address => address[]) private allowedTokens;\\n\\taddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n\\tuint256 public halfwayPoint;\\n\\tuint256 public mintAmountLimit;\\n\\n\\tconstructor() {\\n\\t\\thalfwayPoint = 1700780400;\\n\\t\\tmintAmountLimit = 3;\\n\\t}\\n\\n\\tfunction addAllowedToken(address collectionAddress, address tokenAddress) external onlyOwner {\\n\\t\\tallowedTokens[collectionAddress].push(tokenAddress);\\n\\t}\\n\\n\\tfunction setMintingTimes(uint256 _halfwayPoint) external onlyOwner {\\n\\t\\thalfwayPoint = _halfwayPoint;\\n\\t}\\n\\n\\tfunction setMintAmountLimit(uint256 _mintAmountLimit) external onlyOwner {\\n\\t\\tmintAmountLimit = _mintAmountLimit;\\n\\t}\\n\\n\\tfunction checkRuleset(\\n\\t\\taddress minter,\\n\\t\\taddress receiver,\\n\\t\\taddress collectionAddress,\\n\\t\\taddress lockerRoomAddress,\\n\\t\\tuint256 amount,\\n\\t\\tuint256 tokenId\\n\\t) external returns (bool) {\\n\\t\\tDiamondCollection dc = DiamondCollection(collectionAddress);\\n\\t\\tuint256 blueprintId = dc.getBlueprintId(tokenId);\\n\\t\\t(, , uint256 maxSupply, , , uint256 minted, uint256 rulesetId, ) = dc.getBlueprint(blueprintId);\\n\\n\\t\\tif (isSpecialRuleset(rulesetId)) {\\n\\t\\t\\t(, uint256 ruleId) = getIdsFromRuleset(rulesetId);\\n\\t\\t\\trulesetId = ruleId;\\n\\t\\t}\\n\\n\\t\\tif (rulesetId == 0) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tif (rulesetId == 1) {\\n\\t\\t\\t// Check if both minter and receiver have not minted/received this specific tokenId within the required wait time\\n\\t\\t\\tif (block.timestamp < halfwayPoint + 1 hours) {\\n\\t\\t\\t\\trequire(\\n\\t\\t\\t\\t\\tblock.timestamp >= lastMintTime[collectionAddress][tokenId][minter] + 13 hours &&\\n\\t\\t\\t\\t\\tblock.timestamp >= lastMintTime[collectionAddress][tokenId][receiver] + 13 hours,\\n\\t\\t\\t\\t\\t\\\"Minting limited to 1 each 13 hours.\\\"\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Limit to 1 mint per address\\n\\t\\t\\trequire(amount <= mintAmountLimit, \\\"Max minting amount reached.\\\");\\n\\n\\t\\t\\t// Check if the supply has reached the halfway point, if so check if the second minting time has been reached\\n\\t\\t\\tif (minted > (maxSupply / 2)) {\\n\\t\\t\\t\\trequire(\\n\\t\\t\\t\\t\\tblock.timestamp >= halfwayPoint,\\n\\t\\t\\t\\t\\t\\\"Second minting time not reached yet.\\\"\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\tlastMintTime[collectionAddress][tokenId][minter] = block.timestamp;\\n\\t\\t\\tlastMintTime[collectionAddress][tokenId][receiver] = block.timestamp;\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction getTokenAddressFromRuleset(address collectionAddress, address tokenAddress, uint256 blueprintId) external view returns (address) {\\n\\t\\t(, , , , , , uint256 rulesetId, ) = DiamondCollection(collectionAddress).getBlueprint(blueprintId);\\n\\t\\tif (isSpecialRuleset(rulesetId)) {\\n\\t\\t\\t(uint256 tokenId,) = getIdsFromRuleset(rulesetId);\\n\\t\\t\\tif (tokenId == 0) {\\n\\t\\t\\t\\treturn WETH;\\n\\t\\t\\t}\\n\\t\\t\\treturn allowedTokens[collectionAddress][tokenId-1];\\n\\t\\t}\\n\\t\\treturn tokenAddress;\\n\\t}\\n\\n\\tfunction isSpecialRuleset(uint256 rulesetId) internal pure returns (bool) {\\n\\t\\treturn rulesetId >= 420000;\\n\\t}\\n\\n\\tfunction getIdsFromRuleset(uint256 rulesetId) public pure returns (uint256 tokenId, uint256 ruleId) {\\n\\t\\trequire(isSpecialRuleset(rulesetId), \\\"Not a special ruleset\\\");\\n\\n\\t\\tuint256 originalRulesetId = rulesetId;\\n\\t\\tuint256 divider = 10;\\n\\n\\t\\t// Strip away ruleId\\n\\t\\twhile (rulesetId > 0) {\\n\\t\\t\\t\\tuint256 digit = rulesetId % 10;\\n\\t\\t\\t\\tif (digit == 0 && (rulesetId != originalRulesetId)) {\\n\\t\\t\\t\\t\\trulesetId /= 10;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\trulesetId /= 10;\\n\\t\\t\\t\\tdivider *= 10;\\n\\t\\t}\\n\\t\\truleId = originalRulesetId % (divider);\\n\\t\\tdivider = 10;\\n\\t\\tuint256 newRulesetId = rulesetId;\\n\\n\\t\\twhile (rulesetId >= 10000) {\\n\\t\\t\\t\\trulesetId /= 10;\\n\\t\\t\\t\\tdivider *= 10;\\n\\t\\t}\\n\\t\\ttokenId = newRulesetId % divider;\\n\\n\\t\\treturn (tokenId, ruleId);\\n\\t}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"stackAllocation\": true,\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf\"\r\n        }\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"addAllowedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lockerRoomAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"checkRuleset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rulesetId\",\"type\":\"uint256\"}],\"name\":\"getIdsFromRuleset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ruleId\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blueprintId\",\"type\":\"uint256\"}],\"name\":\"getTokenAddressFromRuleset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"halfwayPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintAmountLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mintAmountLimit\",\"type\":\"uint256\"}],\"name\":\"setMintAmountLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_halfwayPoint\",\"type\":\"uint256\"}],\"name\":\"setMintingTimes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RulesetManager", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}