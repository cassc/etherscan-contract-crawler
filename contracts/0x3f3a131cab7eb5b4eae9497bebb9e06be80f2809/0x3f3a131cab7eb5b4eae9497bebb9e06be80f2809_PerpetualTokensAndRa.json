{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"AcceptModifications.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"LibConstants.sol\\\";\\nimport \\\"MAcceptModifications.sol\\\";\\nimport \\\"MTokenQuantization.sol\\\";\\nimport \\\"MainStorage.sol\\\";\\n\\n/*\\n  Interface containing actions a verifier can invoke on the state.\\n  The contract containing the state should implement these and verify correctness.\\n*/\\nabstract contract AcceptModifications is\\n    MainStorage,\\n    LibConstants,\\n    MAcceptModifications,\\n    MTokenQuantization\\n{\\n    event LogWithdrawalAllowed(\\n        uint256 ownerKey,\\n        uint256 assetType,\\n        uint256 nonQuantizedAmount,\\n        uint256 quantizedAmount\\n    );\\n\\n    event LogNftWithdrawalAllowed(uint256 ownerKey, uint256 assetId);\\n\\n    event LogAssetWithdrawalAllowed(uint256 ownerKey, uint256 assetId, uint256 quantizedAmount);\\n\\n    event LogMintableWithdrawalAllowed(uint256 ownerKey, uint256 assetId, uint256 quantizedAmount);\\n\\n    /*\\n      Transfers funds from the on-chain deposit area to the off-chain area.\\n      Implemented in the Deposits contracts.\\n    */\\n    function acceptDeposit(\\n        uint256 ownerKey,\\n        uint256 vaultId,\\n        uint256 assetId,\\n        uint256 quantizedAmount\\n    ) internal virtual override {\\n        // Fetch deposit.\\n        require(\\n            pendingDeposits[ownerKey][assetId][vaultId] >= quantizedAmount,\\n            \\\"DEPOSIT_INSUFFICIENT\\\"\\n        );\\n\\n        // Subtract accepted quantized amount.\\n        pendingDeposits[ownerKey][assetId][vaultId] -= quantizedAmount;\\n    }\\n\\n    /*\\n      Transfers funds from the off-chain area to the on-chain withdrawal area.\\n    */\\n    function allowWithdrawal(\\n        uint256 ownerKey,\\n        uint256 assetId,\\n        uint256 quantizedAmount\\n    ) internal override {\\n        // Fetch withdrawal.\\n        uint256 withdrawal = pendingWithdrawals[ownerKey][assetId];\\n\\n        // Add accepted quantized amount.\\n        withdrawal += quantizedAmount;\\n        require(withdrawal >= quantizedAmount, \\\"WITHDRAWAL_OVERFLOW\\\");\\n\\n        // Store withdrawal.\\n        pendingWithdrawals[ownerKey][assetId] = withdrawal;\\n\\n        // Log event.\\n        uint256 presumedAssetType = assetId;\\n        if (registeredAssetType[presumedAssetType]) {\\n            emit LogWithdrawalAllowed(\\n                ownerKey,\\n                presumedAssetType,\\n                fromQuantized(presumedAssetType, quantizedAmount),\\n                quantizedAmount\\n            );\\n        } else if (\\n            assetId ==\\n            ((assetId &\\n                (MASK_240 | NON_UNIQUE_MINTABLE_ASSET_ID_FLAG | MINTABLE_ERC20_ASSET_ID_FLAG)) |\\n                MINTABLE_ASSET_ID_FLAG)\\n        ) {\\n            emit LogMintableWithdrawalAllowed(ownerKey, assetId, quantizedAmount);\\n        } else {\\n            // Default case is Non-Mintable ERC721 or ERC1155 asset id.\\n            // In ERC721 and ERC1155 cases, assetId is not the assetType.\\n            require(assetId == assetId & MASK_250, \\\"INVALID_ASSET_ID\\\");\\n            // If withdrawal amount is 1, the asset could be either NFT or SFT. In that case, both\\n            // NFT and general events will be emitted so that the listened for event is captured.\\n            // When withdrawal is greater than 1, it must be SFT and only one event will be emitted.\\n            if (withdrawal <= 1) {\\n                emit LogNftWithdrawalAllowed(ownerKey, assetId);\\n            }\\n            emit LogAssetWithdrawalAllowed(ownerKey, assetId, quantizedAmount);\\n        }\\n    }\\n\\n    // Verifier authorizes withdrawal.\\n    function acceptWithdrawal(\\n        uint256 ownerKey,\\n        uint256 assetId,\\n        uint256 quantizedAmount\\n    ) internal virtual override {\\n        allowWithdrawal(ownerKey, assetId, quantizedAmount);\\n    }\\n}\\n\"\r\n    },\r\n    \"Addresses.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\n/*\\n  Common Utility Libraries.\\n  I. Addresses (extending address).\\n*/\\nlibrary Addresses {\\n    /*\\n      Note: isContract function has some known limitation.\\n      See https://github.com/OpenZeppelin/\\n      openzeppelin-contracts/blob/master/contracts/utils/Address.sol.\\n    */\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function performEthTransfer(address recipient, uint256 amount) internal {\\n        if (amount == 0) return;\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\"); // NOLINT: low-level-calls.\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*\\n      Safe wrapper around ERC20/ERC721 calls.\\n      This is required because many deployed ERC20 contracts don't return a value.\\n      See https://github.com/ethereum/solidity/issues/4116.\\n    */\\n    function safeTokenContractCall(address tokenAddress, bytes memory callData) internal {\\n        require(isContract(tokenAddress), \\\"BAD_TOKEN_ADDRESS\\\");\\n        // NOLINTNEXTLINE: low-level-calls.\\n        (bool success, bytes memory returndata) = tokenAddress.call(callData);\\n        require(success, string(returndata));\\n\\n        if (returndata.length > 0) {\\n            require(abi.decode(returndata, (bool)), \\\"TOKEN_OPERATION_FAILED\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"Deposits.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"LibConstants.sol\\\";\\nimport \\\"MAcceptModifications.sol\\\";\\nimport \\\"MDeposits.sol\\\";\\nimport \\\"MTokenQuantization.sol\\\";\\nimport \\\"MTokenAssetData.sol\\\";\\nimport \\\"MFreezable.sol\\\";\\nimport \\\"MKeyGetters.sol\\\";\\nimport \\\"MTokenTransfers.sol\\\";\\nimport \\\"MainStorage.sol\\\";\\n\\n/**\\n  For a user to perform a deposit to the contract two calls need to take place:\\n\\n  1. A call to an ERC20 contract, authorizing this contract to transfer funds on behalf of the user.\\n  2. A call to :sol:func:`deposit` indicating the starkKey, amount, asset type and target vault ID to which to send the deposit.\\n\\n  The amount should be quantized, according to the specific quantization defined for the asset type.\\n\\n  The result of the operation, assuming all requirements are met, is that an amount of ERC20 tokens\\n  equaling the amount specified in the :sol:func:`deposit` call times the quantization factor is\\n  transferred on behalf of the user to the contract. In addition, the contract adds the funds to an\\n  accumulator of pending deposits for the provided user, asset ID and vault ID.\\n\\n  Once a deposit is made, the exchange may include it in a proof which will result in addition\\n  of the amount(s) deposited to the off-chain vault with the specified ID. When the contract\\n  receives such valid proof, it deducts the transfered funds from the pending deposits for the\\n  specified Stark key, asset ID and vault ID.\\n\\n  The exchange will not be able to move the deposited funds to the off-chain vault if the Stark key\\n  is not registered in the system.\\n\\n  Until that point, the user may cancel the deposit by performing a time-locked cancel-deposit\\n  operation consisting of two calls:\\n\\n  1. A call to :sol:func:`depositCancel`, setting a timer to enable reclaiming the deposit. Until this timer expires the user cannot reclaim funds as the exchange may still be processing the deposit for inclusion in the off chain vault.\\n  2. A call to :sol:func:`depositReclaim`, to perform the actual transfer of funds from the contract back to the ERC20 contract. This will only succeed if the timer set in the previous call has expired. The result should be the transfer of all funds not accounted for in proofs for off-chain inclusion, back to the user account on the ERC20 contract.\\n\\n  Calling depositCancel and depositReclaim can only be done via an ethKey that is associated with\\n  that vault's starkKey. This is enforced by the contract.\\n\\n*/\\nabstract contract Deposits is\\n    MainStorage,\\n    LibConstants,\\n    MAcceptModifications,\\n    MDeposits,\\n    MTokenQuantization,\\n    MTokenAssetData,\\n    MFreezable,\\n    MKeyGetters,\\n    MTokenTransfers\\n{\\n    event LogDeposit(\\n        address depositorEthKey,\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 assetType,\\n        uint256 nonQuantizedAmount,\\n        uint256 quantizedAmount\\n    );\\n\\n    event LogNftDeposit(\\n        address depositorEthKey,\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 assetType,\\n        uint256 tokenId,\\n        uint256 assetId\\n    );\\n\\n    event LogDepositWithTokenId(\\n        address depositorEthKey,\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 assetType,\\n        uint256 tokenId,\\n        uint256 assetId,\\n        uint256 nonQuantizedAmount,\\n        uint256 quantizedAmount\\n    );\\n\\n    event LogDepositCancel(uint256 starkKey, uint256 vaultId, uint256 assetId);\\n\\n    event LogDepositCancelReclaimed(\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 assetType,\\n        uint256 nonQuantizedAmount,\\n        uint256 quantizedAmount\\n    );\\n\\n    event LogDepositNftCancelReclaimed(\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 assetType,\\n        uint256 tokenId,\\n        uint256 assetId\\n    );\\n\\n    event LogDepositWithTokenIdCancelReclaimed(\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 assetType,\\n        uint256 tokenId,\\n        uint256 assetId,\\n        uint256 nonQuantizedAmount,\\n        uint256 quantizedAmount\\n    );\\n\\n    function getDepositBalance(\\n        uint256 starkKey,\\n        uint256 assetId,\\n        uint256 vaultId\\n    ) external view returns (uint256) {\\n        uint256 presumedAssetType = assetId;\\n        return fromQuantized(presumedAssetType, pendingDeposits[starkKey][assetId][vaultId]);\\n    }\\n\\n    function getQuantizedDepositBalance(\\n        uint256 starkKey,\\n        uint256 assetId,\\n        uint256 vaultId\\n    ) external view returns (uint256) {\\n        return pendingDeposits[starkKey][assetId][vaultId];\\n    }\\n\\n    function depositNft(\\n        uint256 starkKey,\\n        uint256 assetType,\\n        uint256 vaultId,\\n        uint256 tokenId\\n    ) external notFrozen {\\n        require(isERC721(assetType), \\\"NOT_ERC721_TOKEN\\\");\\n        depositWithTokenId(starkKey, assetType, tokenId, vaultId, 1);\\n    }\\n\\n    function depositERC1155(\\n        uint256 starkKey,\\n        uint256 assetType,\\n        uint256 tokenId,\\n        uint256 vaultId,\\n        uint256 quantizedAmount\\n    ) external notFrozen {\\n        require(isERC1155(assetType), \\\"NOT_ERC1155_TOKEN\\\");\\n        depositWithTokenId(starkKey, assetType, tokenId, vaultId, quantizedAmount);\\n    }\\n\\n    function depositStateUpdate(\\n        uint256 starkKey,\\n        uint256 assetId,\\n        uint256 vaultId,\\n        uint256 quantizedAmount\\n    ) private returns (uint256) {\\n        // Checks for overflow and updates the pendingDeposits balance.\\n        uint256 vaultBalance = pendingDeposits[starkKey][assetId][vaultId];\\n        vaultBalance += quantizedAmount;\\n        require(vaultBalance >= quantizedAmount, \\\"DEPOSIT_OVERFLOW\\\");\\n        pendingDeposits[starkKey][assetId][vaultId] = vaultBalance;\\n\\n        // Disable the cancellationRequest timeout when users deposit into their own account.\\n        if (\\n            isMsgSenderKeyOwner(starkKey) && cancellationRequests[starkKey][assetId][vaultId] != 0\\n        ) {\\n            delete cancellationRequests[starkKey][assetId][vaultId];\\n        }\\n\\n        // Returns the updated vault balance.\\n        return vaultBalance;\\n    }\\n\\n    function depositWithTokenId(\\n        uint256 starkKey,\\n        uint256 assetType,\\n        uint256 tokenId,\\n        uint256 vaultId,\\n        uint256 quantizedAmount\\n    ) public notFrozen {\\n        // The vaultId is not validated but should be in the allowed range supported by the\\n        // exchange. If not, it will be ignored by the exchange and the starkKey owner may reclaim\\n        // the funds by using depositCancel + depositReclaim.\\n        require(isAssetTypeWithTokenId(assetType), \\\"INVALID_ASSET_TYPE\\\");\\n\\n        uint256 assetId = calculateAssetIdWithTokenId(assetType, tokenId);\\n\\n        // Updates the pendingDeposits balance and clears cancellationRequests when applicable.\\n        uint256 newVaultBalance = depositStateUpdate(starkKey, assetId, vaultId, quantizedAmount);\\n\\n        // No need to verify amount > 0, a deposit with amount = 0 can be used to undo cancellation.\\n        if (isERC721(assetType)) {\\n            require(newVaultBalance <= 1, \\\"ILLEGAL_ERC721_AMOUNT\\\");\\n            emit LogNftDeposit(msg.sender, starkKey, vaultId, assetType, tokenId, assetId);\\n        }\\n        // Transfer the tokens to the Deposit contract.\\n        transferInWithTokenId(assetType, tokenId, quantizedAmount);\\n        // Log event.\\n        emit LogDepositWithTokenId(\\n            msg.sender,\\n            starkKey,\\n            vaultId,\\n            assetType,\\n            tokenId,\\n            assetId,\\n            fromQuantized(assetType, quantizedAmount),\\n            quantizedAmount\\n        );\\n    }\\n\\n    function getCancellationRequest(\\n        uint256 starkKey,\\n        uint256 assetId,\\n        uint256 vaultId\\n    ) external view returns (uint256 request) {\\n        request = cancellationRequests[starkKey][assetId][vaultId];\\n    }\\n\\n    function depositERC20(\\n        uint256 starkKey,\\n        uint256 assetType,\\n        uint256 vaultId,\\n        uint256 quantizedAmount\\n    ) public override {\\n        deposit(starkKey, assetType, vaultId, quantizedAmount);\\n    }\\n\\n    // NOLINTNEXTLINE: locked-ether.\\n    function depositEth(\\n        uint256 starkKey,\\n        uint256 assetType,\\n        uint256 vaultId\\n    ) public payable override {\\n        require(isEther(assetType), \\\"INVALID_ASSET_TYPE\\\");\\n        deposit(starkKey, assetType, vaultId, toQuantized(assetType, msg.value));\\n    }\\n\\n    function deposit(\\n        uint256 starkKey,\\n        uint256 assetType,\\n        uint256 vaultId,\\n        uint256 quantizedAmount\\n    ) public notFrozen {\\n        // The vaultId is not validated but should be in the allowed range supported by the\\n        // exchange. If not, it will be ignored by the exchange and the starkKey owner may reclaim\\n        // the funds by using depositCancel + depositReclaim.\\n\\n        // No need to verify amount > 0, a deposit with amount = 0 can be used to undo cancellation.\\n        require(!isMintableAssetType(assetType), \\\"MINTABLE_ASSET_TYPE\\\");\\n        require(isFungibleAssetType(assetType), \\\"NON_FUNGIBLE_ASSET_TYPE\\\");\\n\\n        uint256 assetId = assetType;\\n\\n        // Updates the pendingDeposits balance and clears cancellationRequests when applicable.\\n        depositStateUpdate(starkKey, assetId, vaultId, quantizedAmount);\\n\\n        // Transfer the tokens to the Deposit contract.\\n        transferIn(assetType, quantizedAmount);\\n\\n        // Log event.\\n        emit LogDeposit(\\n            msg.sender,\\n            starkKey,\\n            vaultId,\\n            assetType,\\n            fromQuantized(assetType, quantizedAmount),\\n            quantizedAmount\\n        );\\n    }\\n\\n    function deposit(\\n        // NOLINT: locked-ether.\\n        uint256 starkKey,\\n        uint256 assetType,\\n        uint256 vaultId\\n    ) external payable {\\n        require(isEther(assetType), \\\"INVALID_ASSET_TYPE\\\");\\n        deposit(starkKey, assetType, vaultId, toQuantized(assetType, msg.value));\\n    }\\n\\n    function depositCancel(\\n        uint256 starkKey,\\n        uint256 assetId,\\n        uint256 vaultId\\n    )\\n        external\\n        onlyKeyOwner(starkKey)\\n    // No notFrozen modifier: This function can always be used, even when frozen.\\n    {\\n        // Start the timeout.\\n        cancellationRequests[starkKey][assetId][vaultId] = block.timestamp;\\n\\n        // Log event.\\n        emit LogDepositCancel(starkKey, vaultId, assetId);\\n    }\\n\\n    function clearCancelledDeposit(\\n        uint256 starkKey,\\n        uint256 assetId,\\n        uint256 vaultId\\n    ) private returns (uint256) {\\n        // Make sure enough time has passed.\\n        uint256 requestTime = cancellationRequests[starkKey][assetId][vaultId];\\n        require(requestTime != 0, \\\"DEPOSIT_NOT_CANCELED\\\");\\n        uint256 freeTime = requestTime + DEPOSIT_CANCEL_DELAY;\\n        assert(freeTime >= DEPOSIT_CANCEL_DELAY);\\n        require(block.timestamp >= freeTime, \\\"DEPOSIT_LOCKED\\\"); // NOLINT: timestamp.\\n\\n        // Clear deposit.\\n        uint256 quantizedAmount = pendingDeposits[starkKey][assetId][vaultId];\\n        delete pendingDeposits[starkKey][assetId][vaultId];\\n        delete cancellationRequests[starkKey][assetId][vaultId];\\n\\n        // Return the cleared amount so it can be transferred back to the reclaimer.\\n        return quantizedAmount;\\n    }\\n\\n    function depositReclaim(\\n        uint256 starkKey,\\n        uint256 assetType,\\n        uint256 vaultId\\n    )\\n        external\\n        onlyKeyOwner(starkKey)\\n    // No notFrozen modifier: This function can always be used, even when frozen.\\n    {\\n        require(isFungibleAssetType(assetType), \\\"NON_FUNGIBLE_ASSET_TYPE\\\");\\n\\n        // Clear deposit and attain the cleared amount to be transferred out.\\n        uint256 assetId = assetType;\\n        uint256 quantizedAmount = clearCancelledDeposit(starkKey, assetId, vaultId);\\n\\n        // Refund deposit.\\n        transferOut(msg.sender, assetType, quantizedAmount);\\n\\n        // Log event.\\n        emit LogDepositCancelReclaimed(\\n            starkKey,\\n            vaultId,\\n            assetType,\\n            fromQuantized(assetType, quantizedAmount),\\n            quantizedAmount\\n        );\\n    }\\n\\n    function depositWithTokenIdReclaim(\\n        uint256 starkKey,\\n        uint256 assetType,\\n        uint256 tokenId,\\n        uint256 vaultId\\n    )\\n        public\\n        onlyKeyOwner(starkKey)\\n    // No notFrozen modifier: This function can always be used, even when frozen.\\n    {\\n        require(isAssetTypeWithTokenId(assetType), \\\"INVALID_ASSET_TYPE\\\");\\n\\n        // Clear deposit and attain the cleared amount to be transferred out.\\n        uint256 assetId = calculateAssetIdWithTokenId(assetType, tokenId);\\n        uint256 quantizedAmount = clearCancelledDeposit(starkKey, assetId, vaultId);\\n\\n        if (quantizedAmount > 0) {\\n            // Refund deposit.\\n            transferOutWithTokenId(msg.sender, assetType, tokenId, quantizedAmount);\\n        }\\n\\n        // Log event.\\n        if (isERC721(assetType)) {\\n            emit LogDepositNftCancelReclaimed(starkKey, vaultId, assetType, tokenId, assetId);\\n        }\\n        emit LogDepositWithTokenIdCancelReclaimed(\\n            starkKey,\\n            vaultId,\\n            assetType,\\n            tokenId,\\n            assetId,\\n            fromQuantized(assetType, quantizedAmount),\\n            quantizedAmount\\n        );\\n    }\\n\\n    function depositNftReclaim(\\n        uint256 starkKey,\\n        uint256 assetType,\\n        uint256 vaultId,\\n        uint256 tokenId\\n    )\\n        external\\n        onlyKeyOwner(starkKey)\\n    // No notFrozen modifier: This function can always be used, even when frozen.\\n    {\\n        depositWithTokenIdReclaim(starkKey, assetType, tokenId, vaultId);\\n    }\\n}\\n\"\r\n    },\r\n    \"ERC721Receiver.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"IERC721Receiver.sol\\\";\\n\\n/*\\n  ERC721 token receiver interface\\n  EIP-721 requires any contract receiving ERC721 tokens to implement IERC721Receiver interface.\\n  By EIP, safeTransferFrom API of ERC721 shall call onERC721Received on the receiving contract.\\n\\n  Have the receiving contract failed to respond as expected, the safeTransferFrom shall be reverted.\\n\\n  Params:\\n  `operator` The address which called `safeTransferFrom` function\\n  `from` The address which previously owned the token\\n  `tokenId` The NFT identifier which is being transferred\\n  `data` Additional data with no specified format\\n\\n  Returns:\\n  When invoked by the main contract, following the deposit pattern:\\n   `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`, which indicates success.\\n  In all other cases: `bytes4(0)`, which should fail ERC721's safeTransferFrom.\\n*/\\ncontract ERC721Receiver is IERC721Receiver {\\n    function onERC721Received(\\n        address operator, // The address which called `safeTransferFrom` function.\\n        address, // from - The address which previously owned the token.\\n        uint256, // tokenId -  The NFT identifier which is being transferred.\\n        bytes calldata // data - Additional data with no specified format.\\n    ) external override returns (bytes4) {\\n        return (operator == address(this) ? this.onERC721Received.selector : bytes4(0));\\n    }\\n}\\n\"\r\n    },\r\n    \"Freezable.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"LibConstants.sol\\\";\\nimport \\\"MFreezable.sol\\\";\\nimport \\\"MGovernance.sol\\\";\\nimport \\\"MainStorage.sol\\\";\\n\\n/*\\n  Implements MFreezable.\\n*/\\nabstract contract Freezable is MainStorage, LibConstants, MGovernance, MFreezable {\\n    event LogFrozen();\\n    event LogUnFrozen();\\n\\n    function isFrozen() public view override returns (bool) {\\n        return stateFrozen;\\n    }\\n\\n    function validateFreezeRequest(uint256 requestTime) internal override {\\n        require(requestTime != 0, \\\"FORCED_ACTION_UNREQUESTED\\\");\\n        // Verify timer on escape request.\\n        uint256 freezeTime = requestTime + FREEZE_GRACE_PERIOD;\\n\\n        // Prevent wraparound.\\n        assert(freezeTime >= FREEZE_GRACE_PERIOD);\\n        require(block.timestamp >= freezeTime, \\\"FORCED_ACTION_PENDING\\\"); // NOLINT: timestamp.\\n\\n        // Forced action requests placed before freeze, are no longer valid after the un-freeze.\\n        require(freezeTime > unFreezeTime, \\\"REFREEZE_ATTEMPT\\\");\\n    }\\n\\n    function freeze() internal override notFrozen {\\n        unFreezeTime = block.timestamp + UNFREEZE_DELAY;\\n\\n        // Update state.\\n        stateFrozen = true;\\n\\n        // Log event.\\n        emit LogFrozen();\\n    }\\n\\n    function unFreeze() external onlyFrozen onlyGovernance {\\n        require(block.timestamp >= unFreezeTime, \\\"UNFREEZE_NOT_ALLOWED_YET\\\");\\n\\n        // Update state.\\n        stateFrozen = false;\\n\\n        // Increment roots to invalidate them, w/o losing information.\\n        validiumVaultRoot += 1;\\n        rollupVaultRoot += 1;\\n        orderRoot += 1;\\n\\n        // Log event.\\n        emit LogUnFrozen();\\n    }\\n}\\n\"\r\n    },\r\n    \"Governance.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"MGovernance.sol\\\";\\n\\n/*\\n  Implements Generic Governance, applicable for both proxy and main contract, and possibly others.\\n  Notes:\\n   The use of the same function names by both the Proxy and a delegated implementation\\n   is not possible since calling the implementation functions is done via the default function\\n   of the Proxy. For this reason, for example, the implementation of MainContract (MainGovernance)\\n   exposes mainIsGovernor, which calls the internal _isGovernor method.\\n*/\\nstruct GovernanceInfoStruct {\\n    mapping(address => bool) effectiveGovernors;\\n    address candidateGovernor;\\n    bool initialized;\\n}\\n\\nabstract contract Governance is MGovernance {\\n    event LogNominatedGovernor(address nominatedGovernor);\\n    event LogNewGovernorAccepted(address acceptedGovernor);\\n    event LogRemovedGovernor(address removedGovernor);\\n    event LogNominationCancelled();\\n\\n    function getGovernanceInfo() internal view virtual returns (GovernanceInfoStruct storage);\\n\\n    /*\\n      Current code intentionally prevents governance re-initialization.\\n      This may be a problem in an upgrade situation, in a case that the upgrade-to implementation\\n      performs an initialization (for real) and within that calls initGovernance().\\n\\n      Possible workarounds:\\n      1. Clearing the governance info altogether by changing the MAIN_GOVERNANCE_INFO_TAG.\\n         This will remove existing main governance information.\\n      2. Modify the require part in this function, so that it will exit quietly\\n         when trying to re-initialize (uncomment the lines below).\\n    */\\n    function initGovernance() internal {\\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\\n        require(!gub.initialized, \\\"ALREADY_INITIALIZED\\\");\\n        gub.initialized = true; // to ensure acceptNewGovernor() won't fail.\\n        // Add the initial governer.\\n        acceptNewGovernor(msg.sender);\\n    }\\n\\n    function _isGovernor(address user) internal view override returns (bool) {\\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\\n        return gub.effectiveGovernors[user];\\n    }\\n\\n    /*\\n      Cancels the nomination of a governor candidate.\\n    */\\n    function _cancelNomination() internal onlyGovernance {\\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\\n        if (gub.candidateGovernor != address(0x0)) {\\n            gub.candidateGovernor = address(0x0);\\n            emit LogNominationCancelled();\\n        }\\n    }\\n\\n    function _nominateNewGovernor(address newGovernor) internal onlyGovernance {\\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\\n        require(newGovernor != address(0x0), \\\"BAD_ADDRESS\\\");\\n        require(!_isGovernor(newGovernor), \\\"ALREADY_GOVERNOR\\\");\\n        require(gub.candidateGovernor == address(0x0), \\\"OTHER_CANDIDATE_PENDING\\\");\\n        gub.candidateGovernor = newGovernor;\\n        emit LogNominatedGovernor(newGovernor);\\n    }\\n\\n    /*\\n      The acceptNewGovernor is called in two cases:\\n      1. by _acceptGovernance when a new governor accepts its role.\\n      2. by initGovernance to add the initial governor.\\n      The difference is that the init path skips the nominate step\\n      that would fail because of the onlyGovernance modifier.\\n    */\\n    function acceptNewGovernor(address newGovernor) private {\\n        require(!_isGovernor(newGovernor), \\\"ALREADY_GOVERNOR\\\");\\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\\n        gub.effectiveGovernors[newGovernor] = true;\\n\\n        // Emit governance information.\\n        emit LogNewGovernorAccepted(newGovernor);\\n    }\\n\\n    function _acceptGovernance() internal {\\n        // The new governor was proposed as a candidate by the current governor.\\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\\n        require(msg.sender == gub.candidateGovernor, \\\"ONLY_CANDIDATE_GOVERNOR\\\");\\n\\n        // Update state.\\n        acceptNewGovernor(msg.sender);\\n        gub.candidateGovernor = address(0x0);\\n    }\\n\\n    /*\\n      Remove a governor from office.\\n    */\\n    function _removeGovernor(address governorForRemoval) internal onlyGovernance {\\n        require(msg.sender != governorForRemoval, \\\"GOVERNOR_SELF_REMOVE\\\");\\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\\n        require(_isGovernor(governorForRemoval), \\\"NOT_GOVERNOR\\\");\\n        gub.effectiveGovernors[governorForRemoval] = false;\\n        emit LogRemovedGovernor(governorForRemoval);\\n    }\\n}\\n\"\r\n    },\r\n    \"GovernanceStorage.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\nimport {GovernanceInfoStruct} from \\\"Governance.sol\\\";\\n\\n/*\\n  Holds the governance slots for ALL entities, including proxy and the main contract.\\n*/\\ncontract GovernanceStorage {\\n    // A map from a Governor tag to its own GovernanceInfoStruct.\\n    mapping(string => GovernanceInfoStruct) internal governanceInfo; //NOLINT uninitialized-state.\\n}\\n\"\r\n    },\r\n    \"IERC1155.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: MIT.\\npragma solidity ^0.6.12;\\n\\n/**\\n  Required interface of an ERC1155 compliant contract, as defined in the\\n  https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n\\n  _Available since v3.1.\\n*/\\ninterface IERC1155 {\\n    /**\\n      Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n    */\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 value\\n    );\\n\\n    /**\\n      Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n      transfers.\\n    */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n      Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n      `approved`.\\n    */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n      Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n\\n      If an {URI} event was emitted for `id`, the standard\\n      https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n      returned by {IERC1155MetadataURI-uri}.\\n    */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n      Returns the amount of tokens of token type `id` owned by `account`.\\n\\n      Requirements:\\n\\n      - `account` cannot be the zero address.\\n    */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n      Requirements:\\n\\n      - `accounts` and `ids` must have the same length.\\n    */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n      Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n\\n      Emits an {ApprovalForAll} event.\\n\\n      Requirements:\\n\\n      - `operator` cannot be the caller.\\n    */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n      Returns true if `operator` is approved to transfer ``account``'s tokens.\\n\\n      See {setApprovalForAll}.\\n    */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n      Transfers `amount` tokens of token type `id` from `from` to `to`.\\n\\n      Emits a {TransferSingle} event.\\n\\n      Requirements:\\n\\n      - `to` cannot be the zero address.\\n      - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n      - `from` must have a balance of tokens of type `id` of at least `amount`.\\n      - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n      acceptance magic value.\\n    */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n      Emits a {TransferBatch} event.\\n\\n      Requirements:\\n\\n      - `ids` and `amounts` must have the same length.\\n      - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n      acceptance magic value.\\n    */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\n/**\\n  Interface of the ERC20 standard as defined in the EIP. Does not include\\n  the optional functions; to access them see {ERC20Detailed}.\\n*/\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"IERC721Receiver.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"Identity.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\ninterface Identity {\\n    /*\\n      Allows a caller to ensure that the provided address is of the expected type and version.\\n    */\\n    function identify() external pure returns (string memory);\\n}\\n\"\r\n    },\r\n    \"KeyGetters.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"MainStorage.sol\\\";\\nimport \\\"MKeyGetters.sol\\\";\\n\\n/*\\n  Implements MKeyGetters.\\n*/\\ncontract KeyGetters is MainStorage, MKeyGetters {\\n    uint256 internal constant MASK_ADDRESS = (1 << 160) - 1;\\n\\n    /*\\n      Returns the Ethereum public key (address) that owns the given ownerKey.\\n      If the ownerKey size is within the range of an Ethereum address (i.e. < 2**160)\\n      it returns the owner key itself.\\n\\n      If the ownerKey is larger than a potential eth address, the eth address for which the starkKey\\n      was registered is returned, and 0 if the starkKey is not registered.\\n\\n      Note - prior to version 4.0 this function reverted on an unregistered starkKey.\\n      For a variant of this function that reverts on an unregistered starkKey, use strictGetEthKey.\\n    */\\n    function getEthKey(uint256 ownerKey) public view override returns (address) {\\n        address registeredEth = ethKeys[ownerKey];\\n\\n        if (registeredEth != address(0x0)) {\\n            return registeredEth;\\n        }\\n\\n        return ownerKey == (ownerKey & MASK_ADDRESS) ? address(ownerKey) : address(0x0);\\n    }\\n\\n    /*\\n      Same as getEthKey, but fails when a stark key is not registered.\\n    */\\n    function strictGetEthKey(uint256 ownerKey) internal view override returns (address ethKey) {\\n        ethKey = getEthKey(ownerKey);\\n        require(ethKey != address(0x0), \\\"USER_UNREGISTERED\\\");\\n    }\\n\\n    function isMsgSenderKeyOwner(uint256 ownerKey) internal view override returns (bool) {\\n        return msg.sender == getEthKey(ownerKey);\\n    }\\n}\\n\"\r\n    },\r\n    \"LibConstants.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\ncontract LibConstants {\\n    // Durations for time locked mechanisms (in seconds).\\n    // Note that it is known that miners can manipulate block timestamps\\n    // up to a deviation of a few seconds.\\n    // This mechanism should not be used for fine grained timing.\\n\\n    // The time required to cancel a deposit, in the case the operator does not move the funds\\n    // to the off-chain storage.\\n    uint256 public constant DEPOSIT_CANCEL_DELAY = 2 days;\\n\\n    // The time required to freeze the exchange, in the case the operator does not execute a\\n    // requested full withdrawal.\\n    uint256 public constant FREEZE_GRACE_PERIOD = 7 days;\\n\\n    // The time after which the exchange may be unfrozen after it froze. This should be enough time\\n    // for users to perform escape hatches to get back their funds.\\n    uint256 public constant UNFREEZE_DELAY = 365 days;\\n\\n    // Maximal number of verifiers which may co-exist.\\n    uint256 public constant MAX_VERIFIER_COUNT = uint256(64);\\n\\n    // The time required to remove a verifier in case of a verifier upgrade.\\n    uint256 public constant VERIFIER_REMOVAL_DELAY = FREEZE_GRACE_PERIOD + (21 days);\\n\\n    address constant ZERO_ADDRESS = address(0x0);\\n\\n    uint256 constant K_MODULUS = 0x800000000000011000000000000000000000000000000000000000000000001;\\n\\n    uint256 constant K_BETA = 0x6f21413efbe40de150e596d72f7a8c5609ad26c15c915c1f4cdfcb99cee9e89;\\n\\n    uint256 internal constant MASK_250 =\\n        0x03FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    uint256 internal constant MASK_240 =\\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n    uint256 public constant MAX_FORCED_ACTIONS_REQS_PER_BLOCK = 10;\\n\\n    uint256 constant QUANTUM_UPPER_BOUND = 2**128;\\n\\n    // All mintable asset ids have the MINTABLE_ASSET_ID_FLAG (251st bit) set.\\n    // Mintable ERC1155 and ERC20 assets have NON_UNIQUE_MINTABLE_ASSET_ID_FLAG (250th bit) set too.\\n    // Mintable ERC20s also have the MINTABLE_ERC20_ASSET_ID_FLAG (249th bit) set.\\n    // I.e. mintable asset ids that start with: 100 => ERC721, 110 => ERC1155, 111 => ERC20.\\n    // All non-mintable asset ids have the MINTABLE_ASSET_ID_FLAG bit off.\\n    uint256 internal constant MINTABLE_ASSET_ID_FLAG = 1 << 250;\\n    uint256 internal constant NON_UNIQUE_MINTABLE_ASSET_ID_FLAG = 1 << 249;\\n    uint256 internal constant MINTABLE_ERC20_ASSET_ID_FLAG = 1 << 248;\\n\\n    // Bit 64 (indexed 63, counting from 0) is a flag indicating a rollup vault id.\\n    uint256 constant ROLLUP_VAULTS_BIT = 63;\\n}\\n\"\r\n    },\r\n    \"MAcceptModifications.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\n/*\\n  Interface containing actions a verifier can invoke on the state.\\n  The contract containing the state should implement these and verify correctness.\\n*/\\nabstract contract MAcceptModifications {\\n    function acceptDeposit(\\n        uint256 ownerKey,\\n        uint256 vaultId,\\n        uint256 assetId,\\n        uint256 quantizedAmount\\n    ) internal virtual;\\n\\n    function allowWithdrawal(\\n        uint256 ownerKey,\\n        uint256 assetId,\\n        uint256 quantizedAmount\\n    ) internal virtual;\\n\\n    function acceptWithdrawal(\\n        uint256 ownerKey,\\n        uint256 assetId,\\n        uint256 quantizedAmount\\n    ) internal virtual;\\n}\\n\"\r\n    },\r\n    \"MDeposits.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nabstract contract MDeposits {\\n    function depositERC20(\\n        // NOLINT external-function.\\n        uint256 starkKey,\\n        uint256 assetType,\\n        uint256 vaultId,\\n        uint256 quantizedAmount\\n    ) public virtual;\\n\\n    function depositEth(\\n        // NOLINT external-function.\\n        uint256 starkKey,\\n        uint256 assetType,\\n        uint256 vaultId\\n    ) public payable virtual;\\n}\\n\"\r\n    },\r\n    \"MFreezable.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nabstract contract MFreezable {\\n    /*\\n      Returns true if the exchange is frozen.\\n    */\\n    function isFrozen() public view virtual returns (bool); // NOLINT: external-function.\\n\\n    /*\\n      Forbids calling the function if the exchange is frozen.\\n    */\\n    modifier notFrozen() {\\n        require(!isFrozen(), \\\"STATE_IS_FROZEN\\\");\\n        _;\\n    }\\n\\n    function validateFreezeRequest(uint256 requestTime) internal virtual;\\n\\n    /*\\n      Allows calling the function only if the exchange is frozen.\\n    */\\n    modifier onlyFrozen() {\\n        require(isFrozen(), \\\"STATE_NOT_FROZEN\\\");\\n        _;\\n    }\\n\\n    /*\\n      Freezes the exchange.\\n    */\\n    function freeze() internal virtual;\\n}\\n\"\r\n    },\r\n    \"MGovernance.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nabstract contract MGovernance {\\n    function _isGovernor(address user) internal view virtual returns (bool);\\n\\n    /*\\n      Allows calling the function only by a Governor.\\n    */\\n    modifier onlyGovernance() {\\n        require(_isGovernor(msg.sender), \\\"ONLY_GOVERNANCE\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"MKeyGetters.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nabstract contract MKeyGetters {\\n    // NOLINTNEXTLINE: external-function.\\n    function getEthKey(uint256 ownerKey) public view virtual returns (address);\\n\\n    function strictGetEthKey(uint256 ownerKey) internal view virtual returns (address);\\n\\n    function isMsgSenderKeyOwner(uint256 ownerKey) internal view virtual returns (bool);\\n\\n    /*\\n      Allows calling the function only if ownerKey is registered to msg.sender.\\n    */\\n    modifier onlyKeyOwner(uint256 ownerKey) {\\n        // Require the calling user to own the stark key.\\n        require(msg.sender == strictGetEthKey(ownerKey), \\\"MISMATCHING_STARK_ETH_KEYS\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"MTokenAssetData.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nabstract contract MTokenAssetData {\\n    // NOLINTNEXTLINE: external-function.\\n    function getAssetInfo(uint256 assetType) public view virtual returns (bytes memory);\\n\\n    function isEther(uint256 assetType) internal view virtual returns (bool);\\n\\n    function isERC20(uint256 assetType) internal view virtual returns (bool);\\n\\n    function isERC721(uint256 assetType) internal view virtual returns (bool);\\n\\n    function isERC1155(uint256 assetType) internal view virtual returns (bool);\\n\\n    function isFungibleAssetType(uint256 assetType) internal view virtual returns (bool);\\n\\n    function isMintableAssetType(uint256 assetType) internal view virtual returns (bool);\\n\\n    function isAssetTypeWithTokenId(uint256 assetType) internal view virtual returns (bool);\\n\\n    function extractContractAddress(uint256 assetType) internal view virtual returns (address);\\n\\n    function verifyAssetInfo(bytes memory assetInfo) internal view virtual;\\n\\n    function isNonFungibleAssetInfo(bytes memory assetInfo) internal pure virtual returns (bool);\\n\\n    function calculateAssetIdWithTokenId(uint256 assetType, uint256 tokenId)\\n        public\\n        view\\n        virtual\\n        returns (uint256);\\n\\n    function calculateMintableAssetId(uint256 assetType, bytes calldata mintingBlob)\\n        public\\n        view\\n        virtual\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"MTokenQuantization.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nabstract contract MTokenQuantization {\\n    function fromQuantized(uint256 presumedAssetType, uint256 quantizedAmount)\\n        internal\\n        view\\n        virtual\\n        returns (uint256 amount);\\n\\n    // NOLINTNEXTLINE: external-function.\\n    function getQuantum(uint256 presumedAssetType) public view virtual returns (uint256 quantum);\\n\\n    function toQuantized(uint256 presumedAssetType, uint256 amount)\\n        internal\\n        view\\n        virtual\\n        returns (uint256 quantizedAmount);\\n}\\n\"\r\n    },\r\n    \"MTokenTransfers.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nabstract contract MTokenTransfers {\\n    function transferIn(uint256 assetType, uint256 quantizedAmount) internal virtual;\\n\\n    function transferInWithTokenId(\\n        uint256 assetType,\\n        uint256 tokenId,\\n        uint256 quantizedAmount\\n    ) internal virtual;\\n\\n    function transferOut(\\n        address payable recipient,\\n        uint256 assetType,\\n        uint256 quantizedAmount\\n    ) internal virtual;\\n\\n    function transferOutWithTokenId(\\n        address recipient,\\n        uint256 assetType,\\n        uint256 tokenId,\\n        uint256 quantizedAmount\\n    ) internal virtual;\\n\\n    function transferOutMint(\\n        uint256 assetType,\\n        uint256 quantizedAmount,\\n        address recipient,\\n        bytes calldata mintingBlob\\n    ) internal virtual;\\n}\\n\"\r\n    },\r\n    \"MainGovernance.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"Governance.sol\\\";\\nimport \\\"GovernanceStorage.sol\\\";\\n\\n/**\\n  The StarkEx contract is governed by one or more Governors of which the initial one is the\\n  deployer of the contract.\\n\\n  A governor has the sole authority to perform the following operations:\\n\\n  1. Nominate additional governors (:sol:func:`mainNominateNewGovernor`)\\n  2. Remove other governors (:sol:func:`mainRemoveGovernor`)\\n  3. Add new :sol:mod:`Verifiers` and :sol:mod:`AvailabilityVerifiers`\\n  4. Remove :sol:mod:`Verifiers` and :sol:mod:`AvailabilityVerifiers` after a timelock allows it\\n  5. Nominate Operators (see :sol:mod:`Operator`) and Token Administrators (see :sol:mod:`TokenRegister`)\\n\\n  Adding governors is performed in a two step procedure:\\n\\n  1. First, an existing governor nominates a new governor (:sol:func:`mainNominateNewGovernor`)\\n  2. Then, the new governor must accept governance to become a governor (:sol:func:`mainAcceptGovernance`)\\n\\n  This two step procedure ensures that a governor public key cannot be nominated unless there is an\\n  entity that has the corresponding private key. This is intended to prevent errors in the addition\\n  process.\\n\\n  The governor private key should typically be held in a secure cold wallet.\\n*/\\n/*\\n  Implements Governance for the StarkDex main contract.\\n  The wrapper methods (e.g. mainIsGovernor wrapping _isGovernor) are needed to give\\n  the method unique names.\\n  Both Proxy and StarkExchange inherit from Governance. Thus, the logical contract method names\\n  must have unique names in order for the proxy to successfully delegate to them.\\n*/\\ncontract MainGovernance is GovernanceStorage, Governance {\\n    // The tag is the sting key that is used in the Governance storage mapping.\\n    string public constant MAIN_GOVERNANCE_INFO_TAG = \\\"StarkEx.Main.2019.GovernorsInformation\\\";\\n\\n    /*\\n      Returns the GovernanceInfoStruct associated with the governance tag.\\n    */\\n    function getGovernanceInfo() internal view override returns (GovernanceInfoStruct storage) {\\n        return governanceInfo[MAIN_GOVERNANCE_INFO_TAG];\\n    }\\n\\n    function mainIsGovernor(address user) external view returns (bool) {\\n        return _isGovernor(user);\\n    }\\n\\n    function mainNominateNewGovernor(address newGovernor) external {\\n        _nominateNewGovernor(newGovernor);\\n    }\\n\\n    function mainRemoveGovernor(address governorForRemoval) external {\\n        _removeGovernor(governorForRemoval);\\n    }\\n\\n    function mainAcceptGovernance() external {\\n        _acceptGovernance();\\n    }\\n\\n    function mainCancelNomination() external {\\n        _cancelNomination();\\n    }\\n}\\n\"\r\n    },\r\n    \"MainStorage.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"ProxyStorage.sol\\\";\\nimport \\\"Addresses.sol\\\";\\nimport {ApprovalChainData} from \\\"StarkExTypes.sol\\\";\\n\\n/*\\n  Holds ALL the main contract state (storage) variables.\\n*/\\ncontract MainStorage is ProxyStorage {\\n    uint256 internal constant LAYOUT_LENGTH = 2**64;\\n\\n    address escapeVerifierAddress; // NOLINT: constable-states.\\n\\n    // Global dex-frozen flag.\\n    bool stateFrozen; // NOLINT: constable-states.\\n\\n    // Time when unFreeze can be successfully called (UNFREEZE_DELAY after freeze).\\n    uint256 unFreezeTime; // NOLINT: constable-states.\\n\\n    // Pending deposits.\\n    // A map STARK key => asset id => vault id => quantized amount.\\n    mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256))) pendingDeposits;\\n\\n    // Cancellation requests.\\n    // A map STARK key => asset id => vault id => request timestamp.\\n    mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256))) cancellationRequests;\\n\\n    // Pending withdrawals.\\n    // A map STARK key => asset id => quantized amount.\\n    mapping(uint256 => mapping(uint256 => uint256)) pendingWithdrawals;\\n\\n    // vault_id => escape used boolean.\\n    mapping(uint256 => bool) escapesUsed;\\n\\n    // Number of escapes that were performed when frozen.\\n    uint256 escapesUsedCount; // NOLINT: constable-states.\\n\\n    // NOTE: fullWithdrawalRequests is deprecated, and replaced by forcedActionRequests.\\n    // NOLINTNEXTLINE naming-convention.\\n    mapping(uint256 => mapping(uint256 => uint256)) fullWithdrawalRequests_DEPRECATED;\\n\\n    // State sequence number.\\n    uint256 sequenceNumber; // NOLINT: constable-states uninitialized-state.\\n\\n    // Validium Vaults Tree Root & Height.\\n    uint256 validiumVaultRoot; // NOLINT: constable-states uninitialized-state.\\n    uint256 validiumTreeHeight; // NOLINT: constable-states uninitialized-state.\\n\\n    // Order Tree Root & Height.\\n    uint256 orderRoot; // NOLINT: constable-states uninitialized-state.\\n    uint256 orderTreeHeight; // NOLINT: constable-states uninitialized-state.\\n\\n    // True if and only if the address is allowed to add tokens.\\n    mapping(address => bool) tokenAdmins;\\n\\n    // This mapping is no longer in use, remains for backwards compatibility.\\n    mapping(address => bool) userAdmins_DEPRECATED; // NOLINT: naming-convention.\\n\\n    // True if and only if the address is an operator (allowed to update state).\\n    mapping(address => bool) operators; // NOLINT: uninitialized-state.\\n\\n    // Mapping of contract ID to asset data.\\n    mapping(uint256 => bytes) assetTypeToAssetInfo; // NOLINT: uninitialized-state.\\n\\n    // Mapping of registered contract IDs.\\n    mapping(uint256 => bool) registeredAssetType; // NOLINT: uninitialized-state.\\n\\n    // Mapping from contract ID to quantum.\\n    mapping(uint256 => uint256) assetTypeToQuantum; // NOLINT: uninitialized-state.\\n\\n    // This mapping is no longer in use, remains for backwards compatibility.\\n    mapping(address => uint256) starkKeys_DEPRECATED; // NOLINT: naming-convention.\\n\\n    // Mapping from STARK public key to the Ethereum public key of its owner.\\n    mapping(uint256 => address) ethKeys; // NOLINT: uninitialized-state.\\n\\n    // Timelocked state transition and availability verification chain.\\n    ApprovalChainData verifiersChain;\\n    ApprovalChainData availabilityVerifiersChain;\\n\\n    // Batch id of last accepted proof.\\n    uint256 lastBatchId; // NOLINT: constable-states uninitialized-state.\\n\\n    // Mapping between sub-contract index to sub-contract address.\\n    mapping(uint256 => address) subContracts; // NOLINT: uninitialized-state.\\n\\n    mapping(uint256 => bool) permissiveAssetType_DEPRECATED; // NOLINT: naming-convention.\\n    // ---- END OF MAIN STORAGE AS DEPLOYED IN STARKEX2.0 ----\\n\\n    // Onchain-data version configured for the system.\\n    uint256 onchainDataVersion_DEPRECATED; // NOLINT: naming-convention constable-states.\\n\\n    // Counter of forced action request in block. The key is the block number.\\n    mapping(uint256 => uint256) forcedRequestsInBlock;\\n\\n    // ForcedAction requests: actionHash => requestTime.\\n    mapping(bytes32 => uint256) forcedActionRequests;\\n\\n    // Mapping for timelocked actions.\\n    // A actionKey => activation time.\\n    mapping(bytes32 => uint256) actionsTimeLock;\\n\\n    // Append only list of requested forced action hashes.\\n    bytes32[] actionHashList;\\n    // ---- END OF MAIN STORAGE AS DEPLOYED IN STARKEX3.0 ----\\n    // ---- END OF MAIN STORAGE AS DEPLOYED IN STARKEX4.0 ----\\n\\n    // Rollup Vaults Tree Root & Height.\\n    uint256 rollupVaultRoot; // NOLINT: constable-states uninitialized-state.\\n    uint256 rollupTreeHeight; // NOLINT: constable-states uninitialized-state.\\n\\n    uint256 globalConfigCode; // NOLINT: constable-states uninitialized-state.\\n\\n    // Reserved storage space for Extensibility.\\n    // Every added MUST be added above the end gap, and the __endGap size must be reduced\\n    // accordingly.\\n    // NOLINTNEXTLINE: naming-convention.\\n    uint256[LAYOUT_LENGTH - 40] private __endGap; // __endGap complements layout to LAYOUT_LENGTH.\\n}\\n\"\r\n    },\r\n    \"PerpetualStorage.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"MainStorage.sol\\\";\\n\\n/*\\n  Extends MainStorage, holds Perpetual App specific state (storage) variables.\\n\\n  ALL State variables that are common to all applications, reside in MainStorage,\\n  whereas ALL the Perpetual app specific ones reside here.\\n*/\\ncontract PerpetualStorage is MainStorage {\\n    uint256 systemAssetType; // NOLINT: constable-states uninitialized-state.\\n\\n    bytes32 public globalConfigurationHash; // NOLINT: constable-states uninitialized-state.\\n\\n    mapping(uint256 => bytes32) public configurationHash; // NOLINT: uninitialized-state.\\n\\n    bytes32 sharedStateHash; // NOLINT: constable-states uninitialized-state.\\n\\n    // Configuration apply time-lock.\\n    // The delay is held in storage (and not constant)\\n    // So that it can be modified during upgrade.\\n    uint256 public configurationDelay; // NOLINT: constable-states.\\n\\n    // Reserved storage space for Extensibility.\\n    // Every added MUST be added above the end gap, and the __endGap size must be reduced\\n    // accordingly.\\n    // NOLINTNEXTLINE: naming-convention shadowing-abstract.\\n    uint256[LAYOUT_LENGTH - 5] private __endGap; // __endGap complements layout to LAYOUT_LENGTH.\\n}\\n\"\r\n    },\r\n    \"PerpetualTokenRegister.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"TokenRegister.sol\\\";\\nimport \\\"PerpetualStorage.sol\\\";\\n\\n/**\\n  Extension of the TokenRegister contract for StarkPerpetual.\\n\\n  The change is that asset registration defines the system asset,\\n  and permitted only once.\\n*/\\nabstract contract PerpetualTokenRegister is PerpetualStorage, TokenRegister {\\n    event LogSystemAssetType(uint256 assetType);\\n\\n    function registerToken(\\n        uint256, /* assetType */\\n        bytes calldata /* assetInfo */\\n    ) external override {\\n        revert(\\\"UNSUPPORTED_FUNCTION\\\");\\n    }\\n\\n    function registerToken(\\n        uint256, /* assetType */\\n        bytes memory, /* assetInfo */\\n        uint256 /* quantum */\\n    ) public override {\\n        revert(\\\"UNSUPPORTED_FUNCTION\\\");\\n    }\\n\\n    // NOLINTNEXTLINE external-function.\\n    function getSystemAssetType() public view returns (uint256) {\\n        return systemAssetType;\\n    }\\n\\n    function registerSystemAssetType(uint256 assetType, bytes calldata assetInfo)\\n        external\\n        onlyTokensAdmin\\n    {\\n        require(systemAssetType == uint256(0), \\\"SYSTEM_ASSET_TYPE_ALREADY_SET\\\");\\n        systemAssetType = assetType;\\n        super.registerToken(assetType, assetInfo, 1);\\n        emit LogSystemAssetType(assetType);\\n    }\\n}\\n\"\r\n    },\r\n    \"PerpetualTokensAndRamping.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"PerpetualTokenRegister.sol\\\";\\nimport \\\"TokenTransfers.sol\\\";\\nimport \\\"ERC721Receiver.sol\\\";\\nimport \\\"Freezable.sol\\\";\\nimport \\\"KeyGetters.sol\\\";\\nimport \\\"MainGovernance.sol\\\";\\nimport \\\"AcceptModifications.sol\\\";\\nimport \\\"Deposits.sol\\\";\\nimport \\\"TokenAssetData.sol\\\";\\nimport \\\"TokenQuantization.sol\\\";\\nimport \\\"Withdrawals.sol\\\";\\nimport \\\"SubContractor.sol\\\";\\n\\ncontract PerpetualTokensAndRamping is\\n    ERC721Receiver,\\n    SubContractor,\\n    Freezable,\\n    MainGovernance,\\n    AcceptModifications,\\n    TokenAssetData,\\n    TokenQuantization,\\n    TokenTransfers,\\n    PerpetualTokenRegister,\\n    KeyGetters,\\n    Deposits,\\n    Withdrawals\\n{\\n    function initialize(\\n        bytes calldata /* data */\\n    ) external override {\\n        revert(\\\"NOT_IMPLEMENTED\\\");\\n    }\\n\\n    function initializerSize() external view override returns (uint256) {\\n        return 0;\\n    }\\n\\n    function validatedSelectors() external pure override returns (bytes4[] memory selectors) {\\n        uint256 len_ = 3;\\n        uint256 index_ = 0;\\n\\n        selectors = new bytes4[](len_);\\n        selectors[index_++] = Deposits.depositCancel.selector;\\n        selectors[index_++] = Deposits.depositReclaim.selector;\\n        selectors[index_++] = Withdrawals.withdraw.selector;\\n        require(index_ == len_, \\\"INCORRECT_SELECTORS_ARRAY_LENGTH\\\");\\n    }\\n\\n    function identify() external pure override returns (string memory) {\\n        return \\\"StarkWare_PerpetualTokensAndRamping_2022_2\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"ProxyStorage.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"GovernanceStorage.sol\\\";\\n\\n/*\\n  Holds the Proxy-specific state variables.\\n  This contract is inherited by the GovernanceStorage (and indirectly by MainStorage)\\n  to prevent collision hazard.\\n*/\\ncontract ProxyStorage is GovernanceStorage {\\n    // NOLINTNEXTLINE: naming-convention uninitialized-state.\\n    mapping(address => bytes32) internal initializationHash_DEPRECATED;\\n\\n    // The time after which we can switch to the implementation.\\n    // Hash(implementation, data, finalize) => time.\\n    mapping(bytes32 => uint256) internal enabledTime;\\n\\n    // A central storage of the flags whether implementation has been initialized.\\n    // Note - it can be used flexibly enough to accommodate multiple levels of initialization\\n    // (i.e. using different key salting schemes for different initialization levels).\\n    mapping(bytes32 => bool) internal initialized;\\n}\\n\"\r\n    },\r\n    \"StarkExTypes.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\n// Structure representing a list of verifiers (validity/availability).\\n// A statement is valid only if all the verifiers in the list agree on it.\\n// Adding a verifier to the list is immediate - this is used for fast resolution of\\n// any soundness issues.\\n// Removing a verifier from the list is time-locked, to ensure that any user of the system\\n// not content with the announced removal has ample time to leave the system before it is\\n// removed.\\nstruct ApprovalChainData {\\n    address[] verifiers;\\n    // Represents the time after which the verifier with the given address can be removed.\\n    // Removal of the verifier with address A is allowed only in the case the value\\n    // of verifierAllowedRemovalTime[A] != 0 and verifierAllowedRemovalTime[A] < (current time).\\n    mapping(address => uint256) verifierAllowedRemovalTime;\\n}\\n\"\r\n    },\r\n    \"SubContractor.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"Identity.sol\\\";\\n\\ninterface SubContractor is Identity {\\n    function initialize(bytes calldata data) external;\\n\\n    function initializerSize() external view returns (uint256);\\n\\n    /*\\n      Returns an array with selectors for validation.\\n      These selectors are the critical ones for maintaining self custody and anti censorship.\\n      During the upgrade process, as part of the sub-contract validation, the MainDispatcher\\n      validates that the selectos are mapped to the correct sub-contract.\\n    */\\n    function validatedSelectors() external pure returns (bytes4[] memory);\\n}\\n\"\r\n    },\r\n    \"TokenAssetData.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"MainStorage.sol\\\";\\nimport \\\"MTokenAssetData.sol\\\";\\nimport \\\"Addresses.sol\\\";\\nimport \\\"LibConstants.sol\\\";\\n\\ncontract TokenAssetData is MainStorage, LibConstants, MTokenAssetData {\\n    bytes4 internal constant ERC20_SELECTOR = bytes4(keccak256(\\\"ERC20Token(address)\\\"));\\n    bytes4 internal constant ETH_SELECTOR = bytes4(keccak256(\\\"ETH()\\\"));\\n    bytes4 internal constant ERC721_SELECTOR = bytes4(keccak256(\\\"ERC721Token(address,uint256)\\\"));\\n    bytes4 internal constant ERC1155_SELECTOR = bytes4(keccak256(\\\"ERC1155Token(address,uint256)\\\"));\\n    bytes4 internal constant MINTABLE_ERC20_SELECTOR =\\n        bytes4(keccak256(\\\"MintableERC20Token(address)\\\"));\\n    bytes4 internal constant MINTABLE_ERC721_SELECTOR =\\n        bytes4(keccak256(\\\"MintableERC721Token(address,uint256)\\\"));\\n    bytes4 internal constant MINTABLE_ERC1155_SELECTOR =\\n        bytes4(keccak256(\\\"MintableERC1155Token(address,uint256)\\\"));\\n\\n    // The selector follows the 0x20 bytes assetInfo.length field.\\n    uint256 internal constant SELECTOR_OFFSET = 0x20;\\n    uint256 internal constant SELECTOR_SIZE = 4;\\n    uint256 internal constant TOKEN_CONTRACT_ADDRESS_OFFSET = SELECTOR_OFFSET + SELECTOR_SIZE;\\n    string internal constant NFT_ASSET_ID_PREFIX = \\\"NFT:\\\";\\n    string internal constant NON_MINTABLE_PREFIX = \\\"NON_MINTABLE:\\\";\\n    string internal constant MINTABLE_PREFIX = \\\"MINTABLE:\\\";\\n\\n    using Addresses for address;\\n\\n    /*\\n      Extract the tokenSelector from assetInfo.\\n\\n      Works like bytes4 tokenSelector = abi.decode(assetInfo, (bytes4))\\n      but does not revert when assetInfo.length < SELECTOR_OFFSET.\\n    */\\n    function extractTokenSelectorFromAssetInfo(bytes memory assetInfo)\\n        private\\n        pure\\n        returns (bytes4 selector)\\n    {\\n        assembly {\\n            selector := and(\\n                0xffffffff00000000000000000000000000000000000000000000000000000000,\\n                mload(add(assetInfo, SELECTOR_OFFSET))\\n            )\\n        }\\n    }\\n\\n    function getAssetInfo(uint256 assetType) public view override returns (bytes memory assetInfo) {\\n        // Verify that the registration is set and valid.\\n        require(registeredAssetType[assetType], \\\"ASSET_TYPE_NOT_REGISTERED\\\");\\n\\n        // Retrieve registration.\\n        assetInfo = assetTypeToAssetInfo[assetType];\\n    }\\n\\n    function extractTokenSelectorFromAssetType(uint256 assetType) private view returns (bytes4) {\\n        return extractTokenSelectorFromAssetInfo(getAssetInfo(assetType));\\n    }\\n\\n    function isEther(uint256 assetType) internal view override returns (bool) {\\n        return extractTokenSelectorFromAssetType(assetType) == ETH_SELECTOR;\\n    }\\n\\n    function isERC20(uint256 assetType) internal view override returns (bool) {\\n        return extractTokenSelectorFromAssetType(assetType) == ERC20_SELECTOR;\\n    }\\n\\n    function isERC721(uint256 assetType) internal view override returns (bool) {\\n        return extractTokenSelectorFromAssetType(assetType) == ERC721_SELECTOR;\\n    }\\n\\n    function isERC1155(uint256 assetType) internal view override returns (bool) {\\n        return extractTokenSelectorFromAssetType(assetType) == ERC1155_SELECTOR;\\n    }\\n\\n    function isFungibleAssetType(uint256 assetType) internal view override returns (bool) {\\n        bytes4 tokenSelector = extractTokenSelectorFromAssetType(assetType);\\n        return\\n            tokenSelector == ETH_SELECTOR ||\\n            tokenSelector == ERC20_SELECTOR ||\\n            tokenSelector == MINTABLE_ERC20_SELECTOR;\\n    }\\n\\n    function isMintableAssetType(uint256 assetType) internal view override returns (bool) {\\n        bytes4 tokenSelector = extractTokenSelectorFromAssetType(assetType);\\n        return\\n            tokenSelector == MINTABLE_ERC20_SELECTOR ||\\n            tokenSelector == MINTABLE_ERC721_SELECTOR ||\\n            tokenSelector == MINTABLE_ERC1155_SELECTOR;\\n    }\\n\\n    function isAssetTypeWithTokenId(uint256 assetType) internal view override returns (bool) {\\n        bytes4 tokenSelector = extractTokenSelectorFromAssetType(assetType);\\n        return tokenSelector == ERC721_SELECTOR || tokenSelector == ERC1155_SELECTOR;\\n    }\\n\\n    function isTokenSupported(bytes4 tokenSelector) private pure returns (bool) {\\n        return\\n            tokenSelector == ETH_SELECTOR ||\\n            tokenSelector == ERC20_SELECTOR ||\\n            tokenSelector == ERC721_SELECTOR ||\\n            tokenSelector == ERC1155_SELECTOR ||\\n            tokenSelector == MINTABLE_ERC20_SELECTOR ||\\n            tokenSelector == MINTABLE_ERC721_SELECTOR ||\\n            tokenSelector == MINTABLE_ERC1155_SELECTOR;\\n    }\\n\\n    function extractContractAddressFromAssetInfo(bytes memory assetInfo)\\n        private\\n        pure\\n        returns (address)\\n    {\\n        uint256 offset = TOKEN_CONTRACT_ADDRESS_OFFSET;\\n        uint256 res;\\n        assembly {\\n            res := mload(add(assetInfo, offset))\\n        }\\n        return address(res);\\n    }\\n\\n    function extractContractAddress(uint256 assetType) internal view override returns (address) {\\n        return extractContractAddressFromAssetInfo(getAssetInfo(assetType));\\n    }\\n\\n    function verifyAssetInfo(bytes memory assetInfo) internal view override {\\n        bytes4 tokenSelector = extractTokenSelectorFromAssetInfo(assetInfo);\\n\\n        // Ensure the selector is of an asset type we know.\\n        require(isTokenSupported(tokenSelector), \\\"UNSUPPORTED_TOKEN_TYPE\\\");\\n\\n        if (tokenSelector == ETH_SELECTOR) {\\n            // Assset info for ETH assetType is only a selector, i.e. 4 bytes length.\\n            require(assetInfo.length == 4, \\\"INVALID_ASSET_STRING\\\");\\n        } else {\\n            // Assset info for other asset types are a selector + uint256 concatanation.\\n            // We pass the address as a uint256 (zero padded),\\n            // thus its length is 0x04 + 0x20 = 0x24.\\n            require(assetInfo.length == 0x24, \\\"INVALID_ASSET_STRING\\\");\\n            address tokenAddress = extractContractAddressFromAssetInfo(assetInfo);\\n            require(tokenAddress.isContract(), \\\"BAD_TOKEN_ADDRESS\\\");\\n        }\\n    }\\n\\n    function isNonFungibleAssetInfo(bytes memory assetInfo) internal pure override returns (bool) {\\n        bytes4 tokenSelector = extractTokenSelectorFromAssetInfo(assetInfo);\\n        return tokenSelector == ERC721_SELECTOR || tokenSelector == MINTABLE_ERC721_SELECTOR;\\n    }\\n\\n    function calculateAssetIdWithTokenId(uint256 assetType, uint256 tokenId)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        require(isAssetTypeWithTokenId(assetType), \\\"ASSET_TYPE_DOES_NOT_TAKE_TOKEN_ID\\\");\\n\\n        string memory prefix = isERC721(assetType) ? NFT_ASSET_ID_PREFIX : NON_MINTABLE_PREFIX;\\n        return uint256(keccak256(abi.encodePacked(prefix, assetType, tokenId))) & MASK_250;\\n    }\\n\\n    function calculateMintableAssetId(uint256 assetType, bytes calldata mintingBlob)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        require(isMintableAssetType(assetType), \\\"NON_MINTABLE_ASSET_TYPE\\\");\\n\\n        // All mintable asset ids have the MINTABLE_ASSET_ID_FLAG (251st bit) set.\\n        // Mintable ERC1155 and ERC20 assets have NON_UNIQUE_MINTABLE_ASSET_ID_FLAG (250th bit) set.\\n        // Mintable ERC20s also have the MINTABLE_ERC20_ASSET_ID_FLAG (249th bit) set.\\n        // I.e. mintable asset ids that start with: 100 => ERC721, 110 => ERC1155, 111 => ERC20.\\n\\n        uint256 mintable_asset_flags = MINTABLE_ASSET_ID_FLAG;\\n        bytes4 selector = extractTokenSelectorFromAssetType(assetType);\\n        if (selector == MINTABLE_ERC1155_SELECTOR || selector == MINTABLE_ERC20_SELECTOR) {\\n            mintable_asset_flags = mintable_asset_flags | NON_UNIQUE_MINTABLE_ASSET_ID_FLAG;\\n        }\\n        if (selector == MINTABLE_ERC20_SELECTOR) {\\n            mintable_asset_flags = mintable_asset_flags | MINTABLE_ERC20_ASSET_ID_FLAG;\\n        }\\n\\n        uint256 blobHash = uint256(keccak256(mintingBlob));\\n        return\\n            (uint256(keccak256(abi.encodePacked(MINTABLE_PREFIX, assetType, blobHash))) &\\n                MASK_240) | mintable_asset_flags;\\n    }\\n}\\n\"\r\n    },\r\n    \"TokenQuantization.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"MainStorage.sol\\\";\\nimport \\\"MTokenQuantization.sol\\\";\\n\\ncontract TokenQuantization is MainStorage, MTokenQuantization {\\n    function fromQuantized(uint256 presumedAssetType, uint256 quantizedAmount)\\n        internal\\n        view\\n        override\\n        returns (uint256 amount)\\n    {\\n        uint256 quantum = getQuantum(presumedAssetType);\\n        amount = quantizedAmount * quantum;\\n        require(amount / quantum == quantizedAmount, \\\"DEQUANTIZATION_OVERFLOW\\\");\\n    }\\n\\n    function getQuantum(uint256 presumedAssetType) public view override returns (uint256 quantum) {\\n        if (!registeredAssetType[presumedAssetType]) {\\n            // Default quantization, for NFTs etc.\\n            quantum = 1;\\n        } else {\\n            // Retrieve registration.\\n            quantum = assetTypeToQuantum[presumedAssetType];\\n        }\\n    }\\n\\n    function toQuantized(uint256 presumedAssetType, uint256 amount)\\n        internal\\n        view\\n        override\\n        returns (uint256 quantizedAmount)\\n    {\\n        uint256 quantum = getQuantum(presumedAssetType);\\n        require(amount % quantum == 0, \\\"INVALID_AMOUNT\\\");\\n        quantizedAmount = amount / quantum;\\n    }\\n}\\n\"\r\n    },\r\n    \"TokenRegister.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"LibConstants.sol\\\";\\nimport \\\"MGovernance.sol\\\";\\nimport \\\"MTokenAssetData.sol\\\";\\nimport \\\"IERC20.sol\\\";\\nimport \\\"MainStorage.sol\\\";\\n\\n/**\\n  Registration of a new token (:sol:func:`registerToken`) entails defining a new asset type within\\n  the system, and associating it with an `assetInfo` array of\\n  bytes and a quantization factor (`quantum`).\\n\\n  The `assetInfo` is a byte array, with a size depending on the token.\\n  For ETH, assetInfo is 4 bytes long. For ERC20 tokens, it is 36 bytes long.\\n\\n  For each token type, the following constant 4-byte hash is defined, called the `selector`:\\n\\n   | `ETH_SELECTOR = bytes4(keccak256(\\\"ETH()\\\"));`\\n   | `ERC20_SELECTOR = bytes4(keccak256(\\\"ERC20Token(address)\\\"));`\\n   | `ERC721_SELECTOR = bytes4(keccak256(\\\"ERC721Token(address,uint256)\\\"));`\\n   | `ERC1155_SELECTOR = bytes4(keccak256(\\\"ERC1155Token(address,uint256)\\\"));`\\n   | `MINTABLE_ERC20_SELECTOR = bytes4(keccak256(\\\"MintableERC20Token(address)\\\"));`\\n   | `MINTABLE_ERC721_SELECTOR = bytes4(keccak256(\\\"MintableERC721Token(address,uint256)\\\"));`\\n   | `MINTABLE_ERC1155_SELECTOR = bytes4(keccak256(\\\"MintableERC1155Token(address,uint256)\\\"));`\\n\\n  For each token type, `assetInfo` is defined as follows:\\n      For ETH,\\n   | `assetInfo = ETH_SELECTOR;`\\n\\n      For all other selectors:\\n   | `assetInfo = abi.encodePacked(SELECTOR, address);`\\n      Where 'address' is a 32 byte representation of the ERC20 token contract address,\\n      padded with leading zeros.\\n\\n  The `quantum` quantization factor defines the multiplicative transformation from the native token\\n  denomination as a 256b unsigned integer to a 63b unsigned integer representation as used by the\\n  Stark exchange. Only amounts in the native representation that represent an integer number of\\n  quanta are allowed in the system.\\n\\n  The asset type is restricted to be the result of a hash of the `assetInfo` and the\\n  `quantum` masked to 250 bits (to be less than the prime used) according to the following formula:\\n\\n  | ``uint256 assetType = uint256(keccak256(abi.encodePacked(assetInfo, quantum))) &``\\n  | ``0x03FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;``\\n\\n  Once registered, tokens cannot be removed from the system, as their IDs may be used by off-chain\\n  accounts.\\n\\n  New tokens may only be registered by a Token Administrator. A Token Administrator may be instantly\\n  appointed or removed by the contract Governor (see :sol:mod:`MainGovernance`). Typically, the\\n  Token Administrator's private key should be kept in a cold wallet.\\n*/\\nabstract contract TokenRegister is MainStorage, LibConstants, MGovernance, MTokenAssetData {\\n    event LogTokenRegistered(uint256 assetType, bytes assetInfo, uint256 quantum);\\n    event LogTokenAdminAdded(address tokenAdmin);\\n    event LogTokenAdminRemoved(address tokenAdmin);\\n\\n    modifier onlyTokensAdmin() {\\n        require(isTokenAdmin(msg.sender), \\\"ONLY_TOKENS_ADMIN\\\");\\n        _;\\n    }\\n\\n    function isTokenAdmin(address testedAdmin) public view returns (bool) {\\n        return tokenAdmins[testedAdmin];\\n    }\\n\\n    function registerTokenAdmin(address newAdmin) external onlyGovernance {\\n        tokenAdmins[newAdmin] = true;\\n        emit LogTokenAdminAdded(newAdmin);\\n    }\\n\\n    function unregisterTokenAdmin(address oldAdmin) external onlyGovernance {\\n        tokenAdmins[oldAdmin] = false;\\n        emit LogTokenAdminRemoved(oldAdmin);\\n    }\\n\\n    function isAssetRegistered(uint256 assetType) public view returns (bool) {\\n        return registeredAssetType[assetType];\\n    }\\n\\n    /*\\n      Registers a new asset to the system.\\n      Once added, it can not be removed and there is a limited number\\n      of slots available.\\n    */\\n    function registerToken(\\n        uint256 assetType,\\n        bytes calldata assetInfo,\\n        uint256 quantum\\n    ) public virtual onlyTokensAdmin {\\n        // Make sure it is not invalid or already registered.\\n        require(!isAssetRegistered(assetType), \\\"ASSET_ALREADY_REGISTERED\\\");\\n        require(assetType < K_MODULUS, \\\"INVALID_ASSET_TYPE\\\");\\n        require(quantum > 0, \\\"INVALID_QUANTUM\\\");\\n        require(quantum < QUANTUM_UPPER_BOUND, \\\"INVALID_QUANTUM\\\");\\n\\n        // Require that the assetType is the hash of the assetInfo and quantum truncated to 250 bits.\\n        uint256 enforcedId = uint256(keccak256(abi.encodePacked(assetInfo, quantum))) & MASK_250;\\n        require(assetType == enforcedId, \\\"INVALID_ASSET_TYPE\\\");\\n\\n        verifyAssetInfo(assetInfo);\\n        // NFTs quantum must equal one.\\n        if (isNonFungibleAssetInfo(assetInfo)) {\\n            require(quantum == 1, \\\"INVALID_NFT_QUANTUM\\\");\\n        }\\n\\n        // Add token to the in-storage structures.\\n        registeredAssetType[assetType] = true;\\n        assetTypeToAssetInfo[assetType] = assetInfo;\\n        assetTypeToQuantum[assetType] = quantum;\\n\\n        // Log the registration of a new token.\\n        emit LogTokenRegistered(assetType, assetInfo, quantum);\\n    }\\n\\n    function registerToken(uint256 assetType, bytes calldata assetInfo) external virtual {\\n        registerToken(assetType, assetInfo, 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"TokenTransfers.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"Addresses.sol\\\";\\nimport \\\"MTokenTransfers.sol\\\";\\nimport \\\"MTokenAssetData.sol\\\";\\nimport \\\"MTokenQuantization.sol\\\";\\nimport \\\"IERC1155.sol\\\";\\nimport \\\"IERC20.sol\\\";\\n\\n/*\\n  Implements various transferIn and transferOut functionalities.\\n*/\\nabstract contract TokenTransfers is MTokenQuantization, MTokenAssetData, MTokenTransfers {\\n    using Addresses for address;\\n    using Addresses for address payable;\\n\\n    /*\\n      Transfers funds from msg.sender to the exchange.\\n    */\\n    function transferIn(uint256 assetType, uint256 quantizedAmount) internal override {\\n        uint256 amount = fromQuantized(assetType, quantizedAmount);\\n        if (isERC20(assetType)) {\\n            if (quantizedAmount == 0) return;\\n            address tokenAddress = extractContractAddress(assetType);\\n            IERC20 token = IERC20(tokenAddress);\\n            uint256 exchangeBalanceBefore = token.balanceOf(address(this));\\n            bytes memory callData = abi.encodeWithSelector(\\n                token.transferFrom.selector,\\n                msg.sender,\\n                address(this),\\n                amount\\n            );\\n            tokenAddress.safeTokenContractCall(callData);\\n            uint256 exchangeBalanceAfter = token.balanceOf(address(this));\\n            require(exchangeBalanceAfter >= exchangeBalanceBefore, \\\"OVERFLOW\\\");\\n            // NOLINTNEXTLINE(incorrect-equality): strict equality needed.\\n            require(\\n                exchangeBalanceAfter == exchangeBalanceBefore + amount,\\n                \\\"INCORRECT_AMOUNT_TRANSFERRED\\\"\\n            );\\n        } else if (isEther(assetType)) {\\n            require(msg.value == amount, \\\"INCORRECT_DEPOSIT_AMOUNT\\\");\\n        } else {\\n            revert(\\\"UNSUPPORTED_TOKEN_TYPE\\\");\\n        }\\n    }\\n\\n    /*\\n      Transfers non fungible and semi fungible tokens from a user to the exchange.\\n    */\\n    function transferInWithTokenId(\\n        uint256 assetType,\\n        uint256 tokenId,\\n        uint256 quantizedAmount\\n    ) internal override {\\n        require(isAssetTypeWithTokenId(assetType), \\\"FUNGIBLE_ASSET_TYPE\\\");\\n\\n        if (isERC721(assetType)) {\\n            require(quantizedAmount == 1, \\\"ILLEGAL_NFT_BALANCE\\\");\\n            transferInNft(assetType, tokenId);\\n        } else if (quantizedAmount > 0) {\\n            transferInSft(assetType, tokenId, quantizedAmount);\\n        }\\n    }\\n\\n    function transferInNft(uint256 assetType, uint256 tokenId) private {\\n        require(isERC721(assetType), \\\"NOT_ERC721_TOKEN\\\");\\n        address tokenAddress = extractContractAddress(assetType);\\n\\n        tokenAddress.safeTokenContractCall(\\n            abi.encodeWithSignature(\\n                \\\"safeTransferFrom(address,address,uint256)\\\",\\n                msg.sender,\\n                address(this),\\n                tokenId\\n            )\\n        );\\n    }\\n\\n    function transferInSft(\\n        uint256 assetType,\\n        uint256 tokenId,\\n        uint256 quantizedAmount\\n    ) private {\\n        require(isERC1155(assetType), \\\"NOT_ERC1155_TOKEN\\\");\\n        if (quantizedAmount == 0) return;\\n\\n        uint256 amount = fromQuantized(assetType, quantizedAmount);\\n        address tokenAddress = extractContractAddress(assetType);\\n        IERC1155 token = IERC1155(tokenAddress);\\n        uint256 exchangeBalanceBefore = token.balanceOf(address(this), tokenId);\\n\\n        // Call an ERC1155 token transfer.\\n        tokenAddress.safeTokenContractCall(\\n            abi.encodeWithSelector(\\n                token.safeTransferFrom.selector,\\n                msg.sender,\\n                address(this),\\n                tokenId,\\n                amount,\\n                bytes(\\\"\\\")\\n            )\\n        );\\n\\n        uint256 exchangeBalanceAfter = token.balanceOf(address(this), tokenId);\\n        require(exchangeBalanceAfter >= exchangeBalanceBefore, \\\"OVERFLOW\\\");\\n        // NOLINTNEXTLINE(incorrect-equality): strict equality needed.\\n        require(\\n            exchangeBalanceAfter == exchangeBalanceBefore + amount,\\n            \\\"INCORRECT_AMOUNT_TRANSFERRED\\\"\\n        );\\n    }\\n\\n    /*\\n      Transfers funds from the exchange to recipient.\\n    */\\n    function transferOut(\\n        address payable recipient,\\n        uint256 assetType,\\n        uint256 quantizedAmount\\n    ) internal override {\\n        // Make sure we don't accidentally burn funds.\\n        require(recipient != address(0x0), \\\"INVALID_RECIPIENT\\\");\\n        uint256 amount = fromQuantized(assetType, quantizedAmount);\\n        if (isERC20(assetType)) {\\n            if (quantizedAmount == 0) return;\\n            address tokenAddress = extractContractAddress(assetType);\\n            IERC20 token = IERC20(tokenAddress);\\n            uint256 exchangeBalanceBefore = token.balanceOf(address(this));\\n            bytes memory callData = abi.encodeWithSelector(\\n                token.transfer.selector,\\n                recipient,\\n                amount\\n            );\\n            tokenAddress.safeTokenContractCall(callData);\\n            uint256 exchangeBalanceAfter = token.balanceOf(address(this));\\n            require(exchangeBalanceAfter <= exchangeBalanceBefore, \\\"UNDERFLOW\\\");\\n            // NOLINTNEXTLINE(incorrect-equality): strict equality needed.\\n            require(\\n                exchangeBalanceAfter == exchangeBalanceBefore - amount,\\n                \\\"INCORRECT_AMOUNT_TRANSFERRED\\\"\\n            );\\n        } else if (isEther(assetType)) {\\n            if (quantizedAmount == 0) return;\\n            recipient.performEthTransfer(amount);\\n        } else {\\n            revert(\\\"UNSUPPORTED_TOKEN_TYPE\\\");\\n        }\\n    }\\n\\n    /*\\n      Transfers non fungible and semi fungible tokens from the exchange to recipient.\\n    */\\n    function transferOutWithTokenId(\\n        address recipient,\\n        uint256 assetType,\\n        uint256 tokenId,\\n        uint256 quantizedAmount\\n    ) internal override {\\n        require(isAssetTypeWithTokenId(assetType), \\\"FUNGIBLE_ASSET_TYPE\\\");\\n        if (isERC721(assetType)) {\\n            require(quantizedAmount == 1, \\\"ILLEGAL_NFT_BALANCE\\\");\\n            transferOutNft(recipient, assetType, tokenId);\\n        } else if (quantizedAmount > 0) {\\n            transferOutSft(recipient, assetType, tokenId, quantizedAmount);\\n        }\\n    }\\n\\n    /*\\n      Transfers NFT from the exchange to recipient.\\n    */\\n    function transferOutNft(\\n        address recipient,\\n        uint256 assetType,\\n        uint256 tokenId\\n    ) private {\\n        // Make sure we don't accidentally burn funds.\\n        require(recipient != address(0x0), \\\"INVALID_RECIPIENT\\\");\\n        require(isERC721(assetType), \\\"NOT_ERC721_TOKEN\\\");\\n        address tokenAddress = extractContractAddress(assetType);\\n\\n        tokenAddress.safeTokenContractCall(\\n            abi.encodeWithSignature(\\n                \\\"safeTransferFrom(address,address,uint256)\\\",\\n                address(this),\\n                recipient,\\n                tokenId\\n            )\\n        );\\n    }\\n\\n    /*\\n      Transfers Semi Fungible Tokens from the exchange to recipient.\\n    */\\n    function transferOutSft(\\n        address recipient,\\n        uint256 assetType,\\n        uint256 tokenId,\\n        uint256 quantizedAmount\\n    ) private {\\n        // Make sure we don't accidentally burn funds.\\n        require(recipient != address(0x0), \\\"INVALID_RECIPIENT\\\");\\n        require(isERC1155(assetType), \\\"NOT_ERC1155_TOKEN\\\");\\n        if (quantizedAmount == 0) return;\\n\\n        uint256 amount = fromQuantized(assetType, quantizedAmount);\\n        address tokenAddress = extractContractAddress(assetType);\\n        IERC1155 token = IERC1155(tokenAddress);\\n        uint256 exchangeBalanceBefore = token.balanceOf(address(this), tokenId);\\n\\n        // Call an ERC1155 token transfer.\\n        tokenAddress.safeTokenContractCall(\\n            abi.encodeWithSelector(\\n                token.safeTransferFrom.selector,\\n                address(this),\\n                recipient,\\n                tokenId,\\n                amount,\\n                bytes(\\\"\\\")\\n            )\\n        );\\n\\n        uint256 exchangeBalanceAfter = token.balanceOf(address(this), tokenId);\\n        require(exchangeBalanceAfter <= exchangeBalanceBefore, \\\"UNDERFLOW\\\");\\n        // NOLINTNEXTLINE(incorrect-equality): strict equality needed.\\n        require(\\n            exchangeBalanceAfter == exchangeBalanceBefore - amount,\\n            \\\"INCORRECT_AMOUNT_TRANSFERRED\\\"\\n        );\\n    }\\n\\n    function transferOutMint(\\n        uint256 assetType,\\n        uint256 quantizedAmount,\\n        address recipient,\\n        bytes calldata mintingBlob\\n    ) internal override {\\n        // Make sure we don't accidentally burn funds.\\n        require(recipient != address(0x0), \\\"INVALID_RECIPIENT\\\");\\n        require(isMintableAssetType(assetType), \\\"NON_MINTABLE_ASSET_TYPE\\\");\\n        require(quantizedAmount > 0, \\\"INVALID_MINT_AMOUNT\\\");\\n        uint256 amount = fromQuantized(assetType, quantizedAmount);\\n        address tokenAddress = extractContractAddress(assetType);\\n        tokenAddress.safeTokenContractCall(\\n            abi.encodeWithSignature(\\n                \\\"mintFor(address,uint256,bytes)\\\",\\n                recipient,\\n                amount,\\n                mintingBlob\\n            )\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"Withdrawals.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"MAcceptModifications.sol\\\";\\nimport \\\"MTokenQuantization.sol\\\";\\nimport \\\"MTokenAssetData.sol\\\";\\nimport \\\"MFreezable.sol\\\";\\nimport \\\"MKeyGetters.sol\\\";\\nimport \\\"MTokenTransfers.sol\\\";\\nimport \\\"MainStorage.sol\\\";\\n\\n/**\\n  For a user to perform a withdrawal operation from the Stark Exchange during normal operation\\n  two calls are required:\\n\\n  1. A call to an offchain exchange API, requesting a withdrawal from a user account (vault).\\n  2. A call to the on-chain :sol:func:`withdraw` function to perform the actual withdrawal of funds transferring them to the users Eth or ERC20 account (depending on the token type).\\n\\n  For simplicity, hereafter it is assumed that all tokens are ERC20 tokens but the text below\\n  applies to Eth in the same manner.\\n\\n  In the first call mentioned above, anyone can call the API to request the withdrawal of an\\n  amount from a given vault. Following the request, the exchange may include the withdrawal in a\\n  STARK proof. The submission of a proof then results in the addition of the amount(s) withdrawn to\\n  an on-chain pending withdrawals account under the stark key of the vault owner and the appropriate\\n  asset ID. At the same time, this also implies that this amount is deducted from the off-chain\\n  vault.\\n\\n  Once the amount to be withdrawn has been transfered to the on-chain pending withdrawals account,\\n  the user may perform the second call mentioned above to complete the transfer of funds from the\\n  Stark Exchange contract to the appropriate ERC20 account. Only a user holding the Eth key\\n  corresponding to the Stark Key of a pending withdrawals account may perform this operation.\\n\\n  It is possible that for multiple withdrawal calls to the API, a single withdrawal call to the\\n  contract may retrieve all funds, as long as they are all for the same asset ID.\\n\\n  The result of the operation, assuming all requirements are met, is that an amount of ERC20 tokens\\n  in the pending withdrawal account times the quantization factor is transferred to the ERC20\\n  account of the user.\\n\\n  A withdrawal request cannot be cancelled. Once funds reach the pending withdrawals account\\n  on-chain, they cannot be moved back into an off-chain vault before completion of the withdrawal\\n  to the ERC20 account of the user.\\n\\n  In the event that the exchange reaches a frozen state the user may perform a withdrawal operation\\n  via an alternative flow, known as the \\\"Escape\\\" flow. In this flow, the API call above is replaced\\n  with an :sol:func:`escape` call to the on-chain contract (see :sol:mod:`Escapes`) proving the\\n  ownership of off-chain funds. If such proof is accepted, the user may proceed as above with\\n  the :sol:func:`withdraw` call to the contract to complete the operation.\\n*/\\nabstract contract Withdrawals is\\n    MainStorage,\\n    MAcceptModifications,\\n    MTokenQuantization,\\n    MTokenAssetData,\\n    MFreezable,\\n    MKeyGetters,\\n    MTokenTransfers\\n{\\n    event LogWithdrawalPerformed(\\n        uint256 ownerKey,\\n        uint256 assetType,\\n        uint256 nonQuantizedAmount,\\n        uint256 quantizedAmount,\\n        address recipient\\n    );\\n\\n    event LogNftWithdrawalPerformed(\\n        uint256 ownerKey,\\n        uint256 assetType,\\n        uint256 tokenId,\\n        uint256 assetId,\\n        address recipient\\n    );\\n\\n    event LogWithdrawalWithTokenIdPerformed(\\n        uint256 ownerKey,\\n        uint256 assetType,\\n        uint256 tokenId,\\n        uint256 assetId,\\n        uint256 nonQuantizedAmount,\\n        uint256 quantizedAmount,\\n        address recipient\\n    );\\n\\n    event LogMintWithdrawalPerformed(\\n        uint256 ownerKey,\\n        uint256 assetType,\\n        uint256 nonQuantizedAmount,\\n        uint256 quantizedAmount,\\n        uint256 assetId\\n    );\\n\\n    function getWithdrawalBalance(uint256 ownerKey, uint256 assetId)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        uint256 presumedAssetType = assetId;\\n        return fromQuantized(presumedAssetType, pendingWithdrawals[ownerKey][assetId]);\\n    }\\n\\n    /*\\n      Moves funds from the pending withdrawal account to the owner address.\\n      Note: this function can be called by anyone.\\n      Can be called normally while frozen.\\n    */\\n    function withdraw(uint256 ownerKey, uint256 assetType) external {\\n        address payable recipient = payable(strictGetEthKey(ownerKey));\\n        require(!isMintableAssetType(assetType), \\\"MINTABLE_ASSET_TYPE\\\");\\n        require(isFungibleAssetType(assetType), \\\"NON_FUNGIBLE_ASSET_TYPE\\\");\\n        uint256 assetId = assetType;\\n        // Fetch and clear quantized amount.\\n        uint256 quantizedAmount = pendingWithdrawals[ownerKey][assetId];\\n        pendingWithdrawals[ownerKey][assetId] = 0;\\n\\n        // Transfer funds.\\n        transferOut(recipient, assetType, quantizedAmount);\\n        emit LogWithdrawalPerformed(\\n            ownerKey,\\n            assetType,\\n            fromQuantized(assetType, quantizedAmount),\\n            quantizedAmount,\\n            recipient\\n        );\\n    }\\n\\n    /*\\n      Allows withdrawal of tokens to their owner's account.\\n      Note: this function can be called by anyone.\\n      This function can be called normally while frozen.\\n    */\\n    function withdrawWithTokenId(\\n        uint256 ownerKey,\\n        uint256 assetType,\\n        uint256 tokenId // No notFrozen modifier: This function can always be used, even when frozen.\\n    ) public {\\n        require(isAssetTypeWithTokenId(assetType), \\\"INVALID_ASSET_TYPE\\\");\\n        uint256 assetId = calculateAssetIdWithTokenId(assetType, tokenId);\\n        address recipient = strictGetEthKey(ownerKey);\\n\\n        uint256 quantizedAmount = pendingWithdrawals[ownerKey][assetId];\\n        pendingWithdrawals[ownerKey][assetId] = 0;\\n\\n        // Transfer funds.\\n        transferOutWithTokenId(recipient, assetType, tokenId, quantizedAmount);\\n        if (isERC721(assetType)) {\\n            emit LogNftWithdrawalPerformed(ownerKey, assetType, tokenId, assetId, recipient);\\n        }\\n        emit LogWithdrawalWithTokenIdPerformed(\\n            ownerKey,\\n            assetType,\\n            tokenId,\\n            assetId,\\n            fromQuantized(assetType, quantizedAmount),\\n            quantizedAmount,\\n            recipient\\n        );\\n    }\\n\\n    /*\\n      Allows withdrawal of an NFT to its owner's account.\\n      Note: this function can be called by anyone.\\n      This function can be called normally while frozen.\\n    */\\n    function withdrawNft(\\n        uint256 ownerKey,\\n        uint256 assetType,\\n        uint256 tokenId // No notFrozen modifier: This function can always be used, even when frozen.\\n    ) external {\\n        withdrawWithTokenId(ownerKey, assetType, tokenId);\\n    }\\n\\n    function withdrawAndMint(\\n        uint256 ownerKey,\\n        uint256 assetType,\\n        bytes calldata mintingBlob\\n    ) external {\\n        address recipient = strictGetEthKey(ownerKey);\\n        require(registeredAssetType[assetType], \\\"INVALID_ASSET_TYPE\\\");\\n        require(isMintableAssetType(assetType), \\\"NON_MINTABLE_ASSET_TYPE\\\");\\n        uint256 assetId = calculateMintableAssetId(assetType, mintingBlob);\\n        require(pendingWithdrawals[ownerKey][assetId] > 0, \\\"NO_PENDING_WITHDRAWAL_BALANCE\\\");\\n        uint256 quantizedAmount = pendingWithdrawals[ownerKey][assetId];\\n        pendingWithdrawals[ownerKey][assetId] = 0;\\n        // Transfer funds.\\n        transferOutMint(assetType, quantizedAmount, recipient, mintingBlob);\\n        emit LogMintWithdrawalPerformed(\\n            ownerKey,\\n            assetType,\\n            fromQuantized(assetType, quantizedAmount),\\n            quantizedAmount,\\n            assetId\\n        );\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {},\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ownerKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"}],\"name\":\"LogAssetWithdrawalAllowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositorEthKey\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonQuantizedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"}],\"name\":\"LogDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"LogDepositCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonQuantizedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"}],\"name\":\"LogDepositCancelReclaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"LogDepositNftCancelReclaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositorEthKey\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonQuantizedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"}],\"name\":\"LogDepositWithTokenId\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonQuantizedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"}],\"name\":\"LogDepositWithTokenIdCancelReclaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ownerKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonQuantizedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"LogMintWithdrawalPerformed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ownerKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"}],\"name\":\"LogMintableWithdrawalAllowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"acceptedGovernor\",\"type\":\"address\"}],\"name\":\"LogNewGovernorAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositorEthKey\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"LogNftDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ownerKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"LogNftWithdrawalAllowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ownerKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"LogNftWithdrawalPerformed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nominatedGovernor\",\"type\":\"address\"}],\"name\":\"LogNominatedGovernor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogNominationCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"removedGovernor\",\"type\":\"address\"}],\"name\":\"LogRemovedGovernor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"}],\"name\":\"LogSystemAssetType\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAdmin\",\"type\":\"address\"}],\"name\":\"LogTokenAdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAdmin\",\"type\":\"address\"}],\"name\":\"LogTokenAdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"assetInfo\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantum\",\"type\":\"uint256\"}],\"name\":\"LogTokenRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogUnFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ownerKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonQuantizedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"}],\"name\":\"LogWithdrawalAllowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ownerKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonQuantizedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"LogWithdrawalPerformed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ownerKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonQuantizedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"LogWithdrawalWithTokenIdPerformed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEPOSIT_CANCEL_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FREEZE_GRACE_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAIN_GOVERNANCE_INFO_TAG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FORCED_ACTIONS_REQS_PER_BLOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_VERIFIER_COUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNFREEZE_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERIFIER_REMOVAL_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"calculateAssetIdWithTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"mintingBlob\",\"type\":\"bytes\"}],\"name\":\"calculateMintableAssetId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configurationDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"configurationHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"depositCancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"}],\"name\":\"depositERC1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"}],\"name\":\"depositERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"depositEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"depositNft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"depositNftReclaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"depositReclaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"}],\"name\":\"depositWithTokenId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"depositWithTokenIdReclaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"}],\"name\":\"getAssetInfo\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"assetInfo\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"getCancellationRequest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"request\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"getDepositBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ownerKey\",\"type\":\"uint256\"}],\"name\":\"getEthKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"getQuantizedDepositBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"presumedAssetType\",\"type\":\"uint256\"}],\"name\":\"getQuantum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"quantum\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSystemAssetType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ownerKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"getWithdrawalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalConfigurationHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"identify\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializerSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"}],\"name\":\"isAssetRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"testedAdmin\",\"type\":\"address\"}],\"name\":\"isTokenAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainAcceptGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainCancelNomination\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"mainIsGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"mainNominateNewGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governorForRemoval\",\"type\":\"address\"}],\"name\":\"mainRemoveGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"assetInfo\",\"type\":\"bytes\"}],\"name\":\"registerSystemAssetType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"registerToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registerToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"registerTokenAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unFreeze\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"}],\"name\":\"unregisterTokenAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validatedSelectors\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ownerKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ownerKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"mintingBlob\",\"type\":\"bytes\"}],\"name\":\"withdrawAndMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ownerKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"withdrawNft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ownerKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"withdrawWithTokenId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PerpetualTokensAndRamping", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": ""}