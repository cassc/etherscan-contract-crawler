{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/reserve/DistributionHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@mean-finance/uniswap-v3-oracle/solidity/interfaces/IStaticOracle.sol\\\";\\nimport \\\"@gooddollar/bridge-contracts/contracts/messagePassingBridge/IMessagePassingBridge.sol\\\";\\n\\nimport \\\"../utils/DAOUpgradeableContract.sol\\\";\\nimport \\\"./ExchangeHelper.sol\\\";\\n\\n// import \\\"hardhat/console.sol\\\";\\n\\n/***\\n * @dev DistributionHelper receives funds and distributes them to recipients\\n * recipients can be on other blockchains and get their funds via fuse/multichain bridge\\n * accounts with ADMIN_ROLE can update the recipients, defaults to Avatar\\n */\\ncontract DistributionHelper is\\n\\tDAOUpgradeableContract,\\n\\tAccessControlEnumerableUpgradeable\\n{\\n\\tbytes32 public constant GUARDIAN_ROLE = keccak256(\\\"GUARDIAN_ROLE\\\");\\n\\n\\terror FEE_LIMIT(uint256 fee);\\n\\n\\t//IStaticOracle(0xB210CE856631EeEB767eFa666EC7C1C57738d438); //@mean-finance/uniswap-v3-oracle\\n\\n\\taddress public constant CELO_TOKEN =\\n\\t\\t0x3294395e62F4eB6aF3f1Fcf89f5602D90Fb3Ef69;\\n\\n\\taddress public constant FUSE_TOKEN =\\n\\t\\t0x970B9bB2C0444F5E81e9d0eFb84C8ccdcdcAf84d;\\n\\n\\taddress public constant USDC_TOKEN =\\n\\t\\t0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\n\\n\\taddress public constant WETH_TOKEN =\\n\\t\\t0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n\\tenum TransferType {\\n\\t\\tFuseBridge,\\n\\t\\tLayerZeroBridge,\\n\\t\\tAxelarBridge,\\n\\t\\tContract\\n\\t}\\n\\n\\tstruct DistributionRecipient {\\n\\t\\tuint32 bps; //share out of each distribution\\n\\t\\tuint32 chainId; //for multichain bridge\\n\\t\\taddress addr; //recipient address\\n\\t\\tTransferType transferType;\\n\\t}\\n\\n\\tstruct FeeSettings {\\n\\t\\tuint128 axelarBaseFeeUSD;\\n\\t\\tuint128 bridgeExecuteGas;\\n\\t\\tuint128 targetChainGasPrice;\\n\\t\\tuint128 maxFee;\\n\\t\\tuint128 minBalanceForFees;\\n\\t\\tuint8 percentageToSellForFee;\\n\\t}\\n\\n\\tDistributionRecipient[] public distributionRecipients;\\n\\n\\taddress public fuseBridge;\\n\\tIMessagePassingBridge public mpbBridge;\\n\\tFeeSettings public feeSettings; //previously anyGoodDollar_unused; //kept for storage layout upgrades\\n\\n\\tIStaticOracle public STATIC_ORACLE;\\n\\n\\tevent Distribution(\\n\\t\\tuint256 distributed,\\n\\t\\tuint256 startingBalance,\\n\\t\\tuint256 incomingAmount,\\n\\t\\tDistributionRecipient[] distributionRecipients\\n\\t);\\n\\tevent RecipientUpdated(DistributionRecipient recipient, uint256 index);\\n\\tevent RecipientAdded(DistributionRecipient recipient, uint256 index);\\n\\n\\treceive() external payable {}\\n\\n\\tfunction initialize(INameService _ns) external initializer {\\n\\t\\t__AccessControlEnumerable_init();\\n\\t\\tsetDAO(_ns);\\n\\t\\t_setupRole(DEFAULT_ADMIN_ROLE, avatar); //this needs to happen after setDAO for avatar to be non empty\\n\\t\\t_setupRole(GUARDIAN_ROLE, avatar);\\n\\t\\tupdateAddresses();\\n\\t}\\n\\n\\tfunction updateAddresses() public {\\n\\t\\tfuseBridge = nameService.getAddress(\\\"BRIDGE_CONTRACT\\\");\\n\\t\\tmpbBridge = IMessagePassingBridge(\\n\\t\\t\\tnameService.getAddress(\\\"MPBBRIDGE_CONTRACT\\\")\\n\\t\\t);\\n\\t\\tSTATIC_ORACLE = IStaticOracle(0xB210CE856631EeEB767eFa666EC7C1C57738d438); //@mean-finance/uniswap-v3-oracle\\n\\t\\t_setupRole(GUARDIAN_ROLE, avatar);\\n\\t\\t_setupRole(GUARDIAN_ROLE, 0xE0c5daa7CC6F88d29505f702a53bb5E67600e7Ec); //guardians on ethereum\\n\\t}\\n\\n\\tfunction setFeeSettings(\\n\\t\\tFeeSettings memory _feeData\\n\\t) external onlyRole(GUARDIAN_ROLE) {\\n\\t\\tfeeSettings = _feeData;\\n\\t}\\n\\n\\tfunction getTargetChainRefundAddress(\\n\\t\\tuint256 chainId\\n\\t) public pure returns (address) {\\n\\t\\tif (chainId == 122) return 0xf96dADc6D71113F6500e97590760C924dA1eF70e; //avatar on fuse\\n\\t\\tif (chainId == 42220) return 0x495d133B938596C9984d462F007B676bDc57eCEC; //avatar on celo\\n\\n\\t\\trevert(\\\"refund chainId\\\");\\n\\t}\\n\\n\\tfunction getTargetChainGasInEth(\\n\\t\\tuint256 gasCostWei,\\n\\t\\tuint256 chainId\\n\\t) public view returns (uint256 quote) {\\n\\t\\taddress baseToken;\\n\\t\\tif (chainId == 122) baseToken = FUSE_TOKEN;\\n\\t\\telse if (chainId == 42220) baseToken = CELO_TOKEN;\\n\\t\\telse revert(\\\"baseToken chainId\\\");\\n\\n\\t\\tuint24[] memory fees = new uint24[](1);\\n\\t\\tfees[0] = 3000;\\n\\t\\t(quote, ) = STATIC_ORACLE.quoteSpecificFeeTiersWithTimePeriod(\\n\\t\\t\\tuint128(gasCostWei),\\n\\t\\t\\tbaseToken,\\n\\t\\t\\tWETH_TOKEN,\\n\\t\\t\\tfees,\\n\\t\\t\\t60 //last 1 minute\\n\\t\\t);\\n\\t}\\n\\n\\tfunction getAxelarFee(\\n\\t\\tuint256 targetChainId\\n\\t) public view returns (uint256 feeInEth) {\\n\\t\\tuint256 executeFeeInEth = getTargetChainGasInEth(\\n\\t\\t\\tfeeSettings.bridgeExecuteGas * feeSettings.targetChainGasPrice,\\n\\t\\t\\ttargetChainId\\n\\t\\t);\\n\\n\\t\\tuint24[] memory fees = new uint24[](1);\\n\\t\\tfees[0] = 500;\\n\\t\\t(uint256 baseFeeInEth, ) = STATIC_ORACLE\\n\\t\\t\\t.quoteSpecificFeeTiersWithTimePeriod(\\n\\t\\t\\t\\tuint128(feeSettings.axelarBaseFeeUSD) / 1e12, //reduce to usdc 6 decimals\\n\\t\\t\\t\\tUSDC_TOKEN,\\n\\t\\t\\t\\tWETH_TOKEN,\\n\\t\\t\\t\\tfees,\\n\\t\\t\\t\\t60 //last 1 minute\\n\\t\\t\\t);\\n\\n\\t\\tfeeInEth = ((baseFeeInEth + executeFeeInEth) * 110) / 100; //add 10%\\n\\t}\\n\\n\\t/**\\n\\t * @notice this is usually called by reserve, but can be called by anyone anytime to trigger distribution\\n\\t * @param _amount how much was sent, informational only\\n\\t */\\n\\tfunction onDistribution(uint256 _amount) external virtual {\\n\\t\\t//we consider the actual balance and not _amount\\n\\t\\t// console.log(\\\"onDistribution amount: %s\\\", _amount);\\n\\t\\tuint256 toDistribute = nativeToken().balanceOf(address(this));\\n\\t\\tif (toDistribute == 0) return;\\n\\n\\t\\tif (address(this).balance < feeSettings.minBalanceForFees) {\\n\\t\\t\\tuint256 gdToSellfForFee = (toDistribute *\\n\\t\\t\\t\\tfeeSettings.percentageToSellForFee) / 100;\\n\\t\\t\\ttoDistribute -= gdToSellfForFee;\\n\\t\\t\\tbuyNativeWithGD(gdToSellfForFee);\\n\\t\\t}\\n\\n\\t\\tuint256 totalDistributed;\\n\\t\\tfor (uint256 i = 0; i < distributionRecipients.length; i++) {\\n\\t\\t\\tDistributionRecipient storage r = distributionRecipients[i];\\n\\t\\t\\tif (r.bps > 0) {\\n\\t\\t\\t\\tuint256 toTransfer = (toDistribute * r.bps) / 10000;\\n\\t\\t\\t\\ttotalDistributed += toTransfer;\\n\\t\\t\\t\\tif (toTransfer > 0) distribute(r, toTransfer);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\temit Distribution(\\n\\t\\t\\ttotalDistributed,\\n\\t\\t\\ttoDistribute,\\n\\t\\t\\t_amount,\\n\\t\\t\\tdistributionRecipients\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @notice add or update a recipient details, if address exists it will update, otherwise add\\n\\t * to \\\"remove\\\" set recipient bps to 0. only ADMIN_ROLE can call this.\\n\\t */\\n\\tfunction addOrUpdateRecipient(\\n\\t\\tDistributionRecipient memory _recipient\\n\\t) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n\\t\\tfor (uint256 i = 0; i < distributionRecipients.length; i++) {\\n\\t\\t\\tif (distributionRecipients[i].addr == _recipient.addr) {\\n\\t\\t\\t\\tdistributionRecipients[i] = _recipient;\\n\\t\\t\\t\\temit RecipientUpdated(_recipient, i);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//if reached here then add new one\\n\\t\\temit RecipientAdded(_recipient, distributionRecipients.length);\\n\\t\\tdistributionRecipients.push(_recipient);\\n\\t}\\n\\n\\t/**\\n\\t * @notice internal function that takes care of sending the G$s according to the transfer type\\n\\t * @param _recipient data about the recipient\\n\\t * @param _amount how much to send\\n\\t */\\n\\tfunction distribute(\\n\\t\\tDistributionRecipient storage _recipient,\\n\\t\\tuint256 _amount\\n\\t) internal {\\n\\t\\tif (_recipient.transferType == TransferType.FuseBridge) {\\n\\t\\t\\tnativeToken().transferAndCall(\\n\\t\\t\\t\\tfuseBridge,\\n\\t\\t\\t\\t_amount,\\n\\t\\t\\t\\tabi.encodePacked(_recipient.addr)\\n\\t\\t\\t);\\n\\t\\t} else if (_recipient.transferType == TransferType.LayerZeroBridge) {\\n\\t\\t\\tnativeToken().approve(address(mpbBridge), _amount);\\n\\t\\t\\t(uint256 lzFee, ) = ILayerZeroFeeEstimator(address(mpbBridge))\\n\\t\\t\\t\\t.estimateSendFee(\\n\\t\\t\\t\\t\\tmpbBridge.toLzChainId(_recipient.chainId),\\n\\t\\t\\t\\t\\taddress(this),\\n\\t\\t\\t\\t\\t_recipient.addr,\\n\\t\\t\\t\\t\\t_amount,\\n\\t\\t\\t\\t\\tfalse,\\n\\t\\t\\t\\t\\tabi.encodePacked(uint16(1), uint256(400000)) // 400k gas to execute bridge at target chain\\n\\t\\t\\t\\t);\\n\\t\\t\\tif (lzFee > feeSettings.maxFee) revert FEE_LIMIT(lzFee);\\n\\n\\t\\t\\tmpbBridge.bridgeToWithLz{ value: lzFee }(\\n\\t\\t\\t\\t_recipient.addr,\\n\\t\\t\\t\\t_recipient.chainId,\\n\\t\\t\\t\\t_amount,\\n\\t\\t\\t\\t\\\"\\\"\\n\\t\\t\\t);\\n\\t\\t} else if (_recipient.transferType == TransferType.AxelarBridge) {\\n\\t\\t\\tnativeToken().approve(address(mpbBridge), _amount);\\n\\t\\t\\tuint256 axlFee = getAxelarFee(_recipient.chainId);\\n\\n\\t\\t\\tif (axlFee > feeSettings.maxFee) revert FEE_LIMIT(axlFee);\\n\\n\\t\\t\\tmpbBridge.bridgeToWithAxelar{ value: axlFee }(\\n\\t\\t\\t\\t_recipient.addr,\\n\\t\\t\\t\\t_recipient.chainId,\\n\\t\\t\\t\\t_amount,\\n\\t\\t\\t\\tgetTargetChainRefundAddress(_recipient.chainId)\\n\\t\\t\\t);\\n\\t\\t} else if (_recipient.transferType == TransferType.Contract) {\\n\\t\\t\\tnativeToken().transferAndCall(_recipient.addr, _amount, \\\"\\\");\\n\\t\\t}\\n\\t}\\n\\n\\tfunction buyNativeWithGD(uint256 amountToSell) internal {\\n\\t\\taddress[] memory path = new address[](2);\\n\\t\\tpath[0] = nameService.getAddress(\\\"DAI\\\");\\n\\t\\tpath[1] = address(0);\\n\\t\\taddress exchg = nameService.getAddress(\\\"EXCHANGE_HELPER\\\");\\n\\t\\tnativeToken().approve(exchg, amountToSell);\\n\\t\\tExchangeHelper(exchg).sell(path, amountToSell, 0, 0, address(this));\\n\\t}\\n}\\n\"\r\n    },\r\n    \"/contracts/utils/NameService.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\n\\nimport \\\"../DAOStackInterfaces.sol\\\";\\n\\n/**\\n@title Simple name to address resolver\\n*/\\n\\ncontract NameService is Initializable, UUPSUpgradeable {\\n\\tmapping(bytes32 => address) public addresses;\\n\\n\\tController public dao;\\n\\tevent AddressChanged(string name ,address addr);\\n\\tfunction initialize(\\n\\t\\tController _dao,\\n\\t\\tbytes32[] memory _nameHashes,\\n\\t\\taddress[] memory _addresses\\n\\t) public virtual initializer {\\n\\t\\tdao = _dao;\\n\\t\\tfor (uint256 i = 0; i < _nameHashes.length; i++) {\\n\\t\\t\\taddresses[_nameHashes[i]] = _addresses[i];\\n\\t\\t}\\n\\t\\taddresses[keccak256(bytes(\\\"CONTROLLER\\\"))] = address(_dao);\\n\\t\\taddresses[keccak256(bytes(\\\"AVATAR\\\"))] = address(_dao.avatar());\\n\\t}\\n\\n\\tfunction _authorizeUpgrade(address) internal override {\\n\\t\\t_onlyAvatar();\\n\\t}\\n\\n\\tfunction _onlyAvatar() internal view {\\n\\t\\trequire(\\n\\t\\t\\taddress(dao.avatar()) == msg.sender,\\n\\t\\t\\t\\\"only avatar can call this method\\\"\\n\\t\\t);\\n\\t}\\n\\n\\tfunction setAddress(string memory name, address addr) external {\\n\\t\\t_onlyAvatar();\\n\\t\\taddresses[keccak256(bytes(name))] = addr;\\n\\t\\temit AddressChanged(name, addr);\\n\\t}\\n\\n\\tfunction setAddresses(bytes32[] calldata hash, address[] calldata addrs)\\n\\t\\texternal\\n\\t{\\n\\t\\t_onlyAvatar();\\n\\t\\tfor (uint256 i = 0; i < hash.length; i++) {\\n\\t\\t\\taddresses[hash[i]] = addrs[i];\\n\\t\\t}\\n\\t}\\n\\n\\tfunction getAddress(string memory name) external view returns (address) {\\n\\t\\treturn addresses[keccak256(bytes(name))];\\n\\t}\\n}\\n\"\r\n    },\r\n    \"/contracts/utils/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nlibrary DataTypes {\\n\\t// refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\\n\\tstruct ReserveData {\\n\\t\\t//stores the reserve configuration\\n\\t\\tReserveConfigurationMap configuration;\\n\\t\\t//the liquidity index. Expressed in ray\\n\\t\\tuint128 liquidityIndex;\\n\\t\\t//variable borrow index. Expressed in ray\\n\\t\\tuint128 variableBorrowIndex;\\n\\t\\t//the current supply rate. Expressed in ray\\n\\t\\tuint128 currentLiquidityRate;\\n\\t\\t//the current variable borrow rate. Expressed in ray\\n\\t\\tuint128 currentVariableBorrowRate;\\n\\t\\t//the current stable borrow rate. Expressed in ray\\n\\t\\tuint128 currentStableBorrowRate;\\n\\t\\tuint40 lastUpdateTimestamp;\\n\\t\\t//tokens addresses\\n\\t\\taddress aTokenAddress;\\n\\t\\taddress stableDebtTokenAddress;\\n\\t\\taddress variableDebtTokenAddress;\\n\\t\\t//address of the interest rate strategy\\n\\t\\taddress interestRateStrategyAddress;\\n\\t\\t//the id of the reserve. Represents the position in the list of the active reserves\\n\\t\\tuint8 id;\\n\\t}\\n\\n\\tstruct ReserveConfigurationMap {\\n\\t\\t//bit 0-15: LTV\\n\\t\\t//bit 16-31: Liq. threshold\\n\\t\\t//bit 32-47: Liq. bonus\\n\\t\\t//bit 48-55: Decimals\\n\\t\\t//bit 56: Reserve is active\\n\\t\\t//bit 57: reserve is frozen\\n\\t\\t//bit 58: borrowing is enabled\\n\\t\\t//bit 59: stable rate borrowing enabled\\n\\t\\t//bit 60-63: reserved\\n\\t\\t//bit 64-79: reserve factor\\n\\t\\tuint256 data;\\n\\t}\\n\\tenum InterestRateMode { NONE, STABLE, VARIABLE }\\n}\\n\"\r\n    },\r\n    \"/contracts/utils/DSMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/// math.sol -- mixin for inline numerical wizardry\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.0;\\n\\ncontract DSMath {\\n\\tfunction rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n\\t\\tz = (x * y) / 10**27;\\n\\t}\\n\\n\\tfunction rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n\\t\\tz = (x * (10**27)) / y;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"/contracts/utils/DAOUpgradeableContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\nimport \\\"./DAOContract.sol\\\";\\n\\n/**\\n@title Simple contract that adds upgradability to DAOContract\\n*/\\n\\ncontract DAOUpgradeableContract is Initializable, UUPSUpgradeable, DAOContract {\\n\\tfunction _authorizeUpgrade(address) internal virtual override {\\n\\t\\t_onlyAvatar();\\n\\t}\\n}\\n\"\r\n    },\r\n    \"/contracts/utils/DAOContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"../DAOStackInterfaces.sol\\\";\\nimport \\\"../Interfaces.sol\\\";\\n\\n/**\\n@title Simple contract that keeps DAO contracts registery\\n*/\\n\\ncontract DAOContract {\\n\\tController public dao;\\n\\n\\taddress public avatar;\\n\\n\\tINameService public nameService;\\n\\n\\tfunction _onlyAvatar() internal view {\\n\\t\\trequire(\\n\\t\\t\\taddress(dao.avatar()) == msg.sender,\\n\\t\\t\\t\\\"only avatar can call this method\\\"\\n\\t\\t);\\n\\t}\\n\\n\\tfunction setDAO(INameService _ns) internal {\\n\\t\\tnameService = _ns;\\n\\t\\tupdateAvatar();\\n\\t}\\n\\n\\tfunction updateAvatar() public {\\n\\t\\tdao = Controller(nameService.getAddress(\\\"CONTROLLER\\\"));\\n\\t\\tavatar = dao.avatar();\\n\\t}\\n\\n\\tfunction nativeToken() public view returns (IGoodDollar) {\\n\\t\\treturn IGoodDollar(nameService.getAddress(\\\"GOODDOLLAR\\\"));\\n\\t}\\n\\n\\tuint256[50] private gap;\\n}\\n\"\r\n    },\r\n    \"/contracts/utils/BancorFormula.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.8.0;\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\\\";\\n\\ncontract BancorFormula {\\n\\tusing SafeMathUpgradeable for uint256;\\n\\n\\tuint256 private constant ONE = 1;\\n\\tuint32 private constant MAX_WEIGHT = 1000000;\\n\\tuint8 private constant MIN_PRECISION = 32;\\n\\tuint8 private constant MAX_PRECISION = 127;\\n\\n\\t// Auto-generated via 'PrintIntScalingFactors.py'\\n\\tuint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\\n\\tuint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\\n\\tuint256 private constant MAX_NUM = 0x200000000000000000000000000000000;\\n\\n\\t// Auto-generated via 'PrintLn2ScalingFactors.py'\\n\\tuint256 private constant LN2_NUMERATOR = 0x3f80fe03f80fe03f80fe03f80fe03f8;\\n\\tuint256 private constant LN2_DENOMINATOR =\\n\\t\\t0x5b9de1d10bf4103d647b0955897ba80;\\n\\n\\t// Auto-generated via 'PrintFunctionOptimalLog.py' and 'PrintFunctionOptimalExp.py'\\n\\tuint256 private constant OPT_LOG_MAX_VAL =\\n\\t\\t0x15bf0a8b1457695355fb8ac404e7a79e3;\\n\\tuint256 private constant OPT_EXP_MAX_VAL =\\n\\t\\t0x800000000000000000000000000000000;\\n\\n\\t// Auto-generated via 'PrintLambertFactors.py'\\n\\tuint256 private constant LAMBERT_CONV_RADIUS =\\n\\t\\t0x002f16ac6c59de6f8d5d6f63c1482a7c86;\\n\\tuint256 private constant LAMBERT_POS2_SAMPLE =\\n\\t\\t0x0003060c183060c183060c183060c18306;\\n\\tuint256 private constant LAMBERT_POS2_MAXVAL =\\n\\t\\t0x01af16ac6c59de6f8d5d6f63c1482a7c80;\\n\\tuint256 private constant LAMBERT_POS3_MAXVAL =\\n\\t\\t0x6b22d43e72c326539cceeef8bb48f255ff;\\n\\n\\t// Auto-generated via 'PrintWeightFactors.py'\\n\\tuint256 private constant MAX_UNF_WEIGHT =\\n\\t\\t0x10c6f7a0b5ed8d36b4c7f34938583621fafc8b0079a2834d26fa3fcc9ea9;\\n\\n\\t// Auto-generated via 'PrintMaxExpArray.py'\\n\\tuint256[128] private maxExpArray;\\n\\n\\tfunction initMaxExpArray() private {\\n\\t\\t//  maxExpArray[  0] = 0x6bffffffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[  1] = 0x67ffffffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[  2] = 0x637fffffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[  3] = 0x5f6fffffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[  4] = 0x5b77ffffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[  5] = 0x57b3ffffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[  6] = 0x5419ffffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[  7] = 0x50a2ffffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[  8] = 0x4d517fffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[  9] = 0x4a233fffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 10] = 0x47165fffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 11] = 0x4429afffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 12] = 0x415bc7ffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 13] = 0x3eab73ffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 14] = 0x3c1771ffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 15] = 0x399e96ffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 16] = 0x373fc47fffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 17] = 0x34f9e8ffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 18] = 0x32cbfd5fffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 19] = 0x30b5057fffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 20] = 0x2eb40f9fffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 21] = 0x2cc8340fffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 22] = 0x2af09481ffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 23] = 0x292c5bddffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 24] = 0x277abdcdffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 25] = 0x25daf6657fffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 26] = 0x244c49c65fffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 27] = 0x22ce03cd5fffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 28] = 0x215f77c047ffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 29] = 0x1fffffffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 30] = 0x1eaefdbdabffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 31] = 0x1d6bd8b2ebffffffffffffffffffffffff;\\n\\t\\tmaxExpArray[32] = 0x1c35fedd14ffffffffffffffffffffffff;\\n\\t\\tmaxExpArray[33] = 0x1b0ce43b323fffffffffffffffffffffff;\\n\\t\\tmaxExpArray[34] = 0x19f0028ec1ffffffffffffffffffffffff;\\n\\t\\tmaxExpArray[35] = 0x18ded91f0e7fffffffffffffffffffffff;\\n\\t\\tmaxExpArray[36] = 0x17d8ec7f0417ffffffffffffffffffffff;\\n\\t\\tmaxExpArray[37] = 0x16ddc6556cdbffffffffffffffffffffff;\\n\\t\\tmaxExpArray[38] = 0x15ecf52776a1ffffffffffffffffffffff;\\n\\t\\tmaxExpArray[39] = 0x15060c256cb2ffffffffffffffffffffff;\\n\\t\\tmaxExpArray[40] = 0x1428a2f98d72ffffffffffffffffffffff;\\n\\t\\tmaxExpArray[41] = 0x13545598e5c23fffffffffffffffffffff;\\n\\t\\tmaxExpArray[42] = 0x1288c4161ce1dfffffffffffffffffffff;\\n\\t\\tmaxExpArray[43] = 0x11c592761c666fffffffffffffffffffff;\\n\\t\\tmaxExpArray[44] = 0x110a688680a757ffffffffffffffffffff;\\n\\t\\tmaxExpArray[45] = 0x1056f1b5bedf77ffffffffffffffffffff;\\n\\t\\tmaxExpArray[46] = 0x0faadceceeff8bffffffffffffffffffff;\\n\\t\\tmaxExpArray[47] = 0x0f05dc6b27edadffffffffffffffffffff;\\n\\t\\tmaxExpArray[48] = 0x0e67a5a25da4107fffffffffffffffffff;\\n\\t\\tmaxExpArray[49] = 0x0dcff115b14eedffffffffffffffffffff;\\n\\t\\tmaxExpArray[50] = 0x0d3e7a392431239fffffffffffffffffff;\\n\\t\\tmaxExpArray[51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\\n\\t\\tmaxExpArray[52] = 0x0c2d415c3db974afffffffffffffffffff;\\n\\t\\tmaxExpArray[53] = 0x0bad03e7d883f69bffffffffffffffffff;\\n\\t\\tmaxExpArray[54] = 0x0b320d03b2c343d5ffffffffffffffffff;\\n\\t\\tmaxExpArray[55] = 0x0abc25204e02828dffffffffffffffffff;\\n\\t\\tmaxExpArray[56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\\n\\t\\tmaxExpArray[57] = 0x09deaf736ac1f569ffffffffffffffffff;\\n\\t\\tmaxExpArray[58] = 0x0976bd9952c7aa957fffffffffffffffff;\\n\\t\\tmaxExpArray[59] = 0x09131271922eaa606fffffffffffffffff;\\n\\t\\tmaxExpArray[60] = 0x08b380f3558668c46fffffffffffffffff;\\n\\t\\tmaxExpArray[61] = 0x0857ddf0117efa215bffffffffffffffff;\\n\\t\\tmaxExpArray[62] = 0x07ffffffffffffffffffffffffffffffff;\\n\\t\\tmaxExpArray[63] = 0x07abbf6f6abb9d087fffffffffffffffff;\\n\\t\\tmaxExpArray[64] = 0x075af62cbac95f7dfa7fffffffffffffff;\\n\\t\\tmaxExpArray[65] = 0x070d7fb7452e187ac13fffffffffffffff;\\n\\t\\tmaxExpArray[66] = 0x06c3390ecc8af379295fffffffffffffff;\\n\\t\\tmaxExpArray[67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\\n\\t\\tmaxExpArray[68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\\n\\t\\tmaxExpArray[69] = 0x05f63b1fc104dbd39587ffffffffffffff;\\n\\t\\tmaxExpArray[70] = 0x05b771955b36e12f7235ffffffffffffff;\\n\\t\\tmaxExpArray[71] = 0x057b3d49dda84556d6f6ffffffffffffff;\\n\\t\\tmaxExpArray[72] = 0x054183095b2c8ececf30ffffffffffffff;\\n\\t\\tmaxExpArray[73] = 0x050a28be635ca2b888f77fffffffffffff;\\n\\t\\tmaxExpArray[74] = 0x04d5156639708c9db33c3fffffffffffff;\\n\\t\\tmaxExpArray[75] = 0x04a23105873875bd52dfdfffffffffffff;\\n\\t\\tmaxExpArray[76] = 0x0471649d87199aa990756fffffffffffff;\\n\\t\\tmaxExpArray[77] = 0x04429a21a029d4c1457cfbffffffffffff;\\n\\t\\tmaxExpArray[78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\\n\\t\\tmaxExpArray[79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\\n\\t\\tmaxExpArray[80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\\n\\t\\tmaxExpArray[81] = 0x0399e96897690418f785257fffffffffff;\\n\\t\\tmaxExpArray[82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\\n\\t\\tmaxExpArray[83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\\n\\t\\tmaxExpArray[84] = 0x032cbfd4a7adc790560b3337ffffffffff;\\n\\t\\tmaxExpArray[85] = 0x030b50570f6e5d2acca94613ffffffffff;\\n\\t\\tmaxExpArray[86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\\n\\t\\tmaxExpArray[87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\\n\\t\\tmaxExpArray[88] = 0x02af09481380a0a35cf1ba02ffffffffff;\\n\\t\\tmaxExpArray[89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\\n\\t\\tmaxExpArray[90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\\n\\t\\tmaxExpArray[91] = 0x025daf6654b1eaa55fd64df5efffffffff;\\n\\t\\tmaxExpArray[92] = 0x0244c49c648baa98192dce88b7ffffffff;\\n\\t\\tmaxExpArray[93] = 0x022ce03cd5619a311b2471268bffffffff;\\n\\t\\tmaxExpArray[94] = 0x0215f77c045fbe885654a44a0fffffffff;\\n\\t\\tmaxExpArray[95] = 0x01ffffffffffffffffffffffffffffffff;\\n\\t\\tmaxExpArray[96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\\n\\t\\tmaxExpArray[97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\\n\\t\\tmaxExpArray[98] = 0x01c35fedd14b861eb0443f7f133fffffff;\\n\\t\\tmaxExpArray[99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\\n\\t\\tmaxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\\n\\t\\tmaxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\\n\\t\\tmaxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\\n\\t\\tmaxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\\n\\t\\tmaxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\\n\\t\\tmaxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\\n\\t\\tmaxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\\n\\t\\tmaxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\\n\\t\\tmaxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\\n\\t\\tmaxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\\n\\t\\tmaxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\\n\\t\\tmaxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\\n\\t\\tmaxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\\n\\t\\tmaxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\\n\\t\\tmaxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\\n\\t\\tmaxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\\n\\t\\tmaxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\\n\\t\\tmaxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\\n\\t\\tmaxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\\n\\t\\tmaxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\\n\\t\\tmaxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\\n\\t\\tmaxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\\n\\t\\tmaxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\\n\\t\\tmaxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\\n\\t\\tmaxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\\n\\t\\tmaxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\\n\\t\\tmaxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\\n\\t\\tmaxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\\n\\t}\\n\\n\\t// Auto-generated via 'PrintLambertArray.py'\\n\\tuint256[128] private lambertArray;\\n\\n\\tfunction initLambertArray() private {\\n\\t\\tlambertArray[0] = 0x60e393c68d20b1bd09deaabc0373b9c5;\\n\\t\\tlambertArray[1] = 0x5f8f46e4854120989ed94719fb4c2011;\\n\\t\\tlambertArray[2] = 0x5e479ebb9129fb1b7e72a648f992b606;\\n\\t\\tlambertArray[3] = 0x5d0bd23fe42dfedde2e9586be12b85fe;\\n\\t\\tlambertArray[4] = 0x5bdb29ddee979308ddfca81aeeb8095a;\\n\\t\\tlambertArray[5] = 0x5ab4fd8a260d2c7e2c0d2afcf0009dad;\\n\\t\\tlambertArray[6] = 0x5998b31359a55d48724c65cf09001221;\\n\\t\\tlambertArray[7] = 0x5885bcad2b322dfc43e8860f9c018cf5;\\n\\t\\tlambertArray[8] = 0x577b97aa1fe222bb452fdf111b1f0be2;\\n\\t\\tlambertArray[9] = 0x5679cb5e3575632e5baa27e2b949f704;\\n\\t\\tlambertArray[10] = 0x557fe8241b3a31c83c732f1cdff4a1c5;\\n\\t\\tlambertArray[11] = 0x548d868026504875d6e59bbe95fc2a6b;\\n\\t\\tlambertArray[12] = 0x53a2465ce347cf34d05a867c17dd3088;\\n\\t\\tlambertArray[13] = 0x52bdce5dcd4faed59c7f5511cf8f8acc;\\n\\t\\tlambertArray[14] = 0x51dfcb453c07f8da817606e7885f7c3e;\\n\\t\\tlambertArray[15] = 0x5107ef6b0a5a2be8f8ff15590daa3cce;\\n\\t\\tlambertArray[16] = 0x5035f241d6eae0cd7bacba119993de7b;\\n\\t\\tlambertArray[17] = 0x4f698fe90d5b53d532171e1210164c66;\\n\\t\\tlambertArray[18] = 0x4ea288ca297a0e6a09a0eee240e16c85;\\n\\t\\tlambertArray[19] = 0x4de0a13fdcf5d4213fc398ba6e3becde;\\n\\t\\tlambertArray[20] = 0x4d23a145eef91fec06b06140804c4808;\\n\\t\\tlambertArray[21] = 0x4c6b5430d4c1ee5526473db4ae0f11de;\\n\\t\\tlambertArray[22] = 0x4bb7886c240562eba11f4963a53b4240;\\n\\t\\tlambertArray[23] = 0x4b080f3f1cb491d2d521e0ea4583521e;\\n\\t\\tlambertArray[24] = 0x4a5cbc96a05589cb4d86be1db3168364;\\n\\t\\tlambertArray[25] = 0x49b566d40243517658d78c33162d6ece;\\n\\t\\tlambertArray[26] = 0x4911e6a02e5507a30f947383fd9a3276;\\n\\t\\tlambertArray[27] = 0x487216c2b31be4adc41db8a8d5cc0c88;\\n\\t\\tlambertArray[28] = 0x47d5d3fc4a7a1b188cd3d788b5c5e9fc;\\n\\t\\tlambertArray[29] = 0x473cfce4871a2c40bc4f9e1c32b955d0;\\n\\t\\tlambertArray[30] = 0x46a771ca578ab878485810e285e31c67;\\n\\t\\tlambertArray[31] = 0x4615149718aed4c258c373dc676aa72d;\\n\\t\\tlambertArray[32] = 0x4585c8b3f8fe489c6e1833ca47871384;\\n\\t\\tlambertArray[33] = 0x44f972f174e41e5efb7e9d63c29ce735;\\n\\t\\tlambertArray[34] = 0x446ff970ba86d8b00beb05ecebf3c4dc;\\n\\t\\tlambertArray[35] = 0x43e9438ec88971812d6f198b5ccaad96;\\n\\t\\tlambertArray[36] = 0x436539d11ff7bea657aeddb394e809ef;\\n\\t\\tlambertArray[37] = 0x42e3c5d3e5a913401d86f66db5d81c2c;\\n\\t\\tlambertArray[38] = 0x4264d2395303070ea726cbe98df62174;\\n\\t\\tlambertArray[39] = 0x41e84a9a593bb7194c3a6349ecae4eea;\\n\\t\\tlambertArray[40] = 0x416e1b785d13eba07a08f3f18876a5ab;\\n\\t\\tlambertArray[41] = 0x40f6322ff389d423ba9dd7e7e7b7e809;\\n\\t\\tlambertArray[42] = 0x40807cec8a466880ecf4184545d240a4;\\n\\t\\tlambertArray[43] = 0x400cea9ce88a8d3ae668e8ea0d9bf07f;\\n\\t\\tlambertArray[44] = 0x3f9b6ae8772d4c55091e0ed7dfea0ac1;\\n\\t\\tlambertArray[45] = 0x3f2bee253fd84594f54bcaafac383a13;\\n\\t\\tlambertArray[46] = 0x3ebe654e95208bb9210c575c081c5958;\\n\\t\\tlambertArray[47] = 0x3e52c1fc5665635b78ce1f05ad53c086;\\n\\t\\tlambertArray[48] = 0x3de8f65ac388101ddf718a6f5c1eff65;\\n\\t\\tlambertArray[49] = 0x3d80f522d59bd0b328ca012df4cd2d49;\\n\\t\\tlambertArray[50] = 0x3d1ab193129ea72b23648a161163a85a;\\n\\t\\tlambertArray[51] = 0x3cb61f68d32576c135b95cfb53f76d75;\\n\\t\\tlambertArray[52] = 0x3c5332d9f1aae851a3619e77e4cc8473;\\n\\t\\tlambertArray[53] = 0x3bf1e08edbe2aa109e1525f65759ef73;\\n\\t\\tlambertArray[54] = 0x3b921d9cff13fa2c197746a3dfc4918f;\\n\\t\\tlambertArray[55] = 0x3b33df818910bfc1a5aefb8f63ae2ac4;\\n\\t\\tlambertArray[56] = 0x3ad71c1c77e34fa32a9f184967eccbf6;\\n\\t\\tlambertArray[57] = 0x3a7bc9abf2c5bb53e2f7384a8a16521a;\\n\\t\\tlambertArray[58] = 0x3a21dec7e76369783a68a0c6385a1c57;\\n\\t\\tlambertArray[59] = 0x39c9525de6c9cdf7c1c157ca4a7a6ee3;\\n\\t\\tlambertArray[60] = 0x39721bad3dc85d1240ff0190e0adaac3;\\n\\t\\tlambertArray[61] = 0x391c324344d3248f0469eb28dd3d77e0;\\n\\t\\tlambertArray[62] = 0x38c78df7e3c796279fb4ff84394ab3da;\\n\\t\\tlambertArray[63] = 0x387426ea4638ae9aae08049d3554c20a;\\n\\t\\tlambertArray[64] = 0x3821f57dbd2763256c1a99bbd2051378;\\n\\t\\tlambertArray[65] = 0x37d0f256cb46a8c92ff62fbbef289698;\\n\\t\\tlambertArray[66] = 0x37811658591ffc7abdd1feaf3cef9b73;\\n\\t\\tlambertArray[67] = 0x37325aa10e9e82f7df0f380f7997154b;\\n\\t\\tlambertArray[68] = 0x36e4b888cfb408d873b9a80d439311c6;\\n\\t\\tlambertArray[69] = 0x3698299e59f4bb9de645fc9b08c64cca;\\n\\t\\tlambertArray[70] = 0x364ca7a5012cb603023b57dd3ebfd50d;\\n\\t\\tlambertArray[71] = 0x36022c928915b778ab1b06aaee7e61d4;\\n\\t\\tlambertArray[72] = 0x35b8b28d1a73dc27500ffe35559cc028;\\n\\t\\tlambertArray[73] = 0x357033e951fe250ec5eb4e60955132d7;\\n\\t\\tlambertArray[74] = 0x3528ab2867934e3a21b5412e4c4f8881;\\n\\t\\tlambertArray[75] = 0x34e212f66c55057f9676c80094a61d59;\\n\\t\\tlambertArray[76] = 0x349c66289e5b3c4b540c24f42fa4b9bb;\\n\\t\\tlambertArray[77] = 0x34579fbbd0c733a9c8d6af6b0f7d00f7;\\n\\t\\tlambertArray[78] = 0x3413bad2e712288b924b5882b5b369bf;\\n\\t\\tlambertArray[79] = 0x33d0b2b56286510ef730e213f71f12e9;\\n\\t\\tlambertArray[80] = 0x338e82ce00e2496262c64457535ba1a1;\\n\\t\\tlambertArray[81] = 0x334d26a96b373bb7c2f8ea1827f27a92;\\n\\t\\tlambertArray[82] = 0x330c99f4f4211469e00b3e18c31475ea;\\n\\t\\tlambertArray[83] = 0x32ccd87d6486094999c7d5e6f33237d8;\\n\\t\\tlambertArray[84] = 0x328dde2dd617b6665a2e8556f250c1af;\\n\\t\\tlambertArray[85] = 0x324fa70e9adc270f8262755af5a99af9;\\n\\t\\tlambertArray[86] = 0x32122f443110611ca51040f41fa6e1e3;\\n\\t\\tlambertArray[87] = 0x31d5730e42c0831482f0f1485c4263d8;\\n\\t\\tlambertArray[88] = 0x31996ec6b07b4a83421b5ebc4ab4e1f1;\\n\\t\\tlambertArray[89] = 0x315e1ee0a68ff46bb43ec2b85032e876;\\n\\t\\tlambertArray[90] = 0x31237fe7bc4deacf6775b9efa1a145f8;\\n\\t\\tlambertArray[91] = 0x30e98e7f1cc5a356e44627a6972ea2ff;\\n\\t\\tlambertArray[92] = 0x30b04760b8917ec74205a3002650ec05;\\n\\t\\tlambertArray[93] = 0x3077a75c803468e9132ce0cf3224241d;\\n\\t\\tlambertArray[94] = 0x303fab57a6a275c36f19cda9bace667a;\\n\\t\\tlambertArray[95] = 0x3008504beb8dcbd2cf3bc1f6d5a064f0;\\n\\t\\tlambertArray[96] = 0x2fd19346ed17dac61219ce0c2c5ac4b0;\\n\\t\\tlambertArray[97] = 0x2f9b7169808c324b5852fd3d54ba9714;\\n\\t\\tlambertArray[98] = 0x2f65e7e711cf4b064eea9c08cbdad574;\\n\\t\\tlambertArray[99] = 0x2f30f405093042ddff8a251b6bf6d103;\\n\\t\\tlambertArray[100] = 0x2efc931a3750f2e8bfe323edfe037574;\\n\\t\\tlambertArray[101] = 0x2ec8c28e46dbe56d98685278339400cb;\\n\\t\\tlambertArray[102] = 0x2e957fd933c3926d8a599b602379b851;\\n\\t\\tlambertArray[103] = 0x2e62c882c7c9ed4473412702f08ba0e5;\\n\\t\\tlambertArray[104] = 0x2e309a221c12ba361e3ed695167feee2;\\n\\t\\tlambertArray[105] = 0x2dfef25d1f865ae18dd07cfea4bcea10;\\n\\t\\tlambertArray[106] = 0x2dcdcee821cdc80decc02c44344aeb31;\\n\\t\\tlambertArray[107] = 0x2d9d2d8562b34944d0b201bb87260c83;\\n\\t\\tlambertArray[108] = 0x2d6d0c04a5b62a2c42636308669b729a;\\n\\t\\tlambertArray[109] = 0x2d3d6842c9a235517fc5a0332691528f;\\n\\t\\tlambertArray[110] = 0x2d0e402963fe1ea2834abc408c437c10;\\n\\t\\tlambertArray[111] = 0x2cdf91ae602647908aff975e4d6a2a8c;\\n\\t\\tlambertArray[112] = 0x2cb15ad3a1eb65f6d74a75da09a1b6c5;\\n\\t\\tlambertArray[113] = 0x2c8399a6ab8e9774d6fcff373d210727;\\n\\t\\tlambertArray[114] = 0x2c564c4046f64edba6883ca06bbc4535;\\n\\t\\tlambertArray[115] = 0x2c2970c431f952641e05cb493e23eed3;\\n\\t\\tlambertArray[116] = 0x2bfd0560cd9eb14563bc7c0732856c18;\\n\\t\\tlambertArray[117] = 0x2bd1084ed0332f7ff4150f9d0ef41a2c;\\n\\t\\tlambertArray[118] = 0x2ba577d0fa1628b76d040b12a82492fb;\\n\\t\\tlambertArray[119] = 0x2b7a5233cd21581e855e89dc2f1e8a92;\\n\\t\\tlambertArray[120] = 0x2b4f95cd46904d05d72bdcde337d9cc7;\\n\\t\\tlambertArray[121] = 0x2b2540fc9b4d9abba3faca6691914675;\\n\\t\\tlambertArray[122] = 0x2afb5229f68d0830d8be8adb0a0db70f;\\n\\t\\tlambertArray[123] = 0x2ad1c7c63a9b294c5bc73a3ba3ab7a2b;\\n\\t\\tlambertArray[124] = 0x2aa8a04ac3cbe1ee1c9c86361465dbb8;\\n\\t\\tlambertArray[125] = 0x2a7fda392d725a44a2c8aeb9ab35430d;\\n\\t\\tlambertArray[126] = 0x2a57741b18cde618717792b4faa216db;\\n\\t\\tlambertArray[127] = 0x2a2f6c81f5d84dd950a35626d6d5503a;\\n\\t}\\n\\n\\t/**\\n\\t * @dev should be executed after construction (too large for the constructor)\\n\\t */\\n\\tfunction init() public {\\n\\t\\tinitMaxExpArray();\\n\\t\\tinitLambertArray();\\n\\t}\\n\\n\\t/**\\n\\t * @dev given a token supply, reserve balance, weight and a deposit amount (in the reserve token),\\n\\t * calculates the target amount for a given conversion (in the main token)\\n\\t *\\n\\t * Formula:\\n\\t * return = _supply * ((1 + _amount / _reserveBalance) ^ (_reserveWeight / 1000000) - 1)\\n\\t *\\n\\t * @param _supply          liquid token supply\\n\\t * @param _reserveBalance  reserve balance\\n\\t * @param _reserveWeight   reserve weight, represented in ppm (1-1000000)\\n\\t * @param _amount          amount of reserve tokens to get the target amount for\\n\\t *\\n\\t * @return target\\n\\t */\\n\\tfunction purchaseTargetAmount(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _reserveBalance,\\n\\t\\tuint32 _reserveWeight,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\t// validate input\\n\\t\\trequire(_supply > 0, \\\"ERR_INVALID_SUPPLY\\\");\\n\\t\\trequire(_reserveBalance > 0, \\\"ERR_INVALID_RESERVE_BALANCE\\\");\\n\\t\\trequire(\\n\\t\\t\\t_reserveWeight > 0 && _reserveWeight <= MAX_WEIGHT,\\n\\t\\t\\t\\\"ERR_INVALID_RESERVE_WEIGHT\\\"\\n\\t\\t);\\n\\n\\t\\t// special case for 0 deposit amount\\n\\t\\tif (_amount == 0) return 0;\\n\\n\\t\\t// special case if the weight = 100%\\n\\t\\tif (_reserveWeight == MAX_WEIGHT)\\n\\t\\t\\treturn _supply.mul(_amount) / _reserveBalance;\\n\\n\\t\\tuint256 result;\\n\\t\\tuint8 precision;\\n\\t\\tuint256 baseN = _amount.add(_reserveBalance);\\n\\t\\t(result, precision) = power(\\n\\t\\t\\tbaseN,\\n\\t\\t\\t_reserveBalance,\\n\\t\\t\\t_reserveWeight,\\n\\t\\t\\tMAX_WEIGHT\\n\\t\\t);\\n\\t\\tuint256 temp = _supply.mul(result) >> precision;\\n\\t\\treturn temp - _supply;\\n\\t}\\n\\n\\t/**\\n\\t * @dev given a token supply, reserve balance, weight and a sell amount (in the main token),\\n\\t * calculates the target amount for a given conversion (in the reserve token)\\n\\t *\\n\\t * Formula:\\n\\t * return = _reserveBalance * (1 - (1 - _amount / _supply) ^ (1000000 / _reserveWeight))\\n\\t *\\n\\t * @param _supply          liquid token supply\\n\\t * @param _reserveBalance  reserve balance\\n\\t * @param _reserveWeight   reserve weight, represented in ppm (1-1000000)\\n\\t * @param _amount          amount of liquid tokens to get the target amount for\\n\\t *\\n\\t * @return reserve token amount\\n\\t */\\n\\tfunction saleTargetAmount(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _reserveBalance,\\n\\t\\tuint32 _reserveWeight,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\t// validate input\\n\\t\\trequire(_supply > 0, \\\"ERR_INVALID_SUPPLY\\\");\\n\\t\\trequire(_reserveBalance > 0, \\\"ERR_INVALID_RESERVE_BALANCE\\\");\\n\\t\\trequire(\\n\\t\\t\\t_reserveWeight > 0 && _reserveWeight <= MAX_WEIGHT,\\n\\t\\t\\t\\\"ERR_INVALID_RESERVE_WEIGHT\\\"\\n\\t\\t);\\n\\t\\trequire(_amount <= _supply, \\\"ERR_INVALID_AMOUNT\\\");\\n\\n\\t\\t// special case for 0 sell amount\\n\\t\\tif (_amount == 0) return 0;\\n\\n\\t\\t// special case for selling the entire supply\\n\\t\\tif (_amount == _supply) return _reserveBalance;\\n\\n\\t\\t// special case if the weight = 100%\\n\\t\\tif (_reserveWeight == MAX_WEIGHT)\\n\\t\\t\\treturn _reserveBalance.mul(_amount) / _supply;\\n\\n\\t\\tuint256 result;\\n\\t\\tuint8 precision;\\n\\t\\tuint256 baseD = _supply - _amount;\\n\\t\\t(result, precision) = power(_supply, baseD, MAX_WEIGHT, _reserveWeight);\\n\\t\\tuint256 temp1 = _reserveBalance.mul(result);\\n\\t\\tuint256 temp2 = _reserveBalance << precision;\\n\\t\\treturn (temp1 - temp2) / result;\\n\\t}\\n\\n\\t/**\\n\\t * @dev given two reserve balances/weights and a sell amount (in the first reserve token),\\n\\t * calculates the target amount for a conversion from the source reserve token to the target reserve token\\n\\t *\\n\\t * Formula:\\n\\t * return = _targetReserveBalance * (1 - (_sourceReserveBalance / (_sourceReserveBalance + _amount)) ^ (_sourceReserveWeight / _targetReserveWeight))\\n\\t *\\n\\t * @param _sourceReserveBalance    source reserve balance\\n\\t * @param _sourceReserveWeight     source reserve weight, represented in ppm (1-1000000)\\n\\t * @param _targetReserveBalance    target reserve balance\\n\\t * @param _targetReserveWeight     target reserve weight, represented in ppm (1-1000000)\\n\\t * @param _amount                  source reserve amount\\n\\t *\\n\\t * @return target reserve amount\\n\\t */\\n\\tfunction crossReserveTargetAmount(\\n\\t\\tuint256 _sourceReserveBalance,\\n\\t\\tuint32 _sourceReserveWeight,\\n\\t\\tuint256 _targetReserveBalance,\\n\\t\\tuint32 _targetReserveWeight,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\t// validate input\\n\\t\\trequire(\\n\\t\\t\\t_sourceReserveBalance > 0 && _targetReserveBalance > 0,\\n\\t\\t\\t\\\"ERR_INVALID_RESERVE_BALANCE\\\"\\n\\t\\t);\\n\\t\\trequire(\\n\\t\\t\\t_sourceReserveWeight > 0 &&\\n\\t\\t\\t\\t_sourceReserveWeight <= MAX_WEIGHT &&\\n\\t\\t\\t\\t_targetReserveWeight > 0 &&\\n\\t\\t\\t\\t_targetReserveWeight <= MAX_WEIGHT,\\n\\t\\t\\t\\\"ERR_INVALID_RESERVE_WEIGHT\\\"\\n\\t\\t);\\n\\n\\t\\t// special case for equal weights\\n\\t\\tif (_sourceReserveWeight == _targetReserveWeight)\\n\\t\\t\\treturn\\n\\t\\t\\t\\t_targetReserveBalance.mul(_amount) /\\n\\t\\t\\t\\t_sourceReserveBalance.add(_amount);\\n\\n\\t\\tuint256 result;\\n\\t\\tuint8 precision;\\n\\t\\tuint256 baseN = _sourceReserveBalance.add(_amount);\\n\\t\\t(result, precision) = power(\\n\\t\\t\\tbaseN,\\n\\t\\t\\t_sourceReserveBalance,\\n\\t\\t\\t_sourceReserveWeight,\\n\\t\\t\\t_targetReserveWeight\\n\\t\\t);\\n\\t\\tuint256 temp1 = _targetReserveBalance.mul(result);\\n\\t\\tuint256 temp2 = _targetReserveBalance << precision;\\n\\t\\treturn (temp1 - temp2) / result;\\n\\t}\\n\\n\\t/**\\n\\t * @dev given a pool token supply, reserve balance, reserve ratio and an amount of requested pool tokens,\\n\\t * calculates the amount of reserve tokens required for purchasing the given amount of pool tokens\\n\\t *\\n\\t * Formula:\\n\\t * return = _reserveBalance * (((_supply + _amount) / _supply) ^ (MAX_WEIGHT / _reserveRatio) - 1)\\n\\t *\\n\\t * @param _supply          pool token supply\\n\\t * @param _reserveBalance  reserve balance\\n\\t * @param _reserveRatio    reserve ratio, represented in ppm (2-2000000)\\n\\t * @param _amount          requested amount of pool tokens\\n\\t *\\n\\t * @return reserve token amount\\n\\t */\\n\\tfunction fundCost(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _reserveBalance,\\n\\t\\tuint32 _reserveRatio,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\t// validate input\\n\\t\\trequire(_supply > 0, \\\"ERR_INVALID_SUPPLY\\\");\\n\\t\\trequire(_reserveBalance > 0, \\\"ERR_INVALID_RESERVE_BALANCE\\\");\\n\\t\\trequire(\\n\\t\\t\\t_reserveRatio > 1 && _reserveRatio <= MAX_WEIGHT * 2,\\n\\t\\t\\t\\\"ERR_INVALID_RESERVE_RATIO\\\"\\n\\t\\t);\\n\\n\\t\\t// special case for 0 amount\\n\\t\\tif (_amount == 0) return 0;\\n\\n\\t\\t// special case if the reserve ratio = 100%\\n\\t\\tif (_reserveRatio == MAX_WEIGHT)\\n\\t\\t\\treturn (_amount.mul(_reserveBalance) - 1) / _supply + 1;\\n\\n\\t\\tuint256 result;\\n\\t\\tuint8 precision;\\n\\t\\tuint256 baseN = _supply.add(_amount);\\n\\t\\t(result, precision) = power(baseN, _supply, MAX_WEIGHT, _reserveRatio);\\n\\t\\tuint256 temp = ((_reserveBalance.mul(result) - 1) >> precision) + 1;\\n\\t\\treturn temp - _reserveBalance;\\n\\t}\\n\\n\\t/**\\n\\t * @dev given a pool token supply, reserve balance, reserve ratio and an amount of reserve tokens to fund with,\\n\\t * calculates the amount of pool tokens received for purchasing with the given amount of reserve tokens\\n\\t *\\n\\t * Formula:\\n\\t * return = _supply * ((_amount / _reserveBalance + 1) ^ (_reserveRatio / MAX_WEIGHT) - 1)\\n\\t *\\n\\t * @param _supply          pool token supply\\n\\t * @param _reserveBalance  reserve balance\\n\\t * @param _reserveRatio    reserve ratio, represented in ppm (2-2000000)\\n\\t * @param _amount          amount of reserve tokens to fund with\\n\\t *\\n\\t * @return pool token amount\\n\\t */\\n\\tfunction fundSupplyAmount(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _reserveBalance,\\n\\t\\tuint32 _reserveRatio,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\t// validate input\\n\\t\\trequire(_supply > 0, \\\"ERR_INVALID_SUPPLY\\\");\\n\\t\\trequire(_reserveBalance > 0, \\\"ERR_INVALID_RESERVE_BALANCE\\\");\\n\\t\\trequire(\\n\\t\\t\\t_reserveRatio > 1 && _reserveRatio <= MAX_WEIGHT * 2,\\n\\t\\t\\t\\\"ERR_INVALID_RESERVE_RATIO\\\"\\n\\t\\t);\\n\\n\\t\\t// special case for 0 amount\\n\\t\\tif (_amount == 0) return 0;\\n\\n\\t\\t// special case if the reserve ratio = 100%\\n\\t\\tif (_reserveRatio == MAX_WEIGHT)\\n\\t\\t\\treturn _amount.mul(_supply) / _reserveBalance;\\n\\n\\t\\tuint256 result;\\n\\t\\tuint8 precision;\\n\\t\\tuint256 baseN = _reserveBalance.add(_amount);\\n\\t\\t(result, precision) = power(\\n\\t\\t\\tbaseN,\\n\\t\\t\\t_reserveBalance,\\n\\t\\t\\t_reserveRatio,\\n\\t\\t\\tMAX_WEIGHT\\n\\t\\t);\\n\\t\\tuint256 temp = _supply.mul(result) >> precision;\\n\\t\\treturn temp - _supply;\\n\\t}\\n\\n\\t/**\\n\\t * @dev given a pool token supply, reserve balance, reserve ratio and an amount of pool tokens to liquidate,\\n\\t * calculates the amount of reserve tokens received for selling the given amount of pool tokens\\n\\t *\\n\\t * Formula:\\n\\t * return = _reserveBalance * (1 - ((_supply - _amount) / _supply) ^ (MAX_WEIGHT / _reserveRatio))\\n\\t *\\n\\t * @param _supply          pool token supply\\n\\t * @param _reserveBalance  reserve balance\\n\\t * @param _reserveRatio    reserve ratio, represented in ppm (2-2000000)\\n\\t * @param _amount          amount of pool tokens to liquidate\\n\\t *\\n\\t * @return reserve token amount\\n\\t */\\n\\tfunction liquidateReserveAmount(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _reserveBalance,\\n\\t\\tuint32 _reserveRatio,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\t// validate input\\n\\t\\trequire(_supply > 0, \\\"ERR_INVALID_SUPPLY\\\");\\n\\t\\trequire(_reserveBalance > 0, \\\"ERR_INVALID_RESERVE_BALANCE\\\");\\n\\t\\trequire(\\n\\t\\t\\t_reserveRatio > 1 && _reserveRatio <= MAX_WEIGHT * 2,\\n\\t\\t\\t\\\"ERR_INVALID_RESERVE_RATIO\\\"\\n\\t\\t);\\n\\t\\trequire(_amount <= _supply, \\\"ERR_INVALID_AMOUNT\\\");\\n\\n\\t\\t// special case for 0 amount\\n\\t\\tif (_amount == 0) return 0;\\n\\n\\t\\t// special case for liquidating the entire supply\\n\\t\\tif (_amount == _supply) return _reserveBalance;\\n\\n\\t\\t// special case if the reserve ratio = 100%\\n\\t\\tif (_reserveRatio == MAX_WEIGHT)\\n\\t\\t\\treturn _amount.mul(_reserveBalance) / _supply;\\n\\n\\t\\tuint256 result;\\n\\t\\tuint8 precision;\\n\\t\\tuint256 baseD = _supply - _amount;\\n\\t\\t(result, precision) = power(_supply, baseD, MAX_WEIGHT, _reserveRatio);\\n\\t\\tuint256 temp1 = _reserveBalance.mul(result);\\n\\t\\tuint256 temp2 = _reserveBalance << precision;\\n\\t\\treturn (temp1 - temp2) / result;\\n\\t}\\n\\n\\t/**\\n\\t * @dev The arbitrage incentive is to convert to the point where the on-chain price is equal to the off-chain price.\\n\\t * We want this operation to also impact the primary reserve balance becoming equal to the primary reserve staked balance.\\n\\t * In other words, we want the arbitrager to convert the difference between the reserve balance and the reserve staked balance.\\n\\t *\\n\\t * Formula input:\\n\\t * - let t denote the primary reserve token staked balance\\n\\t * - let s denote the primary reserve token balance\\n\\t * - let r denote the secondary reserve token balance\\n\\t * - let q denote the numerator of the rate between the tokens\\n\\t * - let p denote the denominator of the rate between the tokens\\n\\t * Where p primary tokens are equal to q secondary tokens\\n\\t *\\n\\t * Formula output:\\n\\t * - compute x = W(t / r * q / p * log(s / t)) / log(s / t)\\n\\t * - return x / (1 + x) as the weight of the primary reserve token\\n\\t * - return 1 / (1 + x) as the weight of the secondary reserve token\\n\\t * Where W is the Lambert W Function\\n\\t *\\n\\t * If the rate-provider provides the rates for a common unit, for example:\\n\\t * - P = 2 ==> 2 primary reserve tokens = 1 ether\\n\\t * - Q = 3 ==> 3 secondary reserve tokens = 1 ether\\n\\t * Then you can simply use p = P and q = Q\\n\\t *\\n\\t * If the rate-provider provides the rates for a single unit, for example:\\n\\t * - P = 2 ==> 1 primary reserve token = 2 ethers\\n\\t * - Q = 3 ==> 1 secondary reserve token = 3 ethers\\n\\t * Then you can simply use p = Q and q = P\\n\\t *\\n\\t * @param _primaryReserveStakedBalance the primary reserve token staked balance\\n\\t * @param _primaryReserveBalance       the primary reserve token balance\\n\\t * @param _secondaryReserveBalance     the secondary reserve token balance\\n\\t * @param _reserveRateNumerator        the numerator of the rate between the tokens\\n\\t * @param _reserveRateDenominator      the denominator of the rate between the tokens\\n\\t *\\n\\t * Note that `numerator / denominator` should represent the amount of secondary tokens equal to one primary token\\n\\t *\\n\\t * @return the weight of the primary reserve token and the weight of the secondary reserve token, both in ppm (0-1000000)\\n\\t */\\n\\tfunction balancedWeights(\\n\\t\\tuint256 _primaryReserveStakedBalance,\\n\\t\\tuint256 _primaryReserveBalance,\\n\\t\\tuint256 _secondaryReserveBalance,\\n\\t\\tuint256 _reserveRateNumerator,\\n\\t\\tuint256 _reserveRateDenominator\\n\\t) public view returns (uint32, uint32) {\\n\\t\\tif (_primaryReserveStakedBalance == _primaryReserveBalance)\\n\\t\\t\\trequire(\\n\\t\\t\\t\\t_primaryReserveStakedBalance > 0 ||\\n\\t\\t\\t\\t\\t_secondaryReserveBalance > 0,\\n\\t\\t\\t\\t\\\"ERR_INVALID_RESERVE_BALANCE\\\"\\n\\t\\t\\t);\\n\\t\\telse\\n\\t\\t\\trequire(\\n\\t\\t\\t\\t_primaryReserveStakedBalance > 0 &&\\n\\t\\t\\t\\t\\t_primaryReserveBalance > 0 &&\\n\\t\\t\\t\\t\\t_secondaryReserveBalance > 0,\\n\\t\\t\\t\\t\\\"ERR_INVALID_RESERVE_BALANCE\\\"\\n\\t\\t\\t);\\n\\t\\trequire(\\n\\t\\t\\t_reserveRateNumerator > 0 && _reserveRateDenominator > 0,\\n\\t\\t\\t\\\"ERR_INVALID_RESERVE_RATE\\\"\\n\\t\\t);\\n\\n\\t\\tuint256 tq = _primaryReserveStakedBalance.mul(_reserveRateNumerator);\\n\\t\\tuint256 rp = _secondaryReserveBalance.mul(_reserveRateDenominator);\\n\\n\\t\\tif (_primaryReserveStakedBalance < _primaryReserveBalance)\\n\\t\\t\\treturn\\n\\t\\t\\t\\tbalancedWeightsByStake(\\n\\t\\t\\t\\t\\t_primaryReserveBalance,\\n\\t\\t\\t\\t\\t_primaryReserveStakedBalance,\\n\\t\\t\\t\\t\\ttq,\\n\\t\\t\\t\\t\\trp,\\n\\t\\t\\t\\t\\ttrue\\n\\t\\t\\t\\t);\\n\\n\\t\\tif (_primaryReserveStakedBalance > _primaryReserveBalance)\\n\\t\\t\\treturn\\n\\t\\t\\t\\tbalancedWeightsByStake(\\n\\t\\t\\t\\t\\t_primaryReserveStakedBalance,\\n\\t\\t\\t\\t\\t_primaryReserveBalance,\\n\\t\\t\\t\\t\\ttq,\\n\\t\\t\\t\\t\\trp,\\n\\t\\t\\t\\t\\tfalse\\n\\t\\t\\t\\t);\\n\\n\\t\\treturn normalizedWeights(tq, rp);\\n\\t}\\n\\n\\t/**\\n\\t * @dev General Description:\\n\\t *     Determine a value of precision.\\n\\t *     Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\\n\\t *     Return the result along with the precision used.\\n\\t *\\n\\t * Detailed Description:\\n\\t *     Instead of calculating \\\"base ^ exp\\\", we calculate \\\"e ^ (log(base) * exp)\\\".\\n\\t *     The value of \\\"log(base)\\\" is represented with an integer slightly smaller than \\\"log(base) * 2 ^ precision\\\".\\n\\t *     The larger \\\"precision\\\" is, the more accurately this value represents the real value.\\n\\t *     However, the larger \\\"precision\\\" is, the more bits are required in order to store this value.\\n\\t *     And the exponentiation function, which takes \\\"x\\\" and calculates \\\"e ^ x\\\", is limited to a maximum exponent (maximum value of \\\"x\\\").\\n\\t *     This maximum exponent depends on the \\\"precision\\\" used, and it is given by \\\"maxExpArray[precision] >> (MAX_PRECISION - precision)\\\".\\n\\t *     Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\\n\\t *     This allows us to compute \\\"base ^ exp\\\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\\n\\t *     This functions assumes that \\\"_expN < 2 ^ 256 / log(MAX_NUM - 1)\\\", otherwise the multiplication should be replaced with a \\\"safeMul\\\".\\n\\t *     Since we rely on unsigned-integer arithmetic and \\\"base < 1\\\" ==> \\\"log(base) < 0\\\", this function does not support \\\"_baseN < _baseD\\\".\\n\\t */\\n\\tfunction power(\\n\\t\\tuint256 _baseN,\\n\\t\\tuint256 _baseD,\\n\\t\\tuint32 _expN,\\n\\t\\tuint32 _expD\\n\\t) internal view returns (uint256, uint8) {\\n\\t\\trequire(_baseN < MAX_NUM);\\n\\n\\t\\tuint256 baseLog;\\n\\t\\tuint256 base = (_baseN * FIXED_1) / _baseD;\\n\\t\\tif (base < OPT_LOG_MAX_VAL) {\\n\\t\\t\\tbaseLog = optimalLog(base);\\n\\t\\t} else {\\n\\t\\t\\tbaseLog = generalLog(base);\\n\\t\\t}\\n\\n\\t\\tuint256 baseLogTimesExp = (baseLog * _expN) / _expD;\\n\\t\\tif (baseLogTimesExp < OPT_EXP_MAX_VAL) {\\n\\t\\t\\treturn (optimalExp(baseLogTimesExp), MAX_PRECISION);\\n\\t\\t} else {\\n\\t\\t\\tuint8 precision = findPositionInMaxExpArray(baseLogTimesExp);\\n\\t\\t\\treturn (\\n\\t\\t\\t\\tgeneralExp(\\n\\t\\t\\t\\t\\tbaseLogTimesExp >> (MAX_PRECISION - precision),\\n\\t\\t\\t\\t\\tprecision\\n\\t\\t\\t\\t),\\n\\t\\t\\t\\tprecision\\n\\t\\t\\t);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes log(x / FIXED_1) * FIXED_1.\\n\\t * This functions assumes that \\\"x >= FIXED_1\\\", because the output would be negative otherwise.\\n\\t */\\n\\tfunction generalLog(uint256 x) internal pure returns (uint256) {\\n\\t\\tuint256 res = 0;\\n\\n\\t\\t// If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\\n\\t\\tif (x >= FIXED_2) {\\n\\t\\t\\tuint8 count = floorLog2(x / FIXED_1);\\n\\t\\t\\tx >>= count; // now x < 2\\n\\t\\t\\tres = count * FIXED_1;\\n\\t\\t}\\n\\n\\t\\t// If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\\n\\t\\tif (x > FIXED_1) {\\n\\t\\t\\tfor (uint8 i = MAX_PRECISION; i > 0; --i) {\\n\\t\\t\\t\\tx = (x * x) / FIXED_1; // now 1 < x < 4\\n\\t\\t\\t\\tif (x >= FIXED_2) {\\n\\t\\t\\t\\t\\tx >>= 1; // now 1 < x < 2\\n\\t\\t\\t\\t\\tres += ONE << (i - 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn (res * LN2_NUMERATOR) / LN2_DENOMINATOR;\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes the largest integer smaller than or equal to the binary logarithm of the input.\\n\\t */\\n\\tfunction floorLog2(uint256 _n) internal pure returns (uint8) {\\n\\t\\tuint8 res = 0;\\n\\n\\t\\tif (_n < 256) {\\n\\t\\t\\t// At most 8 iterations\\n\\t\\t\\twhile (_n > 1) {\\n\\t\\t\\t\\t_n >>= 1;\\n\\t\\t\\t\\tres += 1;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t// Exactly 8 iterations\\n\\t\\t\\tfor (uint8 s = 128; s > 0; s >>= 1) {\\n\\t\\t\\t\\tif (_n >= (ONE << s)) {\\n\\t\\t\\t\\t\\t_n >>= s;\\n\\t\\t\\t\\t\\tres |= s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\t/**\\n\\t * @dev the global \\\"maxExpArray\\\" is sorted in descending order, and therefore the following statements are equivalent:\\n\\t * - This function finds the position of [the smallest value in \\\"maxExpArray\\\" larger than or equal to \\\"x\\\"]\\n\\t * - This function finds the highest position of [a value in \\\"maxExpArray\\\" larger than or equal to \\\"x\\\"]\\n\\t */\\n\\tfunction findPositionInMaxExpArray(uint256 _x)\\n\\t\\tinternal\\n\\t\\tview\\n\\t\\treturns (uint8)\\n\\t{\\n\\t\\tuint8 lo = MIN_PRECISION;\\n\\t\\tuint8 hi = MAX_PRECISION;\\n\\n\\t\\twhile (lo + 1 < hi) {\\n\\t\\t\\tuint8 mid = (lo + hi) / 2;\\n\\t\\t\\tif (maxExpArray[mid] >= _x) lo = mid;\\n\\t\\t\\telse hi = mid;\\n\\t\\t}\\n\\n\\t\\tif (maxExpArray[hi] >= _x) return hi;\\n\\t\\tif (maxExpArray[lo] >= _x) return lo;\\n\\n\\t\\trequire(false);\\n\\t}\\n\\n\\t/**\\n\\t * @dev this function can be auto-generated by the script 'PrintFunctionGeneralExp.py'.\\n\\t * it approximates \\\"e ^ x\\\" via maclaurin summation: \\\"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\\\".\\n\\t * it returns \\\"e ^ (x / 2 ^ precision) * 2 ^ precision\\\", that is, the result is upshifted for accuracy.\\n\\t * the global \\\"maxExpArray\\\" maps each \\\"precision\\\" to \\\"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\\\".\\n\\t * the maximum permitted value for \\\"x\\\" is therefore given by \\\"maxExpArray[precision] >> (MAX_PRECISION - precision)\\\".\\n\\t */\\n\\tfunction generalExp(uint256 _x, uint8 _precision)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\tuint256 xi = _x;\\n\\t\\tuint256 res = 0;\\n\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x3442c4e6074a82f1797f72ac0000000; // add x^02 * (33! / 02!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x116b96f757c380fb287fd0e40000000; // add x^03 * (33! / 03!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x045ae5bdd5f0e03eca1ff4390000000; // add x^04 * (33! / 04!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x00defabf91302cd95b9ffda50000000; // add x^05 * (33! / 05!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x002529ca9832b22439efff9b8000000; // add x^06 * (33! / 06!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x00054f1cf12bd04e516b6da88000000; // add x^07 * (33! / 07!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x0000a9e39e257a09ca2d6db51000000; // add x^08 * (33! / 08!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x000012e066e7b839fa050c309000000; // add x^09 * (33! / 09!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x000001e33d7d926c329a1ad1a800000; // add x^10 * (33! / 10!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x0000002bee513bdb4a6b19b5f800000; // add x^11 * (33! / 11!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x00000003a9316fa79b88eccf2a00000; // add x^12 * (33! / 12!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x0000000048177ebe1fa812375200000; // add x^13 * (33! / 13!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x0000000005263fe90242dcbacf00000; // add x^14 * (33! / 14!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x000000000057e22099c030d94100000; // add x^15 * (33! / 15!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x0000000000057e22099c030d9410000; // add x^16 * (33! / 16!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x00000000000052b6b54569976310000; // add x^17 * (33! / 17!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x00000000000004985f67696bf748000; // add x^18 * (33! / 18!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x000000000000003dea12ea99e498000; // add x^19 * (33! / 19!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x00000000000000031880f2214b6e000; // add x^20 * (33! / 20!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x000000000000000025bcff56eb36000; // add x^21 * (33! / 21!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x000000000000000001b722e10ab1000; // add x^22 * (33! / 22!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x0000000000000000001317c70077000; // add x^23 * (33! / 23!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x00000000000000000000cba84aafa00; // add x^24 * (33! / 24!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x00000000000000000000082573a0a00; // add x^25 * (33! / 25!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x00000000000000000000005035ad900; // add x^26 * (33! / 26!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x000000000000000000000002f881b00; // add x^27 * (33! / 27!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x0000000000000000000000001b29340; // add x^28 * (33! / 28!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x00000000000000000000000000efc40; // add x^29 * (33! / 29!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x0000000000000000000000000007fe0; // add x^30 * (33! / 30!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x0000000000000000000000000000420; // add x^31 * (33! / 31!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x0000000000000000000000000000021; // add x^32 * (33! / 32!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x0000000000000000000000000000001; // add x^33 * (33! / 33!)\\n\\n\\t\\treturn\\n\\t\\t\\tres / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision); // divide by 33! and then add x^1 / 1! + x^0 / 0!\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes log(x / FIXED_1) * FIXED_1\\n\\t * Input range: FIXED_1 <= x <= OPT_LOG_MAX_VAL - 1\\n\\t * Auto-generated via 'PrintFunctionOptimalLog.py'\\n\\t * Detailed description:\\n\\t * - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2\\n\\t * - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent\\n\\t * - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1\\n\\t * - The natural logarithm of the input is calculated by summing up the intermediate results above\\n\\t * - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)\\n\\t */\\n\\tfunction optimalLog(uint256 x) internal pure returns (uint256) {\\n\\t\\tuint256 res = 0;\\n\\n\\t\\tuint256 y;\\n\\t\\tuint256 z;\\n\\t\\tuint256 w;\\n\\n\\t\\tif (x >= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {\\n\\t\\t\\tres += 0x40000000000000000000000000000000;\\n\\t\\t\\tx = (x * FIXED_1) / 0xd3094c70f034de4b96ff7d5b6f99fcd8;\\n\\t\\t} // add 1 / 2^1\\n\\t\\tif (x >= 0xa45af1e1f40c333b3de1db4dd55f29a7) {\\n\\t\\t\\tres += 0x20000000000000000000000000000000;\\n\\t\\t\\tx = (x * FIXED_1) / 0xa45af1e1f40c333b3de1db4dd55f29a7;\\n\\t\\t} // add 1 / 2^2\\n\\t\\tif (x >= 0x910b022db7ae67ce76b441c27035c6a1) {\\n\\t\\t\\tres += 0x10000000000000000000000000000000;\\n\\t\\t\\tx = (x * FIXED_1) / 0x910b022db7ae67ce76b441c27035c6a1;\\n\\t\\t} // add 1 / 2^3\\n\\t\\tif (x >= 0x88415abbe9a76bead8d00cf112e4d4a8) {\\n\\t\\t\\tres += 0x08000000000000000000000000000000;\\n\\t\\t\\tx = (x * FIXED_1) / 0x88415abbe9a76bead8d00cf112e4d4a8;\\n\\t\\t} // add 1 / 2^4\\n\\t\\tif (x >= 0x84102b00893f64c705e841d5d4064bd3) {\\n\\t\\t\\tres += 0x04000000000000000000000000000000;\\n\\t\\t\\tx = (x * FIXED_1) / 0x84102b00893f64c705e841d5d4064bd3;\\n\\t\\t} // add 1 / 2^5\\n\\t\\tif (x >= 0x8204055aaef1c8bd5c3259f4822735a2) {\\n\\t\\t\\tres += 0x02000000000000000000000000000000;\\n\\t\\t\\tx = (x * FIXED_1) / 0x8204055aaef1c8bd5c3259f4822735a2;\\n\\t\\t} // add 1 / 2^6\\n\\t\\tif (x >= 0x810100ab00222d861931c15e39b44e99) {\\n\\t\\t\\tres += 0x01000000000000000000000000000000;\\n\\t\\t\\tx = (x * FIXED_1) / 0x810100ab00222d861931c15e39b44e99;\\n\\t\\t} // add 1 / 2^7\\n\\t\\tif (x >= 0x808040155aabbbe9451521693554f733) {\\n\\t\\t\\tres += 0x00800000000000000000000000000000;\\n\\t\\t\\tx = (x * FIXED_1) / 0x808040155aabbbe9451521693554f733;\\n\\t\\t} // add 1 / 2^8\\n\\n\\t\\tz = y = x - FIXED_1;\\n\\t\\tw = (y * y) / FIXED_1;\\n\\t\\tres +=\\n\\t\\t\\t(z * (0x100000000000000000000000000000000 - y)) /\\n\\t\\t\\t0x100000000000000000000000000000000;\\n\\t\\tz = (z * w) / FIXED_1; // add y^01 / 01 - y^02 / 02\\n\\t\\tres +=\\n\\t\\t\\t(z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y)) /\\n\\t\\t\\t0x200000000000000000000000000000000;\\n\\t\\tz = (z * w) / FIXED_1; // add y^03 / 03 - y^04 / 04\\n\\t\\tres +=\\n\\t\\t\\t(z * (0x099999999999999999999999999999999 - y)) /\\n\\t\\t\\t0x300000000000000000000000000000000;\\n\\t\\tz = (z * w) / FIXED_1; // add y^05 / 05 - y^06 / 06\\n\\t\\tres +=\\n\\t\\t\\t(z * (0x092492492492492492492492492492492 - y)) /\\n\\t\\t\\t0x400000000000000000000000000000000;\\n\\t\\tz = (z * w) / FIXED_1; // add y^07 / 07 - y^08 / 08\\n\\t\\tres +=\\n\\t\\t\\t(z * (0x08e38e38e38e38e38e38e38e38e38e38e - y)) /\\n\\t\\t\\t0x500000000000000000000000000000000;\\n\\t\\tz = (z * w) / FIXED_1; // add y^09 / 09 - y^10 / 10\\n\\t\\tres +=\\n\\t\\t\\t(z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y)) /\\n\\t\\t\\t0x600000000000000000000000000000000;\\n\\t\\tz = (z * w) / FIXED_1; // add y^11 / 11 - y^12 / 12\\n\\t\\tres +=\\n\\t\\t\\t(z * (0x089d89d89d89d89d89d89d89d89d89d89 - y)) /\\n\\t\\t\\t0x700000000000000000000000000000000;\\n\\t\\tz = (z * w) / FIXED_1; // add y^13 / 13 - y^14 / 14\\n\\t\\tres +=\\n\\t\\t\\t(z * (0x088888888888888888888888888888888 - y)) /\\n\\t\\t\\t0x800000000000000000000000000000000; // add y^15 / 15 - y^16 / 16\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes e ^ (x / FIXED_1) * FIXED_1\\n\\t * input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\\n\\t * auto-generated via 'PrintFunctionOptimalExp.py'\\n\\t * Detailed description:\\n\\t * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\\n\\t * - The exponentiation of each binary exponent is given (pre-calculated)\\n\\t * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\\n\\t * - The exponentiation of the input is calculated by multiplying the intermediate results above\\n\\t * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\\n\\t */\\n\\tfunction optimalExp(uint256 x) internal pure returns (uint256) {\\n\\t\\tuint256 res = 0;\\n\\n\\t\\tuint256 y;\\n\\t\\tuint256 z;\\n\\n\\t\\tz = y = x % 0x10000000000000000000000000000000; // get the input modulo 2^(-3)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x000000000001c638; // add y^16 * (20! / 16!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x000000000000017c; // add y^18 * (20! / 18!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x0000000000000014; // add y^19 * (20! / 19!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x0000000000000001; // add y^20 * (20! / 20!)\\n\\t\\tres = res / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\\n\\n\\t\\tif ((x & 0x010000000000000000000000000000000) != 0)\\n\\t\\t\\tres =\\n\\t\\t\\t\\t(res * 0x1c3d6a24ed82218787d624d3e5eba95f9) /\\n\\t\\t\\t\\t0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^2^(-3)\\n\\t\\tif ((x & 0x020000000000000000000000000000000) != 0)\\n\\t\\t\\tres =\\n\\t\\t\\t\\t(res * 0x18ebef9eac820ae8682b9793ac6d1e778) /\\n\\t\\t\\t\\t0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^2^(-2)\\n\\t\\tif ((x & 0x040000000000000000000000000000000) != 0)\\n\\t\\t\\tres =\\n\\t\\t\\t\\t(res * 0x1368b2fc6f9609fe7aceb46aa619baed5) /\\n\\t\\t\\t\\t0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^2^(-1)\\n\\t\\tif ((x & 0x080000000000000000000000000000000) != 0)\\n\\t\\t\\tres =\\n\\t\\t\\t\\t(res * 0x0bc5ab1b16779be3575bd8f0520a9f21e) /\\n\\t\\t\\t\\t0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^2^(+0)\\n\\t\\tif ((x & 0x100000000000000000000000000000000) != 0)\\n\\t\\t\\tres =\\n\\t\\t\\t\\t(res * 0x0454aaa8efe072e7f6ddbab84b40a55c5) /\\n\\t\\t\\t\\t0x00960aadc109e7a3bf4578099615711ea; // multiply by e^2^(+1)\\n\\t\\tif ((x & 0x200000000000000000000000000000000) != 0)\\n\\t\\t\\tres =\\n\\t\\t\\t\\t(res * 0x00960aadc109e7a3bf4578099615711d7) /\\n\\t\\t\\t\\t0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^2^(+2)\\n\\t\\tif ((x & 0x400000000000000000000000000000000) != 0)\\n\\t\\t\\tres =\\n\\t\\t\\t\\t(res * 0x0002bf84208204f5977f9a8cf01fdc307) /\\n\\t\\t\\t\\t0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^2^(+3)\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes W(x / FIXED_1) / (x / FIXED_1) * FIXED_1\\n\\t */\\n\\tfunction lowerStake(uint256 _x) internal view returns (uint256) {\\n\\t\\tif (_x <= LAMBERT_CONV_RADIUS) return lambertPos1(_x);\\n\\t\\tif (_x <= LAMBERT_POS2_MAXVAL) return lambertPos2(_x);\\n\\t\\tif (_x <= LAMBERT_POS3_MAXVAL) return lambertPos3(_x);\\n\\t\\trequire(false);\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes W(-x / FIXED_1) / (-x / FIXED_1) * FIXED_1\\n\\t */\\n\\tfunction higherStake(uint256 _x) internal pure returns (uint256) {\\n\\t\\tif (_x <= LAMBERT_CONV_RADIUS) return lambertNeg1(_x);\\n\\t\\treturn (FIXED_1 * FIXED_1) / _x;\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes W(x / FIXED_1) / (x / FIXED_1) * FIXED_1\\n\\t * input range: 1 <= x <= 1 / e * FIXED_1\\n\\t * auto-generated via 'PrintFunctionLambertPos1.py'\\n\\t */\\n\\tfunction lambertPos1(uint256 _x) internal pure returns (uint256) {\\n\\t\\tuint256 xi = _x;\\n\\t\\tuint256 res = (FIXED_1 - _x) * 0xde1bc4d19efcac82445da75b00000000; // x^(1-1) * (34! * 1^(1-1) / 1!) - x^(2-1) * (34! * 2^(2-1) / 2!)\\n\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x00000000014d29a73a6e7b02c3668c7b0880000000; // add x^(03-1) * (34! * 03^(03-1) / 03!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x0000000002504a0cd9a7f7215b60f9be4800000000; // sub x^(04-1) * (34! * 04^(04-1) / 04!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000000000484d0a1191c0ead267967c7a4a0000000; // add x^(05-1) * (34! * 05^(05-1) / 05!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x00000000095ec580d7e8427a4baf26a90a00000000; // sub x^(06-1) * (34! * 06^(06-1) / 06!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000000001440b0be1615a47dba6e5b3b1f10000000; // add x^(07-1) * (34! * 07^(07-1) / 07!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x000000002d207601f46a99b4112418400000000000; // sub x^(08-1) * (34! * 08^(08-1) / 08!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0000000066ebaac4c37c622dd8288a7eb1b2000000; // add x^(09-1) * (34! * 09^(09-1) / 09!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x00000000ef17240135f7dbd43a1ba10cf200000000; // sub x^(10-1) * (34! * 10^(10-1) / 10!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0000000233c33c676a5eb2416094a87b3657000000; // add x^(11-1) * (34! * 11^(11-1) / 11!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x0000000541cde48bc0254bed49a9f8700000000000; // sub x^(12-1) * (34! * 12^(12-1) / 12!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0000000cae1fad2cdd4d4cb8d73abca0d19a400000; // add x^(13-1) * (34! * 13^(13-1) / 13!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x0000001edb2aa2f760d15c41ceedba956400000000; // sub x^(14-1) * (34! * 14^(14-1) / 14!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0000004ba8d20d2dabd386c9529659841a2e200000; // add x^(15-1) * (34! * 15^(15-1) / 15!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x000000bac08546b867cdaa20000000000000000000; // sub x^(16-1) * (34! * 16^(16-1) / 16!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000001cfa8e70c03625b9db76c8ebf5bbf24820000; // add x^(17-1) * (34! * 17^(17-1) / 17!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x000004851d99f82060df265f3309b26f8200000000; // sub x^(18-1) * (34! * 18^(18-1) / 18!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x00000b550d19b129d270c44f6f55f027723cbb0000; // add x^(19-1) * (34! * 19^(19-1) / 19!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x00001c877dadc761dc272deb65d4b0000000000000; // sub x^(20-1) * (34! * 20^(20-1) / 20!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000048178ece97479f33a77f2ad22a81b64406c000; // add x^(21-1) * (34! * 21^(21-1) / 21!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x0000b6ca8268b9d810fedf6695ef2f8a6c00000000; // sub x^(22-1) * (34! * 22^(22-1) / 22!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0001d0e76631a5b05d007b8cb72a7c7f11ec36e000; // add x^(23-1) * (34! * 23^(23-1) / 23!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x0004a1c37bd9f85fd9c6c780000000000000000000; // sub x^(24-1) * (34! * 24^(24-1) / 24!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000bd8369f1b702bf491e2ebfcee08250313b65400; // add x^(25-1) * (34! * 25^(25-1) / 25!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x001e5c7c32a9f6c70ab2cb59d9225764d400000000; // sub x^(26-1) * (34! * 26^(26-1) / 26!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x004dff5820e165e910f95120a708e742496221e600; // add x^(27-1) * (34! * 27^(27-1) / 27!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x00c8c8f66db1fced378ee50e536000000000000000; // sub x^(28-1) * (34! * 28^(28-1) / 28!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0205db8dffff45bfa2938f128f599dbf16eb11d880; // add x^(29-1) * (34! * 29^(29-1) / 29!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x053a044ebd984351493e1786af38d39a0800000000; // sub x^(30-1) * (34! * 30^(30-1) / 30!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0d86dae2a4cc0f47633a544479735869b487b59c40; // add x^(31-1) * (34! * 31^(31-1) / 31!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x231000000000000000000000000000000000000000; // sub x^(32-1) * (34! * 32^(32-1) / 32!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x5b0485a76f6646c2039db1507cdd51b08649680822; // add x^(33-1) * (34! * 33^(33-1) / 33!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0xec983c46c49545bc17efa6b5b0055e242200000000; // sub x^(34-1) * (34! * 34^(34-1) / 34!)\\n\\n\\t\\treturn res / 0xde1bc4d19efcac82445da75b00000000; // divide by 34!\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes W(x / FIXED_1) / (x / FIXED_1) * FIXED_1\\n\\t * input range: LAMBERT_CONV_RADIUS + 1 <= x <= LAMBERT_POS2_MAXVAL\\n\\t */\\n\\tfunction lambertPos2(uint256 _x) internal view returns (uint256) {\\n\\t\\tuint256 x = _x - LAMBERT_CONV_RADIUS - 1;\\n\\t\\tuint256 i = x / LAMBERT_POS2_SAMPLE;\\n\\t\\tuint256 a = LAMBERT_POS2_SAMPLE * i;\\n\\t\\tuint256 b = LAMBERT_POS2_SAMPLE * (i + 1);\\n\\t\\tuint256 c = lambertArray[i];\\n\\t\\tuint256 d = lambertArray[i + 1];\\n\\t\\treturn (c * (b - x) + d * (x - a)) / LAMBERT_POS2_SAMPLE;\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes W(x / FIXED_1) / (x / FIXED_1) * FIXED_1\\n\\t * input range: LAMBERT_POS2_MAXVAL + 1 <= x <= LAMBERT_POS3_MAXVAL\\n\\t */\\n\\tfunction lambertPos3(uint256 _x) internal pure returns (uint256) {\\n\\t\\tuint256 l1 = _x < OPT_LOG_MAX_VAL ? optimalLog(_x) : generalLog(_x);\\n\\t\\tuint256 l2 = l1 < OPT_LOG_MAX_VAL ? optimalLog(l1) : generalLog(l1);\\n\\t\\treturn ((l1 - l2 + (l2 * FIXED_1) / l1) * FIXED_1) / _x;\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes W(-x / FIXED_1) / (-x / FIXED_1) * FIXED_1\\n\\t * input range: 1 <= x <= 1 / e * FIXED_1\\n\\t * auto-generated via 'PrintFunctionLambertNeg1.py'\\n\\t */\\n\\tfunction lambertNeg1(uint256 _x) internal pure returns (uint256) {\\n\\t\\tuint256 xi = _x;\\n\\t\\tuint256 res = 0;\\n\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x00000000014d29a73a6e7b02c3668c7b0880000000; // add x^(03-1) * (34! * 03^(03-1) / 03!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0000000002504a0cd9a7f7215b60f9be4800000000; // add x^(04-1) * (34! * 04^(04-1) / 04!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000000000484d0a1191c0ead267967c7a4a0000000; // add x^(05-1) * (34! * 05^(05-1) / 05!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x00000000095ec580d7e8427a4baf26a90a00000000; // add x^(06-1) * (34! * 06^(06-1) / 06!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000000001440b0be1615a47dba6e5b3b1f10000000; // add x^(07-1) * (34! * 07^(07-1) / 07!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000000002d207601f46a99b4112418400000000000; // add x^(08-1) * (34! * 08^(08-1) / 08!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0000000066ebaac4c37c622dd8288a7eb1b2000000; // add x^(09-1) * (34! * 09^(09-1) / 09!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x00000000ef17240135f7dbd43a1ba10cf200000000; // add x^(10-1) * (34! * 10^(10-1) / 10!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0000000233c33c676a5eb2416094a87b3657000000; // add x^(11-1) * (34! * 11^(11-1) / 11!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0000000541cde48bc0254bed49a9f8700000000000; // add x^(12-1) * (34! * 12^(12-1) / 12!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0000000cae1fad2cdd4d4cb8d73abca0d19a400000; // add x^(13-1) * (34! * 13^(13-1) / 13!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0000001edb2aa2f760d15c41ceedba956400000000; // add x^(14-1) * (34! * 14^(14-1) / 14!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0000004ba8d20d2dabd386c9529659841a2e200000; // add x^(15-1) * (34! * 15^(15-1) / 15!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000000bac08546b867cdaa20000000000000000000; // add x^(16-1) * (34! * 16^(16-1) / 16!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000001cfa8e70c03625b9db76c8ebf5bbf24820000; // add x^(17-1) * (34! * 17^(17-1) / 17!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000004851d99f82060df265f3309b26f8200000000; // add x^(18-1) * (34! * 18^(18-1) / 18!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x00000b550d19b129d270c44f6f55f027723cbb0000; // add x^(19-1) * (34! * 19^(19-1) / 19!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x00001c877dadc761dc272deb65d4b0000000000000; // add x^(20-1) * (34! * 20^(20-1) / 20!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000048178ece97479f33a77f2ad22a81b64406c000; // add x^(21-1) * (34! * 21^(21-1) / 21!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0000b6ca8268b9d810fedf6695ef2f8a6c00000000; // add x^(22-1) * (34! * 22^(22-1) / 22!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0001d0e76631a5b05d007b8cb72a7c7f11ec36e000; // add x^(23-1) * (34! * 23^(23-1) / 23!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0004a1c37bd9f85fd9c6c780000000000000000000; // add x^(24-1) * (34! * 24^(24-1) / 24!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000bd8369f1b702bf491e2ebfcee08250313b65400; // add x^(25-1) * (34! * 25^(25-1) / 25!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x001e5c7c32a9f6c70ab2cb59d9225764d400000000; // add x^(26-1) * (34! * 26^(26-1) / 26!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x004dff5820e165e910f95120a708e742496221e600; // add x^(27-1) * (34! * 27^(27-1) / 27!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x00c8c8f66db1fced378ee50e536000000000000000; // add x^(28-1) * (34! * 28^(28-1) / 28!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0205db8dffff45bfa2938f128f599dbf16eb11d880; // add x^(29-1) * (34! * 29^(29-1) / 29!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x053a044ebd984351493e1786af38d39a0800000000; // add x^(30-1) * (34! * 30^(30-1) / 30!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0d86dae2a4cc0f47633a544479735869b487b59c40; // add x^(31-1) * (34! * 31^(31-1) / 31!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x231000000000000000000000000000000000000000; // add x^(32-1) * (34! * 32^(32-1) / 32!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x5b0485a76f6646c2039db1507cdd51b08649680822; // add x^(33-1) * (34! * 33^(33-1) / 33!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0xec983c46c49545bc17efa6b5b0055e242200000000; // add x^(34-1) * (34! * 34^(34-1) / 34!)\\n\\n\\t\\treturn res / 0xde1bc4d19efcac82445da75b00000000 + _x + FIXED_1; // divide by 34! and then add x^(2-1) * (34! * 2^(2-1) / 2!) + x^(1-1) * (34! * 1^(1-1) / 1!)\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes the weights based on \\\"W(log(hi / lo) * tq / rp) * tq / rp\\\", where \\\"W\\\" is a variation of the Lambert W function.\\n\\t */\\n\\tfunction balancedWeightsByStake(\\n\\t\\tuint256 _hi,\\n\\t\\tuint256 _lo,\\n\\t\\tuint256 _tq,\\n\\t\\tuint256 _rp,\\n\\t\\tbool _lowerStake\\n\\t) internal view returns (uint32, uint32) {\\n\\t\\t(_tq, _rp) = safeFactors(_tq, _rp);\\n\\t\\tuint256 f = _hi.mul(FIXED_1) / _lo;\\n\\t\\tuint256 g = f < OPT_LOG_MAX_VAL ? optimalLog(f) : generalLog(f);\\n\\t\\tuint256 x = g.mul(_tq) / _rp;\\n\\t\\tuint256 y = _lowerStake ? lowerStake(x) : higherStake(x);\\n\\t\\treturn normalizedWeights(y.mul(_tq), _rp.mul(FIXED_1));\\n\\t}\\n\\n\\t/**\\n\\t * @dev reduces \\\"a\\\" and \\\"b\\\" while maintaining their ratio.\\n\\t */\\n\\tfunction safeFactors(uint256 _a, uint256 _b)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (uint256, uint256)\\n\\t{\\n\\t\\tif (_a <= FIXED_2 && _b <= FIXED_2) return (_a, _b);\\n\\t\\tif (_a < FIXED_2) return ((_a * FIXED_2) / _b, FIXED_2);\\n\\t\\tif (_b < FIXED_2) return (FIXED_2, (_b * FIXED_2) / _a);\\n\\t\\tuint256 c = _a > _b ? _a : _b;\\n\\t\\tuint256 n = floorLog2(c / FIXED_1);\\n\\t\\treturn (_a >> n, _b >> n);\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes \\\"MAX_WEIGHT * a / (a + b)\\\" and \\\"MAX_WEIGHT * b / (a + b)\\\".\\n\\t */\\n\\tfunction normalizedWeights(uint256 _a, uint256 _b)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (uint32, uint32)\\n\\t{\\n\\t\\tif (_a <= _b) return accurateWeights(_a, _b);\\n\\t\\t(uint32 y, uint32 x) = accurateWeights(_b, _a);\\n\\t\\treturn (x, y);\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes \\\"MAX_WEIGHT * a / (a + b)\\\" and \\\"MAX_WEIGHT * b / (a + b)\\\", assuming that \\\"a <= b\\\".\\n\\t */\\n\\tfunction accurateWeights(uint256 _a, uint256 _b)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (uint32, uint32)\\n\\t{\\n\\t\\tif (_a > MAX_UNF_WEIGHT) {\\n\\t\\t\\tuint256 c = _a / (MAX_UNF_WEIGHT + 1) + 1;\\n\\t\\t\\t_a /= c;\\n\\t\\t\\t_b /= c;\\n\\t\\t}\\n\\t\\tuint256 x = roundDiv(_a * MAX_WEIGHT, _a.add(_b));\\n\\t\\tuint256 y = MAX_WEIGHT - x;\\n\\t\\treturn (uint32(x), uint32(y));\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes the nearest integer to a given quotient without overflowing or underflowing.\\n\\t */\\n\\tfunction roundDiv(uint256 _n, uint256 _d) internal pure returns (uint256) {\\n\\t\\treturn _n / _d + (_n % _d) / (_d - _d / 2);\\n\\t}\\n\\n\\t/**\\n\\t * @dev deprecated, backward compatibility\\n\\t */\\n\\tfunction calculatePurchaseReturn(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _reserveBalance,\\n\\t\\tuint32 _reserveWeight,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\treturn\\n\\t\\t\\tpurchaseTargetAmount(\\n\\t\\t\\t\\t_supply,\\n\\t\\t\\t\\t_reserveBalance,\\n\\t\\t\\t\\t_reserveWeight,\\n\\t\\t\\t\\t_amount\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev deprecated, backward compatibility\\n\\t */\\n\\tfunction calculateSaleReturn(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _reserveBalance,\\n\\t\\tuint32 _reserveWeight,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\treturn\\n\\t\\t\\tsaleTargetAmount(_supply, _reserveBalance, _reserveWeight, _amount);\\n\\t}\\n\\n\\t/**\\n\\t * @dev deprecated, backward compatibility\\n\\t */\\n\\tfunction calculateCrossReserveReturn(\\n\\t\\tuint256 _sourceReserveBalance,\\n\\t\\tuint32 _sourceReserveWeight,\\n\\t\\tuint256 _targetReserveBalance,\\n\\t\\tuint32 _targetReserveWeight,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\treturn\\n\\t\\t\\tcrossReserveTargetAmount(\\n\\t\\t\\t\\t_sourceReserveBalance,\\n\\t\\t\\t\\t_sourceReserveWeight,\\n\\t\\t\\t\\t_targetReserveBalance,\\n\\t\\t\\t\\t_targetReserveWeight,\\n\\t\\t\\t\\t_amount\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev deprecated, backward compatibility\\n\\t */\\n\\tfunction calculateCrossConnectorReturn(\\n\\t\\tuint256 _sourceReserveBalance,\\n\\t\\tuint32 _sourceReserveWeight,\\n\\t\\tuint256 _targetReserveBalance,\\n\\t\\tuint32 _targetReserveWeight,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\treturn\\n\\t\\t\\tcrossReserveTargetAmount(\\n\\t\\t\\t\\t_sourceReserveBalance,\\n\\t\\t\\t\\t_sourceReserveWeight,\\n\\t\\t\\t\\t_targetReserveBalance,\\n\\t\\t\\t\\t_targetReserveWeight,\\n\\t\\t\\t\\t_amount\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev deprecated, backward compatibility\\n\\t */\\n\\tfunction calculateFundCost(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _reserveBalance,\\n\\t\\tuint32 _reserveRatio,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\treturn fundCost(_supply, _reserveBalance, _reserveRatio, _amount);\\n\\t}\\n\\n\\t/**\\n\\t * @dev deprecated, backward compatibility\\n\\t */\\n\\tfunction calculateLiquidateReturn(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _reserveBalance,\\n\\t\\tuint32 _reserveRatio,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\treturn\\n\\t\\t\\tliquidateReserveAmount(\\n\\t\\t\\t\\t_supply,\\n\\t\\t\\t\\t_reserveBalance,\\n\\t\\t\\t\\t_reserveRatio,\\n\\t\\t\\t\\t_amount\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev deprecated, backward compatibility\\n\\t */\\n\\tfunction purchaseRate(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _reserveBalance,\\n\\t\\tuint32 _reserveWeight,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\treturn\\n\\t\\t\\tpurchaseTargetAmount(\\n\\t\\t\\t\\t_supply,\\n\\t\\t\\t\\t_reserveBalance,\\n\\t\\t\\t\\t_reserveWeight,\\n\\t\\t\\t\\t_amount\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev deprecated, backward compatibility\\n\\t */\\n\\tfunction saleRate(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _reserveBalance,\\n\\t\\tuint32 _reserveWeight,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\treturn\\n\\t\\t\\tsaleTargetAmount(_supply, _reserveBalance, _reserveWeight, _amount);\\n\\t}\\n\\n\\t/**\\n\\t * @dev deprecated, backward compatibility\\n\\t */\\n\\tfunction crossReserveRate(\\n\\t\\tuint256 _sourceReserveBalance,\\n\\t\\tuint32 _sourceReserveWeight,\\n\\t\\tuint256 _targetReserveBalance,\\n\\t\\tuint32 _targetReserveWeight,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\treturn\\n\\t\\t\\tcrossReserveTargetAmount(\\n\\t\\t\\t\\t_sourceReserveBalance,\\n\\t\\t\\t\\t_sourceReserveWeight,\\n\\t\\t\\t\\t_targetReserveBalance,\\n\\t\\t\\t\\t_targetReserveWeight,\\n\\t\\t\\t\\t_amount\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev deprecated, backward compatibility\\n\\t */\\n\\tfunction liquidateRate(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _reserveBalance,\\n\\t\\tuint32 _reserveRatio,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\treturn\\n\\t\\t\\tliquidateReserveAmount(\\n\\t\\t\\t\\t_supply,\\n\\t\\t\\t\\t_reserveBalance,\\n\\t\\t\\t\\t_reserveRatio,\\n\\t\\t\\t\\t_amount\\n\\t\\t\\t);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"/contracts/reserve/GoodReserveCDai.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\n\\nimport \\\"../utils/DAOUpgradeableContract.sol\\\";\\nimport \\\"../utils/NameService.sol\\\";\\nimport \\\"../DAOStackInterfaces.sol\\\";\\nimport \\\"../Interfaces.sol\\\";\\nimport \\\"./GoodMarketMaker.sol\\\";\\nimport \\\"./DistributionHelper.sol\\\";\\n\\n// import \\\"hardhat/console.sol\\\";\\n\\ninterface ContributionCalc {\\n\\tfunction calculateContribution(\\n\\t\\tGoodMarketMaker _marketMaker,\\n\\t\\tGoodReserveCDai _reserve,\\n\\t\\taddress _contributer,\\n\\t\\tERC20 _token,\\n\\t\\tuint256 _gdAmount\\n\\t) external view returns (uint256);\\n\\n\\tfunction setContributionRatio(uint256 _nom, uint256 _denom) external;\\n}\\n\\n/**\\n@title Reserve based on cDAI and dynamic reserve ratio market maker\\n*/\\ncontract GoodReserveCDai is\\n\\tDAOUpgradeableContract,\\n\\tERC20PresetMinterPauserUpgradeable,\\n\\tGlobalConstraintInterface\\n{\\n\\tbytes32 public constant RESERVE_MINTER_ROLE =\\n\\t\\tkeccak256(\\\"RESERVE_MINTER_ROLE\\\");\\n\\n\\t/// @dev G$ minting cap;\\n\\tuint256 public cap;\\n\\n\\t// The last block number which\\n\\t// `mintUBI` has been executed in\\n\\tuint256 public lastMinted;\\n\\n\\taddress public daiAddress;\\n\\taddress public cDaiAddress;\\n\\n\\t/// @dev merkleroot for GDX airdrop\\n\\tbytes32 public gdxAirdrop;\\n\\n\\t/// @dev mark if user claimed his GDX\\n\\tmapping(address => bool) public isClaimedGDX;\\n\\n\\tuint32 private unused_nonUbiBps; //keep for storage structure upgrades. //how much of expansion G$ to allocate for non Ubi causes\\n\\tDistributionHelper public distributionHelper; //in charge of distributing non UBI to different recipients\\n\\n\\tbool public gdxDisabled;\\n\\tbool public discountDisabled;\\n\\t// Emits when new GD tokens minted\\n\\tevent UBIMinted(\\n\\t\\t//epoch of UBI\\n\\t\\tuint256 indexed day,\\n\\t\\t//the token paid as interest\\n\\t\\taddress indexed interestToken,\\n\\t\\t//wei amount of interest paid in interestToken\\n\\t\\tuint256 interestReceived,\\n\\t\\t// Amount of GD tokens that was\\n\\t\\t// added to the supply as a result\\n\\t\\t// of `mintInterest`\\n\\t\\tuint256 gdInterestMinted,\\n\\t\\t// Amount of GD tokens that was\\n\\t\\t// added to the supply as a result\\n\\t\\t// of `mintExpansion`\\n\\t\\tuint256 gdExpansionMinted,\\n\\t\\t// Amount of GD tokens that was\\n\\t\\t// minted to the `ubiCollector`\\n\\t\\tuint256 gdUbiTransferred\\n\\t);\\n\\n\\t// Emits when GD tokens are purchased\\n\\tevent TokenPurchased(\\n\\t\\t// The initiate of the action\\n\\t\\taddress indexed caller,\\n\\t\\t// The convertible token address\\n\\t\\t// which the GD tokens were\\n\\t\\t// purchased with\\n\\t\\taddress indexed inputToken,\\n\\t\\t// Reserve tokens amount\\n\\t\\tuint256 inputAmount,\\n\\t\\t// Actual return after the\\n\\t\\t// conversion\\n\\t\\tuint256 actualReturn,\\n\\t\\t// Address of the receiver of tokens\\n\\t\\taddress indexed receiverAddress\\n\\t);\\n\\t// Emits when GD tokens are sold\\n\\tevent TokenSold(\\n\\t\\t// The initiate of the action\\n\\t\\taddress indexed caller,\\n\\t\\t// The convertible token address\\n\\t\\t// which the GD tokens were\\n\\t\\t// sold to\\n\\t\\taddress indexed outputToken,\\n\\t\\t// GD tokens amount\\n\\t\\tuint256 gdAmount,\\n\\t\\t// The amount of GD tokens that\\n\\t\\t// was contributed during the\\n\\t\\t// conversion\\n\\t\\tuint256 contributionAmount,\\n\\t\\t// Actual return after the\\n\\t\\t// conversion\\n\\t\\tuint256 actualReturn,\\n\\t\\t// Address of the receiver of tokens\\n\\t\\taddress indexed receiverAddress\\n\\t);\\n\\n\\tevent NonUBIMinted(\\n\\t\\taddress distributionHelper,\\n\\t\\tuint256 amountMinted,\\n\\t\\tbool distributionSucceeded\\n\\t);\\n\\n\\tevent DistributionHelperSet(address distributionHelper, uint32 bps);\\n\\n\\tfunction initialize(\\n\\t\\tINameService _ns,\\n\\t\\tbytes32 _gdxAirdrop\\n\\t) public virtual initializer {\\n\\t\\t__ERC20PresetMinterPauser_init(\\\"GDX\\\", \\\"G$X\\\");\\n\\t\\tsetDAO(_ns);\\n\\n\\t\\t//fixed cdai/dai\\n\\t\\tsetAddresses();\\n\\n\\t\\t//gdx roles\\n\\t\\trenounceRole(MINTER_ROLE, _msgSender());\\n\\t\\trenounceRole(PAUSER_ROLE, _msgSender());\\n\\t\\trenounceRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n\\t\\t_setupRole(DEFAULT_ADMIN_ROLE, address(avatar));\\n\\n\\t\\t//mint access through reserve\\n\\t\\t_setupRole(RESERVE_MINTER_ROLE, address(avatar)); //only Avatar can manage minters\\n\\n\\t\\tcap = 22 * 1e14; //22 trillion G$ cents\\n\\n\\t\\tgdxAirdrop = _gdxAirdrop;\\n\\t}\\n\\n\\t/// @dev GDX decimals\\n\\tfunction decimals() public pure override returns (uint8) {\\n\\t\\treturn 2;\\n\\t}\\n\\n\\tfunction setAddresses() public {\\n\\t\\tdaiAddress = nameService.getAddress(\\\"DAI\\\");\\n\\t\\tcDaiAddress = nameService.getAddress(\\\"CDAI\\\");\\n\\t\\t// Approve transfer to cDAI contract\\n\\t\\tERC20(daiAddress).approve(cDaiAddress, type(uint256).max);\\n\\t}\\n\\n\\t/**\\n\\t * @dev get current MarketMaker from name service\\n\\t * The address of the market maker contract\\n\\t * which makes the calculations and holds\\n\\t * the token and accounts info (should be owned by the reserve)\\n\\t */\\n\\tfunction getMarketMaker() public view returns (GoodMarketMaker) {\\n\\t\\treturn GoodMarketMaker(nameService.getAddress(\\\"MARKET_MAKER\\\"));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Converts cDai tokens to GD tokens and updates the bonding curve params.\\n\\t * `buy` occurs only if the GD return is above the given minimum. It is possible\\n\\t * to buy only with cDAI and when the contract is set to active. MUST call to\\n\\t * cDAI `approve` prior this action to allow this contract to accomplish the\\n\\t * conversion. Will not work when paused (enforced via _mintGoodDollars)\\n\\t * @param _tokenAmount The amount of cDAI tokens that should be converted to GD tokens\\n\\t * @param _minReturn The minimum allowed return in GD tokens\\n\\t * @param _targetAddress address of g$ and gdx recipient if different than msg.sender\\n\\t * @return (gdReturn) How much GD tokens were transferred\\n\\t */\\n\\tfunction buy(\\n\\t\\tuint256 _tokenAmount,\\n\\t\\tuint256 _minReturn,\\n\\t\\taddress _targetAddress\\n\\t) external returns (uint256) {\\n\\t\\tERC20 buyWith = ERC20(cDaiAddress);\\n\\t\\tuint256 gdReturn = getMarketMaker().buy(buyWith, _tokenAmount);\\n\\t\\t_targetAddress = _targetAddress == address(0x0)\\n\\t\\t\\t? msg.sender\\n\\t\\t\\t: _targetAddress;\\n\\t\\taddress exchangeHelper = nameService.getAddress(\\\"EXCHANGE_HELPER\\\");\\n\\t\\tif (msg.sender != exchangeHelper)\\n\\t\\t\\trequire(\\n\\t\\t\\t\\tbuyWith.transferFrom(msg.sender, address(this), _tokenAmount) == true,\\n\\t\\t\\t\\t\\\"transferFrom failed, make sure you approved input token transfer\\\"\\n\\t\\t\\t);\\n\\t\\trequire(gdReturn >= _minReturn, \\\"GD return must be above the minReturn\\\");\\n\\t\\t_mintGoodDollars(_targetAddress, gdReturn, true);\\n\\t\\t//mint GDX\\n\\t\\t_mintGDX(_targetAddress, gdReturn);\\n\\n\\t\\temit TokenPurchased(\\n\\t\\t\\tmsg.sender != exchangeHelper ? msg.sender : tx.origin,\\n\\t\\t\\tcDaiAddress,\\n\\t\\t\\t_tokenAmount,\\n\\t\\t\\tgdReturn,\\n\\t\\t\\t_targetAddress\\n\\t\\t);\\n\\t\\treturn gdReturn;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Mint rewards for staking contracts in G$ and update RR\\n\\t * requires minting permissions which is enforced by _mintGoodDollars.\\n\\t * Will not work when paused\\n\\t * @param _to Receipent address for rewards\\n\\t * @param _amount G$ amount to mint for rewards\\n\\t */\\n\\tfunction mintRewardFromRR(\\n\\t\\taddress _token,\\n\\t\\taddress _to,\\n\\t\\tuint256 _amount\\n\\t) external {\\n\\t\\tgetMarketMaker().mintFromReserveRatio(ERC20(_token), _amount);\\n\\t\\t_mintGoodDollars(_to, _amount, false);\\n\\t\\t//mint GDX\\n\\t\\t_mintGDX(_to, _amount);\\n\\t}\\n\\n\\t/**\\n\\t * @dev sell helper function burns GD tokens and update the bonding curve params.\\n\\t * `sell` occurs only if the token return is above the given minimum. Notice that\\n\\t * there is a contribution amount from the given GD that remains in the reserve.\\n\\t * Will not work when paused.\\n\\t * @param _gdAmount The amount of GD tokens that should be converted to cDAI tokens\\n\\t * @param _minReturn The minimum allowed `sellTo` tokens return\\n\\t * @param _target address of the receiver of cDAI when sell G$\\n\\t * @param _seller address of the seller when using helper contract\\n\\t * @return (tokenReturn, contribution) (cDAI received, G$ exit contribution)\\n\\t */\\n\\tfunction sell(\\n\\t\\tuint256 _gdAmount,\\n\\t\\tuint256 _minReturn,\\n\\t\\taddress _target,\\n\\t\\taddress _seller\\n\\t) external returns (uint256, uint256) {\\n\\t\\trequire(paused() == false, \\\"paused\\\");\\n\\t\\tGoodMarketMaker mm = getMarketMaker();\\n\\t\\tif (msg.sender != nameService.getAddress(\\\"EXCHANGE_HELPER\\\")) {\\n\\t\\t\\tIGoodDollar(nameService.getAddress(\\\"GOODDOLLAR\\\")).burnFrom(\\n\\t\\t\\t\\tmsg.sender,\\n\\t\\t\\t\\t_gdAmount\\n\\t\\t\\t);\\n\\t\\t\\t_seller = msg.sender;\\n\\t\\t}\\n\\t\\t_target = _target == address(0x0) ? msg.sender : _target;\\n\\t\\t//discount on exit contribution based on gdx\\n\\n\\t\\tuint256 discount;\\n\\t\\tif (discountDisabled == false) {\\n\\t\\t\\tuint256 gdx = balanceOf(_seller);\\n\\t\\t\\tdiscount = gdx <= _gdAmount ? gdx : _gdAmount;\\n\\n\\t\\t\\t//burn gdx used for discount\\n\\t\\t\\tif (discount > 0) _burn(_seller, discount);\\n\\t\\t}\\n\\n\\t\\tuint256 contributionAmount = 0;\\n\\t\\tuint256 gdAmountTemp = _gdAmount; // to prevent stack too deep errors\\n\\t\\tif (discount < gdAmountTemp)\\n\\t\\t\\tcontributionAmount = ContributionCalc(\\n\\t\\t\\t\\tnameService.getAddress(\\\"CONTRIBUTION_CALCULATION\\\")\\n\\t\\t\\t).calculateContribution(\\n\\t\\t\\t\\t\\tmm,\\n\\t\\t\\t\\t\\tthis,\\n\\t\\t\\t\\t\\t_seller,\\n\\t\\t\\t\\t\\tERC20(cDaiAddress),\\n\\t\\t\\t\\t\\tgdAmountTemp - discount\\n\\t\\t\\t\\t);\\n\\n\\t\\tuint256 tokenReturn = mm.sellWithContribution(\\n\\t\\t\\tERC20(cDaiAddress),\\n\\t\\t\\tgdAmountTemp,\\n\\t\\t\\tcontributionAmount\\n\\t\\t);\\n\\t\\trequire(\\n\\t\\t\\ttokenReturn >= _minReturn,\\n\\t\\t\\t\\\"Token return must be above the minReturn\\\"\\n\\t\\t);\\n\\t\\trequire(\\n\\t\\t\\tcERC20(cDaiAddress).transfer(_target, tokenReturn),\\n\\t\\t\\t\\\"cdai transfer failed\\\"\\n\\t\\t);\\n\\n\\t\\temit TokenSold(\\n\\t\\t\\t_seller,\\n\\t\\t\\tcDaiAddress,\\n\\t\\t\\t_gdAmount,\\n\\t\\t\\tcontributionAmount,\\n\\t\\t\\ttokenReturn,\\n\\t\\t\\t_target\\n\\t\\t);\\n\\n\\t\\treturn (tokenReturn, contributionAmount);\\n\\t}\\n\\n\\tfunction currentPrice() public view returns (uint256) {\\n\\t\\treturn getMarketMaker().currentPrice(ERC20(cDaiAddress));\\n\\t}\\n\\n\\tfunction currentPriceDAI() external view returns (uint256) {\\n\\t\\tcERC20 cDai = cERC20(cDaiAddress);\\n\\n\\t\\treturn (((currentPrice() * 1e10) * cDai.exchangeRateStored()) / 1e28); // based on https://compound.finance/docs#protocol-math\\n\\t}\\n\\n\\t/**\\n\\t * @dev helper to mint G$s\\n\\t * @param _to the recipient of newly minted G$s\\n\\t * @param _gdToMint how much G$ to mint\\n\\t * @param _internalCall skip minting role validation for internal calls, used when \\\"buying G$\\\" to \\\"allow\\\" buyer to mint G$ in exchange for his cDAI\\n\\t */\\n\\tfunction _mintGoodDollars(\\n\\t\\taddress _to,\\n\\t\\tuint256 _gdToMint,\\n\\t\\tbool _internalCall\\n\\t) internal {\\n\\t\\trequire(paused() == false, \\\"paused\\\");\\n\\n\\t\\t//enforce minting rules\\n\\t\\trequire(\\n\\t\\t\\t_internalCall ||\\n\\t\\t\\t\\t_msgSender() == nameService.getAddress(\\\"FUND_MANAGER\\\") ||\\n\\t\\t\\t\\thasRole(RESERVE_MINTER_ROLE, _msgSender()),\\n\\t\\t\\t\\\"GoodReserve: not a minter\\\"\\n\\t\\t);\\n\\n\\t\\trequire(\\n\\t\\t\\tIGoodDollar(nameService.getAddress(\\\"GOODDOLLAR\\\")).totalSupply() +\\n\\t\\t\\t\\t_gdToMint <=\\n\\t\\t\\t\\tcap,\\n\\t\\t\\t\\\"GoodReserve: cap enforced\\\"\\n\\t\\t);\\n\\n\\t\\tIGoodDollar(nameService.getAddress(\\\"GOODDOLLAR\\\")).mint(_to, _gdToMint);\\n\\t}\\n\\n\\t/// @dev helper to mint GDX to make _mint more verbose\\n\\tfunction _mintGDX(address _to, uint256 _gdx) internal {\\n\\t\\tif (gdxDisabled == false) _mint(_to, _gdx);\\n\\t}\\n\\n\\t/**\\n\\t * @dev only FundManager or other with mint G$ permission can call this to trigger minting.\\n\\t * Reserve sends UBI + interest to FundManager.\\n\\t * @param _daiToConvert DAI amount to convert cDAI\\n\\t * @param _startingCDAIBalance Initial cDAI balance before staking collect process start\\n\\t * @param _interestToken The token that was transfered to the reserve\\n\\t * @return gdUBI,interestInCdai how much GD UBI was minted and how much cDAI collected from staking contracts\\n\\t */\\n\\tfunction mintUBI(\\n\\t\\tuint256 _daiToConvert,\\n\\t\\tuint256 _startingCDAIBalance,\\n\\t\\tERC20 _interestToken\\n\\t) external returns (uint256, uint256) {\\n\\t\\tcERC20(cDaiAddress).mint(_daiToConvert);\\n\\t\\tuint256 interestInCdai = _interestToken.balanceOf(address(this)) -\\n\\t\\t\\t_startingCDAIBalance;\\n\\t\\tuint256 gdInterestToMint = getMarketMaker().mintInterest(\\n\\t\\t\\t_interestToken,\\n\\t\\t\\tinterestInCdai\\n\\t\\t);\\n\\t\\tuint256 gdExpansionToMint = getMarketMaker().mintExpansion(_interestToken);\\n\\n\\t\\tlastMinted = block.number;\\n\\t\\tuint256 gdUBI = gdInterestToMint + gdExpansionToMint;\\n\\n\\t\\trequire(address(distributionHelper) != address(0), \\\"helper not set\\\");\\n\\t\\t_mintGoodDollars(address(distributionHelper), gdUBI, false); //mintGoodDollars enforces that only minter can call mintUBI\\n\\n\\t\\t// if bridging fails this will revert. this is expected behavior\\n\\t\\tdistributionHelper.onDistribution(gdUBI);\\n\\n\\t\\temit UBIMinted(\\n\\t\\t\\tlastMinted,\\n\\t\\t\\taddress(_interestToken),\\n\\t\\t\\tinterestInCdai,\\n\\t\\t\\tgdInterestToMint,\\n\\t\\t\\tgdExpansionToMint,\\n\\t\\t\\tgdUBI\\n\\t\\t);\\n\\n\\t\\treturn (gdUBI, interestInCdai);\\n\\t}\\n\\n\\t/**\\n\\t * @notice allows Avatar to change or set the distribution helper\\n\\t * @param _helper address of distributionhelper contract\\n\\t */\\n\\tfunction setDistributionHelper(DistributionHelper _helper) external {\\n\\t\\t_onlyAvatar();\\n\\t\\tdistributionHelper = _helper;\\n\\t\\temit DistributionHelperSet(address(_helper), 10000);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Allows the DAO to change the daily expansion rate\\n\\t * it is calculated by _nom/_denom with e27 precision. Emits\\n\\t * `ReserveRatioUpdated` event after the ratio has changed.\\n\\t * Only Avatar can call this method.\\n\\t * @param _nom The numerator to calculate the global `reserveRatioDailyExpansion` from\\n\\t * @param _denom The denominator to calculate the global `reserveRatioDailyExpansion` from\\n\\t */\\n\\tfunction setReserveRatioDailyExpansion(\\n\\t\\tuint256 _nom,\\n\\t\\tuint256 _denom\\n\\t) external {\\n\\t\\t_onlyAvatar();\\n\\t\\tgetMarketMaker().setReserveRatioDailyExpansion(_nom, _denom);\\n\\t}\\n\\n\\t//\\n\\t/**\\n\\t * @dev Sets the GDX and discount disabled flags.\\n\\t * @param _gdxDisabled Whether GDX minting is disabled or not.\\n\\t * @param _discountDisabled Whether the discount for existing GDX holders is disabled or not.\\n\\t */\\n\\tfunction setGDXDisabled(bool _gdxDisabled, bool _discountDisabled) external {\\n\\t\\t_onlyAvatar();\\n\\t\\tgdxDisabled = _gdxDisabled;\\n\\t\\tdiscountDisabled = _discountDisabled;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Remove minting rights after it has transferred the cDAI funds to `_avatar`\\n\\t * Only the Avatar can execute this method\\n\\t */\\n\\tfunction end() external {\\n\\t\\t_onlyAvatar();\\n\\t\\t// remaining cDAI tokens in the current reserve contract\\n\\t\\tif (ERC20(cDaiAddress).balanceOf(address(this)) > 0) {\\n\\t\\t\\trequire(\\n\\t\\t\\t\\tERC20(cDaiAddress).transfer(\\n\\t\\t\\t\\t\\taddress(avatar),\\n\\t\\t\\t\\t\\tERC20(cDaiAddress).balanceOf(address(this))\\n\\t\\t\\t\\t),\\n\\t\\t\\t\\t\\\"recover transfer failed\\\"\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\t//restore minting to avatar, so he can re-delegate it\\n\\t\\tIGoodDollar gd = IGoodDollar(nameService.getAddress(\\\"GOODDOLLAR\\\"));\\n\\t\\tif (gd.isMinter(address(avatar)) == false) gd.addMinter(address(avatar));\\n\\n\\t\\tIGoodDollar(nameService.getAddress(\\\"GOODDOLLAR\\\")).renounceMinter();\\n\\t}\\n\\n\\t/**\\n\\t * @dev method to recover any stuck erc20 tokens (ie compound COMP)\\n\\t * @param _token the ERC20 token to recover\\n\\t */\\n\\tfunction recover(ERC20 _token) external {\\n\\t\\t_onlyAvatar();\\n\\t\\trequire(\\n\\t\\t\\t_token.transfer(address(avatar), _token.balanceOf(address(this))),\\n\\t\\t\\t\\\"recover transfer failed\\\"\\n\\t\\t);\\n\\t}\\n\\n\\t//no longer required all gdx was distributed\\n\\t// /**\\n\\t//  * @notice prove user balance in a specific blockchain state hash\\n\\t//  * @dev \\\"rootState\\\" is a special state that can be supplied once, and actually mints reputation on the current blockchain\\n\\t//  * @param _user the user to prove his balance\\n\\t//  * @param _gdx the balance we are prooving\\n\\t//  * @param _proof array of byte32 with proof data (currently merkle tree path)\\n\\t//  * @return true if proof is valid\\n\\t//  */\\n\\n\\t// function claimGDX(\\n\\t// \\taddress _user,\\n\\t// \\tuint256 _gdx,\\n\\t// \\tbytes32[] memory _proof\\n\\t// ) public returns (bool) {\\n\\t// \\trequire(isClaimedGDX[_user] == false, \\\"already claimed gdx\\\");\\n\\t// \\tbytes32 leafHash = keccak256(abi.encode(_user, _gdx));\\n\\t// \\tbool isProofValid = MerkleProofUpgradeable.verify(\\n\\t// \\t\\t_proof,\\n\\t// \\t\\tgdxAirdrop,\\n\\t// \\t\\tleafHash\\n\\t// \\t);\\n\\n\\t// \\trequire(isProofValid, \\\"invalid merkle proof\\\");\\n\\n\\t// \\t_mintGDX(_user, _gdx);\\n\\n\\t// \\tisClaimedGDX[_user] = true;\\n\\t// \\treturn true;\\n\\t// }\\n\\n\\t// implement minting constraints through the GlobalConstraintInterface interface. prevent any minting not through reserve\\n\\tfunction pre(\\n\\t\\taddress _scheme,\\n\\t\\tbytes32 _hash,\\n\\t\\tbytes32 _method\\n\\t) public pure override returns (bool) {\\n\\t\\t_scheme;\\n\\t\\t_hash;\\n\\t\\t_method;\\n\\t\\tif (_method == \\\"mintTokens\\\") return false;\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction when() public pure override returns (CallPhase) {\\n\\t\\treturn CallPhase.Pre;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"/contracts/reserve/GoodMarketMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"../utils/DSMath.sol\\\";\\nimport \\\"../utils/BancorFormula.sol\\\";\\nimport \\\"../DAOStackInterfaces.sol\\\";\\nimport \\\"../Interfaces.sol\\\";\\nimport \\\"../utils/DAOUpgradeableContract.sol\\\";\\n\\n/**\\n@title Dynamic reserve ratio market maker\\n*/\\ncontract GoodMarketMaker is DAOUpgradeableContract, DSMath {\\n\\t// Entity that holds a reserve token\\n\\tstruct ReserveToken {\\n\\t\\t// Determines the reserve token balance\\n\\t\\t// that the reserve contract holds\\n\\t\\tuint256 reserveSupply;\\n\\t\\t// Determines the current ratio between\\n\\t\\t// the reserve token and the GD token\\n\\t\\tuint32 reserveRatio;\\n\\t\\t// How many GD tokens have been minted\\n\\t\\t// against that reserve token\\n\\t\\tuint256 gdSupply;\\n\\t\\t// Last time reserve ratio was expanded\\n\\t\\tuint256 lastExpansion;\\n\\t}\\n\\n\\t// The map which holds the reserve token entities\\n\\tmapping(address => ReserveToken) public reserveTokens;\\n\\n\\t// Emits when a change has occurred in a\\n\\t// reserve balance, i.e. buy / sell will\\n\\t// change the balance\\n\\tevent BalancesUpdated(\\n\\t\\t// The account who initiated the action\\n\\t\\taddress indexed caller,\\n\\t\\t// The address of the reserve token\\n\\t\\taddress indexed reserveToken,\\n\\t\\t// The incoming amount\\n\\t\\tuint256 amount,\\n\\t\\t// The return value\\n\\t\\tuint256 returnAmount,\\n\\t\\t// The updated total supply\\n\\t\\tuint256 totalSupply,\\n\\t\\t// The updated reserve balance\\n\\t\\tuint256 reserveBalance\\n\\t);\\n\\n\\t// Emits when the ratio changed. The caller should be the Avatar by definition\\n\\tevent ReserveRatioUpdated(address indexed caller, uint256 nom, uint256 denom);\\n\\n\\t// Defines the daily change in the reserve ratio in RAY precision.\\n\\t// In the current release, only global ratio expansion is supported.\\n\\t// That will be a part of each reserve token entity in the future.\\n\\tuint256 public reserveRatioDailyExpansion;\\n\\n\\t//goodDollar token decimals\\n\\tuint256 decimals;\\n\\n\\t/**\\n\\t * @dev Constructor\\n\\t * @param _nom The numerator to calculate the global `reserveRatioDailyExpansion` from\\n\\t * @param _denom The denominator to calculate the global `reserveRatioDailyExpansion` from\\n\\t */\\n\\tfunction initialize(\\n\\t\\tINameService _ns,\\n\\t\\tuint256 _nom,\\n\\t\\tuint256 _denom\\n\\t) public virtual initializer {\\n\\t\\treserveRatioDailyExpansion = (_nom * 1e27) / _denom;\\n\\t\\tdecimals = 2;\\n\\t\\tsetDAO(_ns);\\n\\t}\\n\\n\\tfunction _onlyActiveToken(ERC20 _token) internal view {\\n\\t\\tReserveToken storage rtoken = reserveTokens[address(_token)];\\n\\t\\trequire(rtoken.gdSupply > 0, \\\"Reserve token not initialized\\\");\\n\\t}\\n\\n\\tfunction _onlyReserveOrAvatar() internal view {\\n\\t\\trequire(\\n\\t\\t\\tnameService.getAddress(\\\"RESERVE\\\") == msg.sender ||\\n\\t\\t\\t\\tnameService.getAddress(\\\"AVATAR\\\") == msg.sender,\\n\\t\\t\\t\\\"GoodMarketMaker: not Reserve or Avatar\\\"\\n\\t\\t);\\n\\t}\\n\\n\\tfunction getBancor() public view returns (BancorFormula) {\\n\\t\\treturn BancorFormula(nameService.getAddress(\\\"BANCOR_FORMULA\\\"));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Allows the DAO to change the daily expansion rate\\n\\t * it is calculated by _nom/_denom with e27 precision. Emits\\n\\t * `ReserveRatioUpdated` event after the ratio has changed.\\n\\t * Only Avatar can call this method.\\n\\t * @param _nom The numerator to calculate the global `reserveRatioDailyExpansion` from\\n\\t * @param _denom The denominator to calculate the global `reserveRatioDailyExpansion` from\\n\\t */\\n\\tfunction setReserveRatioDailyExpansion(uint256 _nom, uint256 _denom) public {\\n\\t\\t_onlyReserveOrAvatar();\\n\\t\\trequire(_denom > 0, \\\"denominator must be above 0\\\");\\n\\t\\treserveRatioDailyExpansion = (_nom * 1e27) / _denom;\\n\\t\\trequire(reserveRatioDailyExpansion < 1e27, \\\"Invalid nom or denom value\\\");\\n\\t\\temit ReserveRatioUpdated(msg.sender, _nom, _denom);\\n\\t}\\n\\n\\t// NOTICE: In the current release, if there is a wish to add another reserve token,\\n\\t//  `end` method in the reserve contract should be called first. Then, the DAO have\\n\\t//  to deploy a new reserve contract that will own the market maker. A scheme for\\n\\t// updating the new reserve must be deployed too.\\n\\n\\t/**\\n\\t * @dev Initialize a reserve token entity with the given parameters\\n\\t * @param _token The reserve token\\n\\t * @param _gdSupply Initial supply of GD to set the price\\n\\t * @param _tokenSupply Initial supply of reserve token to set the price\\n\\t * @param _reserveRatio The starting reserve ratio\\n\\t * @param _lastExpansion Last time reserve ratio was expanded\\n\\t */\\n\\tfunction initializeToken(\\n\\t\\tERC20 _token,\\n\\t\\tuint256 _gdSupply,\\n\\t\\tuint256 _tokenSupply,\\n\\t\\tuint32 _reserveRatio,\\n\\t\\tuint256 _lastExpansion\\n\\t) public {\\n\\t\\t_onlyReserveOrAvatar();\\n\\t\\treserveTokens[address(_token)] = ReserveToken({\\n\\t\\t\\tgdSupply: _gdSupply,\\n\\t\\t\\treserveSupply: _tokenSupply,\\n\\t\\t\\treserveRatio: _reserveRatio,\\n\\t\\t\\tlastExpansion: _lastExpansion == 0 ? block.timestamp : _lastExpansion\\n\\t\\t});\\n\\t}\\n\\n\\t/**\\n\\t * @dev Calculates how much to decrease the reserve ratio for _token by\\n\\t * the `reserveRatioDailyExpansion`\\n\\t * @param _token The reserve token to calculate the reserve ratio for\\n\\t * @return The new reserve ratio\\n\\t */\\n\\tfunction calculateNewReserveRatio(ERC20 _token) public view returns (uint32) {\\n\\t\\tReserveToken memory reserveToken = reserveTokens[address(_token)];\\n\\t\\tuint256 ratio = uint256(reserveToken.reserveRatio);\\n\\t\\tif (ratio == 0) {\\n\\t\\t\\tratio = 1e6;\\n\\t\\t}\\n\\t\\tratio *= 1e21; //expand to e27 precision\\n\\n\\t\\tuint256 daysPassed = (block.timestamp - reserveToken.lastExpansion) /\\n\\t\\t\\t1 days;\\n\\t\\tfor (uint256 i = 0; i < daysPassed; i++) {\\n\\t\\t\\tratio = (ratio * reserveRatioDailyExpansion) / 1e27;\\n\\t\\t}\\n\\n\\t\\treturn uint32(ratio / 1e21); // return to e6 precision\\n\\t}\\n\\n\\t/**\\n\\t * @dev Decreases the reserve ratio for _token by the `reserveRatioDailyExpansion`\\n\\t * @param _token The token to change the reserve ratio for\\n\\t * @return The new reserve ratio\\n\\t */\\n\\tfunction expandReserveRatio(ERC20 _token) public returns (uint32) {\\n\\t\\t_onlyReserveOrAvatar();\\n\\t\\t_onlyActiveToken(_token);\\n\\t\\tReserveToken storage reserveToken = reserveTokens[address(_token)];\\n\\t\\tuint32 ratio = reserveToken.reserveRatio;\\n\\t\\tif (ratio == 0) {\\n\\t\\t\\tratio = 1e6;\\n\\t\\t}\\n\\t\\treserveToken.reserveRatio = calculateNewReserveRatio(_token);\\n\\n\\t\\t//set last expansion to begining of expansion day\\n\\t\\treserveToken.lastExpansion =\\n\\t\\t\\tblock.timestamp -\\n\\t\\t\\t((block.timestamp - reserveToken.lastExpansion) % 1 days);\\n\\t\\treturn reserveToken.reserveRatio;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Calculates the buy return in GD according to the given _tokenAmount\\n\\t * @param _token The reserve token buying with\\n\\t * @param _tokenAmount The amount of reserve token buying with\\n\\t * @return Number of GD that should be given in exchange as calculated by the bonding curve\\n\\t */\\n\\tfunction buyReturn(ERC20 _token, uint256 _tokenAmount)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\tReserveToken memory rtoken = reserveTokens[address(_token)];\\n\\t\\treturn\\n\\t\\t\\tgetBancor().calculatePurchaseReturn(\\n\\t\\t\\t\\trtoken.gdSupply,\\n\\t\\t\\t\\trtoken.reserveSupply,\\n\\t\\t\\t\\trtoken.reserveRatio,\\n\\t\\t\\t\\t_tokenAmount\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Calculates the sell return in _token according to the given _gdAmount\\n\\t * @param _token The desired reserve token to have\\n\\t * @param _gdAmount The amount of GD that are sold\\n\\t * @return Number of tokens that should be given in exchange as calculated by the bonding curve\\n\\t */\\n\\tfunction sellReturn(ERC20 _token, uint256 _gdAmount)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\tReserveToken memory rtoken = reserveTokens[address(_token)];\\n\\t\\treturn\\n\\t\\t\\tgetBancor().calculateSaleReturn(\\n\\t\\t\\t\\trtoken.gdSupply,\\n\\t\\t\\t\\trtoken.reserveSupply,\\n\\t\\t\\t\\trtoken.reserveRatio,\\n\\t\\t\\t\\t_gdAmount\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Updates the _token bonding curve params. Emits `BalancesUpdated` with the\\n\\t * new reserve token information.\\n\\t * @param _token The reserve token buying with\\n\\t * @param _tokenAmount The amount of reserve token buying with\\n\\t * @return (gdReturn) Number of GD that will be given in exchange as calculated by the bonding curve\\n\\t */\\n\\tfunction buy(ERC20 _token, uint256 _tokenAmount) public returns (uint256) {\\n\\t\\t_onlyReserveOrAvatar();\\n\\t\\t_onlyActiveToken(_token);\\n\\n\\t\\tuint256 gdReturn = buyReturn(_token, _tokenAmount);\\n\\t\\tReserveToken storage rtoken = reserveTokens[address(_token)];\\n\\t\\trtoken.gdSupply += gdReturn;\\n\\t\\trtoken.reserveSupply += _tokenAmount;\\n\\t\\temit BalancesUpdated(\\n\\t\\t\\tmsg.sender,\\n\\t\\t\\taddress(_token),\\n\\t\\t\\t_tokenAmount,\\n\\t\\t\\tgdReturn,\\n\\t\\t\\trtoken.gdSupply,\\n\\t\\t\\trtoken.reserveSupply\\n\\t\\t);\\n\\t\\treturn gdReturn;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Updates the bonding curve params. Decrease RR to in order to mint gd in the amount of provided\\n\\t * new RR = Reserve supply / ((gd supply + gd mint amount) * price)\\n\\t * @param _gdAmount Amount of gd to add reserveParams\\n\\t * @param _token The reserve token which is currently active\\n\\t */\\n\\tfunction mintFromReserveRatio(ERC20 _token, uint256 _gdAmount) public {\\n\\t\\t_onlyReserveOrAvatar();\\n\\t\\t_onlyActiveToken(_token);\\n\\t\\tuint256 reserveDecimalsDiff = uint256(27) - _token.decimals(); // //result is in RAY precision\\n\\t\\tReserveToken storage rtoken = reserveTokens[address(_token)];\\n\\t\\tuint256 priceBeforeGdSupplyChange = currentPrice(_token);\\n\\t\\trtoken.gdSupply += _gdAmount;\\n\\t\\trtoken.reserveRatio = uint32(\\n\\t\\t\\t((rtoken.reserveSupply * 1e27) /\\n\\t\\t\\t\\t(rtoken.gdSupply * priceBeforeGdSupplyChange)) / 10**reserveDecimalsDiff\\n\\t\\t); // Divide it decimal diff to bring it proper decimal\\n\\t}\\n\\n\\t/**\\n\\t * @dev Calculates the sell return with contribution in _token and update the bonding curve params.\\n\\t * Emits `BalancesUpdated` with the new reserve token information.\\n\\t * @param _token The desired reserve token to have\\n\\t * @param _gdAmount The amount of GD that are sold\\n\\t * @param _contributionGdAmount The number of GD tokens that will not be traded for the reserve token\\n\\t * @return Number of tokens that will be given in exchange as calculated by the bonding curve\\n\\t */\\n\\tfunction sellWithContribution(\\n\\t\\tERC20 _token,\\n\\t\\tuint256 _gdAmount,\\n\\t\\tuint256 _contributionGdAmount\\n\\t) public returns (uint256) {\\n\\t\\t_onlyReserveOrAvatar();\\n\\t\\t_onlyActiveToken(_token);\\n\\n\\t\\trequire(\\n\\t\\t\\t_gdAmount >= _contributionGdAmount,\\n\\t\\t\\t\\\"GD amount is lower than the contribution amount\\\"\\n\\t\\t);\\n\\t\\tReserveToken storage rtoken = reserveTokens[address(_token)];\\n\\t\\trequire(\\n\\t\\t\\trtoken.gdSupply >= _gdAmount,\\n\\t\\t\\t\\\"GD amount is higher than the total supply\\\"\\n\\t\\t);\\n\\n\\t\\t// Deduces the convertible amount of GD tokens by the given contribution amount\\n\\t\\tuint256 amountAfterContribution = _gdAmount - _contributionGdAmount;\\n\\n\\t\\t// The return value after the deduction\\n\\t\\tuint256 tokenReturn = sellReturn(_token, amountAfterContribution);\\n\\t\\trtoken.gdSupply -= _gdAmount;\\n\\t\\trtoken.reserveSupply -= tokenReturn;\\n\\t\\temit BalancesUpdated(\\n\\t\\t\\tmsg.sender,\\n\\t\\t\\taddress(_token),\\n\\t\\t\\t_contributionGdAmount,\\n\\t\\t\\ttokenReturn,\\n\\t\\t\\trtoken.gdSupply,\\n\\t\\t\\trtoken.reserveSupply\\n\\t\\t);\\n\\t\\treturn tokenReturn;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Current price of GD in `token`. currently only cDAI is supported.\\n\\t * @param _token The desired reserve token to have\\n\\t * @return price of GD\\n\\t */\\n\\tfunction currentPrice(ERC20 _token) public view returns (uint256) {\\n\\t\\tReserveToken memory rtoken = reserveTokens[address(_token)];\\n\\t\\treturn\\n\\t\\t\\tgetBancor().calculateSaleReturn(\\n\\t\\t\\t\\trtoken.gdSupply,\\n\\t\\t\\t\\trtoken.reserveSupply,\\n\\t\\t\\t\\trtoken.reserveRatio,\\n\\t\\t\\t\\t(10**decimals)\\n\\t\\t\\t);\\n\\t}\\n\\n\\t//TODO: need real calculation and tests\\n\\t/**\\n\\t * @dev Calculates how much G$ to mint based on added token supply (from interest)\\n\\t * and on current reserve ratio, in order to keep G$ price the same at the bonding curve\\n\\t * formula to calculate the gd to mint: gd to mint =\\n\\t * addreservebalance * (gdsupply / (reservebalance * reserveratio))\\n\\t * @param _token the reserve token\\n\\t * @param _addTokenSupply amount of token added to supply\\n\\t * @return how much to mint in order to keep price in bonding curve the same\\n\\t */\\n\\tfunction calculateMintInterest(ERC20 _token, uint256 _addTokenSupply)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\tuint256 decimalsDiff = uint256(27) - decimals;\\n\\t\\t//resulting amount is in RAY precision\\n\\t\\t//we divide by decimalsdiff to get precision in GD (2 decimals)\\n\\t\\treturn\\n\\t\\t\\t((_addTokenSupply * 1e27) / currentPrice(_token)) / (10**decimalsDiff);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Updates bonding curve based on _addTokenSupply and new minted amount\\n\\t * @param _token The reserve token\\n\\t * @param _addTokenSupply Amount of token added to supply\\n\\t * @return How much to mint in order to keep price in bonding curve the same\\n\\t */\\n\\tfunction mintInterest(ERC20 _token, uint256 _addTokenSupply)\\n\\t\\tpublic\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\t_onlyReserveOrAvatar();\\n\\t\\t_onlyActiveToken(_token);\\n\\t\\tif (_addTokenSupply == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tuint256 toMint = calculateMintInterest(_token, _addTokenSupply);\\n\\t\\tReserveToken storage reserveToken = reserveTokens[address(_token)];\\n\\t\\treserveToken.gdSupply += toMint;\\n\\t\\treserveToken.reserveSupply += _addTokenSupply;\\n\\n\\t\\treturn toMint;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Calculate how much G$ to mint based on expansion change (new reserve\\n\\t * ratio), in order to keep G$ price the same at the bonding curve. the\\n\\t * formula to calculate the gd to mint: gd to mint =\\n\\t * (reservebalance / (newreserveratio * currentprice)) - gdsupply\\n\\t * @param _token The reserve token\\n\\t * @return How much to mint in order to keep price in bonding curve the same\\n\\t */\\n\\tfunction calculateMintExpansion(ERC20 _token) public view returns (uint256) {\\n\\t\\tReserveToken memory reserveToken = reserveTokens[address(_token)];\\n\\t\\tuint32 newReserveRatio = calculateNewReserveRatio(_token); // new reserve ratio\\n\\t\\tuint256 reserveDecimalsDiff = uint256(27) - _token.decimals(); // //result is in RAY precision\\n\\t\\tuint256 denom = (uint256(newReserveRatio) *\\n\\t\\t\\t1e21 *\\n\\t\\t\\tcurrentPrice(_token) *\\n\\t\\t\\t(10**reserveDecimalsDiff)) / 1e27; // (newreserveratio * currentprice) in RAY precision\\n\\t\\tuint256 gdDecimalsDiff = uint256(27) - decimals;\\n\\t\\tuint256 toMint = ((reserveToken.reserveSupply *\\n\\t\\t\\t(10**reserveDecimalsDiff) *\\n\\t\\t\\t1e27) / denom) / (10**gdDecimalsDiff); // reservebalance in RAY precision // return to gd precision\\n\\t\\treturn toMint - reserveToken.gdSupply;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Updates bonding curve based on expansion change and new minted amount\\n\\t * @param _token The reserve token\\n\\t * @return How much to mint in order to keep price in bonding curve the same\\n\\t */\\n\\tfunction mintExpansion(ERC20 _token) public returns (uint256) {\\n\\t\\t_onlyReserveOrAvatar();\\n\\t\\t_onlyActiveToken(_token);\\n\\t\\tuint256 toMint = calculateMintExpansion(_token);\\n\\t\\treserveTokens[address(_token)].gdSupply += toMint;\\n\\t\\texpandReserveRatio(_token);\\n\\n\\t\\treturn toMint;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"/contracts/reserve/ExchangeHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\nimport \\\"../utils/DAOUpgradeableContract.sol\\\";\\nimport \\\"../utils/NameService.sol\\\";\\nimport \\\"./GoodReserveCDai.sol\\\";\\n\\ncontract ExchangeHelper is DAOUpgradeableContract {\\n\\tuint256 private _status;\\n\\n\\tfunction initialize(INameService _ns) public virtual initializer {\\n\\t\\tsetDAO(_ns);\\n\\t\\tsetAddresses();\\n\\t\\t_status = 1;\\n\\t}\\n\\n\\t// Emits when GD tokens are purchased\\n\\tevent TokenPurchased(\\n\\t\\t// The initiate of the action\\n\\t\\taddress indexed caller,\\n\\t\\t// The convertible token address\\n\\t\\t// which the GD tokens were\\n\\t\\t// purchased with\\n\\t\\taddress indexed inputToken,\\n\\t\\t// Reserve tokens amount\\n\\t\\tuint256 inputAmount,\\n\\t\\t// Actual return after the\\n\\t\\t// conversion\\n\\t\\tuint256 actualReturn,\\n\\t\\t// Address of the receiver of tokens\\n\\t\\taddress indexed receiverAddress\\n\\t);\\n\\t// Emits when GD tokens are sold\\n\\tevent TokenSold(\\n\\t\\t// The initiate of the action\\n\\t\\taddress indexed caller,\\n\\t\\t// The convertible token address\\n\\t\\t// which the GD tokens were\\n\\t\\t// sold to\\n\\t\\taddress indexed outputToken,\\n\\t\\t// GD tokens amount\\n\\t\\tuint256 gdAmount,\\n\\t\\t// The amount of GD tokens that\\n\\t\\t// was contributed during the\\n\\t\\t// conversion\\n\\t\\tuint256 contributionAmount,\\n\\t\\t// Actual return after the\\n\\t\\t// conversion\\n\\t\\tuint256 actualReturn,\\n\\t\\t// Address of the receiver of tokens\\n\\t\\taddress indexed receiverAddress\\n\\t);\\n\\taddress public daiAddress;\\n\\taddress public cDaiAddress;\\n\\t/**\\n\\t * @dev Prevents a contract from calling itself, directly or indirectly.\\n\\t * Calling a `nonReentrant` function from another `nonReentrant`\\n\\t * function is not supported. It is possible to prevent this from happening\\n\\t * by making the `nonReentrant` function external, and make it call a\\n\\t * `private` function that does the actual work.\\n\\t */\\n\\tmodifier nonReentrant() {\\n\\t\\t// On the first call to nonReentrant, _notEntered will be true\\n\\t\\trequire(_status != 2, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n\\t\\t// Any calls to nonReentrant after this point will fail\\n\\t\\t_status = 2;\\n\\n\\t\\t_;\\n\\n\\t\\t// By storing the original value once again, a refund is triggered (see\\n\\t\\t// https://eips.ethereum.org/EIPS/eip-2200)\\n\\t\\t_status = 1;\\n\\t}\\n\\n\\tfunction setAddresses() public {\\n\\t\\tdaiAddress = nameService.getAddress(\\\"DAI\\\");\\n\\t\\tcDaiAddress = nameService.getAddress(\\\"CDAI\\\");\\n\\t\\t// Approve transfer to cDAI contract\\n\\t\\tERC20(daiAddress).approve(cDaiAddress, type(uint256).max);\\n\\t\\tERC20(daiAddress).approve(\\n\\t\\t\\tnameService.getAddress(\\\"UNISWAP_ROUTER\\\"),\\n\\t\\t\\ttype(uint256).max\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t@dev Converts any 'buyWith' tokens to DAI then call reserve's buy function to convert it to GD tokens(no need reentrancy lock since we don't transfer external token's to user)\\n\\t* @param _buyPath The tokens swap path in order to buy G$ if initial token is not DAI or cDAI then end of the path must set to DAI\\n\\t* @param _tokenAmount The amount of `buyWith` tokens that should be converted to GD tokens\\n\\t* @param _minReturn The minimum allowed return in GD tokens\\n\\t* @param _minDAIAmount The mininmum dai out amount from Exchange swap function\\n\\t* @param _targetAddress address of g$ and gdx recipient if different than msg.sender\\n\\t* @return (gdReturn) How much GD tokens were transferred\\n\\t */\\n\\tfunction buy(\\n\\t\\taddress[] memory _buyPath,\\n\\t\\tuint256 _tokenAmount,\\n\\t\\tuint256 _minReturn,\\n\\t\\tuint256 _minDAIAmount,\\n\\t\\taddress _targetAddress\\n\\t) public payable nonReentrant returns (uint256) {\\n\\t\\trequire(_buyPath.length > 0, \\\"Provide valid path\\\");\\n\\t\\tGoodReserveCDai reserve = GoodReserveCDai(\\n\\t\\t\\tnameService.getAddress(\\\"RESERVE\\\")\\n\\t\\t);\\n\\t\\taddress receiver = _targetAddress == address(0x0)\\n\\t\\t\\t? msg.sender\\n\\t\\t\\t: _targetAddress;\\n\\n\\t\\tif (_buyPath[0] == address(0)) {\\n\\t\\t\\trequire(\\n\\t\\t\\t\\tmsg.value > 0 && _tokenAmount == msg.value,\\n\\t\\t\\t\\t\\\"you need to pay with ETH\\\"\\n\\t\\t\\t);\\n\\t\\t} else {\\n\\t\\t\\trequire(\\n\\t\\t\\t\\tmsg.value == 0,\\n\\t\\t\\t\\t\\\"When input token is different than ETH message value should be zero\\\"\\n\\t\\t\\t);\\n\\t\\t\\trequire(\\n\\t\\t\\t\\tERC20(_buyPath[0]).transferFrom(\\n\\t\\t\\t\\t\\tmsg.sender,\\n\\t\\t\\t\\t\\taddress(_buyPath[0]) == cDaiAddress\\n\\t\\t\\t\\t\\t\\t? address(reserve)\\n\\t\\t\\t\\t\\t\\t: address(this),\\n\\t\\t\\t\\t\\t_tokenAmount\\n\\t\\t\\t\\t) == true,\\n\\t\\t\\t\\t\\\"transferFrom failed, make sure you approved input token transfer\\\"\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\tuint256 result;\\n\\t\\tif (_buyPath[0] == cDaiAddress) {\\n\\t\\t\\tresult = reserve.buy(_tokenAmount, _minReturn, receiver);\\n\\t\\t} else if (_buyPath[0] == daiAddress) {\\n\\t\\t\\tresult = _cdaiMintAndBuy(_tokenAmount, _minReturn, receiver);\\n\\t\\t} else {\\n\\t\\t\\trequire(\\n\\t\\t\\t\\t_buyPath[_buyPath.length - 1] == daiAddress,\\n\\t\\t\\t\\t\\\"Target token in the path must be DAI\\\"\\n\\t\\t\\t);\\n\\t\\t\\tuint256[] memory swap = _uniswapSwap(\\n\\t\\t\\t\\t_buyPath,\\n\\t\\t\\t\\t_tokenAmount,\\n\\t\\t\\t\\t_minDAIAmount,\\n\\t\\t\\t\\t0,\\n\\t\\t\\t\\taddress(this)\\n\\t\\t\\t);\\n\\n\\t\\t\\tuint256 dai = swap[swap.length - 1];\\n\\t\\t\\trequire(dai > 0, \\\"token selling failed\\\");\\n\\n\\t\\t\\tresult = _cdaiMintAndBuy(dai, _minReturn, receiver);\\n\\t\\t}\\n\\n\\t\\temit TokenPurchased(\\n\\t\\t\\tmsg.sender,\\n\\t\\t\\t_buyPath[0],\\n\\t\\t\\t_tokenAmount,\\n\\t\\t\\tresult,\\n\\t\\t\\treceiver\\n\\t\\t);\\n\\n\\t\\treturn result;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Converts GD tokens to cDAI through reserve then make further transactions according to desired _sellTo token(either send cDAI or DAI directly or desired token through uniswap)\\n\\t * @param _sellPath The tokens swap path in order to sell G$ to target token if target token is not DAI or cDAI then first element of the path must be DAI\\n\\t * @param _gdAmount The amount of GD tokens that should be converted to `_sellTo` tokens\\n\\t * @param _minReturn The minimum allowed `sellTo` tokens return\\n\\t * @param _minTokenReturn The mininmum dai out amount from Exchange swap function\\n\\t * @param _targetAddress address of _sellTo token recipient if different than msg.sender\\n\\t * @return (tokenReturn) How much `sellTo` tokens were transferred\\n\\t */\\n\\tfunction sell(\\n\\t\\taddress[] memory _sellPath,\\n\\t\\tuint256 _gdAmount,\\n\\t\\tuint256 _minReturn,\\n\\t\\tuint256 _minTokenReturn,\\n\\t\\taddress _targetAddress\\n\\t) public nonReentrant returns (uint256) {\\n\\t\\trequire(_sellPath.length > 0, \\\"Provide valid path\\\");\\n\\t\\taddress receiver = _targetAddress == address(0x0)\\n\\t\\t\\t? msg.sender\\n\\t\\t\\t: _targetAddress;\\n\\n\\t\\tuint256 result;\\n\\t\\tuint256 contributionAmount;\\n\\t\\tGoodReserveCDai reserve = GoodReserveCDai(\\n\\t\\t\\tnameService.getAddress(\\\"RESERVE\\\")\\n\\t\\t);\\n\\t\\tIGoodDollar(nameService.getAddress(\\\"GOODDOLLAR\\\")).burnFrom(\\n\\t\\t\\tmsg.sender,\\n\\t\\t\\t_gdAmount\\n\\t\\t);\\n\\n\\t\\t(result, contributionAmount) = reserve.sell(\\n\\t\\t\\t_gdAmount,\\n\\t\\t\\t_minReturn,\\n\\t\\t\\t(_sellPath.length == 1 && _sellPath[0] == cDaiAddress)\\n\\t\\t\\t\\t? receiver\\n\\t\\t\\t\\t: address(this), // if the tokens that will received is cDai then return it directly to receiver\\n\\t\\t\\tmsg.sender\\n\\t\\t);\\n\\t\\tif (\\n\\t\\t\\t_sellPath.length == 1 &&\\n\\t\\t\\t(_sellPath[0] == daiAddress || _sellPath[0] == cDaiAddress)\\n\\t\\t) {\\n\\t\\t\\tif (_sellPath[0] == daiAddress) {\\n\\t\\t\\t\\tresult = _redeemDAI(result);\\n\\n\\t\\t\\t\\trequire(\\n\\t\\t\\t\\t\\tERC20(_sellPath[0]).transfer(receiver, result) == true,\\n\\t\\t\\t\\t\\t\\\"Transfer failed\\\"\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t} else if (_sellPath[0] != cDaiAddress) {\\n\\t\\t\\tresult = _redeemDAI(result);\\n\\t\\t\\trequire(\\n\\t\\t\\t\\t_sellPath[0] == daiAddress,\\n\\t\\t\\t\\t\\\"Input token for uniswap must be DAI\\\"\\n\\t\\t\\t);\\n\\t\\t\\tuint256[] memory swap = _uniswapSwap(\\n\\t\\t\\t\\t_sellPath,\\n\\t\\t\\t\\tresult,\\n\\t\\t\\t\\t0,\\n\\t\\t\\t\\t_minTokenReturn,\\n\\t\\t\\t\\treceiver\\n\\t\\t\\t);\\n\\n\\t\\t\\tresult = swap[swap.length - 1];\\n\\t\\t\\trequire(result > 0, \\\"token selling failed\\\");\\n\\t\\t} else {\\n\\t\\t\\trevert();\\n\\t\\t}\\n\\n\\t\\temit TokenSold(\\n\\t\\t\\tmsg.sender,\\n\\t\\t\\t_sellPath[_sellPath.length - 1],\\n\\t\\t\\t_gdAmount,\\n\\t\\t\\tcontributionAmount,\\n\\t\\t\\tresult,\\n\\t\\t\\treceiver\\n\\t\\t);\\n\\t\\treturn result;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Redeem cDAI to DAI\\n\\t * @param _amount Amount of cDAI to redeem for DAI\\n\\t * @return the amount of DAI received\\n\\t */\\n\\tfunction _redeemDAI(uint256 _amount) internal returns (uint256) {\\n\\t\\tcERC20 cDai = cERC20(cDaiAddress);\\n\\t\\tERC20 dai = ERC20(daiAddress);\\n\\n\\t\\tuint256 currDaiBalance = dai.balanceOf(address(this));\\n\\n\\t\\tuint256 daiResult = cDai.redeem(_amount);\\n\\t\\trequire(daiResult == 0, \\\"cDai redeem failed\\\");\\n\\n\\t\\tuint256 daiReturnAmount = dai.balanceOf(address(this)) - currDaiBalance;\\n\\n\\t\\treturn daiReturnAmount;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Convert Dai to CDAI and buy\\n\\t * @param _amount DAI amount to convert\\n\\t * @param _minReturn The minimum allowed return in GD tokens\\n\\t * @param _targetAddress address of g$ and gdx recipient if different than msg.sender\\n\\t * @return (gdReturn) How much GD tokens were transferred\\n\\t */\\n\\tfunction _cdaiMintAndBuy(\\n\\t\\tuint256 _amount,\\n\\t\\tuint256 _minReturn,\\n\\t\\taddress _targetAddress\\n\\t) internal returns (uint256) {\\n\\t\\tGoodReserveCDai reserve = GoodReserveCDai(\\n\\t\\t\\tnameService.getAddress(\\\"RESERVE\\\")\\n\\t\\t);\\n\\t\\tcERC20 cDai = cERC20(cDaiAddress);\\n\\n\\t\\tuint256 currCDaiBalance = cDai.balanceOf(address(this));\\n\\n\\t\\t//Mint cDAIs\\n\\t\\tuint256 cDaiResult = cDai.mint(_amount);\\n\\t\\trequire(cDaiResult == 0, \\\"Minting cDai failed\\\");\\n\\n\\t\\tuint256 cDaiInput = cDai.balanceOf(address(this)) - currCDaiBalance;\\n\\t\\tcDai.transfer(address(reserve), cDaiInput);\\n\\t\\treturn reserve.buy(cDaiInput, _minReturn, _targetAddress);\\n\\t}\\n\\n\\t/**\\n\\t@dev Helper to swap tokens in the Uniswap\\n\\t*@param _inputPath token to used for buy\\n\\t*@param _tokenAmount token amount to sell or buy\\n\\t*@param _minDAIAmount minimum DAI amount to get in swap transaction if transaction is buy\\n\\t*@param _minTokenReturn minimum token amount to get in swap transaction if transaction is sell\\n\\t*@param _receiver receiver of tokens after swap transaction\\n\\t */\\n\\tfunction _uniswapSwap(\\n\\t\\taddress[] memory _inputPath,\\n\\t\\tuint256 _tokenAmount,\\n\\t\\tuint256 _minDAIAmount,\\n\\t\\tuint256 _minTokenReturn,\\n\\t\\taddress _receiver\\n\\t) internal returns (uint256[] memory) {\\n\\t\\tUniswap uniswapContract = Uniswap(nameService.getAddress(\\\"UNISWAP_ROUTER\\\"));\\n\\t\\taddress wETH = uniswapContract.WETH();\\n\\t\\tuint256[] memory swap;\\n\\t\\tbool isBuy = _inputPath[_inputPath.length - 1] == daiAddress; // if outputToken is dai then transaction is buy with any ERC20 token\\n\\t\\tif (_inputPath[0] == address(0x0)) {\\n\\t\\t\\t_inputPath[0] = wETH;\\n\\t\\t\\tswap = uniswapContract.swapExactETHForTokens{ value: _tokenAmount }(\\n\\t\\t\\t\\t_minDAIAmount,\\n\\t\\t\\t\\t_inputPath,\\n\\t\\t\\t\\taddress(this),\\n\\t\\t\\t\\tblock.timestamp\\n\\t\\t\\t);\\n\\t\\t\\treturn swap;\\n\\t\\t} else if (_inputPath[_inputPath.length - 1] == address(0x0)) {\\n\\t\\t\\t_inputPath[_inputPath.length - 1] = wETH;\\n\\t\\t\\tswap = uniswapContract.swapExactTokensForETH(\\n\\t\\t\\t\\t_tokenAmount,\\n\\t\\t\\t\\t_minTokenReturn,\\n\\t\\t\\t\\t_inputPath,\\n\\t\\t\\t\\t_receiver,\\n\\t\\t\\t\\tblock.timestamp\\n\\t\\t\\t);\\n\\t\\t\\treturn swap;\\n\\t\\t} else {\\n\\t\\t\\tif (isBuy)\\n\\t\\t\\t\\tERC20(_inputPath[0]).approve(address(uniswapContract), _tokenAmount);\\n\\t\\t\\tswap = uniswapContract.swapExactTokensForTokens(\\n\\t\\t\\t\\t_tokenAmount,\\n\\t\\t\\t\\tisBuy ? _minDAIAmount : _minTokenReturn,\\n\\t\\t\\t\\t_inputPath,\\n\\t\\t\\t\\t_receiver,\\n\\t\\t\\t\\tblock.timestamp\\n\\t\\t\\t);\\n\\t\\t\\treturn swap;\\n\\t\\t}\\n\\t}\\n}\\n\"\r\n    },\r\n    \"/contracts/Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\nimport { DataTypes } from \\\"./utils/DataTypes.sol\\\";\\npragma solidity >=0.8.0;\\n\\npragma experimental ABIEncoderV2;\\n\\ninterface ERC20 {\\n\\tfunction balanceOf(address addr) external view returns (uint256);\\n\\n\\tfunction transfer(address to, uint256 amount) external returns (bool);\\n\\n\\tfunction approve(address spender, uint256 amount) external returns (bool);\\n\\n\\tfunction decimals() external view returns (uint8);\\n\\n\\tfunction mint(address to, uint256 mintAmount) external returns (uint256);\\n\\n\\tfunction burn(uint256 amount) external;\\n\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\tfunction allowance(\\n\\t\\taddress owner,\\n\\t\\taddress spender\\n\\t) external view returns (uint256);\\n\\n\\tfunction transferFrom(\\n\\t\\taddress sender,\\n\\t\\taddress recipient,\\n\\t\\tuint256 amount\\n\\t) external returns (bool);\\n\\n\\tfunction name() external view returns (string memory);\\n\\n\\tfunction symbol() external view returns (string memory);\\n\\n\\tevent Transfer(address indexed from, address indexed to, uint256 amount);\\n\\tevent Transfer(\\n\\t\\taddress indexed from,\\n\\t\\taddress indexed to,\\n\\t\\tuint256 amount,\\n\\t\\tbytes data\\n\\t);\\n}\\n\\ninterface cERC20 is ERC20 {\\n\\tfunction mint(uint256 mintAmount) external returns (uint256);\\n\\n\\tfunction redeemUnderlying(uint256 mintAmount) external returns (uint256);\\n\\n\\tfunction redeem(uint256 mintAmount) external returns (uint256);\\n\\n\\tfunction exchangeRateCurrent() external returns (uint256);\\n\\n\\tfunction exchangeRateStored() external view returns (uint256);\\n\\n\\tfunction underlying() external returns (address);\\n}\\n\\ninterface IGoodDollar is ERC20 {\\n\\t// view functions\\n\\tfunction feeRecipient() external view returns (address);\\n\\n\\tfunction getFees(\\n\\t\\tuint256 value,\\n\\t\\taddress sender,\\n\\t\\taddress recipient\\n\\t) external view returns (uint256 fee, bool senderPays);\\n\\n\\tfunction cap() external view returns (uint256);\\n\\n\\tfunction isPauser(address _pauser) external view returns (bool);\\n\\n\\tfunction getFees(uint256 value) external view returns (uint256, bool);\\n\\n\\tfunction isMinter(address minter) external view returns (bool);\\n\\n\\tfunction formula() external view returns (address);\\n\\n\\tfunction identity() external view returns (address);\\n\\n\\tfunction owner() external view returns (address);\\n\\n\\t// state changing functions\\n\\tfunction setFeeRecipient(address _feeRecipient) external;\\n\\n\\tfunction setFormula(address _formula) external;\\n\\n\\tfunction transferOwnership(address _owner) external;\\n\\n\\tfunction addPauser(address _pauser) external;\\n\\n\\tfunction pause() external;\\n\\n\\tfunction unpause() external;\\n\\n\\tfunction burn(uint256 amount) external;\\n\\n\\tfunction burnFrom(address account, uint256 amount) external;\\n\\n\\tfunction renounceMinter() external;\\n\\n\\tfunction addMinter(address minter) external;\\n\\n\\tfunction transferAndCall(\\n\\t\\taddress to,\\n\\t\\tuint256 value,\\n\\t\\tbytes calldata data\\n\\t) external returns (bool);\\n\\n\\tfunction setIdentity(address identity) external;\\n}\\n\\ninterface IERC2917 is ERC20 {\\n\\t/// @dev This emit when interests amount per block is changed by the owner of the contract.\\n\\t/// It emits with the old interests amount and the new interests amount.\\n\\tevent InterestRatePerBlockChanged(uint256 oldValue, uint256 newValue);\\n\\n\\t/// @dev This emit when a users' productivity has changed\\n\\t/// It emits with the user's address and the the value after the change.\\n\\tevent ProductivityIncreased(address indexed user, uint256 value);\\n\\n\\t/// @dev This emit when a users' productivity has changed\\n\\t/// It emits with the user's address and the the value after the change.\\n\\tevent ProductivityDecreased(address indexed user, uint256 value);\\n\\n\\t/// @dev Return the current contract's interests rate per block.\\n\\t/// @return The amount of interests currently producing per each block.\\n\\tfunction interestsPerBlock() external view returns (uint256);\\n\\n\\t/// @notice Change the current contract's interests rate.\\n\\t/// @dev Note the best practice will be restrict the gross product provider's contract address to call this.\\n\\t/// @return The true/fase to notice that the value has successfully changed or not, when it succeed, it will emite the InterestRatePerBlockChanged event.\\n\\tfunction changeInterestRatePerBlock(uint256 value) external returns (bool);\\n\\n\\t/// @notice It will get the productivity of given user.\\n\\t/// @dev it will return 0 if user has no productivity proved in the contract.\\n\\t/// @return user's productivity and overall productivity.\\n\\tfunction getProductivity(\\n\\t\\taddress user\\n\\t) external view returns (uint256, uint256);\\n\\n\\t/// @notice increase a user's productivity.\\n\\t/// @dev Note the best practice will be restrict the callee to prove of productivity's contract address.\\n\\t/// @return true to confirm that the productivity added success.\\n\\tfunction increaseProductivity(\\n\\t\\taddress user,\\n\\t\\tuint256 value\\n\\t) external returns (bool);\\n\\n\\t/// @notice decrease a user's productivity.\\n\\t/// @dev Note the best practice will be restrict the callee to prove of productivity's contract address.\\n\\t/// @return true to confirm that the productivity removed success.\\n\\tfunction decreaseProductivity(\\n\\t\\taddress user,\\n\\t\\tuint256 value\\n\\t) external returns (bool);\\n\\n\\t/// @notice take() will return the interests that callee will get at current block height.\\n\\t/// @dev it will always calculated by block.number, so it will change when block height changes.\\n\\t/// @return amount of the interests that user are able to mint() at current block height.\\n\\tfunction take() external view returns (uint256);\\n\\n\\t/// @notice similar to take(), but with the block height joined to calculate return.\\n\\t/// @dev for instance, it returns (_amount, _block), which means at block height _block, the callee has accumulated _amount of interests.\\n\\t/// @return amount of interests and the block height.\\n\\tfunction takeWithBlock() external view returns (uint256, uint256);\\n\\n\\t/// @notice mint the avaiable interests to callee.\\n\\t/// @dev once it mint, the amount of interests will transfer to callee's address.\\n\\t/// @return the amount of interests minted.\\n\\tfunction mint() external returns (uint256);\\n}\\n\\ninterface Staking {\\n\\tstruct Staker {\\n\\t\\t// The staked DAI amount\\n\\t\\tuint256 stakedDAI;\\n\\t\\t// The latest block number which the\\n\\t\\t// staker has staked tokens\\n\\t\\tuint256 lastStake;\\n\\t}\\n\\n\\tfunction stakeDAI(uint256 amount) external;\\n\\n\\tfunction withdrawStake() external;\\n\\n\\tfunction stakers(address staker) external view returns (Staker memory);\\n}\\n\\ninterface Uniswap {\\n\\tfunction swapExactETHForTokens(\\n\\t\\tuint256 amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external payable returns (uint256[] memory amounts);\\n\\n\\tfunction swapExactTokensForETH(\\n\\t\\tuint256 amountIn,\\n\\t\\tuint256 amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external returns (uint256[] memory amounts);\\n\\n\\tfunction swapExactTokensForTokens(\\n\\t\\tuint256 amountIn,\\n\\t\\tuint256 amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external returns (uint256[] memory amounts);\\n\\n\\tfunction WETH() external pure returns (address);\\n\\n\\tfunction factory() external pure returns (address);\\n\\n\\tfunction quote(\\n\\t\\tuint256 amountA,\\n\\t\\tuint256 reserveA,\\n\\t\\tuint256 reserveB\\n\\t) external pure returns (uint256 amountB);\\n\\n\\tfunction getAmountIn(\\n\\t\\tuint256 amountOut,\\n\\t\\tuint256 reserveIn,\\n\\t\\tuint256 reserveOut\\n\\t) external pure returns (uint256 amountIn);\\n\\n\\tfunction getAmountOut(\\n\\t\\tuint256 amountI,\\n\\t\\tuint256 reserveIn,\\n\\t\\tuint256 reserveOut\\n\\t) external pure returns (uint256 amountOut);\\n\\n\\tfunction getAmountsOut(\\n\\t\\tuint256 amountIn,\\n\\t\\taddress[] memory path\\n\\t) external pure returns (uint256[] memory amounts);\\n}\\n\\ninterface UniswapFactory {\\n\\tfunction getPair(\\n\\t\\taddress tokenA,\\n\\t\\taddress tokenB\\n\\t) external view returns (address);\\n}\\n\\ninterface UniswapPair {\\n\\tfunction getReserves()\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n\\n\\tfunction kLast() external view returns (uint256);\\n\\n\\tfunction token0() external view returns (address);\\n\\n\\tfunction token1() external view returns (address);\\n\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\tfunction balanceOf(address owner) external view returns (uint256);\\n}\\n\\ninterface Reserve {\\n\\tfunction buy(\\n\\t\\taddress _buyWith,\\n\\t\\tuint256 _tokenAmount,\\n\\t\\tuint256 _minReturn\\n\\t) external returns (uint256);\\n}\\n\\ninterface IIdentity {\\n\\tfunction isWhitelisted(address user) external view returns (bool);\\n\\n\\tfunction addWhitelistedWithDID(address account, string memory did) external;\\n\\n\\tfunction removeWhitelisted(address account) external;\\n\\n\\tfunction addBlacklisted(address account) external;\\n\\n\\tfunction removeBlacklisted(address account) external;\\n\\n\\tfunction isBlacklisted(address user) external view returns (bool);\\n\\n\\tfunction addIdentityAdmin(address account) external returns (bool);\\n\\n\\tfunction setAvatar(address _avatar) external;\\n\\n\\tfunction isIdentityAdmin(address account) external view returns (bool);\\n\\n\\tfunction owner() external view returns (address);\\n\\n\\tfunction removeContract(address account) external;\\n\\n\\tfunction isDAOContract(address account) external view returns (bool);\\n\\n\\tfunction addrToDID(address account) external view returns (string memory);\\n\\n\\tfunction didHashToAddress(bytes32 hash) external view returns (address);\\n\\n\\tfunction lastAuthenticated(address account) external view returns (uint256);\\n\\n\\tevent WhitelistedAdded(address user);\\n}\\n\\ninterface IIdentityV2 is IIdentity {\\n\\tfunction addWhitelistedWithDIDAndChain(\\n\\t\\taddress account,\\n\\t\\tstring memory did,\\n\\t\\tuint256 orgChainId,\\n\\t\\tuint256 dateAuthenticated\\n\\t) external;\\n\\n\\tfunction getWhitelistedRoot(\\n\\t\\taddress account\\n\\t) external view returns (address root);\\n}\\n\\ninterface IUBIScheme {\\n\\tfunction currentDay() external view returns (uint256);\\n\\n\\tfunction periodStart() external view returns (uint256);\\n\\n\\tfunction hasClaimed(address claimer) external view returns (bool);\\n}\\n\\ninterface IFirstClaimPool {\\n\\tfunction awardUser(address user) external returns (uint256);\\n\\n\\tfunction claimAmount() external view returns (uint256);\\n\\n\\tfunction end() external;\\n}\\n\\ninterface ProxyAdmin {\\n\\tfunction getProxyImplementation(\\n\\t\\taddress proxy\\n\\t) external view returns (address);\\n\\n\\tfunction getProxyAdmin(address proxy) external view returns (address);\\n\\n\\tfunction upgrade(address proxy, address implementation) external;\\n\\n\\tfunction owner() external view returns (address);\\n\\n\\tfunction transferOwnership(address newOwner) external;\\n\\n\\tfunction upgradeAndCall(\\n\\t\\taddress proxy,\\n\\t\\taddress implementation,\\n\\t\\tbytes memory data\\n\\t) external;\\n}\\n\\n/**\\n * @dev Interface for chainlink oracles to obtain price datas\\n */\\ninterface AggregatorV3Interface {\\n\\tfunction decimals() external view returns (uint8);\\n\\n\\tfunction description() external view returns (string memory);\\n\\n\\tfunction version() external view returns (uint256);\\n\\n\\t// getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n\\t// if they do not have data to report, instead of returning unset values\\n\\t// which could be misinterpreted as actual reported values.\\n\\tfunction getRoundData(\\n\\t\\tuint80 _roundId\\n\\t)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (\\n\\t\\t\\tuint80 roundId,\\n\\t\\t\\tint256 answer,\\n\\t\\t\\tuint256 startedAt,\\n\\t\\t\\tuint256 updatedAt,\\n\\t\\t\\tuint80 answeredInRound\\n\\t\\t);\\n\\n\\tfunction latestAnswer() external view returns (int256);\\n}\\n\\n/**\\n\\t@dev interface for AAVE lending Pool\\n */\\ninterface ILendingPool {\\n\\t/**\\n\\t * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\n\\t * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\\n\\t * @param asset The address of the underlying asset to deposit\\n\\t * @param amount The amount to be deposited\\n\\t * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n\\t *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n\\t *   is a different wallet\\n\\t * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n\\t *   0 if the action is executed directly by the user, without any middle-man\\n\\t **/\\n\\tfunction deposit(\\n\\t\\taddress asset,\\n\\t\\tuint256 amount,\\n\\t\\taddress onBehalfOf,\\n\\t\\tuint16 referralCode\\n\\t) external;\\n\\n\\t/**\\n\\t * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\\n\\t * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\n\\t * @param asset The address of the underlying asset to withdraw\\n\\t * @param amount The underlying amount to be withdrawn\\n\\t *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\n\\t * @param to Address that will receive the underlying, same as msg.sender if the user\\n\\t *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\n\\t *   different wallet\\n\\t * @return The final amount withdrawn\\n\\t **/\\n\\tfunction withdraw(\\n\\t\\taddress asset,\\n\\t\\tuint256 amount,\\n\\t\\taddress to\\n\\t) external returns (uint256);\\n\\n\\t/**\\n\\t * @dev Returns the state and configuration of the reserve\\n\\t * @param asset The address of the underlying asset of the reserve\\n\\t * @return The state of the reserve\\n\\t **/\\n\\tfunction getReserveData(\\n\\t\\taddress asset\\n\\t) external view returns (DataTypes.ReserveData memory);\\n}\\n\\ninterface IDonationStaking {\\n\\tfunction stakeDonations() external payable;\\n}\\n\\ninterface INameService {\\n\\tfunction getAddress(string memory _name) external view returns (address);\\n}\\n\\ninterface IAaveIncentivesController {\\n\\t/**\\n\\t * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\\n\\t * @param amount Amount of rewards to claim\\n\\t * @param to Address that will be receiving the rewards\\n\\t * @return Rewards claimed\\n\\t **/\\n\\tfunction claimRewards(\\n\\t\\taddress[] calldata assets,\\n\\t\\tuint256 amount,\\n\\t\\taddress to\\n\\t) external returns (uint256);\\n\\n\\t/**\\n\\t * @dev Returns the total of rewards of an user, already accrued + not yet accrued\\n\\t * @param user The address of the user\\n\\t * @return The rewards\\n\\t **/\\n\\tfunction getRewardsBalance(\\n\\t\\taddress[] calldata assets,\\n\\t\\taddress user\\n\\t) external view returns (uint256);\\n}\\n\\ninterface IGoodStaking {\\n\\tfunction collectUBIInterest(\\n\\t\\taddress recipient\\n\\t) external returns (uint256, uint256, uint256);\\n\\n\\tfunction iToken() external view returns (address);\\n\\n\\tfunction currentGains(\\n\\t\\tbool _returnTokenBalanceInUSD,\\n\\t\\tbool _returnTokenGainsInUSD\\n\\t) external view returns (uint256, uint256, uint256, uint256, uint256);\\n\\n\\tfunction getRewardEarned(address user) external view returns (uint256);\\n\\n\\tfunction getGasCostForInterestTransfer() external view returns (uint256);\\n\\n\\tfunction rewardsMinted(\\n\\t\\taddress user,\\n\\t\\tuint256 rewardsPerBlock,\\n\\t\\tuint256 blockStart,\\n\\t\\tuint256 blockEnd\\n\\t) external returns (uint256);\\n}\\n\\ninterface IHasRouter {\\n\\tfunction getRouter() external view returns (Uniswap);\\n}\\n\\ninterface IAdminWallet {\\n\\tfunction addAdmins(address payable[] memory _admins) external;\\n\\n\\tfunction removeAdmins(address[] memory _admins) external;\\n\\n\\tfunction owner() external view returns (address);\\n\\n\\tfunction transferOwnership(address _owner) external;\\n}\\n\\ninterface IMultichainRouter {\\n\\t// Swaps `amount` `token` from this chain to `toChainID` chain with recipient `to`\\n\\tfunction anySwapOut(\\n\\t\\taddress token,\\n\\t\\taddress to,\\n\\t\\tuint256 amount,\\n\\t\\tuint256 toChainID\\n\\t) external;\\n\\n\\t// Swaps `amount` `token` from this chain to `toChainID` chain with recipient `to`\\n\\tfunction anySwapOutUnderlying(\\n\\t\\taddress token,\\n\\t\\taddress to,\\n\\t\\tuint256 amount,\\n\\t\\tuint256 toChainID\\n\\t) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/DAOStackInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\ninterface Avatar {\\n\\tfunction nativeToken() external view returns (address);\\n\\n\\tfunction nativeReputation() external view returns (address);\\n\\n\\tfunction owner() external view returns (address);\\n}\\n\\ninterface Controller {\\n\\tevent RegisterScheme(address indexed _sender, address indexed _scheme);\\n\\tevent UnregisterScheme(address indexed _sender, address indexed _scheme);\\n\\n\\tfunction genericCall(\\n\\t\\taddress _contract,\\n\\t\\tbytes calldata _data,\\n\\t\\taddress _avatar,\\n\\t\\tuint256 _value\\n\\t) external returns (bool, bytes memory);\\n\\n\\tfunction avatar() external view returns (address);\\n\\n\\tfunction unregisterScheme(address _scheme, address _avatar)\\n\\t\\texternal\\n\\t\\treturns (bool);\\n\\n\\tfunction unregisterSelf(address _avatar) external returns (bool);\\n\\n\\tfunction registerScheme(\\n\\t\\taddress _scheme,\\n\\t\\tbytes32 _paramsHash,\\n\\t\\tbytes4 _permissions,\\n\\t\\taddress _avatar\\n\\t) external returns (bool);\\n\\n\\tfunction isSchemeRegistered(address _scheme, address _avatar)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (bool);\\n\\n\\tfunction getSchemePermissions(address _scheme, address _avatar)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (bytes4);\\n\\n\\tfunction addGlobalConstraint(\\n\\t\\taddress _constraint,\\n\\t\\tbytes32 _paramHash,\\n\\t\\taddress _avatar\\n\\t) external returns (bool);\\n\\n\\tfunction mintTokens(\\n\\t\\tuint256 _amount,\\n\\t\\taddress _beneficiary,\\n\\t\\taddress _avatar\\n\\t) external returns (bool);\\n\\n\\tfunction externalTokenTransfer(\\n\\t\\taddress _token,\\n\\t\\taddress _recipient,\\n\\t\\tuint256 _amount,\\n\\t\\taddress _avatar\\n\\t) external returns (bool);\\n\\n\\tfunction sendEther(\\n\\t\\tuint256 _amountInWei,\\n\\t\\taddress payable _to,\\n\\t\\taddress _avatar\\n\\t) external returns (bool);\\n}\\n\\ninterface GlobalConstraintInterface {\\n\\tenum CallPhase {\\n\\t\\tPre,\\n\\t\\tPost,\\n\\t\\tPreAndPost\\n\\t}\\n\\n\\tfunction pre(\\n\\t\\taddress _scheme,\\n\\t\\tbytes32 _params,\\n\\t\\tbytes32 _method\\n\\t) external returns (bool);\\n\\n\\t/**\\n\\t * @dev when return if this globalConstraints is pre, post or both.\\n\\t * @return CallPhase enum indication  Pre, Post or PreAndPost.\\n\\t */\\n\\tfunction when() external returns (CallPhase);\\n}\\n\\ninterface ReputationInterface {\\n\\tfunction balanceOf(address _user) external view returns (uint256);\\n\\n\\tfunction balanceOfAt(address _user, uint256 _blockNumber)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256);\\n\\n\\tfunction getVotes(address _user) external view returns (uint256);\\n\\n\\tfunction getVotesAt(\\n\\t\\taddress _user,\\n\\t\\tbool _global,\\n\\t\\tuint256 _blockNumber\\n\\t) external view returns (uint256);\\n\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\tfunction totalSupplyAt(uint256 _blockNumber)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256);\\n\\n\\tfunction delegateOf(address _user) external returns (address);\\n}\\n\\ninterface SchemeRegistrar {\\n\\tfunction proposeScheme(\\n\\t\\tAvatar _avatar,\\n\\t\\taddress _scheme,\\n\\t\\tbytes32 _parametersHash,\\n\\t\\tbytes4 _permissions,\\n\\t\\tstring memory _descriptionHash\\n\\t) external returns (bytes32);\\n\\n\\tevent NewSchemeProposal(\\n\\t\\taddress indexed _avatar,\\n\\t\\tbytes32 indexed _proposalId,\\n\\t\\taddress indexed _intVoteInterface,\\n\\t\\taddress _scheme,\\n\\t\\tbytes32 _parametersHash,\\n\\t\\tbytes4 _permissions,\\n\\t\\tstring _descriptionHash\\n\\t);\\n}\\n\\ninterface IntVoteInterface {\\n\\tevent NewProposal(\\n\\t\\tbytes32 indexed _proposalId,\\n\\t\\taddress indexed _organization,\\n\\t\\tuint256 _numOfChoices,\\n\\t\\taddress _proposer,\\n\\t\\tbytes32 _paramsHash\\n\\t);\\n\\n\\tevent ExecuteProposal(\\n\\t\\tbytes32 indexed _proposalId,\\n\\t\\taddress indexed _organization,\\n\\t\\tuint256 _decision,\\n\\t\\tuint256 _totalReputation\\n\\t);\\n\\n\\tevent VoteProposal(\\n\\t\\tbytes32 indexed _proposalId,\\n\\t\\taddress indexed _organization,\\n\\t\\taddress indexed _voter,\\n\\t\\tuint256 _vote,\\n\\t\\tuint256 _reputation\\n\\t);\\n\\n\\tevent CancelProposal(\\n\\t\\tbytes32 indexed _proposalId,\\n\\t\\taddress indexed _organization\\n\\t);\\n\\tevent CancelVoting(\\n\\t\\tbytes32 indexed _proposalId,\\n\\t\\taddress indexed _organization,\\n\\t\\taddress indexed _voter\\n\\t);\\n\\n\\t/**\\n\\t * @dev register a new proposal with the given parameters. Every proposal has a unique ID which is being\\n\\t * generated by calculating keccak256 of a incremented counter.\\n\\t * @param _numOfChoices number of voting choices\\n\\t * @param _proposalParameters defines the parameters of the voting machine used for this proposal\\n\\t * @param _proposer address\\n\\t * @param _organization address - if this address is zero the msg.sender will be used as the organization address.\\n\\t * @return proposal's id.\\n\\t */\\n\\tfunction propose(\\n\\t\\tuint256 _numOfChoices,\\n\\t\\tbytes32 _proposalParameters,\\n\\t\\taddress _proposer,\\n\\t\\taddress _organization\\n\\t) external returns (bytes32);\\n\\n\\tfunction vote(\\n\\t\\tbytes32 _proposalId,\\n\\t\\tuint256 _vote,\\n\\t\\tuint256 _rep,\\n\\t\\taddress _voter\\n\\t) external returns (bool);\\n\\n\\tfunction cancelVote(bytes32 _proposalId) external;\\n\\n\\tfunction getNumberOfChoices(bytes32 _proposalId)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256);\\n\\n\\tfunction isVotable(bytes32 _proposalId) external view returns (bool);\\n\\n\\t/**\\n\\t * @dev voteStatus returns the reputation voted for a proposal for a specific voting choice.\\n\\t * @param _proposalId the ID of the proposal\\n\\t * @param _choice the index in the\\n\\t * @return voted reputation for the given choice\\n\\t */\\n\\tfunction voteStatus(bytes32 _proposalId, uint256 _choice)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256);\\n\\n\\t/**\\n\\t * @dev isAbstainAllow returns if the voting machine allow abstain (0)\\n\\t * @return bool true or false\\n\\t */\\n\\tfunction isAbstainAllow() external pure returns (bool);\\n\\n\\t/**\\n     * @dev getAllowedRangeOfChoices returns the allowed range of choices for a voting machine.\\n     * @return min - minimum number of choices\\n               max - maximum number of choices\\n     */\\n\\tfunction getAllowedRangeOfChoices()\\n\\t\\texternal\\n\\t\\tpure\\n\\t\\treturns (uint256 min, uint256 max);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title The interface for the Uniswap V3 Factory\\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\\ninterface IUniswapV3Factory {\\n    /// @notice Emitted when the owner of the factory is changed\\n    /// @param oldOwner The owner before the owner was changed\\n    /// @param newOwner The owner after the owner was changed\\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @notice Emitted when a pool is created\\n    /// @param token0 The first token of the pool by address sort order\\n    /// @param token1 The second token of the pool by address sort order\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\\n    /// @param pool The address of the created pool\\n    event PoolCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        uint24 indexed fee,\\n        int24 tickSpacing,\\n        address pool\\n    );\\n\\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\\n    /// @param fee The enabled fee, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\\n\\n    /// @notice Returns the current owner of the factory\\n    /// @dev Can be changed by the current owner via setOwner\\n    /// @return The address of the factory owner\\n    function owner() external view returns (address);\\n\\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\\n    /// @return The tick spacing\\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\\n\\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\\n    /// @param tokenA The contract address of either token0 or token1\\n    /// @param tokenB The contract address of the other token\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @return pool The pool address\\n    function getPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) external view returns (address pool);\\n\\n    /// @notice Creates a pool for the given two tokens and fee\\n    /// @param tokenA One of the two tokens in the desired pool\\n    /// @param tokenB The other of the two tokens in the desired pool\\n    /// @param fee The desired fee for the pool\\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\\n    /// are invalid.\\n    /// @return pool The address of the newly created pool\\n    function createPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) external returns (address pool);\\n\\n    /// @notice Updates the owner of the factory\\n    /// @dev Must be called by the current owner\\n    /// @param _owner The new owner of the factory\\n    function setOwner(address _owner) external;\\n\\n    /// @notice Enables a fee amount with the given tickSpacing\\n    /// @dev Fee amounts may never be removed once enabled\\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSetUpgradeable {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMathUpgradeable {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary MathUpgradeable {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProofUpgradeable {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/MathUpgradeable.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = MathUpgradeable.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/presets/ERC20PresetMinterPauser.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/ERC20BurnableUpgradeable.sol\\\";\\nimport \\\"../extensions/ERC20PausableUpgradeable.sol\\\";\\nimport \\\"../../../access/AccessControlEnumerableUpgradeable.sol\\\";\\nimport \\\"../../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev {ERC20} token, including:\\n *\\n *  - ability for holders to burn (destroy) their tokens\\n *  - a minter role that allows for token minting (creation)\\n *  - a pauser role that allows to stop all token transfers\\n *\\n * This contract uses {AccessControl} to lock permissioned functions using the\\n * different roles - head to its documentation for details.\\n *\\n * The account that deploys the contract will be granted the minter and pauser\\n * roles, as well as the default admin role, which will let it grant both minter\\n * and pauser roles to other accounts.\\n *\\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\\n */\\ncontract ERC20PresetMinterPauserUpgradeable is Initializable, ContextUpgradeable, AccessControlEnumerableUpgradeable, ERC20BurnableUpgradeable, ERC20PausableUpgradeable {\\n    function initialize(string memory name, string memory symbol) public virtual initializer {\\n        __ERC20PresetMinterPauser_init(name, symbol);\\n    }\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n    bytes32 public constant PAUSER_ROLE = keccak256(\\\"PAUSER_ROLE\\\");\\n\\n    /**\\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\\n     * account that deploys the contract.\\n     *\\n     * See {ERC20-constructor}.\\n     */\\n    function __ERC20PresetMinterPauser_init(string memory name, string memory symbol) internal onlyInitializing {\\n        __ERC20_init_unchained(name, symbol);\\n        __Pausable_init_unchained();\\n        __ERC20PresetMinterPauser_init_unchained(name, symbol);\\n    }\\n\\n    function __ERC20PresetMinterPauser_init_unchained(string memory, string memory) internal onlyInitializing {\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n\\n        _setupRole(MINTER_ROLE, _msgSender());\\n        _setupRole(PAUSER_ROLE, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Creates `amount` new tokens for `to`.\\n     *\\n     * See {ERC20-_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `MINTER_ROLE`.\\n     */\\n    function mint(address to, uint256 amount) public virtual {\\n        require(hasRole(MINTER_ROLE, _msgSender()), \\\"ERC20PresetMinterPauser: must have minter role to mint\\\");\\n        _mint(to, amount);\\n    }\\n\\n    /**\\n     * @dev Pauses all token transfers.\\n     *\\n     * See {ERC20Pausable} and {Pausable-_pause}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `PAUSER_ROLE`.\\n     */\\n    function pause() public virtual {\\n        require(hasRole(PAUSER_ROLE, _msgSender()), \\\"ERC20PresetMinterPauser: must have pauser role to pause\\\");\\n        _pause();\\n    }\\n\\n    /**\\n     * @dev Unpauses all token transfers.\\n     *\\n     * See {ERC20Pausable} and {Pausable-_unpause}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `PAUSER_ROLE`.\\n     */\\n    function unpause() public virtual {\\n        require(hasRole(PAUSER_ROLE, _msgSender()), \\\"ERC20PresetMinterPauser: must have pauser role to unpause\\\");\\n        _unpause();\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual override(ERC20Upgradeable, ERC20PausableUpgradeable) {\\n        super._beforeTokenTransfer(from, to, amount);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20Upgradeable.sol\\\";\\nimport \\\"../../../security/PausableUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev ERC20 token with pausable token transfers, minting and burning.\\n *\\n * Useful for scenarios such as preventing trades until the end of an evaluation\\n * period, or having an emergency switch for freezing all token transfers in the\\n * event of a large bug.\\n */\\nabstract contract ERC20PausableUpgradeable is Initializable, ERC20Upgradeable, PausableUpgradeable {\\n    function __ERC20Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __ERC20Pausable_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {ERC20-_beforeTokenTransfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - the contract must not be paused.\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, amount);\\n\\n        require(!paused(), \\\"ERC20Pausable: token transfer while paused\\\");\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20Upgradeable.sol\\\";\\nimport \\\"../../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\\n    function __ERC20Burnable_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        _spendAllowance(account, _msgSender(), amount);\\n        _burn(account, amount);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[45] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../ERC1967/ERC1967UpgradeUpgradeable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"UUPSUpgradeable: must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeaconUpgradeable {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeaconUpgradeable.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/StorageSlotUpgradeable.sol\\\";\\nimport \\\"../utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\\n    function __ERC1967Upgrade_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\\n    }\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(AddressUpgradeable.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(AddressUpgradeable.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\\n        require(AddressUpgradeable.isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return AddressUpgradeable.verifyCallResult(success, returndata, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822ProxiableUpgradeable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControlUpgradeable {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControlUpgradeable.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\\n */\\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControlUpgradeable.sol\\\";\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../utils/StringsUpgradeable.sol\\\";\\nimport \\\"../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\\n    function __AccessControl_init() internal onlyInitializing {\\n    }\\n\\n    function __AccessControl_init_unchained() internal onlyInitializing {\\n    }\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        StringsUpgradeable.toHexString(account),\\n                        \\\" is missing role \\\",\\n                        StringsUpgradeable.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControlEnumerableUpgradeable.sol\\\";\\nimport \\\"./AccessControlUpgradeable.sol\\\";\\nimport \\\"../utils/structs/EnumerableSetUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\\n */\\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\\n    function __AccessControlEnumerable_init() internal onlyInitializing {\\n    }\\n\\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\\n    }\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\n\\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\\n        return _roleMembers[role].at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\\n        return _roleMembers[role].length();\\n    }\\n\\n    /**\\n     * @dev Overload {_grantRole} to track enumerable memberships\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual override {\\n        super._grantRole(role, account);\\n        _roleMembers[role].add(account);\\n    }\\n\\n    /**\\n     * @dev Overload {_revokeRole} to track enumerable memberships\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual override {\\n        super._revokeRole(role, account);\\n        _roleMembers[role].remove(account);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@mean-finance/uniswap-v3-oracle/solidity/interfaces/IStaticOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.7.6 <0.9.0;\\n\\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol';\\n\\n/// @title Uniswap V3 Static Oracle\\n/// @notice Oracle contract for calculating price quoting against Uniswap V3\\ninterface IStaticOracle {\\n  /// @notice Returns the address of the Uniswap V3 factory\\n  /// @dev This value is assigned during deployment and cannot be changed\\n  /// @return The address of the Uniswap V3 factory\\n  function UNISWAP_V3_FACTORY() external view returns (IUniswapV3Factory);\\n\\n  /// @notice Returns how many observations are needed per minute in Uniswap V3 oracles, on the deployed chain\\n  /// @dev This value is assigned during deployment and cannot be changed\\n  /// @return Number of observation that are needed per minute\\n  function CARDINALITY_PER_MINUTE() external view returns (uint8);\\n\\n  /// @notice Returns all supported fee tiers\\n  /// @return The supported fee tiers\\n  function supportedFeeTiers() external view returns (uint24[] memory);\\n\\n  /// @notice Returns whether a specific pair can be supported by the oracle\\n  /// @dev The pair can be provided in tokenA/tokenB or tokenB/tokenA order\\n  /// @return Whether the given pair can be supported by the oracle\\n  function isPairSupported(address tokenA, address tokenB) external view returns (bool);\\n\\n  /// @notice Returns all existing pools for the given pair\\n  /// @dev The pair can be provided in tokenA/tokenB or tokenB/tokenA order\\n  /// @return All existing pools for the given pair\\n  function getAllPoolsForPair(address tokenA, address tokenB) external view returns (address[] memory);\\n\\n  /// @notice Returns a quote, based on the given tokens and amount, by querying all of the pair's pools\\n  /// @dev If some pools are not configured correctly for the given period, then they will be ignored\\n  /// @dev Will revert if there are no pools available/configured for the pair and period combination\\n  /// @param baseAmount Amount of token to be converted\\n  /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\\n  /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\\n  /// @param period Number of seconds from which to calculate the TWAP\\n  /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\\n  /// @return queriedPools The pools that were queried to calculate the quote\\n  function quoteAllAvailablePoolsWithTimePeriod(\\n    uint128 baseAmount,\\n    address baseToken,\\n    address quoteToken,\\n    uint32 period\\n  ) external view returns (uint256 quoteAmount, address[] memory queriedPools);\\n\\n  /// @notice Returns a quote, based on the given tokens and amount, by querying only the specified fee tiers\\n  /// @dev Will revert if the pair does not have a pool for one of the given fee tiers, or if one of the pools\\n  /// is not prepared/configured correctly for the given period\\n  /// @param baseAmount Amount of token to be converted\\n  /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\\n  /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\\n  /// @param feeTiers The fee tiers to consider when calculating the quote\\n  /// @param period Number of seconds from which to calculate the TWAP\\n  /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\\n  /// @return queriedPools The pools that were queried to calculate the quote\\n  function quoteSpecificFeeTiersWithTimePeriod(\\n    uint128 baseAmount,\\n    address baseToken,\\n    address quoteToken,\\n    uint24[] calldata feeTiers,\\n    uint32 period\\n  ) external view returns (uint256 quoteAmount, address[] memory queriedPools);\\n\\n  /// @notice Returns a quote, based on the given tokens and amount, by querying only the specified pools\\n  /// @dev Will revert if one of the pools is not prepared/configured correctly for the given period\\n  /// @param baseAmount Amount of token to be converted\\n  /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\\n  /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\\n  /// @param pools The pools to consider when calculating the quote\\n  /// @param period Number of seconds from which to calculate the TWAP\\n  /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\\n  function quoteSpecificPoolsWithTimePeriod(\\n    uint128 baseAmount,\\n    address baseToken,\\n    address quoteToken,\\n    address[] calldata pools,\\n    uint32 period\\n  ) external view returns (uint256 quoteAmount);\\n\\n  /// @notice Will initialize all existing pools for the given pair, so that they can be queried with the given period in the future\\n  /// @dev Will revert if there are no pools available for the pair and period combination\\n  /// @param tokenA One of the pair's tokens\\n  /// @param tokenB The other of the pair's tokens\\n  /// @param period The period that will be guaranteed when quoting\\n  /// @return preparedPools The pools that were prepared\\n  function prepareAllAvailablePoolsWithTimePeriod(\\n    address tokenA,\\n    address tokenB,\\n    uint32 period\\n  ) external returns (address[] memory preparedPools);\\n\\n  /// @notice Will initialize the pair's pools with the specified fee tiers, so that they can be queried with the given period in the future\\n  /// @dev Will revert if the pair does not have a pool for a given fee tier\\n  /// @param tokenA One of the pair's tokens\\n  /// @param tokenB The other of the pair's tokens\\n  /// @param feeTiers The fee tiers to consider when searching for the pair's pools\\n  /// @param period The period that will be guaranteed when quoting\\n  /// @return preparedPools The pools that were prepared\\n  function prepareSpecificFeeTiersWithTimePeriod(\\n    address tokenA,\\n    address tokenB,\\n    uint24[] calldata feeTiers,\\n    uint32 period\\n  ) external returns (address[] memory preparedPools);\\n\\n  /// @notice Will initialize all given pools, so that they can be queried with the given period in the future\\n  /// @param pools The pools to initialize\\n  /// @param period The period that will be guaranteed when quoting\\n  function prepareSpecificPoolsWithTimePeriod(address[] calldata pools, uint32 period) external;\\n\\n  /// @notice Will increase observations for all existing pools for the given pair, so they start accruing information for twap calculations\\n  /// @dev Will revert if there are no pools available for the pair and period combination\\n  /// @param tokenA One of the pair's tokens\\n  /// @param tokenB The other of the pair's tokens\\n  /// @param cardinality The cardinality that will be guaranteed when quoting\\n  /// @return preparedPools The pools that were prepared\\n  function prepareAllAvailablePoolsWithCardinality(\\n    address tokenA,\\n    address tokenB,\\n    uint16 cardinality\\n  ) external returns (address[] memory preparedPools);\\n\\n  /// @notice Will increase the pair's pools with the specified fee tiers observations, so they start accruing information for twap calculations\\n  /// @dev Will revert if the pair does not have a pool for a given fee tier\\n  /// @param tokenA One of the pair's tokens\\n  /// @param tokenB The other of the pair's tokens\\n  /// @param feeTiers The fee tiers to consider when searching for the pair's pools\\n  /// @param cardinality The cardinality that will be guaranteed when quoting\\n  /// @return preparedPools The pools that were prepared\\n  function prepareSpecificFeeTiersWithCardinality(\\n    address tokenA,\\n    address tokenB,\\n    uint24[] calldata feeTiers,\\n    uint16 cardinality\\n  ) external returns (address[] memory preparedPools);\\n\\n  /// @notice Will increase all given pools observations, so they start accruing information for twap calculations\\n  /// @param pools The pools to initialize\\n  /// @param cardinality The cardinality that will be guaranteed when quoting\\n  function prepareSpecificPoolsWithCardinality(address[] calldata pools, uint16 cardinality) external;\\n\\n  /// @notice Adds support for a new fee tier\\n  /// @dev Will revert if the given tier is invalid, or already supported\\n  /// @param feeTier The new fee tier to add\\n  function addNewFeeTier(uint24 feeTier) external;\\n}\\n\"\r\n    },\r\n    \"@gooddollar/bridge-contracts/contracts/messagePassingBridge/IMessagePassingBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface ILayerZeroFeeEstimator {\\n    function estimateSendFee(\\n        uint16 _dstChainId,\\n        address _fromAddress,\\n        address _toAddress,\\n        uint _normalizedAmount,\\n        bool _useZro,\\n        bytes memory _adapterParams\\n    ) external view returns (uint nativeFee, uint zroFee);\\n}\\n\\ninterface IMessagePassingBridge {\\n    enum BridgeService {\\n        AXELAR,\\n        LZ\\n    }\\n\\n    // A struct for storing bridge fees\\n    struct BridgeFees {\\n        uint256 minFee;\\n        uint256 maxFee;\\n        uint256 fee;\\n    }\\n\\n    // A struct for storing bridge limits\\n    struct BridgeLimits {\\n        uint256 dailyLimit;\\n        uint256 txLimit;\\n        uint256 accountDailyLimit;\\n        uint256 minAmount;\\n        bool onlyWhitelisted;\\n    }\\n\\n    function lzEndpoint_() external view returns (address);\\n\\n    function TESTNET() external view returns (bool);\\n\\n    function guardian() external view returns (address);\\n\\n    function bridgeFees() external view returns (uint256 minFee, uint256 maxFee, uint256 fee);\\n\\n    function bridgeLimits()\\n        external\\n        view\\n        returns (\\n            uint256 dailyLimit,\\n            uint256 txLimit,\\n            uint256 accountDailyLimit,\\n            uint256 minAmount,\\n            bool onlyWhitelisted\\n        );\\n\\n    function bridgeDailyLimit() external view returns (uint256 lastTransferReset, uint256 bridged24Hours);\\n\\n    function feeRecipient() external view returns (address);\\n\\n    function toLzChainId(uint256 chainId) external view returns (uint16 lzChainId);\\n\\n    function setFeeRecipient(address recipient) external;\\n\\n    function setBridgeLimits(BridgeLimits memory _limits) external;\\n\\n    function setBridgeFees(BridgeFees memory _fees) external;\\n\\n    function setDisabledBridges(bytes32[] memory bridgeKeys, bool[] memory disabled) external;\\n\\n    function setFaucet(address _faucet) external;\\n\\n    function setGuardian(address _guardian) external;\\n\\n    function canBridge(address from, uint256 amount) external view returns (bool isWithinLimit, string memory error);\\n\\n    function withdraw(address token, uint256 amount) external;\\n\\n    function pauseBridge(bool isPaused) external;\\n\\n    function bridgeTo(address target, uint256 targetChainId, uint256 amount, BridgeService bridge) external payable;\\n\\n    function bridgeToWithLz(\\n        address target,\\n        uint256 targetChainId,\\n        uint256 amount,\\n        bytes calldata adapterParams\\n    ) external payable;\\n\\n    function bridgeToWithAxelar(\\n        address target,\\n        uint256 targetChainId,\\n        uint256 amount,\\n        address gasRefundAddress\\n    ) external payable;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 0\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"FEE_LIMIT\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"distributed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startingBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"incomingAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"bps\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"chainId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"enum DistributionHelper.TransferType\",\"name\":\"transferType\",\"type\":\"uint8\"}],\"indexed\":false,\"internalType\":\"struct DistributionHelper.DistributionRecipient[]\",\"name\":\"distributionRecipients\",\"type\":\"tuple[]\"}],\"name\":\"Distribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"bps\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"chainId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"enum DistributionHelper.TransferType\",\"name\":\"transferType\",\"type\":\"uint8\"}],\"indexed\":false,\"internalType\":\"struct DistributionHelper.DistributionRecipient\",\"name\":\"recipient\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"RecipientAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"bps\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"chainId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"enum DistributionHelper.TransferType\",\"name\":\"transferType\",\"type\":\"uint8\"}],\"indexed\":false,\"internalType\":\"struct DistributionHelper.DistributionRecipient\",\"name\":\"recipient\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"RecipientUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CELO_TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FUSE_TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GUARDIAN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STATIC_ORACLE\",\"outputs\":[{\"internalType\":\"contract IStaticOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDC_TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH_TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"bps\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"chainId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"enum DistributionHelper.TransferType\",\"name\":\"transferType\",\"type\":\"uint8\"}],\"internalType\":\"struct DistributionHelper.DistributionRecipient\",\"name\":\"_recipient\",\"type\":\"tuple\"}],\"name\":\"addOrUpdateRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avatar\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dao\",\"outputs\":[{\"internalType\":\"contract Controller\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"distributionRecipients\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"bps\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"chainId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"enum DistributionHelper.TransferType\",\"name\":\"transferType\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeSettings\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"axelarBaseFeeUSD\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"bridgeExecuteGas\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"targetChainGasPrice\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"maxFee\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"minBalanceForFees\",\"type\":\"uint128\"},{\"internalType\":\"uint8\",\"name\":\"percentageToSellForFee\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fuseBridge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetChainId\",\"type\":\"uint256\"}],\"name\":\"getAxelarFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feeInEth\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasCostWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"getTargetChainGasInEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"quote\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"getTargetChainRefundAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract INameService\",\"name\":\"_ns\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mpbBridge\",\"outputs\":[{\"internalType\":\"contract IMessagePassingBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nameService\",\"outputs\":[{\"internalType\":\"contract INameService\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeToken\",\"outputs\":[{\"internalType\":\"contract IGoodDollar\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"onDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"axelarBaseFeeUSD\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"bridgeExecuteGas\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"targetChainGasPrice\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"maxFee\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"minBalanceForFees\",\"type\":\"uint128\"},{\"internalType\":\"uint8\",\"name\":\"percentageToSellForFee\",\"type\":\"uint8\"}],\"internalType\":\"struct DistributionHelper.FeeSettings\",\"name\":\"_feeData\",\"type\":\"tuple\"}],\"name\":\"setFeeSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateAvatar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DistributionHelper", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "0", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}