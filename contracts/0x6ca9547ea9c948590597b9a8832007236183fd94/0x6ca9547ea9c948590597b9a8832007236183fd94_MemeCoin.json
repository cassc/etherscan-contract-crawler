{"SourceCode": "// Set the license for the smart contract.\r\n// SPDX-License-Identifier: MIT\r\n\r\n// Specify the version of the Solidity compiler.\r\npragma solidity ^0.8.0;\r\n\r\n// Define the interface for the ERC20 standard.\r\ninterface IERC20 {\r\n    // Returns the total supply of the token.\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    // Returns the token balance of a specific address.\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    // Transfers tokens to a specific address.\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    // Returns the remaining number of tokens that spender can spend on behalf of the owner.\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    // Sets the allowance of one address, allowing another to spend on its behalf.\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    // Transfers tokens from one address to another.\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    // Event emitted when tokens are transferred.\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // Event emitted when an allowance is set.\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// The main token contract.\r\ncontract MemeCoin is IERC20 {\r\n    // Declare the token's name.\r\n    string public constant name = \"MemeCoin\";\r\n\r\n    // Declare the token's symbol.\r\n    string public constant symbol = \"MEME\";\r\n\r\n    // Set the number of decimals the token uses.\r\n    uint8 public constant decimals = 18;\r\n\r\n    // Initialize the total supply of the token.\r\n    uint256 private _totalSupply = 1000000 * 10**decimals;\r\n\r\n    // A mapping to store each address's balance.\r\n    mapping(address => uint256) private _balances;\r\n\r\n    // A mapping to store allowances.\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    // Addresses to receive the 1% tax.\r\n    address public developerAddress;\r\n    address public marketingAddress;\r\n\r\n    // The constructor sets the initial supply and developer/marketing addresses.\r\n    constructor(address _developerAddress, address _marketingAddress) {\r\n        // Assign the total supply to the creator's balance.\r\n        _balances[msg.sender] = _totalSupply;\r\n        \r\n        // Emit a transfer event for the creation of tokens.\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n\r\n        // Set the addresses for tax purposes.\r\n        developerAddress = _developerAddress;\r\n        marketingAddress = _marketingAddress;\r\n    }\r\n\r\n    // Returns the total supply.\r\n    function totalSupply() external view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    // Returns the balance of a specific address.\r\n    function balanceOf(address account) external view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    // Transfer tokens to a recipient after deducting tax.\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        // Calculate the 1% taxes.\r\n        uint256 developerTax = amount / 100;\r\n        uint256 marketingTax = amount / 100;\r\n\r\n        // Handle the tax transfers.\r\n        _transferTax(msg.sender, developerTax, marketingTax);\r\n\r\n        // Calculate the net amount after taxes.\r\n        uint256 netAmount = amount - developerTax - marketingTax;\r\n\r\n        // Perform the token transfer.\r\n        return _transfer(msg.sender, recipient, netAmount);\r\n    }\r\n\r\n    // Check the allowance an owner gave to a spender.\r\n    function allowance(address owner, address spender) external view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    // Allow a spender to spend a set amount of tokens on behalf of the caller.\r\n    function approve(address spender, uint256 amount) external override returns (bool) {\r\n        // Set the allowance.\r\n        _allowances[msg.sender][spender] = amount;\r\n\r\n        // Emit an approval event.\r\n        emit Approval(msg.sender, spender, amount);\r\n        \r\n        return true;\r\n    }\r\n\r\n    // Transfer tokens on behalf of an address after deducting tax.\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        // Calculate the 1% taxes.\r\n        uint256 developerTax = amount / 100;\r\n        uint256 marketingTax = amount / 100;\r\n\r\n        // Handle the tax transfers.\r\n        _transferTax(sender, developerTax, marketingTax);\r\n\r\n        // Calculate the net amount after taxes.\r\n        uint256 netAmount = amount - developerTax - marketingTax;\r\n\r\n        // Transfer the tokens and reduce the allowance.\r\n        bool success = _transfer(sender, recipient, netAmount);\r\n        if (success) {\r\n            _allowances[sender][msg.sender] -= amount;\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    // Internal function to handle token transfers.\r\n    function _transfer(address from, address to, uint256 value) internal returns (bool) {\r\n        // Ensure recipient isn't zero address.\r\n        require(to != address(0), \"Transfer to zero address\");\r\n        \r\n        // Check sender has enough tokens.\r\n        require(_balances[from] >= value, \"Insufficient balance\");\r\n\r\n        // Adjust balances after transfer.\r\n        _balances[from] -= value;\r\n        _balances[to] += value;\r\n\r\n        // Emit a transfer event.\r\n        emit Transfer(from, to, value);\r\n        \r\n        return true;\r\n    }\r\n\r\n    // Internal function to handle the tax transfers.\r\n    function _transferTax(address from, uint256 developerTax, uint256 marketingTax) internal {\r\n        // Deduct total tax from sender.\r\n        _balances[from] -= (developerTax + marketingTax);\r\n\r\n        // Add tax to developer's balance.\r\n        _balances[developerAddress] += developerTax;\r\n\r\n        // Add tax to marketing's balance.\r\n        _balances[marketingAddress] += marketingTax;\r\n\r\n                // Emit transfer events for transparency.\r\n        emit Transfer(from, developerAddress, developerTax);\r\n        emit Transfer(from, marketingAddress, marketingTax);\r\n    }\r\n\r\n    // Function to safely subtract two numbers. This prevents underflows.\r\n    function _sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"Subtraction amount exceeds balance\");\r\n        return a - b;\r\n    }\r\n\r\n    // Function to safely add two numbers. This prevents overflows.\r\n    function _add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"Addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    // Allow the developer or marketing addresses to be updated in the future, if necessary.\r\n    // Note: This can be removed if you want these addresses to remain constant.\r\n    function setDeveloperAddress(address _newDeveloperAddress) external {\r\n        require(msg.sender == developerAddress, \"Only the current developer can change the address\");\r\n        developerAddress = _newDeveloperAddress;\r\n    }\r\n\r\n    function setMarketingAddress(address _newMarketingAddress) external {\r\n        require(msg.sender == marketingAddress, \"Only the current marketer can change the address\");\r\n        marketingAddress = _newMarketingAddress;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_developerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketingAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newDeveloperAddress\",\"type\":\"address\"}],\"name\":\"setDeveloperAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMarketingAddress\",\"type\":\"address\"}],\"name\":\"setMarketingAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MemeCoin", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000e9e32d8e7997ffae59dfcfa200e5ed4b515858bf000000000000000000000000e9e32d8e7997ffae59dfcfa200e5ed4b515858bf", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://abaf0df77f2c0ff29d6d9b2c3e817cbe22b63f7cbd4b2359de3c45030d9041ad"}