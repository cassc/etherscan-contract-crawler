{"SourceCode": "// Sources flattened with hardhat v2.12.6 https://hardhat.org\r\n\r\n// File contracts/interfaces/IMintFactory.sol\r\n\r\n// SPDX-License-Identifier: UNLICENSED\r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\npragma solidity 0.8.17;\r\n\r\ninterface IMintFactory {\r\n\r\n    struct TaxHelper {\r\n        string Name;\r\n        address Address;\r\n        uint Index;\r\n    }\r\n\r\n    function addTaxHelper(string calldata _name, address _address) external;\r\n\r\n    function updateTaxHelper(uint _index, address _address) external;\r\n\r\n    function getTaxHelperAddress(uint _index) external view returns(address);\r\n\r\n    function getTaxHelpersDataByIndex(uint _index) external view returns(TaxHelper memory);\r\n\r\n    function registerToken (address _tokenOwner, address _tokenAddress) external;\r\n\r\n    function tokenIsRegistered(address _tokenAddress) external view returns (bool);\r\n\r\n    function tokenGeneratorsLength() external view returns (uint256);\r\n\r\n    function tokenGeneratorIsAllowed(address _tokenGenerator) external view returns (bool);\r\n\r\n    function getFacetHelper() external view returns (address);\r\n\r\n    function updateFacetHelper(address _newFacetHelperAddress) external;\r\n\r\n    function getFeeHelper() external view returns (address);\r\n\r\n    function updateFeeHelper(address _newFeeHelperAddress) external;\r\n    \r\n    function getLosslessController() external view returns (address);\r\n\r\n    function updateLosslessController(address _newLosslessControllerAddress) external;\r\n}\r\n\r\n\r\n// File contracts/interfaces/ITaxHelper.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n\r\n\r\ninterface ITaxHelper {\r\n\r\n    function initiateBuyBackTax(\r\n        address _token,\r\n        address _wallet\r\n    ) external returns (bool);\r\n\r\n    function initiateLPTokenTax(        \r\n        address _token,\r\n        address _wallet\r\n    ) external returns (bool);\r\n\r\n    function lpTokenHasReserves(address _lpToken) external view returns (bool);\r\n\r\n    function createLPToken() external returns (address lpToken);\r\n\r\n    function sync(address _lpToken) external;\r\n}\r\n\r\n\r\n// File contracts/interfaces/IERC20.sol\r\n\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.0.0\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File contracts/interfaces/ITaxToken.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n\r\ninterface ITaxToken is IERC20 {\r\n\r\n    function taxHelperIndex()external view returns(uint);\r\n\r\n    function buyBackBurn(uint256 _amount) external;\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function pairAddress() external view returns (address);\r\n    function decimals() external view returns (uint8);\r\n\r\n}\r\n\r\n\r\n// File contracts/libraries/Context.sol\r\n\r\n// \r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.0.0\r\n\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/Ownable.sol\r\n\r\n// \r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.0.0\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/BuyBackWallet.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n\r\ncontract BuyBackWallet is Ownable{\r\n    \r\n\r\n    ITaxToken public token; \r\n    IMintFactory public factory;\r\n    uint256 private threshold;\r\n\r\n    event UpdatedThreshold(uint256 _newThreshold);\r\n    event ETHtoTaxHelper(uint256 amount);\r\n\r\n\r\n    constructor(address _factory, address _token, uint256 _newThreshold) {\r\n        token = ITaxToken(_token);\r\n        factory = IMintFactory(_factory);\r\n        threshold = _newThreshold;\r\n        emit UpdatedThreshold(_newThreshold);\r\n        transferOwnership(_token);\r\n    }\r\n    \r\n    function checkBuyBackTrigger() public view returns (bool) {\r\n        return address(this).balance > threshold;\r\n    }\r\n\r\n    function getBalance() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function sendEthToTaxHelper() external returns (uint256) {\r\n        uint index = token.taxHelperIndex();\r\n        require(msg.sender == factory.getTaxHelperAddress(index), \"RA\");\r\n        uint256 amount = address(this).balance;\r\n        (bool sent,) = msg.sender.call{value: amount}(\"\");\r\n        require(sent, \"Failed to send Ether\");\r\n        emit ETHtoTaxHelper(amount);\r\n        return amount;\r\n    }\r\n\r\n    function updateThreshold(uint256 _newThreshold) external onlyOwner {\r\n        threshold = _newThreshold;\r\n        emit UpdatedThreshold(_newThreshold);\r\n    }\r\n\r\n    function getThreshold() external view returns (uint256) {\r\n        return threshold;\r\n    }\r\n\r\n    receive() payable external {\r\n    }\r\n}\r\n\r\n\r\n// File contracts/FacetHelper.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n\r\ncontract FacetHelper is Ownable{\r\n\r\n    event AddedFacet(address _newFacet);\r\n    event AddedSelector(address _facet, bytes4 _sig);\r\n    event RemovedSelector(bytes4 _sig);\r\n    event ResetStorage();\r\n\r\n    event UpdatedSettingsFacet(address _newAddress);\r\n    event UpdatedLosslessFacet(address _newAddress);\r\n    event UpdatedTaxFacet(address _newAddress);\r\n    event UpdatedConstructorFacet(address _newAddress);\r\n    event UpdatedWalletsFacet(address _newAddress);\r\n    event UpdatedAntiBotFacet(address _newAddress);\r\n    event UpdatedMulticallFacet(address _newAddress);\r\n\r\n    struct Facets {\r\n        address Settings;\r\n        address Lossless;\r\n        address Tax;\r\n        address Constructor;\r\n        address Wallets;\r\n        address AntiBot;\r\n        address Multicall;\r\n    }\r\n\r\n    struct FacetAddressAndPosition {\r\n        address facetAddress;\r\n        uint16 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\r\n    }\r\n\r\n    struct FacetFunctionSelectors {\r\n        bytes4[] functionSelectors;\r\n        uint16 facetAddressPosition; // position of facetAddress in facetAddresses array\r\n    }\r\n\r\n    // maps function selector to the facet address and\r\n    // the position of the selector in the facetFunctionSelectors.selectors array\r\n    mapping(bytes4 => FacetAddressAndPosition) _selectorToFacetAndPosition;\r\n    // maps facet addresses to function selectors\r\n    mapping(address => FacetFunctionSelectors) _facetFunctionSelectors;\r\n    // facet addresses\r\n    address[] _facetAddresses;\r\n    // Used to query if a contract implements an interface.\r\n    // Used to implement ERC-165.\r\n    mapping(bytes4 => bool) supportedInterfaces;\r\n\r\n    Facets public facetsInfo;\r\n\r\n    enum FacetCutAction {Add, Replace, Remove}\r\n    // Add=0, Replace=1, Remove=2\r\n\r\n    struct FacetCut {\r\n        address facetAddress;\r\n        FacetCutAction action;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    struct Facet {\r\n        address facetAddress;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Gets all facets and their selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external view returns (Facet[] memory facets_) {\r\n        uint256 numFacets = _facetAddresses.length;\r\n        facets_ = new Facet[](numFacets);\r\n        for (uint256 i; i < numFacets; i++) {\r\n            address facetAddress_ = _facetAddresses[i];\r\n            facets_[i].facetAddress = facetAddress_;\r\n            facets_[i].functionSelectors = _facetFunctionSelectors[facetAddress_].functionSelectors;\r\n        }\r\n    }\r\n\r\n    /// @notice Gets all the function selectors provided by a facet.\r\n    /// @param _facet The facet address.\r\n    /// @return facetFunctionSelectors_\r\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_) {\r\n        facetFunctionSelectors_ = _facetFunctionSelectors[_facet].functionSelectors;\r\n    }\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses() external view returns (address[] memory facetAddresses_) {\r\n        facetAddresses_ = _facetAddresses;\r\n    }\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_) {\r\n        facetAddress_ = _selectorToFacetAndPosition[_functionSelector].facetAddress;\r\n    }\r\n\r\n    // This implements ERC-165.\r\n    function supportsInterface(bytes4 _interfaceId) external view returns (bool) {\r\n        return supportedInterfaces[_interfaceId];\r\n    }\r\n\r\n    event DiamondCut(FacetCut[] _diamondCut);\r\n\r\n    function diamondCut(\r\n        FacetCut[] memory _diamondCut\r\n    ) public onlyOwner {\r\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\r\n            FacetCutAction action = _diamondCut[facetIndex].action;\r\n            if (action == FacetCutAction.Add) {\r\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\r\n            } else if (action == FacetCutAction.Replace) {\r\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\r\n            } else if (action == FacetCutAction.Remove) {\r\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\r\n            } else {\r\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\r\n            }\r\n        }\r\n        emit DiamondCut(_diamondCut);\r\n    }\r\n\r\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\r\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\r\n        // uint16 selectorCount = uint16(diamondStorage().selectors.length);\r\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\r\n        uint16 selectorPosition = uint16(_facetFunctionSelectors[_facetAddress].functionSelectors.length);\r\n        // add new facet address if it does not exist\r\n        if (selectorPosition == 0) {\r\n            enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\r\n            _facetFunctionSelectors[_facetAddress].facetAddressPosition = uint16(_facetAddresses.length);\r\n            _facetAddresses.push(_facetAddress);\r\n        }\r\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\r\n            bytes4 selector = _functionSelectors[selectorIndex];\r\n            address oldFacetAddress = _selectorToFacetAndPosition[selector].facetAddress;\r\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\r\n            _facetFunctionSelectors[_facetAddress].functionSelectors.push(selector);\r\n            _selectorToFacetAndPosition[selector].facetAddress = _facetAddress;\r\n            _selectorToFacetAndPosition[selector].functionSelectorPosition = selectorPosition;\r\n            selectorPosition++;\r\n        }\r\n    }\r\n\r\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\r\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\r\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\r\n        uint16 selectorPosition = uint16(_facetFunctionSelectors[_facetAddress].functionSelectors.length);\r\n        // add new facet address if it does not exist\r\n        if (selectorPosition == 0) {\r\n            enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\r\n            _facetFunctionSelectors[_facetAddress].facetAddressPosition = uint16(_facetAddresses.length);\r\n            _facetAddresses.push(_facetAddress);\r\n        }\r\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\r\n            bytes4 selector = _functionSelectors[selectorIndex];\r\n            address oldFacetAddress = _selectorToFacetAndPosition[selector].facetAddress;\r\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\r\n            removeFunction(oldFacetAddress, selector);\r\n            // add function\r\n            _selectorToFacetAndPosition[selector].functionSelectorPosition = selectorPosition;\r\n            _facetFunctionSelectors[_facetAddress].functionSelectors.push(selector);\r\n            _selectorToFacetAndPosition[selector].facetAddress = _facetAddress;\r\n            selectorPosition++;\r\n        }\r\n    }\r\n\r\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\r\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\r\n        // if function does not exist then do nothing and return\r\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\r\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\r\n            bytes4 selector = _functionSelectors[selectorIndex];\r\n            address oldFacetAddress = _selectorToFacetAndPosition[selector].facetAddress;\r\n            removeFunction(oldFacetAddress, selector);\r\n        }\r\n    }\r\n\r\n    function removeFunction(address _facetAddress, bytes4 _selector) internal {\r\n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\r\n        // an immutable function is a function defined directly in a diamond\r\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\r\n        // replace selector with last selector, then delete last selector\r\n        uint256 selectorPosition = _selectorToFacetAndPosition[_selector].functionSelectorPosition;\r\n        uint256 lastSelectorPosition = _facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\r\n        // if not the same then replace _selector with lastSelector\r\n        if (selectorPosition != lastSelectorPosition) {\r\n            bytes4 lastSelector = _facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\r\n            _facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\r\n            _selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint16(selectorPosition);\r\n        }\r\n        // delete the last selector\r\n        _facetFunctionSelectors[_facetAddress].functionSelectors.pop();\r\n        delete _selectorToFacetAndPosition[_selector];\r\n\r\n        // if no more selectors for facet address then delete the facet address\r\n        if (lastSelectorPosition == 0) {\r\n            // replace facet address with last facet address and delete last facet address\r\n            uint256 lastFacetAddressPosition = _facetAddresses.length - 1;\r\n            uint256 facetAddressPosition = _facetFunctionSelectors[_facetAddress].facetAddressPosition;\r\n            if (facetAddressPosition != lastFacetAddressPosition) {\r\n                address lastFacetAddress = _facetAddresses[lastFacetAddressPosition];\r\n                _facetAddresses[facetAddressPosition] = lastFacetAddress;\r\n                _facetFunctionSelectors[lastFacetAddress].facetAddressPosition = uint16(facetAddressPosition);\r\n            }\r\n            _facetAddresses.pop();\r\n            delete _facetFunctionSelectors[_facetAddress].facetAddressPosition;\r\n        }\r\n    }\r\n\r\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\r\n        uint256 contractSize;\r\n        assembly {\r\n            contractSize := extcodesize(_contract)\r\n        }\r\n        require(contractSize > 0, _errorMessage);\r\n    }\r\n\r\n    // mapping(bytes4 => address) public selectorToFacet;\r\n    // bytes4[] public selectorsList;\r\n    // mapping(address => bool) public isFacet;\r\n    // address[] public facetsList;\r\n\r\n    // function addFacet(address _newFacet) public onlyOwner {\r\n    //     isFacet[_newFacet] = true;\r\n    //     facetsList.push(_newFacet);\r\n    //     emit AddedFacet(_newFacet);\r\n    // }\r\n\r\n    // function batchAddSelectors(address _facet, bytes4[] memory _sigs) public onlyOwner {\r\n    //     for(uint256 index; index < _sigs.length; index++) {\r\n    //         addSelector(_facet, _sigs[index]);\r\n    //     }\r\n    // }\r\n\r\n    // function addSelector(address _facet, bytes4 _sig) public onlyOwner {\r\n    //     require(selectorToFacet[_sig] == address(0));\r\n    //     // require(isFacet[_facet]);\r\n    //     selectorToFacet[_sig] = _facet;\r\n    //     selectorsList.push(_sig);\r\n    //     emit AddedSelector(_facet, _sig);\r\n    // }\r\n\r\n    // Removing of the selectors occurs during resetFacetStorage();\r\n    // it is easier to reset and rebuild using the script when deploying and updating the facets\r\n    // function removeSelector(bytes4 _sig) public onlyOwner {\r\n    //     selectorToFacet[_sig] = address(0);\r\n    //     emit RemovedSelector(_sig);\r\n    // }    \r\n\r\n    // function getFacetAddressFromSelector(bytes4 _sig) public view returns (address) {\r\n    //     return selectorToFacet[_sig];\r\n    // }\r\n\r\n    // function getFacetByIndex(uint256 _index) public view returns(address) {\r\n    //     return facetsList[_index];\r\n    // }\r\n\r\n    // function resetFacetStorage() public onlyOwner {\r\n    //     for(uint i = 0; i < selectorsList.length; i++) {\r\n    //         bytes4 sig = selectorsList[i];\r\n    //         selectorToFacet[sig] = address(0);\r\n    //     }\r\n    //     delete selectorsList;\r\n\r\n    //     for(uint i = 0; i < facetsList.length; i++) {\r\n    //         address facet = facetsList[i];\r\n    //         isFacet[facet] = false;\r\n    //     }\r\n    //     delete facetsList;\r\n\r\n    //     emit ResetStorage();\r\n    // }\r\n\r\n        // Facet getters and setters\r\n\r\n    function getSettingsFacet() public view returns (address) {\r\n        return facetsInfo.Settings;\r\n    }\r\n\r\n    function updateSettingsFacet(address _newSettingsAddress) public onlyOwner {\r\n        facetsInfo.Settings = _newSettingsAddress;\r\n        emit UpdatedSettingsFacet(_newSettingsAddress);\r\n    }\r\n\r\n    function getLosslessFacet() public view returns (address) {\r\n        return facetsInfo.Lossless;\r\n    }\r\n\r\n    function updateLosslessFacet(address _newLosslessAddress) public onlyOwner {\r\n        facetsInfo.Lossless = _newLosslessAddress;\r\n        emit UpdatedLosslessFacet(_newLosslessAddress);\r\n    }\r\n\r\n    function getTaxFacet() public view returns (address) {\r\n        return facetsInfo.Tax;\r\n    }\r\n\r\n    function updateTaxFacet(address _newTaxAddress) public onlyOwner {\r\n        facetsInfo.Tax = _newTaxAddress;\r\n        emit UpdatedTaxFacet(_newTaxAddress);\r\n    }\r\n\r\n    function getConstructorFacet() public view returns (address) {\r\n        return facetsInfo.Constructor;\r\n    }\r\n\r\n    function updateConstructorFacet(address _newConstructorAddress) public onlyOwner {\r\n        facetsInfo.Constructor = _newConstructorAddress;\r\n        emit UpdatedConstructorFacet(_newConstructorAddress);\r\n    }\r\n\r\n    function getWalletsFacet() public view returns (address) {\r\n        return facetsInfo.Wallets;\r\n    }\r\n\r\n    function updateWalletsFacet(address _newWalletsAddress) public onlyOwner {\r\n        facetsInfo.Wallets = _newWalletsAddress;\r\n        emit UpdatedWalletsFacet(_newWalletsAddress);\r\n    }\r\n\r\n    function getAntiBotFacet() public view returns (address) {\r\n        return facetsInfo.AntiBot;\r\n    }\r\n\r\n    function updateAntiBotFacet(address _newAntiBotAddress) public onlyOwner {\r\n        facetsInfo.AntiBot = _newAntiBotAddress;\r\n        emit UpdatedAntiBotFacet(_newAntiBotAddress);\r\n    }\r\n\r\n    function getMulticallFacet() public view returns (address) {\r\n        return facetsInfo.Multicall;\r\n    }\r\n\r\n    function updateMulticallFacet(address _newWalletsAddress) public onlyOwner {\r\n        facetsInfo.Multicall = _newWalletsAddress;\r\n        emit UpdatedMulticallFacet(_newWalletsAddress);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/ILosslessController.sol\r\n\r\n// \r\n\r\n\r\n\r\ninterface ILosslessController {\r\n    \r\n    function pause() external;\r\n    function unpause() external;\r\n    function setAdmin(address _newAdmin) external;\r\n    function setRecoveryAdmin(address _newRecoveryAdmin) external;\r\n\r\n    function beforeTransfer(address _sender, address _recipient, uint256 _amount) external;\r\n    function beforeTransferFrom(address _msgSender, address _sender, address _recipient, uint256 _amount) external;\r\n    function beforeApprove(address _sender, address _spender, uint256 _amount) external;\r\n    function beforeIncreaseAllowance(address _msgSender, address _spender, uint256 _addedValue) external;\r\n    function beforeDecreaseAllowance(address _msgSender, address _spender, uint256 _subtractedValue) external;\r\n    function beforeMint(address _to, uint256 _amount) external;\r\n    function beforeBurn(address _account, uint256 _amount) external;\r\n    function afterTransfer(address _sender, address _recipient, uint256 _amount) external;\r\n\r\n\r\n    event AdminChange(address indexed _newAdmin);\r\n    event RecoveryAdminChange(address indexed _newAdmin);\r\n}\r\n\r\n\r\n// File contracts/facets/Storage.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n\r\nstruct Storage {\r\n\r\n    uint256 CONTRACT_VERSION;\r\n\r\n\r\n    TaxSettings taxSettings;\r\n    TaxSettings isLocked;\r\n    Fees fees;\r\n    CustomTax[] customTaxes;\r\n\r\n    address transactionTaxWallet;\r\n    uint256 customTaxLength;\r\n    uint256 MaxTax;\r\n    uint8 MaxCustom;\r\n\r\n    uint256 DENOMINATOR;\r\n\r\n    mapping (address => uint256) _rOwned;\r\n    mapping (address => uint256) _tOwned;\r\n    mapping (address => mapping (address => uint256)) _allowances;\r\n\r\n    mapping (address => bool) _isExcluded;\r\n    address[] _excluded;\r\n   \r\n    uint256 MAX;\r\n    uint256 _tTotal;\r\n    uint256 _rTotal;\r\n    uint256 _tFeeTotal;\r\n\r\n    mapping (address => bool) lpTokens;\r\n    \r\n    string _name;\r\n    string _symbol;\r\n    uint8 _decimals;\r\n    address _creator;\r\n\r\n    address factory;\r\n\r\n    address buyBackWallet;\r\n    address lpWallet;\r\n\r\n    bool isPaused;\r\n\r\n    bool isTaxed;\r\n    \r\n    mapping(address => bool) blacklist;\r\n    mapping(address => bool) swapWhitelist;\r\n    mapping(address => bool) maxBalanceWhitelist;\r\n    mapping(address => bool) taxWhitelist;\r\n\r\n    address pairAddress;\r\n\r\n    uint256 taxHelperIndex;\r\n\r\n    // AntiBot Variables\r\n\r\n    bool marketInit;\r\n    uint256 marketInitBlockTime;\r\n\r\n    AntiBotSettings antiBotSettings;\r\n\r\n    mapping (address => uint256) antiBotBalanceTracker;\r\n\r\n    uint256 maxBalanceAfterBuy;\r\n    \r\n    SwapWhitelistingSettings swapWhitelistingSettings;\r\n\r\n    // Lossless data and events\r\n\r\n    address recoveryAdmin;\r\n    address recoveryAdminCandidate;\r\n    bytes32 recoveryAdminKeyHash;\r\n    address admin;\r\n    uint256 timelockPeriod;\r\n    uint256 losslessTurnOffTimestamp;\r\n    bool isLosslessTurnOffProposed;\r\n    bool isLosslessOn;\r\n}\r\n\r\nstruct TaxSettings {\r\n    bool transactionTax;\r\n    bool buyBackTax;\r\n    bool holderTax;\r\n    bool lpTax;\r\n    bool canBlacklist;\r\n    bool canMint;\r\n    bool canPause;\r\n    bool maxBalanceAfterBuy;\r\n}\r\n\r\nstruct Fee {\r\n    uint256 buy;\r\n    uint256 sell;\r\n}\r\n\r\nstruct Fees {\r\n    Fee transactionTax;\r\n    uint256 buyBackTax;\r\n    uint256 holderTax;\r\n    uint256 lpTax;\r\n}\r\n\r\nstruct CustomTax {\r\n    string name;\r\n    Fee fee;\r\n    address wallet;\r\n    bool withdrawAsGas;\r\n}\r\n\r\nstruct AntiBotSettings {\r\n    uint256 startBlock;\r\n    uint256 endDate;\r\n    uint256 increment;\r\n    uint256 initialMaxHold;\r\n    bool isActive;\r\n}\r\n\r\nstruct SwapWhitelistingSettings {\r\n    uint256 endDate;\r\n    bool isActive;\r\n}\r\n\r\n\r\n// File contracts/facets/AntiBot.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n\r\ncontract AntiBotFacet is Ownable {\r\n    Storage internal s;\r\n\r\n    event UpdatedAntiBotIncrement(uint256 _updatedIncrement);\r\n    event UpdatedAntiBotEndDate(uint256 _updatedEndDate);\r\n    event UpdatedAntiBotInitialMaxHold(uint256 _updatedInitialMaxHold);\r\n    event UpdatedAntiBotActiveStatus(bool _isActive);\r\n    event UpdatedSwapWhitelistingEndDate(uint256 _updatedEndDate);\r\n    event UpdatedSwapWhitelistingActiveStatus(bool _isActive);\r\n    event UpdatedMaxBalanceAfterBuy(uint256 _newMaxBalance);\r\n\r\n    event AddedMaxBalanceWhitelistAddress(address _address);   \r\n    event RemovedMaxBalanceWhitelistAddress(address _address);        \r\n    event AddedSwapWhitelistAddress(address _address);\r\n    event RemovedSwapWhitelistAddress(address _address);\r\n    \r\n    // AntiBot\r\n\r\n    function antiBotIsActiveModifier() view internal {\r\n        require(s.antiBotSettings.isActive, \"ABD\");\r\n    }\r\n\r\n    modifier antiBotIsActive() {\r\n        antiBotIsActiveModifier();\r\n        _;\r\n    }\r\n\r\n    function setIncrement(uint256 _updatedIncrement) public onlyOwner antiBotIsActive {\r\n        s.antiBotSettings.increment = _updatedIncrement;\r\n        emit UpdatedAntiBotIncrement(_updatedIncrement);\r\n    }\r\n\r\n    function setEndDate( uint256 _updatedEndDate) public onlyOwner antiBotIsActive {\r\n        require(_updatedEndDate <= 48, \"ED\");\r\n        s.antiBotSettings.endDate = _updatedEndDate;\r\n        emit UpdatedAntiBotEndDate(_updatedEndDate);\r\n    }\r\n\r\n    function setInitialMaxHold( uint256 _updatedInitialMaxHold) public onlyOwner antiBotIsActive {\r\n        s.antiBotSettings.initialMaxHold = _updatedInitialMaxHold;\r\n        emit UpdatedAntiBotInitialMaxHold(_updatedInitialMaxHold);\r\n    }\r\n\r\n    function updateAntiBot(bool _isActive) public onlyOwner {\r\n        require(!s.marketInit, \"AMIE\");\r\n        s.antiBotSettings.isActive = _isActive;\r\n        emit UpdatedAntiBotActiveStatus(_isActive);\r\n    }\r\n\r\n    function antiBotCheck(uint256 amount, address receiver) public returns(bool) {\r\n        // restrict it to being only called by registered tokens\r\n        require(IMintFactory(s.factory).tokenIsRegistered(address(this)));\r\n        require(s.marketInit, \"AMIE\");\r\n        if(block.timestamp > s.marketInitBlockTime + (s.antiBotSettings.endDate * 1 hours)) {\r\n            s.antiBotSettings.isActive = false;\r\n            return true;\r\n        }\r\n\r\n        s.antiBotBalanceTracker[receiver] += amount;\r\n        uint256 userAntiBotBalance = s.antiBotBalanceTracker[receiver];\r\n        uint256 maxAntiBotBalance = ((block.number - s.antiBotSettings.startBlock) * s.antiBotSettings.increment) + s.antiBotSettings.initialMaxHold;\r\n\r\n        require((userAntiBotBalance <= maxAntiBotBalance), \"ABMSA\");\r\n        return true;\r\n    }\r\n\r\n    // MaxBalanceAfterBuy\r\n   \r\n    function addMaxBalanceWhitelistedAddress(address _address) public onlyOwner {\r\n        require(s.taxSettings.maxBalanceAfterBuy, \"AMBABD\");\r\n        s.maxBalanceWhitelist[_address] = true;\r\n        emit AddedMaxBalanceWhitelistAddress(_address);\r\n    }\r\n\r\n    function removeMaxBalanceWhitelistedAddress(address _address) public onlyOwner {\r\n        require(s.taxSettings.maxBalanceAfterBuy, \"AMBABD\");\r\n        s.maxBalanceWhitelist[_address] = false;\r\n        emit RemovedMaxBalanceWhitelistAddress(_address);\r\n    }\r\n\r\n    function updateMaxBalanceWhitelistBatch(address[] calldata _updatedAddresses, bool _isMaxBalanceWhitelisted) public onlyOwner {\r\n        require(s.taxSettings.maxBalanceAfterBuy, \"AMBABD\");\r\n        for(uint i = 0; i < _updatedAddresses.length; i++) {\r\n            s.maxBalanceWhitelist[_updatedAddresses[i]] = _isMaxBalanceWhitelisted;\r\n            if(_isMaxBalanceWhitelisted) {\r\n                emit AddedMaxBalanceWhitelistAddress(_updatedAddresses[i]);\r\n            } else {\r\n                emit RemovedMaxBalanceWhitelistAddress(_updatedAddresses[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function isMaxBalanceWhitelisted(address _address) public view returns (bool) {\r\n        return s.maxBalanceWhitelist[_address];\r\n    }\r\n\r\n    function updateMaxBalanceAfterBuy(uint256 _updatedMaxBalanceAfterBuy) public onlyOwner {\r\n        require(s.taxSettings.maxBalanceAfterBuy, \"AMBABD\");\r\n        s.maxBalanceAfterBuy = _updatedMaxBalanceAfterBuy;\r\n        emit UpdatedMaxBalanceAfterBuy(_updatedMaxBalanceAfterBuy);\r\n    }\r\n\r\n    function maxBalanceAfterBuyCheck(uint256 amount, address receiver) public view returns(bool) {\r\n        if(s.maxBalanceWhitelist[receiver]) {\r\n            return true;\r\n        }\r\n        require(s.taxSettings.maxBalanceAfterBuy);\r\n        uint256 receiverBalance;\r\n        if(s.taxSettings.holderTax) {\r\n            receiverBalance = s._rOwned[receiver];\r\n        } else {\r\n            receiverBalance = s._tOwned[receiver];\r\n        }\r\n        receiverBalance += amount;\r\n        require(receiverBalance <= s.maxBalanceAfterBuy, \"MBAB\");\r\n        return true;\r\n    }\r\n\r\n    // SwapWhitelist\r\n\r\n    function addSwapWhitelistedAddress(address _address) public onlyOwner {\r\n        require(s.swapWhitelistingSettings.isActive, \"ASWD\");\r\n        s.swapWhitelist[_address] = true;\r\n        emit AddedSwapWhitelistAddress(_address);\r\n    }\r\n\r\n    function removeSwapWhitelistedAddress(address _address) public onlyOwner {\r\n        require(s.swapWhitelistingSettings.isActive, \"ASWD\");\r\n        s.swapWhitelist[_address] = false;\r\n        emit RemovedSwapWhitelistAddress(_address);\r\n    }\r\n\r\n    function updateSwapWhitelistBatch(address[] calldata _updatedAddresses, bool _isSwapWhitelisted) public onlyOwner {\r\n        require(s.swapWhitelistingSettings.isActive, \"ASWD\");\r\n        for(uint i = 0; i < _updatedAddresses.length; i++) {\r\n            s.swapWhitelist[_updatedAddresses[i]] = _isSwapWhitelisted;\r\n            if(_isSwapWhitelisted) {\r\n                emit AddedSwapWhitelistAddress(_updatedAddresses[i]);\r\n            } else {\r\n                emit RemovedSwapWhitelistAddress(_updatedAddresses[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function isSwapWhitelisted(address _address) public view returns (bool) {\r\n        return s.swapWhitelist[_address];\r\n    }\r\n\r\n    function setSwapWhitelistEndDate( uint256 _updatedEndDate) public onlyOwner {\r\n        require(s.swapWhitelistingSettings.isActive, \"ASWD\");\r\n        require(_updatedEndDate <= 48, \"ED\");\r\n        s.swapWhitelistingSettings.endDate = _updatedEndDate;\r\n        emit UpdatedSwapWhitelistingEndDate(_updatedEndDate);\r\n    }\r\n\r\n    function updateSwapWhitelisting(bool _isActive) public onlyOwner {\r\n        require(!s.marketInit, \"AMIE\");\r\n        s.swapWhitelistingSettings.isActive = _isActive;\r\n        emit UpdatedSwapWhitelistingActiveStatus(_isActive);\r\n    }\r\n\r\n    function swapWhitelistingCheck(address receiver) public returns(bool) {\r\n        require(s.marketInit, \"AMIE\");\r\n        if(block.timestamp > s.marketInitBlockTime + (s.swapWhitelistingSettings.endDate * 1 hours)) {\r\n            s.swapWhitelistingSettings.isActive = false;\r\n            return true;\r\n        }\r\n        require(s.swapWhitelist[receiver], \"SWL\");\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IBuyBackWallet.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n\r\n\r\ninterface IBuyBackWallet {\r\n\r\n    function checkBuyBackTrigger() external view returns (bool);\r\n\r\n    function getBalance() external view returns (uint256);\r\n\r\n    function sendEthToTaxHelper() external returns(uint256);\r\n\r\n    function updateThreshold(uint256 _newThreshold) external;\r\n\r\n    function getThreshold() external view returns (uint256);\r\n}\r\n\r\n\r\n// File contracts/interfaces/IFacetHelper.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n\r\n\r\ninterface IFacetHelper {\r\n\r\n    struct Facet {\r\n        address facetAddress;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Gets all facet addresses and their four byte function selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external view returns (Facet[] memory facets_);\r\n\r\n    /// @notice Gets all the function selectors supported by a specific facet.\r\n    /// @param _facet The facet address.\r\n    /// @return facetFunctionSelectors_\r\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\r\n\r\n    // function addFacet(address _newFacet) external;\r\n\r\n    // function addSelector(address _facet, bytes4 _sig) external;\r\n\r\n    // function removeSelector(bytes4 _sig) external;\r\n\r\n    function getFacetAddressFromSelector(bytes4 _sig) external view returns (address);\r\n\r\n    function getSettingsFacet() external view returns (address);\r\n\r\n    function updateSettingsFacet(address _newSettingsAddress) external;\r\n\r\n    function getTaxFacet() external view returns (address);\r\n\r\n    function updateTaxFacet(address _newTaxesAddress) external;\r\n\r\n    function getLosslessFacet() external view returns (address);\r\n\r\n    function updateLosslessFacet(address _newLosslessAddress) external;\r\n\r\n    function getConstructorFacet() external view returns (address);\r\n\r\n    function updateConstructorFacet(address _newConstructorAddress) external;\r\n\r\n    function getWalletsFacet() external view returns (address);\r\n\r\n    function updateWalletsFacet(address _newWalletsAddress) external;\r\n\r\n    function getAntiBotFacet() external view returns (address);\r\n\r\n    function updateAntiBotFacet(address _newWalletsAddress) external;\r\n\r\n    function getMulticallFacet() external view returns (address);\r\n\r\n    function updateMulticallFacet(address _newWalletsAddress) external;\r\n    \r\n}\r\n\r\n\r\n// File contracts/interfaces/ILPWallet.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n\r\n\r\ninterface ILPWallet {\r\n\r\n    function checkLPTrigger() external view returns (bool);\r\n\r\n    function getBalance() external view returns (uint256);\r\n\r\n    function sendEthToTaxHelper() external returns(uint256);\r\n\r\n    function transferBalanceToTaxHelper() external;\r\n\r\n    function updateThreshold(uint256 _newThreshold) external;\r\n\r\n    function getThreshold() external view returns (uint256);\r\n}\r\n\r\n\r\n// File contracts/interfaces/ISettings.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n\r\n\r\ninterface ISettingsFacet {\r\n\r\n    function getFacetAddressFromSelector(bytes4 _sig) external view returns (address);\r\n    function createBuyBackWallet(address _factory, address _token) external returns (address);\r\n    function createLPWallet(address _factory, address _token) external returns (address);\r\n}\r\n\r\n\r\n// File contracts/interfaces/IWallets.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n\r\n\r\ninterface IWalletsFacet {\r\n\r\n    function createBuyBackWallet(address _factory, address _token, uint256 _newThreshold) external returns (address);\r\n    function createLPWallet(address _factory, address _token, uint256 _newThreshold) external returns (address);\r\n\r\n    function updateBuyBackWalletThreshold(uint256 _newThreshold) external;\r\n\r\n    function updateLPWalletThreshold(uint256 _newThreshold) external;\r\n}\r\n\r\n\r\n// File contracts/facets/Constructor.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n\r\ncontract ConstructorFacet is Ownable {\r\n    Storage internal s;\r\n\r\n    event ExcludedAccount(address account);\r\n    event AdminChanged(address indexed previousAdmin, address indexed newAdmin);\r\n    event RecoveryAdminChanged(address indexed previousAdmin, address indexed newAdmin);\r\n    event UpdatedCustomTaxes(CustomTax[] _customTaxes);\r\n    event UpdatedTaxFees(Fees _updatedFees);\r\n    event UpdatedTransactionTaxAddress(address _newAddress);\r\n    event UpdatedLockedSettings(TaxSettings _updatedLocks);\r\n    event UpdatedSettings(TaxSettings _updatedSettings);\r\n    event UpdatedTaxHelperIndex(uint _newIndex);\r\n    event UpdatedAntiBotSettings(AntiBotSettings _antiBotSettings);\r\n    event UpdatedSwapWhitelistingSettings(SwapWhitelistingSettings _swapWhitelistingSettings);\r\n    event UpdatedMaxBalanceAfterBuy(uint256 _newMaxBalance);\r\n    event AddedLPToken(address _newLPToken);\r\n    event TokenCreated(string name, string symbol, uint8 decimals, uint256 totalSupply, uint256 reflectionTotalSupply);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n    struct ConstructorParams {\r\n        string name_; \r\n        string symbol_; \r\n        uint8 decimals_; \r\n        address creator_; \r\n        uint256 tTotal_;\r\n        uint256 _maxTax;\r\n        TaxSettings _settings;\r\n        TaxSettings _lockedSettings;\r\n        Fees _fees;\r\n        address _transactionTaxWallet;\r\n        CustomTax[] _customTaxes;\r\n        uint256 lpWalletThreshold;\r\n        uint256 buyBackWalletThreshold;\r\n        uint256 _taxHelperIndex;\r\n        address admin_; \r\n        address recoveryAdmin_; \r\n        bool isLossless_;\r\n        AntiBotSettings _antiBotSettings;\r\n        uint256 _maxBalanceAfterBuy;\r\n        SwapWhitelistingSettings _swapWhitelistingSettings;\r\n    }\r\n\r\n    function constructorHandler(ConstructorParams calldata params, address _factory) external {\r\n        require(IMintFactory(_factory).tokenGeneratorIsAllowed(msg.sender), \"RA\");\r\n        require(params.creator_ != address(0), \"ZA\");\r\n        require(params._transactionTaxWallet != address(0), \"ZA\");\r\n        require(params.admin_ != address(0), \"ZA\");\r\n        require(params.recoveryAdmin_ != address(0), \"ZA\");\r\n        require(_factory != address(0), \"ZA\");\r\n\r\n        // Set inital values\r\n        s.CONTRACT_VERSION = 1;\r\n        s.customTaxLength = 0;\r\n        s.MaxTax = 3000;\r\n        s.MaxCustom = 10;\r\n        s.MAX = ~uint256(0);\r\n        s.isPaused = false;\r\n        s.isTaxed = false;\r\n        s.marketInit = false;\r\n\r\n        s._name = params.name_;\r\n        s._symbol = params.symbol_;\r\n        s._decimals = params.decimals_;\r\n        s._creator = params.creator_;\r\n        s._isExcluded[params.creator_] = true;\r\n        s._excluded.push(params.creator_);\r\n        emit ExcludedAccount(s._creator);\r\n        // Lossless\r\n        s.isLosslessOn = params.isLossless_;\r\n        s.admin = params.admin_;\r\n        emit AdminChanged(address(0), s.admin);\r\n        s.recoveryAdmin = params.recoveryAdmin_;\r\n        emit RecoveryAdminChanged(address(0), s.recoveryAdmin);\r\n        s.timelockPeriod = 7 days;\r\n        address lossless = IMintFactory(_factory).getLosslessController();\r\n        s._isExcluded[lossless] = true;\r\n        s._excluded.push(lossless);\r\n        emit ExcludedAccount(lossless);\r\n        // Tax Settings\r\n        require(params._maxTax <= s.MaxTax, \"MT\");\r\n        s.MaxTax = params._maxTax;\r\n        s.taxSettings = params._settings;\r\n        emit UpdatedSettings(s.taxSettings);\r\n        s.isLocked = params._lockedSettings;\r\n        s.isLocked.holderTax = true;\r\n        if(s.taxSettings.holderTax) {\r\n            s.taxSettings.canMint = false;\r\n            s.isLocked.canMint = true;\r\n        }\r\n        emit UpdatedLockedSettings(s.isLocked);\r\n        s.fees = params._fees;\r\n        emit UpdatedTaxFees(s.fees);\r\n        require(params._customTaxes.length < s.MaxCustom + 1, \"MCT\");\r\n        for(uint i = 0; i < params._customTaxes.length; i++) {\r\n            require(params._customTaxes[i].wallet != address(0));\r\n            s.customTaxes.push(params._customTaxes[i]);\r\n        }\r\n        emit UpdatedCustomTaxes(s.customTaxes);\r\n        s.customTaxLength = params._customTaxes.length;\r\n        s.transactionTaxWallet = params._transactionTaxWallet;\r\n        emit UpdatedTransactionTaxAddress(s.transactionTaxWallet);\r\n        // Factory, Wallets, Pair Address\r\n        s.factory = _factory;\r\n        s.taxHelperIndex = params._taxHelperIndex;\r\n        emit UpdatedTaxHelperIndex(s.taxHelperIndex);\r\n        address taxHelper = IMintFactory(s.factory).getTaxHelperAddress(s.taxHelperIndex);\r\n        s.pairAddress = ITaxHelper(taxHelper).createLPToken();\r\n        addLPToken(s.pairAddress);\r\n        address wallets = IFacetHelper(IMintFactory(s.factory).getFacetHelper()).getWalletsFacet(); \r\n        s.buyBackWallet = IWalletsFacet(wallets).createBuyBackWallet(s.factory, address(this), params.buyBackWalletThreshold);\r\n        s.lpWallet = IWalletsFacet(wallets).createLPWallet(s.factory, address(this), params.lpWalletThreshold);\r\n        // Total Supply and other info\r\n        s._rTotal = (s.MAX - (s.MAX % params.tTotal_));\r\n        s._rOwned[params.creator_] = s._rTotal;\r\n        s.DENOMINATOR = 10000;\r\n        s._isExcluded[taxHelper] = true;\r\n        s._excluded.push(taxHelper);\r\n        emit ExcludedAccount(taxHelper);\r\n        require(checkMaxTax(true), \"BF\");\r\n        require(checkMaxTax(false), \"SF\");\r\n        transferOwnership(params.creator_);\r\n        _mintInitial(params.creator_, params.tTotal_);\r\n        // AntiBot Settings\r\n        require(params._antiBotSettings.endDate <= 48, \"ED\");\r\n        require(params._swapWhitelistingSettings.endDate <= 48, \"ED\");\r\n        s.antiBotSettings = params._antiBotSettings;\r\n        emit UpdatedAntiBotSettings(s.antiBotSettings);\r\n        s.maxBalanceAfterBuy = params._maxBalanceAfterBuy;\r\n        emit UpdatedMaxBalanceAfterBuy(s.maxBalanceAfterBuy);\r\n        s.swapWhitelistingSettings = params._swapWhitelistingSettings;\r\n        emit UpdatedSwapWhitelistingSettings(s.swapWhitelistingSettings);\r\n        emit TokenCreated(s._name, s._symbol, s._decimals, s._tTotal, s._rTotal);\r\n    }\r\n\r\n    function _mintInitial(address account, uint256 amount) internal virtual {\r\n        s._tTotal += amount;\r\n        s._tOwned[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function checkMaxTax(bool isBuy) internal view returns (bool) {\r\n        uint256 totalTaxes;\r\n        if(isBuy) {\r\n            totalTaxes += s.fees.transactionTax.buy;\r\n            totalTaxes += s.fees.holderTax;\r\n            for(uint i = 0; i < s.customTaxes.length; i++) {\r\n                totalTaxes += s.customTaxes[i].fee.buy;\r\n            }\r\n        } else {\r\n            totalTaxes += s.fees.transactionTax.sell;\r\n            totalTaxes += s.fees.lpTax;\r\n            totalTaxes += s.fees.holderTax;\r\n            totalTaxes += s.fees.buyBackTax;\r\n            for(uint i = 0; i < s.customTaxes.length; i++) {\r\n                totalTaxes += s.customTaxes[i].fee.sell;\r\n            }\r\n        }\r\n        if(totalTaxes <= s.MaxTax) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    function addLPToken(address _newLPToken) internal {\r\n        s.lpTokens[_newLPToken] = true;\r\n        emit AddedLPToken(_newLPToken);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/facets/Lossless.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n\r\ncontract LosslessFacet is Ownable {\r\n    Storage internal s;\r\n\r\n    event AdminChanged(address indexed previousAdmin, address indexed newAdmin);\r\n    event RecoveryAdminChangeProposed(address indexed candidate);\r\n    event RecoveryAdminChanged(address indexed previousAdmin, address indexed newAdmin);\r\n    event LosslessTurnOffProposed(uint256 turnOffDate);\r\n    event LosslessTurnedOff();\r\n    event LosslessTurnedOn();\r\n\r\n    function onlyRecoveryAdminCheck() internal view {\r\n        require(_msgSender() == s.recoveryAdmin, \"LRA\");\r\n    }\r\n\r\n    modifier onlyRecoveryAdmin() {\r\n        onlyRecoveryAdminCheck();\r\n        _;\r\n    }\r\n\r\n    // --- LOSSLESS management ---\r\n\r\n    function getAdmin() external view returns (address) {\r\n        return s.admin;\r\n    }\r\n\r\n    function setLosslessAdmin(address newAdmin) external onlyRecoveryAdmin {\r\n        require(newAdmin != address(0), \"LZ\");\r\n        emit AdminChanged(s.admin, newAdmin);\r\n        s.admin = newAdmin;\r\n    }\r\n\r\n    function transferRecoveryAdminOwnership(address candidate, bytes32 keyHash) external onlyRecoveryAdmin {\r\n        require(candidate != address(0), \"LZ\");\r\n        s.recoveryAdminCandidate = candidate;\r\n        s.recoveryAdminKeyHash = keyHash;\r\n        emit RecoveryAdminChangeProposed(candidate);\r\n    }\r\n\r\n    function acceptRecoveryAdminOwnership(bytes memory key) external {\r\n        require(_msgSender() == s.recoveryAdminCandidate, \"LC\");\r\n        require(keccak256(key) == s.recoveryAdminKeyHash, \"LIK\");\r\n        emit RecoveryAdminChanged(s.recoveryAdmin, s.recoveryAdminCandidate);\r\n        s.recoveryAdmin = s.recoveryAdminCandidate;\r\n    }\r\n\r\n    function proposeLosslessTurnOff() external onlyRecoveryAdmin {\r\n        s.losslessTurnOffTimestamp = block.timestamp + s.timelockPeriod;\r\n        s.isLosslessTurnOffProposed = true;\r\n        emit LosslessTurnOffProposed(s.losslessTurnOffTimestamp);\r\n    }\r\n\r\n    function executeLosslessTurnOff() external onlyRecoveryAdmin {\r\n        require(s.isLosslessTurnOffProposed, \"LTNP\");\r\n        require(s.losslessTurnOffTimestamp <= block.timestamp, \"LTL\");\r\n        s.isLosslessOn = false;\r\n        s.isLosslessTurnOffProposed = false;\r\n        emit LosslessTurnedOff();\r\n    }\r\n\r\n    function executeLosslessTurnOn() external onlyRecoveryAdmin {\r\n        s.isLosslessTurnOffProposed = false;\r\n        s.isLosslessOn = true;\r\n        emit LosslessTurnedOn();\r\n    }\r\n}\r\n\r\n\r\n// File contracts/facets/Multicall.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n\r\ncontract MulticallFacet is Ownable {\r\n    Storage internal s;\r\n\r\n    event UpdatedSettings(TaxSettings _updatedSettings);\r\n    event UpdatedLockedSettings(TaxSettings _updatedLocks);\r\n    event UpdatedCustomTaxes(CustomTax[] _customTaxes);\r\n    event UpdatedTaxFees(Fees _updatedFees);\r\n    event UpdatedTransactionTaxAddress(address _newAddress);\r\n    event UpdatedMaxBalanceAfterBuy(uint256 _newMaxBalance);\r\n    event UpdatedBuyBackWalletThreshold(uint256 _newThreshold);\r\n    event UpdatedLPWalletThreshold(uint256 _newThreshold);\r\n    event UpdatedAntiBotIncrement(uint256 _updatedIncrement);\r\n    event UpdatedAntiBotEndDate(uint256 _updatedEndDate);\r\n    event UpdatedAntiBotInitialMaxHold(uint256 _updatedInitialMaxHold);\r\n    event UpdatedAntiBotActiveStatus(bool _isActive);\r\n    event UpdatedSwapWhitelistingEndDate(uint256 _updatedEndDate);\r\n    event UpdatedSwapWhitelistingActiveStatus(bool _isActive);\r\n\r\n    struct MulticallAdminUpdateParams {\r\n        TaxSettings _taxSettings;\r\n        TaxSettings _lockSettings;\r\n        CustomTax[] _customTaxes;\r\n        Fees _fees;\r\n        address _transactionTaxWallet;\r\n        uint256 _maxBalanceAfterBuy;\r\n        uint256 _lpWalletThreshold;\r\n        uint256 _buyBackWalletThreshold;\r\n    }\r\n\r\n    function multicallAdminUpdate(MulticallAdminUpdateParams calldata params) public onlyOwner {\r\n        // Tax Settings\r\n        if(!s.isLocked.transactionTax && s.taxSettings.transactionTax != params._taxSettings.transactionTax) {\r\n            s.taxSettings.transactionTax = params._taxSettings.transactionTax;\r\n        }\r\n        if(!s.isLocked.holderTax && s.taxSettings.holderTax != params._taxSettings.holderTax && !params._taxSettings.canMint) {\r\n            s.taxSettings.holderTax = params._taxSettings.holderTax;\r\n        }\r\n        if(!s.isLocked.buyBackTax && s.taxSettings.buyBackTax != params._taxSettings.buyBackTax) {\r\n            s.taxSettings.buyBackTax = params._taxSettings.buyBackTax;\r\n        }\r\n        if(!s.isLocked.lpTax && s.taxSettings.lpTax != params._taxSettings.lpTax) {\r\n            s.taxSettings.lpTax = params._taxSettings.lpTax;\r\n        }\r\n        if(!s.isLocked.canMint && s.taxSettings.canMint != params._taxSettings.canMint && !s.taxSettings.holderTax) {\r\n            s.taxSettings.canMint = params._taxSettings.canMint;\r\n        }\r\n        if(!s.isLocked.canPause && s.taxSettings.canPause != params._taxSettings.canPause) {\r\n            s.taxSettings.canPause = params._taxSettings.canPause;\r\n        }\r\n        if(!s.isLocked.canBlacklist && s.taxSettings.canBlacklist != params._taxSettings.canBlacklist) {\r\n            s.taxSettings.canBlacklist = params._taxSettings.canBlacklist;\r\n        }\r\n        if(!s.isLocked.maxBalanceAfterBuy && s.taxSettings.maxBalanceAfterBuy != params._taxSettings.maxBalanceAfterBuy) {\r\n            s.taxSettings.maxBalanceAfterBuy = params._taxSettings.maxBalanceAfterBuy;\r\n        }\r\n        emit UpdatedSettings(s.taxSettings);\r\n\r\n\r\n        // Lock Settings\r\n        if(!s.isLocked.transactionTax) {\r\n            s.isLocked.transactionTax = params._lockSettings.transactionTax;\r\n        }\r\n        if(!s.isLocked.holderTax) {\r\n            s.isLocked.holderTax = params._lockSettings.holderTax;\r\n        }\r\n        if(!s.isLocked.buyBackTax) {\r\n            s.isLocked.buyBackTax = params._lockSettings.buyBackTax;\r\n        }\r\n        if(!s.isLocked.lpTax) {\r\n            s.isLocked.lpTax = params._lockSettings.lpTax;\r\n        }\r\n        if(!s.isLocked.canMint) {\r\n            s.isLocked.canMint = params._lockSettings.canMint;\r\n        }\r\n        if(!s.isLocked.canPause) {\r\n            s.isLocked.canPause = params._lockSettings.canPause;\r\n        }\r\n        if(!s.isLocked.canBlacklist) {\r\n            s.isLocked.canBlacklist = params._lockSettings.canBlacklist;\r\n        }\r\n        if(!s.isLocked.maxBalanceAfterBuy) {\r\n            s.isLocked.maxBalanceAfterBuy = params._lockSettings.maxBalanceAfterBuy;\r\n        }\r\n        emit UpdatedLockedSettings(s.isLocked);\r\n\r\n\r\n        // Custom Taxes\r\n        require(params._customTaxes.length < s.MaxCustom + 1, \"MCT\");\r\n        delete s.customTaxes;\r\n\r\n        for(uint i = 0; i < params._customTaxes.length; i++) {\r\n            require(params._customTaxes[i].wallet != address(0), \"ZA\");\r\n            s.customTaxes.push(params._customTaxes[i]);\r\n        }\r\n        s.customTaxLength = params._customTaxes.length;\r\n        emit UpdatedCustomTaxes(params._customTaxes);\r\n\r\n        // Fees        \r\n        s.fees.transactionTax.buy = params._fees.transactionTax.buy;\r\n        s.fees.transactionTax.sell = params._fees.transactionTax.sell;\r\n\r\n        s.fees.buyBackTax = params._fees.buyBackTax;\r\n\r\n        s.fees.holderTax = params._fees.holderTax;\r\n\r\n        s.fees.lpTax = params._fees.lpTax;\r\n\r\n        require(checkMaxTax(true), \"BF\");\r\n        require(checkMaxTax(false), \"SF\");\r\n        emit UpdatedTaxFees(params._fees);\r\n        \r\n        // transactionTax address\r\n        require(params._transactionTaxWallet != address(0), \"ZA\");\r\n        s.transactionTaxWallet = params._transactionTaxWallet;\r\n        emit UpdatedTransactionTaxAddress(params._transactionTaxWallet);\r\n\r\n        // maxBalanceAfterBuy\r\n        if(s.taxSettings.maxBalanceAfterBuy) {\r\n            s.maxBalanceAfterBuy = params._maxBalanceAfterBuy;\r\n            emit UpdatedMaxBalanceAfterBuy(params._maxBalanceAfterBuy);\r\n        }\r\n\r\n        // update wallet thresholds\r\n        ILPWallet(s.lpWallet).updateThreshold(params._lpWalletThreshold);\r\n        emit UpdatedLPWalletThreshold(params._lpWalletThreshold);\r\n\r\n        IBuyBackWallet(s.buyBackWallet).updateThreshold(params._buyBackWalletThreshold);\r\n        emit UpdatedBuyBackWalletThreshold(params._buyBackWalletThreshold);\r\n    }\r\n\r\n    function checkMaxTax(bool isBuy) internal view returns (bool) {\r\n        uint256 totalTaxes;\r\n        if(isBuy) {\r\n            totalTaxes += s.fees.transactionTax.buy;\r\n            totalTaxes += s.fees.holderTax;\r\n            for(uint i = 0; i < s.customTaxes.length; i++) {\r\n                totalTaxes += s.customTaxes[i].fee.buy;\r\n            }\r\n        } else {\r\n            totalTaxes += s.fees.transactionTax.sell;\r\n            totalTaxes += s.fees.lpTax;\r\n            totalTaxes += s.fees.holderTax;\r\n            totalTaxes += s.fees.buyBackTax;\r\n            for(uint i = 0; i < s.customTaxes.length; i++) {\r\n                totalTaxes += s.customTaxes[i].fee.sell;\r\n            }\r\n        }\r\n        if(totalTaxes <= s.MaxTax) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    struct AntiBotUpdateParams {\r\n        AntiBotSettings _antiBotSettings;\r\n        SwapWhitelistingSettings _swapWhitelistingSettings;\r\n    }\r\n\r\n    // Multicall AntiBot Update\r\n    function multicallAntiBotUpdate(AntiBotUpdateParams calldata params) public onlyOwner {\r\n        // AntiBot\r\n        s.antiBotSettings.increment = params._antiBotSettings.increment;\r\n        emit UpdatedAntiBotIncrement(s.antiBotSettings.increment);\r\n\r\n        require(params._antiBotSettings.endDate <= 48, \"ED\");\r\n        s.antiBotSettings.endDate = params._antiBotSettings.endDate;\r\n        emit UpdatedAntiBotEndDate(s.antiBotSettings.endDate);\r\n\r\n        s.antiBotSettings.initialMaxHold = params._antiBotSettings.initialMaxHold;\r\n        emit UpdatedAntiBotInitialMaxHold(s.antiBotSettings.initialMaxHold);\r\n\r\n        if(!s.marketInit) {\r\n            s.antiBotSettings.isActive = params._antiBotSettings.isActive;\r\n            emit UpdatedAntiBotActiveStatus(s.antiBotSettings.isActive);\r\n        }\r\n\r\n        // SwapWhitelisting\r\n        require(params._swapWhitelistingSettings.endDate <= 48, \"ED\");\r\n        s.swapWhitelistingSettings.endDate = params._swapWhitelistingSettings.endDate;\r\n        emit UpdatedSwapWhitelistingEndDate(s.antiBotSettings.endDate);\r\n\r\n        if(!s.marketInit) {\r\n            s.swapWhitelistingSettings.isActive = params._swapWhitelistingSettings.isActive;\r\n            emit UpdatedSwapWhitelistingActiveStatus(s.swapWhitelistingSettings.isActive);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IFeeHelper.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n\r\n\r\ninterface IFeeHelper {\r\n    function getFee() view external returns(uint256);\r\n    \r\n    function getFeeDenominator() view external returns(uint256);\r\n    \r\n    function setFee(uint _fee) external;\r\n    \r\n    function getFeeAddress() view external returns(address);\r\n    \r\n    function setFeeAddress(address payable _feeAddress) external;\r\n\r\n    function getGeneratorFee() view external returns(uint256);\r\n\r\n    function setGeneratorFee(uint256 _fee) external;\r\n}\r\n\r\n\r\n// File contracts/LPWallet.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n\r\n\r\ncontract LPWallet is Ownable{\r\n\r\n    ITaxToken public token;\r\n    IMintFactory public factory;\r\n    uint256 private threshold;\r\n\r\n    event UpdatedThreshold(uint256 _newThreshold);\r\n    event ETHtoTaxHelper(uint256 amount);\r\n    event TransferBalancetoTaxHelper(uint256 tokenBalance);\r\n\r\n    constructor(address _factory, address _token, uint256 _newThreshold) {\r\n        token = ITaxToken(_token);\r\n        factory = IMintFactory(_factory);\r\n        threshold = _newThreshold;\r\n        emit UpdatedThreshold(_newThreshold);\r\n        transferOwnership(_token);\r\n    }\r\n    \r\n    function checkLPTrigger() public view returns (bool) {\r\n        return address(this).balance > threshold;\r\n    }\r\n\r\n    function getBalance() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function sendEthToTaxHelper() external returns (uint256) {\r\n        uint index = token.taxHelperIndex();\r\n        require(msg.sender == factory.getTaxHelperAddress(index), \"RA\");\r\n        uint256 amount = address(this).balance;\r\n        (bool sent,) = msg.sender.call{value: amount}(\"\");\r\n        require(sent, \"Failed to send Ether\");\r\n        emit ETHtoTaxHelper(amount);\r\n        return amount;\r\n    }\r\n\r\n    function transferBalanceToTaxHelper() external {\r\n        uint index = token.taxHelperIndex();\r\n        require(msg.sender == factory.getTaxHelperAddress(index));\r\n        uint256 tokenBalance = token.balanceOf(address(this));\r\n        token.transfer(msg.sender, tokenBalance);\r\n        emit TransferBalancetoTaxHelper(tokenBalance);\r\n    }\r\n\r\n    function updateThreshold(uint256 _newThreshold) external onlyOwner {\r\n        threshold = _newThreshold;\r\n        emit UpdatedThreshold(_newThreshold);\r\n    }\r\n\r\n    function getThreshold() external view returns (uint256) {\r\n        return threshold;\r\n    }\r\n\r\n    receive() payable external {\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n// File contracts/facets/Settings.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n\r\ncontract SettingsFacet is Ownable {\r\n    Storage internal s;\r\n\r\n    event AddedLPToken(address _newLPToken);\r\n    event RemovedLPToken(address _lpToken);\r\n    event AddedBlacklistAddress(address _address);\r\n    event RemovedBlacklistAddress(address _address);\r\n    event ToggledPause(bool _isPaused);\r\n    event UpdatedCustomTaxes(CustomTax[] _customTaxes);\r\n    event UpdatedTaxFees(Fees _updatedFees);\r\n    event UpdatedTransactionTaxAddress(address _newAddress);\r\n    event UpdatedLockedSettings(TaxSettings _updatedLocks);\r\n    event UpdatedSettings(TaxSettings _updatedSettings);\r\n    event UpdatedPairAddress(address _newPairAddress);\r\n    event UpdatedTaxHelperIndex(uint _newIndex);\r\n    event AddedTaxWhitelistAddress(address _address);   \r\n    event RemovedTaxWhitelistAddress(address _address);\r\n\r\n    function canBlacklistRequire() internal view {\r\n        require(s.taxSettings.canBlacklist, \"NB\");\r\n    }\r\n\r\n    modifier canBlacklist {\r\n        canBlacklistRequire();\r\n        _;\r\n    }\r\n\r\n    function addLPToken(address _newLPToken) public onlyOwner {\r\n        s.lpTokens[_newLPToken] = true;\r\n        emit AddedLPToken(_newLPToken);\r\n    }\r\n\r\n    function removeLPToken(address _lpToken) public onlyOwner {\r\n        s.lpTokens[_lpToken] = false;\r\n        emit RemovedLPToken(_lpToken);\r\n    }\r\n\r\n    function checkMaxTax(bool isBuy) internal view returns (bool) {\r\n        uint256 totalTaxes;\r\n        if(isBuy) {\r\n            totalTaxes += s.fees.transactionTax.buy;\r\n            totalTaxes += s.fees.holderTax;\r\n            for(uint i = 0; i < s.customTaxes.length; i++) {\r\n                totalTaxes += s.customTaxes[i].fee.buy;\r\n            }\r\n        } else {\r\n            totalTaxes += s.fees.transactionTax.sell;\r\n            totalTaxes += s.fees.lpTax;\r\n            totalTaxes += s.fees.holderTax;\r\n            totalTaxes += s.fees.buyBackTax;\r\n            for(uint i = 0; i < s.customTaxes.length; i++) {\r\n                totalTaxes += s.customTaxes[i].fee.sell;\r\n            }\r\n        }\r\n        if(totalTaxes <= s.MaxTax) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function paused() public view returns (bool) {\r\n        if(s.taxSettings.canPause == false) {\r\n            return false;\r\n        }\r\n        return s.isPaused;\r\n    }\r\n\r\n    function togglePause() public onlyOwner returns (bool) {\r\n        require(s.taxSettings.canPause, \"NP\");\r\n        s.isPaused = !s.isPaused;\r\n        emit ToggledPause(s.isPaused);\r\n        return s.isPaused;\r\n    }\r\n\r\n    function addBlacklistedAddress(address _address) public onlyOwner canBlacklist {\r\n        IFeeHelper feeHelper = IFeeHelper(IMintFactory(s.factory).getFeeHelper());\r\n        address feeAddress = feeHelper.getFeeAddress();\r\n        require(_address != feeAddress);\r\n        s.blacklist[_address] = true;\r\n        emit AddedBlacklistAddress(_address);\r\n    }\r\n\r\n    function removeBlacklistedAddress(address _address) public onlyOwner canBlacklist {\r\n        s.blacklist[_address] = false;\r\n        emit RemovedBlacklistAddress(_address);\r\n    }\r\n\r\n    function updateBlacklistBatch(address[] calldata _updatedAddresses, bool _isBlacklisted) public onlyOwner canBlacklist {\r\n        IFeeHelper feeHelper = IFeeHelper(IMintFactory(s.factory).getFeeHelper());\r\n        address feeAddress = feeHelper.getFeeAddress();\r\n        for(uint i = 0; i < _updatedAddresses.length; i++) {\r\n            if(_updatedAddresses[i] != feeAddress) {\r\n                s.blacklist[_updatedAddresses[i]] = _isBlacklisted;\r\n                if(_isBlacklisted) {\r\n                    emit AddedBlacklistAddress(_updatedAddresses[i]);\r\n                } else {\r\n                    emit RemovedBlacklistAddress(_updatedAddresses[i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function isBlacklisted(address _address) public view returns (bool) {\r\n        return s.blacklist[_address];\r\n    }\r\n\r\n    function updateCustomTaxes(CustomTax[] calldata _customTaxes) public onlyOwner {\r\n        require(_customTaxes.length < s.MaxCustom + 1, \"MCT\");\r\n        delete s.customTaxes;\r\n\r\n        for(uint i = 0; i < _customTaxes.length; i++) {\r\n            require(_customTaxes[i].wallet != address(0));\r\n            s.customTaxes.push(_customTaxes[i]);\r\n        }\r\n        s.customTaxLength = _customTaxes.length;\r\n\r\n        require(checkMaxTax(true), \"BF\");\r\n        require(checkMaxTax(false), \"SF\");\r\n        emit UpdatedCustomTaxes(_customTaxes);\r\n    }\r\n\r\n    function updateTaxFees(Fees calldata _updatedFees) public onlyOwner {\r\n        s.fees.transactionTax.buy = _updatedFees.transactionTax.buy;\r\n        s.fees.transactionTax.sell = _updatedFees.transactionTax.sell;\r\n\r\n        s.fees.buyBackTax = _updatedFees.buyBackTax;\r\n\r\n        s.fees.holderTax = _updatedFees.holderTax;\r\n\r\n        s.fees.lpTax = _updatedFees.lpTax;\r\n\r\n        require(checkMaxTax(true), \"BF\");\r\n        require(checkMaxTax(false), \"SF\");\r\n        emit UpdatedTaxFees(_updatedFees);\r\n    }\r\n\r\n    function updateTransactionTaxAddress(address _newAddress) public onlyOwner {\r\n        // confirm if this is updateable\r\n        require(_newAddress != address(0));\r\n        s.transactionTaxWallet = _newAddress;\r\n        emit UpdatedTransactionTaxAddress(_newAddress);\r\n    }\r\n\r\n    function lockSettings(TaxSettings calldata _updatedLocks) public onlyOwner {\r\n        if(!s.isLocked.transactionTax) {\r\n            s.isLocked.transactionTax = _updatedLocks.transactionTax;\r\n        }\r\n        if(!s.isLocked.holderTax) {\r\n            s.isLocked.holderTax = _updatedLocks.holderTax;\r\n        }\r\n        if(!s.isLocked.buyBackTax) {\r\n            s.isLocked.buyBackTax = _updatedLocks.buyBackTax;\r\n        }\r\n        if(!s.isLocked.lpTax) {\r\n            s.isLocked.lpTax = _updatedLocks.lpTax;\r\n        }\r\n        if(!s.isLocked.canMint) {\r\n            s.isLocked.canMint = _updatedLocks.canMint;\r\n        }\r\n        if(!s.isLocked.canPause) {\r\n            s.isLocked.canPause = _updatedLocks.canPause;\r\n        }\r\n        if(!s.isLocked.canBlacklist) {\r\n            s.isLocked.canBlacklist = _updatedLocks.canBlacklist;\r\n        }\r\n        if(!s.isLocked.maxBalanceAfterBuy) {\r\n            s.isLocked.maxBalanceAfterBuy = _updatedLocks.maxBalanceAfterBuy;\r\n        }\r\n        emit UpdatedLockedSettings(s.isLocked);\r\n    }\r\n\r\n    function updateSettings(TaxSettings calldata _updatedSettings) public onlyOwner {\r\n        if(!s.isLocked.transactionTax && s.taxSettings.transactionTax != _updatedSettings.transactionTax) {\r\n            s.taxSettings.transactionTax = _updatedSettings.transactionTax;\r\n        }\r\n        if(!s.isLocked.holderTax && s.taxSettings.holderTax != _updatedSettings.holderTax && !_updatedSettings.canMint) {\r\n            s.taxSettings.holderTax = _updatedSettings.holderTax;\r\n        }\r\n        if(!s.isLocked.buyBackTax && s.taxSettings.buyBackTax != _updatedSettings.buyBackTax) {\r\n            s.taxSettings.buyBackTax = _updatedSettings.buyBackTax;\r\n        }\r\n        if(!s.isLocked.lpTax && s.taxSettings.lpTax != _updatedSettings.lpTax) {\r\n            s.taxSettings.lpTax = _updatedSettings.lpTax;\r\n        }\r\n        if(!s.isLocked.canMint && s.taxSettings.canMint != _updatedSettings.canMint && !s.taxSettings.holderTax) {\r\n            s.taxSettings.canMint = _updatedSettings.canMint;\r\n        }\r\n        if(!s.isLocked.canPause && s.taxSettings.canPause != _updatedSettings.canPause) {\r\n            s.taxSettings.canPause = _updatedSettings.canPause;\r\n        }\r\n        if(!s.isLocked.canBlacklist && s.taxSettings.canBlacklist != _updatedSettings.canBlacklist) {\r\n            s.taxSettings.canBlacklist = _updatedSettings.canBlacklist;\r\n        }\r\n        if(!s.isLocked.maxBalanceAfterBuy && s.taxSettings.maxBalanceAfterBuy != _updatedSettings.maxBalanceAfterBuy) {\r\n            s.taxSettings.maxBalanceAfterBuy = _updatedSettings.maxBalanceAfterBuy;\r\n        }\r\n        emit UpdatedSettings(s.taxSettings);\r\n    }\r\n\r\n    function updatePairAddress(address _newPairAddress) public onlyOwner {\r\n        s.pairAddress = _newPairAddress;\r\n        s.lpTokens[_newPairAddress] = true;\r\n        emit AddedLPToken(_newPairAddress);\r\n        emit UpdatedPairAddress(_newPairAddress);\r\n    }\r\n\r\n    function updateTaxHelperIndex(uint8 _newIndex) public onlyOwner {\r\n        s.taxHelperIndex = _newIndex;\r\n        emit UpdatedTaxHelperIndex(_newIndex);\r\n    }\r\n\r\n    function addTaxWhitelistedAddress(address _address) public onlyOwner {\r\n        s.taxWhitelist[_address] = true;\r\n        emit AddedTaxWhitelistAddress(_address);\r\n    }\r\n\r\n    function removeTaxWhitelistedAddress(address _address) public onlyOwner {\r\n        s.taxWhitelist[_address] = false;\r\n        emit RemovedTaxWhitelistAddress(_address);\r\n    }\r\n\r\n    function updateTaxWhitelistBatch(address[] calldata _updatedAddresses, bool _isTaxWhitelisted) public onlyOwner {\r\n        for(uint i = 0; i < _updatedAddresses.length; i++) {\r\n            s.taxWhitelist[_updatedAddresses[i]] = _isTaxWhitelisted;\r\n            if(_isTaxWhitelisted) {\r\n                emit AddedTaxWhitelistAddress(_updatedAddresses[i]);\r\n            } else {\r\n                emit RemovedTaxWhitelistAddress(_updatedAddresses[i]);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/FullMath.sol\r\n\r\n// \r\n\r\n\r\n/// @title Contains 512-bit math functions\r\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\r\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\r\nlibrary FullMath {\r\n   /// @notice Calculates floor(a\u251c\u00f9b\u251c\u2556denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n/// @param a The multiplicand\r\n/// @param b The multiplier\r\n/// @param denominator The divisor\r\n/// @return result The 256-bit result\r\n/// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\r\nfunction mulDiv(\r\n    uint256 a,\r\n    uint256 b,\r\n    uint256 denominator\r\n) internal pure returns (uint256 result) {\r\n    // 512-bit multiply [prod1 prod0] = a * b\r\n    // Compute the product mod 2**256 and mod 2**256 - 1\r\n    // then use the Chinese Remainder Theorem to reconstruct\r\n    // the 512 bit result. The result is stored in two 256\r\n    // variables such that product = prod1 * 2**256 + prod0\r\n    uint256 prod0; // Least significant 256 bits of the product\r\n    uint256 prod1; // Most significant 256 bits of the product\r\n    assembly {\r\n        let mm := mulmod(a, b, not(0))\r\n        prod0 := mul(a, b)\r\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n    }\r\n\r\n    // Handle non-overflow cases, 256 by 256 division\r\n    if (prod1 == 0) {\r\n        require(denominator > 0);\r\n        assembly {\r\n            result := div(prod0, denominator)\r\n        }\r\n        return result;\r\n    }\r\n\r\n    // Make sure the result is less than 2**256.\r\n    // Also prevents denominator == 0\r\n    require(denominator > prod1);\r\n\r\n    ///////////////////////////////////////////////\r\n    // 512 by 256 division.\r\n    ///////////////////////////////////////////////\r\n\r\n    // Make division exact by subtracting the remainder from [prod1 prod0]\r\n    // Compute remainder using mulmod\r\n    uint256 remainder;\r\n    assembly {\r\n        remainder := mulmod(a, b, denominator)\r\n    }\r\n    // Subtract 256 bit number from 512 bit number\r\n    assembly {\r\n        prod1 := sub(prod1, gt(remainder, prod0))\r\n        prod0 := sub(prod0, remainder)\r\n    }\r\n\r\n    // Factor powers of two out of denominator\r\n    // Compute largest power of two divisor of denominator.\r\n    // Always >= 1.\r\n    unchecked {\r\n        uint256 twos = (type(uint256).max - denominator + 1) & denominator;\r\n        // Divide denominator by power of two\r\n        assembly {\r\n            denominator := div(denominator, twos)\r\n        }\r\n\r\n        // Divide [prod1 prod0] by the factors of two\r\n        assembly {\r\n            prod0 := div(prod0, twos)\r\n        }\r\n        // Shift in bits from prod1 into prod0. For this we need\r\n        // to flip `twos` such that it is 2**256 / twos.\r\n        // If twos is zero, then it becomes one\r\n        assembly {\r\n            twos := add(div(sub(0, twos), twos), 1)\r\n        }\r\n        prod0 |= prod1 * twos;\r\n\r\n        // Invert denominator mod 2**256\r\n        // Now that denominator is an odd number, it has an inverse\r\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\r\n        // Compute the inverse by starting with a seed that is correct\r\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\r\n        uint256 inv = (3 * denominator) ^ 2;\r\n        // Now use Newton-Raphson iteration to improve the precision.\r\n        // Thanks to Hensel's lifting lemma, this also works in modular\r\n        // arithmetic, doubling the correct bits in each step.\r\n        inv *= 2 - denominator * inv; // inverse mod 2**8\r\n        inv *= 2 - denominator * inv; // inverse mod 2**16\r\n        inv *= 2 - denominator * inv; // inverse mod 2**32\r\n        inv *= 2 - denominator * inv; // inverse mod 2**64\r\n        inv *= 2 - denominator * inv; // inverse mod 2**128\r\n        inv *= 2 - denominator * inv; // inverse mod 2**256\r\n\r\n        // Because the division is now exact we can divide by multiplying\r\n        // with the modular inverse of denominator. This will give us the\r\n        // correct result modulo 2**256. Since the precoditions guarantee\r\n        // that the outcome is less than 2**256, this is the final result.\r\n        // We don't need to compute the high bits of the result and prod1\r\n        // is no longer required.\r\n        result = prod0 * inv;\r\n        return result;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates ceil(a\u251c\u00f9b\u251c\u2556denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n    /// @param a The multiplicand\r\n    /// @param b The multiplier\r\n    /// @param denominator The divisor\r\n    /// @return result The 256-bit result\r\n    function mulDivRoundingUp(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        result = mulDiv(a, b, denominator);\r\n        if (mulmod(a, b, denominator) > 0) {\r\n            require(result < type(uint256).max);\r\n            result++;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/facets/Tax.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n// This contract logs all tokens on the platform\r\n\r\n\r\ncontract TaxFacet is Ownable {\r\n    Storage internal s;\r\n\r\n    event MarketInit(uint256 timestamp, uint256 blockNumber);\r\n    event BuyBackTaxInitiated(address _sender, uint256 _fee, address _wallet, bool _isBuy);\r\n    event TransactionTaxInitiated(address _sender, uint256 _fee, address _wallet, bool _isBuy);\r\n    event LPTaxInitiated(address _sender, uint256 _fee, address _wallet, bool _isBuy);\r\n    event CustomTaxInitiated(address _sender, uint256 _fee, address _wallet, bool _isBuy);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Reflect(uint256 tAmount, uint256 rAmount, uint256 rTotal_, uint256 teeTotal_);\r\n    event ExcludedAccount(address account);\r\n    event IncludedAccount(address account);\r\n\r\n    function paused() internal view returns (bool) {\r\n        return s.isPaused;\r\n    }\r\n\r\n    function isBlacklisted(address _address) internal view returns (bool) {\r\n        return s.blacklist[_address];\r\n    }\r\n\r\n    /// @notice Handles the taxes for the token.\r\n    /// Calls the appropriate tax helper contract to handle \r\n    /// LP and BuyBack tax logic\r\n    /// @dev handles every tax within the tax facet. \r\n    /// @param sender the one sending the transaction\r\n    /// @param recipient the one receiving the transaction\r\n    /// @param amount the amount of tokens being sent\r\n    /// @return totalTaxAmount the total amount of the token taxed\r\n    function handleTaxes(address sender, address recipient, uint256 amount) public virtual returns (uint256 totalTaxAmount) {\r\n        // restrict it to being only called by registered tokens\r\n        require(IMintFactory(s.factory).tokenIsRegistered(address(this)));\r\n        bool isBuy = false;\r\n\r\n        if(s.lpTokens[sender]) {\r\n            isBuy = true;\r\n            if(!s.marketInit) {\r\n                s.marketInit = true;\r\n                s.antiBotSettings.startBlock = block.number;\r\n                s.marketInitBlockTime = block.timestamp;\r\n                emit MarketInit(block.timestamp, block.number);\r\n            }\r\n        }\r\n\r\n        if(!s.lpTokens[sender] && !s.lpTokens[recipient]) {\r\n            return 0;\r\n        }\r\n\r\n        if(isBuy && s.taxWhitelist[recipient]) {\r\n            return 0;\r\n        }\r\n\r\n        if(!isBuy && s.taxWhitelist[sender]) {\r\n            return 0;\r\n        }\r\n\r\n        ITaxHelper TaxHelper = ITaxHelper(IMintFactory(s.factory).getTaxHelperAddress(s.taxHelperIndex));\r\n        if(sender == address(TaxHelper) || recipient == address(TaxHelper)) {\r\n            return 0;\r\n        }\r\n        totalTaxAmount;\r\n        uint256 fee;\r\n        if(s.taxSettings.buyBackTax && !isBuy) {\r\n            if(TaxHelper.lpTokenHasReserves(s.pairAddress)) {\r\n                fee = amount * s.fees.buyBackTax / s.DENOMINATOR;\r\n            }\r\n            \r\n            if(fee != 0) {\r\n                _transfer(sender, address(TaxHelper), fee);\r\n\r\n                TaxHelper.initiateBuyBackTax(address(this), address(s.buyBackWallet));\r\n                emit BuyBackTaxInitiated(sender, fee, address(s.buyBackWallet), isBuy);\r\n                totalTaxAmount += fee;\r\n            }\r\n            fee = 0;\r\n        }\r\n        if(s.taxSettings.transactionTax) {\r\n            if(isBuy) {\r\n                fee = amount * s.fees.transactionTax.buy / s.DENOMINATOR;\r\n            } else {\r\n                fee = amount * s.fees.transactionTax.sell / s.DENOMINATOR;\r\n            }\r\n            if(fee != 0) {\r\n                _transfer(sender, s.transactionTaxWallet, fee);\r\n                emit TransactionTaxInitiated(sender, fee, s.transactionTaxWallet, isBuy);\r\n                totalTaxAmount += fee;\r\n            }\r\n            fee = 0;\r\n        }\r\n        if(s.taxSettings.lpTax && !isBuy) {\r\n            if(TaxHelper.lpTokenHasReserves(s.pairAddress)) {\r\n                fee = amount * s.fees.lpTax / s.DENOMINATOR;\r\n            }\r\n            if(fee != 0) {\r\n                _transfer(sender, address(TaxHelper), fee);\r\n                TaxHelper.initiateLPTokenTax(address(this), address(s.lpWallet));\r\n                emit LPTaxInitiated(sender, fee, address(s.lpWallet), isBuy);\r\n                totalTaxAmount += fee;\r\n            }\r\n            fee = 0;\r\n        }\r\n        if(s.customTaxes.length > 0) {\r\n            for(uint8 i = 0; i < s.customTaxes.length; i++) {\r\n                uint256 customFee;\r\n                if(isBuy) {\r\n                    customFee = amount * s.customTaxes[i].fee.buy / s.DENOMINATOR;\r\n                } else {\r\n                    customFee = amount * s.customTaxes[i].fee.sell / s.DENOMINATOR;\r\n                }\r\n                fee += customFee;\r\n                if(fee != 0) {\r\n                    totalTaxAmount += fee;\r\n                    _transfer(sender, s.customTaxes[i].wallet, fee);\r\n                    emit CustomTaxInitiated(sender, fee, s.customTaxes[i].wallet, isBuy);\r\n                    fee = 0;\r\n                }\r\n            }\r\n        }    \r\n    }\r\n\r\n    /// @notice internal transfer method\r\n    /// @dev includes checks for all features not handled by handleTaxes()\r\n    /// @param sender the one sending the transaction\r\n    /// @param recipient the one receiving the transaction\r\n    /// @param amount the amount of tokens being sent\r\n    function _transfer(address sender, address recipient, uint256 amount) public {\r\n        // restrict it to being only called by registered tokens\r\n        if(!IMintFactory(s.factory).tokenGeneratorIsAllowed(msg.sender)) {\r\n            require(IMintFactory(s.factory).tokenIsRegistered(address(this)));\r\n        }\r\n        require(sender != address(0), \"ETFZ\");\r\n        require(recipient != address(0), \"ETTZ\");\r\n        require(amount > 0, \"TGZ\");\r\n        require(!paused(), \"TP\");\r\n        require(!isBlacklisted(sender), \"SB\");\r\n        require(!isBlacklisted(recipient), \"RB\"); \r\n        require(!isBlacklisted(tx.origin), \"SB\");\r\n        // Reflection Transfers\r\n        if(s.taxSettings.holderTax) {\r\n            if (s._isExcluded[sender] && !s._isExcluded[recipient]) {\r\n            _transferFromExcluded(sender, recipient, amount);\r\n            } else if (!s._isExcluded[sender] && s._isExcluded[recipient]) {\r\n                _transferToExcluded(sender, recipient, amount);\r\n            } else if (!s._isExcluded[sender] && !s._isExcluded[recipient]) {\r\n                _transferStandard(sender, recipient, amount);\r\n            } else if (s._isExcluded[sender] && s._isExcluded[recipient]) {\r\n                _transferBothExcluded(sender, recipient, amount);\r\n            } else {\r\n                _transferStandard(sender, recipient, amount);\r\n            }\r\n        } else {\r\n            // Non Reflection Transfer\r\n            _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n            uint256 senderBalance = s._tOwned[sender];\r\n            require(senderBalance >= amount, \"ETA\");\r\n            s._tOwned[sender] = senderBalance - amount;\r\n            s._tOwned[recipient] += amount;\r\n\r\n            emit Transfer(sender, recipient, amount);\r\n        }\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n\r\n\r\n    // Reflection Functions\r\n\r\n\r\n    function reflect(uint256 tAmount) public {\r\n        address sender = _msgSender();\r\n        require(!s._isExcluded[sender], \"EA\");\r\n        (uint256 rAmount,,,,) = _getValues(tAmount);\r\n        s._rOwned[sender] = s._rOwned[sender] - rAmount;\r\n        s._rTotal = s._rTotal - rAmount;\r\n        s._tFeeTotal = s._tFeeTotal + tAmount;\r\n        emit Reflect(tAmount, rAmount, s._rTotal, s._tFeeTotal);\r\n        ITaxHelper TaxHelper = ITaxHelper(IMintFactory(s.factory).getTaxHelperAddress(s.taxHelperIndex));\r\n        TaxHelper.sync(s.pairAddress);\r\n    }\r\n\r\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\r\n        require(tAmount <= s._tTotal, \"ALS\");\r\n        if (!deductTransferFee) {\r\n            (uint256 rAmount,,,,) = _getValues(tAmount);\r\n            return rAmount;\r\n        } else {\r\n            (,uint256 rTransferAmount,,,) = _getValues(tAmount);\r\n            return rTransferAmount;\r\n        }\r\n    }\r\n\r\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256)  {\r\n        require(rAmount <= s._rTotal, \"ALR\");\r\n        uint256 currentRate = _getRate();\r\n        return rAmount / currentRate;\r\n    }\r\n\r\n    function excludeAccount(address account) external onlyOwner {\r\n        require(!s._isExcluded[account], \"AE\");\r\n        if(s._rOwned[account] > 0) {\r\n            s._tOwned[account] = tokenFromReflection(s._rOwned[account]);\r\n        }\r\n        s._isExcluded[account] = true;\r\n        s._excluded.push(account);\r\n        emit ExcludedAccount(account);\r\n    }\r\n\r\n    function includeAccount(address account) external onlyOwner {\r\n        require(s._isExcluded[account], \"AI\");\r\n        for (uint256 i = 0; i < s._excluded.length; i++) {\r\n            if (s._excluded[i] == account) {\r\n                s._excluded[i] = s._excluded[s._excluded.length - 1];\r\n                s._tOwned[account] = 0;\r\n                s._isExcluded[account] = false;\r\n                s._excluded.pop();\r\n                break;\r\n            }\r\n        }\r\n        emit IncludedAccount(account);\r\n    }\r\n\r\n    function isExcluded(address account) external view returns(bool) {\r\n        return s._isExcluded[account];\r\n    }\r\n\r\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\r\n        s._rOwned[sender] = s._rOwned[sender] - rAmount;\r\n        s._rOwned[recipient] = s._rOwned[recipient] + rTransferAmount;    \r\n        _reflectFee(rFee, tFee);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\r\n        s._rOwned[sender] = s._rOwned[sender] - rAmount;\r\n        s._tOwned[recipient] = s._tOwned[recipient] + tTransferAmount;\r\n        s._rOwned[recipient] = s._rOwned[recipient] + rTransferAmount;           \r\n        _reflectFee(rFee, tFee);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\r\n        s._tOwned[sender] = s._tOwned[sender] - tAmount;\r\n        s._rOwned[sender] = s._rOwned[sender] - rAmount;\r\n        s._rOwned[recipient] = s._rOwned[recipient] + rTransferAmount;   \r\n        _reflectFee(rFee, tFee);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\r\n        s._tOwned[sender] = s._tOwned[sender] - tAmount;\r\n        s._rOwned[sender] = s._rOwned[sender] - rAmount;\r\n        s._tOwned[recipient] = s._tOwned[recipient] + tTransferAmount;\r\n        s._rOwned[recipient] = s._rOwned[recipient] + rTransferAmount;        \r\n        _reflectFee(rFee, tFee);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\r\n        s._rTotal = s._rTotal - rFee;\r\n        s._tFeeTotal = s._tFeeTotal + tFee;\r\n    }\r\n\r\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256) {\r\n        (uint256 tTransferAmount, uint256 tFee) = _getTValues(tAmount);\r\n        uint256 currentRate = _getRate();\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);\r\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee);\r\n    }\r\n\r\n    function _getTValues(uint256 tAmount) private view returns (uint256, uint256) {\r\n        uint256 tFee = tAmount / s.fees.holderTax;\r\n        uint256 tTransferAmount = tAmount - tFee;\r\n        return (tTransferAmount, tFee);\r\n    }\r\n\r\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\r\n        uint256 rAmount = tAmount * currentRate;\r\n        uint256 rFee = tFee * currentRate;\r\n        uint256 rTransferAmount = rAmount - rFee;\r\n        return (rAmount, rTransferAmount, rFee);\r\n    }\r\n\r\n    function _getRate() private view returns(uint256) {\r\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n        return rSupply / tSupply;\r\n    }\r\n\r\n    function _getCurrentSupply() private view returns(uint256, uint256) {\r\n        uint256 rSupply = s._rTotal;\r\n        uint256 tSupply = s._tTotal;      \r\n        for (uint256 i = 0; i < s._excluded.length; i++) {\r\n            if (s._rOwned[s._excluded[i]] > rSupply || s._tOwned[s._excluded[i]] > tSupply) return (s._rTotal, s._tTotal);\r\n            rSupply = rSupply - s._rOwned[s._excluded[i]];\r\n            tSupply = tSupply - s._tOwned[s._excluded[i]];\r\n        }\r\n        if (rSupply < s._rTotal / s._tTotal) return (s._rTotal, s._tTotal);\r\n        return (rSupply, tSupply);\r\n    }\r\n\r\n    function burn(uint256 amount) public {\r\n        address taxHelper = IMintFactory(s.factory).getTaxHelperAddress(s.taxHelperIndex);\r\n        require(msg.sender == taxHelper || msg.sender == owner(), \"RA\");\r\n        _burn(owner(), amount);\r\n    }\r\n\r\n    /// @notice custom burn to handle reflection\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"EBZ\");\r\n\r\n        if (s.isLosslessOn) {\r\n            ILosslessController(IMintFactory(s.factory).getLosslessController()).beforeBurn(account, amount);\r\n        } \r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        if(s.taxSettings.holderTax && !s._isExcluded[account]) {\r\n            (uint256 rAmount,,,,) = _getValues(amount);\r\n            s._rOwned[account] = s._rOwned[account] - rAmount;\r\n            s._rTotal = s._rTotal - rAmount;\r\n            s._tFeeTotal = s._tFeeTotal + amount;\r\n        }\r\n\r\n        uint256 accountBalance = s._tOwned[account];\r\n        require(accountBalance >= amount, \"EBB\");\r\n        s._tOwned[account] = accountBalance - amount;\r\n        s._tTotal -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n    \r\n}\r\n\r\n\r\n// File contracts/facets/Wallets.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n\r\ncontract WalletsFacet is Ownable {\r\n    Storage internal s;\r\n\r\n    event CreatedBuyBackWallet(address _wallet);\r\n    event CreatedLPWallet(address _wallet);\r\n    event UpdatedBuyBackWalletThreshold(uint256 _newThreshold);\r\n    event UpdatedLPWalletThreshold(uint256 _newThreshold);\r\n\r\n    function createBuyBackWallet(address _factory, address _token, uint256 _newThreshold) external returns (address) {\r\n        BuyBackWallet newBuyBackWallet = new BuyBackWallet(_factory, _token,_newThreshold);\r\n        emit CreatedBuyBackWallet(address(newBuyBackWallet));\r\n        return address(newBuyBackWallet);\r\n    }\r\n\r\n    function createLPWallet(address _factory, address _token, uint256 _newThreshold) external returns (address) {\r\n        LPWallet newLPWallet = new LPWallet(_factory, _token, _newThreshold);\r\n        emit CreatedLPWallet(address(newLPWallet));\r\n        return address(newLPWallet);\r\n    }\r\n\r\n    function updateBuyBackWalletThreshold(uint256 _newThreshold) public onlyOwner {\r\n        IBuyBackWallet(s.buyBackWallet).updateThreshold(_newThreshold);\r\n        emit UpdatedBuyBackWalletThreshold(_newThreshold);\r\n    }\r\n\r\n    function updateLPWalletThreshold(uint256 _newThreshold) public onlyOwner {\r\n        ILPWallet(s.lpWallet).updateThreshold(_newThreshold);\r\n        emit UpdatedLPWalletThreshold(_newThreshold);\r\n    }\r\n\r\n}\r\n\r\n\r\n// File contracts/FeeHelper.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n\r\ncontract FeeHelper is Ownable{\r\n    \r\n    struct Settings {\r\n        uint256 GENERATOR_FEE;\r\n        uint256 FEE; \r\n        uint256 DENOMINATOR;\r\n        address payable FEE_ADDRESS;\r\n    }\r\n    \r\n    Settings public SETTINGS;\r\n    \r\n    constructor() {\r\n        SETTINGS.GENERATOR_FEE = 0;\r\n        SETTINGS.FEE = 100;\r\n        SETTINGS.DENOMINATOR = 10000;\r\n        SETTINGS.FEE_ADDRESS = payable(msg.sender);\r\n    }\r\n\r\n    function getGeneratorFee() external view returns(uint256) {\r\n        return SETTINGS.GENERATOR_FEE;\r\n    }\r\n    \r\n    function getFee() external view returns(uint256) {\r\n        return SETTINGS.FEE;\r\n    }\r\n\r\n    function getFeeDenominator() external view returns(uint256) {\r\n        return SETTINGS.DENOMINATOR;\r\n    }\r\n\r\n    function setGeneratorFee(uint256 _fee) external onlyOwner {\r\n        SETTINGS.GENERATOR_FEE = _fee;\r\n    }\r\n    \r\n    function setFee(uint _fee) external onlyOwner {\r\n        SETTINGS.FEE = _fee;\r\n    }\r\n    \r\n    function getFeeAddress() external view returns(address) {\r\n        return SETTINGS.FEE_ADDRESS;\r\n    }\r\n    \r\n    function setFeeAddress(address payable _feeAddress) external onlyOwner {\r\n        SETTINGS.FEE_ADDRESS = _feeAddress;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IUniswapV2Router01.sol\r\n\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\n// File contracts/interfaces/ICamelotV2Router.sol\r\n\r\n\r\ninterface ICamelotRouter is IUniswapV2Router01 {\r\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n    address token,\r\n    uint liquidity,\r\n    uint amountTokenMin,\r\n    uint amountETHMin,\r\n    address to,\r\n    uint deadline\r\n  ) external returns (uint amountETH);\r\n\r\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n    address token,\r\n    uint liquidity,\r\n    uint amountTokenMin,\r\n    uint amountETHMin,\r\n    address to,\r\n    uint deadline,\r\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n  ) external returns (uint amountETH);\r\n\r\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n    uint amountIn,\r\n    uint amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    address referrer,\r\n    uint deadline\r\n  ) external;\r\n\r\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n    uint amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    address referrer,\r\n    uint deadline\r\n  ) external payable;\r\n\r\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n    uint amountIn,\r\n    uint amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    address referrer,\r\n    uint deadline\r\n  ) external;\r\n\r\n\r\n}\r\n\r\n\r\n// File contracts/interfaces/IUniswapV2Router02.sol\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n\r\n// File contracts/libraries/ERC20.sol\r\n\r\n// \r\n\r\n// File @openzeppelin/contracts/token/ERC20/ERC20.sol@v4.0.0\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The defaut value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overloaded;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        _balances[account] = accountBalance - amount;\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\n\r\n// File contracts/libraries/Pausable.sol\r\n\r\n// \r\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\r\n\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused(), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/EnumerableSet.sol\r\n\r\n// \r\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\r\n\r\n\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint256` (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            if (lastIndex != toDeleteIndex) {\r\n                bytes32 lastvalue = set._values[lastIndex];\r\n\r\n                // Move the last value to the index where the value to delete is\r\n                set._values[toDeleteIndex] = lastvalue;\r\n                // Update the index for the moved value\r\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\r\n            }\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        return set._values[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function _values(Set storage set) private view returns (bytes32[] memory) {\r\n        return set._values;\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\r\n        return _values(set._inner);\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(AddressSet storage set) internal view returns (address[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        address[] memory result;\r\n\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        uint256[] memory result;\r\n\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/MintFactory.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n\r\n// This contract logs all tokens on the platform\r\n\r\n\r\ncontract MintFactory is Ownable {\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    \r\n    EnumerableSet.AddressSet private tokens;\r\n    EnumerableSet.AddressSet private tokenGenerators;\r\n\r\n    struct TaxHelper {\r\n        string Name;\r\n        address Address;\r\n        uint256 Index;\r\n    }\r\n\r\n    mapping(uint => TaxHelper) private taxHelpersData;\r\n    address[] private taxHelpers;\r\n     \r\n    mapping(address => address[]) private tokenOwners;\r\n\r\n    address private FacetHelper;\r\n    address private FeeHelper;\r\n    address private LosslessController;\r\n\r\n    event TokenRegistered(address tokenOwner, address tokenContract);\r\n    event AllowTokenGenerator(address _address, bool _allow);\r\n\r\n    event AddedTaxHelper(string _name, address _address, uint256 _index);\r\n    event UpdatedTaxHelper(address _newAddress, uint256 _index);\r\n\r\n    event UpdatedFacetHelper(address _newAddress);\r\n    event UpdatedFeeHelper(address _newAddress);\r\n    event UpdatedLosslessController(address _newAddress);\r\n    \r\n    function adminAllowTokenGenerator (address _address, bool _allow) public onlyOwner {\r\n        if (_allow) {\r\n            tokenGenerators.add(_address);\r\n        } else {\r\n            tokenGenerators.remove(_address);\r\n        }\r\n        emit AllowTokenGenerator(_address, _allow);\r\n    }\r\n\r\n    function addTaxHelper(string calldata _name, address _address) public onlyOwner {\r\n        uint256 index = taxHelpers.length;\r\n        TaxHelper memory newTaxHelper;\r\n        newTaxHelper.Name = _name;\r\n        newTaxHelper.Address = _address;\r\n        newTaxHelper.Index = index;\r\n        taxHelpersData[index] = newTaxHelper;\r\n        taxHelpers.push(_address);\r\n        emit AddedTaxHelper(_name, _address, index);\r\n    }\r\n\r\n    function updateTaxHelper(uint256 _index, address _address) public onlyOwner {\r\n        taxHelpersData[_index].Address = _address;\r\n        taxHelpers[_index] = _address;\r\n        emit UpdatedTaxHelper(_address, _index);\r\n    }\r\n\r\n    function getTaxHelperAddress(uint256 _index) public view returns(address){\r\n        return taxHelpers[_index];\r\n    }\r\n\r\n    function getTaxHelpersDataByIndex(uint256 _index) public view returns(TaxHelper memory) {\r\n        return taxHelpersData[_index];\r\n    }\r\n    \r\n    /**\r\n     * @notice called by a registered tokenGenerator upon token creation\r\n     */\r\n    function registerToken (address _tokenOwner, address _tokenAddress) public {\r\n        require(tokenGenerators.contains(msg.sender), 'FORBIDDEN');\r\n        tokens.add(_tokenAddress);\r\n        tokenOwners[_tokenOwner].push(_tokenAddress);\r\n        emit TokenRegistered(_tokenOwner, _tokenAddress);\r\n    }\r\n\r\n     /**\r\n     * @notice gets a token at index registered under a user address\r\n     * @return token addresses registered to the user address\r\n     */\r\n     function getTokenByOwnerAtIndex(address _tokenOwner, uint256 _index) external view returns(address) {\r\n         return tokenOwners[_tokenOwner][_index];\r\n     }\r\n     \r\n     /**\r\n     * @notice gets the total of tokens registered under a user address\r\n     * @return uint total of token addresses registered to the user address\r\n     */\r\n     \r\n     function getTokensLengthByOwner(address _tokenOwner) external view returns(uint256) {\r\n         return tokenOwners[_tokenOwner].length;\r\n     }\r\n    \r\n    /**\r\n     * @notice Number of allowed tokenGenerators\r\n     */\r\n    function tokenGeneratorsLength() external view returns (uint256) {\r\n        return tokenGenerators.length();\r\n    }\r\n    \r\n    /**\r\n     * @notice Gets the address of a registered tokenGenerator at specified index\r\n     */\r\n    function tokenGeneratorAtIndex(uint256 _index) external view returns (address) {\r\n        return tokenGenerators.at(_index);\r\n    }\r\n\r\n    /**\r\n     * @notice returns true if user is allowed to generate tokens\r\n     */\r\n    function tokenGeneratorIsAllowed(address _tokenGenerator) external view returns (bool) {\r\n        return tokenGenerators.contains(_tokenGenerator);\r\n    }\r\n    \r\n    /**\r\n     * @notice returns true if the token address was generated by the Unicrypt token platform\r\n     */\r\n    function tokenIsRegistered(address _tokenAddress) external view returns (bool) {\r\n        return tokens.contains(_tokenAddress);\r\n    }\r\n    \r\n    /**\r\n     * @notice The length of all tokens on the platform\r\n     */\r\n    function tokensLength() external view returns (uint256) {\r\n        return tokens.length();\r\n    }\r\n    \r\n    /**\r\n     * @notice gets a token at a specific index. Although using Enumerable Set, since tokens are only added and not removed, indexes will never change\r\n     * @return the address of the token contract at index\r\n     */\r\n    function tokenAtIndex(uint256 _index) external view returns (address) {\r\n        return tokens.at(_index);\r\n    }\r\n\r\n    // Helpers and Controllers\r\n    \r\n    function getFacetHelper() public view returns (address) {\r\n        return FacetHelper;\r\n    }\r\n\r\n    function updateFacetHelper(address _newFacetHelperAddress) public onlyOwner {\r\n        require(_newFacetHelperAddress != address(0));\r\n        FacetHelper = _newFacetHelperAddress;\r\n        emit UpdatedFacetHelper(_newFacetHelperAddress);\r\n    }\r\n\r\n    function getFeeHelper() public view returns (address) {\r\n        return FeeHelper;\r\n    }\r\n\r\n    function updateFeeHelper(address _newFeeHelperAddress) public onlyOwner {\r\n        require(_newFeeHelperAddress != address(0));\r\n        FeeHelper = _newFeeHelperAddress;\r\n        emit UpdatedFeeHelper(_newFeeHelperAddress);\r\n    }\r\n\r\n    function getLosslessController() public view returns (address) {\r\n        return LosslessController;\r\n    }\r\n\r\n    function updateLosslessController(address _newLosslessControllerAddress) public onlyOwner {\r\n        require(_newLosslessControllerAddress != address(0));\r\n        LosslessController = _newLosslessControllerAddress;\r\n        emit UpdatedLosslessController(_newLosslessControllerAddress);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/TaxToken.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n\r\n\r\ncontract TaxToken is Ownable{\r\n    Storage internal s;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    struct ConstructorParams {\r\n        string name_; \r\n        string symbol_; \r\n        uint8 decimals_; \r\n        address creator_;\r\n        uint256 tTotal_;\r\n        uint256 _maxTax;\r\n        TaxSettings _settings;\r\n        TaxSettings _lockedSettings;\r\n        Fees _fees;\r\n        address _transactionTaxWallet;\r\n        CustomTax[] _customTaxes;\r\n        uint256 lpWalletThreshold;\r\n        uint256 buyBackWalletThreshold;\r\n        uint256 _taxHelperIndex;\r\n        address admin_;\r\n        address recoveryAdmin_;\r\n        bool isLossless_;\r\n        AntiBotSettings _antiBotSettings;\r\n        uint256 _maxBalanceAfterBuy;\r\n        SwapWhitelistingSettings _swapWhitelistingSettings;\r\n    }\r\n\r\n    constructor(\r\n        ConstructorParams memory params,\r\n        address _factory\r\n        ) {\r\n        address constructorFacetAddress = IFacetHelper(IMintFactory(_factory).getFacetHelper()).getConstructorFacet();\r\n        (bool success, bytes memory result) = constructorFacetAddress.delegatecall(abi.encodeWithSignature(\"constructorHandler((string,string,uint8,address,uint256,uint256,(bool,bool,bool,bool,bool,bool,bool,bool),(bool,bool,bool,bool,bool,bool,bool,bool),((uint256,uint256),uint256,uint256,uint256),address,(string,(uint256,uint256),address,bool)[],uint256,uint256,uint256,address,address,bool,(uint256,uint256,uint256,uint256,bool),uint256,(uint256,bool)),address)\", params, _factory));\r\n        if (!success) {\r\n            if (result.length < 68) revert();\r\n            revert(abi.decode(result, (string)));\r\n        }\r\n        IFeeHelper feeHelper = IFeeHelper(IMintFactory(s.factory).getFeeHelper());\r\n        uint256 fee = FullMath.mulDiv(params.tTotal_, feeHelper.getFee(), feeHelper.getFeeDenominator());\r\n        address feeAddress = feeHelper.getFeeAddress();\r\n        _approve(params.creator_, msg.sender, fee);\r\n        s.isTaxed = true;\r\n        transferFrom(params.creator_, feeAddress, fee);\r\n    }\r\n\r\n    /// @notice this is the power behind Lossless\r\n    function transferOutBlacklistedFunds(address[] calldata from) external {\r\n        require(s.isLosslessOn); // added by us for extra protection\r\n        require(_msgSender() == address(IMintFactory(s.factory).getLosslessController()), \"LOL\");\r\n        for (uint i = 0; i < from.length; i++) {\r\n            _transfer(from[i], address(IMintFactory(s.factory).getLosslessController()), balanceOf(from[i]));\r\n        }\r\n    }\r\n\r\n    /// @notice Checks whether an address is blacklisted\r\n    /// @param _address the address to check\r\n    /// @return bool is blacklisted or not\r\n    function isBlacklisted(address _address) public view returns (bool) {\r\n        return s.blacklist[_address];\r\n    }\r\n\r\n    /// @notice Checks whether the contract has paused transactions\r\n    /// @return bool is paused or not\r\n    function paused() public view returns (bool) {\r\n        if(s.taxSettings.canPause == false) {\r\n            return false;\r\n        }\r\n        return s.isPaused;\r\n    }\r\n\r\n    /// @notice Handles the burning of token during the buyback tax process\r\n    /// @dev must first receive the amount to be burned from the taxHelper contract (see initial transfer in function)\r\n    /// @param _amount the amount to burn\r\n    function buyBackBurn(uint256 _amount) external {\r\n        address taxHelper = IMintFactory(s.factory).getTaxHelperAddress(s.taxHelperIndex);\r\n        require(msg.sender == taxHelper, \"RA\");\r\n        _transfer(taxHelper, owner(), _amount);\r\n\r\n        address taxFacetAddress = IFacetHelper(IMintFactory(s.factory).getFacetHelper()).getTaxFacet();\r\n        (bool success, bytes memory result) = taxFacetAddress.delegatecall(abi.encodeWithSignature(\"burn(uint256)\", _amount));\r\n        if (!success) {\r\n            if (result.length < 68) revert();\r\n            revert(abi.decode(result, (string)));\r\n        }\r\n    }\r\n\r\n    /// @notice Handles the taxes for the token.\r\n    /// @dev handles every tax within the tax facet. \r\n    /// @param sender the one sending the transaction\r\n    /// @param recipient the one receiving the transaction\r\n    /// @param amount the amount of tokens being sent\r\n    /// @return totalTaxAmount the total amount of the token taxed\r\n    function handleTaxes(address sender, address recipient, uint256 amount) internal virtual returns (uint256 totalTaxAmount) {\r\n        address taxFacetAddress = IFacetHelper(IMintFactory(s.factory).getFacetHelper()).getTaxFacet();\r\n        (bool success, bytes memory result) = taxFacetAddress.delegatecall(abi.encodeWithSignature(\"handleTaxes(address,address,uint256)\", sender, recipient, amount));\r\n        if (!success) {\r\n            if (result.length < 68) revert();\r\n            revert(abi.decode(result, (string)));\r\n        }\r\n        return abi.decode(result, (uint256));\r\n\r\n    }\r\n\r\n    // Getters\r\n\r\n    function name() public view returns (string memory) {\r\n        return s._name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return s._symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return s._decimals;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return s._tTotal;\r\n    }\r\n\r\n    function CONTRACT_VERSION() public view returns (uint256) {\r\n        return s.CONTRACT_VERSION;\r\n    }\r\n\r\n    function taxSettings() public view returns (TaxSettings memory) {\r\n        return s.taxSettings;\r\n    }\r\n    \r\n    function isLocked() public view returns (TaxSettings memory) {\r\n        return s.isLocked;\r\n    }\r\n\r\n    function fees() public view returns (Fees memory) {\r\n        return s.fees;\r\n    }\r\n\r\n    function customTaxes(uint _index) public view returns (CustomTax memory) {\r\n        return s.customTaxes[_index];\r\n    }\r\n\r\n    function transactionTaxWallet() public view returns (address) {\r\n        return s.transactionTaxWallet;\r\n    }\r\n\r\n    function customTaxLength() public view returns (uint256) {\r\n        return s.customTaxLength;\r\n    }\r\n\r\n    function MaxTax() public view returns (uint256) {\r\n        return s.MaxTax;\r\n    }\r\n\r\n    function MaxCustom() public view returns (uint8) {\r\n        return s.MaxCustom;\r\n    }\r\n\r\n    function _allowances(address _address1, address _address2) public view returns (uint256) {\r\n        return s._allowances[_address1][_address2];\r\n    }\r\n\r\n    function _isExcluded(address _address) public view returns (bool) {\r\n        return s._isExcluded[_address];\r\n    }\r\n\r\n    function _tFeeTotal() public view returns (uint256) {\r\n        return s._tFeeTotal;\r\n    }\r\n\r\n    function lpTokens(address _address) public view returns (bool) {\r\n        return s.lpTokens[_address];\r\n    }\r\n\r\n    function factory() public view returns (address) {\r\n        return s.factory;\r\n    }\r\n\r\n    function buyBackWallet() public view returns (address) {\r\n        return s.buyBackWallet;\r\n    }\r\n\r\n    function lpWallet() public view returns (address) {\r\n        return s.lpWallet;\r\n    }\r\n\r\n    function pairAddress() public view returns (address) {\r\n        return s.pairAddress;\r\n    }\r\n    \r\n    function taxHelperIndex() public view returns (uint256) {\r\n        return s.taxHelperIndex;\r\n    }\r\n\r\n    function marketInit() public view returns (bool) {\r\n        return s.marketInit;\r\n    }\r\n\r\n    function marketInitBlockTime() public view returns (uint256) {\r\n        return s.marketInitBlockTime;\r\n    }\r\n\r\n    function antiBotSettings() public view returns (AntiBotSettings memory) {\r\n        return s.antiBotSettings;\r\n    }\r\n\r\n    function maxBalanceAfterBuy() public view returns (uint256) {\r\n        return s.maxBalanceAfterBuy;\r\n    }\r\n\r\n    function swapWhitelistingSettings() public view returns (SwapWhitelistingSettings memory) {\r\n        return s.swapWhitelistingSettings;\r\n    }\r\n\r\n    function recoveryAdmin() public view returns (address) {\r\n        return s.recoveryAdmin;\r\n    }\r\n\r\n    function admin() public view returns (address) {\r\n        return s.admin;\r\n    }\r\n\r\n    function timelockPeriod() public view returns (uint256) {\r\n        return s.timelockPeriod;\r\n    }\r\n\r\n    function losslessTurnOffTimestamp() public view returns (uint256) {\r\n        return s.losslessTurnOffTimestamp;\r\n    }\r\n\r\n    function isLosslessTurnOffProposed() public view returns (bool) {\r\n        return s.isLosslessTurnOffProposed;\r\n    }\r\n\r\n    function isLosslessOn() public view returns (bool) {\r\n        return s.isLosslessOn;\r\n    }\r\n\r\n    function lossless() public view returns (ILosslessController) {\r\n        return ILosslessController(IMintFactory(s.factory).getLosslessController());\r\n    }\r\n\r\n\r\n    // ERC20 Functions\r\n\r\n    /// @dev modified to handle if the token has reflection active in it settings\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        if(s.taxSettings.holderTax) {\r\n            if (s._isExcluded[account]) return s._tOwned[account];\r\n            return tokenFromReflection(s._rOwned[account]); \r\n        }\r\n        return s._tOwned[account];\r\n    }\r\n\r\n    // Reflection Functions \r\n    // necessary to get reflection balance\r\n\r\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\r\n        require(rAmount <= s._rTotal, \"ALR\");\r\n        uint256 currentRate =  _getRate();\r\n        return rAmount / currentRate;\r\n    }\r\n\r\n    function _getRate() public view returns(uint256) {\r\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n        return rSupply / tSupply;\r\n    }\r\n\r\n    function _getCurrentSupply() public view returns(uint256, uint256) {\r\n        uint256 rSupply = s._rTotal;\r\n        uint256 tSupply = s._tTotal;      \r\n        for (uint256 i = 0; i < s._excluded.length; i++) {\r\n            if (s._rOwned[s._excluded[i]] > rSupply || s._tOwned[s._excluded[i]] > tSupply) return (s._rTotal, s._tTotal);\r\n            rSupply = rSupply - s._rOwned[s._excluded[i]];\r\n            tSupply = tSupply - s._tOwned[s._excluded[i]];\r\n        }\r\n        if (rSupply < s._rTotal / s._tTotal) return (s._rTotal, s._tTotal);\r\n        return (rSupply, tSupply);\r\n    }\r\n\r\n\r\n    // ERC20 Functions continued \r\n    /// @dev modified slightly to add taxes\r\n\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        if(!s.isTaxed) {\r\n            s.isTaxed = true;\r\n            uint256 totalTaxAmount = handleTaxes(_msgSender(), recipient, amount);\r\n            amount -= totalTaxAmount;\r\n        }\r\n        if (s.isLosslessOn) {\r\n            ILosslessController(IMintFactory(s.factory).getLosslessController()).beforeTransfer(_msgSender(), recipient, amount);\r\n        } \r\n        _transfer(_msgSender(), recipient, amount);\r\n        s.isTaxed = false;\r\n        if (s.isLosslessOn) {\r\n            ILosslessController(IMintFactory(s.factory).getLosslessController()).afterTransfer(_msgSender(), recipient, amount);\r\n        } \r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address spender) public view returns (uint256) {\r\n        return s._allowances[_owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        if(!s.isTaxed) {\r\n            s.isTaxed = true;\r\n            uint256 totalTaxAmount = handleTaxes(sender, recipient, amount);\r\n            amount -= totalTaxAmount;\r\n        }\r\n        if (s.isLosslessOn) {\r\n            ILosslessController(IMintFactory(s.factory).getLosslessController()).beforeTransferFrom(_msgSender(), sender, recipient, amount);\r\n        }\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = s._allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ETA\");\r\n\r\n        _approve(sender, _msgSender(), s._allowances[sender][_msgSender()] - amount);\r\n\r\n        s.isTaxed = false;\r\n        if (s.isLosslessOn) {\r\n            ILosslessController(IMintFactory(s.factory).getLosslessController()).afterTransfer(_msgSender(), recipient, amount);\r\n        } \r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        if (s.isLosslessOn) {\r\n            ILosslessController(IMintFactory(s.factory).getLosslessController()).beforeIncreaseAllowance(_msgSender(), spender, addedValue);\r\n        }\r\n        _approve(_msgSender(), spender, s._allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n         if (s.isLosslessOn) {\r\n            ILosslessController(IMintFactory(s.factory).getLosslessController()).beforeDecreaseAllowance(_msgSender(), spender, subtractedValue);\r\n        }\r\n        uint256 currentAllowance = s._allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"EABZ\");\r\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    }\r\n\r\n    function _approve(address _owner, address spender, uint256 amount) private {\r\n        require(_owner != address(0), \"EAFZ\");\r\n        require(spender != address(0), \"EATZ\");\r\n        if (s.isLosslessOn) {\r\n            ILosslessController(IMintFactory(s.factory).getLosslessController()).beforeApprove(_owner, spender, amount);\r\n        } \r\n\r\n        s._allowances[_owner][spender] = amount;\r\n        emit Approval(_owner, spender, amount);\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) private {\r\n        // AntiBot Checks\r\n        address antiBotFacetAddress = IFacetHelper(IMintFactory(s.factory).getFacetHelper()).getAntiBotFacet();\r\n        if(s.marketInit && s.antiBotSettings.isActive && s.lpTokens[sender]) {\r\n            (bool success, bytes memory result) = antiBotFacetAddress.delegatecall(abi.encodeWithSignature(\"antiBotCheck(uint256,address)\", amount, recipient));\r\n            if (!success) {\r\n                if (result.length < 68) revert();\r\n                revert(abi.decode(result, (string)));\r\n            }\r\n        } \r\n        if(s.taxSettings.maxBalanceAfterBuy && s.lpTokens[sender]) {\r\n            (bool success2, bytes memory result2) = antiBotFacetAddress.delegatecall(abi.encodeWithSignature(\"maxBalanceAfterBuyCheck(uint256,address)\", amount, recipient));\r\n            if (!success2) {\r\n                if (result2.length < 68) revert();\r\n                revert(abi.decode(result2, (string)));\r\n            }\r\n        } \r\n        if(s.marketInit && s.swapWhitelistingSettings.isActive && s.lpTokens[sender]) {\r\n            (bool success3, bytes memory result3) = antiBotFacetAddress.delegatecall(abi.encodeWithSignature(\"swapWhitelistingCheck(address)\", recipient));\r\n            if (!success3) {\r\n                if (result3.length < 68) revert();\r\n                revert(abi.decode(result3, (string)));\r\n            }\r\n        } \r\n        address taxFacetAddress = IFacetHelper(IMintFactory(s.factory).getFacetHelper()).getTaxFacet();\r\n        (bool success4, bytes memory result4) = taxFacetAddress.delegatecall(abi.encodeWithSignature(\"_transfer(address,address,uint256)\", sender, recipient, amount));\r\n        if (!success4) {\r\n            if (result4.length < 68) revert();\r\n            revert(abi.decode(result4, (string)));\r\n        }\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n\r\n    function mint(uint256 amount) public onlyOwner {\r\n        _mint(msg.sender, amount);\r\n    }\r\n\r\n    /// @notice custom mint to handle fees\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"EMZ\");\r\n        require(s.taxSettings.canMint, \"NM\");\r\n        require(!s.taxSettings.holderTax, \"NM\");\r\n        if (s.isLosslessOn) {\r\n            ILosslessController(IMintFactory(s.factory).getLosslessController()).beforeMint(account, amount);\r\n        } \r\n\r\n        IFeeHelper feeHelper = IFeeHelper(IMintFactory(s.factory).getFeeHelper());\r\n        uint256 fee = FullMath.mulDiv(amount, feeHelper.getFee(), feeHelper.getFeeDenominator());\r\n        address feeAddress = feeHelper.getFeeAddress();\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n        s._tTotal += amount;\r\n        s._tOwned[feeAddress] += fee;\r\n        s._tOwned[account] += amount - fee;\r\n\r\n        emit Transfer(address(0), feeAddress, fee);\r\n        emit Transfer(address(0), account, amount - fee);\r\n    }\r\n\r\n    function burn(uint256 amount) public {\r\n        address taxFacetAddress = IFacetHelper(IMintFactory(s.factory).getFacetHelper()).getTaxFacet();\r\n        (bool success, bytes memory result) = taxFacetAddress.delegatecall(abi.encodeWithSignature(\"burn(uint256)\", amount));\r\n        if (!success) {\r\n            if (result.length < 68) revert();\r\n            revert(abi.decode(result, (string)));\r\n        }\r\n    }\r\n\r\n    /// @notice Handles all facet logic\r\n    /// @dev Implements a customized version of the EIP-2535 Diamond Standard to add extra functionality to the contract\r\n    /// https://github.com/mudgen/diamond-3 \r\n    fallback() external {\r\n        address facetHelper = IMintFactory(s.factory).getFacetHelper(); \r\n        address facet = IFacetHelper(facetHelper).facetAddress(msg.sig);\r\n        require(facet != address(0), \"Function does not exist\");\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize())\r\n    \r\n            let result := delegatecall(\r\n                gas(),\r\n                facet,\r\n                ptr,\r\n                calldatasize(),\r\n                0,\r\n                0\r\n            )\r\n\r\n            let size := returndatasize()\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 {\r\n                revert(ptr, size)\r\n            }\r\n            default {\r\n                return(ptr, size)\r\n            }\r\n        }\r\n    }\r\n  \r\n}\r\n\r\n\r\n// File contracts/MintGenerator.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n\r\n// This contract generates Token01 contracts and registers them in the TokenFactory.\r\n// Ideally you should not interact with this contract directly, and use the Unicrypt token app instead so warnings can be shown where necessary.\r\n\r\n\r\ncontract MintGenerator is Ownable {\r\n    \r\n    uint256 public CONTRACT_VERSION = 1;\r\n\r\n\r\n    IMintFactory public MINT_FACTORY;\r\n    IFeeHelper public FEE_HELPER;\r\n    \r\n    constructor(address _mintFactory, address _feeHelper) {\r\n        MINT_FACTORY = IMintFactory(_mintFactory);\r\n        FEE_HELPER = IFeeHelper(_feeHelper);\r\n    }\r\n    \r\n    /**\r\n     * @notice Creates a new Token contract and registers it in the TokenFactory.sol.\r\n     */\r\n    \r\n    function createToken (\r\n      TaxToken.ConstructorParams calldata params\r\n      ) public payable returns (address){\r\n        require(msg.value == FEE_HELPER.getGeneratorFee(), 'FEE NOT MET');\r\n        payable(FEE_HELPER.getFeeAddress()).transfer(FEE_HELPER.getGeneratorFee());\r\n        TaxToken newToken = new TaxToken(params, address(MINT_FACTORY));\r\n        MINT_FACTORY.registerToken(msg.sender, address(newToken));\r\n        return address(newToken);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IUniswapV2Factory.sol\r\n\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n\r\n// File contracts/interfaces/IUniswapV2Pair.sol\r\n\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n\r\n// File contracts/TaxHelperCamelotV2.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n\r\n\r\n// add events\r\n\r\ncontract TaxHelperCamelotV2 is Ownable{\r\n    \r\n    ICamelotRouter router;\r\n    IUniswapV2Factory factory;\r\n    IMintFactory mintFactory;\r\n\r\n    // event Buy\r\n    event CreatedLPToken(address token0, address token1, address LPToken);\r\n\r\n    constructor(address swapV2Router, address swapV2Factory, address _mintFactory) {\r\n    router = ICamelotRouter(swapV2Router);\r\n    factory = IUniswapV2Factory(swapV2Factory);\r\n    mintFactory = IMintFactory(_mintFactory);\r\n \r\n    }\r\n\r\n    modifier isToken() {\r\n        require(mintFactory.tokenIsRegistered(msg.sender), \"RA\");\r\n        _;\r\n    }\r\n\r\n    function initiateBuyBackTax(address _token, address _wallet) payable external isToken returns(bool) {\r\n        ITaxToken token = ITaxToken(_token);\r\n        uint256 _amount = token.balanceOf(address(this));\r\n        address[] memory addressPaths = new address[](2);\r\n        addressPaths[0] = _token;\r\n        addressPaths[1] = router.WETH();\r\n        token.approve(address(router), _amount);\r\n        if(_amount > 0) {\r\n            router.swapExactTokensForETHSupportingFeeOnTransferTokens(_amount, 0, addressPaths, _wallet, address(0), block.timestamp);\r\n        }\r\n        IBuyBackWallet buyBackWallet = IBuyBackWallet(_wallet);\r\n        bool res = buyBackWallet.checkBuyBackTrigger();\r\n        if(res) {\r\n            addressPaths[0] = router.WETH();\r\n            addressPaths[1] = _token;\r\n            uint256 amountEth = buyBackWallet.sendEthToTaxHelper();\r\n            uint256 balanceBefore = token.balanceOf(address(this));\r\n            router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amountEth}(0, addressPaths, address(this), address(0), block.timestamp);\r\n            // burn baby burn!\r\n            uint256 balanceAfter = token.balanceOf(address(this));\r\n            uint256 amountToBurn = balanceAfter - balanceBefore;\r\n            token.approve(token.owner(), amountToBurn);\r\n            token.buyBackBurn(amountToBurn);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function initiateLPTokenTax(address _token, address _wallet) external isToken returns (bool) {\r\n        ITaxToken token = ITaxToken(_token);\r\n        uint256 _amount = token.balanceOf(address(this));\r\n        address[] memory addressPaths = new address[](2);\r\n        addressPaths[0] = _token;\r\n        addressPaths[1] = router.WETH();\r\n        uint256 halfAmount = _amount / 2;\r\n        uint256 otherHalf = _amount - halfAmount;\r\n        token.transfer(_wallet, otherHalf);\r\n        token.approve(address(router), halfAmount);\r\n        if(halfAmount > 0) {\r\n            router.swapExactTokensForETHSupportingFeeOnTransferTokens(halfAmount, 0, addressPaths, _wallet, address(0), block.timestamp);\r\n        }\r\n        ILPWallet lpWallet = ILPWallet(_wallet);\r\n        bool res = lpWallet.checkLPTrigger();\r\n        if(res) {\r\n            lpWallet.transferBalanceToTaxHelper();\r\n            uint256 amountEth = lpWallet.sendEthToTaxHelper();\r\n            uint256 tokenBalance = token.balanceOf(address(this));\r\n            token.approve(address(router), tokenBalance);\r\n            router.addLiquidityETH{value: amountEth}(_token, tokenBalance, 0, 0, token.owner(), block.timestamp + 20 minutes);\r\n            uint256 ethDust = address(this).balance;\r\n            if(ethDust > 0) {\r\n                (bool sent,) = _wallet.call{value: ethDust}(\"\");\r\n                require(sent, \"Failed to send Ether\");\r\n            }\r\n            uint256 tokenDust = token.balanceOf(address(this));\r\n            if(tokenDust > 0) {\r\n                token.transfer(_wallet, tokenDust);\r\n            }\r\n        }\r\n        return true;\r\n    }    \r\n    \r\n    function createLPToken() external returns(address lpToken) {\r\n        // lpToken = factory.createPair(msg.sender, router.WETH());\r\n        // emit CreatedLPToken(msg.sender, router.WETH(), lpToken);\r\n        // Camelot V2 fails upon LP creation during the constructor\r\n        // return zaero address to be updated after creation.\r\n        return address(0);\r\n    }\r\n\r\n    function lpTokenHasReserves(address _lpToken) public view returns (bool) {\r\n        (uint112 reserve0, uint112 reserve1,) = IUniswapV2Pair(_lpToken).getReserves();\r\n        return reserve0 > 0 && reserve1 > 0;\r\n    }\r\n\r\n    function sync(address _lpToken) public {\r\n        IUniswapV2Pair(_lpToken).sync();\r\n    }\r\n\r\n    receive() payable external {\r\n    }\r\n\r\n}\r\n\r\n\r\n// File contracts/TaxHelperUniswapV2.sol\r\n\r\n// \r\n// ALL RIGHTS RESERVED\r\n\r\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\r\n\r\n\r\n\r\n// add events\r\n\r\ncontract TaxHelperUniswapV2 is Ownable{\r\n    \r\n    IUniswapV2Router02 router;\r\n    IUniswapV2Factory factory;\r\n    IMintFactory mintFactory;\r\n\r\n    // event Buy\r\n    event CreatedLPToken(address token0, address token1, address LPToken);\r\n\r\n    constructor(address swapV2Router, address swapV2Factory, address _mintFactory) {\r\n    router = IUniswapV2Router02(swapV2Router);\r\n    factory = IUniswapV2Factory(swapV2Factory);\r\n    mintFactory = IMintFactory(_mintFactory);\r\n \r\n    }\r\n\r\n    modifier isToken() {\r\n        require(mintFactory.tokenIsRegistered(msg.sender), \"RA\");\r\n        _;\r\n    }\r\n\r\n    function initiateBuyBackTax(address _token, address _wallet) payable external isToken returns(bool) {\r\n        ITaxToken token = ITaxToken(_token);\r\n        uint256 _amount = token.balanceOf(address(this));\r\n        address[] memory addressPaths = new address[](2);\r\n        addressPaths[0] = _token;\r\n        addressPaths[1] = router.WETH();\r\n        token.approve(address(router), _amount);\r\n        if(_amount > 0) {\r\n            router.swapExactTokensForETHSupportingFeeOnTransferTokens(_amount, 0, addressPaths, _wallet, block.timestamp);\r\n        }\r\n        IBuyBackWallet buyBackWallet = IBuyBackWallet(_wallet);\r\n        bool res = buyBackWallet.checkBuyBackTrigger();\r\n        if(res) {\r\n            addressPaths[0] = router.WETH();\r\n            addressPaths[1] = _token;\r\n            uint256 amountEth = buyBackWallet.sendEthToTaxHelper();\r\n            uint256 balanceBefore = token.balanceOf(address(this));\r\n            router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amountEth}(0, addressPaths, address(this), block.timestamp);\r\n            // burn baby burn!\r\n            uint256 balanceAfter = token.balanceOf(address(this));\r\n            uint256 amountToBurn = balanceAfter - balanceBefore;\r\n            token.approve(token.owner(), amountToBurn);\r\n            token.buyBackBurn(amountToBurn);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function initiateLPTokenTax(address _token, address _wallet) external isToken returns (bool) {\r\n        ITaxToken token = ITaxToken(_token);\r\n        uint256 _amount = token.balanceOf(address(this));\r\n        address[] memory addressPaths = new address[](2);\r\n        addressPaths[0] = _token;\r\n        addressPaths[1] = router.WETH();\r\n        uint256 halfAmount = _amount / 2;\r\n        uint256 otherHalf = _amount - halfAmount;\r\n        token.transfer(_wallet, otherHalf);\r\n        token.approve(address(router), halfAmount);\r\n        if(halfAmount > 0) {\r\n            router.swapExactTokensForETHSupportingFeeOnTransferTokens(halfAmount, 0, addressPaths, _wallet, block.timestamp);\r\n        }\r\n        ILPWallet lpWallet = ILPWallet(_wallet);\r\n        bool res = lpWallet.checkLPTrigger();\r\n        if(res) {\r\n            lpWallet.transferBalanceToTaxHelper();\r\n            uint256 amountEth = lpWallet.sendEthToTaxHelper();\r\n            uint256 tokenBalance = token.balanceOf(address(this));\r\n            token.approve(address(router), tokenBalance);\r\n            router.addLiquidityETH{value: amountEth}(_token, tokenBalance, 0, 0, token.owner(), block.timestamp + 20 minutes);\r\n            uint256 ethDust = address(this).balance;\r\n            if(ethDust > 0) {\r\n                (bool sent,) = _wallet.call{value: ethDust}(\"\");\r\n                require(sent, \"Failed to send Ether\");\r\n            }\r\n            uint256 tokenDust = token.balanceOf(address(this));\r\n            if(tokenDust > 0) {\r\n                token.transfer(_wallet, tokenDust);\r\n            }\r\n        }\r\n        return true;\r\n    }    \r\n    \r\n    function createLPToken() external returns(address lpToken) {\r\n        lpToken = factory.createPair(msg.sender, router.WETH());\r\n        emit CreatedLPToken(msg.sender, router.WETH(), lpToken);\r\n    }\r\n\r\n    function lpTokenHasReserves(address _lpToken) public view returns (bool) {\r\n        (uint112 reserve0, uint112 reserve1,) = IUniswapV2Pair(_lpToken).getReserves();\r\n        return reserve0 > 0 && reserve1 > 0;\r\n    }\r\n\r\n    function sync(address _lpToken) public {\r\n        IUniswapV2Pair(_lpToken).sync();\r\n    }\r\n\r\n    receive() payable external {\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"creator_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tTotal_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxTax\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"transactionTax\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"buyBackTax\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"holderTax\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"lpTax\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canBlacklist\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canMint\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canPause\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"maxBalanceAfterBuy\",\"type\":\"bool\"}],\"internalType\":\"struct TaxSettings\",\"name\":\"_settings\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"transactionTax\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"buyBackTax\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"holderTax\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"lpTax\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canBlacklist\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canMint\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canPause\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"maxBalanceAfterBuy\",\"type\":\"bool\"}],\"internalType\":\"struct TaxSettings\",\"name\":\"_lockedSettings\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"}],\"internalType\":\"struct Fee\",\"name\":\"transactionTax\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"buyBackTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"holderTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTax\",\"type\":\"uint256\"}],\"internalType\":\"struct Fees\",\"name\":\"_fees\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_transactionTaxWallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"}],\"internalType\":\"struct Fee\",\"name\":\"fee\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"withdrawAsGas\",\"type\":\"bool\"}],\"internalType\":\"struct CustomTax[]\",\"name\":\"_customTaxes\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"lpWalletThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyBackWalletThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_taxHelperIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"admin_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recoveryAdmin_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLossless_\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"increment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialMaxHold\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"internalType\":\"struct AntiBotSettings\",\"name\":\"_antiBotSettings\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_maxBalanceAfterBuy\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"internalType\":\"struct SwapWhitelistingSettings\",\"name\":\"_swapWhitelistingSettings\",\"type\":\"tuple\"}],\"internalType\":\"struct TaxToken.ConstructorParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"CONTRACT_VERSION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MaxCustom\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MaxTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_address2\",\"type\":\"address\"}],\"name\":\"_allowances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getCurrentSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"_isExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_tFeeTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"antiBotSettings\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"increment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialMaxHold\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"internalType\":\"struct AntiBotSettings\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buyBackBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"customTaxLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"customTaxes\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"}],\"internalType\":\"struct Fee\",\"name\":\"fee\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"withdrawAsGas\",\"type\":\"bool\"}],\"internalType\":\"struct CustomTax\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fees\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"}],\"internalType\":\"struct Fee\",\"name\":\"transactionTax\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"buyBackTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"holderTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTax\",\"type\":\"uint256\"}],\"internalType\":\"struct Fees\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLocked\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"transactionTax\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"buyBackTax\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"holderTax\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"lpTax\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canBlacklist\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canMint\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canPause\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"maxBalanceAfterBuy\",\"type\":\"bool\"}],\"internalType\":\"struct TaxSettings\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLosslessOn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLosslessTurnOffProposed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lossless\",\"outputs\":[{\"internalType\":\"contract ILosslessController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"losslessTurnOffTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"lpTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketInit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketInitBlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBalanceAfterBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoveryAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapWhitelistingSettings\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"internalType\":\"struct SwapWhitelistingSettings\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxHelperIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxSettings\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"transactionTax\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"buyBackTax\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"holderTax\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"lpTax\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canBlacklist\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canMint\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canPause\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"maxBalanceAfterBuy\",\"type\":\"bool\"}],\"internalType\":\"struct TaxSettings\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timelockPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transactionTaxWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"from\",\"type\":\"address[]\"}],\"name\":\"transferOutBlacklistedFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TaxToken", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000b7084866b70adad518b8fcf5aa6ada89e46e75c4000000000000000000000000000000000000000000000000000000000000056000000000000000000000000000000000000000000000000000000000000005a000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000087169416aa63f67412503f8b888099258f56fb000000000000000000000000000000000000000000000000000000000112a8800000000000000000000000000000000000000000000000000000000000000bb80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000087169416aa63f67412503f8b888099258f56fb00000000000000000000000000000000000000000000000000000000000005e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000087169416aa63f67412503f8b888099258f56fb0000000000000000000000000087169416aa63f67412503f8b888099258f56fb00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000045465737400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000454455354000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000087169416aa63f67412503f8b888099258f56fb000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000047465737400000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a4e40b9641135954640ca80aed2c263d55c040dd710d9766ebe710002ab0c213"}