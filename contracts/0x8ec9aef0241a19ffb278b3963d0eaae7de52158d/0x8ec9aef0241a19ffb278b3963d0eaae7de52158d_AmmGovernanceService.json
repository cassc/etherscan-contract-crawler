{"SourceCode": "// SPDX-License-Identifier: GPL-2.0-or-later\r\n// File: contracts/libraries/StorageLib.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n/// @title Storage ID's associated with the IPOR Protocol Router.\r\nlibrary StorageLib {\r\n    uint256 constant STORAGE_SLOT_BASE = 1_000_000;\r\n\r\n    // append only\r\n    enum StorageId {\r\n        /// @dev The address of the contract owner.\r\n        Owner,\r\n        AppointedOwner,\r\n        Paused,\r\n        PauseGuardian,\r\n        ReentrancyStatus,\r\n        RouterFunctionPaused,\r\n        AmmSwapsLiquidators,\r\n        AmmPoolsAppointedToRebalance,\r\n        AmmPoolsParams\r\n    }\r\n\r\n    /// @notice Struct which contains owner address of IPOR Protocol Router.\r\n    struct OwnerStorage {\r\n        address owner;\r\n    }\r\n\r\n    /// @notice Struct which contains appointed owner address of IPOR Protocol Router.\r\n    struct AppointedOwnerStorage {\r\n        address appointedOwner;\r\n    }\r\n\r\n    /// @notice Struct which contains reentrancy status of IPOR Protocol Router.\r\n    struct ReentrancyStatusStorage {\r\n        uint256 value;\r\n    }\r\n\r\n    /// @notice Struct which contains information about swap liquidators.\r\n    /// @dev First key is an asset (pool), second key is an liquidator address in the asset pool,\r\n    /// value is a flag to indicate whether account is a liquidator.\r\n    /// True - account is a liquidator, False - account is not a liquidator.\r\n    struct AmmSwapsLiquidatorsStorage {\r\n        mapping(address => mapping(address => bool)) value;\r\n    }\r\n\r\n    /// @notice Struct which contains information about accounts appointed to rebalance.\r\n    /// @dev first key - asset address, second key - account address which is allowed to rebalance in the asset pool,\r\n    /// value - flag to indicate whether account is allowed to rebalance. True - allowed, False - not allowed.\r\n    struct AmmPoolsAppointedToRebalanceStorage {\r\n        mapping(address => mapping(address => bool)) value;\r\n    }\r\n\r\n    struct AmmPoolsParamsValue {\r\n        /// @dev max liquidity pool balance in the asset pool, represented without 18 decimals\r\n        uint32 maxLiquidityPoolBalance;\r\n        /// @dev The threshold for auto-rebalancing the pool. Value represented without 18 decimals.\r\n        /// Value represents multiplication of 1000.\r\n        uint32 autoRebalanceThresholdInThousands;\r\n        /// @dev asset management ratio, represented without 18 decimals, value represents percentage with 2 decimals\r\n        /// 65% = 6500, 99,99% = 9999, this is a percentage which stay in Amm Treasury in opposite to Asset Management\r\n        /// based on AMM Treasury balance (100%).\r\n        uint16 ammTreasuryAndAssetManagementRatio;\r\n    }\r\n\r\n    /// @dev key - asset address, value - struct AmmOpenSwapParamsValue\r\n    struct AmmPoolsParamsStorage {\r\n        mapping(address => AmmPoolsParamsValue) value;\r\n    }\r\n\r\n    /// @dev key - function sig, value - 1 if function is paused, 0 if not\r\n    struct RouterFunctionPausedStorage {\r\n        mapping(bytes4 => uint256) value;\r\n    }\r\n\r\n    /// @notice Gets Ipor Protocol Router owner address.\r\n    function getOwner() internal pure returns (OwnerStorage storage owner) {\r\n        uint256 slot = _getStorageSlot(StorageId.Owner);\r\n        assembly {\r\n            owner.slot := slot\r\n        }\r\n    }\r\n\r\n    /// @notice Gets Ipor Protocol Router appointed owner address.\r\n    function getAppointedOwner() internal pure returns (AppointedOwnerStorage storage appointedOwner) {\r\n        uint256 slot = _getStorageSlot(StorageId.AppointedOwner);\r\n        assembly {\r\n            appointedOwner.slot := slot\r\n        }\r\n    }\r\n\r\n    /// @notice Gets Ipor Protocol Router reentrancy status.\r\n    function getReentrancyStatus() internal pure returns (ReentrancyStatusStorage storage reentrancyStatus) {\r\n        uint256 slot = _getStorageSlot(StorageId.ReentrancyStatus);\r\n        assembly {\r\n            reentrancyStatus.slot := slot\r\n        }\r\n    }\r\n\r\n    /// @notice Gets information if function is paused in Ipor Protocol Router.\r\n    function getRouterFunctionPaused() internal pure returns (RouterFunctionPausedStorage storage paused) {\r\n        uint256 slot = _getStorageSlot(StorageId.RouterFunctionPaused);\r\n        assembly {\r\n            paused.slot := slot\r\n        }\r\n    }\r\n\r\n    /// @notice Gets point to pause guardian storage.\r\n    function getPauseGuardianStorage() internal pure returns (mapping(address => bool) storage store) {\r\n        uint256 slot = _getStorageSlot(StorageId.PauseGuardian);\r\n        assembly {\r\n            store.slot := slot\r\n        }\r\n    }\r\n\r\n    /// @notice Gets point to liquidators storage.\r\n    /// @return store - point to liquidators storage.\r\n    function getAmmSwapsLiquidatorsStorage() internal pure returns (AmmSwapsLiquidatorsStorage storage store) {\r\n        uint256 slot = _getStorageSlot(StorageId.AmmSwapsLiquidators);\r\n        assembly {\r\n            store.slot := slot\r\n        }\r\n    }\r\n\r\n    /// @notice Gets point to accounts appointed to rebalance storage.\r\n    /// @return store - point to accounts appointed to rebalance storage.\r\n    function getAmmPoolsAppointedToRebalanceStorage()\r\n        internal\r\n        pure\r\n        returns (AmmPoolsAppointedToRebalanceStorage storage store)\r\n    {\r\n        uint256 slot = _getStorageSlot(StorageId.AmmPoolsAppointedToRebalance);\r\n        assembly {\r\n            store.slot := slot\r\n        }\r\n    }\r\n\r\n    /// @notice Gets point to amm pools params storage.\r\n    /// @return store - point to amm pools params storage.\r\n    function getAmmPoolsParamsStorage() internal pure returns (AmmPoolsParamsStorage storage store) {\r\n        uint256 slot = _getStorageSlot(StorageId.AmmPoolsParams);\r\n        assembly {\r\n            store.slot := slot\r\n        }\r\n    }\r\n\r\n    function _getStorageSlot(StorageId storageId) private pure returns (uint256 slot) {\r\n        return uint256(storageId) + STORAGE_SLOT_BASE;\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/errors/IporErrors.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\nlibrary IporErrors {\r\n    // 000-199 - general codes\r\n\r\n    /// @notice General problem, address is wrong\r\n    string public constant WRONG_ADDRESS = \"IPOR_000\";\r\n\r\n    /// @notice General problem. Wrong decimals\r\n    string public constant WRONG_DECIMALS = \"IPOR_001\";\r\n\r\n    /// @notice General problem, addresses mismatch\r\n    string public constant ADDRESSES_MISMATCH = \"IPOR_002\";\r\n\r\n    /// @notice Sender's asset balance is too low to transfer and to open a swap\r\n    string public constant SENDER_ASSET_BALANCE_TOO_LOW = \"IPOR_003\";\r\n\r\n    /// @notice Value is not greater than zero\r\n    string public constant VALUE_NOT_GREATER_THAN_ZERO = \"IPOR_004\";\r\n\r\n    /// @notice Input arrays length mismatch\r\n    string public constant INPUT_ARRAYS_LENGTH_MISMATCH = \"IPOR_005\";\r\n\r\n    /// @notice Amount is too low to transfer\r\n    string public constant NOT_ENOUGH_AMOUNT_TO_TRANSFER = \"IPOR_006\";\r\n\r\n    /// @notice msg.sender is not an appointed owner, so cannot confirm his appointment to be an owner of a specific smart contract\r\n    string public constant SENDER_NOT_APPOINTED_OWNER = \"IPOR_007\";\r\n\r\n    /// @notice only Router can have access to function\r\n    string public constant CALLER_NOT_IPOR_PROTOCOL_ROUTER = \"IPOR_008\";\r\n\r\n    /// @notice Chunk size is equal to zero\r\n    string public constant CHUNK_SIZE_EQUAL_ZERO = \"IPOR_009\";\r\n\r\n    /// @notice Chunk size is too big\r\n    string public constant CHUNK_SIZE_TOO_BIG = \"IPOR_010\";\r\n\r\n    /// @notice Caller is not a  guardian\r\n    string public constant CALLER_NOT_GUARDIAN = \"IPOR_011\";\r\n\r\n    /// @notice Request contains invalid method signature, which is not supported by the Ipor Protocol Router\r\n    string public constant ROUTER_INVALID_SIGNATURE = \"IPOR_012\";\r\n\r\n    /// @notice Only AMM Treasury can have access to function\r\n    string public constant CALLER_NOT_AMM_TREASURY = \"IPOR_013\";\r\n\r\n    /// @notice Caller is not an owner\r\n    string public constant CALLER_NOT_OWNER = \"IPOR_014\";\r\n\r\n    /// @notice Method is paused\r\n    string public constant METHOD_PAUSED = \"IPOR_015\";\r\n\r\n    /// @notice Reentrancy appears\r\n    string public constant REENTRANCY = \"IPOR_016\";\r\n\r\n    /// @notice Asset is not supported\r\n    string public constant ASSET_NOT_SUPPORTED = \"IPOR_017\";\r\n\r\n    /// @notice Return back ETH failed in Ipor Protocol Router\r\n    string public constant ROUTER_RETURN_BACK_ETH_FAILED = \"IPOR_018\";\r\n}\r\n\r\n// File: contracts/libraries/IporContractValidator.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n\r\nlibrary IporContractValidator {\r\n    function checkAddress(address addr) internal pure returns (address) {\r\n        require(addr != address(0), IporErrors.WRONG_ADDRESS);\r\n        return addr;\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/errors/AmmPoolsErrors.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\nlibrary AmmPoolsErrors {\r\n    // 400-499-Amm Pools\r\n    /// @notice IP Token Value which should be minted is too low\r\n    string public constant IP_TOKEN_MINT_AMOUNT_TOO_LOW = \"IPOR_400\";\r\n\r\n    /// @notice Amount which should be burned is too low\r\n    string public constant IP_TOKEN_BURN_AMOUNT_TOO_LOW = \"IPOR_401\";\r\n\r\n    /// @notice Liquidity Pool Collateral Ration is exceeded when redeeming\r\n    string public constant REDEEM_LP_COLLATERAL_RATIO_EXCEEDED = \"IPOR_402\";\r\n\r\n    /// @notice User cannot redeem underlying tokens because ipToken on his balance is too low\r\n    string public constant CANNOT_REDEEM_IP_TOKEN_TOO_LOW = \"IPOR_403\";\r\n\r\n    /// @notice Caller is not a treasury manager, not match address defined in IPOR Protocol configuration\r\n    string public constant CALLER_NOT_TREASURY_MANAGER = \"IPOR_404\";\r\n\r\n    /// @notice Account cannot redeem ip tokens because amount of underlying tokens for transfer to beneficiary is too low.\r\n    string public constant CANNOT_REDEEM_ASSET_AMOUNT_TOO_LOW = \"IPOR_405\";\r\n\r\n    /// @notice Sender is not a publication fee transferer, not match address defined in IporConfiguration in key AMM_TREASURY_PUBLICATION_FEE_TRANSFERER\r\n    string public constant CALLER_NOT_PUBLICATION_FEE_TRANSFERER = \"IPOR_406\";\r\n\r\n    /// @notice Asset Management Balance is empty\r\n    string public constant ASSET_MANAGEMENT_BALANCE_IS_EMPTY = \"IPOR_407\";\r\n\r\n    /// @notice Incorrect AMM Treasury and Asset Management Ratio\r\n    string public constant AMM_TREASURY_ASSET_MANAGEMENT_RATIO = \"IPOR_408\";\r\n\r\n    /// @notice Insufficient ERC20 balance\r\n    string public constant INSUFFICIENT_ERC20_BALANCE = \"IPOR_409\";\r\n\r\n    /// @notice Caller is not appointed to rebalance\r\n    string public constant CALLER_NOT_APPOINTED_TO_REBALANCE = \"IPOR_410\";\r\n\r\n    /// @notice Invalid redeem fee rate\r\n    string public constant CFG_INVALID_REDEEM_FEE_RATE = \"IPOR_411\";\r\n\r\n    /// @notice Invalid redeem lp max collateral ratio\r\n    string public constant CFG_INVALID_REDEEM_LP_MAX_COLLATERAL_RATIO = \"IPOR_412\";\r\n}\r\n\r\n// File: contracts/governance/AmmConfigurationManager.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n\r\n\r\n\r\n/// @title Configuration manager for AMM\r\nlibrary AmmConfigurationManager {\r\n    /// @notice Emitted when new liquidator is added to the list of SwapLiquidators.\r\n    /// @param asset address of the asset (pool)\r\n    /// @param liquidator address of the new liquidator\r\n    event AmmSwapsLiquidatorChanged(address indexed asset, address indexed liquidator, bool status);\r\n\r\n    /// @notice Emitted when new account is added to the list of AppointedToRebalance.\r\n    /// @param asset address of the asset (pool)\r\n    /// @param account address of account appointed to rebalance\r\n    /// @param status true if account is appointed to rebalance, false otherwise\r\n    event AmmAppointedToRebalanceChanged(address indexed asset, address indexed account, bool status);\r\n\r\n    /// @notice Emitted when AMM Pools Params are changed.\r\n    /// @param asset address of the asset (pool)\r\n    /// @param maxLiquidityPoolBalance maximum liquidity pool balance\r\n    /// @param autoRebalanceThresholdInThousands auto rebalance threshold in thousands\r\n    /// @param ammTreasuryAndAssetManagementRatio AMM treasury and asset management ratio\r\n    event AmmPoolsParamsChanged(\r\n        address indexed asset,\r\n        uint32 maxLiquidityPoolBalance,\r\n        uint32 autoRebalanceThresholdInThousands,\r\n        uint16 ammTreasuryAndAssetManagementRatio\r\n    );\r\n\r\n    /// @notice Adds new liquidator to the list of SwapLiquidators.\r\n    /// @param asset address of the asset (pool)\r\n    /// @param account address of the new liquidator\r\n    /// @dev Allowed only for the owner of the Ipor Protocol Router\r\n    function addSwapLiquidator(address asset, address account) internal {\r\n        require(account != address(0), IporErrors.WRONG_ADDRESS);\r\n        require(asset != address(0), IporErrors.WRONG_ADDRESS);\r\n\r\n        mapping(address => mapping(address => bool)) storage swapLiquidators = StorageLib\r\n            .getAmmSwapsLiquidatorsStorage()\r\n            .value;\r\n        swapLiquidators[asset][account] = true;\r\n\r\n        emit AmmSwapsLiquidatorChanged(asset, account, true);\r\n    }\r\n\r\n    /// @notice Removes liquidator from the list of SwapLiquidators.\r\n    /// @param asset address of the asset (pool)\r\n    /// @param account address of the liquidator\r\n    /// @dev Allowed only for the owner of the Ipor Protocol Router\r\n    function removeSwapLiquidator(address asset, address account) internal {\r\n        require(account != address(0), IporErrors.WRONG_ADDRESS);\r\n        require(asset != address(0), IporErrors.WRONG_ADDRESS);\r\n\r\n        mapping(address => mapping(address => bool)) storage swapLiquidators = StorageLib\r\n            .getAmmSwapsLiquidatorsStorage()\r\n            .value;\r\n        swapLiquidators[asset][account] = false;\r\n\r\n        emit AmmSwapsLiquidatorChanged(asset, account, false);\r\n    }\r\n\r\n    /// @notice Checks if account is a SwapLiquidator.\r\n    /// @param asset address of the asset (pool)\r\n    /// @param account address of the account\r\n    /// @return true if account is a SwapLiquidator, false otherwise\r\n    function isSwapLiquidator(address asset, address account) internal view returns (bool) {\r\n        mapping(address => mapping(address => bool)) storage swapLiquidators = StorageLib\r\n            .getAmmSwapsLiquidatorsStorage()\r\n            .value;\r\n        return swapLiquidators[asset][account];\r\n    }\r\n\r\n    /// @notice Adds new account to the list of AppointedToRebalance in AMM.\r\n    /// @param asset address of the asset (pool)\r\n    /// @param account address added to appointed to rebalance\r\n    /// @dev Allowed only for the owner of the Ipor Protocol Router\r\n    function addAppointedToRebalanceInAmm(address asset, address account) internal {\r\n        require(asset != address(0), IporErrors.WRONG_ADDRESS);\r\n        require(account != address(0), IporErrors.WRONG_ADDRESS);\r\n\r\n        mapping(address => mapping(address => bool)) storage appointedToRebalance = StorageLib\r\n            .getAmmPoolsAppointedToRebalanceStorage()\r\n            .value;\r\n        appointedToRebalance[asset][account] = true;\r\n\r\n        emit AmmAppointedToRebalanceChanged(asset, account, true);\r\n    }\r\n\r\n    /// @notice Removes account from the list of AppointedToRebalance in AMM.\r\n    /// @param asset address of the asset (pool)\r\n    /// @param account address removed from appointed to rebalance\r\n    /// @dev Allowed only for the owner of the Ipor Protocol Router\r\n    function removeAppointedToRebalanceInAmm(address asset, address account) internal {\r\n        require(asset != address(0), IporErrors.WRONG_ADDRESS);\r\n        require(account != address(0), IporErrors.WRONG_ADDRESS);\r\n\r\n        mapping(address => mapping(address => bool)) storage appointedToRebalance = StorageLib\r\n            .getAmmPoolsAppointedToRebalanceStorage()\r\n            .value;\r\n        appointedToRebalance[asset][account] = false;\r\n\r\n        emit AmmAppointedToRebalanceChanged(asset, account, false);\r\n    }\r\n\r\n    /// @notice Checks if account is appointed to rebalance in AMM.\r\n    /// @param asset address of the asset (pool)\r\n    /// @param account address of the account\r\n    /// @return true if account is appointed to rebalance, false otherwise\r\n    function isAppointedToRebalanceInAmm(address asset, address account) internal view returns (bool) {\r\n        mapping(address => mapping(address => bool)) storage appointedToRebalance = StorageLib\r\n            .getAmmPoolsAppointedToRebalanceStorage()\r\n            .value;\r\n        return appointedToRebalance[asset][account];\r\n    }\r\n\r\n    /// @notice Sets AMM Pools Params.\r\n    /// @param asset address of the asset (pool)\r\n    /// @param newMaxLiquidityPoolBalance maximum liquidity pool balance\r\n    /// @param newAutoRebalanceThresholdInThousands auto rebalance threshold in thousands\r\n    /// @param newAmmTreasuryAndAssetManagementRatio AMM treasury and asset management ratio\r\n    /// @dev Allowed only for the owner of the Ipor Protocol Router\r\n    function setAmmPoolsParams(\r\n        address asset,\r\n        uint32 newMaxLiquidityPoolBalance,\r\n        uint32 newAutoRebalanceThresholdInThousands,\r\n        uint16 newAmmTreasuryAndAssetManagementRatio\r\n    ) internal {\r\n        require(asset != address(0), IporErrors.WRONG_ADDRESS);\r\n        /// @dev newAmmTreasuryAndAssetManagementRatio is percentage with 2 decimals, example: 65% = 6500, (see description in StorageLib.AmmPoolsParamsValue)\r\n        /// value cannot be greater than 10000 which is 100%\r\n        require(newAmmTreasuryAndAssetManagementRatio < 1e4, AmmPoolsErrors.AMM_TREASURY_ASSET_MANAGEMENT_RATIO);\r\n\r\n        StorageLib.getAmmPoolsParamsStorage().value[asset] = StorageLib.AmmPoolsParamsValue({\r\n            maxLiquidityPoolBalance: newMaxLiquidityPoolBalance,\r\n            autoRebalanceThresholdInThousands: newAutoRebalanceThresholdInThousands,\r\n            ammTreasuryAndAssetManagementRatio: newAmmTreasuryAndAssetManagementRatio\r\n        });\r\n\r\n        emit AmmPoolsParamsChanged(\r\n            asset,\r\n            newMaxLiquidityPoolBalance,\r\n            newAutoRebalanceThresholdInThousands,\r\n            newAmmTreasuryAndAssetManagementRatio\r\n        );\r\n    }\r\n\r\n    /// @notice Gets AMM Pools Params.\r\n    /// @param asset address of the asset (pool)\r\n    /// @return AMM Pools Params struct\r\n    function getAmmPoolsParams(address asset) internal view returns (StorageLib.AmmPoolsParamsValue memory) {\r\n        return StorageLib.getAmmPoolsParamsStorage().value[asset];\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/math/IporMath.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\nlibrary IporMath {\r\n    uint256 private constant RAY = 1e27;\r\n\r\n    //@notice Division with rounding up on last position, x, and y is with MD\r\n    function division(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = (x + (y / 2)) / y;\r\n    }\r\n\r\n    function divisionInt(int256 x, int256 y) internal pure returns (int256 z) {\r\n        uint256 absX = uint256(x < 0 ? -x : x);\r\n        uint256 absY = uint256(y < 0 ? -y : y);\r\n\r\n        // Use bitwise XOR to get the sign on MBS bit then shift to LSB\r\n        // sign == 0x0000...0000 ==  0 if the number is non-negative\r\n        // sign == 0xFFFF...FFFF == -1 if the number is negative\r\n        int256 sign = (x ^ y) >> 255;\r\n\r\n        uint256 divAbs;\r\n        uint256 remainder;\r\n\r\n        unchecked {\r\n            divAbs = absX / absY;\r\n            remainder = absX % absY;\r\n        }\r\n        // Check if we need to round\r\n        if (sign < 0) {\r\n            // remainder << 1 left shift is equivalent to multiplying by 2\r\n            if (remainder << 1 > absY) {\r\n                ++divAbs;\r\n            }\r\n        } else {\r\n            if (remainder << 1 >= absY) {\r\n                ++divAbs;\r\n            }\r\n        }\r\n\r\n        // (sign | 1) is cheaper than (sign < 0) ? -1 : 1;\r\n        unchecked {\r\n            z = int256(divAbs) * (sign | 1);\r\n        }\r\n    }\r\n\r\n    function divisionWithoutRound(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x / y;\r\n    }\r\n\r\n    function convertWadToAssetDecimals(uint256 value, uint256 assetDecimals) internal pure returns (uint256) {\r\n        if (assetDecimals == 18) {\r\n            return value;\r\n        } else if (assetDecimals > 18) {\r\n            return value * 10 ** (assetDecimals - 18);\r\n        } else {\r\n            return division(value, 10 ** (18 - assetDecimals));\r\n        }\r\n    }\r\n\r\n    function convertWadToAssetDecimalsWithoutRound(\r\n        uint256 value,\r\n        uint256 assetDecimals\r\n    ) internal pure returns (uint256) {\r\n        if (assetDecimals == 18) {\r\n            return value;\r\n        } else if (assetDecimals > 18) {\r\n            return value * 10 ** (assetDecimals - 18);\r\n        } else {\r\n            return divisionWithoutRound(value, 10 ** (18 - assetDecimals));\r\n        }\r\n    }\r\n\r\n    function convertToWad(uint256 value, uint256 assetDecimals) internal pure returns (uint256) {\r\n        if (value > 0) {\r\n            if (assetDecimals == 18) {\r\n                return value;\r\n            } else if (assetDecimals > 18) {\r\n                return division(value, 10 ** (assetDecimals - 18));\r\n            } else {\r\n                return value * 10 ** (18 - assetDecimals);\r\n            }\r\n        } else {\r\n            return value;\r\n        }\r\n    }\r\n\r\n    function absoluteValue(int256 value) internal pure returns (uint256) {\r\n        return (uint256)(value < 0 ? -value : value);\r\n    }\r\n\r\n    function percentOf(uint256 value, uint256 rate) internal pure returns (uint256) {\r\n        return division(value * rate, 1e18);\r\n    }\r\n\r\n    /// @notice Calculates x^n where x and y are represented in RAY (27 decimals)\r\n    /// @param x base, represented in 27 decimals\r\n    /// @param n exponent, represented in 27 decimals\r\n    /// @return z x^n represented in 27 decimals\r\n    function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\r\n        assembly {\r\n            switch x\r\n            case 0 {\r\n                switch n\r\n                case 0 {\r\n                    z := RAY\r\n                }\r\n                default {\r\n                    z := 0\r\n                }\r\n            }\r\n            default {\r\n                switch mod(n, 2)\r\n                case 0 {\r\n                    z := RAY\r\n                }\r\n                default {\r\n                    z := x\r\n                }\r\n                let half := div(RAY, 2) // for rounding.\r\n                for {\r\n                    n := div(n, 2)\r\n                } n {\r\n                    n := div(n, 2)\r\n                } {\r\n                    let xx := mul(x, x)\r\n                    if iszero(eq(div(xx, x), x)) {\r\n                        revert(0, 0)\r\n                    }\r\n                    let xxRound := add(xx, half)\r\n                    if lt(xxRound, xx) {\r\n                        revert(0, 0)\r\n                    }\r\n                    x := div(xxRound, RAY)\r\n                    if mod(n, 2) {\r\n                        let zx := mul(z, x)\r\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\r\n                            revert(0, 0)\r\n                        }\r\n                        let zxRound := add(zx, half)\r\n                        if lt(zxRound, zx) {\r\n                            revert(0, 0)\r\n                        }\r\n                        z := div(zxRound, RAY)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IAmmGovernanceLens.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n/// @title Interface for interacting with AmmGovernanceLens. Interface responsible for reading data from AMM Governance.\r\ninterface IAmmGovernanceLens {\r\n    /// @notice Structure of common params described AMM Pool configuration\r\n    struct AmmGovernancePoolConfiguration {\r\n        /// @notice address of asset which represents specific pool\r\n        address asset;\r\n        /// @notice asset decimals\r\n        uint256 decimals;\r\n        /// @notice address of AMM Storage\r\n        address ammStorage;\r\n        /// @notice address of AMM Treasury\r\n        address ammTreasury;\r\n        /// @notice address of AMM Pools Treasury Wallet\r\n        address ammPoolsTreasury;\r\n        /// @notice address of user which is allowed to manage AMM Pools Treasury Wallet\r\n        address ammPoolsTreasuryManager;\r\n        /// @notice address of AMM Charlie Treasury Wallet\r\n        address ammCharlieTreasury;\r\n        /// @notice address of user which is allowed to manage AMM Charlie Treasury Wallet\r\n        address ammCharlieTreasuryManager;\r\n    }\r\n\r\n    /// @dev A struct to represent a pool's parameters configuration.\r\n    struct AmmPoolsParamsConfiguration {\r\n        /// @dev max liquidity pool balance in the asset pool, represented in 18 decimals\r\n        uint256 maxLiquidityPoolBalance;\r\n        /// @dev The threshold for auto-rebalancing the pool. Value represented without 18 decimals.\r\n        /// Value represents multiplication of 1000.\r\n        uint256 autoRebalanceThresholdInThousands;\r\n        /// @dev asset management ratio, represented without 18 decimals, value represents percentage with 2 decimals\r\n        /// 65% = 6500, 99,99% = 9999, this is a percentage which stay in Amm Treasury in opposite to Asset Management\r\n        /// based on AMM Treasury balance (100%).\r\n        uint256 ammTreasuryAndAssetManagementRatio;\r\n    }\r\n\r\n    /// @notice Gets the structure or common params described AMM Pool configuration\r\n    /// @param asset Address of asset which represents specific pool\r\n    /// @return poolConfiguration Structure of common params described AMM Pool configuration\r\n    function getAmmGovernancePoolConfiguration(\r\n        address asset\r\n    ) external view returns (AmmGovernancePoolConfiguration memory);\r\n\r\n    /// @notice Flag which indicates if given account is an liquidator for given asset\r\n    /// @param asset Address of asset which represents specific pool\r\n    /// @param account Address of account which is checked if is an liquidator\r\n    /// @return isSwapLiquidator Flag which indicates if given account is an liquidator for given asset\r\n    function isSwapLiquidator(address asset, address account) external view returns (bool);\r\n\r\n    /// @notice Flag which indicates if given account is an appointed to rebalance in AMM for given asset\r\n    /// @param asset Address of asset which represents specific pool\r\n    /// @param account Address of account which is checked if is an appointed to rebalance in AMM\r\n    /// @return isAppointedToRebalanceInAmm Flag which indicates if given account is an appointed to rebalance in AMM for given asset\r\n    function isAppointedToRebalanceInAmm(address asset, address account) external view returns (bool);\r\n\r\n    /// @notice Gets the structure or common params described AMM Pool configuration\r\n    /// @param asset Address of asset which represents specific pool\r\n    /// @return ammPoolsParams Structure of common params described AMM Pool configuration\r\n    function getAmmPoolsParams(address asset) external view returns (AmmPoolsParamsConfiguration memory);\r\n}\r\n\r\n// File: contracts/interfaces/IAmmGovernanceService.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n/// @title Interface for interacting with the AmmGovernanceService. Interface responsible for managing AMM Pools.\r\ninterface IAmmGovernanceService {\r\n    /// @notice Transfers the asset amount from the AmmTreasury to the AssetManagement. Action available only to the IPOR Protocol Owner.\r\n    /// @param asset Address of asset representing specific pool\r\n    /// @param assetAmount Amount of asset to transfer\r\n    function depositToAssetManagement(address asset, uint256 assetAmount) external;\r\n\r\n    /// @notice Transfers the asset amount from the AssetManagement to the AmmTreasury. Action available only to the IPOR Protocol Owner.\r\n    /// @param asset Address of asset representing specific pool\r\n    /// @param assetAmount Amount of asset to transfer\r\n    function withdrawFromAssetManagement(address asset, uint256 assetAmount) external;\r\n\r\n    /// @notice Transfers all of the asset from the AssetManagement to the AmmTreasury. Action available only to the IPOR Protocol Owner.\r\n    /// @param asset Address of the asset representing specific pool\r\n    function withdrawAllFromAssetManagement(address asset) external;\r\n\r\n    /// @notice Transfers the asset amount from the AmmTreasury to the Treasury Wallet. Action available only to the AMM Treasury Manager.\r\n    /// @dev The AMM collects a part of swap's opening fee adn accounts it towards the \"treasury\".\r\n    /// @param asset Address of asset representing specific pool\r\n    /// @param assetAmount Amount of asset to transfer\r\n    function transferToTreasury(address asset, uint256 assetAmount) external;\r\n\r\n    /// @notice Transfers the asset amount from the AmmTreasury to Oracle Treasury Wallet. Action available only to the  AMM Charlie Treasury Manager.\r\n    /// @dev A specific balance known as \"iporPublicationFee\" exists in AmmTreasury, which is used to collect IPOR publication fees from traders when they initiate swaps.\r\n    /// @dev Within the AmmTreasury, there exists a distinct balance known as \"iporPublicationFee,\" which is utilized by the AMM to accumulate IPOR publication fees from traders as they open swaps.\r\n    /// @param asset Address of asset representing specific pool\r\n    /// @param assetAmount Amount of asset to transfer\r\n    function transferToCharlieTreasury(address asset, uint256 assetAmount) external;\r\n\r\n    /// @notice Adds an account to the list of swap liquidators for a given asset. Action available only to IPOR Protocol Owner.\r\n    /// @param asset Address of asset representing specific pool\r\n    /// @param account Address of an account added to the list of swap liquidators\r\n    function addSwapLiquidator(address asset, address account) external;\r\n\r\n    /// @notice Removes an account from the list of swap liquidators for a given asset. Action available only to IPOR Protocol Owner.\r\n    /// @param asset Address of asset representing specific pool\r\n    /// @param account Address of an account removed to the list of swap liquidators\r\n    function removeSwapLiquidator(address asset, address account) external;\r\n\r\n    /// @notice Add an account to the list of addresses appointed to rebalance AMM for given asset. Action available only to the IPOR Protocol Owner.\r\n    /// @param asset Address of asset representing specific pool\r\n    /// @param account Address of an account added to the list of addresses appointed to rebalance in AMM\r\n    /// @dev Rebalancing the AMM is a process of moving liquidity between the AMM and the AssetManagement in the amount defined in param called \"ammTreasuryAndAssetManagementRatio\".\r\n    function addAppointedToRebalanceInAmm(address asset, address account) external;\r\n\r\n    /// @notice Remove account from the list of appointed to rebalance in AMM for given asset.\r\n    /// @param asset Address of asset which represents specific pool\r\n    /// @param account Address of account which is removed from the list of appointed to rebalance in AMM\r\n    /// @dev Rebalancing the AMM is a process of moving liquidity between the AMM and the AssetManagement in the amount defined in param called \"ammTreasuryAndAssetManagementRatio\".\r\n    function removeAppointedToRebalanceInAmm(address asset, address account) external;\r\n\r\n    /// @notice Sets AMM Pools params for a given asset (pool). Action available only to IPOR Protocol Owner.\r\n    /// @param asset Address of asset representing specific pool\r\n    /// @param newMaxLiquidityPoolBalance New max liquidity pool balance threshold. Value represented WITHOUT 18 decimals.\r\n    /// @param newAutoRebalanceThresholdInThousands New auto rebalance threshold in thousands. Value represented WITHOUT 18 decimals. Value represents multiplication of 1000.\r\n    /// @param newAmmTreasuryAndAssetManagementRatio New AMM Treasury and Asset Management ratio, represented WITHOUT 18 decimals, value represents percentage with 2 decimals. Example: 65% = 6500, 99,99% = 9999\r\n    function setAmmPoolsParams(\r\n        address asset,\r\n        uint32 newMaxLiquidityPoolBalance,\r\n        uint32 newAutoRebalanceThresholdInThousands,\r\n        uint16 newAmmTreasuryAndAssetManagementRatio\r\n    ) external;\r\n}\r\n\r\n// File: contracts/interfaces/types/AmmStorageTypes.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n/// @title Types used in AmmStorage smart contract\r\nlibrary AmmStorageTypes {\r\n    /// @notice struct representing swap's ID and direction\r\n    /// @dev direction = 0 - Pay Fixed - Receive Floating, direction = 1 - Receive Fixed - Pay Floating\r\n    struct IporSwapId {\r\n        /// @notice Swap's ID\r\n        uint256 id;\r\n        /// @notice Swap's direction, 0 - Pay Fixed Receive Floating, 1 - Receive Fixed Pay Floating\r\n        uint8 direction;\r\n    }\r\n\r\n    /// @notice Struct containing extended balance information.\r\n    /// @dev extended information includes: opening fee balance, liquidation deposit balance,\r\n    /// IPOR publication fee balance, treasury balance, all values are with 18 decimals\r\n    struct ExtendedBalancesMemory {\r\n        /// @notice Swap's balance for Pay Fixed leg\r\n        uint256 totalCollateralPayFixed;\r\n        /// @notice Swap's balance for Receive Fixed leg\r\n        uint256 totalCollateralReceiveFixed;\r\n        /// @notice Liquidity Pool's Balance\r\n        uint256 liquidityPool;\r\n        /// @notice AssetManagement's (Asset Management) balance\r\n        uint256 vault;\r\n        /// @notice IPOR publication fee balance. This balance is used to subsidise the oracle operations\r\n        uint256 iporPublicationFee;\r\n        /// @notice Balance of the DAO's treasury. Fed by portion of the opening fee set by the DAO\r\n        uint256 treasury;\r\n    }\r\n\r\n    /// @notice A struct with parameters required to calculate SOAP for pay fixed and receive fixed legs.\r\n    /// @dev Committed to the memory.\r\n    struct SoapIndicators {\r\n        /// @notice Value of interest accrued on a fixed leg of all derivatives for this particular type of swap.\r\n        /// @dev Represented in 18 decimals.\r\n        uint256 hypotheticalInterestCumulative;\r\n        /// @notice Sum of all swaps' notional amounts for a given leg.\r\n        /// @dev Represented in 18 decimals.\r\n        uint256 totalNotional;\r\n        /// @notice Sum of all IBTs on a given leg.\r\n        /// @dev Represented in 18 decimals.\r\n        uint256 totalIbtQuantity;\r\n        /// @notice The notional-weighted average interest rate of all swaps on a given leg combined.\r\n        /// @dev Represented in 18 decimals.\r\n        uint256 averageInterestRate;\r\n        /// @notice EPOCH timestamp of when the most recent rebalancing took place\r\n        uint256 rebalanceTimestamp;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/types/IporTypes.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n/// @title Struct used across various interfaces in IPOR Protocol.\r\nlibrary IporTypes {\r\n    /// @notice enum describing Swap's state, ACTIVE - when the swap is opened, INACTIVE when it's closed\r\n    enum SwapState {\r\n        INACTIVE,\r\n        ACTIVE\r\n    }\r\n\r\n    /// @notice enum describing Swap's duration, 28 days, 60 days or 90 days\r\n    enum SwapTenor {\r\n        DAYS_28,\r\n        DAYS_60,\r\n        DAYS_90\r\n    }\r\n\r\n    /// @notice The struct describing the IPOR and its params calculated for the time when it was most recently updated and the change that took place since the update.\r\n    /// Namely, the interest that would be computed into IBT should the rebalance occur.\r\n    struct  AccruedIpor {\r\n        /// @notice IPOR Index Value\r\n        /// @dev value represented in 18 decimals\r\n        uint256 indexValue;\r\n        /// @notice IBT Price (IBT - Interest Bearing Token). For more information refer to the documentation:\r\n        /// https://ipor-labs.gitbook.io/ipor-labs/interest-rate-derivatives/ibt\r\n        /// @dev value represented in 18 decimals\r\n        uint256 ibtPrice;\r\n    }\r\n\r\n    /// @notice Struct representing balances used internally for asset calculations\r\n    /// @dev all balances in 18 decimals\r\n    struct AmmBalancesMemory {\r\n        /// @notice Sum of all collateral put forward by the derivative buyer's on  Pay Fixed & Receive Floating leg.\r\n        uint256 totalCollateralPayFixed;\r\n        /// @notice Sum of all collateral put forward by the derivative buyer's on  Pay Floating & Receive Fixed leg.\r\n        uint256 totalCollateralReceiveFixed;\r\n        /// @notice Liquidity Pool Balance. This balance is where the liquidity from liquidity providers and the opening fee are accounted for,\r\n        /// @dev Amount of opening fee accounted in this balance is defined by _OPENING_FEE_FOR_TREASURY_PORTION_RATE param.\r\n        uint256 liquidityPool;\r\n        /// @notice Vault's balance, describes how much asset has been transferred to Asset Management Vault (AssetManagement)\r\n        uint256 vault;\r\n    }\r\n\r\n    struct AmmBalancesForOpenSwapMemory {\r\n        /// @notice Sum of all collateral put forward by the derivative buyer's on  Pay Fixed & Receive Floating leg.\r\n        uint256 totalCollateralPayFixed;\r\n        /// @notice Total notional amount of all swaps on  Pay Fixed leg (denominated in 18 decimals).\r\n        uint256 totalNotionalPayFixed;\r\n        /// @notice Sum of all collateral put forward by the derivative buyer's on  Pay Floating & Receive Fixed leg.\r\n        uint256 totalCollateralReceiveFixed;\r\n        /// @notice Total notional amount of all swaps on  Receive Fixed leg (denominated in 18 decimals).\r\n        uint256 totalNotionalReceiveFixed;\r\n        /// @notice Liquidity Pool Balance.\r\n        uint256 liquidityPool;\r\n    }\r\n\r\n    struct SpreadInputs {\r\n        //// @notice Swap's assets DAI/USDC/USDT\r\n        address asset;\r\n        /// @notice Swap's notional value\r\n        uint256 swapNotional;\r\n        /// @notice demand spread factor used in demand spread calculation\r\n        uint256 demandSpreadFactor;\r\n        /// @notice Base spread\r\n        int256 baseSpreadPerLeg;\r\n        /// @notice Swap's balance for Pay Fixed leg\r\n        uint256 totalCollateralPayFixed;\r\n        /// @notice Swap's balance for Receive Fixed leg\r\n        uint256 totalCollateralReceiveFixed;\r\n        /// @notice Liquidity Pool's Balance\r\n        uint256 liquidityPoolBalance;\r\n        /// @notice Ipor index value at the time of swap creation\r\n        uint256 iporIndexValue;\r\n        // @notice fixed rate cap for given leg for offered rate without demandSpread in 18 decimals\r\n        uint256 fixedRateCapPerLeg;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/types/AmmTypes.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n\r\n/// @title Types used in interfaces strictly related to AMM (Automated Market Maker).\r\n/// @dev Used by IAmmTreasury and IAmmStorage interfaces.\r\nlibrary AmmTypes {\r\n    /// @notice Struct describing AMM Pool's core addresses.\r\n    struct AmmPoolCoreModel {\r\n        /// @notice asset address\r\n        address asset;\r\n        /// @notice asset decimals\r\n        uint256 assetDecimals;\r\n        /// @notice ipToken address associated to the asset\r\n        address ipToken;\r\n        /// @notice AMM Storage address\r\n        address ammStorage;\r\n        /// @notice AMM Treasury address\r\n        address ammTreasury;\r\n        /// @notice Asset Management address\r\n        address assetManagement;\r\n        /// @notice IPOR Oracle address\r\n        address iporOracle;\r\n        /// @notice IPOR Risk Management Oracle address\r\n        address iporRiskManagementOracle;\r\n    }\r\n\r\n    /// @notice Structure which represents Swap's data that will be saved in the storage.\r\n    /// Refer to the documentation https://ipor-labs.gitbook.io/ipor-labs/automated-market-maker/ipor-swaps for more information.\r\n    struct NewSwap {\r\n        /// @notice Account / trader who opens the Swap\r\n        address buyer;\r\n        /// @notice Epoch timestamp of when position was opened by the trader.\r\n        uint256 openTimestamp;\r\n        /// @notice Swap's collateral amount.\r\n        /// @dev value represented in 18 decimals\r\n        uint256 collateral;\r\n        /// @notice Swap's notional amount.\r\n        /// @dev value represented in 18 decimals\r\n        uint256 notional;\r\n        /// @notice Quantity of Interest Bearing Token (IBT) at moment when position was opened.\r\n        /// @dev value represented in 18 decimals\r\n        uint256 ibtQuantity;\r\n        /// @notice Fixed interest rate at which the position has been opened.\r\n        /// @dev value represented in 18 decimals\r\n        uint256 fixedInterestRate;\r\n        /// @notice Liquidation deposit is retained when the swap is opened. It is then paid back to agent who closes the derivative at maturity.\r\n        /// It can be both trader or community member. Trader receives the deposit back when he chooses to close the derivative before maturity.\r\n        /// @dev value represented WITHOUT 18 decimals\r\n        uint256 liquidationDepositAmount;\r\n        /// @notice Opening fee amount part which is allocated in Liquidity Pool Balance. This fee is calculated as a rate of the swap's collateral.\r\n        /// @dev value represented in 18 decimals\r\n        uint256 openingFeeLPAmount;\r\n        /// @notice Opening fee amount part which is allocated in Treasury Balance. This fee is calculated as a rate of the swap's collateral.\r\n        /// @dev value represented in 18 decimals\r\n        uint256 openingFeeTreasuryAmount;\r\n        /// @notice Swap's tenor, 0 - 28 days, 1 - 60 days or 2 - 90 days\r\n        IporTypes.SwapTenor tenor;\r\n    }\r\n\r\n    /// @notice Struct representing swap item, used for listing and in internal calculations\r\n    struct Swap {\r\n        /// @notice Swap's unique ID\r\n        uint256 id;\r\n        /// @notice Swap's buyer\r\n        address buyer;\r\n        /// @notice Swap opening epoch timestamp\r\n        uint256 openTimestamp;\r\n        /// @notice Swap's tenor\r\n        IporTypes.SwapTenor tenor;\r\n        /// @notice Index position of this Swap in an array of swaps' identification associated to swap buyer\r\n        /// @dev Field used for gas optimization purposes, it allows for quick removal by id in the array.\r\n        /// During removal the last item in the array is switched with the one that just has been removed.\r\n        uint256 idsIndex;\r\n        /// @notice Swap's collateral\r\n        /// @dev value represented in 18 decimals\r\n        uint256 collateral;\r\n        /// @notice Swap's notional amount\r\n        /// @dev value represented in 18 decimals\r\n        uint256 notional;\r\n        /// @notice Swap's notional amount denominated in the Interest Bearing Token (IBT)\r\n        /// @dev value represented in 18 decimals\r\n        uint256 ibtQuantity;\r\n        /// @notice Fixed interest rate at which the position has been opened\r\n        /// @dev value represented in 18 decimals\r\n        uint256 fixedInterestRate;\r\n        /// @notice Liquidation deposit amount\r\n        /// @dev value represented in 18 decimals\r\n        uint256 liquidationDepositAmount;\r\n        /// @notice State of the swap\r\n        /// @dev 0 - INACTIVE, 1 - ACTIVE\r\n        IporTypes.SwapState state;\r\n    }\r\n\r\n    /// @notice Struct representing amounts related to Swap that is presently being opened.\r\n    /// @dev all values represented in 18 decimals\r\n    struct OpenSwapAmount {\r\n        /// @notice Total Amount of asset that is sent from buyer to AmmTreasury when opening swap.\r\n        uint256 totalAmount;\r\n        /// @notice Swap's collateral\r\n        uint256 collateral;\r\n        /// @notice Swap's notional\r\n        uint256 notional;\r\n        /// @notice Opening Fee - part allocated as a profit of the Liquidity Pool\r\n        uint256 openingFeeLPAmount;\r\n        /// @notice  Part of the fee set aside for subsidizing the oracle that publishes IPOR rate. Flat fee set by the DAO.\r\n        /// @notice Opening Fee - part allocated in Treasury balance. Part of the fee set asside for subsidising the oracle that publishes IPOR rate. Flat fee set by the DAO.\r\n        uint256 openingFeeTreasuryAmount;\r\n        /// @notice Fee set aside for subsidizing the oracle that publishes IPOR rate. Flat fee set by the DAO.\r\n        uint256 iporPublicationFee;\r\n        /// @notice Liquidation deposit is retained when the swap is opened. Value represented in 18 decimals.\r\n        uint256 liquidationDepositAmount;\r\n    }\r\n\r\n    /// @notice Structure describes one swap processed by closeSwaps method, information about swap ID and flag if this swap was closed during execution closeSwaps method.\r\n    struct IporSwapClosingResult {\r\n        /// @notice Swap ID\r\n        uint256 swapId;\r\n        /// @notice Flag describe if swap was closed during this execution\r\n        bool closed;\r\n    }\r\n\r\n    /// @notice Technical structure used for storing information about amounts used during redeeming assets from liquidity pool.\r\n    struct RedeemAmount {\r\n        /// @notice Asset amount represented in 18 decimals\r\n        /// @dev Asset amount is a sum of wadRedeemFee and wadRedeemAmount\r\n        uint256 wadAssetAmount;\r\n        /// @notice Redeemed amount represented in decimals of asset\r\n        uint256 redeemAmount;\r\n        /// @notice Redeem fee value represented in 18 decimals\r\n        uint256 wadRedeemFee;\r\n        /// @notice Redeem amount represented in 18 decimals\r\n        uint256 wadRedeemAmount;\r\n    }\r\n\r\n    /// @notice Swap direction (long = Pay Fixed and Receive a Floating or short = receive fixed and pay a floating)\r\n    enum SwapDirection {\r\n        /// @notice When taking the \"long\" position the trader will pay a fixed rate and receive a floating rate.\r\n        /// for more information refer to the documentation https://ipor-labs.gitbook.io/ipor-labs/automated-market-maker/ipor-swaps\r\n        PAY_FIXED_RECEIVE_FLOATING,\r\n        /// @notice When taking the \"short\" position the trader will pay a floating rate and receive a fixed rate.\r\n        PAY_FLOATING_RECEIVE_FIXED\r\n    }\r\n    /// @notice List of closable statuses for a given swap\r\n    /// @dev Closable status is a one of the following values:\r\n    /// 0 - Swap is closable\r\n    /// 1 - Swap is already closed\r\n    /// 2 - Swap state required Buyer or Liquidator to close. Sender is not Buyer nor Liquidator.\r\n    /// 3 - Cannot close swap, closing is too early for Community\r\n    enum SwapClosableStatus {\r\n        SWAP_IS_CLOSABLE,\r\n        SWAP_ALREADY_CLOSED,\r\n        SWAP_REQUIRED_BUYER_OR_LIQUIDATOR_TO_CLOSE,\r\n        SWAP_CANNOT_CLOSE_CLOSING_TOO_EARLY_FOR_COMMUNITY\r\n    }\r\n\r\n    /// @notice Collection of swap attributes connected with IPOR Index and swap itself.\r\n    /// @dev all values are in 18 decimals\r\n    struct IporSwapIndicator {\r\n        /// @notice IPOR Index value at the time of swap opening\r\n        uint256 iporIndexValue;\r\n        /// @notice IPOR Interest Bearing Token (IBT) price at the time of swap opening\r\n        uint256 ibtPrice;\r\n        /// @notice Swap's notional denominated in IBT\r\n        uint256 ibtQuantity;\r\n        /// @notice Fixed interest rate at which the position has been opened,\r\n        /// it is quote from spread documentation\r\n        uint256 fixedInterestRate;\r\n    }\r\n\r\n    /// @notice Risk indicators calculated for swap opening\r\n    struct OpenSwapRiskIndicators {\r\n        /// @notice Maximum collateral ratio in general\r\n        uint256 maxCollateralRatio;\r\n        /// @notice Maximum collateral ratio for a given leg\r\n        uint256 maxCollateralRatioPerLeg;\r\n        /// @notice Maximum leverage for a given leg\r\n        uint256 maxLeveragePerLeg;\r\n        /// @notice Base Spread for a given leg (without demand part)\r\n        int256 baseSpreadPerLeg;\r\n        /// @notice Fixed rate cap\r\n        uint256 fixedRateCapPerLeg;\r\n        /// @notice Demand spread factor used to calculate demand spread\r\n        uint256 demandSpreadFactor;\r\n    }\r\n\r\n    /// @notice Structure containing information about swap's closing status, unwind values and PnL for a given swap and time.\r\n    struct ClosingSwapDetails {\r\n        /// @notice Swap's closing status\r\n        AmmTypes.SwapClosableStatus closableStatus;\r\n        /// @notice Flag indicating if swap unwind is required\r\n        bool swapUnwindRequired;\r\n        /// @notice Swap's unwind PnL Value, part of PnL corresponded to virtual swap (unwinded swap), represented in 18 decimals\r\n        int256 swapUnwindPnlValue;\r\n        /// @notice Unwind opening fee amount it is a sum of `swapUnwindFeeLPAmount` and `swapUnwindFeeTreasuryAmount`\r\n        uint256 swapUnwindOpeningFeeAmount;\r\n        /// @notice Part of unwind opening fee allocated as a profit of the Liquidity Pool\r\n        uint256 swapUnwindFeeLPAmount;\r\n        /// @notice Part of unwind opening fee allocated in Treasury Balance\r\n        uint256 swapUnwindFeeTreasuryAmount;\r\n        /// @notice Final Profit and Loss which takes into account the swap unwind and limits the PnL to the collateral amount. Represented in 18 decimals.\r\n        int256 pnlValue;\r\n    }\r\n}\r\n\r\n// File: contracts/amm/libraries/types/AmmInternalTypes.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n\r\n\r\n/// @notice The types used in the AmmTreasury's interface.\r\n/// @dev All values, where applicable, are represented in 18 decimals.\r\nlibrary AmmInternalTypes {\r\n    struct PnlValueStruct    {\r\n        /// @notice PnL Value of the swap.\r\n        int256 pnlValue;\r\n        /// @notice flag indicating if unwind is required when closing swap.\r\n        bool swapUnwindRequired;\r\n        /// @notice Unwind amount of the swap.\r\n        int256 swapUnwindAmount;\r\n        /// @notice Unwind fee of the swap that will be added to the AMM liquidity pool balance.\r\n        uint256 swapUnwindFeeLPAmount;\r\n        /// @notice Unwind fee of the swap that will be added to the AMM treasury balance.\r\n        uint256 swapUnwindFeeTreasuryAmount;\r\n    }\r\n\r\n    struct BeforeOpenSwapStruct {\r\n        /// @notice Sum of all asset transfered when opening swap. It includes the collateral, fees and desposits.\r\n        /// @dev The amount is represented in 18 decimals regardless of the decimals of the asset.\r\n        uint256 wadTotalAmount;\r\n        /// @notice Swap's collateral.\r\n        uint256 collateral;\r\n        /// @notice Swap's notional amount.\r\n        uint256 notional;\r\n        /// @notice The part of the opening fee that will be added to the liquidity pool balance.\r\n        uint256 openingFeeLPAmount;\r\n        /// @notice Part of the opening fee that will be added to the treasury balance.\r\n        uint256 openingFeeTreasuryAmount;\r\n        /// @notice Amount of asset set aside for the oracle subsidization.\r\n        uint256 iporPublicationFeeAmount;\r\n        /// @notice Refundable deposit blocked for the entity that will close the swap.\r\n        /// For more information on how the liquidations work refer to the documentation.\r\n        /// https://ipor-labs.gitbook.io/ipor-labs/automated-market-maker/liquidations\r\n        /// @dev value represented without decimals, as an integer\r\n        uint256 liquidationDepositAmount;\r\n        /// @notice The struct describing the IPOR and its params calculated for the time when it was most recently updated and the change that took place since the update.\r\n        /// Namely, the interest that would be computed into IBT should the rebalance occur.\r\n        IporTypes.AccruedIpor accruedIpor;\r\n    }\r\n\r\n    /// @notice Risk indicators context data\r\n    struct RiskIndicatorsContext {\r\n        /// @notice Asset address for which the risk indicators are calculated.\r\n        address asset;\r\n        /// @notice Ipor Risk Management Oracle address.\r\n        address iporRiskManagementOracle;\r\n        /// @notice Tenor of the swap.\r\n        IporTypes.SwapTenor tenor;\r\n        /// @notice AMM Liquidity Pool balance.\r\n        uint256 liquidityPoolBalance;\r\n        /// @notice AMM Min Leverage allowed for a swap.\r\n        uint256 minLeverage;\r\n    }\r\n\r\n    /// @notice Spread context data\r\n    struct SpreadContext {\r\n        /// @notice Asset address for which the spread is calculated.\r\n        address asset;\r\n        /// @notice Signature of spread method used to calculate spread.\r\n        bytes4 spreadFunctionSig;\r\n        /// @notice Tenor of the swap.\r\n        IporTypes.SwapTenor tenor;\r\n        /// @notice Swap's notional\r\n        uint256 notional;\r\n        /// @notice Minimum leverage allowed for a swap.\r\n        uint256 minLeverage;\r\n        /// @notice Ipor Index Value\r\n        uint256 indexValue;\r\n        /// @notice Risk Indicators data for a opened swap used to calculate spread.\r\n        AmmTypes.OpenSwapRiskIndicators riskIndicators;\r\n        /// @notice AMM Balance for a opened swap used to calculate spread.\r\n        IporTypes.AmmBalancesForOpenSwapMemory balance;\r\n    }\r\n\r\n    /// @notice Open swap item - element of linked list of swaps\r\n    struct OpenSwapItem {\r\n        /// @notice Swap ID\r\n        uint32 swapId;\r\n        /// @notcie Next swap ID in linked list\r\n        uint32 nextSwapId;\r\n        /// @notice Previous swap ID in linked list\r\n        uint32 previousSwapId;\r\n        /// @notice Timestamp of the swap opening\r\n        uint32 openSwapTimestamp;\r\n    }\r\n\r\n    /// @notice Open swap list structure\r\n    struct OpenSwapList {\r\n        /// @notice Head swap ID\r\n        uint32 headSwapId;\r\n        /// @notice Swaps mapping, where key is swap ID\r\n        mapping(uint32 => OpenSwapItem) swaps;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IAmmStorage.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n\r\n\r\n\r\n\r\n/// @title Interface for interaction with the IPOR AMM Storage, contract responsible for managing AMM storage.\r\ninterface IAmmStorage {\r\n    /// @notice Returns the current version of AmmTreasury Storage\r\n    /// @dev Increase number when the implementation inside source code is different that the implementation deployed on the Mainnet\r\n    /// @return current AmmTreasury Storage version, integer\r\n    function getVersion() external pure returns (uint256);\r\n\r\n    /// @notice Gets the configuration of the IPOR AMM Storage.\r\n    /// @return ammTreasury address of the AmmTreasury contract\r\n    /// @return router address of the IPOR Protocol Router contract\r\n    function getConfiguration() external view returns (address ammTreasury, address router);\r\n\r\n    /// @notice Gets last swap ID.\r\n    /// @dev swap ID is incremented when new position is opened, last swap ID is used in Pay Fixed and Receive Fixed swaps.\r\n    /// @dev ID is global for all swaps, regardless if they are Pay Fixed or Receive Fixed in tenor 28, 60 or 90 days.\r\n    /// @return last swap ID, integer\r\n    function getLastSwapId() external view returns (uint256);\r\n\r\n    /// @notice Gets the last opened swap for a given tenor and direction.\r\n    /// @param tenor tenor of the swap\r\n    /// @param direction direction of the swap: 0 for Pay Fixed, 1 for Receive Fixed\r\n    /// @return last opened swap {AmmInternalTypes.OpenSwapItem}\r\n    function getLastOpenedSwap(\r\n        IporTypes.SwapTenor tenor,\r\n        uint256 direction\r\n    ) external view returns (AmmInternalTypes.OpenSwapItem memory);\r\n\r\n    /// @notice Gets the AMM balance struct\r\n    /// @dev Balance contains:\r\n    /// # Pay Fixed Total Collateral\r\n    /// # Receive Fixed Total Collateral\r\n    /// # Liquidity Pool and Vault balances.\r\n    /// @return balance structure {IporTypes.AmmBalancesMemory}\r\n    function getBalance() external view returns (IporTypes.AmmBalancesMemory memory);\r\n\r\n    /// @notice Gets the balance for open swap\r\n    /// @dev Balance contains:\r\n    /// # Pay Fixed Total Collateral\r\n    /// # Receive Fixed Total Collateral\r\n    /// # Liquidity Pool balance\r\n    /// # Total Notional Pay Fixed\r\n    /// # Total Notional Receive Fixed\r\n    /// @return balance structure {IporTypes.AmmBalancesForOpenSwapMemory}\r\n    function getBalancesForOpenSwap() external view returns (IporTypes.AmmBalancesForOpenSwapMemory memory);\r\n\r\n    /// @notice Gets the balance with the extended information: IPOR publication fee balance and Treasury balance.\r\n    /// @return balance structure {AmmStorageTypes.ExtendedBalancesMemory}\r\n    function getExtendedBalance() external view returns (AmmStorageTypes.ExtendedBalancesMemory memory);\r\n\r\n    /// @notice gets the SOAP indicators.\r\n    /// @dev SOAP is a Sum Of All Payouts, aka undealised PnL.\r\n    /// @return indicatorsPayFixed structure {AmmStorageTypes.SoapIndicators} indicators for Pay Fixed swaps\r\n    /// @return indicatorsReceiveFixed structure {AmmStorageTypes.SoapIndicators} indicators for Receive Fixed swaps\r\n    function getSoapIndicators()\r\n        external\r\n        view\r\n        returns (\r\n            AmmStorageTypes.SoapIndicators memory indicatorsPayFixed,\r\n            AmmStorageTypes.SoapIndicators memory indicatorsReceiveFixed\r\n        );\r\n\r\n    /// @notice Gets swap based on the direction and swap ID.\r\n    /// @param direction direction of the swap: 0 for Pay Fixed, 1 for Receive Fixed\r\n    /// @param swapId swap ID\r\n    /// @return swap structure {AmmTypes.Swap}\r\n    function getSwap(AmmTypes.SwapDirection direction, uint256 swapId) external view returns (AmmTypes.Swap memory);\r\n\r\n    /// @notice Gets the active Pay-Fixed swaps for a given account address.\r\n    /// @param account account address\r\n    /// @param offset offset for paging\r\n    /// @param chunkSize page size for paging\r\n    /// @return totalCount total number of active Pay-Fixed swaps\r\n    /// @return swaps array where each element has structure {AmmTypes.Swap}\r\n    function getSwapsPayFixed(\r\n        address account,\r\n        uint256 offset,\r\n        uint256 chunkSize\r\n    ) external view returns (uint256 totalCount, AmmTypes.Swap[] memory swaps);\r\n\r\n    /// @notice Gets the active Receive-Fixed swaps for a given account address.\r\n    /// @param account account address\r\n    /// @param offset offset for paging\r\n    /// @param chunkSize page size for paging\r\n    /// @return totalCount total number of active Receive Fixed swaps\r\n    /// @return swaps array where each element has structure {AmmTypes.Swap}\r\n    function getSwapsReceiveFixed(\r\n        address account,\r\n        uint256 offset,\r\n        uint256 chunkSize\r\n    ) external view returns (uint256 totalCount, AmmTypes.Swap[] memory swaps);\r\n\r\n    /// @notice Gets the active Pay-Fixed and Receive-Fixed swaps IDs for a given account address.\r\n    /// @param account account address\r\n    /// @param offset offset for paging\r\n    /// @param chunkSize page size for paging\r\n    /// @return totalCount total number of active Pay-Fixed and Receive-Fixed IDs.\r\n    /// @return ids array where each element has structure {AmmStorageTypes.IporSwapId}\r\n    function getSwapIds(\r\n        address account,\r\n        uint256 offset,\r\n        uint256 chunkSize\r\n    ) external view returns (uint256 totalCount, AmmStorageTypes.IporSwapId[] memory ids);\r\n\r\n    /// @notice adds liquidity to the Liquidity Pool. Function available only to Router.\r\n    /// @param account account address executing request for redeem asset amount\r\n    /// @param assetAmount amount of asset added to balance of Liquidity Pool, represented in 18 decimals\r\n    /// @param cfgMaxLiquidityPoolBalance max liquidity pool balance taken from AmmPoolsService configuration, represented in 18 decimals.\r\n    /// @dev Function is only available to AmmPoolsService, can be executed only by IPOR Protocol Router as internal interaction.\r\n    function addLiquidityInternal(address account, uint256 assetAmount, uint256 cfgMaxLiquidityPoolBalance) external;\r\n\r\n    /// @notice subtract liquidity from the Liquidity Pool. Function available only to Router.\r\n    /// @param assetAmount amount of asset subtracted from Liquidity Pool, represented in 18 decimals\r\n    /// @dev Function is only available to AmmPoolsService, it can be executed only by IPOR Protocol Router as internal interaction.\r\n    function subtractLiquidityInternal(uint256 assetAmount) external;\r\n\r\n    /// @notice Updates structures in storage: balance, swaps, SOAP indicators when new Pay-Fixed swap is opened.\r\n    /// @dev Function is only available to AmmOpenSwapService, it can be executed only by IPOR Protocol Router as internal interaction.\r\n    /// @param newSwap new swap structure {AmmTypes.NewSwap}\r\n    /// @param cfgIporPublicationFee publication fee amount taken from AmmTreasury configuration, represented in 18 decimals.\r\n    /// @return new swap ID\r\n    function updateStorageWhenOpenSwapPayFixedInternal(\r\n        AmmTypes.NewSwap memory newSwap,\r\n        uint256 cfgIporPublicationFee\r\n    ) external returns (uint256);\r\n\r\n    /// @notice Updates structures in the storage: balance, swaps, SOAP indicators when new Receive-Fixed swap is opened.\r\n    /// @dev Function is only available to AmmOpenSwapService, it can be executed only by IPOR Protocol Router as internal interaction.\r\n    /// @param newSwap new swap structure {AmmTypes.NewSwap}\r\n    /// @param cfgIporPublicationFee publication fee amount taken from AmmTreasury configuration, represented in 18 decimals.\r\n    /// @return new swap ID\r\n    function updateStorageWhenOpenSwapReceiveFixedInternal(\r\n        AmmTypes.NewSwap memory newSwap,\r\n        uint256 cfgIporPublicationFee\r\n    ) external returns (uint256);\r\n\r\n    /// @notice Updates structures in the storage: balance, swaps, SOAP indicators when closing Pay-Fixed swap.\r\n    /// @dev Function is only available to AmmCloseSwapService, it can be executed only by IPOR Protocol Router as internal interaction.\r\n    /// @param swap The swap structure containing IPOR swap information.\r\n    /// @param pnlValue The amount that the trader has earned or lost on the swap, represented in 18 decimals.\r\n    /// pnValue can be negative, pnlValue NOT INCLUDE potential unwind fee.\r\n    /// @param swapUnwindFeeLPAmount unwind fee which is accounted on AMM Liquidity Pool balance.\r\n    /// @param swapUnwindFeeTreasuryAmount unwind fee which is accounted on AMM Treasury balance.\r\n    /// @param closingTimestamp The moment when the swap was closed.\r\n    /// @return closedSwap A memory struct representing the closed swap.\r\n    function updateStorageWhenCloseSwapPayFixedInternal(\r\n        AmmTypes.Swap memory swap,\r\n        int256 pnlValue,\r\n        uint256 swapUnwindFeeLPAmount,\r\n        uint256 swapUnwindFeeTreasuryAmount,\r\n        uint256 closingTimestamp\r\n    ) external returns (AmmInternalTypes.OpenSwapItem memory closedSwap);\r\n\r\n    /// @notice Updates structures in the storage: swaps, balances, SOAP indicators when closing Receive-Fixed swap.\r\n    /// @dev Function is only available to AmmCloseSwapService, it can be executed only by IPOR Protocol Router as internal interaction.\r\n    /// @param swap The swap structure containing IPOR swap information.\r\n    /// @param pnlValue The amount that the trader has earned or lost on the swap, represented in 18 decimals.\r\n    /// pnValue can be negative, pnlValue NOT INCLUDE potential unwind fee.\r\n    /// @param swapUnwindFeeLPAmount unwind fee which is accounted on AMM Liquidity Pool balance.\r\n    /// @param swapUnwindFeeTreasuryAmount unwind fee which is accounted on AMM Treasury balance.\r\n    /// @param closingTimestamp The moment when the swap was closed.\r\n    /// @return closedSwap A memory struct representing the closed swap.\r\n    function updateStorageWhenCloseSwapReceiveFixedInternal(\r\n        AmmTypes.Swap memory swap,\r\n        int256 pnlValue,\r\n        uint256 swapUnwindFeeLPAmount,\r\n        uint256 swapUnwindFeeTreasuryAmount,\r\n        uint256 closingTimestamp\r\n    ) external returns (AmmInternalTypes.OpenSwapItem memory closedSwap);\r\n\r\n    /// @notice Updates the balance when the AmmPoolsService withdraws AmmTreasury's assets from the AssetManagement.\r\n    /// @dev Function is only available to the AmmTreasury contract.\r\n    /// @param withdrawnAmount asset amount that was withdrawn from AssetManagement to AmmTreasury by AmmPoolsService, represented in 18 decimals.\r\n    /// @param vaultBalance Asset Management Vault (AssetManagement) balance, represented in 18 decimals\r\n    function updateStorageWhenWithdrawFromAssetManagement(uint256 withdrawnAmount, uint256 vaultBalance) external;\r\n\r\n    /// @notice Updates the balance when AmmPoolsService deposits AmmTreasury's assets to AssetManagement. Function is only available to AmmTreasury.\r\n    /// @param depositAmount asset amount deposited from AmmTreasury to AssetManagement by AmmPoolsService, represented in 18 decimals.\r\n    /// @param vaultBalance actual Asset Management Vault(AssetManagement) balance , represented in 18 decimals\r\n    function updateStorageWhenDepositToAssetManagement(uint256 depositAmount, uint256 vaultBalance) external;\r\n\r\n    /// @notice Updates the balance when AmmPoolsService transfers AmmTreasury's assets to Oracle Treasury's multisig wallet.\r\n    /// @dev Function is only available to the AmmGovernanceService, can be executed only by IPOR Protocol Router as internal interaction.\r\n    /// @param transferredAmount asset amount transferred to Charlie Treasury multisig wallet.\r\n    function updateStorageWhenTransferToCharlieTreasuryInternal(uint256 transferredAmount) external;\r\n\r\n    /// @notice Updates the balance when AmmPoolsService transfers AmmTreasury's assets to Treasury's multisig wallet.\r\n    /// @dev Function is only available to the AmmGovernanceService, can be executed only by IPOR Protocol Router as internal interaction.\r\n    /// @param transferredAmount asset amount transferred to Treasury's multisig wallet.\r\n    function updateStorageWhenTransferToTreasuryInternal(uint256 transferredAmount) external;\r\n}\r\n\r\n// File: contracts/interfaces/IAmmTreasury.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n/// @title Interface for interaction with AmmTreasury, smart contract responsible for storing assets treasury for AMM\r\ninterface IAmmTreasury {\r\n    /// @notice Returns the current version of AmmTreasury\r\n    /// @dev Increase the number when the implementation inside source code is different that implementation deployed on Mainnet\r\n    /// @return Current AmmTreasury's version\r\n    function getVersion() external pure returns (uint256);\r\n\r\n    /// @notice Gets the configuration of AmmTreasury\r\n    /// @return asset address of asset\r\n    /// @return decimals decimals of asset\r\n    /// @return ammStorage address of AmmStorage\r\n    /// @return assetManagement address of AssetManagement\r\n    /// @return iporProtocolRouter address of IporProtocolRouter\r\n    function getConfiguration()\r\n        external\r\n        view\r\n        returns (\r\n            address asset,\r\n            uint256 decimals,\r\n            address ammStorage,\r\n            address assetManagement,\r\n            address iporProtocolRouter\r\n        );\r\n\r\n    /// @notice Transfers the assets from the AmmTreasury to the AssetManagement.\r\n    /// @dev AmmTreasury balance in storage is not changing after this deposit, balance of ERC20 assets on AmmTreasury\r\n    /// is changing as they get transferred to the AssetManagement.\r\n    /// @param wadAssetAmount amount of asset, value represented in 18 decimals\r\n    /// @dev Function can be executed only by the IPOR Protocol Router as internal interaction.\r\n    function depositToAssetManagementInternal(uint256 wadAssetAmount) external;\r\n\r\n    /// @notice Transfers the assets from the AssetManagement to the AmmTreasury.\r\n    /// @dev AmmTreasury balance in storage is not changing, balance of ERC20 assets of AmmTreasury is changing.\r\n    /// @param wadAssetAmount amount of assets, value represented in 18 decimals\r\n    /// @dev Function can be executed only by the IPOR Protocol Router as internal interaction.\r\n    function withdrawFromAssetManagementInternal(uint256 wadAssetAmount) external;\r\n\r\n    /// @notice Transfers assets (underlying tokens) from the AssetManagement to the AmmTreasury.\r\n    /// @dev AmmTreasury Balance in storage is not changing after this withdraw, balance of ERC20 assets on AmmTreasury is changing.\r\n    /// @dev Function can be executed only by the IPOR Protocol Router as internal interaction.\r\n    function withdrawAllFromAssetManagementInternal() external;\r\n\r\n    /// @notice sets the max allowance for a given spender. Action available only for AmmTreasury contract Owner.\r\n    /// @param spender account which will have rights to transfer ERC20 underlying assets on behalf of AmmTreasury\r\n    function grantMaxAllowanceForSpender(address spender) external;\r\n\r\n    /// @notice sets the zero allowance for a given spender. Action available only for AmmTreasury contract Owner.\r\n    /// @param spender account which will have rights to transfer ERC20 underlying assets on behalf of AmmTreasury\r\n    function revokeAllowanceForSpender(address spender) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary AddressUpgradeable {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     *\r\n     * Furthermore, `isContract` will also return true if the target contract within\r\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\r\n     * which only has an effect at the end of a transaction.\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20PermitUpgradeable {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20Upgradeable {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20Upgradeable {\r\n    using AddressUpgradeable for address;\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\r\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\r\n        uint256 oldAllowance = token.allowance(address(this), spender);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\r\n     * to be set to zero before setting it to a non-zero value, such as USDT.\r\n     */\r\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\r\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\r\n\r\n        if (!_callOptionalReturnBool(token, approvalCall)) {\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\r\n            _callOptionalReturn(token, approvalCall);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\r\n     * Revert on invalid signature.\r\n     */\r\n    function safePermit(\r\n        IERC20PermitUpgradeable token,\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal {\r\n        uint256 nonceBefore = token.nonces(owner);\r\n        token.permit(owner, spender, value, deadline, v, r, s);\r\n        uint256 nonceAfter = token.nonces(owner);\r\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     *\r\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\r\n     */\r\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\r\n        // and not revert is the subcall reverts.\r\n\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        return\r\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     *\r\n     * Furthermore, `isContract` will also return true if the target contract within\r\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\r\n     * which only has an effect at the end of a transaction.\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/amm/AmmGovernanceService.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @dev It is not recommended to use service contract directly, should be used only through IporProtocolRouter.\r\ncontract AmmGovernanceService is IAmmGovernanceService, IAmmGovernanceLens {\r\n    using IporContractValidator for address;\r\n    using SafeERC20Upgradeable for IERC20Upgradeable;\r\n\r\n    address internal immutable _usdt;\r\n    uint256 internal immutable _usdtDecimals;\r\n    address internal immutable _usdtAmmStorage;\r\n    address internal immutable _usdtAmmTreasury;\r\n    address internal immutable _usdtAmmPoolsTreasury;\r\n    address internal immutable _usdtAmmPoolsTreasuryManager;\r\n    address internal immutable _usdtAmmCharlieTreasury;\r\n    address internal immutable _usdtAmmCharlieTreasuryManager;\r\n\r\n    address internal immutable _usdc;\r\n    uint256 internal immutable _usdcDecimals;\r\n    address internal immutable _usdcAmmStorage;\r\n    address internal immutable _usdcAmmTreasury;\r\n    address internal immutable _usdcAmmPoolsTreasury;\r\n    address internal immutable _usdcAmmPoolsTreasuryManager;\r\n    address internal immutable _usdcAmmCharlieTreasury;\r\n    address internal immutable _usdcAmmCharlieTreasuryManager;\r\n\r\n    address internal immutable _dai;\r\n    uint256 internal immutable _daiDecimals;\r\n    address internal immutable _daiAmmStorage;\r\n    address internal immutable _daiAmmTreasury;\r\n    address internal immutable _daiAmmPoolsTreasury;\r\n    address internal immutable _daiAmmPoolsTreasuryManager;\r\n    address internal immutable _daiAmmCharlieTreasury;\r\n    address internal immutable _daiAmmCharlieTreasuryManager;\r\n\r\n    constructor(\r\n        AmmGovernancePoolConfiguration memory usdtPoolCfg,\r\n        AmmGovernancePoolConfiguration memory usdcPoolCfg,\r\n        AmmGovernancePoolConfiguration memory daiPoolCfg\r\n    ) {\r\n        _usdt = usdtPoolCfg.asset.checkAddress();\r\n        _usdtDecimals = usdtPoolCfg.decimals;\r\n        _usdtAmmStorage = usdtPoolCfg.ammStorage.checkAddress();\r\n        _usdtAmmTreasury = usdtPoolCfg.ammTreasury.checkAddress();\r\n        _usdtAmmPoolsTreasury = usdtPoolCfg.ammPoolsTreasury.checkAddress();\r\n        _usdtAmmPoolsTreasuryManager = usdtPoolCfg.ammPoolsTreasuryManager.checkAddress();\r\n        _usdtAmmCharlieTreasury = usdtPoolCfg.ammCharlieTreasury.checkAddress();\r\n        _usdtAmmCharlieTreasuryManager = usdtPoolCfg.ammCharlieTreasuryManager.checkAddress();\r\n\r\n        _usdc = usdcPoolCfg.asset.checkAddress();\r\n        _usdcDecimals = usdcPoolCfg.decimals;\r\n        _usdcAmmStorage = usdcPoolCfg.ammStorage.checkAddress();\r\n        _usdcAmmTreasury = usdcPoolCfg.ammTreasury.checkAddress();\r\n        _usdcAmmPoolsTreasury = usdcPoolCfg.ammPoolsTreasury.checkAddress();\r\n        _usdcAmmPoolsTreasuryManager = usdcPoolCfg.ammPoolsTreasuryManager.checkAddress();\r\n        _usdcAmmCharlieTreasury = usdcPoolCfg.ammCharlieTreasury.checkAddress();\r\n        _usdcAmmCharlieTreasuryManager = usdcPoolCfg.ammCharlieTreasuryManager.checkAddress();\r\n\r\n        _dai = daiPoolCfg.asset.checkAddress();\r\n        _daiDecimals = daiPoolCfg.decimals;\r\n        _daiAmmStorage = daiPoolCfg.ammStorage.checkAddress();\r\n        _daiAmmTreasury = daiPoolCfg.ammTreasury.checkAddress();\r\n        _daiAmmPoolsTreasury = daiPoolCfg.ammPoolsTreasury.checkAddress();\r\n        _daiAmmPoolsTreasuryManager = daiPoolCfg.ammPoolsTreasuryManager.checkAddress();\r\n        _daiAmmCharlieTreasury = daiPoolCfg.ammCharlieTreasury.checkAddress();\r\n        _daiAmmCharlieTreasuryManager = daiPoolCfg.ammCharlieTreasuryManager.checkAddress();\r\n    }\r\n\r\n    function getAmmGovernancePoolConfiguration(\r\n        address asset\r\n    ) external view override returns (AmmGovernancePoolConfiguration memory) {\r\n        return _getPoolConfiguration(asset);\r\n    }\r\n\r\n    function depositToAssetManagement(address asset, uint256 wadAssetAmount) external override {\r\n        IAmmTreasury(_getAmmTreasury(asset)).depositToAssetManagementInternal(wadAssetAmount);\r\n    }\r\n\r\n    function withdrawFromAssetManagement(address asset, uint256 wadAssetAmount) external override {\r\n        IAmmTreasury(_getAmmTreasury(asset)).withdrawFromAssetManagementInternal(wadAssetAmount);\r\n    }\r\n\r\n    function withdrawAllFromAssetManagement(address asset) external override {\r\n        IAmmTreasury(_getAmmTreasury(asset)).withdrawAllFromAssetManagementInternal();\r\n    }\r\n\r\n    function transferToTreasury(address asset, uint256 wadAssetAmountInput) external override {\r\n        AmmGovernancePoolConfiguration memory poolCfg = _getPoolConfiguration(asset);\r\n\r\n        require(msg.sender == poolCfg.ammPoolsTreasuryManager, AmmPoolsErrors.CALLER_NOT_TREASURY_MANAGER);\r\n\r\n        uint256 assetAmountAssetDecimals = IporMath.convertWadToAssetDecimals(wadAssetAmountInput, poolCfg.decimals);\r\n        uint256 wadAssetAmount = IporMath.convertToWad(assetAmountAssetDecimals, poolCfg.decimals);\r\n\r\n        IAmmStorage(poolCfg.ammStorage).updateStorageWhenTransferToTreasuryInternal(wadAssetAmount);\r\n\r\n        IERC20Upgradeable(asset).safeTransferFrom(\r\n            poolCfg.ammTreasury,\r\n            poolCfg.ammPoolsTreasury,\r\n            assetAmountAssetDecimals\r\n        );\r\n    }\r\n\r\n    function transferToCharlieTreasury(address asset, uint256 wadAssetAmountInput) external override {\r\n        AmmGovernancePoolConfiguration memory poolCfg = _getPoolConfiguration(asset);\r\n\r\n        require(msg.sender == poolCfg.ammCharlieTreasuryManager, AmmPoolsErrors.CALLER_NOT_PUBLICATION_FEE_TRANSFERER);\r\n\r\n        uint256 assetAmountAssetDecimals = IporMath.convertWadToAssetDecimals(wadAssetAmountInput, poolCfg.decimals);\r\n        uint256 wadAssetAmount = IporMath.convertToWad(assetAmountAssetDecimals, poolCfg.decimals);\r\n\r\n        IAmmStorage(poolCfg.ammStorage).updateStorageWhenTransferToCharlieTreasuryInternal(wadAssetAmount);\r\n\r\n        IERC20Upgradeable(asset).safeTransferFrom(\r\n            poolCfg.ammTreasury,\r\n            poolCfg.ammCharlieTreasury,\r\n            assetAmountAssetDecimals\r\n        );\r\n    }\r\n\r\n    function addSwapLiquidator(address asset, address account) external override {\r\n        AmmConfigurationManager.addSwapLiquidator(asset, account);\r\n    }\r\n\r\n    function removeSwapLiquidator(address asset, address account) external override {\r\n        AmmConfigurationManager.removeSwapLiquidator(asset, account);\r\n    }\r\n\r\n    function isSwapLiquidator(address asset, address account) external view override returns (bool) {\r\n        return AmmConfigurationManager.isSwapLiquidator(asset, account);\r\n    }\r\n\r\n    function addAppointedToRebalanceInAmm(address asset, address account) external override {\r\n        AmmConfigurationManager.addAppointedToRebalanceInAmm(asset, account);\r\n    }\r\n\r\n    function removeAppointedToRebalanceInAmm(address asset, address account) external override {\r\n        AmmConfigurationManager.removeAppointedToRebalanceInAmm(asset, account);\r\n    }\r\n\r\n    function isAppointedToRebalanceInAmm(address asset, address account) external view override returns (bool) {\r\n        return AmmConfigurationManager.isAppointedToRebalanceInAmm(asset, account);\r\n    }\r\n\r\n    function setAmmPoolsParams(\r\n        address asset,\r\n        uint32 newMaxLiquidityPoolBalance,\r\n        uint32 newAutoRebalanceThresholdInThousands,\r\n        uint16 newAmmTreasuryAndAssetManagementRatio\r\n    ) external override {\r\n        AmmConfigurationManager.setAmmPoolsParams(\r\n            asset,\r\n            newMaxLiquidityPoolBalance,\r\n            newAutoRebalanceThresholdInThousands,\r\n            newAmmTreasuryAndAssetManagementRatio\r\n        );\r\n    }\r\n\r\n    function getAmmPoolsParams(address asset) external view override returns (AmmPoolsParamsConfiguration memory cfg) {\r\n        StorageLib.AmmPoolsParamsValue memory ammPoolsParamsCfg = AmmConfigurationManager.getAmmPoolsParams(asset);\r\n        cfg = AmmPoolsParamsConfiguration({\r\n            maxLiquidityPoolBalance: uint256(ammPoolsParamsCfg.maxLiquidityPoolBalance) * 1e18,\r\n            autoRebalanceThresholdInThousands: ammPoolsParamsCfg.autoRebalanceThresholdInThousands,\r\n            ammTreasuryAndAssetManagementRatio: ammPoolsParamsCfg.ammTreasuryAndAssetManagementRatio\r\n        });\r\n    }\r\n\r\n    function _getPoolConfiguration(address asset) internal view returns (AmmGovernancePoolConfiguration memory) {\r\n        if (asset == _usdt) {\r\n            return\r\n                AmmGovernancePoolConfiguration({\r\n                    asset: _usdt,\r\n                    decimals: _usdtDecimals,\r\n                    ammStorage: _usdtAmmStorage,\r\n                    ammTreasury: _usdtAmmTreasury,\r\n                    ammPoolsTreasury: _usdtAmmPoolsTreasury,\r\n                    ammPoolsTreasuryManager: _usdtAmmPoolsTreasuryManager,\r\n                    ammCharlieTreasury: _usdtAmmCharlieTreasury,\r\n                    ammCharlieTreasuryManager: _usdtAmmCharlieTreasuryManager\r\n                });\r\n        } else if (asset == _usdc) {\r\n            return\r\n                AmmGovernancePoolConfiguration({\r\n                    asset: _usdc,\r\n                    decimals: _usdcDecimals,\r\n                    ammStorage: _usdcAmmStorage,\r\n                    ammTreasury: _usdcAmmTreasury,\r\n                    ammPoolsTreasury: _usdcAmmPoolsTreasury,\r\n                    ammPoolsTreasuryManager: _usdcAmmPoolsTreasuryManager,\r\n                    ammCharlieTreasury: _usdcAmmCharlieTreasury,\r\n                    ammCharlieTreasuryManager: _usdcAmmCharlieTreasuryManager\r\n                });\r\n        } else if (asset == _dai) {\r\n            return\r\n                AmmGovernancePoolConfiguration({\r\n                    asset: _dai,\r\n                    decimals: _daiDecimals,\r\n                    ammStorage: _daiAmmStorage,\r\n                    ammTreasury: _daiAmmTreasury,\r\n                    ammPoolsTreasury: _daiAmmPoolsTreasury,\r\n                    ammPoolsTreasuryManager: _daiAmmPoolsTreasuryManager,\r\n                    ammCharlieTreasury: _daiAmmCharlieTreasury,\r\n                    ammCharlieTreasuryManager: _daiAmmCharlieTreasuryManager\r\n                });\r\n        } else {\r\n            revert(IporErrors.ASSET_NOT_SUPPORTED);\r\n        }\r\n    }\r\n\r\n    function _getAmmTreasury(address asset) internal view returns (address) {\r\n        if (asset == _usdt) {\r\n            return _usdtAmmTreasury;\r\n        } else if (asset == _usdc) {\r\n            return _usdcAmmTreasury;\r\n        } else if (asset == _dai) {\r\n            return _daiAmmTreasury;\r\n        } else {\r\n            revert(IporErrors.ASSET_NOT_SUPPORTED);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ammStorage\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammTreasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammPoolsTreasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammPoolsTreasuryManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammCharlieTreasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammCharlieTreasuryManager\",\"type\":\"address\"}],\"internalType\":\"struct IAmmGovernanceLens.AmmGovernancePoolConfiguration\",\"name\":\"usdtPoolCfg\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ammStorage\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammTreasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammPoolsTreasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammPoolsTreasuryManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammCharlieTreasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammCharlieTreasuryManager\",\"type\":\"address\"}],\"internalType\":\"struct IAmmGovernanceLens.AmmGovernancePoolConfiguration\",\"name\":\"usdcPoolCfg\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ammStorage\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammTreasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammPoolsTreasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammPoolsTreasuryManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammCharlieTreasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammCharlieTreasuryManager\",\"type\":\"address\"}],\"internalType\":\"struct IAmmGovernanceLens.AmmGovernancePoolConfiguration\",\"name\":\"daiPoolCfg\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"AmmAppointedToRebalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"maxLiquidityPoolBalance\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"autoRebalanceThresholdInThousands\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"ammTreasuryAndAssetManagementRatio\",\"type\":\"uint16\"}],\"name\":\"AmmPoolsParamsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"AmmSwapsLiquidatorChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addAppointedToRebalanceInAmm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addSwapLiquidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wadAssetAmount\",\"type\":\"uint256\"}],\"name\":\"depositToAssetManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getAmmGovernancePoolConfiguration\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ammStorage\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammTreasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammPoolsTreasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammPoolsTreasuryManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammCharlieTreasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammCharlieTreasuryManager\",\"type\":\"address\"}],\"internalType\":\"struct IAmmGovernanceLens.AmmGovernancePoolConfiguration\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getAmmPoolsParams\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"maxLiquidityPoolBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"autoRebalanceThresholdInThousands\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ammTreasuryAndAssetManagementRatio\",\"type\":\"uint256\"}],\"internalType\":\"struct IAmmGovernanceLens.AmmPoolsParamsConfiguration\",\"name\":\"cfg\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isAppointedToRebalanceInAmm\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isSwapLiquidator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeAppointedToRebalanceInAmm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeSwapLiquidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"newMaxLiquidityPoolBalance\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"newAutoRebalanceThresholdInThousands\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"newAmmTreasuryAndAssetManagementRatio\",\"type\":\"uint16\"}],\"name\":\"setAmmPoolsParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wadAssetAmountInput\",\"type\":\"uint256\"}],\"name\":\"transferToCharlieTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wadAssetAmountInput\",\"type\":\"uint256\"}],\"name\":\"transferToTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"withdrawAllFromAssetManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wadAssetAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFromAssetManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AmmGovernanceService", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000000000000000000000000000000000000000000006000000000000000000000000364f116352eb95033d73822ba81257b8c1f5b1ce00000000000000000000000028bc58e600ef718b9e97d294098abecb8c96b687000000000000000000000000558c8eb91f6fd83fc5c995572c3515e2daf7b7e0000000000000000000000000b7be82790d40258fd028beef2f2007dc044f345900000000000000000000000075dc10597861b687ea1c6f955cdda0c913e2299f000000000000000000000000b7be82790d40258fd028beef2f2007dc044f3459000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000000000000000000000000000000000000000000006000000000000000000000000b3d1c1ab4d30800162da40eb18b3024154924ba5000000000000000000000000137000352b4ed784e8fa8815d225c713ab2e7dc9000000000000000000000000558c8eb91f6fd83fc5c995572c3515e2daf7b7e0000000000000000000000000b7be82790d40258fd028beef2f2007dc044f345900000000000000000000000075dc10597861b687ea1c6f955cdda0c913e2299f000000000000000000000000b7be82790d40258fd028beef2f2007dc044f34590000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000b99f2a02c0851efdd417bd6935d2efcd23c56e61000000000000000000000000ed7d74aa7eb1f12f83da36dfac1de2257b4e7523000000000000000000000000558c8eb91f6fd83fc5c995572c3515e2daf7b7e0000000000000000000000000b7be82790d40258fd028beef2f2007dc044f345900000000000000000000000075dc10597861b687ea1c6f955cdda0c913e2299f000000000000000000000000b7be82790d40258fd028beef2f2007dc044f3459", "EVMVersion": "paris", "Library": "", "LicenseType": "GNU GPLv2", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c1b0b54e7588d3e158ce4ff07d0ad83bda19b13ba3eebec571e43bbdc65daf70"}