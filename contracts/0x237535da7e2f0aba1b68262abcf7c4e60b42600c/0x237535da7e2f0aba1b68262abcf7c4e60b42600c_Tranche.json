{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Tranche.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IWrappedPosition.sol\\\";\\nimport \\\"./interfaces/ITranche.sol\\\";\\nimport \\\"./interfaces/ITrancheFactory.sol\\\";\\nimport \\\"./interfaces/IInterestToken.sol\\\";\\n\\nimport \\\"./libraries/ERC20Permit.sol\\\";\\nimport \\\"./libraries/DateString.sol\\\";\\n\\n/// @author Element Finance\\n/// @title Tranche\\ncontract Tranche is ERC20Permit, ITranche {\\n    IInterestToken public immutable override interestToken;\\n    IWrappedPosition public immutable position;\\n    IERC20 public immutable underlying;\\n    uint8 internal immutable _underlyingDecimals;\\n\\n    // The outstanding amount of underlying which\\n    // can be redeemed from the contract from Principal Tokens\\n    // NOTE - we use smaller sizes so that they can be one storage slot\\n    uint128 public valueSupplied;\\n    // The total supply of interest tokens\\n    uint128 public override interestSupply;\\n    // The timestamp when tokens can be redeemed.\\n    uint256 public immutable unlockTimestamp;\\n    // The amount of slippage allowed on the Principal token redemption [0.1 basis points]\\n    uint256 internal constant _SLIPPAGE_BP = 1e13;\\n    // The speedbump variable records the first timestamp where redemption was attempted to be\\n    // performed on a tranche where loss occurred. It blocks redemptions for 48 hours after\\n    // it is triggered in order to (1) prevent atomic flash loan price manipulation (2)\\n    // give 48 hours to remediate any other loss scenario before allowing withdraws\\n    uint256 public speedbump;\\n    // Const which is 48 hours in seconds\\n    uint256 internal constant _FORTY_EIGHT_HOURS = 172800;\\n    // An event to listen for when negative interest withdraw are triggered\\n    event SpeedBumpHit(uint256 timestamp);\\n\\n    /// @notice Constructs this contract\\n    constructor() ERC20Permit(\\\"Element Principal Token \\\", \\\"eP\\\") {\\n        // Assume the caller is the Tranche factory.\\n        ITrancheFactory trancheFactory = ITrancheFactory(msg.sender);\\n        (\\n            address wpAddress,\\n            uint256 expiration,\\n            IInterestToken interestTokenTemp,\\n            // solhint-disable-next-line\\n            address unused\\n        ) = trancheFactory.getData();\\n        interestToken = interestTokenTemp;\\n\\n        IWrappedPosition wpContract = IWrappedPosition(wpAddress);\\n        position = wpContract;\\n\\n        // Store the immutable time variables\\n        unlockTimestamp = expiration;\\n        // We use local because immutables are not readable in construction\\n        IERC20 localUnderlying = wpContract.token();\\n        underlying = localUnderlying;\\n        // We load and store the underlying decimals\\n        uint8 localUnderlyingDecimals = localUnderlying.decimals();\\n        _underlyingDecimals = localUnderlyingDecimals;\\n        // And set this contract to have the same\\n        _setupDecimals(localUnderlyingDecimals);\\n    }\\n\\n    /// @notice We override the optional extra construction function from ERC20 to change names\\n    function _extraConstruction() internal override {\\n        // Assume the caller is the Tranche factory and that this is called from constructor\\n        // We have to do this double load because of the lack of flexibility in constructor ordering\\n        ITrancheFactory trancheFactory = ITrancheFactory(msg.sender);\\n        (\\n            address wpAddress,\\n            uint256 expiration,\\n            // solhint-disable-next-line\\n            IInterestToken unused,\\n            address dateLib\\n        ) = trancheFactory.getData();\\n\\n        string memory strategySymbol = IWrappedPosition(wpAddress).symbol();\\n\\n        // Write the strategySymbol and expiration time to name and symbol\\n\\n        // This logic was previously encoded as calling a library \\\"DateString\\\"\\n        // in line and directly. However even though this code is only in the constructor\\n        // it both made the code of this contract much bigger and made the factory\\n        // un deployable. So we needed to use the library as an external contract\\n        // but solidity does not have support for address to library conversions\\n        // or other support for working directly with libraries in a type safe way.\\n        // For that reason we have to use this ugly and non type safe hack to make these\\n        // contracts deployable. Since the library is an immutable in the factory\\n        // the security profile is quite similar to a standard external linked library.\\n\\n        // We load the real storage slots of the symbol and name storage variables\\n        uint256 namePtr;\\n        uint256 symbolPtr;\\n        assembly {\\n            namePtr := name.slot\\n            symbolPtr := symbol.slot\\n        }\\n        // We then call the 'encodeAndWriteTimestamp' function on our library contract\\n        (bool success1, ) = dateLib.delegatecall(\\n            abi.encodeWithSelector(\\n                DateString.encodeAndWriteTimestamp.selector,\\n                strategySymbol,\\n                expiration,\\n                namePtr\\n            )\\n        );\\n        (bool success2, ) = dateLib.delegatecall(\\n            abi.encodeWithSelector(\\n                DateString.encodeAndWriteTimestamp.selector,\\n                strategySymbol,\\n                expiration,\\n                symbolPtr\\n            )\\n        );\\n        // Assert that both calls succeeded\\n        assert(success1 && success2);\\n    }\\n\\n    /// @notice An aliasing of the getter for valueSupplied to improve ERC20 compatibility\\n    /// @return The number of principal tokens which exist.\\n    function totalSupply() external view returns (uint256) {\\n        return uint256(valueSupplied);\\n    }\\n\\n    /**\\n    @notice Deposit wrapped position tokens and receive interest and Principal ERC20 tokens.\\n            If interest has already been accrued by the wrapped position\\n            tokens held in this contract, the number of Principal tokens minted is\\n            reduced in order to pay for the accrued interest.\\n    @param _amount The amount of underlying to deposit\\n    @param _destination The address to mint to\\n    @return The amount of principal and yield token minted as (pt, yt)\\n     */\\n    function deposit(uint256 _amount, address _destination)\\n        external\\n        override\\n        returns (uint256, uint256)\\n    {\\n        // Transfer the underlying to be wrapped into the position\\n        underlying.transferFrom(msg.sender, address(position), _amount);\\n        // Now that we have funded the deposit we can call\\n        // the prefunded deposit\\n        return prefundedDeposit(_destination);\\n    }\\n\\n    /// @notice This function calls the prefunded deposit method to\\n    ///         create wrapped position tokens held by the contract. It should\\n    ///         only be called when a transfer has already been made to\\n    ///         the wrapped position contract of the underlying\\n    /// @param _destination The address to mint to\\n    /// @return the amount of principal and yield token minted as (pt, yt)\\n    /// @dev WARNING - The call which funds this method MUST be in the same transaction\\n    //                 as the call to this method or you risk loss of funds\\n    function prefundedDeposit(address _destination)\\n        public\\n        override\\n        returns (uint256, uint256)\\n    {\\n        // We check that this it is possible to deposit\\n        require(block.timestamp < unlockTimestamp, \\\"expired\\\");\\n        // Since the wrapped position contract holds a balance we use the prefunded deposit method\\n        (\\n            uint256 shares,\\n            uint256 usedUnderlying,\\n            uint256 balanceBefore\\n        ) = position.prefundedDeposit(address(this));\\n        // The implied current value of the holding of this contract in underlying\\n        // is the balanceBefore*(usedUnderlying/shares) since (usedUnderlying/shares)\\n        // is underlying per share and balanceBefore is the balance of this contract\\n        // in position tokens before this deposit.\\n        uint256 holdingsValue = (balanceBefore * usedUnderlying) / shares;\\n        // This formula is inputUnderlying - inputUnderlying*interestPerUnderlying\\n        // Accumulated interest has its value in the interest tokens so we have to mint less\\n        // principal tokens to account for that.\\n        // NOTE - If a pool has more than 100% interest in the period this will revert on underflow\\n        //        The user cannot discount the principal token enough to pay for the outstanding interest accrued.\\n        (uint256 _valueSupplied, uint256 _interestSupply) = (\\n            uint256(valueSupplied),\\n            uint256(interestSupply)\\n        );\\n        // We block deposits in negative interest rate regimes\\n        // The +2 allows for very small rounding errors which occur when\\n        // depositing into a tranche which is attached to a wp which has\\n        // accrued interest but the tranche has not yet accrued interest\\n        // and the first deposit into the tranche is substantially smaller\\n        // than following ones.\\n        require(_valueSupplied <= holdingsValue + 2, \\\"E:NEG_INT\\\");\\n\\n        uint256 adjustedAmount;\\n        // Have to split on the initialization case and negative interest case\\n        if (_valueSupplied > 0 && holdingsValue > _valueSupplied) {\\n            adjustedAmount =\\n                usedUnderlying -\\n                ((holdingsValue - _valueSupplied) * usedUnderlying) /\\n                _interestSupply;\\n        } else {\\n            adjustedAmount = usedUnderlying;\\n        }\\n        // We record the new input of reclaimable underlying\\n        (valueSupplied, interestSupply) = (\\n            uint128(_valueSupplied + adjustedAmount),\\n            uint128(_interestSupply + usedUnderlying)\\n        );\\n        // We mint interest token for each underlying provided\\n        interestToken.mint(_destination, usedUnderlying);\\n        // We mint principal token discounted by the accumulated interest.\\n        _mint(_destination, adjustedAmount);\\n        // We return the number of principal token and yield token\\n        return (adjustedAmount, usedUnderlying);\\n    }\\n\\n    /**\\n    @notice Burn principal tokens to withdraw underlying tokens.\\n    @param _amount The number of tokens to burn.\\n    @param _destination The address to send the underlying too\\n    @return The number of underlying tokens released\\n    @dev This method will return 1 underlying for 1 principal except when interest\\n         is negative, in which case the principal tokens is redeemable pro rata for\\n         the assets controlled by this vault.\\n         Also note: Redemption has the possibility of at most _SLIPPAGE_BP\\n         numerical error on each redemption so each principal token may occasionally redeem\\n         for less than 1 unit of underlying. Max loss defaults to 0.1 BP ie 0.001% loss\\n     */\\n    function withdrawPrincipal(uint256 _amount, address _destination)\\n        external\\n        override\\n        returns (uint256)\\n    {\\n        // No redemptions before unlock\\n        require(block.timestamp >= unlockTimestamp, \\\"E:Not Expired\\\");\\n        // If the speedbump == 0 it's never been hit so we don't need\\n        // to change the withdraw rate.\\n        uint256 localSpeedbump = speedbump;\\n        uint256 withdrawAmount = _amount;\\n        uint256 localSupply = uint256(valueSupplied);\\n        if (localSpeedbump != 0) {\\n            // Load the assets we have in this vault\\n            uint256 holdings = position.balanceOfUnderlying(address(this));\\n            // If we check and the interest rate is no longer negative then we\\n            // allow normal 1 to 1 withdraws [even if the speedbump was hit less\\n            // than 48 hours ago, to prevent possible griefing]\\n            if (holdings < localSupply) {\\n                // We allow the user to only withdraw their percent of holdings\\n                // NOTE - Because of the discounting mechanics this causes account loss\\n                //        percentages to be slightly perturbed from overall loss.\\n                //        ie: tokens holders who join when interest has accumulated\\n                //        will get slightly higher percent loss than those who joined earlier\\n                //        in the case of loss at the end of the period. Biases are very\\n                //        small except in extreme cases.\\n                withdrawAmount = (_amount * holdings) / localSupply;\\n                // If the interest rate is still negative and we are not 48 hours after\\n                // speedbump being set we revert\\n                require(\\n                    localSpeedbump + _FORTY_EIGHT_HOURS < block.timestamp,\\n                    \\\"E:Early\\\"\\n                );\\n            }\\n        }\\n        // Burn from the sender\\n        _burn(msg.sender, _amount);\\n        // Remove these principal token from the interest calculations for future interest redemptions\\n        valueSupplied = uint128(localSupply) - uint128(_amount);\\n        // Load the share balance of the vault before withdrawing [gas note - both the smart\\n        // contract and share value is warmed so this is actually quite a cheap lookup]\\n        uint256 shareBalanceBefore = position.balanceOf(address(this));\\n        // Calculate the min output\\n        uint256 minOutput = withdrawAmount -\\n            (withdrawAmount * _SLIPPAGE_BP) /\\n            1e18;\\n        // We make the actual withdraw from the position.\\n        (uint256 actualWithdraw, uint256 sharesBurned) = position\\n            .withdrawUnderlying(_destination, withdrawAmount, minOutput);\\n\\n        // At this point we check that the implied contract holdings before this withdraw occurred\\n        // are more than enough to redeem all of the principal tokens for underlying ie that no\\n        // loss has happened.\\n        uint256 balanceBefore = (shareBalanceBefore * actualWithdraw) /\\n            sharesBurned;\\n        if (balanceBefore < localSupply) {\\n            // Require that that the speedbump has been set.\\n            require(localSpeedbump != 0, \\\"E:NEG_INT\\\");\\n            // This assert should be very difficult to hit because it is checked above\\n            // but may be possible with  complex reentrancy.\\n            assert(localSpeedbump + _FORTY_EIGHT_HOURS < block.timestamp);\\n        }\\n        return (actualWithdraw);\\n    }\\n\\n    /// @notice This function allows someone to trigger the speedbump and eventually allow\\n    ///         pro rata withdraws\\n    function hitSpeedbump() external {\\n        // We only allow setting the speedbump once\\n        require(speedbump == 0, \\\"E:AlreadySet\\\");\\n        // We only allow setting it when withdraws can happen\\n        require(block.timestamp >= unlockTimestamp, \\\"E:Not Expired\\\");\\n        // We require that the total holds are less than the supply of\\n        // principal token we need to redeem\\n        uint256 totalHoldings = position.balanceOfUnderlying(address(this));\\n        if (totalHoldings < valueSupplied) {\\n            // We emit a notification so that if a speedbump is hit the community\\n            // can investigate.\\n            // Note - this is a form of defense mechanism because any flash loan\\n            //        attack must be public for at least 48 hours before it has\\n            //        affects.\\n            emit SpeedBumpHit(block.timestamp);\\n            // Set the speedbump\\n            speedbump = block.timestamp;\\n        } else {\\n            revert(\\\"E:NoLoss\\\");\\n        }\\n    }\\n\\n    /**\\n    @notice Burn interest tokens to withdraw underlying tokens.\\n    @param _amount The number of interest tokens to burn.\\n    @param _destination The address to send the result to\\n    @return The number of underlying token released\\n    @dev Due to slippage the redemption may receive up to _SLIPPAGE_BP less\\n         in output compared to the floating rate.\\n     */\\n    function withdrawInterest(uint256 _amount, address _destination)\\n        external\\n        override\\n        returns (uint256)\\n    {\\n        require(block.timestamp >= unlockTimestamp, \\\"E:Not Expired\\\");\\n        // Burn tokens from the sender\\n        interestToken.burn(msg.sender, _amount);\\n        // Load the underlying value of this contract\\n        uint256 underlyingValueLocked = position.balanceOfUnderlying(\\n            address(this)\\n        );\\n        // Load a stack variable to avoid future sloads\\n        (uint256 _valueSupplied, uint256 _interestSupply) = (\\n            uint256(valueSupplied),\\n            uint256(interestSupply)\\n        );\\n        // Interest is value locked minus current value\\n        uint256 interest = underlyingValueLocked > _valueSupplied\\n            ? underlyingValueLocked - _valueSupplied\\n            : 0;\\n        // The redemption amount is the interest per token times the amount\\n        uint256 redemptionAmount = (interest * _amount) / _interestSupply;\\n        uint256 minRedemption = redemptionAmount -\\n            (redemptionAmount * _SLIPPAGE_BP) /\\n            1e18;\\n        // Store that we reduced the supply\\n        interestSupply = uint128(_interestSupply - _amount);\\n        // Redeem position tokens for underlying\\n        (uint256 redemption, ) = position.withdrawUnderlying(\\n            _destination,\\n            redemptionAmount,\\n            minRedemption\\n        );\\n        return (redemption);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\ninterface IERC20 {\\n    function symbol() external view returns (string memory);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    // Note this is non standard but nearly all ERC20 have exposed decimal functions\\n    function decimals() external view returns (uint8);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWrappedPosition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Permit.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IWrappedPosition is IERC20Permit {\\n    function token() external view returns (IERC20);\\n\\n    function balanceOfUnderlying(address who) external view returns (uint256);\\n\\n    function getSharesToUnderlying(uint256 shares)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function deposit(address sender, uint256 amount) external returns (uint256);\\n\\n    function withdraw(\\n        address sender,\\n        uint256 _shares,\\n        uint256 _minUnderlying\\n    ) external returns (uint256);\\n\\n    function withdrawUnderlying(\\n        address _destination,\\n        uint256 _amount,\\n        uint256 _minUnderlying\\n    ) external returns (uint256, uint256);\\n\\n    function prefundedDeposit(address _destination)\\n        external\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITranche.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Permit.sol\\\";\\nimport \\\"./IInterestToken.sol\\\";\\n\\ninterface ITranche is IERC20Permit {\\n    function deposit(uint256 _shares, address destination)\\n        external\\n        returns (uint256, uint256);\\n\\n    function prefundedDeposit(address _destination)\\n        external\\n        returns (uint256, uint256);\\n\\n    function withdrawPrincipal(uint256 _amount, address _destination)\\n        external\\n        returns (uint256);\\n\\n    function withdrawInterest(uint256 _amount, address _destination)\\n        external\\n        returns (uint256);\\n\\n    function interestToken() external view returns (IInterestToken);\\n\\n    function interestSupply() external view returns (uint128);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITrancheFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"../InterestToken.sol\\\";\\nimport \\\"../libraries/DateString.sol\\\";\\n\\ninterface ITrancheFactory {\\n    function getData()\\n        external\\n        returns (\\n            address,\\n            uint256,\\n            InterestToken,\\n            address\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IInterestToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Permit.sol\\\";\\n\\ninterface IInterestToken is IERC20Permit {\\n    function mint(address _account, uint256 _amount) external;\\n\\n    function burn(address _account, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/ERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IERC20Permit.sol\\\";\\n\\n// This default erc20 library is designed for max efficiency and security.\\n// WARNING: By default it does not include totalSupply which breaks the ERC20 standard\\n//          to use a fully standard compliant ERC20 use 'ERC20PermitWithSupply\\\"\\nabstract contract ERC20Permit is IERC20Permit {\\n    // --- ERC20 Data ---\\n    // The name of the erc20 token\\n    string public name;\\n    // The symbol of the erc20 token\\n    string public override symbol;\\n    // The decimals of the erc20 token, should default to 18 for new tokens\\n    uint8 public override decimals;\\n\\n    // A mapping which tracks user token balances\\n    mapping(address => uint256) public override balanceOf;\\n    // A mapping which tracks which addresses a user allows to move their tokens\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n    // A mapping which tracks the permit signature nonces for users\\n    mapping(address => uint256) public override nonces;\\n\\n    // --- EIP712 niceties ---\\n    // solhint-disable-next-line var-name-mixedcase\\n    bytes32 public override DOMAIN_SEPARATOR;\\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32\\n        public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    /// @notice Initializes the erc20 contract\\n    /// @param name_ the value 'name' will be set to\\n    /// @param symbol_ the value 'symbol' will be set to\\n    /// @dev decimals default to 18 and must be reset by an inheriting contract for\\n    ///      non standard decimal values\\n    constructor(string memory name_, string memory symbol_) {\\n        // Set the state variables\\n        name = name_;\\n        symbol = symbol_;\\n        decimals = 18;\\n\\n        // By setting these addresses to 0 attempting to execute a transfer to\\n        // either of them will revert. This is a gas efficient way to prevent\\n        // a common user mistake where they transfer to the token address.\\n        // These values are not considered 'real' tokens and so are not included\\n        // in 'total supply' which only contains minted tokens.\\n        balanceOf[address(0)] = type(uint256).max;\\n        balanceOf[address(this)] = type(uint256).max;\\n\\n        // Optional extra state manipulation\\n        _extraConstruction();\\n\\n        // Computes the EIP 712 domain separator which prevents user signed messages for\\n        // this contract to be replayed in other contracts.\\n        // https://eips.ethereum.org/EIPS/eip-712\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                ),\\n                keccak256(bytes(name)),\\n                keccak256(bytes(\\\"1\\\")),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /// @notice An optional override function to execute and change state before immutable assignment\\n    function _extraConstruction() internal virtual {}\\n\\n    // --- Token ---\\n    /// @notice Allows a token owner to send tokens to another address\\n    /// @param recipient The address which will be credited with the tokens\\n    /// @param amount The amount user token to send\\n    /// @return returns true on success, reverts on failure so cannot return false.\\n    /// @dev transfers to this contract address or 0 will fail\\n    function transfer(address recipient, uint256 amount)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        // We forward this call to 'transferFrom'\\n        return transferFrom(msg.sender, recipient, amount);\\n    }\\n\\n    /// @notice Transfers an amount of erc20 from a spender to a receipt\\n    /// @param spender The source of the ERC20 tokens\\n    /// @param recipient The destination of the ERC20 tokens\\n    /// @param amount the number of tokens to send\\n    /// @return returns true on success and reverts on failure\\n    /// @dev will fail transfers which send funds to this contract or 0\\n    function transferFrom(\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        // Load balance and allowance\\n        uint256 balance = balanceOf[spender];\\n        require(balance >= amount, \\\"ERC20: insufficient-balance\\\");\\n        // We potentially have to change allowances\\n        if (spender != msg.sender) {\\n            // Loading the allowance in the if block prevents vanilla transfers\\n            // from paying for the sload.\\n            uint256 allowed = allowance[spender][msg.sender];\\n            // If the allowance is max we do not reduce it\\n            // Note - This means that max allowances will be more gas efficient\\n            // by not requiring a sstore on 'transferFrom'\\n            if (allowed != type(uint256).max) {\\n                require(allowed >= amount, \\\"ERC20: insufficient-allowance\\\");\\n                allowance[spender][msg.sender] = allowed - amount;\\n            }\\n        }\\n        // Update the balances\\n        balanceOf[spender] = balance - amount;\\n        // Note - In the constructor we initialize the 'balanceOf' of address 0 and\\n        //        the token address to uint256.max and so in 8.0 transfers to those\\n        //        addresses revert on this step.\\n        balanceOf[recipient] = balanceOf[recipient] + amount;\\n        // Emit the needed event\\n        emit Transfer(spender, recipient, amount);\\n        // Return that this call succeeded\\n        return true;\\n    }\\n\\n    /// @notice This internal minting function allows inheriting contracts\\n    ///         to mint tokens in the way they wish.\\n    /// @param account the address which will receive the token.\\n    /// @param amount the amount of token which they will receive\\n    /// @dev This function is virtual so that it can be overridden, if you\\n    ///      are reviewing this contract for security you should ensure to\\n    ///      check for overrides\\n    function _mint(address account, uint256 amount) internal virtual {\\n        // Add tokens to the account\\n        balanceOf[account] = balanceOf[account] + amount;\\n        // Emit an event to track the minting\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /// @notice This internal burning function allows inheriting contracts to\\n    ///         burn tokens in the way they see fit.\\n    /// @param account the account to remove tokens from\\n    /// @param amount  the amount of tokens to remove\\n    /// @dev This function is virtual so that it can be overridden, if you\\n    ///      are reviewing this contract for security you should ensure to\\n    ///      check for overrides\\n    function _burn(address account, uint256 amount) internal virtual {\\n        // Reduce the balance of the account\\n        balanceOf[account] = balanceOf[account] - amount;\\n        // Emit an event tracking transfers\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /// @notice This function allows a user to approve an account which can transfer\\n    ///         tokens on their behalf.\\n    /// @param account The account which will be approve to transfer tokens\\n    /// @param amount The approval amount, if set to uint256.max the allowance does not go down on transfers.\\n    /// @return returns true for compatibility with the ERC20 standard\\n    function approve(address account, uint256 amount)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        // Set the senders allowance for account to amount\\n        allowance[msg.sender][account] = amount;\\n        // Emit an event to track approvals\\n        emit Approval(msg.sender, account, amount);\\n        return true;\\n    }\\n\\n    /// @notice This function allows a caller who is not the owner of an account to execute the functionality of 'approve' with the owners signature.\\n    /// @param owner the owner of the account which is having the new approval set\\n    /// @param spender the address which will be allowed to spend owner's tokens\\n    /// @param value the new allowance value\\n    /// @param deadline the timestamp which the signature must be submitted by to be valid\\n    /// @param v Extra ECDSA data which allows public key recovery from signature assumed to be 27 or 28\\n    /// @param r The r component of the ECDSA signature\\n    /// @param s The s component of the ECDSA signature\\n    /// @dev The signature for this function follows EIP 712 standard and should be generated with the\\n    ///      eth_signTypedData JSON RPC call instead of the eth_sign JSON RPC call. If using out of date\\n    ///      parity signing libraries the v component may need to be adjusted. Also it is very rare but possible\\n    ///      for v to be other values, those values are not supported.\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override {\\n        // The EIP 712 digest for this function\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        PERMIT_TYPEHASH,\\n                        owner,\\n                        spender,\\n                        value,\\n                        nonces[owner],\\n                        deadline\\n                    )\\n                )\\n            )\\n        );\\n        // Require that the owner is not zero\\n        require(owner != address(0), \\\"ERC20: invalid-address-0\\\");\\n        // Require that we have a valid signature from the owner\\n        require(owner == ecrecover(digest, v, r, s), \\\"ERC20: invalid-permit\\\");\\n        // Require that the signature is not expired\\n        require(\\n            deadline == 0 || block.timestamp <= deadline,\\n            \\\"ERC20: permit-expired\\\"\\n        );\\n        // Format the signature to the default format\\n        require(\\n            uint256(s) <=\\n                0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\\n            \\\"ERC20: invalid signature 's' value\\\"\\n        );\\n        // Increment the signature nonce to prevent replay\\n        nonces[owner]++;\\n        // Set the allowance to the new value\\n        allowance[owner][spender] = value;\\n        // Emit an approval event to be able to track this happening\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    /// @notice Internal function which allows inheriting contract to set custom decimals\\n    /// @param decimals_ the new decimal value\\n    function _setupDecimals(uint8 decimals_) internal {\\n        // Set the decimals\\n        decimals = decimals_;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/DateString.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nlibrary DateString {\\n    uint256 public constant SECONDS_PER_DAY = 24 * 60 * 60;\\n    uint256 public constant SECONDS_PER_HOUR = 60 * 60;\\n    uint256 public constant SECONDS_PER_MINUTE = 60;\\n    int256 public constant OFFSET19700101 = 2440588;\\n\\n    // This function was forked from https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\n    // ------------------------------------------------------------------------\\n    // Calculate year/month/day from the number of days since 1970/01/01 using\\n    // the date conversion algorithm from\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\\n    //\\n    // int L = days + 68569 + offset\\n    // int N = 4 * L / 146097\\n    // L = L - (146097 * N + 3) / 4\\n    // year = 4000 * (L + 1) / 1461001\\n    // L = L - 1461 * year / 4 + 31\\n    // month = 80 * L / 2447\\n    // dd = L - 2447 * month / 80\\n    // L = month / 11\\n    // month = month + 2 - 12 * L\\n    // year = 100 * (N - 49) + year + L\\n    // ------------------------------------------------------------------------\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    function _daysToDate(uint256 _days)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day\\n        )\\n    {\\n        int256 __days = int256(_days);\\n        // solhint-disable-next-line var-name-mixedcase\\n        int256 L = __days + 68569 + OFFSET19700101;\\n        // solhint-disable-next-line var-name-mixedcase\\n        int256 N = (4 * L) / 146097;\\n        L = L - (146097 * N + 3) / 4;\\n        int256 _year = (4000 * (L + 1)) / 1461001;\\n        L = L - (1461 * _year) / 4 + 31;\\n        int256 _month = (80 * L) / 2447;\\n        int256 _day = L - (2447 * _month) / 80;\\n        L = _month / 11;\\n        _month = _month + 2 - 12 * L;\\n        _year = 100 * (N - 49) + _year + L;\\n\\n        year = uint256(_year);\\n        month = uint256(_month);\\n        day = uint256(_day);\\n    }\\n\\n    /// @dev Writes a prefix and an timestamp encoding to an output storage location\\n    ///      This function is designed to only work with ASCII encoded strings. No emojis please.\\n    /// @param _prefix The string to write before the timestamp\\n    /// @param _timestamp the timestamp to encode and store\\n    /// @param _output the storage location of the output string\\n    /// NOTE - Current cost ~90k if gas is problem revisit and use assembly to remove the extra\\n    ///        sstore s.\\n    function encodeAndWriteTimestamp(\\n        string memory _prefix,\\n        uint256 _timestamp,\\n        string storage _output\\n    ) external {\\n        _encodeAndWriteTimestamp(_prefix, _timestamp, _output);\\n    }\\n\\n    /// @dev Sn internal version of the above function 'encodeAndWriteTimestamp'\\n    // solhint-disable-next-line\\n    function _encodeAndWriteTimestamp(\\n        string memory _prefix,\\n        uint256 _timestamp,\\n        string storage _output\\n    ) internal {\\n        // Cast the prefix string to a byte array\\n        bytes memory bytePrefix = bytes(_prefix);\\n        // Cast the output string to a byte array\\n        bytes storage bytesOutput = bytes(_output);\\n        // Copy the bytes from the prefix onto the byte array\\n        // NOTE - IF PREFIX CONTAINS NON-ASCII CHARS THIS WILL CAUSE AN INCORRECT STRING LENGTH\\n        for (uint256 i = 0; i < bytePrefix.length; i++) {\\n            bytesOutput.push(bytePrefix[i]);\\n        }\\n        // Add a '-' to the string to separate the prefix from the the date\\n        bytesOutput.push(bytes1(\\\"-\\\"));\\n        // Add the date string\\n        timestampToDateString(_timestamp, _output);\\n    }\\n\\n    /// @dev Converts a unix second encoded timestamp to a date format (year, month, day)\\n    ///      then writes the string encoding of that to the output pointer.\\n    /// @param _timestamp the unix seconds timestamp\\n    /// @param _outputPointer the storage pointer to change.\\n    function timestampToDateString(\\n        uint256 _timestamp,\\n        string storage _outputPointer\\n    ) public {\\n        _timestampToDateString(_timestamp, _outputPointer);\\n    }\\n\\n    /// @dev Sn internal version of the above function 'timestampToDateString'\\n    // solhint-disable-next-line\\n    function _timestampToDateString(\\n        uint256 _timestamp,\\n        string storage _outputPointer\\n    ) internal {\\n        // We pretend the string is a 'bytes' only push UTF8 encodings to it\\n        bytes storage output = bytes(_outputPointer);\\n        // First we get the day month and year\\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(\\n            _timestamp / SECONDS_PER_DAY\\n        );\\n        // First we add encoded day to the string\\n        {\\n            // Round out the second digit\\n            uint256 firstDigit = day / 10;\\n            // add it to the encoded byte for '0'\\n            output.push(bytes1(uint8(bytes1(\\\"0\\\")) + uint8(firstDigit)));\\n            // Extract the second digit\\n            uint256 secondDigit = day % 10;\\n            // add it to the string\\n            output.push(bytes1(uint8(bytes1(\\\"0\\\")) + uint8(secondDigit)));\\n        }\\n        // Next we encode the month string and add it\\n        if (month == 1) {\\n            stringPush(output, \\\"J\\\", \\\"A\\\", \\\"N\\\");\\n        } else if (month == 2) {\\n            stringPush(output, \\\"F\\\", \\\"E\\\", \\\"B\\\");\\n        } else if (month == 3) {\\n            stringPush(output, \\\"M\\\", \\\"A\\\", \\\"R\\\");\\n        } else if (month == 4) {\\n            stringPush(output, \\\"A\\\", \\\"P\\\", \\\"R\\\");\\n        } else if (month == 5) {\\n            stringPush(output, \\\"M\\\", \\\"A\\\", \\\"Y\\\");\\n        } else if (month == 6) {\\n            stringPush(output, \\\"J\\\", \\\"U\\\", \\\"N\\\");\\n        } else if (month == 7) {\\n            stringPush(output, \\\"J\\\", \\\"U\\\", \\\"L\\\");\\n        } else if (month == 8) {\\n            stringPush(output, \\\"A\\\", \\\"U\\\", \\\"G\\\");\\n        } else if (month == 9) {\\n            stringPush(output, \\\"S\\\", \\\"E\\\", \\\"P\\\");\\n        } else if (month == 10) {\\n            stringPush(output, \\\"O\\\", \\\"C\\\", \\\"T\\\");\\n        } else if (month == 11) {\\n            stringPush(output, \\\"N\\\", \\\"O\\\", \\\"V\\\");\\n        } else if (month == 12) {\\n            stringPush(output, \\\"D\\\", \\\"E\\\", \\\"C\\\");\\n        } else {\\n            revert(\\\"date decoding error\\\");\\n        }\\n        // We take the last two digits of the year\\n        // Hopefully that's enough\\n        {\\n            uint256 lastDigits = year % 100;\\n            // Round out the second digit\\n            uint256 firstDigit = lastDigits / 10;\\n            // add it to the encoded byte for '0'\\n            output.push(bytes1(uint8(bytes1(\\\"0\\\")) + uint8(firstDigit)));\\n            // Extract the second digit\\n            uint256 secondDigit = lastDigits % 10;\\n            // add it to the string\\n            output.push(bytes1(uint8(bytes1(\\\"0\\\")) + uint8(secondDigit)));\\n        }\\n    }\\n\\n    function stringPush(\\n        bytes storage output,\\n        bytes1 data1,\\n        bytes1 data2,\\n        bytes1 data3\\n    ) internal {\\n        output.push(data1);\\n        output.push(data2);\\n        output.push(data3);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Permit.sol\": {\r\n      \"content\": \"// Forked from openzepplin\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit is IERC20 {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/InterestToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./libraries/ERC20Permit.sol\\\";\\nimport \\\"./libraries/DateString.sol\\\";\\n\\nimport \\\"./interfaces/IInterestToken.sol\\\";\\nimport \\\"./interfaces/ITranche.sol\\\";\\n\\ncontract InterestToken is ERC20Permit, IInterestToken {\\n    // The tranche address which controls the minting\\n    ITranche public immutable tranche;\\n\\n    /// @dev Initializes the ERC20 and writes the correct names\\n    /// @param _tranche The tranche contract address\\n    /// @param _strategySymbol The symbol of the associated WrappedPosition contract\\n    /// @param _timestamp The unlock time on the tranche\\n    /// @param _decimals The decimal encoding for this token\\n    constructor(\\n        address _tranche,\\n        string memory _strategySymbol,\\n        uint256 _timestamp,\\n        uint8 _decimals\\n    )\\n        ERC20Permit(\\n            _processName(\\\"Element Yield Token \\\", _strategySymbol, _timestamp),\\n            _processSymbol(\\\"eY\\\", _strategySymbol, _timestamp)\\n        )\\n    {\\n        tranche = ITranche(_tranche);\\n        _setupDecimals(_decimals);\\n    }\\n\\n    /// @notice We use this function to add the date to the name string\\n    /// @param _name start of the name\\n    /// @param _strategySymbol the strategy symbol\\n    /// @param _timestamp the unix second timestamp to be encoded and added to the end of the string\\n    function _processName(\\n        string memory _name,\\n        string memory _strategySymbol,\\n        uint256 _timestamp\\n    ) internal returns (string memory) {\\n        // Set the name in the super\\n        name = _name;\\n        // Use the library to write the rest\\n        DateString._encodeAndWriteTimestamp(_strategySymbol, _timestamp, name);\\n        // load and return the name\\n        return name;\\n    }\\n\\n    /// @notice We use this function to add the date to the name string\\n    /// @param _symbol start of the symbol\\n    /// @param _strategySymbol the strategy symbol\\n    /// @param _timestamp the unix second timestamp to be encoded and added to the end of the string\\n    function _processSymbol(\\n        string memory _symbol,\\n        string memory _strategySymbol,\\n        uint256 _timestamp\\n    ) internal returns (string memory) {\\n        // Set the symbol in the super\\n        symbol = _symbol;\\n        // Use the library to write the rest\\n        DateString._encodeAndWriteTimestamp(\\n            _strategySymbol,\\n            _timestamp,\\n            symbol\\n        );\\n        // load and return the name\\n        return symbol;\\n    }\\n\\n    /// @dev Aliasing of the lookup method for the supply of yield tokens which\\n    ///      improves our ERC20 compatibility.\\n    /// @return The total supply of yield tokens\\n    function totalSupply() external view returns (uint256) {\\n        return uint256(tranche.interestSupply());\\n    }\\n\\n    /// @dev Prevents execution if the caller isn't the tranche\\n    modifier onlyMintAuthority() {\\n        require(\\n            msg.sender == address(tranche),\\n            \\\"caller is not an authorized minter\\\"\\n        );\\n        _;\\n    }\\n\\n    /// @dev Mints tokens to an address\\n    /// @param _account The account to mint to\\n    /// @param _amount The amount to mint\\n    function mint(address _account, uint256 _amount)\\n        external\\n        override\\n        onlyMintAuthority\\n    {\\n        _mint(_account, _amount);\\n    }\\n\\n    /// @dev Burns tokens from an address\\n    /// @param _account The account to burn from\\n    /// @param _amount The amount of token to burn\\n    function burn(address _account, uint256 _amount)\\n        external\\n        override\\n        onlyMintAuthority\\n    {\\n        _burn(_account, _amount);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 7500\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"SpeedBumpHit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hitSpeedbump\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestSupply\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestToken\",\"outputs\":[{\"internalType\":\"contract IInterestToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"position\",\"outputs\":[{\"internalType\":\"contract IWrappedPosition\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"}],\"name\":\"prefundedDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"speedbump\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"valueSupplied\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"}],\"name\":\"withdrawInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"}],\"name\":\"withdrawPrincipal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Tranche", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "7500", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}