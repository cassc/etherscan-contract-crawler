{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Akolytes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport {Owned} from \\\"solmate/auth/Owned.sol\\\";\\nimport {ERC721} from \\\"solmate/tokens/ERC721.sol\\\";\\n\\nimport {ERC2981} from \\\"openzeppelin-contracts/contracts/token/common/ERC2981.sol\\\";\\nimport {IERC2981} from \\\"openzeppelin-contracts/contracts/interfaces/IERC2981.sol\\\";\\nimport {Strings} from \\\"openzeppelin-contracts/contracts/utils/Strings.sol\\\";\\n\\nimport {IERC721} from \\\"openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\\\";\\nimport {ICurve} from \\\"lssvm2/bonding-curves/ICurve.sol\\\";\\nimport {LSSVMPair} from \\\"lssvm2/LSSVMPair.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\n\\nimport {PairFactoryLike} from \\\"./PairFactoryLike.sol\\\";\\nimport {RoyaltyHandler} from \\\"./RoyaltyHandler.sol\\\";\\nimport {ERC721Minimal} from \\\"./ERC721Minimal.sol\\\";\\n\\nimport {StringLib} from \\\"./libs/StringLib.sol\\\";\\nimport {Base64} from \\\"./libs/Base64.sol\\\";\\n\\ninterface IMarkov {\\n    function speak(uint256 magic, uint256 duration) external view returns (string memory s);\\n}\\n\\ncontract Akolytes is ERC721Minimal, ERC2981, Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                  Struct\\n    //////////////////////////////////////////////////////////////*/\\n\\n    struct OwnerOfWithData {\\n        address owner;\\n        uint96 lastTransferTimestamp;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      Libraries\\n    //////////////////////////////////////////////////////////////*/\\n\\n    using SafeTransferLib for address payable;\\n    using SafeTransferLib for ERC20;\\n    using StringLib for string;\\n    using StringLib for StringLib.slice;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                       Error\\n    //////////////////////////////////////////////////////////////*/\\n\\n    error Cooldown();\\n    error Monless();\\n    error Akoless();\\n    error Scarce();\\n    error TooHigh();\\n    error NoYeet();\\n    error NoZero();\\n    error WrongFrom();\\n    error Unauth();\\n\\n    /*//////////////////////////////////////////////////////////////\\n                       Events\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event NewRoyalty(uint256 newRoyalty);\\n    event RoyaltiesClaimed(address token, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         Constants\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 constant TOTAL_AKOLS = 512;\\n    string private constant ARWEAVE_HASH = \\\"XxDgZs6LRWDmzQIfR0Lssic8a4k3eQbyaosttObj7Ec\\\";\\n\\n    // Name generation process: 1 random from s1, 1 random from s2, and then 0-2 from s3\\n    string private constant s1 = \\\"Cth,Az,Ap,Ch,Bl,Gh,Gl,Kr,M,Nl,Ny,D,Xy,Rh,U,Bl,Cz,En,Fz,H,Il,J,Jh,Y,YvK,Z,Zh,Sl,T,O,U,Ub,Os,Eh,Sh\\\";\\n    uint256 private constant s1Length = 35;\\n\\n    string private constant s2 = \\\"ak,al,es,et,id,il,id,oo,or,ux,un,ap,ek,ex,in,ol,up,-af,-aw,'et,'ed,-in,-is,'od,-at,-of\\\";\\n    uint256 private constant s2Length = 26;\\n\\n    string private constant s3 = \\\"ag,al,on,ak,ash,a,ber,bal,buk,cla,ced,ck,dar,dru,est,end,fli,fa,-fur,gen,ga,his,ha,ilk,in,-in,ju,ja,-ki,ll,lo,mo,-mu,ma,no,r,ss,sh,sto,ta,tha,un,vy,va,wy,wu,y,yy,z,zs,ton,gon,-man,lu,get,har,uz,ek,ec,-s\\\";\\n    uint256 private constant s3Length = 60;\\n\\n    // Max number of times we grab a syllable from s3\\n    uint256 private constant maxS3Iters = 2;\\n\\n    // Max 10% royalty\\n    uint256 private constant MAX_ROYALTY = 1000;\\n\\n    // Get ur akolytes before i yeet them\\n    uint256 private constant MIN_YEET_DELAY = 7 days;\\n\\n    // For metadata\\n    uint256 constant DURATION = 42;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         Immutables\\n    //////////////////////////////////////////////////////////////*/\\n\\n    // Immutable contract reference vars\\n    address private immutable MONS;\\n    address private immutable SUDO_FACTORY;\\n    address private immutable GDA_ADDRESS;\\n    address private immutable LINEAR_ADDRESS;\\n    address private immutable XMON_ADDRESS;\\n    address payable public immutable ROYALTY_HANDER;\\n    uint256 private immutable START_TIME;\\n\\n    // Babble babble\\n    IMarkov public immutable MARKOV;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         Storage\\n    //////////////////////////////////////////////////////////////*/\\n\\n    // Mapping of (id, 256 bits) => (owner address, 160 bits | unlockDate timestamp, 96 bits)\\n    mapping(uint256 => OwnerOfWithData) public ownerOfWithData;\\n\\n    // Mapping of (token address, 160 bits | akolyte id, 96 bits) => amount already claimed for that id\\n    mapping(uint256 => uint256) public royaltyClaimedPerId;\\n\\n    // Mapping of royalty amounts accumulated in total per royalty token\\n    mapping(address => uint256) public royaltyAccumulatedPerTokenType;\\n\\n    // Seed overrides for speaking\\n    mapping(uint256 => uint256) public markovSeed;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         Constructor\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _mons, address _factory, address _markov, address _gda, address _xmon, address _linear)\\n        ERC721Minimal(\\\"Akolytes\\\", \\\"AKOL\\\")\\n        Owned(msg.sender)\\n    {\\n        MONS = _mons;\\n        SUDO_FACTORY = _factory;\\n        ROYALTY_HANDER = payable(address(new RoyaltyHandler()));\\n        START_TIME = block.timestamp;\\n        MARKOV = IMarkov(_markov);\\n        GDA_ADDRESS = _gda;\\n        XMON_ADDRESS = _xmon;\\n        LINEAR_ADDRESS = _linear;\\n\\n        // 5% royalty, set to this address\\n        _setDefaultRoyalty(address(this), 500);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                 User Facing\\n    //////////////////////////////////////////////////////////////*/\\n\\n    // Claim for mons\\n    function tap_to_summon_akolytes(uint256[] calldata ids) public {\\n        for (uint256 i; i < ids.length; ++i) {\\n            if (ERC721(MONS).ownerOf(ids[i]) != msg.sender) {\\n                revert Monless();\\n            }\\n        }\\n        _mint(msg.sender, ids);\\n    }\\n\\n    // Claims royalties accrued for owned IDs\\n    function claimRoyalties(address royaltyToken, uint256[] calldata ids) public returns (uint256 royaltiesReceived) {\\n        uint256 idLength = ids.length;\\n        accumulateRoyalty(royaltyToken);\\n        uint256 amountPerId = royaltyAccumulatedPerTokenType[royaltyToken] / TOTAL_AKOLS;\\n        for (uint256 i; i < idLength; ++i) {\\n            if (ownerOf(ids[i]) == msg.sender) {\\n                uint256 idAndTokenKey = uint256(uint160(royaltyToken)) << 96 | ids[i];\\n\\n                // This should undeflow if already claimed to the maximum amount\\n                uint256 royaltyToAdd = amountPerId - royaltyClaimedPerId[idAndTokenKey];\\n\\n                // If we are sending a royalty amount, then keep track of the amount\\n                if (royaltyToAdd > 0) {\\n                    royaltiesReceived += royaltyToAdd;\\n                    royaltyClaimedPerId[idAndTokenKey] = amountPerId;\\n                }\\n            } else {\\n                revert Akoless();\\n            }\\n        }\\n        // If native token\\n        if (royaltyToken == address(0)) {\\n            RoyaltyHandler(ROYALTY_HANDER).sendETH(payable(msg.sender), royaltiesReceived);\\n        }\\n        // Otherwise, do ERC20 transfer\\n        else {\\n            RoyaltyHandler(ROYALTY_HANDER).sendERC20(msg.sender, royaltyToken, royaltiesReceived);\\n        }\\n        return royaltiesReceived;\\n    }\\n\\n    // Accumulates royalties accrued\\n    function accumulateRoyalty(address royaltyToken) public {\\n        // Handle native token royalties\\n        if (royaltyToken == address(0)) {\\n            // Send balance and accumulate\\n            uint256 ethBalance = address(this).balance;\\n            royaltyAccumulatedPerTokenType[address(0)] += ethBalance;\\n            ROYALTY_HANDER.safeTransferETH(ethBalance);\\n            emit RoyaltiesClaimed(royaltyToken, ethBalance);\\n        } else {\\n            uint256 tokenBalance = ERC20(royaltyToken).balanceOf(address(this));\\n            royaltyAccumulatedPerTokenType[royaltyToken] += tokenBalance;\\n            ERC20(royaltyToken).safeTransfer(ROYALTY_HANDER, tokenBalance);\\n            emit RoyaltiesClaimed(royaltyToken, tokenBalance);\\n        }\\n    }\\n\\n    function recast(uint256 id, uint256 seed) external payable {\\n        require(msg.value == 0.01 ether);\\n        require(ownerOf(id) == msg.sender);\\n        markovSeed[id] = seed;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                   IERC721 Compliance\\n    //////////////////////////////////////////////////////////////*/\\n\\n    // Overrides both ERC721 and ERC2981\\n    function supportsInterface(bytes4 interfaceId) public pure override(ERC2981, ERC721Minimal) returns (bool) {\\n        return interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165\\n            || interfaceId == 0x80ac58cd // ERC165 Interface ID for ERC721\\n            || interfaceId == type(IERC2981).interfaceId // ERC165 interface for IERC2981\\n            || interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    function ownerOf(uint256 id) public view override returns (address owner) {\\n        owner = ownerOfWithData[id].owner;\\n    }\\n\\n    // Transfers and sets time delay if to/from a non-sudo pool\\n    function transferFrom(address from, address to, uint256 id) public override {\\n        if (from != ownerOf(id)) {\\n            revert WrongFrom();\\n        }\\n        if (to == address(0)) {\\n            revert NoZero();\\n        }\\n        if (msg.sender != from && !isApprovedForAll[from][msg.sender] && msg.sender != getApproved[id]) {\\n            revert Unauth();\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n            _balanceOf[to]++;\\n        }\\n        delete getApproved[id];\\n        uint256 timestamp = block.timestamp;\\n\\n        // Always allow transfer if one of the recipients is a sudo pool\\n        bool isPair;\\n        try PairFactoryLike(SUDO_FACTORY).isValidPair(from) returns (bool result) {\\n            isPair = result;\\n        } catch {}\\n        if (!isPair) {\\n            try PairFactoryLike(SUDO_FACTORY).isValidPair(to) returns (bool result) {\\n                isPair = result;\\n            } catch {}\\n        }\\n        // If either to or from a pool, always allow it\\n        if (isPair) {\\n            ownerOfWithData[id].owner = to;\\n        }\\n        // If one of the two recipients is not a sudo pool\\n        else {\\n            // Check if earlier than allowed, if so, then revert\\n            if (timestamp < ownerOfWithData[id].lastTransferTimestamp) {\\n                revert Cooldown();\\n            }\\n            // If it is past the cooldown, then we set a new cooldown, and let the transfer go through\\n            ownerOfWithData[id] = OwnerOfWithData({owner: to, lastTransferTimestamp: uint96(timestamp + 7 days)});\\n        }\\n        emit Transfer(from, to, id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                  Generative Metadata\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function getName(uint256 seed) public pure returns (string memory) {\\n        uint256 rng = seed;\\n        // Get uniform from s1\\n        string memory nameS1 = _getItemFromCSV(s1, rng % s1Length);\\n        // Update seed\\n        rng = uint256(keccak256(abi.encode(rng)));\\n        // Get uniform from s2\\n        string memory nameS2 = _getItemFromCSV(s2, rng % s2Length);\\n        // Concatenate the two\\n        string memory name = string(abi.encodePacked(nameS1, nameS2));\\n        // Update seed\\n        rng = uint256(keccak256(abi.encode(rng)));\\n        // Add any s3 syllables (if possible)\\n        for (uint256 i = 0; i < rng % (maxS3Iters + 1); i++) {\\n            string memory nameS3 = _getItemFromCSV(s3, rng % s3Length);\\n            rng = uint256(keccak256(abi.encode(rng)));\\n            name = string(abi.encodePacked(name, nameS3));\\n        }\\n        return name;\\n    }\\n\\n    // @dev Don't worry about anything from here until the tokenURI\\n    function _getItemFromCSV(string memory str, uint256 index) internal pure returns (string memory) {\\n        StringLib.slice memory strSlice = str.toSlice();\\n        string memory separatorStr = \\\",\\\";\\n        StringLib.slice memory separator = separatorStr.toSlice();\\n        StringLib.slice memory item;\\n        for (uint256 i = 0; i <= index; i++) {\\n            item = strSlice.split(separator);\\n        }\\n        return item.toString();\\n    }\\n\\n    function d1(uint256 seed) internal pure returns (uint256 result) {\\n        uint256 start = 0;\\n        uint256 end = 512;\\n        uint256 diff = end + 1 - start;\\n        result = (seed % diff) + start;\\n    }\\n\\n    function d2(uint256 seed) internal pure returns (uint256 result) {\\n        uint256 start = 0;\\n        uint256 end = 512;\\n        uint256 subresult1 = d1(seed);\\n        uint256 seed2 = uint256(keccak256(abi.encode(seed, start, end)));\\n        uint256 subresult2 = d1(seed2);\\n        result = (subresult1 + subresult2) / 2;\\n    }\\n\\n    function d3(uint256 seed) internal pure returns (uint256 result) {\\n        uint256 start = 0;\\n        uint256 end = 512;\\n        uint256 midpoint = (start + end) / 2;\\n        uint256 d2Value = d2(seed);\\n        if (d2Value >= midpoint) {\\n            result = end - (d2Value - midpoint);\\n        } else {\\n            result = start + (midpoint - d2Value);\\n        }\\n    }\\n\\n    function d4(uint256 seed) internal pure returns (uint256 result) {\\n        uint256 start = 0;\\n        uint256 end = 512;\\n        result = d1(seed);\\n        if (result % 2 == 1) {\\n            result = d1(uint256(keccak256(abi.encode(seed, start, end))));\\n        }\\n    }\\n\\n    function d5(uint256 seed) internal pure returns (uint256 result) {\\n        uint256 selector = seed % 4;\\n        uint256 newSeed = uint256(keccak256(abi.encode(seed / d1(seed))));\\n        if (selector == 0) {\\n            result = d3(newSeed);\\n        } else if (selector == 1) {\\n            result = d1(newSeed);\\n        } else if (selector == 2) {\\n            result = d2(newSeed);\\n        } else if (selector == 3) {}\\n        result = d4(newSeed);\\n    }\\n\\n    function d6(uint256 id) internal pure returns (uint256) {\\n        if (id == 0) {\\n            return 0;\\n        }\\n        for (uint256 i = 2; i <= id / 2; i++) {\\n            uint256 result = id - ((id / i) * i);\\n            if (result == 0) {\\n                return 1;\\n            }\\n        }\\n        return 2;\\n    }\\n\\n    function secondD(uint256 seed, uint256 id) internal pure returns (string memory) {\\n        return string(\\n            abi.encodePacked(\\n                '\\\"trait_type\\\": \\\"4tiart\\\",' '\\\"value\\\": \\\"',\\n                Strings.toString(d4(seed)),\\n                '\\\"},{',\\n                '\\\"trait_type\\\": \\\"V\\\",' '\\\"value\\\": \\\"',\\n                Strings.toString(d5(seed)),\\n                '\\\"},{',\\n                '\\\"trait_type\\\": \\\"-- . . . .\\\",' '\\\"value\\\": \\\"',\\n                Strings.toString(d6(id)),\\n                '\\\"}'\\n            )\\n        );\\n    }\\n\\n    function getD(uint256 seed, uint256 id) internal pure returns (string memory) {\\n        return string(\\n            abi.encodePacked(\\n                \\\"{\\\",\\n                '\\\"trait_type\\\": \\\"TRAIT ONE\\\",' '\\\"value\\\": \\\"',\\n                Strings.toString(d1(seed)),\\n                '\\\"},{',\\n                '\\\"trait_type\\\": \\\"7R417_2\\\",' '\\\"value\\\": \\\"',\\n                Strings.toString(d2(seed)),\\n                '\\\"},{',\\n                '\\\"trait_type\\\": \\\"trait3\\\",' '\\\"value\\\": \\\"',\\n                Strings.toString(d3(seed)),\\n                '\\\"},{',\\n                secondD(seed, id)\\n            )\\n        );\\n    }\\n\\n    function getMagic(uint256 id) public view returns (uint256) {\\n        if (markovSeed[id] == 0) {\\n          return uint256(keccak256(abi.encode(id)));\\n        }\\n        else {\\n          return uint256(keccak256(abi.encode(id, markovSeed[id])));\\n        }\\n    }\\n\\n    // Handles metadata from arweave hash, constructs name and metadata\\n    function tokenURI(uint256 id) public view override returns (string memory) {\\n        uint256 seed = uint256(keccak256(abi.encode(id, uint160(SUDO_FACTORY))));\\n        return string(\\n            abi.encodePacked(\\n                \\\"data:application/json;base64,\\\",\\n                Base64.encode(\\n                    bytes(\\n                        abi.encodePacked(\\n                            '{\\\"name\\\":\\\"',\\n                            getName(id),\\n                            '\\\", \\\"description\\\":\\\"',\\n                            MARKOV.speak(getMagic(id), DURATION),\\n                            '\\\", \\\"image\\\": \\\"',\\n                            \\\"ar://\\\",\\n                            ARWEAVE_HASH,\\n                            \\\"/m\\\",\\n                            Strings.toString(id),\\n                            \\\".gif\\\",\\n                            '\\\", \\\"attributes\\\": [',\\n                            getD(seed, id),\\n                            \\\"]\\\",\\n                            \\\"}\\\"\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      Mint x Pool \\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256[] memory ids) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n        uint256 numIds = ids.length;\\n        unchecked {\\n            _balanceOf[to] += numIds;\\n        }\\n        for (uint256 i; i < numIds;) {\\n            uint256 id = ids[i];\\n            if (id >= TOTAL_AKOLS) {\\n                revert Scarce();\\n            }\\n            require(ownerOf(id) == address(0), \\\"ALREADY_MINTED\\\");\\n            ownerOfWithData[id].owner = to;\\n            emit Transfer(address(0), to, id);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function initPools() public onlyOwner returns (address gdaPool, address tradePool){\\n        uint256[] memory empty = new uint256[](0);\\n        gdaPool = address(\\n            PairFactoryLike(SUDO_FACTORY).createPairERC721ERC20(\\n                PairFactoryLike.CreateERC721ERC20PairParams({\\n                    token: ERC20(XMON_ADDRESS),\\n                    nft: IERC721(address(this)),\\n                    bondingCurve: ICurve(GDA_ADDRESS),\\n                    assetRecipient: payable(address(0)),\\n                    poolType: LSSVMPair.PoolType.NFT,\\n                    delta: ((uint128(1500000000) << 88)) | ((uint128(11574) << 48)) | uint128(block.timestamp),\\n                    fee: 0,\\n                    spotPrice: 5 ether,\\n                    propertyChecker: address(0),\\n                    initialNFTIDs: empty,\\n                    initialTokenBalance: 0\\n                })\\n            )\\n        );\\n        tradePool = address(\\n            PairFactoryLike(SUDO_FACTORY).createPairERC721ETH(\\n                IERC721(address(this)),\\n                ICurve(LINEAR_ADDRESS),\\n                payable(address(this)),\\n                LSSVMPair.PoolType.TRADE,\\n                0.0128 ether,\\n                0,\\n                0.0128 ether,\\n                address(0),\\n                empty\\n            )\\n        );\\n        uint256[] memory akolytesToDeposit = new uint256[](69);\\n        for (uint256 i; i < 69;) {\\n            akolytesToDeposit[i] = 341 + i;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        _mint(gdaPool, akolytesToDeposit);\\n        akolytesToDeposit = new uint256[](102);\\n        for (uint256 i; i < 102;) {\\n            akolytesToDeposit[i] = 410 + i;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        _mint(tradePool, akolytesToDeposit);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        Conveniences\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function idsForAddress(address a) external view returns (uint256[] memory) {\\n        uint256 balance = balanceOf(a);\\n        uint256[] memory ids = new uint256[](balance);\\n        if (balance > 0) {\\n            uint256 counter = 0;\\n            for (uint256 i; i < TOTAL_AKOLS;) {\\n                address owner = ownerOfWithData[i].owner;\\n                if (owner == a) {\\n                    ids[counter] = i;\\n                    unchecked {\\n                        ++counter;\\n                    }\\n                    if (counter == balance) {\\n                        return ids;\\n                    }\\n                }\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n        return ids;\\n    }\\n\\n    function royaltiesAccrued(uint256[] memory ids, address royaltyToken)\\n        external\\n        view\\n        returns (uint256[] memory royaltyPerId)\\n    {\\n        uint256 idLength = ids.length;\\n        royaltyPerId = new uint256[](idLength);\\n        uint256 amountPerId = royaltyAccumulatedPerTokenType[royaltyToken] / TOTAL_AKOLS;\\n        for (uint256 i; i < idLength; ++i) {\\n            uint256 idAndTokenKey = uint256(uint160(royaltyToken)) << 96 | ids[i];\\n            royaltyPerId[i] = amountPerId - royaltyClaimedPerId[idAndTokenKey];\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        Tweaks\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function adjustRoyalty(uint96 newRoyalty) public onlyOwner {\\n        if (newRoyalty <= MAX_ROYALTY) {\\n            _setDefaultRoyalty(address(this), newRoyalty);\\n            emit NewRoyalty(newRoyalty);\\n        } else {\\n            revert TooHigh();\\n        }\\n    }\\n\\n    function yeet(uint256[] calldata ids) public onlyOwner {\\n        // Can only yeet after min yeet delay\\n        if (block.timestamp < START_TIME + MIN_YEET_DELAY) {\\n            revert NoYeet();\\n        }\\n\\n        // Can only yeet below 341 (ensures no supply rug)\\n        uint256 numIds = ids.length;\\n        for (uint256 i; i < numIds; ++i) {\\n            if (ids[i] >= 341) {\\n                revert Scarce();\\n            }\\n        }\\n\\n        _mint(msg.sender, ids);\\n    }\\n\\n    // Receive ETH\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/common/ERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/common/ERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IERC2981.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\\n *\\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\\n *\\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\\n * fee is specified in basis points by default.\\n *\\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\\n *\\n * _Available since v4.5._\\n */\\nabstract contract ERC2981 is IERC2981, ERC165 {\\n    struct RoyaltyInfo {\\n        address receiver;\\n        uint96 royaltyFraction;\\n    }\\n\\n    RoyaltyInfo private _defaultRoyaltyInfo;\\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC2981\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public view virtual override returns (address, uint256) {\\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[tokenId];\\n\\n        if (royalty.receiver == address(0)) {\\n            royalty = _defaultRoyaltyInfo;\\n        }\\n\\n        uint256 royaltyAmount = (salePrice * royalty.royaltyFraction) / _feeDenominator();\\n\\n        return (royalty.receiver, royaltyAmount);\\n    }\\n\\n    /**\\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\\n     * override.\\n     */\\n    function _feeDenominator() internal pure virtual returns (uint96) {\\n        return 10000;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information that all ids in this contract will default to.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: invalid receiver\\\");\\n\\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Removes default royalty information.\\n     */\\n    function _deleteDefaultRoyalty() internal virtual {\\n        delete _defaultRoyaltyInfo;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: Invalid parameters\\\");\\n\\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Resets royalty information for the token id back to the global default.\\n     */\\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\\n        delete _tokenRoyaltyInfo[tokenId];\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(\\n        uint256 tokenId,\\n        uint256 salePrice\\n    ) external view returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/lssvm2/src/bonding-curves/ICurve.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {CurveErrorCodes} from \\\"./CurveErrorCodes.sol\\\";\\n\\ninterface ICurve {\\n    /**\\n     * @notice Validates if a delta value is valid for the curve. The criteria for\\n     * validity can be different for each type of curve, for instance ExponentialCurve\\n     * requires delta to be greater than 1.\\n     * @param delta The delta value to be validated\\n     * @return valid True if delta is valid, false otherwise\\n     */\\n    function validateDelta(uint128 delta) external pure returns (bool valid);\\n\\n    /**\\n     * @notice Validates if a new spot price is valid for the curve. Spot price is generally assumed to be the immediate sell price of 1 NFT to the pool, in units of the pool's paired token.\\n     * @param newSpotPrice The new spot price to be set\\n     * @return valid True if the new spot price is valid, false otherwise\\n     */\\n    function validateSpotPrice(uint128 newSpotPrice) external view returns (bool valid);\\n\\n    /**\\n     * @notice Given the current state of the pair and the trade, computes how much the user\\n     * should pay to purchase an NFT from the pair, the new spot price, and other values.\\n     * @param spotPrice The current selling spot price of the pair, in tokens\\n     * @param delta The delta parameter of the pair, what it means depends on the curve\\n     * @param numItems The number of NFTs the user is buying from the pair\\n     * @param feeMultiplier Determines how much fee the LP takes from this trade, 18 decimals\\n     * @param protocolFeeMultiplier Determines how much fee the protocol takes from this trade, 18 decimals\\n     * @return error Any math calculation errors, only Error.OK means the returned values are valid\\n     * @return newSpotPrice The updated selling spot price, in tokens\\n     * @return newDelta The updated delta, used to parameterize the bonding curve\\n     * @return inputValue The amount that the user should pay, in tokens\\n     * @return tradeFee The amount that is sent to the trade fee recipient\\n     * @return protocolFee The amount of fee to send to the protocol, in tokens\\n     */\\n    function getBuyInfo(\\n        uint128 spotPrice,\\n        uint128 delta,\\n        uint256 numItems,\\n        uint256 feeMultiplier,\\n        uint256 protocolFeeMultiplier\\n    )\\n        external\\n        view\\n        returns (\\n            CurveErrorCodes.Error error,\\n            uint128 newSpotPrice,\\n            uint128 newDelta,\\n            uint256 inputValue,\\n            uint256 tradeFee,\\n            uint256 protocolFee\\n        );\\n\\n    /**\\n     * @notice Given the current state of the pair and the trade, computes how much the user\\n     * should receive when selling NFTs to the pair, the new spot price, and other values.\\n     * @param spotPrice The current selling spot price of the pair, in tokens\\n     * @param delta The delta parameter of the pair, what it means depends on the curve\\n     * @param numItems The number of NFTs the user is selling to the pair\\n     * @param feeMultiplier Determines how much fee the LP takes from this trade, 18 decimals\\n     * @param protocolFeeMultiplier Determines how much fee the protocol takes from this trade, 18 decimals\\n     * @return error Any math calculation errors, only Error.OK means the returned values are valid\\n     * @return newSpotPrice The updated selling spot price, in tokens\\n     * @return newDelta The updated delta, used to parameterize the bonding curve\\n     * @return outputValue The amount that the user should receive, in tokens\\n     * @return tradeFee The amount that is sent to the trade fee recipient\\n     * @return protocolFee The amount of fee to send to the protocol, in tokens\\n     */\\n    function getSellInfo(\\n        uint128 spotPrice,\\n        uint128 delta,\\n        uint256 numItems,\\n        uint256 feeMultiplier,\\n        uint256 protocolFeeMultiplier\\n    )\\n        external\\n        view\\n        returns (\\n            CurveErrorCodes.Error error,\\n            uint128 newSpotPrice,\\n            uint128 newDelta,\\n            uint256 outputValue,\\n            uint256 tradeFee,\\n            uint256 protocolFee\\n        );\\n}\\n\"\r\n    },\r\n    \"lib/lssvm2/src/LSSVMPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {IRoyaltyEngineV1} from \\\"manifoldxyz/IRoyaltyEngineV1.sol\\\";\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\n\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport {ERC721Holder} from \\\"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\\\";\\nimport {ERC1155Holder} from \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\\\";\\n\\nimport {LSSVMRouter} from \\\"./LSSVMRouter.sol\\\";\\nimport {ICurve} from \\\"./bonding-curves/ICurve.sol\\\";\\nimport {ILSSVMPairFactoryLike} from \\\"./ILSSVMPairFactoryLike.sol\\\";\\nimport {CurveErrorCodes} from \\\"./bonding-curves/CurveErrorCodes.sol\\\";\\nimport {IOwnershipTransferReceiver} from \\\"./lib/IOwnershipTransferReceiver.sol\\\";\\nimport {OwnableWithTransferCallback} from \\\"./lib/OwnableWithTransferCallback.sol\\\";\\n\\n/**\\n * @title The base contract for an NFT/TOKEN AMM pair\\n * @author boredGenius, 0xmons, 0xCygaar\\n * @notice This implements the core swap logic from NFT to TOKEN\\n */\\nabstract contract LSSVMPair is OwnableWithTransferCallback, ERC721Holder, ERC1155Holder {\\n    /**\\n     * Library usage **\\n     */\\n\\n    using Address for address;\\n\\n    /**\\n     *  Enums **\\n     */\\n\\n    enum PoolType {\\n        TOKEN,\\n        NFT,\\n        TRADE\\n    }\\n\\n    /**\\n     * Constants **\\n     */\\n\\n    /**\\n     * @dev 50%, must <= 1 - MAX_PROTOCOL_FEE (set in LSSVMPairFactory)\\n     */\\n    uint256 internal constant MAX_TRADE_FEE = 0.5e18;\\n\\n    /**\\n     *  Immutable params **\\n     */\\n\\n    /**\\n     * @notice Sudoswap Royalty Engine\\n     */\\n    IRoyaltyEngineV1 public immutable ROYALTY_ENGINE;\\n\\n    /**\\n     *  Storage variables **\\n     */\\n\\n    /**\\n     * @dev This is generally used to mean the immediate sell price for the next marginal NFT.\\n     * However, this should NOT be assumed, as bonding curves may use spotPrice in different ways.\\n     * Use getBuyNFTQuote and getSellNFTQuote for accurate pricing info.\\n     */\\n    uint128 public spotPrice;\\n\\n    /**\\n     * @notice The parameter for the pair's bonding curve.\\n     * Units and meaning are bonding curve dependent.\\n     */\\n    uint128 public delta;\\n\\n    /**\\n     * @notice The spread between buy and sell prices, set to be a multiplier we apply to the buy price\\n     * Fee is only relevant for TRADE pools. Units are in base 1e18.\\n     */\\n    uint96 public fee;\\n\\n    /**\\n     * @notice The address that swapped assets are sent to.\\n     * For TRADE pools, assets are always sent to the pool, so this is used to track trade fee.\\n     * If set to address(0), will default to owner() for NFT and TOKEN pools.\\n     */\\n    address payable internal assetRecipient;\\n\\n    /**\\n     *  Events\\n     */\\n\\n    event SwapNFTInPair(uint256 amountOut, uint256[] ids);\\n    event SwapNFTInPair(uint256 amountOut, uint256 numNFTs);\\n    event SwapNFTOutPair(uint256 amountIn, uint256[] ids);\\n    event SwapNFTOutPair(uint256 amountIn, uint256 numNFTs);\\n    event SpotPriceUpdate(uint128 newSpotPrice);\\n    event TokenDeposit(uint256 amount);\\n    event TokenWithdrawal(uint256 amount);\\n    event NFTWithdrawal(uint256[] ids);\\n    event NFTWithdrawal(uint256 numNFTs);\\n    event DeltaUpdate(uint128 newDelta);\\n    event FeeUpdate(uint96 newFee);\\n    event AssetRecipientChange(address indexed a);\\n\\n    /**\\n     *  Errors\\n     */\\n\\n    error LSSVMPair__NotRouter();\\n    error LSSVMPair__CallFailed();\\n    error LSSVMPair__InvalidDelta();\\n    error LSSVMPair__WrongPoolType();\\n    error LSSVMPair__OutputTooSmall();\\n    error LSSVMPair__ZeroSwapAmount();\\n    error LSSVMPair__RoyaltyTooLarge();\\n    error LSSVMPair__TradeFeeTooLarge();\\n    error LSSVMPair__InvalidSpotPrice();\\n    error LSSVMPair__TargetNotAllowed();\\n    error LSSVMPair__NftNotTransferred();\\n    error LSSVMPair__AlreadyInitialized();\\n    error LSSVMPair__FunctionNotAllowed();\\n    error LSSVMPair__DemandedInputTooLarge();\\n    error LSSVMPair__NonTradePoolWithTradeFee();\\n    error LSSVMPair__BondingCurveError(CurveErrorCodes.Error error);\\n\\n    constructor(IRoyaltyEngineV1 royaltyEngine) {\\n        ROYALTY_ENGINE = royaltyEngine;\\n    }\\n\\n    /**\\n     * @notice Called during pair creation to set initial parameters\\n     * @dev Only called once by factory to initialize.\\n     * We verify this by making sure that the current owner is address(0).\\n     * The Ownable library we use disallows setting the owner to be address(0), so this condition\\n     * should only be valid before the first initialize call.\\n     * @param _owner The owner of the pair\\n     * @param _assetRecipient The address that will receive the TOKEN or NFT sent to this pair during swaps. NOTE: If set to address(0), they will go to the pair itself.\\n     * @param _delta The initial delta of the bonding curve\\n     * @param _fee The initial % fee taken, if this is a trade pair\\n     * @param _spotPrice The initial price to sell an asset into the pair\\n     */\\n    function initialize(\\n        address _owner,\\n        address payable _assetRecipient,\\n        uint128 _delta,\\n        uint96 _fee,\\n        uint128 _spotPrice\\n    ) external {\\n        if (owner() != address(0)) revert LSSVMPair__AlreadyInitialized();\\n        __Ownable_init(_owner);\\n\\n        ICurve _bondingCurve = bondingCurve();\\n        PoolType _poolType = poolType();\\n        if (_poolType != PoolType.TRADE) {\\n            if (_fee != 0) revert LSSVMPair__NonTradePoolWithTradeFee();\\n        } else {\\n            if (_fee > MAX_TRADE_FEE) revert LSSVMPair__TradeFeeTooLarge();\\n            fee = _fee;\\n        }\\n\\n        assetRecipient = _assetRecipient;\\n\\n        if (!_bondingCurve.validateDelta(_delta)) revert LSSVMPair__InvalidDelta();\\n        if (!_bondingCurve.validateSpotPrice(_spotPrice)) revert LSSVMPair__InvalidSpotPrice();\\n        delta = _delta;\\n        spotPrice = _spotPrice;\\n    }\\n\\n    /**\\n     * External state-changing functions\\n     */\\n\\n    /**\\n     * @notice Sends token to the pair in exchange for a specific set of NFTs\\n     * @dev To compute the amount of token to send, call bondingCurve.getBuyInfo\\n     * This swap is meant for users who want specific IDs. Also higher chance of\\n     * reverting if some of the specified IDs leave the pool before the swap goes through.\\n     * @param nftIds The list of IDs of the NFTs to purchase\\n     * @param maxExpectedTokenInput The maximum acceptable cost from the sender. If the actual\\n     * amount is greater than this value, the transaction will be reverted.\\n     * @param nftRecipient The recipient of the NFTs\\n     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for ETH pairs.\\n     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for ETH pairs.\\n     * @return - The amount of token used for purchase\\n     */\\n    function swapTokenForSpecificNFTs(\\n        uint256[] calldata nftIds,\\n        uint256 maxExpectedTokenInput,\\n        address nftRecipient,\\n        bool isRouter,\\n        address routerCaller\\n    ) external payable virtual returns (uint256);\\n\\n    /**\\n     * @notice Sends a set of NFTs to the pair in exchange for token\\n     * @dev To compute the amount of token to that will be received, call bondingCurve.getSellInfo.\\n     * @param nftIds The list of IDs of the NFTs to sell to the pair\\n     * @param minExpectedTokenOutput The minimum acceptable token received by the sender. If the actual\\n     * amount is less than this value, the transaction will be reverted.\\n     * @param tokenRecipient The recipient of the token output\\n     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for\\n     * ETH pairs.\\n     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for\\n     * ETH pairs.\\n     * @return outputAmount The amount of token received\\n     */\\n    function swapNFTsForToken(\\n        uint256[] calldata nftIds,\\n        uint256 minExpectedTokenOutput,\\n        address payable tokenRecipient,\\n        bool isRouter,\\n        address routerCaller\\n    ) external virtual returns (uint256 outputAmount);\\n\\n    /**\\n     * View functions\\n     */\\n\\n    /**\\n     * @dev Used as read function to query the bonding curve for buy pricing info\\n     * @param numNFTs The number of NFTs to buy from the pair\\n     */\\n    function getBuyNFTQuote(uint256 assetId, uint256 numNFTs)\\n        external\\n        view\\n        returns (\\n            CurveErrorCodes.Error error,\\n            uint256 newSpotPrice,\\n            uint256 newDelta,\\n            uint256 inputAmount,\\n            uint256 protocolFee,\\n            uint256 royaltyAmount\\n        )\\n    {\\n        uint256 tradeFee;\\n        (error, newSpotPrice, newDelta, inputAmount, tradeFee, protocolFee) =\\n            bondingCurve().getBuyInfo(spotPrice, delta, numNFTs, fee, factory().protocolFeeMultiplier());\\n\\n        if (numNFTs != 0) {\\n            // Calculate the inputAmount minus tradeFee and protocolFee\\n            uint256 inputAmountMinusFees = inputAmount - tradeFee - protocolFee;\\n\\n            // Compute royalties\\n            (,, royaltyAmount) = calculateRoyaltiesView(assetId, inputAmountMinusFees);\\n\\n            inputAmount += royaltyAmount;\\n        }\\n    }\\n\\n    /**\\n     * @dev Used as read function to query the bonding curve for sell pricing info including royalties\\n     * @param numNFTs The number of NFTs to sell to the pair\\n     */\\n    function getSellNFTQuote(uint256 assetId, uint256 numNFTs)\\n        external\\n        view\\n        returns (\\n            CurveErrorCodes.Error error,\\n            uint256 newSpotPrice,\\n            uint256 newDelta,\\n            uint256 outputAmount,\\n            uint256 protocolFee,\\n            uint256 royaltyAmount\\n        )\\n    {\\n        (error, newSpotPrice, newDelta, outputAmount, /* tradeFee */, protocolFee) =\\n            bondingCurve().getSellInfo(spotPrice, delta, numNFTs, fee, factory().protocolFeeMultiplier());\\n\\n        if (numNFTs != 0) {\\n            // Compute royalties\\n            (,, royaltyAmount) = calculateRoyaltiesView(assetId, outputAmount);\\n\\n            // Deduct royalties from outputAmount\\n            unchecked {\\n                // Safe because we already require outputAmount >= royaltyAmount in _calculateRoyalties()\\n                outputAmount -= royaltyAmount;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the pair's variant (Pair uses ETH or ERC20)\\n     */\\n    function pairVariant() public pure virtual returns (ILSSVMPairFactoryLike.PairVariant);\\n\\n    function factory() public pure returns (ILSSVMPairFactoryLike _factory) {\\n        uint256 paramsLength = _immutableParamsLength();\\n        assembly {\\n            _factory := shr(0x60, calldataload(sub(calldatasize(), paramsLength)))\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the type of bonding curve that parameterizes the pair\\n     */\\n    function bondingCurve() public pure returns (ICurve _bondingCurve) {\\n        uint256 paramsLength = _immutableParamsLength();\\n        assembly {\\n            _bondingCurve := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), 20)))\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the address of NFT collection that parameterizes the pair\\n     */\\n    function nft() public pure returns (address _nft) {\\n        uint256 paramsLength = _immutableParamsLength();\\n        assembly {\\n            _nft := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), 40)))\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the pair's type (TOKEN/NFT/TRADE)\\n     */\\n    function poolType() public pure returns (PoolType _poolType) {\\n        uint256 paramsLength = _immutableParamsLength();\\n        assembly {\\n            _poolType := shr(0xf8, calldataload(add(sub(calldatasize(), paramsLength), 60)))\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the address that receives assets when a swap is done with this pair\\n     * Can be set to another address by the owner, but has no effect on TRADE pools\\n     * If set to address(0), defaults to owner() for NFT/TOKEN pools\\n     */\\n    function getAssetRecipient() public view returns (address payable) {\\n        // TRADE pools will always receive the asset themselves\\n        if (poolType() == PoolType.TRADE) {\\n            return payable(address(this));\\n        }\\n\\n        address payable _assetRecipient = assetRecipient;\\n\\n        // Otherwise, we return the recipient if it's been set\\n        // Or, we replace it with owner() if it's address(0)\\n        if (_assetRecipient == address(0)) {\\n            return payable(owner());\\n        }\\n        return _assetRecipient;\\n    }\\n\\n    /**\\n     * @notice Returns the address that receives trade fees when a swap is done with this pair\\n     * Only relevant for TRADE pools\\n     * If set to address(0), defaults to the pair itself\\n     */\\n    function getFeeRecipient() public view returns (address payable _feeRecipient) {\\n        _feeRecipient = assetRecipient;\\n        if (_feeRecipient == address(0)) {\\n            _feeRecipient = payable(address(this));\\n        }\\n    }\\n\\n    /**\\n     * Internal functions\\n     */\\n\\n    /**\\n     * @notice Calculates the amount needed to be sent into the pair for a buy and adjusts spot price or delta if necessary\\n     * @param numNFTs The amount of NFTs to purchase from the pair\\n     * @param _bondingCurve The bonding curve to use for price calculation\\n     * @param _factory The factory to use for protocol fee lookup\\n     * @return tradeFee The amount of tokens to send as trade fee\\n     * @return protocolFee The amount of tokens to send as protocol fee\\n     * @return inputAmount The amount of tokens total tokens receive\\n     */\\n    function _calculateBuyInfoAndUpdatePoolParams(uint256 numNFTs, ICurve _bondingCurve, ILSSVMPairFactoryLike _factory)\\n        internal\\n        returns (uint256 tradeFee, uint256 protocolFee, uint256 inputAmount)\\n    {\\n        CurveErrorCodes.Error error;\\n        // Save on 2 SLOADs by caching\\n        uint128 currentSpotPrice = spotPrice;\\n        uint128 currentDelta = delta;\\n        uint128 newDelta;\\n        uint128 newSpotPrice;\\n        (error, newSpotPrice, newDelta, inputAmount, tradeFee, protocolFee) =\\n            _bondingCurve.getBuyInfo(currentSpotPrice, currentDelta, numNFTs, fee, _factory.protocolFeeMultiplier());\\n\\n        // Revert if bonding curve had an error\\n        if (error != CurveErrorCodes.Error.OK) {\\n            revert LSSVMPair__BondingCurveError(error);\\n        }\\n\\n        // Consolidate writes to save gas\\n        if (currentSpotPrice != newSpotPrice || currentDelta != newDelta) {\\n            spotPrice = newSpotPrice;\\n            delta = newDelta;\\n        }\\n\\n        // Emit spot price update if it has been updated\\n        if (currentSpotPrice != newSpotPrice) {\\n            emit SpotPriceUpdate(newSpotPrice);\\n        }\\n\\n        // Emit delta update if it has been updated\\n        if (currentDelta != newDelta) {\\n            emit DeltaUpdate(newDelta);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates the amount needed to be sent by the pair for a sell and adjusts spot price or delta if necessary\\n     * @param numNFTs The amount of NFTs to send to the the pair\\n     * @param _bondingCurve The bonding curve to use for price calculation\\n     * @param _factory The factory to use for protocol fee lookup\\n     * @return protocolFee The amount of tokens to send as protocol fee\\n     * @return outputAmount The amount of tokens total tokens receive\\n     */\\n    function _calculateSellInfoAndUpdatePoolParams(\\n        uint256 numNFTs,\\n        ICurve _bondingCurve,\\n        ILSSVMPairFactoryLike _factory\\n    ) internal returns (uint256 protocolFee, uint256 outputAmount) {\\n        CurveErrorCodes.Error error;\\n        // Save on 2 SLOADs by caching\\n        uint128 currentSpotPrice = spotPrice;\\n        uint128 currentDelta = delta;\\n        uint128 newSpotPrice;\\n        uint128 newDelta;\\n        (error, newSpotPrice, newDelta, outputAmount, /*tradeFee*/, protocolFee) =\\n            _bondingCurve.getSellInfo(currentSpotPrice, currentDelta, numNFTs, fee, _factory.protocolFeeMultiplier());\\n\\n        // Revert if bonding curve had an error\\n        if (error != CurveErrorCodes.Error.OK) {\\n            revert LSSVMPair__BondingCurveError(error);\\n        }\\n\\n        // Consolidate writes to save gas\\n        if (currentSpotPrice != newSpotPrice || currentDelta != newDelta) {\\n            spotPrice = newSpotPrice;\\n            delta = newDelta;\\n        }\\n\\n        // Emit spot price update if it has been updated\\n        if (currentSpotPrice != newSpotPrice) {\\n            emit SpotPriceUpdate(newSpotPrice);\\n        }\\n\\n        // Emit delta update if it has been updated\\n        if (currentDelta != newDelta) {\\n            emit DeltaUpdate(newDelta);\\n        }\\n    }\\n\\n    /**\\n     * @notice Pulls the token input of a trade from the trader (including all royalties and fees)\\n     * @param inputAmountExcludingRoyalty The amount of tokens to be sent, excluding the royalty (includes protocol fee)\\n     * @param royaltyAmounts The amounts of tokens to be sent as royalties\\n     * @param royaltyRecipients The recipients of the royalties\\n     * @param royaltyTotal The sum of all royaltyAmounts\\n     * @param tradeFeeAmount The amount of tokens to be sent as trade fee (if applicable)\\n     * @param isRouter Whether or not the caller is LSSVMRouter\\n     * @param routerCaller If called from LSSVMRouter, store the original caller\\n     * @param protocolFee The protocol fee to be paid\\n     */\\n    function _pullTokenInputs(\\n        uint256 inputAmountExcludingRoyalty,\\n        uint256[] memory royaltyAmounts,\\n        address payable[] memory royaltyRecipients,\\n        uint256 royaltyTotal,\\n        uint256 tradeFeeAmount,\\n        bool isRouter,\\n        address routerCaller,\\n        uint256 protocolFee\\n    ) internal virtual;\\n\\n    /**\\n     * @notice Sends excess tokens back to the caller (if applicable)\\n     * @dev Swap callers interacting with an ETH pair must be able to receive ETH (e.g. if the caller sends too much ETH)\\n     */\\n    function _refundTokenToSender(uint256 inputAmount) internal virtual;\\n\\n    /**\\n     * @notice Sends tokens to a recipient\\n     * @param tokenRecipient The address receiving the tokens\\n     * @param outputAmount The amount of tokens to send\\n     */\\n    function _sendTokenOutput(address payable tokenRecipient, uint256 outputAmount) internal virtual;\\n\\n    /**\\n     * @dev Used internally to grab pair parameters from calldata, see LSSVMPairCloner for technical details\\n     */\\n    function _immutableParamsLength() internal pure virtual returns (uint256);\\n\\n    /**\\n     * Royalty support functions\\n     */\\n\\n    function _calculateRoyalties(uint256 assetId, uint256 saleAmount)\\n        internal\\n        returns (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal)\\n    {\\n        (address payable[] memory recipients, uint256[] memory amounts) =\\n            ROYALTY_ENGINE.getRoyalty(nft(), assetId, saleAmount);\\n        return _calculateRoyaltiesLogic(recipients, amounts, saleAmount);\\n    }\\n\\n    /**\\n     * @dev Same as _calculateRoyalties, but uses getRoyaltyView to avoid state mutations and is public for external callers\\n     */\\n    function calculateRoyaltiesView(uint256 assetId, uint256 saleAmount)\\n        public\\n        view\\n        returns (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal)\\n    {\\n        (address payable[] memory recipients, uint256[] memory amounts) =\\n            ROYALTY_ENGINE.getRoyaltyView(nft(), assetId, saleAmount);\\n        return _calculateRoyaltiesLogic(recipients, amounts, saleAmount);\\n    }\\n\\n    /**\\n     * @dev Common logic used by _calculateRoyalties() and calculateRoyaltiesView()\\n     */\\n    function _calculateRoyaltiesLogic(address payable[] memory recipients, uint256[] memory amounts, uint256 saleAmount)\\n        internal\\n        view\\n        returns (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal)\\n    {\\n        // Cache to save gas\\n        uint256 numRecipients = recipients.length;\\n\\n        if (numRecipients != 0) {\\n            // If a pair has custom Settings, use the overridden royalty amount and only use the first receiver\\n            try factory().getSettingsForPair(address(this)) returns (bool settingsEnabled, uint96 bps) {\\n                if (settingsEnabled) {\\n                    royaltyRecipients = new address payable[](1);\\n                    royaltyRecipients[0] = recipients[0];\\n                    royaltyAmounts = new uint256[](1);\\n                    royaltyAmounts[0] = (saleAmount * bps) / 10000;\\n\\n                    // Update numRecipients to match new recipients list\\n                    numRecipients = 1;\\n                } else {\\n                    royaltyRecipients = recipients;\\n                    royaltyAmounts = amounts;\\n                }\\n            } catch {\\n                // Use the input values to calculate royalties if factory call fails\\n                royaltyRecipients = recipients;\\n                royaltyAmounts = amounts;\\n            }\\n        }\\n\\n        for (uint256 i; i < numRecipients;) {\\n            royaltyTotal += royaltyAmounts[i];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Ensure royalty total is at most 25% of the sale amount\\n        // This defends against a rogue Manifold registry that charges extremely high royalties\\n        if (royaltyTotal > saleAmount >> 2) {\\n            revert LSSVMPair__RoyaltyTooLarge();\\n        }\\n    }\\n\\n    /**\\n     * Owner functions\\n     */\\n\\n    /**\\n     * @notice Rescues a specified set of NFTs owned by the pair to the owner address. (onlyOwnable modifier is in the implemented function)\\n     * @param a The NFT to transfer\\n     * @param nftIds The list of IDs of the NFTs to send to the owner\\n     */\\n    function withdrawERC721(IERC721 a, uint256[] calldata nftIds) external virtual;\\n\\n    /**\\n     * @notice Rescues ERC20 tokens from the pair to the owner. Only callable by the owner (onlyOwnable modifier is in the implemented function).\\n     * @param a The token to transfer\\n     * @param amount The amount of tokens to send to the owner\\n     */\\n    function withdrawERC20(ERC20 a, uint256 amount) external virtual;\\n\\n    /**\\n     * @notice Rescues ERC1155 tokens from the pair to the owner. Only callable by the owner.\\n     * @param a The NFT to transfer\\n     * @param ids The NFT ids to transfer\\n     * @param amounts The amounts of each id to transfer\\n     */\\n    function withdrawERC1155(IERC1155 a, uint256[] calldata ids, uint256[] calldata amounts) external virtual;\\n\\n    /**\\n     * @notice Updates the selling spot price. Only callable by the owner.\\n     * @param newSpotPrice The new selling spot price value, in Token\\n     */\\n    function changeSpotPrice(uint128 newSpotPrice) external onlyOwner {\\n        ICurve _bondingCurve = bondingCurve();\\n        if (!_bondingCurve.validateSpotPrice(newSpotPrice)) revert LSSVMPair__InvalidSpotPrice();\\n        if (spotPrice != newSpotPrice) {\\n            spotPrice = newSpotPrice;\\n            emit SpotPriceUpdate(newSpotPrice);\\n        }\\n    }\\n\\n    /**\\n     * @notice Updates the delta parameter. Only callable by the owner.\\n     * @param newDelta The new delta parameter\\n     */\\n    function changeDelta(uint128 newDelta) external onlyOwner {\\n        ICurve _bondingCurve = bondingCurve();\\n        if (!_bondingCurve.validateDelta(newDelta)) revert LSSVMPair__InvalidDelta();\\n        if (delta != newDelta) {\\n            delta = newDelta;\\n            emit DeltaUpdate(newDelta);\\n        }\\n    }\\n\\n    /**\\n     * @notice Updates the fee taken by the LP. Only callable by the owner.\\n     * Only callable if the pool is a Trade pool. Reverts if the fee is >= MAX_FEE.\\n     * @param newFee The new LP fee percentage, 18 decimals\\n     */\\n    function changeFee(uint96 newFee) external onlyOwner {\\n        PoolType _poolType = poolType();\\n        if (_poolType != PoolType.TRADE) revert LSSVMPair__NonTradePoolWithTradeFee();\\n        if (newFee > MAX_TRADE_FEE) revert LSSVMPair__TradeFeeTooLarge();\\n        if (fee != newFee) {\\n            fee = newFee;\\n            emit FeeUpdate(newFee);\\n        }\\n    }\\n\\n    /**\\n     * @notice Changes the address that will receive assets received from\\n     * trades. Only callable by the owner.\\n     * @param newRecipient The new asset recipient\\n     */\\n    function changeAssetRecipient(address payable newRecipient) external onlyOwner {\\n        if (assetRecipient != newRecipient) {\\n            assetRecipient = newRecipient;\\n            emit AssetRecipientChange(newRecipient);\\n        }\\n    }\\n\\n    function _preCallCheck(address target) internal virtual;\\n\\n    /**\\n     * @notice Allows the pair to make arbitrary external calls to contracts\\n     * whitelisted by the protocol. Only callable by the owner.\\n     * @param target The contract to call\\n     * @param data The calldata to pass to the contract\\n     */\\n    function call(address payable target, bytes calldata data) external onlyOwner {\\n        ILSSVMPairFactoryLike _factory = factory();\\n        if (!_factory.callAllowed(target)) revert LSSVMPair__TargetNotAllowed();\\n\\n        // Ensure the call isn't calling a banned function\\n        bytes4 sig = bytes4(data[:4]);\\n        if (\\n            sig == IOwnershipTransferReceiver.onOwnershipTransferred.selector\\n                || sig == LSSVMRouter.pairTransferERC20From.selector || sig == LSSVMRouter.pairTransferNFTFrom.selector\\n                || sig == LSSVMRouter.pairTransferERC1155From.selector || sig == ILSSVMPairFactoryLike.openLock.selector\\n                || sig == ILSSVMPairFactoryLike.closeLock.selector\\n        ) {\\n            revert LSSVMPair__FunctionNotAllowed();\\n        }\\n\\n        // Prevent calling the pair's underlying nft\\n        // (We ban calling the underlying NFT/ERC20 to avoid maliciously transferring assets approved for the pair to spend)\\n        if (target == nft()) revert LSSVMPair__TargetNotAllowed();\\n\\n        _preCallCheck(target);\\n\\n        (bool success,) = target.call{value: 0}(data);\\n        if (!success) revert LSSVMPair__CallFailed();\\n    }\\n\\n    /**\\n     * @notice Allows owner to batch multiple calls, forked from: https://github.com/boringcrypto/BoringSolidity/blob/master/contracts/BoringBatchable.sol\\n     * @notice The revert handling is forked from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/c239e1af8d1a1296577108dd6989a17b57434f8e/contracts/utils/Address.sol#L201\\n     * @dev Intended for withdrawing/altering pool pricing in one tx, only callable by owner, cannot change owner\\n     * @param calls The calldata for each call to make\\n     * @param revertOnFail Whether or not to revert the entire tx if any of the calls fail. Calls to transferOwnership will revert regardless.\\n     */\\n    function multicall(bytes[] calldata calls, bool revertOnFail) external onlyOwner {\\n        for (uint256 i; i < calls.length;) {\\n            bytes4 sig = bytes4(calls[i][:4]);\\n            // We ban calling transferOwnership when ownership\\n            if (sig == transferOwnership.selector) revert LSSVMPair__FunctionNotAllowed();\\n\\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\\n            if (!success && revertOnFail) {\\n                assembly {\\n                    revert(add(0x20, result), mload(result))\\n                }\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/PairFactoryLike.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IERC721} from \\\"openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\\\";\\nimport {ICurve} from \\\"lssvm2/bonding-curves/ICurve.sol\\\";\\nimport {LSSVMPair} from \\\"lssvm2/LSSVMPair.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\n\\ninterface PairFactoryLike {\\n    function isValidPair(address pairAddress) external view returns (bool);\\n\\n    function createPairERC721ETH(\\n        IERC721 _nft,\\n        ICurve _bondingCurve,\\n        address payable _assetRecipient,\\n        LSSVMPair.PoolType _poolType,\\n        uint128 _delta,\\n        uint96 _fee,\\n        uint128 _spotPrice,\\n        address _propertyChecker,\\n        uint256[] calldata _initialNFTIDs\\n    ) external payable returns (LSSVMPair pair);\\n\\n    struct CreateERC721ERC20PairParams {\\n        ERC20 token;\\n        IERC721 nft;\\n        ICurve bondingCurve;\\n        address payable assetRecipient;\\n        LSSVMPair.PoolType poolType;\\n        uint128 delta;\\n        uint96 fee;\\n        uint128 spotPrice;\\n        address propertyChecker;\\n        uint256[] initialNFTIDs;\\n        uint256 initialTokenBalance;\\n    }\\n\\n    function createPairERC721ERC20(CreateERC721ERC20PairParams calldata params) external returns (LSSVMPair pair);\\n}\\n\"\r\n    },\r\n    \"src/RoyaltyHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {Owned} from \\\"solmate/auth/Owned.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\n\\ncontract RoyaltyHandler is Owned {\\n    using SafeTransferLib for address payable;\\n    using SafeTransferLib for ERC20;\\n\\n    constructor() Owned(msg.sender) {}\\n\\n    function sendETH(address payable to, uint256 amount) external onlyOwner {\\n        to.safeTransferETH(amount);\\n    }\\n\\n    function sendERC20(address to, address erc20Address, uint256 amount) external onlyOwner {\\n        ERC20(erc20Address).safeTransfer(to, amount);\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"src/ERC721Minimal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Forked from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721Minimal {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner);\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = ownerOf(id);\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(address from, address to, uint256 id) public virtual;\\n\\n    function safeTransferFrom(address from, address to, uint256 id) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0\\n                || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\")\\n                    == ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0\\n                || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data)\\n                    == ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165\\n            || interfaceId == 0x80ac58cd // ERC165 Interface ID for ERC721\\n            || interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(address, address, uint256, bytes calldata) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libs/StringLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nlibrary StringLib {\\n    struct slice {\\n        uint256 _len;\\n        uint256 _ptr;\\n    }\\n\\n    function memcpy(uint256 dest, uint256 src, uint256 len) private pure {\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        uint256 mask = 256 ** (32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /*\\n    * @dev Returns a slice containing the entire string.\\n    * @param self The string to make a slice from.\\n    * @return A newly allocated slice containing the entire string.\\n    */\\n    function toSlice(string memory self) internal pure returns (slice memory) {\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(self, 0x20)\\n        }\\n        return slice(bytes(self).length, ptr);\\n    }\\n\\n    /*\\n    * @dev Copies a slice to a new string.\\n    * @param self The slice to copy.\\n    * @return A newly allocated string containing the slice's text.\\n    */\\n    function toString(slice memory self) internal pure returns (string memory) {\\n        string memory ret = new string(self._len);\\n        uint256 retptr;\\n        assembly {\\n            retptr := add(ret, 32)\\n        }\\n\\n        memcpy(retptr, self._ptr, self._len);\\n        return ret;\\n    }\\n\\n    // Returns the memory address of the first byte of the first occurrence of\\n    // `needle` in `self`, or the first byte after `self` if not found.\\n    function findPtr(uint256 selflen, uint256 selfptr, uint256 needlelen, uint256 needleptr)\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 ptr = selfptr;\\n        uint256 idx;\\n\\n        if (needlelen <= selflen) {\\n            if (needlelen <= 32) {\\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\\n\\n                bytes32 needledata;\\n                assembly {\\n                    needledata := and(mload(needleptr), mask)\\n                }\\n\\n                uint256 end = selfptr + selflen - needlelen;\\n                bytes32 ptrdata;\\n                assembly {\\n                    ptrdata := and(mload(ptr), mask)\\n                }\\n\\n                while (ptrdata != needledata) {\\n                    if (ptr >= end) {\\n                        return selfptr + selflen;\\n                    }\\n                    ptr++;\\n                    assembly {\\n                        ptrdata := and(mload(ptr), mask)\\n                    }\\n                }\\n                return ptr;\\n            } else {\\n                // For long needles, use hashing\\n                bytes32 hash;\\n                assembly {\\n                    hash := keccak256(needleptr, needlelen)\\n                }\\n\\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\\n                    bytes32 testHash;\\n                    assembly {\\n                        testHash := keccak256(ptr, needlelen)\\n                    }\\n                    if (hash == testHash) {\\n                        return ptr;\\n                    }\\n                    ptr += 1;\\n                }\\n            }\\n        }\\n        return selfptr + selflen;\\n    }\\n\\n    /*\\n    * @dev Splits the slice, setting `self` to everything after the first\\n    *      occurrence of `needle`, and `token` to everything before it. If\\n    *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n    *      and `token` is set to the entirety of `self`.\\n    * @param self The slice to split.\\n    * @param needle The text to search for in `self`.\\n    * @param token An output parameter to which the first token is written.\\n    * @return `token`.\\n    */\\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\\n        uint256 ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        token._ptr = self._ptr;\\n        token._len = ptr - self._ptr;\\n        if (ptr == self._ptr + self._len) {\\n            // Not found\\n            self._len = 0;\\n        } else {\\n            self._len -= token._len + needle._len;\\n            self._ptr = ptr + needle._len;\\n        }\\n        return token;\\n    }\\n\\n    /*\\n    * @dev Splits the slice, setting `self` to everything after the first\\n    *      occurrence of `needle`, and returning everything before it. If\\n    *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n    *      and the entirety of `self` is returned.\\n    * @param self The slice to split.\\n    * @param needle The text to search for in `self`.\\n    * @return The part of `self` up to the first occurrence of `delim`.\\n    */\\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\\n        split(self, needle, token);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libs/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\n/// @title Base64\\n/// @notice Provides a function for encoding some bytes in base64\\n/// @author Brecht Devos <brecht@loopring.org>\\nlibrary Base64 {\\n    bytes internal constant TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /// @notice Encodes some bytes to the base64 representation\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        uint256 len = data.length;\\n        if (len == 0) return \\\"\\\";\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((len + 2) / 3);\\n\\n        // Add some extra buffer at the end\\n        bytes memory result = new bytes(encodedLen + 32);\\n\\n        bytes memory table = TABLE;\\n\\n        assembly {\\n            let tablePtr := add(table, 1)\\n            let resultPtr := add(result, 32)\\n\\n            for { let i := 0 } lt(i, len) {} {\\n                i := add(i, 3)\\n                let input := and(mload(add(data, i)), 0xffffff)\\n\\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\\n                out := shl(224, out)\\n\\n                mstore(resultPtr, out)\\n\\n                resultPtr := add(resultPtr, 4)\\n            }\\n\\n            switch mod(len, 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n\\n            mstore(result, encodedLen)\\n        }\\n\\n        return string(result);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/lssvm2/src/bonding-curves/CurveErrorCodes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\ncontract CurveErrorCodes {\\n    enum Error {\\n        OK, // No error\\n        INVALID_NUMITEMS, // The numItem value is 0\\n        SPOT_PRICE_OVERFLOW, // The updated spot price doesn't fit into 128 bits\\n        DELTA_OVERFLOW, // The updated delta doesn't fit into 128 bits\\n        SPOT_PRICE_UNDERFLOW, // The updated spot price goes too low\\n        AUCTION_ENDED // The auction has ended\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/lssvm2/lib/royalty-registry-solidity/contracts/IRoyaltyEngineV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Lookup engine interface\\n */\\ninterface IRoyaltyEngineV1 is IERC165 {\\n    /**\\n     * Get the royalty for a given token (address, id) and value amount.  Does not cache the bps/amounts.  Caches the spec for a given token address\\n     *\\n     * @param tokenAddress - The address of the token\\n     * @param tokenId      - The id of the token\\n     * @param value        - The value you wish to get the royalty of\\n     *\\n     * returns Two arrays of equal length, royalty recipients and the corresponding amount each recipient should get\\n     */\\n    function getRoyalty(address tokenAddress, uint256 tokenId, uint256 value)\\n        external\\n        returns (address payable[] memory recipients, uint256[] memory amounts);\\n\\n    /**\\n     * View only version of getRoyalty\\n     *\\n     * @param tokenAddress - The address of the token\\n     * @param tokenId      - The id of the token\\n     * @param value        - The value you wish to get the royalty of\\n     *\\n     * returns Two arrays of equal length, royalty recipients and the corresponding amount each recipient should get\\n     */\\n    function getRoyaltyView(address tokenAddress, uint256 tokenId, uint256 value)\\n        external\\n        view\\n        returns (address payable[] memory recipients, uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"lib/lssvm2/lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/lssvm2/lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/lssvm2/lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/lssvm2/lib/openzeppelin-contracts/contracts/token/ERC721/utils/ERC721Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721Holder is IERC721Receiver {\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/lssvm2/lib/openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC1155Receiver.sol\\\";\\n\\n/**\\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\\n *\\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\\n * stuck.\\n *\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155Holder is ERC1155Receiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/lssvm2/src/LSSVMRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\n\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\nimport {LSSVMPair} from \\\"./LSSVMPair.sol\\\";\\nimport {ILSSVMPairFactoryLike} from \\\"./ILSSVMPairFactoryLike.sol\\\";\\nimport {CurveErrorCodes} from \\\"./bonding-curves/CurveErrorCodes.sol\\\";\\n\\ncontract LSSVMRouter {\\n    using SafeTransferLib for address payable;\\n    using SafeTransferLib for ERC20;\\n\\n    struct PairSwapSpecific {\\n        LSSVMPair pair;\\n        uint256[] nftIds;\\n    }\\n\\n    struct RobustPairSwapSpecific {\\n        PairSwapSpecific swapInfo;\\n        uint256 maxCost;\\n    }\\n\\n    struct RobustPairSwapSpecificForToken {\\n        PairSwapSpecific swapInfo;\\n        uint256 minOutput;\\n    }\\n\\n    struct NFTsForSpecificNFTsTrade {\\n        PairSwapSpecific[] nftToTokenTrades;\\n        PairSwapSpecific[] tokenToNFTTrades;\\n    }\\n\\n    struct RobustPairNFTsFoTokenAndTokenforNFTsTrade {\\n        RobustPairSwapSpecific[] tokenToNFTTrades;\\n        RobustPairSwapSpecificForToken[] nftToTokenTrades;\\n        uint256 inputAmount;\\n        address payable tokenRecipient;\\n        address nftRecipient;\\n    }\\n\\n    modifier checkDeadline(uint256 deadline) {\\n        _checkDeadline(deadline);\\n        _;\\n    }\\n\\n    ILSSVMPairFactoryLike public immutable factory;\\n\\n    constructor(ILSSVMPairFactoryLike _factory) {\\n        factory = _factory;\\n    }\\n\\n    /**\\n     * ETH swaps\\n     */\\n\\n    /**\\n     * @notice Swaps ETH into specific NFTs using multiple pairs.\\n     * @param swapList The list of pairs to trade with and the IDs of the NFTs to buy from each.\\n     * @param ethRecipient The address that will receive the unspent ETH input\\n     * @param nftRecipient The address that will receive the NFT output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return remainingValue The unspent ETH amount\\n     */\\n    function swapETHForSpecificNFTs(\\n        PairSwapSpecific[] calldata swapList,\\n        address payable ethRecipient,\\n        address nftRecipient,\\n        uint256 deadline\\n    ) external payable checkDeadline(deadline) returns (uint256 remainingValue) {\\n        return _swapETHForSpecificNFTs(swapList, msg.value, ethRecipient, nftRecipient);\\n    }\\n\\n    /**\\n     * @notice Swaps one set of NFTs into another set of specific NFTs using multiple pairs, using\\n     * ETH as the intermediary.\\n     * @param trade The struct containing all NFT-to-ETH swaps and ETH-to-NFT swaps.\\n     * @param minOutput The minimum acceptable total excess ETH received\\n     * @param ethRecipient The address that will receive the ETH output\\n     * @param nftRecipient The address that will receive the NFT output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return outputAmount The total ETH received\\n     */\\n    function swapNFTsForSpecificNFTsThroughETH(\\n        NFTsForSpecificNFTsTrade calldata trade,\\n        uint256 minOutput,\\n        address payable ethRecipient,\\n        address nftRecipient,\\n        uint256 deadline\\n    ) external payable checkDeadline(deadline) returns (uint256 outputAmount) {\\n        // Swap NFTs for ETH\\n        // minOutput of swap set to 0 since we're doing an aggregate slippage check\\n        outputAmount = _swapNFTsForToken(trade.nftToTokenTrades, 0, payable(address(this)));\\n\\n        // Add extra value to buy NFTs\\n        outputAmount += msg.value;\\n\\n        // Swap ETH for specific NFTs\\n        // cost <= inputValue = outputAmount - minOutput, so outputAmount' = (outputAmount - minOutput - cost) + minOutput >= minOutput\\n        outputAmount = _swapETHForSpecificNFTs(\\n            trade.tokenToNFTTrades, outputAmount - minOutput, ethRecipient, nftRecipient\\n        ) + minOutput;\\n    }\\n\\n    /**\\n     * ERC20 swaps\\n     *\\n     * Note: All ERC20 swaps assume that a single ERC20 token is used for all the pairs involved.\\n     * Swapping using multiple tokens in the same transaction is possible, but the slippage checks\\n     * & the return values will be meaningless, and may lead to undefined behavior.\\n     *\\n     * Note: The sender should ideally grant infinite token approval to the router in order for NFT-to-NFT\\n     * swaps to work smoothly.\\n     */\\n\\n    /**\\n     * @notice Swaps ERC20 tokens into specific NFTs using multiple pairs.\\n     * @param swapList The list of pairs to trade with and the IDs of the NFTs to buy from each.\\n     * @param inputAmount The amount of ERC20 tokens to add to the ERC20-to-NFT swaps\\n     * @param nftRecipient The address that will receive the NFT output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return remainingValue The unspent token amount\\n     */\\n    function swapERC20ForSpecificNFTs(\\n        PairSwapSpecific[] calldata swapList,\\n        uint256 inputAmount,\\n        address nftRecipient,\\n        uint256 deadline\\n    ) external checkDeadline(deadline) returns (uint256 remainingValue) {\\n        return _swapERC20ForSpecificNFTs(swapList, inputAmount, nftRecipient);\\n    }\\n\\n    /**\\n     * @notice Swaps NFTs into ETH/ERC20 using multiple pairs.\\n     * @param swapList The list of pairs to trade with and the IDs of the NFTs to sell to each.\\n     * @param minOutput The minimum acceptable total tokens received\\n     * @param tokenRecipient The address that will receive the token output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return outputAmount The total tokens received\\n     */\\n    function swapNFTsForToken(\\n        PairSwapSpecific[] calldata swapList,\\n        uint256 minOutput,\\n        address tokenRecipient,\\n        uint256 deadline\\n    ) external checkDeadline(deadline) returns (uint256 outputAmount) {\\n        return _swapNFTsForToken(swapList, minOutput, payable(tokenRecipient));\\n    }\\n\\n    /**\\n     * @notice Swaps one set of NFTs into another set of specific NFTs using multiple pairs, using\\n     * an ERC20 token as the intermediary.\\n     * @param trade The struct containing all NFT-to-ERC20 swaps and ERC20-to-NFT swaps.\\n     * @param inputAmount The amount of ERC20 tokens to add to the ERC20-to-NFT swaps\\n     * @param minOutput The minimum acceptable total excess tokens received\\n     * @param nftRecipient The address that will receive the NFT output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return outputAmount The total ERC20 tokens received\\n     */\\n    function swapNFTsForSpecificNFTsThroughERC20(\\n        NFTsForSpecificNFTsTrade calldata trade,\\n        uint256 inputAmount,\\n        uint256 minOutput,\\n        address nftRecipient,\\n        uint256 deadline\\n    ) external checkDeadline(deadline) returns (uint256 outputAmount) {\\n        // Swap NFTs for ERC20\\n        // minOutput of swap set to 0 since we're doing an aggregate slippage check\\n        // output tokens are sent to msg.sender\\n        outputAmount = _swapNFTsForToken(trade.nftToTokenTrades, 0, payable(msg.sender));\\n\\n        // Add extra value to buy NFTs\\n        outputAmount += inputAmount;\\n\\n        // Swap ERC20 for specific NFTs\\n        // cost <= maxCost = outputAmount - minOutput, so outputAmount' = outputAmount - cost >= minOutput\\n        // input tokens are taken directly from msg.sender\\n        outputAmount =\\n            _swapERC20ForSpecificNFTs(trade.tokenToNFTTrades, outputAmount - minOutput, nftRecipient) + minOutput;\\n    }\\n\\n    /**\\n     * Robust Swaps\\n     * These are \\\"robust\\\" versions of the NFT<>Token swap functions which will never revert due to slippage\\n     * Instead, users specify a per-swap max cost. If the price changes more than the user specifies, no swap is attempted. This allows users to specify a batch of swaps, and execute as many of them as possible.\\n     */\\n\\n    /**\\n     * @dev Ensure msg.value >= sum of values in maxCostPerPair to make sure the transaction doesn't revert\\n     * @param swapList The list of pairs to trade with and the IDs of the NFTs to buy from each.\\n     * @param ethRecipient The address that will receive the unspent ETH input\\n     * @param nftRecipient The address that will receive the NFT output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return remainingValue The unspent token amount\\n     */\\n    function robustSwapETHForSpecificNFTs(\\n        RobustPairSwapSpecific[] calldata swapList,\\n        address payable ethRecipient,\\n        address nftRecipient,\\n        uint256 deadline\\n    ) public payable virtual checkDeadline(deadline) returns (uint256 remainingValue) {\\n        remainingValue = msg.value;\\n        uint256 pairCost;\\n        CurveErrorCodes.Error error;\\n\\n        // Try doing each swap\\n        uint256 numSwaps = swapList.length;\\n        for (uint256 i; i < numSwaps;) {\\n            // Calculate actual cost per swap\\n            (error,,, pairCost,,) = swapList[i].swapInfo.pair.getBuyNFTQuote(\\n                swapList[i].swapInfo.nftIds[0], swapList[i].swapInfo.nftIds.length\\n            );\\n\\n            // If within our maxCost and no error, proceed\\n            if (pairCost <= swapList[i].maxCost && error == CurveErrorCodes.Error.OK) {\\n                // We know how much ETH to send because we already did the math above\\n                // So we just send that much\\n                remainingValue -= swapList[i].swapInfo.pair.swapTokenForSpecificNFTs{value: pairCost}(\\n                    swapList[i].swapInfo.nftIds, pairCost, nftRecipient, true, msg.sender\\n                );\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Return remaining value to sender\\n        if (remainingValue > 0) {\\n            ethRecipient.safeTransferETH(remainingValue);\\n        }\\n    }\\n\\n    /**\\n     * @notice Swaps as many ERC20 tokens for specific NFTs as possible, respecting the per-swap max cost.\\n     * @param swapList The list of pairs to trade with and the IDs of the NFTs to buy from each.\\n     * @param inputAmount The amount of ERC20 tokens to add to the ERC20-to-NFT swaps\\n     * @param nftRecipient The address that will receive the NFT output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return remainingValue The unspent token amount\\n     */\\n    function robustSwapERC20ForSpecificNFTs(\\n        RobustPairSwapSpecific[] calldata swapList,\\n        uint256 inputAmount,\\n        address nftRecipient,\\n        uint256 deadline\\n    ) public virtual checkDeadline(deadline) returns (uint256 remainingValue) {\\n        remainingValue = inputAmount;\\n        uint256 pairCost;\\n        CurveErrorCodes.Error error;\\n\\n        // Try doing each swap\\n        uint256 numSwaps = swapList.length;\\n        for (uint256 i; i < numSwaps;) {\\n            // Calculate actual cost per swap\\n            (error,,, pairCost,,) = swapList[i].swapInfo.pair.getBuyNFTQuote(\\n                swapList[i].swapInfo.nftIds[0], swapList[i].swapInfo.nftIds.length\\n            );\\n\\n            // If within our maxCost and no error, proceed\\n            if (pairCost <= swapList[i].maxCost && error == CurveErrorCodes.Error.OK) {\\n                remainingValue -= swapList[i].swapInfo.pair.swapTokenForSpecificNFTs(\\n                    swapList[i].swapInfo.nftIds, pairCost, nftRecipient, true, msg.sender\\n                );\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Swaps as many NFTs for tokens as possible, respecting the per-swap min output\\n     * @param swapList The list of pairs to trade with and the IDs of the NFTs to sell to each.\\n     * @param tokenRecipient The address that will receive the token output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return outputAmount The total ETH/ERC20 received\\n     */\\n    function robustSwapNFTsForToken(\\n        RobustPairSwapSpecificForToken[] calldata swapList,\\n        address payable tokenRecipient,\\n        uint256 deadline\\n    ) public virtual checkDeadline(deadline) returns (uint256 outputAmount) {\\n        // Try doing each swap\\n        uint256 numSwaps = swapList.length;\\n        for (uint256 i; i < numSwaps;) {\\n            uint256 pairOutput;\\n\\n            // Locally scoped to avoid stack too deep error\\n            {\\n                CurveErrorCodes.Error error;\\n                uint256[] memory nftIds = swapList[i].swapInfo.nftIds;\\n                if (nftIds.length == 0) {\\n                    unchecked {\\n                        ++i;\\n                    }\\n                    continue;\\n                }\\n                (error,,, pairOutput,,) = swapList[i].swapInfo.pair.getSellNFTQuote(nftIds[0], nftIds.length);\\n                if (error != CurveErrorCodes.Error.OK) {\\n                    unchecked {\\n                        ++i;\\n                    }\\n                    continue;\\n                }\\n            }\\n\\n            // If at least equal to our minOutput, proceed\\n            if (pairOutput >= swapList[i].minOutput) {\\n                // Do the swap and update outputAmount with how many tokens we got\\n                outputAmount += swapList[i].swapInfo.pair.swapNFTsForToken(\\n                    swapList[i].swapInfo.nftIds, 0, tokenRecipient, true, msg.sender\\n                );\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Buys NFTs with ETH and sells them for tokens in one transaction\\n     * @param params All the parameters for the swap (packed in struct to avoid stack too deep), containing:\\n     * - ethToNFTSwapList The list of NFTs to buy\\n     * - nftToTokenSwapList The list of NFTs to sell\\n     * - inputAmount The max amount of tokens to send (if ERC20)\\n     * - tokenRecipient The address that receives tokens from the NFTs sold\\n     * - nftRecipient The address that receives NFTs\\n     * - deadline UNIX timestamp deadline for the swap\\n     */\\n    function robustSwapETHForSpecificNFTsAndNFTsToToken(RobustPairNFTsFoTokenAndTokenforNFTsTrade calldata params)\\n        external\\n        payable\\n        virtual\\n        returns (uint256 remainingValue, uint256 outputAmount)\\n    {\\n        {\\n            remainingValue = msg.value;\\n            uint256 pairCost;\\n            CurveErrorCodes.Error error;\\n\\n            // Try doing each swap\\n            uint256 numSwaps = params.tokenToNFTTrades.length;\\n            for (uint256 i; i < numSwaps;) {\\n                // Calculate actual cost per swap\\n                (error,,, pairCost,,) = params.tokenToNFTTrades[i].swapInfo.pair.getBuyNFTQuote(\\n                    params.tokenToNFTTrades[i].swapInfo.nftIds[0], params.tokenToNFTTrades[i].swapInfo.nftIds.length\\n                );\\n\\n                // If within our maxCost and no error, proceed\\n                if (pairCost <= params.tokenToNFTTrades[i].maxCost && error == CurveErrorCodes.Error.OK) {\\n                    // We know how much ETH to send because we already did the math above\\n                    // So we just send that much\\n                    remainingValue -= params.tokenToNFTTrades[i].swapInfo.pair.swapTokenForSpecificNFTs{value: pairCost}(\\n                        params.tokenToNFTTrades[i].swapInfo.nftIds, pairCost, params.nftRecipient, true, msg.sender\\n                    );\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n\\n            // Return remaining value to sender\\n            if (remainingValue > 0) {\\n                params.tokenRecipient.safeTransferETH(remainingValue);\\n            }\\n        }\\n        {\\n            // Try doing each swap\\n            uint256 numSwaps = params.nftToTokenTrades.length;\\n            for (uint256 i; i < numSwaps;) {\\n                uint256 pairOutput;\\n\\n                // Locally scoped to avoid stack too deep error\\n                {\\n                    CurveErrorCodes.Error error;\\n                    uint256 assetId = params.nftToTokenTrades[i].swapInfo.nftIds[0];\\n                    (error,,, pairOutput,,) = params.nftToTokenTrades[i].swapInfo.pair.getSellNFTQuote(\\n                        assetId, params.nftToTokenTrades[i].swapInfo.nftIds.length\\n                    );\\n                    if (error != CurveErrorCodes.Error.OK) {\\n                        unchecked {\\n                            ++i;\\n                        }\\n                        continue;\\n                    }\\n                }\\n\\n                // If at least equal to our minOutput, proceed\\n                if (pairOutput >= params.nftToTokenTrades[i].minOutput) {\\n                    // Do the swap and update outputAmount with how many tokens we got\\n                    outputAmount += params.nftToTokenTrades[i].swapInfo.pair.swapNFTsForToken(\\n                        params.nftToTokenTrades[i].swapInfo.nftIds, 0, params.tokenRecipient, true, msg.sender\\n                    );\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Buys NFTs with ERC20, and sells them for tokens in one transaction\\n     * @param params All the parameters for the swap (packed in struct to avoid stack too deep), containing:\\n     * - ethToNFTSwapList The list of NFTs to buy\\n     * - nftToTokenSwapList The list of NFTs to sell\\n     * - inputAmount The max amount of tokens to send (if ERC20)\\n     * - tokenRecipient The address that receives tokens from the NFTs sold\\n     * - nftRecipient The address that receives NFTs\\n     * - deadline UNIX timestamp deadline for the swap\\n     */\\n    function robustSwapERC20ForSpecificNFTsAndNFTsToToken(RobustPairNFTsFoTokenAndTokenforNFTsTrade calldata params)\\n        external\\n        virtual\\n        returns (uint256 remainingValue, uint256 outputAmount)\\n    {\\n        {\\n            remainingValue = params.inputAmount;\\n            uint256 pairCost;\\n            CurveErrorCodes.Error error;\\n\\n            // Try doing each swap\\n            uint256 numSwaps = params.tokenToNFTTrades.length;\\n            for (uint256 i; i < numSwaps;) {\\n                // Calculate actual cost per swap\\n                (error,,, pairCost,,) = params.tokenToNFTTrades[i].swapInfo.pair.getBuyNFTQuote(\\n                    params.tokenToNFTTrades[i].swapInfo.nftIds[0], params.tokenToNFTTrades[i].swapInfo.nftIds.length\\n                );\\n\\n                // If within our maxCost and no error, proceed\\n                if (pairCost <= params.tokenToNFTTrades[i].maxCost && error == CurveErrorCodes.Error.OK) {\\n                    remainingValue -= params.tokenToNFTTrades[i].swapInfo.pair.swapTokenForSpecificNFTs(\\n                        params.tokenToNFTTrades[i].swapInfo.nftIds, pairCost, params.nftRecipient, true, msg.sender\\n                    );\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n        {\\n            // Try doing each swap\\n            uint256 numSwaps = params.nftToTokenTrades.length;\\n            for (uint256 i; i < numSwaps;) {\\n                uint256 pairOutput;\\n\\n                // Locally scoped to avoid stack too deep error\\n                {\\n                    CurveErrorCodes.Error error;\\n                    uint256 assetId = params.nftToTokenTrades[i].swapInfo.nftIds[0];\\n                    (error,,, pairOutput,,) = params.nftToTokenTrades[i].swapInfo.pair.getSellNFTQuote(\\n                        assetId, params.nftToTokenTrades[i].swapInfo.nftIds.length\\n                    );\\n                    if (error != CurveErrorCodes.Error.OK) {\\n                        unchecked {\\n                            ++i;\\n                        }\\n                        continue;\\n                    }\\n                }\\n\\n                // If at least equal to our minOutput, proceed\\n                if (pairOutput >= params.nftToTokenTrades[i].minOutput) {\\n                    // Do the swap and update outputAmount with how many tokens we got\\n                    outputAmount += params.nftToTokenTrades[i].swapInfo.pair.swapNFTsForToken(\\n                        params.nftToTokenTrades[i].swapInfo.nftIds, 0, params.tokenRecipient, true, msg.sender\\n                    );\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n    }\\n\\n    receive() external payable {}\\n\\n    /**\\n     * Restricted functions\\n     */\\n\\n    /**\\n     * @dev Allows an ERC20 pair contract to transfer ERC20 tokens directly from\\n     * the sender, in order to minimize the number of token transfers. Only callable by an ERC20 pair.\\n     * @param token The ERC20 token to transfer\\n     * @param from The address to transfer tokens from\\n     * @param to The address to transfer tokens to\\n     * @param amount The amount of tokens to transfer\\n     */\\n    function pairTransferERC20From(ERC20 token, address from, address to, uint256 amount) external {\\n        // verify caller is a trusted pair contract\\n        require(factory.isValidPair(msg.sender), \\\"Not pair\\\");\\n        // verify caller is an ERC20 pair\\n        require(factory.getPairTokenType(msg.sender) == ILSSVMPairFactoryLike.PairTokenType.ERC20, \\\"Not ERC20 pair\\\");\\n\\n        // transfer tokens to pair\\n        token.safeTransferFrom(from, to, amount);\\n    }\\n\\n    /**\\n     * @dev Allows a pair contract to transfer ERC721 NFTs directly from\\n     * the sender, in order to minimize the number of token transfers. Only callable by a pair.\\n     * @param nft The ERC721 NFT to transfer\\n     * @param from The address to transfer tokens from\\n     * @param to The address to transfer tokens to\\n     * @param id The ID of the NFT to transfer\\n     */\\n    function pairTransferNFTFrom(IERC721 nft, address from, address to, uint256 id) external {\\n        // verify caller is a trusted pair contract\\n        require(factory.isValidPair(msg.sender), \\\"Not pair\\\");\\n\\n        // transfer NFTs to pair\\n        nft.transferFrom(from, to, id);\\n    }\\n\\n    function pairTransferERC1155From(\\n        IERC1155 nft,\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        // verify caller is a trusted pair contract\\n        require(factory.isValidPair(msg.sender), \\\"Not pair\\\");\\n\\n        nft.safeBatchTransferFrom(from, to, ids, amounts, bytes(\\\"\\\"));\\n    }\\n\\n    /**\\n     * Internal functions\\n     */\\n\\n    /**\\n     * @param deadline The last valid time for a swap\\n     */\\n    function _checkDeadline(uint256 deadline) internal view {\\n        require(block.timestamp <= deadline, \\\"Deadline passed\\\");\\n    }\\n\\n    /**\\n     * @notice Internal function used to swap ETH for a specific set of NFTs\\n     * @param swapList The list of pairs and swap calldata\\n     * @param inputAmount The total amount of ETH to send\\n     * @param ethRecipient The address receiving excess ETH\\n     * @param nftRecipient The address receiving the NFTs from the pairs\\n     * @return remainingValue The unspent token amount\\n     */\\n    function _swapETHForSpecificNFTs(\\n        PairSwapSpecific[] calldata swapList,\\n        uint256 inputAmount,\\n        address payable ethRecipient,\\n        address nftRecipient\\n    ) internal virtual returns (uint256 remainingValue) {\\n        remainingValue = inputAmount;\\n\\n        uint256 pairCost;\\n        CurveErrorCodes.Error error;\\n\\n        // Do swaps\\n        uint256 numSwaps = swapList.length;\\n        for (uint256 i; i < numSwaps;) {\\n            // Calculate the cost per swap first to send exact amount of ETH over, saves gas by avoiding the need to send back excess ETH\\n            (error,,, pairCost,,) = swapList[i].pair.getBuyNFTQuote(swapList[i].nftIds[0], swapList[i].nftIds.length);\\n\\n            // Require no errors\\n            require(error == CurveErrorCodes.Error.OK, \\\"Bonding curve error\\\");\\n\\n            // Total ETH taken from sender cannot exceed inputAmount\\n            // because otherwise the deduction from remainingValue will fail\\n            remainingValue -= swapList[i].pair.swapTokenForSpecificNFTs{value: pairCost}(\\n                swapList[i].nftIds, remainingValue, nftRecipient, true, msg.sender\\n            );\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Return remaining value to sender\\n        if (remainingValue > 0) {\\n            ethRecipient.safeTransferETH(remainingValue);\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function used to swap an ERC20 token for specific NFTs\\n     * @dev Note that we don't need to query the pair's bonding curve first for pricing data because\\n     * we just calculate and take the required amount from the caller during swap time.\\n     * However, we can't \\\"pull\\\" ETH, which is why for the ETH->NFT swaps, we need to calculate the pricing info\\n     * to figure out how much the router should send to the pool.\\n     * @param swapList The list of pairs and swap calldata\\n     * @param inputAmount The total amount of ERC20 tokens to send\\n     * @param nftRecipient The address receiving the NFTs from the pairs\\n     * @return remainingValue The unspent token amount\\n     */\\n    function _swapERC20ForSpecificNFTs(PairSwapSpecific[] calldata swapList, uint256 inputAmount, address nftRecipient)\\n        internal\\n        virtual\\n        returns (uint256 remainingValue)\\n    {\\n        remainingValue = inputAmount;\\n\\n        // Do swaps\\n        uint256 numSwaps = swapList.length;\\n        for (uint256 i; i < numSwaps;) {\\n            // Tokens are transferred in by the pair calling router.pairTransferERC20From\\n            // Total tokens taken from sender cannot exceed inputAmount\\n            // because otherwise the deduction from remainingValue will fail\\n            remainingValue -= swapList[i].pair.swapTokenForSpecificNFTs(\\n                swapList[i].nftIds, remainingValue, nftRecipient, true, msg.sender\\n            );\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Swaps NFTs for tokens, designed to be used for 1 token at a time\\n     * @dev Calling with multiple tokens is permitted, BUT minOutput will be\\n     * far from enough of a safety check because different tokens almost certainly have different unit prices.\\n     * @param swapList The list of pairs and swap calldata\\n     * @param minOutput The minimum number of tokens to be receieved from the swaps\\n     * @param tokenRecipient The address that receives the tokens\\n     * @return outputAmount The number of tokens to be received\\n     */\\n    function _swapNFTsForToken(PairSwapSpecific[] calldata swapList, uint256 minOutput, address payable tokenRecipient)\\n        internal\\n        virtual\\n        returns (uint256 outputAmount)\\n    {\\n        // Do swaps\\n        uint256 numSwaps = swapList.length;\\n        for (uint256 i; i < numSwaps;) {\\n            // Do the swap for token and then update outputAmount\\n            // Note: minExpectedTokenOutput is set to 0 since we're doing an aggregate slippage check below\\n            outputAmount += swapList[i].pair.swapNFTsForToken(swapList[i].nftIds, 0, tokenRecipient, true, msg.sender);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Aggregate slippage check\\n        require(outputAmount >= minOutput, \\\"outputAmount too low\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/lssvm2/src/ILSSVMPairFactoryLike.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {LSSVMRouter} from \\\"./LSSVMRouter.sol\\\";\\n\\ninterface ILSSVMPairFactoryLike {\\n    struct Settings {\\n        uint96 bps;\\n        address pairAddress;\\n    }\\n\\n    enum PairNFTType {\\n        ERC721,\\n        ERC1155\\n    }\\n\\n    enum PairTokenType {\\n        ETH,\\n        ERC20\\n    }\\n\\n    enum PairVariant {\\n        ERC721_ETH,\\n        ERC721_ERC20,\\n        ERC1155_ETH,\\n        ERC1155_ERC20\\n    }\\n\\n    function protocolFeeMultiplier() external view returns (uint256);\\n\\n    function protocolFeeRecipient() external view returns (address payable);\\n\\n    function callAllowed(address target) external view returns (bool);\\n\\n    function authAllowedForToken(address tokenAddress, address proposedAuthAddress) external view returns (bool);\\n\\n    function getSettingsForPair(address pairAddress) external view returns (bool settingsEnabled, uint96 bps);\\n\\n    function enableSettingsForPair(address settings, address pairAddress) external;\\n\\n    function disableSettingsForPair(address settings, address pairAddress) external;\\n\\n    function routerStatus(LSSVMRouter router) external view returns (bool allowed, bool wasEverTouched);\\n\\n    function isValidPair(address pairAddress) external view returns (bool);\\n\\n    function getPairNFTType(address pairAddress) external pure returns (PairNFTType);\\n\\n    function getPairTokenType(address pairAddress) external pure returns (PairTokenType);\\n\\n    function openLock() external;\\n\\n    function closeLock() external;\\n}\\n\"\r\n    },\r\n    \"lib/lssvm2/src/lib/IOwnershipTransferReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.4;\\n\\ninterface IOwnershipTransferReceiver {\\n    function onOwnershipTransferred(address oldOwner, bytes memory data) external payable;\\n}\\n\"\r\n    },\r\n    \"lib/lssvm2/src/lib/OwnableWithTransferCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.4;\\n\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {ERC165Checker} from \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\n\\nimport {IOwnershipTransferReceiver} from \\\"./IOwnershipTransferReceiver.sol\\\";\\n\\nabstract contract OwnableWithTransferCallback {\\n    using ERC165Checker for address;\\n    using Address for address;\\n\\n    bytes4 constant TRANSFER_CALLBACK = type(IOwnershipTransferReceiver).interfaceId;\\n\\n    error Ownable_NotOwner();\\n    error Ownable_NewOwnerZeroAddress();\\n\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init(address initialOwner) internal {\\n        _owner = initialOwner;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        if (owner() != msg.sender) revert Ownable_NotOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * @param newOwner The new address to become owner\\n     * @param data Any additional data to send to the ownership received callback.\\n     * Disallows setting to the zero address as a way to more gas-efficiently avoid reinitialization.\\n     * When ownership is transferred, if the new owner implements IOwnershipTransferCallback, we make a callback.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner, bytes calldata data) public payable virtual onlyOwner {\\n        if (newOwner == address(0)) revert Ownable_NewOwnerZeroAddress();\\n        _transferOwnership(newOwner);\\n\\n        if (newOwner.isContract()) {\\n            try IOwnershipTransferReceiver(newOwner).onOwnershipTransferred{value: msg.value}(msg.sender, data) {}\\n            // If revert...\\n            catch (bytes memory reason) {\\n                // If we just transferred to a contract w/ no callback, this is fine\\n                if (reason.length == 0) {\\n                    // i.e., no need to revert\\n                }\\n                // Otherwise, the callback had an error, and we should revert\\n                else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\\n     * @dev Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        _owner = newOwner;\\n        emit OwnershipTransferred(newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/lssvm2/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/lssvm2/lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"lib/lssvm2/lib/openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Receiver.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/lssvm2/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165Checker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface.\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\\n        internal\\n        view\\n        returns (bool[] memory)\\n    {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success && returnSize >= 0x20 && returnValue > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/lssvm2/lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"lib/lssvm2/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@manifoldxyz/=lib/lssvm2/lib/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/lssvm2/lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/lssvm2/lib/openzeppelin-contracts/contracts/\",\r\n      \"@prb/math/=lib/lssvm2/lib/prb-math/src/\",\r\n      \"clones-with-immutable-args/=lib/lssvm2/lib/clones-with-immutable-args/src/\",\r\n      \"create2-helpers/=lib/lssvm2/lib/royalty-registry-solidity/lib/create2-helpers/\",\r\n      \"create3-factory/=lib/lssvm2/lib/create3-factory/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"foundry-huff/=lib/lssvm2/lib/foundry-huff/src/\",\r\n      \"huffmate/=lib/lssvm2/lib/huffmate/src/\",\r\n      \"libraries-solidity/=lib/lssvm2/lib/libraries-solidity/contracts/\",\r\n      \"lssvm2/=lib/lssvm2/src/\",\r\n      \"manifoldxyz/=lib/lssvm2/lib/royalty-registry-solidity/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/lssvm2/lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"prb-math/=lib/lssvm2/lib/prb-math/src/\",\r\n      \"prb-test/=lib/lssvm2/lib/prb-math/lib/prb-test/src/\",\r\n      \"royalty-registry-solidity/=lib/lssvm2/lib/royalty-registry-solidity/\",\r\n      \"solady/=lib/solady/\",\r\n      \"solidity-stringutils/=lib/lssvm2/lib/foundry-huff/lib/solidity-stringutils/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"stringutils/=lib/lssvm2/lib/foundry-huff/lib/solidity-stringutils/\",\r\n      \"zipped-contracts/=lib/zipped-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mons\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_markov\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gda\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_xmon\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_linear\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Akoless\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Cooldown\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Monless\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoYeet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Scarce\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauth\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongFrom\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRoyalty\",\"type\":\"uint256\"}],\"name\":\"NewRoyalty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RoyaltiesClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MARKOV\",\"outputs\":[{\"internalType\":\"contract IMarkov\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROYALTY_HANDER\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"royaltyToken\",\"type\":\"address\"}],\"name\":\"accumulateRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"newRoyalty\",\"type\":\"uint96\"}],\"name\":\"adjustRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"royaltyToken\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"claimRoyalties\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"royaltiesReceived\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getMagic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"}],\"name\":\"getName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"idsForAddress\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initPools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"gdaPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tradePool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"markovSeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOfWithData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"lastTransferTimestamp\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"}],\"name\":\"recast\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"royaltyToken\",\"type\":\"address\"}],\"name\":\"royaltiesAccrued\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"royaltyPerId\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"royaltyAccumulatedPerTokenType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"royaltyClaimedPerId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"tap_to_summon_akolytes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"yeet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Akolytes", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000427743df720801825a5c82e0582b1e915e0f750000000000000000000000000a020d57ab0448ef74115c112d18a9c231cc860000000000000000000000000002a7021d9a7cd3a13b00fb01a5b5dead63705676d0000000000000000000000001fd5876d4a3860eb0159055a3b7cb79fdfff6b670000000000000000000000003aada3e213abf8529606924d8d1c55cbdc70bf74000000000000000000000000e5d78fec1a7f42d2f3620238c498f088a866fdc5", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}