{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/UrulokiDex.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n// Uruloki DEX is NOT LICENSED FOR COPYING.\\r\\n// Uruloki DEX (C) 2022. All Rights Reserved.\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\n\\r\\ninterface IUniswapV2Router {\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n\\r\\n    function getAmountsOut(\\r\\n        uint amountIn,\\r\\n        address[] calldata path\\r\\n    ) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IOrderMgr {\\r\\n    //// Define enums\\r\\n    enum OrderType {\\r\\n        TargetPrice,\\r\\n        PriceRange\\r\\n    }\\r\\n    enum OrderStatus {\\r\\n        Active,\\r\\n        Cancelled,\\r\\n        OutOfFunds,\\r\\n        Completed\\r\\n    }\\r\\n\\r\\n    //// Define structs\\r\\n    // One time order, it's a base order struct\\r\\n    struct OrderBase {\\r\\n        address userAddress;\\r\\n        address pairedTokenAddress;\\r\\n        address tokenAddress;\\r\\n        OrderType orderType;\\r\\n        uint256 targetPrice;\\r\\n        bool isBuy;\\r\\n        uint256 maxPrice;\\r\\n        uint256 minPrice;\\r\\n        OrderStatus status;\\r\\n        uint256 amount;\\r\\n        uint256 predictionAmount;\\r\\n        bool isContinuous;\\r\\n    }\\r\\n\\r\\n    // Continuous Order, it's an extended order struct, including the base order struct\\r\\n    struct Order {\\r\\n        OrderBase orderBase;\\r\\n        uint256 numExecutions;\\r\\n        uint256 resetPercentage;\\r\\n        bool hasPriceReset;\\r\\n    }\\r\\n\\r\\n    function createOneTimeOrder(\\r\\n        address userAddress,\\r\\n        address pairedTokenAddress,\\r\\n        address tokenAddress,\\r\\n        bool isBuy,\\r\\n        uint256 targetPrice,\\r\\n        uint256 minPrice,\\r\\n        uint256 maxPrice,\\r\\n        uint256 amount,\\r\\n        uint256 predictionAmount\\r\\n    ) external returns (uint256);\\r\\n\\r\\n    function createContinuousOrder(\\r\\n        address userAddress,\\r\\n        address pairedTokenAddress,\\r\\n        address tokenAddress,\\r\\n        bool isBuy,\\r\\n        uint256 targetPrice,\\r\\n        uint256 minPrice,\\r\\n        uint256 maxPrice,\\r\\n        uint256 amount,\\r\\n        uint256 predictionAmount,\\r\\n        uint256 resetPercentage\\r\\n    ) external returns (uint256);\\r\\n\\r\\n    function updateOrder(\\r\\n        uint256 orderId,\\r\\n        address pairedTokenAddress,\\r\\n        address tokenAddress,\\r\\n        bool isBuy,\\r\\n        uint256 targetPrice,\\r\\n        uint256 minPrice,\\r\\n        uint256 maxPrice,\\r\\n        uint256 amount,\\r\\n        uint256 predictionAmount,\\r\\n        uint256 resetPercentage\\r\\n    ) external;\\r\\n\\r\\n    function cancelOrder(uint256 orderId) external returns (uint256);\\r\\n\\r\\n    function orderCounter() external view returns (uint256);\\r\\n\\r\\n    function getOrder(uint256 orderId) external view returns (Order memory);\\r\\n\\r\\n    function setOrderStatus(\\r\\n        uint256 orderId,\\r\\n        IOrderMgr.OrderStatus status\\r\\n    ) external;\\r\\n\\r\\n    function incNumExecutions(uint256 orderId) external;\\r\\n\\r\\n    function setHasPriceReset(uint256 orderId, bool flag) external;\\r\\n}\\r\\n\\r\\ninterface IERC20Ext is IERC20 {\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\\r\\ncontract UrulokiDEX is ReentrancyGuard {\\r\\n    //// Define events\\r\\n    event OneTimeOrderCreated(uint256 orderId);\\r\\n    event ContinuousOrderCreated(uint256 orderId);\\r\\n    event OneTimeOrderEdited(uint256 orderId);\\r\\n    event ContinuousOrderEdited(uint256 orderId);\\r\\n    event OrderCanceled(uint256 orderId);\\r\\n    event ExecutedOutOfPrice(uint256 orderId, bool isBuy, uint256 price);\\r\\n    event ExecutedOneTimeOrder(\\r\\n        uint256 orderId,\\r\\n        bool isBuy,\\r\\n        uint256 pairAmount,\\r\\n        uint256 tokenAmount,\\r\\n        uint256 price\\r\\n    );\\r\\n    event ExecutedContinuousOrder(\\r\\n        uint256 orderId,\\r\\n        bool isBuy,\\r\\n        uint256 price\\r\\n    );\\r\\n    event FundsWithdrawn(\\r\\n        address userAddress,\\r\\n        address tokenAddress,\\r\\n        uint256 amount\\r\\n    );\\r\\n    event BackendOwner(address newOwner);\\r\\n    event OutOfFunds(uint256 orderId);\\r\\n    event SwapFailed(uint256 orderId);\\r\\n\\r\\n    //// Define constants\\r\\n    address private constant UNISWAP_V2_ROUTER =\\r\\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\r\\n\\r\\n    //// Define variables\\r\\n    mapping(address => mapping(address => uint256)) public balances;\\r\\n\\r\\n    IUniswapV2Router private uniswapRouter =\\r\\n        IUniswapV2Router(UNISWAP_V2_ROUTER);\\r\\n\\r\\n    address public backend_owner;\\r\\n    address public orderMgrAddress;\\r\\n    IOrderMgr _orderMgr;\\r\\n\\r\\n    constructor() {\\r\\n        backend_owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    modifier initOneTimeOrderBalance (\\r\\n        uint256 orderId\\r\\n    ) {\\r\\n        IOrderMgr.Order memory order = _orderMgr.getOrder(orderId);\\r\\n\\r\\n        // Validate order owner\\r\\n        require(\\r\\n            order.orderBase.userAddress == msg.sender,\\r\\n            \\\"msg.sender is not order owner\\\"\\r\\n        );\\r\\n\\r\\n        // Is continous order\\r\\n        require(order.orderBase.isContinuous == false, \\\"Incorrect order type\\\");\\r\\n        require(order.orderBase.status == IOrderMgr.OrderStatus.Active, \\\"Incorrect order status\\\");\\r\\n\\r\\n        if (!order.orderBase.isContinuous)\\r\\n            if(!order.orderBase.isBuy) {\\r\\n                balances[msg.sender][order.orderBase.tokenAddress] += order.orderBase.amount;\\r\\n            } else {\\r\\n                balances[msg.sender][order.orderBase.pairedTokenAddress] += order.orderBase.amount;\\r\\n            }\\r\\n\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function validateOneTimeOrder(\\r\\n        address pairedTokenAddress,\\r\\n        address tokenAddress,\\r\\n        bool isBuy,\\r\\n        uint256 amount\\r\\n    ) internal returns (bool) {\\r\\n        // if buying token, pair token is spendable else if sell, the token is spendable\\r\\n        if (!isBuy) {\\r\\n            // Check if the user has enough balance\\r\\n            if(balances[msg.sender][tokenAddress] >= amount) {\\r\\n                // Update the user's balance\\r\\n                balances[msg.sender][tokenAddress] -= amount;\\r\\n            } else \\r\\n                return false;\\r\\n        } else {\\r\\n            // Check if the user has enough balance\\r\\n            if(balances[msg.sender][pairedTokenAddress] >= amount) {\\r\\n                // Update the user's balance\\r\\n                balances[msg.sender][pairedTokenAddress] -= amount;\\r\\n            } else \\r\\n                return false;\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // set backend owner address\\r\\n    function setBackendOwner(address new_owner) public {\\r\\n        require(msg.sender == backend_owner, \\\"Not admin\\\");\\r\\n        backend_owner = new_owner;\\r\\n        emit BackendOwner(backend_owner);\\r\\n    }\\r\\n\\r\\n    function setOrderMgr(address _orderMgrAddress) public {\\r\\n        require(msg.sender == backend_owner, \\\"setOrderMgr: not allowed\\\");\\r\\n        require(\\r\\n            _orderMgrAddress != address(0),\\r\\n            \\\"setOrderMgr: invalid orderMgrAddress\\\"\\r\\n        );\\r\\n        orderMgrAddress = _orderMgrAddress;\\r\\n        _orderMgr = IOrderMgr(_orderMgrAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice allows users to make a deposit\\r\\n     * @dev token should be transferred from the user wallet to the contract\\r\\n     * @param tokenAddress token address\\r\\n     * @param amount deposit amount\\r\\n     */\\r\\n    function addFunds(\\r\\n        address tokenAddress,\\r\\n        uint256 amount\\r\\n    ) external nonReentrant {\\r\\n        require(amount > 0, \\\"Amount must be greater than zero\\\");\\r\\n\\r\\n        IERC20 token = IERC20(tokenAddress);\\r\\n        uint256 balanceBefore = token.balanceOf(address(this));\\r\\n\\r\\n        require(\\r\\n            token.transferFrom(msg.sender, address(this), amount),\\r\\n            \\\"Transfer failed\\\"\\r\\n        );\\r\\n\\r\\n        // Update the user's balance\\r\\n        balances[msg.sender][tokenAddress] += token.balanceOf(address(this)) - balanceBefore;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev funds withdrawal external call\\r\\n     * @param tokenAddress token address\\r\\n     * @param amount token amount\\r\\n     */\\r\\n    function withdrawFunds(\\r\\n        address tokenAddress,\\r\\n        uint256 amount\\r\\n    ) external nonReentrant {\\r\\n        require(amount > 0, \\\"Amount must be greater than zero\\\");\\r\\n\\r\\n        // Check if the user has enough balance to withdraw\\r\\n        require(\\r\\n            balances[msg.sender][tokenAddress] >= amount,\\r\\n            \\\"Insufficient balance\\\"\\r\\n        );\\r\\n\\r\\n        // Update the user's balance\\r\\n        balances[msg.sender][tokenAddress] -= amount;\\r\\n\\r\\n        // Transfer ERC20 token to the user\\r\\n        IERC20 token = IERC20(tokenAddress);\\r\\n        require(token.transfer(msg.sender, amount), \\\"Transfer failed\\\");\\r\\n        // Emit event\\r\\n        emit FundsWithdrawn(msg.sender, tokenAddress, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice create non-continuous price range order\\r\\n     * @param pairedTokenAddress pair address\\r\\n     * @param tokenAddress token address\\r\\n     * @param isBuy buy or sell\\r\\n     * @param minPrice minimum price\\r\\n     * @param maxPrice maximum price\\r\\n     * @param amount token amount\\r\\n     * @param predictionAmount predictionAmount\\r\\n     */\\r\\n    function createNonContinuousPriceRangeOrder(\\r\\n        address pairedTokenAddress,\\r\\n        address tokenAddress,\\r\\n        bool isBuy,\\r\\n        uint256 minPrice,\\r\\n        uint256 maxPrice,\\r\\n        uint256 amount,\\r\\n        uint256 predictionAmount\\r\\n    )   external nonReentrant {\\r\\n        require(validateOneTimeOrder(pairedTokenAddress, tokenAddress, isBuy, amount), \\\"Validation failed\\\");\\r\\n\\r\\n        uint256 id = _orderMgr.createOneTimeOrder(\\r\\n            msg.sender,\\r\\n            pairedTokenAddress,\\r\\n            tokenAddress,\\r\\n            isBuy,\\r\\n            0,\\r\\n            minPrice,\\r\\n            maxPrice,\\r\\n            amount,\\r\\n            predictionAmount\\r\\n        );\\r\\n        // Emit an event\\r\\n        emit OneTimeOrderCreated(id);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice creates a non-continuous order with a target price\\r\\n     * @dev target price order is only executed when the market price is equal to the target price\\r\\n     * @param pairedTokenAddress pair address\\r\\n     * @param tokenAddress token address\\r\\n     * @param targetPrice target price\\r\\n     * @param isBuy buy or sell order\\r\\n     * @param amount token amount\\r\\n     * @param predictionAmount predictionAmount\\r\\n     */\\r\\n    function createNonContinuousTargetPriceOrder(\\r\\n        address pairedTokenAddress,\\r\\n        address tokenAddress,\\r\\n        bool isBuy,\\r\\n        uint256 targetPrice,\\r\\n        uint256 amount,\\r\\n        uint256 predictionAmount\\r\\n    )   external nonReentrant {\\r\\n        require(validateOneTimeOrder(pairedTokenAddress, tokenAddress, isBuy, amount), \\\"Validation failed\\\");\\r\\n\\r\\n        // Create a new order\\r\\n        uint256 id = _orderMgr.createOneTimeOrder(\\r\\n            msg.sender,\\r\\n            pairedTokenAddress,\\r\\n            tokenAddress,\\r\\n            isBuy,\\r\\n            targetPrice,\\r\\n            0,\\r\\n            0,\\r\\n            amount,\\r\\n            predictionAmount\\r\\n        );\\r\\n\\r\\n        // Emit event\\r\\n        emit OneTimeOrderCreated(id);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice creates a continuous order with price range\\r\\n     * @param pairedTokenAddress pair address\\r\\n     * @param tokenAddress token address\\r\\n     * @param isBuy buy or sell order\\r\\n     * @param minPrice minimum price\\r\\n     * @param maxPrice maximum price\\r\\n     * @param amount token amount - this will be the amount of tokens to buy or sell, based on the token address provided\\r\\n     * @param predictionAmount predictionAmount\\r\\n     * @param resetPercentage decimal represented as an int with 2 places of precision\\r\\n     */\\r\\n    function createContinuousPriceRangeOrder(\\r\\n        address pairedTokenAddress,\\r\\n        address tokenAddress,\\r\\n        bool isBuy,\\r\\n        uint256 minPrice,\\r\\n        uint256 maxPrice,\\r\\n        uint256 amount,\\r\\n        uint256 predictionAmount,\\r\\n        uint256 resetPercentage\\r\\n    ) external nonReentrant {\\r\\n        uint256 id = _orderMgr.createContinuousOrder(\\r\\n            msg.sender,\\r\\n            pairedTokenAddress,\\r\\n            tokenAddress,\\r\\n            isBuy,\\r\\n            0,\\r\\n            minPrice,\\r\\n            maxPrice,\\r\\n            amount,\\r\\n            predictionAmount,\\r\\n            resetPercentage\\r\\n        );\\r\\n\\r\\n        // Emit an event\\r\\n        emit ContinuousOrderCreated(id);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice creates a continuous order with a target price\\r\\n     * @param pairedTokenAddress pair address\\r\\n     * @param tokenAddress token address\\r\\n     * @param isBuy buy or sell order\\r\\n     * @param targetPrice target price\\r\\n     * @param amount token amount - this will be the amount of tokens to buy or sell, based on the token address provided\\r\\n     * @param resetPercentage decimal represented as an int with 2 places of precision\\r\\n     */\\r\\n    function createContinuousTargetPriceOrder(\\r\\n        address pairedTokenAddress,\\r\\n        address tokenAddress,\\r\\n        bool isBuy,\\r\\n        uint256 targetPrice,\\r\\n        uint256 amount,\\r\\n        uint256 predictionAmount,\\r\\n        uint256 resetPercentage\\r\\n    ) external nonReentrant {\\r\\n        // Create the ContinuousOrder struct\\r\\n        uint256 id = _orderMgr.createContinuousOrder(\\r\\n            msg.sender,\\r\\n            pairedTokenAddress,\\r\\n            tokenAddress,\\r\\n            isBuy,\\r\\n            targetPrice,\\r\\n            0,\\r\\n            0,\\r\\n            amount,\\r\\n            predictionAmount,\\r\\n            resetPercentage\\r\\n        );\\r\\n\\r\\n        // Emit an event\\r\\n        emit ContinuousOrderCreated(id);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev cancel exist order\\r\\n     * @param orderId order id\\r\\n     */\\r\\n    function cancelOrder(uint256 orderId) external {\\r\\n        // Validate order owner\\r\\n        IOrderMgr.Order memory order = _orderMgr.getOrder(orderId);\\r\\n        require(\\r\\n            order.orderBase.userAddress == msg.sender,\\r\\n            \\\"msg.sender is not order owner\\\"\\r\\n        );\\r\\n\\r\\n        _orderMgr.cancelOrder(orderId);\\r\\n        if (!order.orderBase.isContinuous)\\r\\n            if (order.orderBase.isBuy) {\\r\\n                balances[msg.sender][order.orderBase.pairedTokenAddress] += order\\r\\n                    .orderBase\\r\\n                    .amount;\\r\\n            } else {\\r\\n                balances[msg.sender][order.orderBase.tokenAddress] += order\\r\\n                    .orderBase\\r\\n                    .amount;\\r\\n            }\\r\\n\\r\\n        // Emit event\\r\\n        emit OrderCanceled(orderId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice process a one-time order\\r\\n     * @dev internal function\\r\\n     * @param orderId id of the order\\r\\n     */\\r\\n    function _processOneTimeOrder(IOrderMgr.Order memory order, uint256 orderId) internal returns (bool) {\\r\\n        // Get the price in amount\\r\\n        uint256 price = _getPairPrice(\\r\\n            order.orderBase.tokenAddress,\\r\\n            order.orderBase.pairedTokenAddress,\\r\\n            10 ** IERC20Ext(order.orderBase.tokenAddress).decimals()\\r\\n        );\\r\\n        address fromToken;\\r\\n        address toToken;\\r\\n        uint256 toAmount;\\r\\n        bool swapStatus;\\r\\n\\r\\n        // Check if the order type is PriceRange\\r\\n        if (order.orderBase.orderType == IOrderMgr.OrderType.PriceRange) {\\r\\n            if (\\r\\n                order.orderBase.minPrice > price || price > order.orderBase.maxPrice\\r\\n            ) {\\r\\n                emit ExecutedOutOfPrice(orderId, order.orderBase.isBuy, price);\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (order.orderBase.isBuy) {\\r\\n            // Check if the order type is TargetPrice\\r\\n            if (order.orderBase.orderType == IOrderMgr.OrderType.TargetPrice) {\\r\\n                if (\\r\\n                    price > order.orderBase.targetPrice\\r\\n                ) {\\r\\n                    emit ExecutedOutOfPrice(orderId, order.orderBase.isBuy, price);\\r\\n                    return false;\\r\\n                }\\r\\n            }\\r\\n            fromToken = order.orderBase.pairedTokenAddress;\\r\\n            toToken = order.orderBase.tokenAddress;\\r\\n        } else {\\r\\n            // Check if the order type is TargetPrice\\r\\n            if (order.orderBase.orderType == IOrderMgr.OrderType.TargetPrice) {\\r\\n                if (price < order.orderBase.targetPrice) {\\r\\n                    emit ExecutedOutOfPrice(orderId, order.orderBase.isBuy, price);\\r\\n                    return false;\\r\\n                }\\r\\n            }\\r\\n            fromToken = order.orderBase.tokenAddress;\\r\\n            toToken = order.orderBase.pairedTokenAddress;\\r\\n        }\\r\\n\\r\\n        (toAmount, swapStatus) = _swapTokens(\\r\\n            fromToken, \\r\\n            toToken, \\r\\n            order.orderBase.amount,\\r\\n            order.orderBase.predictionAmount\\r\\n        );\\r\\n\\r\\n        if(swapStatus) {\\r\\n            balances[order.orderBase.userAddress][toToken] += toAmount;\\r\\n\\r\\n            _orderMgr.setOrderStatus(orderId, IOrderMgr.OrderStatus.Completed);\\r\\n            emit ExecutedOneTimeOrder(\\r\\n                orderId,\\r\\n                order.orderBase.isBuy,\\r\\n                order.orderBase.amount,\\r\\n                toAmount,\\r\\n                price\\r\\n            );\\r\\n\\r\\n            return true;\\r\\n        } else {\\r\\n            emit SwapFailed(orderId);\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice process a continuous order\\r\\n     * @dev internal function\\r\\n     * @param orderId id of the order\\r\\n     */\\r\\n    function _processContinuousOrder(IOrderMgr.Order memory order, uint256 orderId) internal returns (bool){\\r\\n        if (order.orderBase.targetPrice == 0) {\\r\\n            // Price range order\\r\\n            return _processContinuousPriceRangeOrder(order, orderId);\\r\\n        } else {\\r\\n            // Target price order\\r\\n            return _processContinuousTargetPriceOrder(order, orderId);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev internal function to process a continuous price range order\\r\\n     * @param order the order memory instance\\r\\n     * @param orderId order id\\r\\n     */\\r\\n    function _processContinuousPriceRangeOrder(\\r\\n        IOrderMgr.Order memory order,\\r\\n        uint256 orderId\\r\\n    ) internal returns(bool) {\\r\\n        // Get the price in amount\\r\\n        uint256 price = _getPairPrice(\\r\\n            order.orderBase.tokenAddress,\\r\\n            order.orderBase.pairedTokenAddress,\\r\\n            10 ** IERC20Ext(order.orderBase.tokenAddress).decimals()\\r\\n        );\\r\\n\\r\\n        if (order.hasPriceReset) {\\r\\n            if (\\r\\n                !(\\r\\n                price > order.orderBase.minPrice \\r\\n                && price < order.orderBase.maxPrice\\r\\n                )\\r\\n            ) {\\r\\n                emit ExecutedOutOfPrice(orderId, order.orderBase.isBuy, price);\\r\\n                return false;\\r\\n            }\\r\\n            address fromToken;\\r\\n            address toToken;\\r\\n            uint256 toAmount;\\r\\n            bool swapStatus;\\r\\n\\r\\n            if (order.orderBase.isBuy) {\\r\\n                fromToken = order.orderBase.pairedTokenAddress;\\r\\n                toToken = order.orderBase.tokenAddress;\\r\\n            } else {\\r\\n                fromToken = order.orderBase.tokenAddress;\\r\\n                toToken = order.orderBase.pairedTokenAddress;\\r\\n            }\\r\\n            if (\\r\\n                balances[order.orderBase.userAddress][fromToken] >=\\r\\n                order.orderBase.amount\\r\\n            ) {\\r\\n                (toAmount, swapStatus) = _swapTokens(\\r\\n                    fromToken,\\r\\n                    toToken,\\r\\n                    order.orderBase.amount,\\r\\n                    order.orderBase.predictionAmount\\r\\n                );\\r\\n\\r\\n                if(swapStatus) {\\r\\n                    balances[order.orderBase.userAddress][toToken] += toAmount;\\r\\n                    balances[order.orderBase.userAddress][fromToken] -= order\\r\\n                        .orderBase\\r\\n                        .amount;\\r\\n\\r\\n                    _orderMgr.setOrderStatus(orderId, IOrderMgr.OrderStatus.Active);\\r\\n                    _orderMgr.incNumExecutions(orderId);\\r\\n                    _orderMgr.setHasPriceReset(orderId, false);\\r\\n\\r\\n                    emit ExecutedContinuousOrder(orderId, order.orderBase.isBuy, price);\\r\\n                } else {\\r\\n                    emit SwapFailed(orderId);\\r\\n                }\\r\\n            } else {\\r\\n                _orderMgr.setOrderStatus(\\r\\n                    orderId,\\r\\n                    IOrderMgr.OrderStatus.OutOfFunds\\r\\n                );\\r\\n                emit OutOfFunds(orderId);\\r\\n            }\\r\\n        } else {\\r\\n            uint256 lowerDiff = (order.orderBase.minPrice *\\r\\n                order.resetPercentage) / 100;\\r\\n            uint256 upperDiff = (order.orderBase.maxPrice *\\r\\n                order.resetPercentage) / 100;\\r\\n\\r\\n            if (\\r\\n                !(price < order.orderBase.minPrice - lowerDiff\\r\\n                || price > order.orderBase.maxPrice + upperDiff)\\r\\n            ) {\\r\\n                emit ExecutedOutOfPrice(orderId, order.orderBase.isBuy, price);\\r\\n                return false;\\r\\n            }\\r\\n            _orderMgr.setHasPriceReset(orderId, true);\\r\\n        }\\r\\n        \\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev internal function to process a continuous target price order\\r\\n     * @param order the order memory instance\\r\\n     * @param orderId order id\\r\\n     */\\r\\n    function _processContinuousTargetPriceOrder(\\r\\n        IOrderMgr.Order memory order,\\r\\n        uint256 orderId\\r\\n    ) internal returns (bool) {\\r\\n        // Get the price in amount\\r\\n        uint256 price = _getPairPrice(\\r\\n            order.orderBase.tokenAddress,\\r\\n            order.orderBase.pairedTokenAddress,\\r\\n            10 ** IERC20Ext(order.orderBase.tokenAddress).decimals()\\r\\n        );\\r\\n\\r\\n        if (order.orderBase.isBuy) {\\r\\n            if (order.hasPriceReset) {\\r\\n                if (price > order.orderBase.targetPrice) {\\r\\n                    emit ExecutedOutOfPrice(orderId, order.orderBase.isBuy, price);\\r\\n                    return false;\\r\\n                }\\r\\n                address fromToken;\\r\\n                address toToken;\\r\\n                uint256 toAmount;\\r\\n                bool swapStatus;\\r\\n\\r\\n                fromToken = order.orderBase.pairedTokenAddress;\\r\\n                toToken = order.orderBase.tokenAddress;\\r\\n\\r\\n                if (\\r\\n                    balances[order.orderBase.userAddress][fromToken] >=\\r\\n                    order.orderBase.amount\\r\\n                ) {\\r\\n                    (toAmount, swapStatus) = _swapTokens(\\r\\n                        fromToken,\\r\\n                        toToken,\\r\\n                        order.orderBase.amount,\\r\\n                        order.orderBase.predictionAmount\\r\\n                    );\\r\\n\\r\\n                    if(swapStatus) {\\r\\n                        balances[order.orderBase.userAddress][toToken] += toAmount;\\r\\n                        balances[order.orderBase.userAddress][fromToken] -= order\\r\\n                            .orderBase\\r\\n                            .amount;\\r\\n\\r\\n                        _orderMgr.setOrderStatus(\\r\\n                            orderId,\\r\\n                            IOrderMgr.OrderStatus.Active\\r\\n                        );\\r\\n                        _orderMgr.incNumExecutions(orderId);\\r\\n                        _orderMgr.setHasPriceReset(orderId, false);\\r\\n\\r\\n                        emit ExecutedContinuousOrder(orderId, order.orderBase.isBuy, price);\\r\\n                    } else {\\r\\n                        emit SwapFailed(orderId);\\r\\n                    }\\r\\n                } else {\\r\\n                    _orderMgr.setOrderStatus(\\r\\n                        orderId,\\r\\n                        IOrderMgr.OrderStatus.OutOfFunds\\r\\n                    );\\r\\n                    emit OutOfFunds(orderId);\\r\\n                }\\r\\n            } else {\\r\\n                uint256 diff = (order.orderBase.targetPrice *\\r\\n                    order.resetPercentage) / 100;\\r\\n\\r\\n                if (price < order.orderBase.targetPrice + diff) {\\r\\n                    emit ExecutedOutOfPrice(orderId, order.orderBase.isBuy, price);\\r\\n                    return false;\\r\\n                }\\r\\n                _orderMgr.setHasPriceReset(orderId, true);\\r\\n            }\\r\\n        } else {\\r\\n            if (order.hasPriceReset) {\\r\\n                if (price < order.orderBase.targetPrice) {\\r\\n                    emit ExecutedOutOfPrice(orderId, order.orderBase.isBuy, price);\\r\\n                    return false;\\r\\n                }\\r\\n                address fromToken;\\r\\n                address toToken;\\r\\n                uint256 toAmount;\\r\\n                bool swapStatus;\\r\\n\\r\\n                fromToken = order.orderBase.tokenAddress;\\r\\n                toToken = order.orderBase.pairedTokenAddress;\\r\\n\\r\\n                if (\\r\\n                    balances[order.orderBase.userAddress][fromToken] >=\\r\\n                    order.orderBase.amount\\r\\n                ) {\\r\\n                    (toAmount, swapStatus) = _swapTokens(\\r\\n                        fromToken,\\r\\n                        toToken,\\r\\n                        order.orderBase.amount,\\r\\n                        order.orderBase.predictionAmount\\r\\n                    );\\r\\n\\r\\n                    if(swapStatus) {\\r\\n                        balances[order.orderBase.userAddress][toToken] += toAmount;\\r\\n                        balances[order.orderBase.userAddress][fromToken] -= order\\r\\n                            .orderBase\\r\\n                            .amount;\\r\\n\\r\\n                        _orderMgr.setOrderStatus(\\r\\n                            orderId,\\r\\n                            IOrderMgr.OrderStatus.Active\\r\\n                        );\\r\\n                        _orderMgr.incNumExecutions(orderId);\\r\\n                        _orderMgr.setHasPriceReset(orderId, false);\\r\\n\\r\\n                        emit ExecutedContinuousOrder(orderId, order.orderBase.isBuy, price);\\r\\n                    } else {\\r\\n                        emit SwapFailed(orderId);\\r\\n                    }\\r\\n                } else {\\r\\n                    _orderMgr.setOrderStatus(\\r\\n                        orderId,\\r\\n                        IOrderMgr.OrderStatus.OutOfFunds\\r\\n                    );\\r\\n                    emit OutOfFunds(orderId);\\r\\n                }\\r\\n            } else {\\r\\n                uint256 diff = (order.orderBase.targetPrice *\\r\\n                    order.resetPercentage) / 100;\\r\\n\\r\\n                if (price > order.orderBase.targetPrice - diff) {\\r\\n                    emit ExecutedOutOfPrice(orderId, order.orderBase.isBuy, price);\\r\\n                    return false;\\r\\n                }\\r\\n                _orderMgr.setHasPriceReset(orderId, true);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function processOrders(uint256[] memory orderIds) external {\\r\\n        IOrderMgr.Order memory order;\\r\\n        for (uint256 i = 0; i < orderIds.length; i++) {\\r\\n            order = _orderMgr.getOrder(orderIds[i]);\\r\\n            uint256 orderId = orderIds[i];\\r\\n            if (order.orderBase.tokenAddress == address(0))\\r\\n                continue;\\r\\n\\r\\n            if (order.orderBase.isContinuous == true) {\\r\\n                if (order.orderBase.status == IOrderMgr.OrderStatus.Cancelled)\\r\\n                    continue;\\r\\n                _processContinuousOrder(order, orderId);\\r\\n            } else {\\r\\n                if (order.orderBase.status != IOrderMgr.OrderStatus.Active)\\r\\n                    continue;\\r\\n                _processOneTimeOrder(order, orderId);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _swapTokens(\\r\\n        address _fromTokenAddress,\\r\\n        address _toTokenAddress,\\r\\n        uint256 _amount,\\r\\n        uint256 _predictionAmount\\r\\n    ) internal returns (uint256 amount, bool status ) {\\r\\n        IERC20 fromToken = IERC20(_fromTokenAddress);\\r\\n        // Already transferred when adding Funds and deducted from balances when creating an order\\r\\n        // fromToken.transferFrom(msg.sender, address(this), _amount);\\r\\n        fromToken.approve(address(uniswapRouter), _amount);\\r\\n\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = _fromTokenAddress;\\r\\n        path[1] = _toTokenAddress;\\r\\n\\r\\n        uint256 balanceBefore = IERC20(_toTokenAddress).balanceOf(address(this));\\r\\n        \\r\\n        try uniswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n            _amount,\\r\\n            _predictionAmount,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        ) {} catch (bytes memory) {\\r\\n            return (0, false);\\r\\n        }\\r\\n        uint256 toAmount = IERC20(_toTokenAddress).balanceOf(address(this)) - balanceBefore;\\r\\n\\r\\n        return (toAmount, true);\\r\\n    }\\r\\n\\r\\n    function _getPairPrice(\\r\\n        address _fromTokenAddress,\\r\\n        address _toTokenAddress,\\r\\n        uint256 _amount\\r\\n    ) internal view returns (uint256) {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = _fromTokenAddress;\\r\\n        path[1] = _toTokenAddress;\\r\\n\\r\\n        uint[] memory amountsOut = uniswapRouter.getAmountsOut(_amount, path);\\r\\n\\r\\n        return amountsOut[1];\\r\\n    }\\r\\n\\r\\n    function getPairPrice(\\r\\n        address _fromTokenAddress,\\r\\n        address _toTokenAddress\\r\\n    ) external view returns (uint256) {\\r\\n        return\\r\\n            _getPairPrice(\\r\\n                _fromTokenAddress,\\r\\n                _toTokenAddress,\\r\\n                10 ** IERC20Ext(_fromTokenAddress).decimals()\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @notice edit a continuous order with price range\\r\\n     * @param orderId order id\\r\\n     * @param pairedTokenAddress pair address\\r\\n     * @param tokenAddress token address\\r\\n     * @param isBuy buy or sell order\\r\\n     * @param targetPrice target price\\r\\n     * @param amount token amount - this will be the amount of tokens to buy or sell, based on the token address provided\\r\\n     * @param resetPercentage decimal represented as an int with 2 places of precision\\r\\n     */\\r\\n    function editContinuousTargetPriceOrder(\\r\\n        uint256 orderId,\\r\\n        address pairedTokenAddress,\\r\\n        address tokenAddress,\\r\\n        bool isBuy,\\r\\n        uint256 targetPrice,\\r\\n        uint256 amount,\\r\\n        uint256 predictionAmount,\\r\\n        uint256 resetPercentage\\r\\n    ) external {\\r\\n        IOrderMgr.Order memory order = _orderMgr.getOrder(orderId);\\r\\n        // Validate order owner\\r\\n        require(\\r\\n            order.orderBase.userAddress == msg.sender,\\r\\n            \\\"msg.sender is not order owner\\\"\\r\\n        );\\r\\n        // Is continous order\\r\\n        require(order.orderBase.isContinuous == true, \\\"Incorrect order type\\\");\\r\\n\\r\\n        _orderMgr.updateOrder(\\r\\n            orderId,\\r\\n            pairedTokenAddress,\\r\\n            tokenAddress,\\r\\n            isBuy,\\r\\n            targetPrice,\\r\\n            0,\\r\\n            0,\\r\\n            amount,\\r\\n            predictionAmount,\\r\\n            resetPercentage\\r\\n        );\\r\\n\\r\\n        // Emit an event\\r\\n        emit ContinuousOrderEdited(orderId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice edit a continuous order with price range\\r\\n     * @param orderId order id\\r\\n     * @param pairedTokenAddress pair address\\r\\n     * @param tokenAddress token address\\r\\n     * @param isBuy buy or sell order\\r\\n     * @param minPrice minimum price\\r\\n     * @param maxPrice maximum price\\r\\n     * @param amount token amount - this will be the amount of tokens to buy or sell, based on the token address provided\\r\\n     * @param resetPercentage decimal represented as an int with 2 places of precision\\r\\n     */\\r\\n    function editContinuousPriceRangeOrder(\\r\\n        uint256 orderId,\\r\\n        address pairedTokenAddress,\\r\\n        address tokenAddress,\\r\\n        bool isBuy,\\r\\n        uint256 minPrice,\\r\\n        uint256 maxPrice,\\r\\n        uint256 amount,\\r\\n        uint256 predictionAmount,\\r\\n        uint256 resetPercentage\\r\\n    ) external {\\r\\n        IOrderMgr.Order memory order = _orderMgr.getOrder(orderId);\\r\\n        // Validate order owner\\r\\n        require(\\r\\n            order.orderBase.userAddress == msg.sender,\\r\\n            \\\"msg.sender is not order owner\\\"\\r\\n        );\\r\\n        // Is continous order\\r\\n        require(order.orderBase.isContinuous == true, \\\"Incorrect order type\\\");\\r\\n\\r\\n        _orderMgr.updateOrder(\\r\\n            orderId,\\r\\n            pairedTokenAddress,\\r\\n            tokenAddress,\\r\\n            isBuy,\\r\\n            0,\\r\\n            minPrice,\\r\\n            maxPrice,\\r\\n            amount,\\r\\n            predictionAmount,\\r\\n            resetPercentage\\r\\n        );\\r\\n\\r\\n        // Emit an event\\r\\n        emit ContinuousOrderEdited(orderId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice edit non-continuous price range order\\r\\n     * @param orderId order id\\r\\n     * @param pairedTokenAddress pair address\\r\\n     * @param tokenAddress token address\\r\\n     * @param isBuy buy or sell\\r\\n     * @param minPrice minimum price\\r\\n     * @param maxPrice maximum price\\r\\n     * @param amount token amount\\r\\n     */\\r\\n    function editNonContinuousPriceRangeOrder(\\r\\n        uint256 orderId,\\r\\n        address pairedTokenAddress,\\r\\n        address tokenAddress,\\r\\n        bool isBuy,\\r\\n        uint256 minPrice,\\r\\n        uint256 maxPrice,\\r\\n        uint256 amount,\\r\\n        uint256 predictionAmount\\r\\n    ) \\r\\n        external\\r\\n        nonReentrant\\r\\n        initOneTimeOrderBalance(orderId)\\r\\n    {\\r\\n        require(validateOneTimeOrder(pairedTokenAddress, tokenAddress, isBuy, amount), \\\"Validation failed\\\");\\r\\n\\r\\n        _orderMgr.updateOrder(\\r\\n            orderId,\\r\\n            pairedTokenAddress,\\r\\n            tokenAddress,\\r\\n            isBuy,\\r\\n            0,\\r\\n            minPrice,\\r\\n            maxPrice,\\r\\n            amount,\\r\\n            predictionAmount,\\r\\n            0\\r\\n        );\\r\\n        // Emit an event\\r\\n        emit OneTimeOrderEdited(orderId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice edit a non-continuous order with a target price\\r\\n     * @dev target price order is only executed when the market price is equal to the target price\\r\\n     * @param orderId order id\\r\\n     * @param pairedTokenAddress pair address\\r\\n     * @param tokenAddress token address\\r\\n     * @param targetPrice target price\\r\\n     * @param isBuy buy or sell order\\r\\n     * @param amount token amount\\r\\n     */\\r\\n    function editNonContinuousTargetPriceOrder(\\r\\n        uint256 orderId,\\r\\n        address pairedTokenAddress,\\r\\n        address tokenAddress,\\r\\n        uint256 targetPrice,\\r\\n        bool isBuy,\\r\\n        uint256 amount,\\r\\n        uint256 predictionAmount\\r\\n    ) \\r\\n        external\\r\\n        nonReentrant\\r\\n        initOneTimeOrderBalance(orderId)\\r\\n    {\\r\\n        require(validateOneTimeOrder(pairedTokenAddress, tokenAddress, isBuy, amount), \\\"Validation failed\\\");\\r\\n\\r\\n        _orderMgr.updateOrder(\\r\\n            orderId,\\r\\n            pairedTokenAddress,\\r\\n            tokenAddress,\\r\\n            isBuy,\\r\\n            targetPrice,\\r\\n            0,\\r\\n            0,\\r\\n            amount,\\r\\n            predictionAmount,\\r\\n            0\\r\\n        );\\r\\n\\r\\n        // Emit event\\r\\n        emit OneTimeOrderEdited(orderId);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"BackendOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"ContinuousOrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"ContinuousOrderEdited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"ExecutedContinuousOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pairAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"ExecutedOneTimeOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"ExecutedOutOfPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"OneTimeOrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"OneTimeOrderEdited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"OrderCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"OutOfFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"SwapFailed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"backend_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"predictionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resetPercentage\",\"type\":\"uint256\"}],\"name\":\"createContinuousPriceRangeOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"targetPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"predictionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resetPercentage\",\"type\":\"uint256\"}],\"name\":\"createContinuousTargetPriceOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"predictionAmount\",\"type\":\"uint256\"}],\"name\":\"createNonContinuousPriceRangeOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"targetPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"predictionAmount\",\"type\":\"uint256\"}],\"name\":\"createNonContinuousTargetPriceOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"predictionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resetPercentage\",\"type\":\"uint256\"}],\"name\":\"editContinuousPriceRangeOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"targetPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"predictionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resetPercentage\",\"type\":\"uint256\"}],\"name\":\"editContinuousTargetPriceOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"predictionAmount\",\"type\":\"uint256\"}],\"name\":\"editNonContinuousPriceRangeOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"targetPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"predictionAmount\",\"type\":\"uint256\"}],\"name\":\"editNonContinuousTargetPriceOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fromTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_toTokenAddress\",\"type\":\"address\"}],\"name\":\"getPairPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orderMgrAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"orderIds\",\"type\":\"uint256[]\"}],\"name\":\"processOrders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_owner\",\"type\":\"address\"}],\"name\":\"setBackendOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_orderMgrAddress\",\"type\":\"address\"}],\"name\":\"setOrderMgr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "UrulokiDEX", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}