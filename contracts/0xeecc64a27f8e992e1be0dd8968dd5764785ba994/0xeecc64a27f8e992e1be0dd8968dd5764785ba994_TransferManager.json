{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TransferManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IERC165 {\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\\r\\ninterface IERC721 is IERC165 {\\r\\n   \\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\r\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n    \\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\r\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\r\\n    function approve(address to, uint256 tokenId) external;\\r\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\r\\n    function setApprovalForAll(address operator, bool _approved) external;\\r\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\r\\n}\\r\\n\\r\\ncontract TransferManager {\\r\\n\\r\\n    address public admin;\\r\\n    address public signer;\\r\\n    address payable public vaultWallet;\\r\\n    string public salt = \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\";\\r\\n\\r\\n    uint private _transferFee;\\r\\n\\r\\n    mapping(address => uint256) public nonces;\\r\\n\\r\\n    IERC721 public EPIKNFT;\\r\\n\\r\\n    event WithdrawItem(address indexed sender, address indexed receiver, uint256 indexed tokenId, string userId, uint nonce);\\r\\n    \\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == admin, \\\"Not admin\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlySigner() {\\r\\n        require(msg.sender == signer, \\\"Not signer\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(address _signer, address _EPIKNFT, address payable _vaultWallet) {\\r\\n        admin = msg.sender;\\r\\n        signer = _signer;\\r\\n        EPIKNFT = IERC721(_EPIKNFT);\\r\\n        vaultWallet = _vaultWallet;\\r\\n    }\\r\\n\\r\\n    function setAdmin(address _newAdmin) external onlyAdmin {\\r\\n        require(_newAdmin != address(0), \\\"Invalid address\\\");\\r\\n        \\r\\n        admin = _newAdmin;\\r\\n    }\\r\\n    \\r\\n    function setSalt(string memory _salt) external onlyAdmin {\\r\\n        salt = _salt;\\r\\n    }\\r\\n\\r\\n    function setSignerAddress(address _signer) public onlyAdmin {\\r\\n        require(_signer != address(0), \\\"Invalid address\\\");\\r\\n        \\r\\n        signer = _signer;\\r\\n    }\\r\\n\\r\\n    function setNFTAddress(address _epikNFT) external onlyAdmin {\\r\\n        EPIKNFT = IERC721(_epikNFT);\\r\\n    }\\r\\n\\r\\n    function setVaultAddress(address payable _vaultWallet) public onlyAdmin {\\r\\n        require(_vaultWallet != address(0), \\\"Invalid vault address\\\");\\r\\n        \\r\\n        vaultWallet = _vaultWallet;\\r\\n    }\\r\\n\\r\\n    function setTransferFee() external payable onlyAdmin {\\r\\n        _transferFee = msg.value;\\r\\n    }\\r\\n\\r\\n    function getTransferFee() public view returns(uint) {\\r\\n        return _transferFee;\\r\\n    }\\r\\n\\r\\n    function getMessageHash(address _from, address _to, string memory _userId, uint256 _tokenId, uint256 _nonce)\\r\\n        public pure returns (bytes32)\\r\\n    {\\r\\n        return keccak256(abi.encodePacked(_from, _to, _userId, _tokenId, _nonce));\\r\\n    }\\r\\n\\r\\n    function getEthSignedMessageHash(bytes32 _messageHash) public view returns (bytes32) {\\r\\n        /*\\r\\n        Signature is produced by signing a keccak256 hash with the following format:\\r\\n        \\\"\\\\x19Ethereum Signed Message\\\\n\\\" + len(msg) + msg\\r\\n        */\\r\\n        return keccak256(abi.encodePacked(salt, _messageHash));\\r\\n    }\\r\\n\\r\\n    function verify(address _from, address _to, string memory _userId, \\r\\n        uint256 _tokenId, uint256 _nonce, bytes memory signature\\r\\n    )\\r\\n        public view returns (bool)\\r\\n    {\\r\\n        bytes32 messageHash = getMessageHash(_from, _to, _userId, _tokenId, _nonce);\\r\\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\\r\\n\\r\\n        return recoverSigner(ethSignedMessageHash, signature) == signer;\\r\\n    }\\r\\n\\r\\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature)\\r\\n        public pure returns (address)\\r\\n    {\\r\\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\\r\\n\\r\\n        return ecrecover(_ethSignedMessageHash, v, r, s);\\r\\n    }\\r\\n\\r\\n    function splitSignature(bytes memory sig)\\r\\n        public pure returns (bytes32 r, bytes32 s, uint8 v)\\r\\n    {\\r\\n        require(sig.length == 65, \\\"invalid signature length\\\");\\r\\n\\r\\n        assembly {\\r\\n            /*\\r\\n            First 32 bytes stores the length of the signature\\r\\n            add(sig, 32) = pointer of sig + 32\\r\\n            effectively, skips first 32 bytes of signature\\r\\n            mload(p) loads next 32 bytes starting at the memory address p into memory\\r\\n            */\\r\\n\\r\\n            // first 32 bytes, after the length prefix\\r\\n            r := mload(add(sig, 32))\\r\\n            // second 32 bytes\\r\\n            s := mload(add(sig, 64))\\r\\n            // final byte (first byte of the next 32 bytes)\\r\\n            v := byte(0, mload(add(sig, 96)))\\r\\n        }\\r\\n\\r\\n        // implicitly return (r, s, v)\\r\\n    }\\r\\n\\r\\n    function transferItem(address _to, string memory _userId, uint256 _tokenId, uint256 _nonce, \\r\\n            bytes memory signature) public payable {\\r\\n                \\r\\n        require(_nonce > 0 , 'Invalid nonce number');\\r\\n        require(nonces[msg.sender] < _nonce , 'Nonce is ready use');\\r\\n        require(verify(msg.sender, _to, _userId, _tokenId, _nonce, signature) == true, \\\"Invalid signature\\\");\\r\\n\\r\\n        require(msg.value == _transferFee, 'fee is not correct');\\r\\n\\r\\n        nonces[msg.sender] = _nonce;\\r\\n        EPIKNFT.transferFrom(signer, _to, _tokenId);\\r\\n\\r\\n        if(msg.value > 0) vaultWallet.transfer(msg.value);\\r\\n\\r\\n        emit WithdrawItem(msg.sender, _to, _tokenId, _userId, _nonce);\\r\\n    }\\r\\n\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_EPIKNFT\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_vaultWallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"userId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"WithdrawItem\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EPIKNFT\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_messageHash\",\"type\":\"bytes32\"}],\"name\":\"getEthSignedMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_userId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"getMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTransferFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_ethSignedMessageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"recoverSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"salt\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_epikNFT\",\"type\":\"address\"}],\"name\":\"setNFTAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_salt\",\"type\":\"string\"}],\"name\":\"setSalt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"setSignerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setTransferFee\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_vaultWallet\",\"type\":\"address\"}],\"name\":\"setVaultAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"splitSignature\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_userId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"transferItem\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_userId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TransferManager", "CompilerVersion": "v0.8.3+commit.8d00100c", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e8a0518eee8a9d41b31b7e6273acbb00b390040f000000000000000000000000d0643a91d2adc98d71b37332e0b5cb5e7ffcbd7e000000000000000000000000e8a0518eee8a9d41b31b7e6273acbb00b390040f", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}