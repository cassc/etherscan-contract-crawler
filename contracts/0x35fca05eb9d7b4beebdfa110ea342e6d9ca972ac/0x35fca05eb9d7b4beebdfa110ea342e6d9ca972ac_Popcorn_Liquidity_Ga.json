{"SourceCode": "# @version 0.3.7\r\n\"\"\"\r\n@title Popcorn Liquidity Gauge\r\n@author Curve Finance\r\n@license MIT\r\n@notice Modified to give 0 rewards to those without vote-locked tokens\r\n\"\"\"\r\nfrom vyper.interfaces import ERC20\r\n\r\nimplements: ERC20\r\n\r\n\r\ninterface TokenAdmin:\r\n    def getVault() -> address: view\r\n    def future_epoch_time_write() -> uint256: nonpayable\r\n    def rate() -> uint256: view\r\n\r\ninterface Controller:\r\n    def voting_escrow() -> address: view\r\n    def checkpoint_gauge(addr: address): nonpayable\r\n    def gauge_relative_weight(addr: address, time: uint256) -> uint256: view\r\n\r\ninterface ERC20Extended:\r\n    def symbol() -> String[32]: view\r\n    def decimals() -> uint256: view\r\n\r\ninterface ERC1271:\r\n    def isValidSignature(_hash: bytes32, _signature: Bytes[65]) -> bytes32: view\r\n\r\ninterface Minter:\r\n    def getTokenAdmin() -> address: view\r\n    def getGaugeController() -> address: view\r\n    def minted(user: address, gauge: address) -> uint256: view\r\n\r\ninterface VotingEscrow:\r\n    def user_point_epoch(addr: address) -> uint256: view\r\n    def user_point_history__ts(addr: address, epoch: uint256) -> uint256: view\r\n\r\ninterface DelegationProxy:\r\n    def adjusted_balance_of(_account: address) -> uint256: view\r\n\r\n\r\nevent Deposit:\r\n    provider: indexed(address)\r\n    value: uint256\r\n\r\nevent Withdraw:\r\n    provider: indexed(address)\r\n    value: uint256\r\n\r\nevent UpdateLiquidityLimit:\r\n    user: indexed(address)\r\n    original_balance: uint256\r\n    original_supply: uint256\r\n    working_balance: uint256\r\n    working_supply: uint256\r\n\r\nevent Transfer:\r\n    _from: indexed(address)\r\n    _to: indexed(address)\r\n    _value: uint256\r\n\r\nevent Approval:\r\n    _owner: indexed(address)\r\n    _spender: indexed(address)\r\n    _value: uint256\r\n\r\nevent RewardDistributorUpdated:\r\n    reward_token: indexed(address)\r\n    distributor: address\r\n\r\nevent RelativeWeightCapChanged:\r\n    new_relative_weight_cap: uint256\r\n\r\nevent NewPendingAdmin:\r\n    new_pending_admin: address\r\n\r\nevent NewAdmin:\r\n    new_admin: address\r\n\r\nevent NewTokenlessProduction:\r\n    new_tokenless_production: uint8\r\n\r\nstruct Reward:\r\n    token: address\r\n    distributor: address\r\n    period_finish: uint256\r\n    rate: uint256\r\n    last_update: uint256\r\n    integral: uint256\r\n\r\n\r\nMAX_REWARDS: constant(uint256) = 8\r\nWEEK: constant(uint256) = 604800\r\n\r\n# keccak256(\"isValidSignature(bytes32,bytes)\")[:4] << 224\r\nERC1271_MAGIC_VAL: constant(bytes32) = 0x1626ba7e00000000000000000000000000000000000000000000000000000000\r\nVERSION: constant(String[8]) = \"v5.0.0\"\r\n\r\nEIP712_TYPEHASH: constant(bytes32) = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\r\nPERMIT_TYPEHASH: constant(bytes32) = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\r\n\r\nTOKEN_ADMIN: immutable(address)\r\nGAUGE_CONTROLLER: immutable(address)\r\nMINTER: immutable(address)\r\nVOTING_ESCROW: immutable(address)\r\nDELEGATION_PROXY: immutable(address)\r\n\r\nMAX_RELATIVE_WEIGHT_CAP: constant(uint256) = 10 ** 18\r\n\r\ntokenless_production: public(uint8)\r\n\r\npending_admin: public(address)\r\nadmin: public(address)\r\n\r\n# ERC20\r\nbalanceOf: public(HashMap[address, uint256])\r\ntotalSupply: public(uint256)\r\n_allowance: HashMap[address, HashMap[address, uint256]]\r\n\r\nname: public(String[64])\r\nsymbol: public(String[40])\r\n\r\n# ERC2612\r\nDOMAIN_SEPARATOR: public(bytes32)\r\nnonces: public(HashMap[address, uint256])\r\n\r\n# Gauge\r\nlp_token: public(address)\r\ngauge_state: public(uint8)\r\ndecimals: public(uint256)\r\n\r\n# [future_epoch_time uint40][inflation_rate uint216]\r\ninflation_params: uint256\r\n\r\n# For tracking external rewards\r\nreward_count: public(uint256)\r\nreward_data: public(HashMap[address, Reward])\r\n\r\n# claimant -> default reward receiver\r\nrewards_receiver: public(HashMap[address, address])\r\n\r\n# reward token -> claiming address -> integral\r\nreward_integral_for: public(HashMap[address, HashMap[address, uint256]])\r\n\r\n# user -> [uint128 claimable amount][uint128 claimed amount]\r\nclaim_data: HashMap[address, HashMap[address, uint256]]\r\n\r\nworking_balances: public(HashMap[address, uint256])\r\nworking_supply: public(uint256)\r\n\r\n# 1e18 * \u222b(rate(t) / totalSupply(t) dt) from (last_action) till checkpoint\r\nintegrate_inv_supply_of: public(HashMap[address, uint256])\r\nintegrate_checkpoint_of: public(HashMap[address, uint256])\r\n\r\n# \u222b(balance * rate(t) / totalSupply(t) dt) from 0 till checkpoint\r\n# Units: rate * t = already number of coins per address to issue\r\nintegrate_fraction: public(HashMap[address, uint256])\r\n\r\n# The goal is to be able to calculate \u222b(rate * balance / totalSupply dt) from 0 till checkpoint\r\n# All values are kept in units of being multiplied by 1e18\r\nperiod: public(int128)\r\n\r\n# array of reward tokens\r\nreward_tokens: public(address[MAX_REWARDS])\r\n\r\nperiod_timestamp: public(uint256[100000000000000000000000000000])\r\n# 1e18 * \u222b(rate(t) / totalSupply(t) dt) from 0 till checkpoint\r\nintegrate_inv_supply: public(uint256[100000000000000000000000000000])  # bump epoch when rate() changes\r\n\r\n_relative_weight_cap: uint256\r\n\r\n@external\r\ndef __init__(minter: address, delegation_proxy: address):\r\n    \"\"\"\r\n    @param minter The Minter contract used for minting reward tokens\r\n    \"\"\"\r\n    gaugeController: address = Minter(minter).getGaugeController()\r\n    tokenAdmin: address = Minter(minter).getTokenAdmin()\r\n    TOKEN_ADMIN = tokenAdmin\r\n    GAUGE_CONTROLLER = gaugeController\r\n    MINTER = minter\r\n    VOTING_ESCROW = Controller(gaugeController).voting_escrow()\r\n    DELEGATION_PROXY = delegation_proxy\r\n\r\n    # prevent initialization of implementation\r\n    self.lp_token = 0x000000000000000000000000000000000000dEaD\r\n\r\n\r\n# Internal Functions\r\n\r\n\r\n@internal\r\n@view\r\ndef _getCappedRelativeWeight(period: uint256) -> uint256:\r\n    \"\"\"\r\n    @dev Returns the gauge's relative weight, capped to its _relative_weight_cap attribute.\r\n    \"\"\"\r\n    return min(Controller(GAUGE_CONTROLLER).gauge_relative_weight(self, period), self._relative_weight_cap)\r\n\r\n\r\n@internal\r\ndef _checkpoint(addr: address):\r\n    \"\"\"\r\n    @notice Checkpoint for a user\r\n    @dev Updates the reward emissions a user is entitled to receive\r\n    @param addr User address\r\n    \"\"\"\r\n    _period: int128 = self.period\r\n    _period_time: uint256 = self.period_timestamp[_period]\r\n    _integrate_inv_supply: uint256 = self.integrate_inv_supply[_period]\r\n\r\n    inflation_params: uint256 = self.inflation_params\r\n    rate: uint256 = inflation_params % 2 ** 216\r\n    prev_future_epoch: uint256 = shift(inflation_params, -216)\r\n    new_rate: uint256 = rate\r\n\r\n    if prev_future_epoch >= _period_time:\r\n        new_rate = TokenAdmin(TOKEN_ADMIN).rate()\r\n        self.inflation_params = shift(TokenAdmin(TOKEN_ADMIN).future_epoch_time_write(), 216) + new_rate\r\n\r\n    if self._is_killed():\r\n        # Stop distributing inflation as soon as killed\r\n        rate = 0\r\n        new_rate = 0  # prevent distribution when crossing epochs\r\n\r\n    # Update integral of 1/supply\r\n    if block.timestamp > _period_time:\r\n        _working_supply: uint256 = self.working_supply\r\n        Controller(GAUGE_CONTROLLER).checkpoint_gauge(self)\r\n        prev_week_time: uint256 = _period_time\r\n        week_time: uint256 = min((_period_time + WEEK) / WEEK * WEEK, block.timestamp)\r\n\r\n        for i in range(500):\r\n            dt: uint256 = week_time - prev_week_time\r\n            w: uint256 = self._getCappedRelativeWeight(prev_week_time / WEEK * WEEK)\r\n\r\n            if _working_supply > 0:\r\n                if prev_future_epoch >= prev_week_time and prev_future_epoch < week_time:\r\n                    # If we went across one or multiple epochs, apply the rate\r\n                    # of the first epoch until it ends, and then the rate of\r\n                    # the last epoch.\r\n                    # If more than one epoch is crossed - the gauge gets less,\r\n                    # but that'd meen it wasn't called for more than 1 year\r\n                    _integrate_inv_supply += rate * w * (prev_future_epoch - prev_week_time) / _working_supply\r\n                    rate = new_rate\r\n                    _integrate_inv_supply += rate * w * (week_time - prev_future_epoch) / _working_supply\r\n                else:\r\n                    _integrate_inv_supply += rate * w * dt / _working_supply\r\n                # On precisions of the calculation\r\n                # rate ~= 10e18\r\n                # last_weight > 0.01 * 1e18 = 1e16 (if pool weight is 1%)\r\n                # _working_supply ~= TVL * 1e18 ~= 1e26 ($100M for example)\r\n                # The largest loss is at dt = 1\r\n                # Loss is 1e-9 - acceptable\r\n\r\n            if week_time == block.timestamp:\r\n                break\r\n            prev_week_time = week_time\r\n            week_time = min(week_time + WEEK, block.timestamp)\r\n\r\n    _period += 1\r\n    self.period = _period\r\n    self.period_timestamp[_period] = block.timestamp\r\n    self.integrate_inv_supply[_period] = _integrate_inv_supply\r\n\r\n    # Update user-specific integrals\r\n    _working_balance: uint256 = self.working_balances[addr]\r\n    self.integrate_fraction[addr] += _working_balance * (_integrate_inv_supply - self.integrate_inv_supply_of[addr]) / 10 ** 18\r\n    self.integrate_inv_supply_of[addr] = _integrate_inv_supply\r\n    self.integrate_checkpoint_of[addr] = block.timestamp\r\n\r\n\r\n@internal\r\ndef _checkpoint_rewards(_user: address, _total_supply: uint256, _claim: bool, _receiver: address):\r\n    \"\"\"\r\n    @notice Claim pending rewards and checkpoint rewards for a user\r\n    \"\"\"\r\n    user_balance: uint256 = 0\r\n    receiver: address = _receiver\r\n    if _user != empty(address):\r\n        user_balance = self.balanceOf[_user]\r\n        if _claim and _receiver == empty(address):\r\n            # if receiver is not explicitly declared, check if a default receiver is set\r\n            receiver = self.rewards_receiver[_user]\r\n            if receiver == empty(address):\r\n                # if no default receiver is set, direct claims to the user\r\n                receiver = _user\r\n\r\n    reward_count: uint256 = self.reward_count\r\n    for i in range(MAX_REWARDS):\r\n        if i == reward_count:\r\n            break\r\n        token: address = self.reward_tokens[i]\r\n\r\n        integral: uint256 = self.reward_data[token].integral\r\n        last_update: uint256 = min(block.timestamp, self.reward_data[token].period_finish)\r\n        duration: uint256 = last_update - self.reward_data[token].last_update\r\n        if duration != 0:\r\n            self.reward_data[token].last_update = last_update\r\n            if _total_supply != 0:\r\n                integral += duration * self.reward_data[token].rate * 10**18 / _total_supply\r\n                self.reward_data[token].integral = integral\r\n\r\n        if _user != empty(address):\r\n            integral_for: uint256 = self.reward_integral_for[token][_user]\r\n            new_claimable: uint256 = 0\r\n\r\n            if integral_for < integral:\r\n                self.reward_integral_for[token][_user] = integral\r\n                new_claimable = user_balance * (integral - integral_for) / 10**18\r\n\r\n            claim_data: uint256 = self.claim_data[_user][token]\r\n            total_claimable: uint256 = shift(claim_data, -128) + new_claimable\r\n            if total_claimable > 0:\r\n                total_claimed: uint256 = claim_data % 2**128\r\n                if _claim:\r\n                    response: Bytes[32] = raw_call(\r\n                        token,\r\n                        _abi_encode(\r\n                            receiver,\r\n                            total_claimable,\r\n                            method_id=method_id(\"transfer(address,uint256)\")\r\n                        ),\r\n                        max_outsize=32,\r\n                    )\r\n                    if len(response) != 0:\r\n                        assert convert(response, bool)\r\n                    self.claim_data[_user][token] = total_claimed + total_claimable\r\n                elif new_claimable > 0:\r\n                    self.claim_data[_user][token] = total_claimed + shift(total_claimable, 128)\r\n\r\n\r\n@internal\r\ndef _voting_balance_of(addr: address) -> uint256:\r\n    return DelegationProxy(DELEGATION_PROXY).adjusted_balance_of(addr)\r\n\r\n\r\n@internal\r\ndef _update_liquidity_limit(addr: address, l: uint256, L: uint256):\r\n    \"\"\"\r\n    @notice Calculate limits which depend on the amount of LP token per-user.\r\n            Effectively it calculates working balances to apply amplification\r\n            of reward production by LP\r\n    @param addr User address\r\n    @param l User's amount of liquidity (LP tokens)\r\n    @param L Total amount of liquidity (LP tokens)\r\n    \"\"\"\r\n    # To be called after totalSupply is updated\r\n    voting_balance: uint256 = self._voting_balance_of(addr)\r\n    voting_total: uint256 = ERC20(VOTING_ESCROW).totalSupply()\r\n\r\n    _tokenless_production: uint256 = convert(self.tokenless_production, uint256)\r\n    lim: uint256 = l * _tokenless_production / 100 # component based on user liquidity\r\n    if voting_total > 0:\r\n        lim += L * voting_balance / voting_total * (100 - _tokenless_production) / 100 # component based on vote locked tokens\r\n\r\n    lim = min(l, lim)\r\n    old_bal: uint256 = self.working_balances[addr]\r\n    self.working_balances[addr] = lim\r\n    _working_supply: uint256 = self.working_supply + lim - old_bal\r\n    self.working_supply = _working_supply\r\n\r\n    log UpdateLiquidityLimit(addr, l, L, lim, _working_supply)\r\n\r\n\r\n@internal\r\ndef _transfer(_from: address, _to: address, _value: uint256):\r\n    \"\"\"\r\n    @notice Transfer tokens as well as checkpoint users\r\n    \"\"\"\r\n    self._checkpoint(_from)\r\n    self._checkpoint(_to)\r\n\r\n    if _value != 0:\r\n        total_supply: uint256 = self.totalSupply\r\n        is_rewards: bool = self.reward_count != 0\r\n        if is_rewards:\r\n            self._checkpoint_rewards(_from, total_supply, False, empty(address))\r\n        new_balance: uint256 = self.balanceOf[_from] - _value\r\n        self.balanceOf[_from] = new_balance\r\n        self._update_liquidity_limit(_from, new_balance, total_supply)\r\n\r\n        if is_rewards:\r\n            self._checkpoint_rewards(_to, total_supply, False, empty(address))\r\n        new_balance = self.balanceOf[_to] + _value\r\n        self.balanceOf[_to] = new_balance\r\n        self._update_liquidity_limit(_to, new_balance, total_supply)\r\n\r\n    log Transfer(_from, _to, _value)\r\n\r\n\r\n# External User Facing Functions\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef deposit(_value: uint256, _addr: address = msg.sender, _claim_rewards: bool = False):\r\n    \"\"\"\r\n    @notice Deposit `_value` LP tokens\r\n    @dev Depositting also claims pending reward tokens\r\n    @param _value Number of tokens to deposit\r\n    @param _addr Address to deposit for\r\n    \"\"\"\r\n\r\n    self._checkpoint(_addr)\r\n\r\n    if _value != 0:\r\n        is_rewards: bool = self.reward_count != 0\r\n        total_supply: uint256 = self.totalSupply\r\n        if is_rewards:\r\n            self._checkpoint_rewards(_addr, total_supply, _claim_rewards, empty(address))\r\n\r\n        total_supply += _value\r\n        new_balance: uint256 = self.balanceOf[_addr] + _value\r\n        self.balanceOf[_addr] = new_balance\r\n        self.totalSupply = total_supply\r\n\r\n        self._update_liquidity_limit(_addr, new_balance, total_supply)\r\n\r\n        ERC20(self.lp_token).transferFrom(msg.sender, self, _value)\r\n\r\n    log Deposit(_addr, _value)\r\n    log Transfer(empty(address), _addr, _value)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef withdraw(_value: uint256, _claim_rewards: bool = False):\r\n    \"\"\"\r\n    @notice Withdraw `_value` LP tokens\r\n    @dev Withdrawing also claims pending reward tokens\r\n    @param _value Number of tokens to withdraw\r\n    \"\"\"\r\n    self._checkpoint(msg.sender)\r\n\r\n    if _value != 0:\r\n        is_rewards: bool = self.reward_count != 0\r\n        total_supply: uint256 = self.totalSupply\r\n        if is_rewards:\r\n            self._checkpoint_rewards(msg.sender, total_supply, _claim_rewards, empty(address))\r\n\r\n        total_supply -= _value\r\n        new_balance: uint256 = self.balanceOf[msg.sender] - _value\r\n        self.balanceOf[msg.sender] = new_balance\r\n        self.totalSupply = total_supply\r\n\r\n        self._update_liquidity_limit(msg.sender, new_balance, total_supply)\r\n\r\n        ERC20(self.lp_token).transfer(msg.sender, _value)\r\n\r\n    log Withdraw(msg.sender, _value)\r\n    log Transfer(msg.sender, empty(address), _value)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef claim_rewards(_addr: address = msg.sender, _receiver: address = empty(address)):\r\n    \"\"\"\r\n    @notice Claim available reward tokens for `_addr`\r\n    @param _addr Address to claim for\r\n    @param _receiver Address to transfer rewards to - if set to\r\n                     empty(address), uses the default reward receiver\r\n                     for the caller\r\n    \"\"\"\r\n    if _receiver != empty(address):\r\n        assert _addr == msg.sender  # dev: cannot redirect when claiming for another user\r\n    self._checkpoint_rewards(_addr, self.totalSupply, True, _receiver)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef transferFrom(_from: address, _to :address, _value: uint256) -> bool:\r\n    \"\"\"\r\n     @notice Transfer tokens from one address to another.\r\n     @dev Transferring claims pending reward tokens for the sender and receiver\r\n     @param _from address The address which you want to send tokens from\r\n     @param _to address The address which you want to transfer to\r\n     @param _value uint256 the amount of tokens to be transferred\r\n    \"\"\"\r\n    _allowance: uint256 = self._allowance[_from][msg.sender]\r\n    if _allowance != max_value(uint256):\r\n        self._allowance[_from][msg.sender] = _allowance - _value\r\n\r\n    self._transfer(_from, _to, _value)\r\n\r\n    return True\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef transfer(_to: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Transfer token for a specified address\r\n    @dev Transferring claims pending reward tokens for the sender and receiver\r\n    @param _to The address to transfer to.\r\n    @param _value The amount to be transferred.\r\n    \"\"\"\r\n    self._transfer(msg.sender, _to, _value)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef approve(_spender : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @notice Approve the passed address to transfer the specified amount of\r\n            tokens on behalf of msg.sender\r\n    @dev Beware that changing an allowance via this method brings the risk\r\n         that someone may use both the old and new allowance by unfortunate\r\n         transaction ordering. This may be mitigated with the use of\r\n         {incraseAllowance} and {decreaseAllowance}.\r\n         https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    @param _spender The address which will transfer the funds\r\n    @param _value The amount of tokens that may be transferred\r\n    @return bool success\r\n    \"\"\"\r\n    self._allowance[msg.sender][_spender] = _value\r\n    log Approval(msg.sender, _spender, _value)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef permit(\r\n    _owner: address,\r\n    _spender: address,\r\n    _value: uint256,\r\n    _deadline: uint256,\r\n    _v: uint8,\r\n    _r: bytes32,\r\n    _s: bytes32\r\n) -> bool:\r\n    \"\"\"\r\n    @notice Approves spender by owner's signature to expend owner's tokens.\r\n        See https://eips.ethereum.org/EIPS/eip-2612.\r\n    @dev Inspired by https://github.com/yearn/yearn-vaults/blob/main/contracts/Vault.vy#L753-L793\r\n    @dev Supports smart contract wallets which implement ERC1271\r\n        https://eips.ethereum.org/EIPS/eip-1271\r\n    @param _owner The address which is a source of funds and has signed the Permit.\r\n    @param _spender The address which is allowed to spend the funds.\r\n    @param _value The amount of tokens to be spent.\r\n    @param _deadline The timestamp after which the Permit is no longer valid.\r\n    @param _v The bytes[64] of the valid secp256k1 signature of permit by owner\r\n    @param _r The bytes[0:32] of the valid secp256k1 signature of permit by owner\r\n    @param _s The bytes[32:64] of the valid secp256k1 signature of permit by owner\r\n    @return True, if transaction completes successfully\r\n    \"\"\"\r\n    assert _owner != empty(address)\r\n    assert block.timestamp <= _deadline\r\n\r\n    nonce: uint256 = self.nonces[_owner]\r\n    digest: bytes32 = keccak256(\r\n        concat(\r\n            b\"\\x19\\x01\",\r\n            self.DOMAIN_SEPARATOR,\r\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\r\n        )\r\n    )\r\n\r\n    if _owner.is_contract:\r\n        sig: Bytes[65] = concat(_abi_encode(_r, _s), slice(convert(_v, bytes32), 31, 1))\r\n        # reentrancy not a concern since this is a staticcall\r\n        assert ERC1271(_owner).isValidSignature(digest, sig) == ERC1271_MAGIC_VAL\r\n    else:\r\n        assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\r\n\r\n    self._allowance[_owner][_spender] = _value\r\n    self.nonces[_owner] = nonce + 1\r\n\r\n    log Approval(_owner, _spender, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef increaseAllowance(_spender: address, _added_value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Increase the allowance granted to `_spender` by the caller\r\n    @dev This is alternative to {approve} that can be used as a mitigation for\r\n         the potential race condition\r\n    @param _spender The address which will transfer the funds\r\n    @param _added_value The amount of to increase the allowance\r\n    @return bool success\r\n    \"\"\"\r\n    allowance: uint256 = self._allowance[msg.sender][_spender] + _added_value\r\n    self._allowance[msg.sender][_spender] = allowance\r\n\r\n    log Approval(msg.sender, _spender, allowance)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef decreaseAllowance(_spender: address, _subtracted_value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Decrease the allowance granted to `_spender` by the caller\r\n    @dev This is alternative to {approve} that can be used as a mitigation for\r\n         the potential race condition\r\n    @param _spender The address which will transfer the funds\r\n    @param _subtracted_value The amount of to decrease the allowance\r\n    @return bool success\r\n    \"\"\"\r\n    allowance: uint256 = self._allowance[msg.sender][_spender] - _subtracted_value\r\n    self._allowance[msg.sender][_spender] = allowance\r\n\r\n    log Approval(msg.sender, _spender, allowance)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef user_checkpoint(addr: address) -> bool:\r\n    \"\"\"\r\n    @notice Record a checkpoint for `addr`\r\n    @param addr User address\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender in [addr, MINTER]  # dev: unauthorized\r\n    self._checkpoint(addr)\r\n    self._update_liquidity_limit(addr, self.balanceOf[addr], self.totalSupply)\r\n    return True\r\n\r\n\r\n@external\r\ndef set_rewards_receiver(_receiver: address):\r\n    \"\"\"\r\n    @notice Set the default reward receiver for the caller.\r\n    @dev When set to empty(address), rewards are sent to the caller\r\n    @param _receiver Receiver address for any rewards claimed via `claim_rewards`\r\n    \"\"\"\r\n    self.rewards_receiver[msg.sender] = _receiver\r\n\r\n\r\n@external\r\ndef kick(addr: address):\r\n    \"\"\"\r\n    @notice Kick `addr` for abusing their boost\r\n    @dev Only if either they had another voting event, or their voting escrow lock expired\r\n    @param addr Address to kick\r\n    \"\"\"\r\n    t_last: uint256 = self.integrate_checkpoint_of[addr]\r\n    t_ve: uint256 = VotingEscrow(VOTING_ESCROW).user_point_history__ts(\r\n        addr, VotingEscrow(VOTING_ESCROW).user_point_epoch(addr)\r\n    )\r\n    _balance: uint256 = self.balanceOf[addr]\r\n\r\n    assert ERC20(VOTING_ESCROW).balanceOf(addr) == 0 or t_ve > t_last # dev: kick not allowed\r\n    assert self.working_balances[addr] > _balance * convert(self.tokenless_production, uint256) / 100  # dev: kick not needed\r\n\r\n    self._checkpoint(addr)\r\n    self._update_liquidity_limit(addr, self.balanceOf[addr], self.totalSupply)\r\n\r\n\r\n# Administrative Functions\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef deposit_reward_token(_reward_token: address, _amount: uint256):\r\n    \"\"\"\r\n    @notice Deposit a reward token for distribution\r\n    @param _reward_token The reward token being deposited\r\n    @param _amount The amount of `_reward_token` being deposited\r\n    \"\"\"\r\n    assert msg.sender == self.reward_data[_reward_token].distributor\r\n\r\n    self._checkpoint_rewards(empty(address), self.totalSupply, False, empty(address))\r\n\r\n    response: Bytes[32] = raw_call(\r\n        _reward_token,\r\n        _abi_encode(\r\n            msg.sender, self, _amount, method_id=method_id(\"transferFrom(address,address,uint256)\")\r\n        ),\r\n        max_outsize=32,\r\n    )\r\n    if len(response) != 0:\r\n        assert convert(response, bool)\r\n\r\n    period_finish: uint256 = self.reward_data[_reward_token].period_finish\r\n    if block.timestamp >= period_finish:\r\n        self.reward_data[_reward_token].rate = _amount / WEEK\r\n    else:\r\n        remaining: uint256 = period_finish - block.timestamp\r\n        leftover: uint256 = remaining * self.reward_data[_reward_token].rate\r\n        self.reward_data[_reward_token].rate = (_amount + leftover) / WEEK\r\n\r\n    self.reward_data[_reward_token].last_update = block.timestamp\r\n    self.reward_data[_reward_token].period_finish = block.timestamp + WEEK\r\n\r\n\r\n@external\r\ndef add_reward(_reward_token: address, _distributor: address):\r\n    \"\"\"\r\n    @notice Add additional rewards to be distributed to stakers\r\n    @param _reward_token The token to add as an additional reward\r\n    @param _distributor Address permitted to fund this contract with the reward token\r\n    \"\"\"\r\n    assert _distributor != empty(address)\r\n    assert msg.sender == self.admin  # dev: only owner\r\n\r\n    reward_count: uint256 = self.reward_count\r\n    assert reward_count < MAX_REWARDS\r\n    assert self.reward_data[_reward_token].distributor == empty(address)\r\n\r\n    self.reward_data[_reward_token].distributor = _distributor\r\n    self.reward_tokens[reward_count] = _reward_token\r\n    self.reward_count = reward_count + 1\r\n    log RewardDistributorUpdated(_reward_token, _distributor)\r\n\r\n\r\n@external\r\ndef set_reward_distributor(_reward_token: address, _distributor: address):\r\n    \"\"\"\r\n    @notice Reassign the reward distributor for a reward token\r\n    @param _reward_token The reward token to reassign distribution rights to\r\n    @param _distributor The address of the new distributor\r\n    \"\"\"\r\n    current_distributor: address = self.reward_data[_reward_token].distributor\r\n\r\n    assert msg.sender == current_distributor or msg.sender == self.admin\r\n    assert current_distributor != empty(address)\r\n    assert _distributor != empty(address)\r\n\r\n    self.reward_data[_reward_token].distributor = _distributor\r\n    log RewardDistributorUpdated(_reward_token, _distributor)\r\n\r\n\r\n@external\r\ndef killGauge():\r\n    \"\"\"\r\n    @notice Kills the gauge so it always yields a rate of 0 and so cannot mint rewards\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: only owner\r\n\r\n    self.gauge_state = 1 # DEAD\r\n\r\n\r\n@external\r\ndef unkillGauge():\r\n    \"\"\"\r\n    @notice Unkills the gauge so it can mint rewards again\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: only owner\r\n\r\n    self.gauge_state = 2 # ALIVE\r\n\r\n\r\n@external\r\ndef change_pending_admin(new_pending_admin: address):\r\n    \"\"\"\r\n    @notice Change pending_admin to `new_pending_admin`\r\n    @param new_pending_admin The new pending_admin address\r\n    \"\"\"\r\n    assert msg.sender == self.admin # dev: only owner\r\n\r\n    self.pending_admin = new_pending_admin\r\n\r\n    log NewPendingAdmin(new_pending_admin)\r\n\r\n\r\n@external\r\ndef claim_admin():\r\n    \"\"\"\r\n    @notice Called by pending_admin to set admin to pending_admin\r\n    \"\"\"\r\n    assert msg.sender == self.pending_admin # dev: only pending admin\r\n\r\n    self.admin = msg.sender\r\n    self.pending_admin = empty(address)\r\n\r\n    log NewAdmin(msg.sender)\r\n\r\n\r\n@external\r\ndef set_tokenless_production(new_tokenless_production: uint8):\r\n    \"\"\"\r\n    @notice Updates the tokenless production weight, which affects how\r\n    much staking weight is given to liquidity and how much is given to\r\n    vote locked tokens.\r\n    @param new_tokenless_production The new tokenless_production value\r\n    \"\"\"\r\n    assert msg.sender == self.admin # dev: only owner\r\n    assert new_tokenless_production <= 100 # dev: has to be between 0 and 100\r\n\r\n    self.tokenless_production = new_tokenless_production\r\n\r\n    log NewTokenlessProduction(new_tokenless_production)\r\n\r\n\r\n# View Methods\r\n\r\n\r\n@view\r\n@external\r\ndef claimed_reward(_addr: address, _token: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the number of already-claimed reward tokens for a user\r\n    @param _addr Account to get reward amount for\r\n    @param _token Token to get reward amount for\r\n    @return uint256 Total amount of `_token` already claimed by `_addr`\r\n    \"\"\"\r\n    return self.claim_data[_addr][_token] % 2**128\r\n\r\n\r\n@view\r\n@external\r\ndef claimable_reward(_user: address, _reward_token: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the number of claimable reward tokens for a user\r\n    @param _user Account to get reward amount for\r\n    @param _reward_token Token to get reward amount for\r\n    @return uint256 Claimable reward token amount\r\n    \"\"\"\r\n    integral: uint256 = self.reward_data[_reward_token].integral\r\n    total_supply: uint256 = self.totalSupply\r\n    if total_supply != 0:\r\n        last_update: uint256 = min(block.timestamp, self.reward_data[_reward_token].period_finish)\r\n        duration: uint256 = last_update - self.reward_data[_reward_token].last_update\r\n        integral += (duration * self.reward_data[_reward_token].rate * 10**18 / total_supply)\r\n\r\n    integral_for: uint256 = self.reward_integral_for[_reward_token][_user]\r\n    new_claimable: uint256 = self.balanceOf[_user] * (integral - integral_for) / 10**18\r\n\r\n    return shift(self.claim_data[_user][_reward_token], -128) + new_claimable\r\n\r\n\r\n@external\r\ndef claimable_tokens(addr: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the number of claimable tokens per user\r\n    @dev This function should be manually changed to \"view\" in the ABI\r\n    @return uint256 number of claimable tokens per user\r\n    \"\"\"\r\n    self._checkpoint(addr)\r\n    return self.integrate_fraction[addr] - Minter(MINTER).minted(addr, self)\r\n\r\n\r\n@view\r\n@external\r\ndef integrate_checkpoint() -> uint256:\r\n    \"\"\"\r\n    @notice Get the timestamp of the last checkpoint\r\n    \"\"\"\r\n    return self.period_timestamp[self.period]\r\n\r\n\r\n@view\r\n@external\r\ndef future_epoch_time() -> uint256:\r\n    \"\"\"\r\n    @notice Get the locally stored reward future epoch start time\r\n    \"\"\"\r\n    return shift(self.inflation_params, -216)\r\n\r\n\r\n@view\r\n@external\r\ndef inflation_rate() -> uint256:\r\n    \"\"\"\r\n    @notice Get the locally stored reward inflation rate\r\n    \"\"\"\r\n    return self.inflation_params % 2 ** 216\r\n\r\n\r\n@view\r\n@external\r\ndef version() -> String[8]:\r\n    \"\"\"\r\n    @notice Get the version of this gauge contract\r\n    \"\"\"\r\n    return VERSION\r\n\r\n@view\r\n@external\r\ndef allowance(owner: address, spender: address) -> uint256:\r\n    \"\"\"\r\n     @notice Get `spender`'s current allowance from `owner` \r\n    \"\"\"\r\n    return self._allowance[owner][spender]\r\n\r\n\r\n@external\r\n@view\r\ndef is_killed() -> bool:\r\n    return self._is_killed()\r\n\r\n\r\n@internal\r\n@view\r\ndef _is_killed() -> bool:\r\n    return self.gauge_state == 1 # 1 == DEAD, 2 == ALIVE\r\n\r\n\r\n# Initializer\r\n\r\n@internal\r\ndef _setRelativeWeightCap(relative_weight_cap: uint256):\r\n    assert relative_weight_cap <= MAX_RELATIVE_WEIGHT_CAP, \"Relative weight cap exceeds allowed absolute maximum\"\r\n    self._relative_weight_cap = relative_weight_cap\r\n    log RelativeWeightCapChanged(relative_weight_cap)\r\n\r\n@external\r\ndef initialize(_lp_token: address, relative_weight_cap: uint256, _admin: address):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param _lp_token Liquidity Pool contract address\r\n    @param relative_weight_cap The initial relative weight cap\r\n    @param _admin The initial admin address\r\n    \"\"\"\r\n    assert self.lp_token == empty(address)\r\n\r\n    self.admin = _admin\r\n    self.lp_token = _lp_token\r\n    self.decimals = ERC20Extended(_lp_token).decimals()\r\n\r\n    symbol: String[32] = ERC20Extended(_lp_token).symbol()\r\n    name: String[64] = concat(\"VaultCraft \", symbol, \" Gauge Deposit\")\r\n\r\n    self.name = name\r\n    self.symbol = concat(symbol, \"-gauge\")\r\n\r\n    self.DOMAIN_SEPARATOR = keccak256(\r\n        _abi_encode(EIP712_TYPEHASH, keccak256(name), keccak256(VERSION), chain.id, self)\r\n    )\r\n\r\n    self.period_timestamp[0] = block.timestamp\r\n    self.inflation_params = shift(TokenAdmin(TOKEN_ADMIN).future_epoch_time_write(), 216) + TokenAdmin(TOKEN_ADMIN).rate()\r\n    self._setRelativeWeightCap(relative_weight_cap)\r\n\r\n@external\r\ndef setRelativeWeightCap(relative_weight_cap: uint256):\r\n    \"\"\"\r\n    @notice Sets a new relative weight cap for the gauge.\r\n            The value shall be normalized to 1e18, and not greater than MAX_RELATIVE_WEIGHT_CAP.\r\n    @param relative_weight_cap New relative weight cap.\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: only owner\r\n    self._setRelativeWeightCap(relative_weight_cap)\r\n\r\n@external\r\n@view\r\ndef getRelativeWeightCap() -> uint256:\r\n    \"\"\"\r\n    @notice Returns relative weight cap for the gauge.\r\n    \"\"\"\r\n    return self._relative_weight_cap\r\n\r\n@external\r\n@view\r\ndef getCappedRelativeWeight(time: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Returns the gauge's relative weight for a given time, capped to its _relative_weight_cap attribute.\r\n    @param time Timestamp in the past or present.\r\n    \"\"\"\r\n    return self._getCappedRelativeWeight(time)\r\n\r\n@external\r\n@pure\r\ndef getMaxRelativeWeightCap() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the maximum value that can be set to _relative_weight_cap attribute.\r\n    \"\"\"\r\n    return MAX_RELATIVE_WEIGHT_CAP", "ABI": "[{\"name\":\"Deposit\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Withdraw\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateLiquidityLimit\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\",\"indexed\":true},{\"name\":\"original_balance\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"original_supply\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"working_balance\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"working_supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Transfer\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_to\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Approval\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_spender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RewardDistributorUpdated\",\"inputs\":[{\"name\":\"reward_token\",\"type\":\"address\",\"indexed\":true},{\"name\":\"distributor\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RelativeWeightCapChanged\",\"inputs\":[{\"name\":\"new_relative_weight_cap\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NewPendingAdmin\",\"inputs\":[{\"name\":\"new_pending_admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NewAdmin\",\"inputs\":[{\"name\":\"new_admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NewTokenlessProduction\",\"inputs\":[{\"name\":\"new_tokenless_production\",\"type\":\"uint8\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"minter\",\"type\":\"address\"},{\"name\":\"delegation_proxy\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_claim_rewards\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_claim_rewards\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_rewards\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_rewards\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_rewards\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transferFrom\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transfer\",\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"approve\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"permit\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_deadline\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"increaseAllowance\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_added_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"decreaseAllowance\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtracted_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"user_checkpoint\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_rewards_receiver\",\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"kick\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit_reward_token\",\"inputs\":[{\"name\":\"_reward_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_reward\",\"inputs\":[{\"name\":\"_reward_token\",\"type\":\"address\"},{\"name\":\"_distributor\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_reward_distributor\",\"inputs\":[{\"name\":\"_reward_token\",\"type\":\"address\"},{\"name\":\"_distributor\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"killGauge\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"unkillGauge\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"change_pending_admin\",\"inputs\":[{\"name\":\"new_pending_admin\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_admin\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_tokenless_production\",\"inputs\":[{\"name\":\"new_tokenless_production\",\"type\":\"uint8\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"claimed_reward\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"claimable_reward\",\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_reward_token\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claimable_tokens\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_checkpoint\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_epoch_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"inflation_rate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"version\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"allowance\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_killed\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"initialize\",\"inputs\":[{\"name\":\"_lp_token\",\"type\":\"address\"},{\"name\":\"relative_weight_cap\",\"type\":\"uint256\"},{\"name\":\"_admin\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setRelativeWeightCap\",\"inputs\":[{\"name\":\"relative_weight_cap\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"getRelativeWeightCap\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"getCappedRelativeWeight\",\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"getMaxRelativeWeightCap\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"tokenless_production\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pending_admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"DOMAIN_SEPARATOR\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"nonces\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lp_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gauge_state\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"decimals\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"reward_count\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"reward_data\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"distributor\",\"type\":\"address\"},{\"name\":\"period_finish\",\"type\":\"uint256\"},{\"name\":\"rate\",\"type\":\"uint256\"},{\"name\":\"last_update\",\"type\":\"uint256\"},{\"name\":\"integral\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rewards_receiver\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"reward_integral_for\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"working_balances\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"working_supply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_inv_supply_of\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_checkpoint_of\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_fraction\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"period\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"reward_tokens\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"period_timestamp\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_inv_supply\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]", "ContractName": "Popcorn Liquidity Gauge", "CompilerVersion": "vyper:0.3.7", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "00000000000000000000000049f095b38ee6d8541758af51c509332e7793d4b0000000000000000000000000afe32869caf311585647adcd79050b83dbcf94c8", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}