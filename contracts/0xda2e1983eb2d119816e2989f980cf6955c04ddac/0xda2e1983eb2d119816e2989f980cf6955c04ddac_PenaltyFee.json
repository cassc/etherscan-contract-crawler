{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/staking/interfaces/IMultiplier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\ninterface IMultiplier {\\n    /**\\n     * Applies a multiplier on the _amount, based on the _pool and _beneficiary.\\n     * The multiplier is not necessarily a constant number, it can be a more complex factor.\\n     */\\n    function applyMultiplier(uint256 _amount, uint256 _duration) external view returns (uint256);\\n\\n    function getMultiplier(uint256 _amount, uint256 _duration) external view returns (uint256);\\n\\n    function getDurationGroup(uint256 _duration) external view returns (uint256);\\n\\n    function getDurationMultiplier(uint256 _duration) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/staking/interfaces/IPenaltyFee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\ninterface IPenaltyFee {\\n    /**\\n     * Calculates the penalty fee for the given _amount for a specific _beneficiary.\\n     */\\n    function calculate(\\n        uint256 _amount,\\n        uint256 _duration,\\n        address _pool\\n    ) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/staking/interfaces/IStakingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\nimport { IMultiplier } from \\\"../interfaces/IMultiplier.sol\\\";\\nimport { IPenaltyFee } from \\\"../interfaces/IPenaltyFee.sol\\\";\\n\\ninterface IStakingPool {\\n    struct StakingInfo {\\n        uint256 stakedAmount; // amount of the stake\\n        uint256 minimumStakeTimestamp; // timestamp of the minimum stake\\n        uint256 duration; // in seconds\\n        uint256 rewardPerTokenPaid; // Reward per token paid\\n        uint256 rewards; // rewards to be claimed\\n    }\\n\\n    function rewardsMultiplier() external view returns (IMultiplier);\\n\\n    function penaltyFeeCalculator() external view returns (IPenaltyFee);\\n\\n    event Staked(address indexed user, uint256 stakeNumber, uint256 amount);\\n    event Unstaked(address indexed user, uint256 stakeNumber, uint256 amount);\\n    event RewardPaid(address indexed user, uint256 stakeNumber, uint256 reward);\\n}\\n\"\r\n    },\r\n    \"contracts/staking/penalty/PenaltyFee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\nimport { IMultiplier } from \\\"../interfaces/IMultiplier.sol\\\";\\nimport { IPenaltyFee } from \\\"../interfaces/IPenaltyFee.sol\\\";\\nimport { IStakingPool } from \\\"../interfaces/IStakingPool.sol\\\";\\n\\ncontract PenaltyFee is IPenaltyFee {\\n    uint256 public constant MULTIPLIER_BASIS = 1e4;\\n    uint256[] public penaltyFeePerGroup;\\n\\n    constructor(uint256[] memory _penaltyFeePerGroup) {\\n        for (uint256 i = 0; i < _penaltyFeePerGroup.length; i++) {\\n            require(_penaltyFeePerGroup[i] < MULTIPLIER_BASIS, \\\"PenaltyFee::constructor: penaltyBasis >= MAX_ALLOWED_PENALTY\\\");\\n        }\\n        penaltyFeePerGroup = _penaltyFeePerGroup;\\n    }\\n\\n    function calculate(\\n        uint256 _amount,\\n        uint256 _duration,\\n        address _pool\\n    ) external view override returns (uint256) {\\n        IMultiplier rewardsMultiplier = IStakingPool(_pool).rewardsMultiplier();\\n        uint256 group = rewardsMultiplier.getDurationGroup(_duration);\\n        return (_amount * penaltyFeePerGroup[group]) / MULTIPLIER_BASIS;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_penaltyFeePerGroup\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"MULTIPLIER_BASIS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"calculate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"penaltyFeePerGroup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PenaltyFee", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000000005dc00000000000000000000000000000000000000000000000000000000000007d00000000000000000000000000000000000000000000000000000000000000bb8", "EVMVersion": "istanbul", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}