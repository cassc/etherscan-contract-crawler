{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n\t/**\r\n\t * @dev Returns the addition of two unsigned integers, reverting on overflow.\r\n\t *\r\n\t * Counterpart to Solidity's `+` operator.\r\n\t *\r\n\t * Requirements:\r\n\t * - Addition cannot overflow.\r\n\t */\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c;\r\n\t\tunchecked {\r\n\t\t\tc = a + b;\r\n\t\t}\r\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\r\n\t *\r\n\t * Counterpart to Solidity's `+` operator.\r\n\t *\r\n\t * Requirements:\r\n\t * - Addition cannot overflow.\r\n\t */\r\n\tfunction add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n\t\tuint256 c;\r\n\t\tunchecked {\r\n\t\t\tc = a + b;\r\n\t\t}\r\n\t\trequire(c >= a, errorMessage);\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\r\n\t *\r\n\t * Counterpart to Solidity's `-` operator.\r\n\t *\r\n\t * Requirements:\r\n\t * - Subtraction cannot underflow.\r\n\t */\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn sub(a, b, \"SafeMath: subtraction underflow\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\r\n\t *\r\n\t * Counterpart to Solidity's `-` operator.\r\n\t *\r\n\t * Requirements:\r\n\t * - Subtraction cannot underflow.\r\n\t */\r\n\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n\t\trequire(b <= a, errorMessage);\r\n\t\tuint256 c = a - b;\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n\t *\r\n\t * Counterpart to Solidity's `*` operator.\r\n\t *\r\n\t * Requirements:\r\n\t * - Multiplication cannot overflow.\r\n\t */\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n\t\t// benefit is lost if 'b' is also tested.\r\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint256 c;\r\n\t\tunchecked {\r\n\t\t\tc = a * b;\r\n\t\t}\r\n\t\trequire(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n\t *\r\n\t * Counterpart to Solidity's `*` operator.\r\n\t *\r\n\t * Requirements:\r\n\t * - Multiplication cannot overflow.\r\n\t */\r\n\tfunction mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n\t\t// benefit is lost if 'b' is also tested.\r\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint256 c;\r\n\t\tunchecked {\r\n\t\t\tc = a * b;\r\n\t\t}\r\n\t\trequire(c / a == b, errorMessage);\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the integer division of two unsigned integers.\r\n\t * Reverts on division by zero. The result is rounded towards zero.\r\n\t *\r\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n\t * uses an invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn div(a, b, \"SafeMath: division by zero\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the integer division of two unsigned integers.\r\n\t * Reverts with custom message on division by zero. The result is rounded towards zero.\r\n\t *\r\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n\t * uses an invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n\t\t// Solidity only automatically asserts when dividing by 0\r\n\t\trequire(b > 0, errorMessage);\r\n\t\tuint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n\t * Reverts when dividing by zero.\r\n\t *\r\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n\t * invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn mod(a, b, \"SafeMath: modulo by zero\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n\t * Reverts with custom message when dividing by zero.\r\n\t *\r\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n\t * invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n\t\trequire(b != 0, errorMessage);\r\n\t\treturn a % b;\r\n\t}\r\n}\r\n\r\ncontract Timelock {\r\n\tusing SafeMath for uint;\r\n\r\n\tevent NewAdmin(address indexed newAdmin);\r\n\tevent NewPendingAdmin(address indexed newPendingAdmin);\r\n\tevent NewDelay(uint indexed newDelay);\r\n\tevent CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\r\n\tevent ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\r\n\tevent QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\r\n\r\n\tuint public constant GRACE_PERIOD = 14 days;\r\n\tuint public constant MINIMUM_DELAY = 1 days;\r\n\tuint public constant MAXIMUM_DELAY = 30 days;\r\n\r\n\taddress public admin;\r\n\taddress public pendingAdmin;\r\n\tuint public delay;\r\n\r\n\tmapping(bytes32 => bool) public queuedTransactions;\r\n\r\n\tconstructor(address admin_, uint delay_) public {\r\n\t\trequire(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\r\n\t\trequire(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\r\n\r\n\t\tadmin = admin_;\r\n\t\tdelay = delay_;\r\n\t}\r\n\r\n\treceive() external payable {}\r\n\r\n\tfunction setDelay(uint delay_) public {\r\n\t\trequire(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\r\n\t\trequire(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\r\n\t\trequire(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\r\n\t\tdelay = delay_;\r\n\r\n\t\temit NewDelay(delay);\r\n\t}\r\n\r\n\tfunction acceptAdmin() public {\r\n\t\trequire(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\r\n\t\tadmin = msg.sender;\r\n\t\tpendingAdmin = address(0);\r\n\r\n\t\temit NewAdmin(admin);\r\n\t}\r\n\r\n\tfunction setPendingAdmin(address pendingAdmin_) public {\r\n\t\trequire(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\r\n\t\tpendingAdmin = pendingAdmin_;\r\n\r\n\t\temit NewPendingAdmin(pendingAdmin);\r\n\t}\r\n\r\n\tfunction queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\r\n\t\trequire(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\r\n\t\trequire(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\r\n\r\n\t\tbytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n\t\tqueuedTransactions[txHash] = true;\r\n\r\n\t\temit QueueTransaction(txHash, target, value, signature, data, eta);\r\n\t\treturn txHash;\r\n\t}\r\n\r\n\tfunction cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\r\n\t\trequire(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\r\n\r\n\t\tbytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n\t\tqueuedTransactions[txHash] = false;\r\n\r\n\t\temit CancelTransaction(txHash, target, value, signature, data, eta);\r\n\t}\r\n\r\n\tfunction executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\r\n\t\trequire(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\r\n\r\n\t\tbytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n\t\trequire(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\r\n\t\trequire(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\r\n\t\trequire(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\r\n\r\n\t\tqueuedTransactions[txHash] = false;\r\n\r\n\t\tbytes memory callData;\r\n\r\n\t\tif (bytes(signature).length == 0) {\r\n\t\t\tcallData = data;\r\n\t\t} else {\r\n\t\t\tcallData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\r\n\t\t}\r\n\r\n\t\t// solium-disable-next-line security/no-call-value\r\n\t\t(bool success, bytes memory returnData) = target.call{value: value}(callData);\r\n\t\trequire(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\r\n\r\n\t\temit ExecuteTransaction(txHash, target, value, signature, data, eta);\r\n\r\n\t\treturn returnData;\r\n\t}\r\n\r\n\tfunction getBlockTimestamp() internal view returns (uint) {\r\n\t\t// solium-disable-next-line security/no-block-members\r\n\t\treturn block.timestamp;\r\n\t}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"delay_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"txHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"CancelTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"txHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"ExecuteTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newDelay\",\"type\":\"uint256\"}],\"name\":\"NewDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"NewPendingAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"txHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"QueueTransaction\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"GRACE_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAXIMUM_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINIMUM_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"cancelTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"executeTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"queueTransaction\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"queuedTransactions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"delay_\",\"type\":\"uint256\"}],\"name\":\"setDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingAdmin_\",\"type\":\"address\"}],\"name\":\"setPendingAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Timelock", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000005bacb1d4fcefb11da92c05c60d1ddcded2215883000000000000000000000000000000000000000000000000000000000002a300", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bec91c23046254b73bb33d8ee219e54bf9cf8237555273b361e390e843756f00"}