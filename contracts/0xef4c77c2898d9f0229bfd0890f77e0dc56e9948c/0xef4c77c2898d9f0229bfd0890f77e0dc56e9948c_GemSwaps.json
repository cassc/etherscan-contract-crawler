{"SourceCode": "// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n\r\n// File: swappingGem.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface IERC20 {\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IERC20Burnable {\r\n    function burnFrom(address account, uint256 amount) external;\r\n}\r\n\r\ncontract GemSwaps is ReentrancyGuard {\r\n    IERC20 public mGem;\r\n    IERC20 public Mandox;\r\n    uint256 public exchangeRate;\r\n    address public owner;\r\n\r\n    constructor(address _mGem, address _Mandox, uint256 _exchangeRate) {\r\n        mGem = IERC20(_mGem);\r\n        Mandox = IERC20(_Mandox);\r\n        exchangeRate = _exchangeRate;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function setExchangeRate(uint256 _newRate) external onlyOwner {\r\n        exchangeRate = _newRate;\r\n    }\r\n\r\n\r\nfunction exchangemGemForMandox(uint256 _amountOfmGem) external nonReentrant {\r\n    // Convert the amount from whole tokens to the smallest unit\r\n    uint256 mGemAmount = _amountOfmGem * 10**9;\r\n\r\n    require(mGem.allowance(msg.sender, address(this)) >= mGemAmount, \"Contract needs allowance to burn mGEM\");\r\n    require(Mandox.balanceOf(address(this)) >= mGemAmount * exchangeRate, \"Insufficient Mandox balance in contract\");\r\n\r\n    // Burn mGem\r\n    IERC20Burnable(address(mGem)).burnFrom(msg.sender, mGemAmount);\r\n\r\n    // Calculate the Mandox transfer amount\r\n    uint256 mandoxTransferAmount = mGemAmount * exchangeRate;\r\n\r\n    // Transfer Mandox to the user\r\n    require(Mandox.transfer(msg.sender, mandoxTransferAmount), \"Transfer of Mandox failed\");\r\n}\r\n\r\n\r\n\r\n    // Function to withdraw ERC-20 tokens\r\n    function rescueTokens(address _tokenAddr) external onlyOwner {\r\n        IERC20 token = IERC20(_tokenAddr);\r\n        uint256 tokenBalance = token.balanceOf(address(this));\r\n        require(tokenBalance > 0, \"No tokens to rescue\");\r\n        token.transfer(owner, tokenBalance);\r\n    }\r\n\r\n    // Function to withdraw Ether\r\n    function rescueEther() external onlyOwner {\r\n        uint256 etherBalance = address(this).balance;\r\n        require(etherBalance > 0, \"No Ether to rescue\");\r\n        payable(owner).transfer(etherBalance);\r\n    }\r\n\r\n    // Fallback function\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mGem\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_Mandox\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_exchangeRate\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Mandox\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOfmGem\",\"type\":\"uint256\"}],\"name\":\"exchangemGemForMandox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mGem\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"rescueTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newRate\",\"type\":\"uint256\"}],\"name\":\"setExchangeRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GemSwaps", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "00000000000000000000000053b2f6bebaa82acad31afdd93b1236c3f4f2f3100000000000000000000000007a8adcf432ebcc2311b955d176ee4bfed13bb9a70000000000000000000000000000000000000000000000000000000000000032", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4b766f50e221bc0bae7e3cf723fc1b2e34ac58748aaf476fcab00e5050beffa4"}