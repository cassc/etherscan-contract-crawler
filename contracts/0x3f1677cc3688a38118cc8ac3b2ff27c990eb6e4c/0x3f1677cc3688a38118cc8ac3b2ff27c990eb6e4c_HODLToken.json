{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/HODLToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n// HODL is a decentralised reserve currency\\n// Telegram: https://t.me/StakerTechPortal\\n// Website: https://staker.tech\\n// Twitter: https://twitter.com/StakerTechHODL\\n// Docs: https://docs.staker.tech\\n//\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {WETH} from \\\"solmate/tokens/WETH.sol\\\";\\nimport {Owned} from \\\"solmate/auth/Owned.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport {IUniswapV2Factory} from \\\"./interfaces/IUniswapV2Factory.sol\\\";\\nimport {IUniswapV2Router} from \\\"./interfaces/IUniswapV2Router.sol\\\";\\n\\ncontract HODLToken is ERC20, Owned {\\n    using SafeTransferLib for ERC20;\\n    struct User {\\n        bool isBlacklisted;\\n        bool isAutomatedMarketMaker;\\n        bool isExcludedFromFees;\\n        bool isExcludedFromMaxTransactionAmount;\\n    }\\n\\n    struct Fees {\\n        uint8 buy;\\n        uint8 sell;\\n        uint8 liquidity;\\n        uint8 development;\\n        uint8 staking;\\n    }\\n\\n    struct Settings {\\n        bool limitsInEffect;\\n        bool swapEnabled;\\n        bool blacklistRenounced;\\n        bool feeChangeRenounced;\\n        bool tradingActive;\\n        /// @dev Upon enabling trading, record the end block for bot protection fee\\n        /// @dev This fee is a 90% fee that is reduced by 5% every block for 18 blocks.\\n        uint216 endBlock;\\n    }\\n\\n    uint256 public constant MAX_SUPPLY = 10_000_000 * 1e18;\\n    uint256 public constant MIN_SWAP_AMOUNT = MAX_SUPPLY / 100_000; // 0.001%\\n    uint256 public constant MAX_SWAP_AMOUNT = (MAX_SUPPLY * 5) / 1_000; // 0.5%\\n    uint256 public exitTaxRate;\\n\\n    IUniswapV2Router public immutable uniswapV2Router;\\n    address public immutable uniswapV2Pair;\\n    address public immutable developmentWallet;\\n    address public stakingAddress;\\n\\n    uint256 public maxTransactionAmount;\\n    uint256 public swapTokensAtAmount;\\n    uint256 public maxWallet;\\n    uint256 public tokensForBotProtection;\\n\\n    Fees public feeAmounts;\\n\\n    bool private _swapping;\\n\\n    Settings private settings =\\n        Settings({\\n            limitsInEffect: true,\\n            swapEnabled: true,\\n            blacklistRenounced: false,\\n            feeChangeRenounced: false,\\n            tradingActive: false,\\n            endBlock: uint216(0)\\n        });\\n\\n    mapping(address => User) private _users;\\n    mapping(address => uint256) private _lastBuyTimestamp;\\n    address private wethAddress;\\n\\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\n    event ExcludeFromMaxTransaction(address indexed account, bool isExcluded);\\n    event FailedSwapBackTransfer(address indexed destination, uint256 amount);\\n    event MaxTransactionAmountUpdated(uint256 newAmount, uint256 oldAmount);\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool value);\\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 ethReceived);\\n    event TransferToStaking(uint256 amount);\\n    event SwapTokensAtAmountUpdated(uint256 newAmount, uint256 oldAmount);\\n\\n    error HODL__BlacklistModificationDisabled();\\n    error HODL__BuyAmountGreaterThanMax();\\n    error HODL__CannotBlacklistLPPair();\\n    error HODL__CannotBlacklistRouter();\\n    error HODL__CannotRemovePairFromAMMs();\\n    error HODL__CannotTransferFromAddressZero();\\n    error HODL__CannotTransferToAddressZero();\\n    error HODL__ErrorWithdrawingEth();\\n    error HODL__FeeChangeRenounced();\\n    error HODL__MaxFeeFivePercent();\\n    error HODL__MaxTransactionTooLow();\\n    error HODL__MaxWalletAmountExceeded();\\n    error HODL__MaxWalletAmountTooLow();\\n    error HODL__OnlyOwner();\\n    error HODL__ReceiverBlacklisted();\\n    error HODL__ReceiverCannotBeAddressZero();\\n    error HODL__SellAmountGreaterThanMax();\\n    error HODL__SenderBlacklisted();\\n    error HODL__StuckEthWithdrawError();\\n    error HODL__SwapAmountGreaterThanMaximum();\\n    error HODL__SwapAmountLowerThanMinimum();\\n    error HODL__TokenAddressCannotBeAddressZero();\\n    error HODL__TradingNotActive();\\n\\n    constructor(\\n        address routerAddress,\\n        address devWallet,\\n        uint256 _exitTaxRate\\n    ) ERC20(\\\"HODL\\\", \\\"HODL\\\", 18) Owned(msg.sender) {\\n        developmentWallet = devWallet;\\n        exitTaxRate = _exitTaxRate;\\n        IUniswapV2Router _uniswapV2Router = IUniswapV2Router(routerAddress);\\n        uniswapV2Router = _uniswapV2Router;\\n        wethAddress = uniswapV2Router.WETH();\\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\\n            .createPair(address(this), _uniswapV2Router.WETH());\\n\\n        maxTransactionAmount = MAX_SUPPLY / 200; // 0.5%\\n        maxWallet = MAX_SUPPLY / 100; // 1%\\n        swapTokensAtAmount = (MAX_SUPPLY * 5) / 10_000; // 0.05%\\n        feeAmounts = Fees({\\n            buy: 5,\\n            sell: 5,\\n            liquidity: 20,\\n            development: 30,\\n            staking: 50\\n        });\\n\\n        _users[msg.sender] = User({\\n            isExcludedFromFees: true,\\n            isExcludedFromMaxTransactionAmount: true,\\n            isAutomatedMarketMaker: false,\\n            isBlacklisted: false\\n        });\\n\\n        _users[address(this)] = User({\\n            isExcludedFromFees: true,\\n            isExcludedFromMaxTransactionAmount: true,\\n            isAutomatedMarketMaker: false,\\n            isBlacklisted: false\\n        });\\n\\n        _users[address(uniswapV2Router)] = User({\\n            isExcludedFromMaxTransactionAmount: true,\\n            isAutomatedMarketMaker: false,\\n            isExcludedFromFees: false,\\n            isBlacklisted: false\\n        });\\n\\n        _users[address(uniswapV2Pair)] = User({\\n            isExcludedFromMaxTransactionAmount: true,\\n            isAutomatedMarketMaker: true,\\n            isExcludedFromFees: false,\\n            isBlacklisted: false\\n        });\\n\\n        _mint(msg.sender, MAX_SUPPLY);\\n        _approve(address(uniswapV2Router), type(uint256).max);\\n        _lastBuyTimestamp[devWallet] = block.timestamp;\\n    }\\n\\n    receive() external payable {}\\n\\n    function _requireIsOwner() internal view {\\n        require(msg.sender == owner, \\\"!owner\\\");\\n    }\\n\\n    function burn(address from, uint256 amount) external {\\n        _burn(from, amount);\\n    }\\n\\n    function setStakingAddress(address _staking) external {\\n        _requireIsOwner();\\n        stakingAddress = _staking;\\n    }\\n\\n    function updateExitTaxRate(uint256 _exitTaxRate) external {\\n        _requireIsOwner();\\n        exitTaxRate = _exitTaxRate;\\n    }\\n\\n    function updateFees(Fees memory newFees) external {\\n        _requireIsOwner();\\n        feeAmounts = newFees;\\n    }\\n\\n    function enableTrading() external {\\n        _requireIsOwner();\\n        settings.endBlock = uint216(block.number) + 20;\\n        settings.tradingActive = true;\\n    }\\n\\n    function removeLimits() external {\\n        _requireIsOwner();\\n        settings.limitsInEffect = false;\\n    }\\n\\n    // change the minimum amount of tokens to sell from fees\\n    function updateSwapTokensAtAmount(uint256 newAmount) external {\\n        _requireIsOwner();\\n        if (newAmount < MIN_SWAP_AMOUNT) {\\n            revert HODL__SwapAmountLowerThanMinimum();\\n        }\\n        if (newAmount > MAX_SWAP_AMOUNT) {\\n            revert HODL__SwapAmountGreaterThanMaximum();\\n        }\\n        uint256 oldSwapAmount = swapTokensAtAmount;\\n        swapTokensAtAmount = newAmount;\\n        emit SwapTokensAtAmountUpdated(newAmount, oldSwapAmount);\\n    }\\n\\n    function updateMaxTransactionAmount(uint256 newAmount) external {\\n        _requireIsOwner();\\n        if (newAmount < (MAX_SUPPLY * 5) / 1000) {\\n            revert HODL__MaxTransactionTooLow();\\n        }\\n        uint256 oldMaxTransactionAmount = maxTransactionAmount;\\n        maxTransactionAmount = newAmount;\\n        emit MaxTransactionAmountUpdated(newAmount, oldMaxTransactionAmount);\\n    }\\n\\n    function excludeFromFees(address account, bool excluded) external {\\n        _requireIsOwner();\\n        _users[account].isExcludedFromFees = excluded;\\n        emit ExcludeFromFees(account, excluded);\\n    }\\n\\n    function excludeFromMaxTransaction(\\n        address account,\\n        bool isExcluded\\n    ) external {\\n        _requireIsOwner();\\n        _users[account].isExcludedFromMaxTransactionAmount = isExcluded;\\n        emit ExcludeFromMaxTransaction(account, isExcluded);\\n    }\\n\\n    function setAutomatedMarketMakerPair(address pair, bool value) external {\\n        _requireIsOwner();\\n        if (pair == uniswapV2Pair) {\\n            revert HODL__CannotRemovePairFromAMMs();\\n        }\\n\\n        _users[pair].isAutomatedMarketMaker = value;\\n        emit SetAutomatedMarketMakerPair(pair, value);\\n    }\\n\\n    function renounceBlacklist() external {\\n        _requireIsOwner();\\n        settings.blacklistRenounced = true;\\n    }\\n\\n    function blacklist(address account) external {\\n        _requireIsOwner();\\n        if (settings.blacklistRenounced) {\\n            revert HODL__BlacklistModificationDisabled();\\n        }\\n        if (account == uniswapV2Pair) {\\n            revert HODL__CannotBlacklistLPPair();\\n        }\\n        if (account == address(uniswapV2Router)) {\\n            revert HODL__CannotBlacklistRouter();\\n        }\\n        _users[account].isBlacklisted = true;\\n    }\\n\\n    // @dev unblacklist address; not affected by blacklistRenounced incase team wants to unblacklist v3 pools down the\\n    function unblacklist(address account) external {\\n        _requireIsOwner();\\n        _users[account].isBlacklisted = false;\\n    }\\n\\n    function isExcludedFromFees(address account) external view returns (bool) {\\n        return _users[account].isExcludedFromFees;\\n    }\\n\\n    function isExcludedFromMaxTransactionAmount(\\n        address account\\n    ) external view returns (bool) {\\n        return _users[account].isExcludedFromMaxTransactionAmount;\\n    }\\n\\n    function isAutomatedMarketMakerPair(\\n        address pair\\n    ) external view returns (bool) {\\n        return _users[pair].isAutomatedMarketMaker;\\n    }\\n\\n    function isBlacklisted(address account) external view returns (bool) {\\n        return _users[account].isBlacklisted;\\n    }\\n\\n    function isSwapEnabled() external view returns (bool) {\\n        return settings.swapEnabled;\\n    }\\n\\n    function isBlacklistRenounced() external view returns (bool) {\\n        return settings.blacklistRenounced;\\n    }\\n\\n    function isFeeChangeRenounced() external view returns (bool) {\\n        return settings.feeChangeRenounced;\\n    }\\n\\n    function isTradingActive() external view returns (bool) {\\n        return settings.tradingActive;\\n    }\\n\\n    function isLimitInEffect() external view returns (bool) {\\n        return settings.limitsInEffect;\\n    }\\n\\n    function transfer(\\n        address to,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _transfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n        if (allowed != type(uint256).max) {\\n            allowance[from][msg.sender] = allowed - amount;\\n        }\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        User memory fromData = _users[from];\\n        User memory toData = _users[to];\\n        Settings memory settingCache = settings;\\n\\n        if (!settingCache.tradingActive) {\\n            if (!fromData.isExcludedFromFees) {\\n                if (!toData.isExcludedFromFees) {\\n                    revert HODL__TradingNotActive();\\n                }\\n            }\\n        }\\n\\n        // Apply blacklist protection\\n        if (fromData.isBlacklisted) {\\n            revert HODL__SenderBlacklisted();\\n        }\\n        if (toData.isBlacklisted) {\\n            revert HODL__ReceiverBlacklisted();\\n        }\\n\\n        // If zero amount, continue\\n        if (amount == 0) {\\n            return true;\\n        }\\n\\n        bool excludedFromFees = fromData.isExcludedFromFees ||\\n            toData.isExcludedFromFees;\\n\\n        // Cache transaction type for reference.\\n        // 1 = Buy\\n        // 2 = Sell\\n        // 3 = Transfer\\n        uint8 txType = 3;\\n\\n        if (fromData.isAutomatedMarketMaker) {\\n            // Buys originate from the AMM pair\\n            txType = 1;\\n        } else if (toData.isAutomatedMarketMaker) {\\n            // Sells send funds to AMM pair\\n            txType = 2;\\n        }\\n\\n        if (!_swapping) {\\n            if (settingCache.limitsInEffect) {\\n                //when buy\\n                if (txType == 1 && !toData.isExcludedFromMaxTransactionAmount) {\\n                    if (amount > maxTransactionAmount) {\\n                        revert HODL__BuyAmountGreaterThanMax();\\n                    }\\n                    if (amount + this.balanceOf(to) > maxWallet) {\\n                        revert HODL__MaxWalletAmountExceeded();\\n                    }\\n                }\\n                //when sell\\n                else if (\\n                    txType == 2 && !fromData.isExcludedFromMaxTransactionAmount\\n                ) {\\n                    if (amount > maxTransactionAmount) {\\n                        revert HODL__SellAmountGreaterThanMax();\\n                    }\\n                } else if (!toData.isExcludedFromMaxTransactionAmount) {\\n                    if (amount + this.balanceOf(to) > maxWallet) {\\n                        revert HODL__MaxWalletAmountExceeded();\\n                    }\\n                }\\n            }\\n\\n            if (settingCache.swapEnabled) {\\n                // Only sells will trigger the fee swap\\n                if (txType == 2) {\\n                    if (this.balanceOf(address(this)) >= swapTokensAtAmount) {\\n                        _swapping = true;\\n                        _swapBack();\\n                        _swapping = false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (txType < 3) {\\n            bool takeFee = !_swapping;\\n\\n            // if any account belongs to _isExcludedFromFee account then remove the fee\\n            if (excludedFromFees) {\\n                takeFee = false;\\n            }\\n            uint256 fees = 0;\\n            // only take fees on buys/sells, do not take on wallet transfers\\n            if (takeFee) {\\n                Fees memory feeCache = feeAmounts;\\n                // on sell\\n\\n                if (block.number < settingCache.endBlock) {\\n                    uint256 blocksLeft = settingCache.endBlock - block.number;\\n                    uint256 botFeeMultiplier = 95;\\n\\n                    // Apply sniper protection - first 18 blocks have a fee reduced 5% each block.\\n                    if (blocksLeft < 19) {\\n                        botFeeMultiplier -= (5 * (19 - blocksLeft));\\n                    }\\n                    uint256 botFee = (amount * botFeeMultiplier) / 100;\\n                    _doTransfer(from, owner, fees);\\n                    amount -= botFee;\\n                    tokensForBotProtection += botFee;\\n                } else {\\n                    if (txType == 2) {\\n                        if (feeCache.sell > 0) {\\n                            uint256 feePercentage = getExitTax(from);\\n                            fees = (amount * feePercentage) / 100;\\n                        }\\n                    } else if (txType == 1) {\\n                        if (feeCache.buy > 0) {\\n                            fees = (amount * feeCache.buy) / 100;\\n                            _lastBuyTimestamp[from] = block.timestamp;\\n                        }\\n                    }\\n                }\\n\\n                amount -= fees;\\n\\n                if (fees > 0) {\\n                    _doTransfer(from, address(this), fees);\\n                }\\n            }\\n        }\\n\\n        // Update last buy timestamp when to anotheraddress\\n        if (txType == 3) {\\n            if (_lastBuyTimestamp[from] > _lastBuyTimestamp[to]) {\\n                _lastBuyTimestamp[to] = _lastBuyTimestamp[from];\\n            }\\n        }\\n\\n        _doTransfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    function getExitTax(address from) public view returns (uint256) {\\n        // Scale exit tax liearly from exitTaxRate% to 5%\\n        uint256 lastBuy = _lastBuyTimestamp[from];\\n        if (lastBuy == 0) {\\n            return exitTaxRate;\\n        }\\n        uint256 timeSinceLastBuy = block.timestamp - lastBuy;\\n        uint256 percentageOfDay = (timeSinceLastBuy * 1000) / 8 hours;\\n        if (percentageOfDay >= 1000) {\\n            return 5;\\n        }\\n        uint256 exitTax = exitTaxRate -\\n            ((exitTaxRate * percentageOfDay) / 1000);\\n        return exitTax;\\n    }\\n\\n    function getLastBuyTimestamp(address from) public view returns (uint256) {\\n        return _lastBuyTimestamp[from];\\n    }\\n\\n    function _swapTokensForEth(uint256 tokenAmount) internal {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    function _addLiquidity(uint256 tokenAmount, uint256 ethAmount) internal {\\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\\n            address(this),\\n            tokenAmount,\\n            0, // slippage is unavoidable\\n            0, // slippage is unavoidable\\n            developmentWallet,\\n            block.timestamp\\n        );\\n    }\\n\\n    function _doTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    function _swapBack() internal {\\n        // Cache values\\n        uint256 contractBalance = this.balanceOf(address(this));\\n        Fees memory feeCache = feeAmounts;\\n\\n        if (contractBalance == 0) {\\n            return;\\n        }\\n\\n        // Prevent too many tokens from being swapped\\n        uint256 maxAmount = swapTokensAtAmount * 20;\\n        if (contractBalance > maxAmount) {\\n            contractBalance = maxAmount;\\n        }\\n\\n        uint256 liquidityAmount = (contractBalance * feeCache.liquidity) / 100;\\n\\n        // Halve the amount of liquidity tokens\\n        uint256 liquidityTokens = liquidityAmount - (liquidityAmount / 2);\\n\\n        uint256 initialETHBalance = address(this).balance;\\n        _swapTokensForEth(liquidityTokens);\\n        uint256 ethForLiquidity = address(this).balance - initialETHBalance;\\n\\n        if (liquidityTokens > 0 && ethForLiquidity > 0) {\\n            _addLiquidity(liquidityTokens, ethForLiquidity);\\n            emit SwapAndLiquify(liquidityTokens, ethForLiquidity);\\n        }\\n\\n        uint256 amountToSwapForETH = contractBalance - liquidityAmount;\\n        _swapTokensForEth(amountToSwapForETH);\\n\\n        uint256 contractEthAmount = address(this).balance;\\n        uint256 initialTotalEth = contractEthAmount + (ethForLiquidity * 2);\\n\\n        uint256 developmentEthAmount = (initialTotalEth *\\n            feeCache.development) / 100;\\n        (bool success, ) = address(developmentWallet).call{\\n            value: developmentEthAmount\\n        }(\\\"\\\");\\n        require(success);\\n\\n        uint256 stakingAmount = contractEthAmount - developmentEthAmount;\\n        WETH(payable(wethAddress)).deposit{value: stakingAmount}();\\n        ERC20(wethAddress).safeTransfer(stakingAddress, stakingAmount);\\n        emit TransferToStaking(stakingAmount);\\n    }\\n\\n    function _approve(address spender, uint256 amount) internal onlyOwner {\\n        allowance[address(this)][spender] = amount;\\n        emit Approval(address(this), spender, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/WETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"./ERC20.sol\\\";\\n\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\n\\n/// @notice Minimalist and modern Wrapped Ether implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/WETH.sol)\\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\\ncontract WETH is ERC20(\\\"Wrapped Ether\\\", \\\"WETH\\\", 18) {\\n    using SafeTransferLib for address;\\n\\n    event Deposit(address indexed from, uint256 amount);\\n\\n    event Withdrawal(address indexed to, uint256 amount);\\n\\n    function deposit() public payable virtual {\\n        _mint(msg.sender, msg.value);\\n\\n        emit Deposit(msg.sender, msg.value);\\n    }\\n\\n    function withdraw(uint256 amount) public virtual {\\n        _burn(msg.sender, amount);\\n\\n        emit Withdrawal(msg.sender, amount);\\n\\n        msg.sender.safeTransferETH(amount);\\n    }\\n\\n    receive() external payable virtual {\\n        deposit();\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IUniswapV2Factory {\\n    function createPair(\\n        address tokenA,\\n        address tokenB\\n    ) external returns (address pair);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IUniswapV2Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IUniswapV2Router {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@uniswap/=lib/@uniswap/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"routerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"devWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_exitTaxRate\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"HODL__BlacklistModificationDisabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HODL__BuyAmountGreaterThanMax\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HODL__CannotBlacklistLPPair\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HODL__CannotBlacklistRouter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HODL__CannotRemovePairFromAMMs\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HODL__CannotTransferFromAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HODL__CannotTransferToAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HODL__ErrorWithdrawingEth\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HODL__FeeChangeRenounced\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HODL__MaxFeeFivePercent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HODL__MaxTransactionTooLow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HODL__MaxWalletAmountExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HODL__MaxWalletAmountTooLow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HODL__OnlyOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HODL__ReceiverBlacklisted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HODL__ReceiverCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HODL__SellAmountGreaterThanMax\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HODL__SenderBlacklisted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HODL__StuckEthWithdrawError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HODL__SwapAmountGreaterThanMaximum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HODL__SwapAmountLowerThanMinimum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HODL__TokenAddressCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HODL__TradingNotActive\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromMaxTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FailedSwapBackTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldAmount\",\"type\":\"uint256\"}],\"name\":\"MaxTransactionAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldAmount\",\"type\":\"uint256\"}],\"name\":\"SwapTokensAtAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferToStaking\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SWAP_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_SWAP_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developmentWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"excludeFromMaxTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exitTaxRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeAmounts\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"buy\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sell\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"liquidity\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"development\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"staking\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"getExitTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"getLastBuyTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"isAutomatedMarketMakerPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isBlacklistRenounced\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromMaxTransactionAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFeeChangeRenounced\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLimitInEffect\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSwapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTradingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransactionAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staking\",\"type\":\"address\"}],\"name\":\"setStakingAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensForBotProtection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unblacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_exitTaxRate\",\"type\":\"uint256\"}],\"name\":\"updateExitTaxRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"buy\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sell\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"liquidity\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"development\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"staking\",\"type\":\"uint8\"}],\"internalType\":\"struct HODLToken.Fees\",\"name\":\"newFees\",\"type\":\"tuple\"}],\"name\":\"updateFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"updateMaxTransactionAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"updateSwapTokensAtAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "HODLToken", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d00000000000000000000000058899259e93f93ab8ca803a341713d34341cc2a90000000000000000000000000000000000000000000000000000000000000032", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}