{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n    struct InitializableStorage {\\n        /**\\n         * @dev Indicates that the contract has been initialized.\\n         */\\n        uint64 _initialized;\\n        /**\\n         * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n    /**\\n     * @dev The contract is already initialized.\\n     */\\n    error InvalidInitialization();\\n\\n    /**\\n     * @dev The contract is not initializing.\\n     */\\n    error NotInitializing();\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint64 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        // Cache values to avoid duplicated sloads\\n        bool isTopLevelCall = !$._initializing;\\n        uint64 initialized = $._initialized;\\n\\n        // Allowed calls:\\n        // - initialSetup: the contract is not in the initializing state and no previous version was\\n        //                 initialized\\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\\n        //                 current contract is just being deployed\\n        bool initialSetup = initialized == 0 && isTopLevelCall;\\n        bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n        if (!initialSetup && !construction) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = 1;\\n        if (isTopLevelCall) {\\n            $._initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            $._initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint64 version) {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing || $._initialized >= version) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = version;\\n        $._initializing = true;\\n        _;\\n        $._initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n    function _checkInitializing() internal view virtual {\\n        if (!_isInitializing()) {\\n            revert NotInitializing();\\n        }\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing) {\\n            revert InvalidInitialization();\\n        }\\n        if ($._initialized != type(uint64).max) {\\n            $._initialized = type(uint64).max;\\n            emit Initialized(type(uint64).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint64) {\\n        return _getInitializableStorage()._initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _getInitializableStorage()._initializing;\\n    }\\n\\n    /**\\n     * @dev Returns a pointer to the storage namespace.\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n        assembly {\\n            $.slot := INITIALIZABLE_STORAGE\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC1822Proxiable} from \\\"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\\\";\\nimport {ERC1967Utils} from \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\\\";\\nimport {Initializable} from \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\\n     * If the getter returns `\\\"5.0.0\\\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\\n     * during an upgrade.\\n     */\\n    string public constant UPGRADE_INTERFACE_VERSION = \\\"5.0.0\\\";\\n\\n    /**\\n     * @dev The call is from an unauthorized context.\\n     */\\n    error UUPSUnauthorizedCallContext();\\n\\n    /**\\n     * @dev The storage `slot` is unsupported as a UUID.\\n     */\\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        _checkProxy();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        _checkNotDelegated();\\n        _;\\n    }\\n\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data);\\n    }\\n\\n    /**\\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\\n     * See {_onlyProxy}.\\n     */\\n    function _checkProxy() internal view virtual {\\n        if (\\n            address(this) == __self || // Must be called through delegatecall\\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\\n        ) {\\n            revert UUPSUnauthorizedCallContext();\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts if the execution is performed via delegatecall.\\n     * See {notDelegated}.\\n     */\\n    function _checkNotDelegated() internal view virtual {\\n        if (address(this) != __self) {\\n            // Must not be called through delegatecall\\n            revert UUPSUnauthorizedCallContext();\\n        }\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\\n     *\\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\\n     * is expected to be the implementation slot in ERC1967.\\n     *\\n     * Emits an {IERC1967-Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\\n                revert UUPSUnsupportedProxiableUUID(slot);\\n            }\\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\\n        } catch {\\n            // The implementation is not UUPS\\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\\n    struct ReentrancyGuardStorage {\\n        uint256 _status;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.ReentrancyGuard\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\\n\\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\\n        assembly {\\n            $.slot := ReentrancyGuardStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        $._status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if ($._status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        $._status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        $._status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        return $._status == ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {UpgradeableBeacon} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IBeacon} from \\\"../beacon/IBeacon.sol\\\";\\nimport {Address} from \\\"../../utils/Address.sol\\\";\\nimport {StorageSlot} from \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n */\\nlibrary ERC1967Utils {\\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev The `implementation` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidImplementation(address implementation);\\n\\n    /**\\n     * @dev The `admin` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidAdmin(address admin);\\n\\n    /**\\n     * @dev The `beacon` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidBeacon(address beacon);\\n\\n    /**\\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\\n     */\\n    error ERC1967NonPayable();\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        if (newImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(newImplementation);\\n        }\\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        if (newAdmin == address(0)) {\\n            revert ERC1967InvalidAdmin(address(0));\\n        }\\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {IERC1967-AdminChanged} event.\\n     */\\n    function changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.beacon\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        if (newBeacon.code.length == 0) {\\n            revert ERC1967InvalidBeacon(newBeacon);\\n        }\\n\\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\\n\\n        address beaconImplementation = IBeacon(newBeacon).implementation();\\n        if (beaconImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(beaconImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-BeaconUpgraded} event.\\n     *\\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\\n     * efficiency.\\n     */\\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\\n     * if an upgrade doesn't perform an initialization call.\\n     */\\n    function _checkNonPayable() private {\\n        if (msg.value > 0) {\\n            revert ERC1967NonPayable();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length > 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/DN404/DN404.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @title DN404\\r\\n/// @notice DN404 is a hybrid ERC20 and ERC721 implementation that mints\\r\\n/// and burns NFTs based on an account's ERC20 token balance.\\r\\n///\\r\\n/// @author vectorized.eth (@optimizoor)\\r\\n/// @author Quit (@0xQuit)\\r\\n/// @author Michael Amadi (@AmadiMichaels)\\r\\n/// @author cygaar (@0xCygaar)\\r\\n/// @author Thomas (@0xjustadev)\\r\\n/// @author Harrison (@PopPunkOnChain)\\r\\n///\\r\\n/// @dev Note:\\r\\n/// - The ERC721 data is stored in this base DN404 contract, however a\\r\\n///   DN404Mirror contract ***MUST*** be deployed and linked during\\r\\n///   initialization.\\r\\nabstract contract DN404 {\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                           EVENTS                           */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\\r\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\r\\n\\r\\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\r\\n\\r\\n    /// @dev Emitted when `target` sets their skipNFT flag to `status`.\\r\\n    event SkipNFTSet(address indexed target, bool status);\\r\\n\\r\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\r\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\r\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\r\\n\\r\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\r\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\r\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\r\\n\\r\\n    /// @dev `keccak256(bytes(\\\"SkipNFTSet(address,bool)\\\"))`.\\r\\n    uint256 private constant _SKIP_NFT_SET_EVENT_SIGNATURE =\\r\\n        0xb5a1de456fff688115a4f75380060c23c8532d14ff85f687cc871456d6420393;\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                        CUSTOM ERRORS                       */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Thrown when attempting to double-initialize the contract.\\r\\n    error DNAlreadyInitialized();\\r\\n\\r\\n    /// @dev Thrown when attempting to transfer or burn more tokens than sender's balance.\\r\\n    error InsufficientBalance();\\r\\n\\r\\n    /// @dev Thrown when a spender attempts to transfer tokens with an insufficient allowance.\\r\\n    error InsufficientAllowance();\\r\\n\\r\\n    /// @dev Thrown when minting an amount of tokens that would overflow the max tokens.\\r\\n    error TotalSupplyOverflow();\\r\\n\\r\\n    /// @dev The unit cannot be zero.\\r\\n    error UnitIsZero();\\r\\n\\r\\n    /// @dev Thrown when the caller for a fallback NFT function is not the mirror contract.\\r\\n    error SenderNotMirror();\\r\\n\\r\\n    /// @dev Thrown when attempting to transfer tokens to the zero address.\\r\\n    error TransferToZeroAddress();\\r\\n\\r\\n    /// @dev Thrown when the mirror address provided for initialization is the zero address.\\r\\n    error MirrorAddressIsZero();\\r\\n\\r\\n    /// @dev Thrown when the link call to the mirror contract reverts.\\r\\n    error LinkMirrorContractFailed();\\r\\n\\r\\n    /// @dev Thrown when setting an NFT token approval\\r\\n    /// and the caller is not the owner or an approved operator.\\r\\n    error ApprovalCallerNotOwnerNorApproved();\\r\\n\\r\\n    /// @dev Thrown when transferring an NFT\\r\\n    /// and the caller is not the owner or an approved operator.\\r\\n    error TransferCallerNotOwnerNorApproved();\\r\\n\\r\\n    /// @dev Thrown when transferring an NFT and the from address is not the current owner.\\r\\n    error TransferFromIncorrectOwner();\\r\\n\\r\\n    /// @dev Thrown when checking the owner or approved address for a non-existent NFT.\\r\\n    error TokenDoesNotExist();\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                         CONSTANTS                          */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev The flag to denote that the address data is initialized.\\r\\n    uint8 internal constant _ADDRESS_DATA_INITIALIZED_FLAG = 1 << 0;\\r\\n\\r\\n    /// @dev The flag to denote that the address should skip NFTs.\\r\\n    uint8 internal constant _ADDRESS_DATA_SKIP_NFT_FLAG = 1 << 1;\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                          STORAGE                           */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Struct containing an address's token data and settings.\\r\\n    struct AddressData {\\r\\n        // Auxiliary data.\\r\\n        uint88 aux;\\r\\n        // Flags for `initialized` and `skipNFT`.\\r\\n        uint8 flags;\\r\\n        // The alias for the address. Zero means absence of an alias.\\r\\n        uint32 addressAlias;\\r\\n        // The number of NFT tokens.\\r\\n        uint32 ownedLength;\\r\\n        // The token balance in wei.\\r\\n        uint96 balance;\\r\\n    }\\r\\n\\r\\n    /// @dev A uint32 map in storage.\\r\\n    struct Uint32Map {\\r\\n        uint256 spacer;\\r\\n    }\\r\\n\\r\\n    /// @dev A bitmap in storage.\\r\\n    struct Bitmap {\\r\\n        uint256 spacer;\\r\\n    }\\r\\n\\r\\n    /// @dev A struct to wrap a uint256 in storage.\\r\\n    struct Uint256Ref {\\r\\n        uint256 value;\\r\\n    }\\r\\n\\r\\n    /// @dev A mapping of an address pair to a Uint256Ref.\\r\\n    struct AddressPairToUint256RefMap {\\r\\n        uint256 spacer;\\r\\n    }\\r\\n\\r\\n    /// @dev Struct containing the base token contract storage.\\r\\n    struct DN404Storage {\\r\\n        // Current number of address aliases assigned.\\r\\n        uint32 numAliases;\\r\\n        // Next token ID to assign for an NFT mint.\\r\\n        uint32 nextTokenId;\\r\\n        // Total number of IDs in the burned pool.\\r\\n        uint32 burnedPoolSize;\\r\\n        // Total supply of minted NFTs.\\r\\n        uint32 totalNFTSupply;\\r\\n        // Total supply of tokens.\\r\\n        uint96 totalSupply;\\r\\n        // Address of the NFT mirror contract.\\r\\n        address mirrorERC721;\\r\\n        // Mapping of a user alias number to their address.\\r\\n        mapping(uint32 => address) aliasToAddress;\\r\\n        // Mapping of user operator approvals for NFTs.\\r\\n        AddressPairToUint256RefMap operatorApprovals;\\r\\n        // Mapping of NFT token approvals to approved operators.\\r\\n        mapping(uint256 => address) nftApprovals;\\r\\n        // Bitmap of whether an non-zero NFT approval may exist.\\r\\n        Bitmap mayHaveNFTApproval;\\r\\n        // Mapping of user allowances for token spenders.\\r\\n        AddressPairToUint256RefMap allowance;\\r\\n        // Mapping of NFT IDs owned by an address.\\r\\n        mapping(address => Uint32Map) owned;\\r\\n        // The pool of burned NFT IDs.\\r\\n        Uint32Map burnedPool;\\r\\n        // Even indices: owner aliases. Odd indices: owned indices.\\r\\n        Uint32Map oo;\\r\\n        // Mapping of user account AddressData.\\r\\n        mapping(address => AddressData) addressData;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns a storage pointer for DN404Storage.\\r\\n    function _getDN404Storage() internal pure virtual returns (DN404Storage storage $) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // `uint72(bytes9(keccak256(\\\"DN404_STORAGE\\\")))`.\\r\\n            $.slot := 0xa20d6e21d0e5255308 // Truncate to 9 bytes to reduce bytecode size.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                         INITIALIZER                        */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Initializes the DN404 contract with an\\r\\n    /// `initialTokenSupply`, `initialTokenOwner` and `mirror` NFT contract address.\\r\\n    function _initializeDN404(\\r\\n        uint256 initialTokenSupply,\\r\\n        address initialSupplyOwner,\\r\\n        address mirror\\r\\n    ) internal virtual {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n\\r\\n        if ($.nextTokenId != 0) revert DNAlreadyInitialized();\\r\\n\\r\\n        if (mirror == address(0)) revert MirrorAddressIsZero();\\r\\n\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Make the call to link the mirror contract.\\r\\n            mstore(0x00, 0x0f4599e5) // `linkMirrorContract(address)`.\\r\\n            mstore(0x20, caller())\\r\\n            if iszero(and(eq(mload(0x00), 1), call(gas(), mirror, 0, 0x1c, 0x24, 0x00, 0x20))) {\\r\\n                mstore(0x00, 0xd125259c) // `LinkMirrorContractFailed()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n        }\\r\\n\\r\\n        $.nextTokenId = 1;\\r\\n        $.mirrorERC721 = mirror;\\r\\n\\r\\n        if (_unit() == 0) revert UnitIsZero();\\r\\n\\r\\n        if (initialTokenSupply != 0) {\\r\\n            if (initialSupplyOwner == address(0)) revert TransferToZeroAddress();\\r\\n            if (_totalSupplyOverflows(initialTokenSupply)) revert TotalSupplyOverflow();\\r\\n\\r\\n            $.totalSupply = uint96(initialTokenSupply);\\r\\n            AddressData storage initialOwnerAddressData = _addressData(initialSupplyOwner);\\r\\n            initialOwnerAddressData.balance = uint96(initialTokenSupply);\\r\\n\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                // Emit the {Transfer} event.\\r\\n                mstore(0x00, initialTokenSupply)\\r\\n                log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, shl(96, initialSupplyOwner)))\\r\\n            }\\r\\n\\r\\n            _setSkipNFT(initialSupplyOwner, true);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*               BASE UNIT FUNCTION TO OVERRIDE               */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Amount of token balance that is equal to one NFT.\\r\\n    function _unit() internal view virtual returns (uint256) {\\r\\n        return 10 ** 18;\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*               METADATA FUNCTIONS TO OVERRIDE               */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Returns the name of the token.\\r\\n    function name() public view virtual returns (string memory);\\r\\n\\r\\n    /// @dev Returns the symbol of the token.\\r\\n    function symbol() public view virtual returns (string memory);\\r\\n\\r\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id`.\\r\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                      ERC20 OPERATIONS                      */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Returns the decimals places of the token. Always 18.\\r\\n    function decimals() public pure returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the amount of tokens in existence.\\r\\n    function totalSupply() public view virtual returns (uint256) {\\r\\n        return uint256(_getDN404Storage().totalSupply);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the amount of tokens owned by `owner`.\\r\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\r\\n        return _getDN404Storage().addressData[owner].balance;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\\r\\n    function allowance(address owner, address spender) public view returns (uint256) {\\r\\n        return _ref(_getDN404Storage().allowance, owner, spender).value;\\r\\n    }\\r\\n\\r\\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n    ///\\r\\n    /// Emits a {Approval} event.\\r\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @dev Transfer `amount` tokens from the caller to `to`.\\r\\n    ///\\r\\n    /// Will burn sender NFTs if balance after transfer is less than\\r\\n    /// the amount required to support the current NFT balance.\\r\\n    ///\\r\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\r\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\r\\n    /// set to false.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - `from` must at least have `amount`.\\r\\n    ///\\r\\n    /// Emits a {Transfer} event.\\r\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\r\\n        _transfer(msg.sender, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @dev Transfers `amount` tokens from `from` to `to`.\\r\\n    ///\\r\\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\\r\\n    ///\\r\\n    /// Will burn sender NFTs if balance after transfer is less than\\r\\n    /// the amount required to support the current NFT balance.\\r\\n    ///\\r\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\r\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\r\\n    /// set to false.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - `from` must at least have `amount`.\\r\\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\\r\\n    ///\\r\\n    /// Emits a {Transfer} event.\\r\\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\\r\\n        Uint256Ref storage a = _ref(_getDN404Storage().allowance, from, msg.sender);\\r\\n        uint256 allowed = a.value;\\r\\n\\r\\n        if (allowed != type(uint256).max) {\\r\\n            if (amount > allowed) revert InsufficientAllowance();\\r\\n            unchecked {\\r\\n                a.value = allowed - amount;\\r\\n            }\\r\\n        }\\r\\n        _transfer(from, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                  INTERNAL MINT FUNCTIONS                   */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\\r\\n    ///\\r\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\r\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\r\\n    /// set to false.\\r\\n    ///\\r\\n    /// Emits a {Transfer} event.\\r\\n    function _mint(address to, uint256 amount) internal virtual {\\r\\n        if (to == address(0)) revert TransferToZeroAddress();\\r\\n\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n\\r\\n        AddressData storage toAddressData = _addressData(to);\\r\\n\\r\\n        unchecked {\\r\\n            uint256 maxNFTId;\\r\\n            {\\r\\n                uint256 totalSupply_ = uint256($.totalSupply) + amount;\\r\\n                $.totalSupply = uint96(totalSupply_);\\r\\n                uint256 overflows = _toUint(_totalSupplyOverflows(totalSupply_));\\r\\n                if (overflows | _toUint(totalSupply_ < amount) != 0) revert TotalSupplyOverflow();\\r\\n                maxNFTId = totalSupply_ / _unit();\\r\\n            }\\r\\n            uint256 toEnd;\\r\\n            {\\r\\n                uint256 toBalance = uint256(toAddressData.balance) + amount;\\r\\n                toAddressData.balance = uint96(toBalance);\\r\\n                toEnd = toBalance / _unit();\\r\\n            }\\r\\n            if (toAddressData.flags & _ADDRESS_DATA_SKIP_NFT_FLAG == 0) {\\r\\n                Uint32Map storage toOwned = $.owned[to];\\r\\n                Uint32Map storage oo = $.oo;\\r\\n                uint256 toIndex = toAddressData.ownedLength;\\r\\n                _PackedLogs memory packedLogs = _packedLogsMalloc(_zeroFloorSub(toEnd, toIndex));\\r\\n\\r\\n                if (packedLogs.logs.length != 0) {\\r\\n                    _packedLogsSet(packedLogs, to, 0);\\r\\n                    uint256 burnedPoolSize = $.burnedPoolSize;\\r\\n                    uint256 nextTokenId = $.nextTokenId;\\r\\n                    uint32 toAlias = _registerAndResolveAlias(toAddressData, to);\\r\\n                    $.totalNFTSupply += uint32(packedLogs.logs.length);\\r\\n                    toAddressData.ownedLength = uint32(toEnd);\\r\\n                    // Mint loop.\\r\\n                    do {\\r\\n                        uint256 id;\\r\\n                        if (burnedPoolSize != 0) {\\r\\n                            id = _get($.burnedPool, --burnedPoolSize);\\r\\n                        } else {\\r\\n                            id = nextTokenId;\\r\\n                            while (_get(oo, _ownershipIndex(id)) != 0) {\\r\\n                                id = _wrapNFTId(id + 1, maxNFTId);\\r\\n                            }\\r\\n                            nextTokenId = _wrapNFTId(id + 1, maxNFTId);\\r\\n                        }\\r\\n                        _set(toOwned, toIndex, uint32(id));\\r\\n                        _setOwnerAliasAndOwnedIndex(oo, id, toAlias, uint32(toIndex++));\\r\\n                        _packedLogsAppend(packedLogs, id);\\r\\n                    } while (toIndex != toEnd);\\r\\n\\r\\n                    // Leave some spacing between minted batches for better open addressing.\\r\\n                    $.nextTokenId = uint32(_wrapNFTId(nextTokenId + 7, maxNFTId));\\r\\n                    $.burnedPoolSize = uint32(burnedPoolSize);\\r\\n                    _packedLogsSend(packedLogs, $.mirrorERC721);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Emit the {Transfer} event.\\r\\n            mstore(0x00, amount)\\r\\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, shl(96, to)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                  INTERNAL BURN FUNCTIONS                   */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\\r\\n    ///\\r\\n    /// Will burn sender NFTs if balance after transfer is less than\\r\\n    /// the amount required to support the current NFT balance.\\r\\n    ///\\r\\n    /// Emits a {Transfer} event.\\r\\n    function _burn(address from, uint256 amount) internal virtual {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n\\r\\n        AddressData storage fromAddressData = _addressData(from);\\r\\n\\r\\n        uint256 fromBalance = fromAddressData.balance;\\r\\n        if (amount > fromBalance) revert InsufficientBalance();\\r\\n\\r\\n        unchecked {\\r\\n            fromAddressData.balance = uint96(fromBalance -= amount);\\r\\n            uint256 totalSupply_ = uint256($.totalSupply) - amount;\\r\\n            $.totalSupply = uint96(totalSupply_);\\r\\n\\r\\n            Uint32Map storage fromOwned = $.owned[from];\\r\\n            uint256 fromIndex = fromAddressData.ownedLength;\\r\\n            uint256 numNFTBurns = _zeroFloorSub(fromIndex, fromBalance / _unit());\\r\\n\\r\\n            if (numNFTBurns != 0) {\\r\\n                _PackedLogs memory packedLogs = _packedLogsMalloc(numNFTBurns);\\r\\n                _packedLogsSet(packedLogs, from, 1);\\r\\n                uint256 totalNFTSupply = uint256($.totalNFTSupply) - numNFTBurns;\\r\\n                $.totalNFTSupply = uint32(totalNFTSupply);\\r\\n                bool addToBurnedPool = _addToBurnedPool(totalNFTSupply, totalSupply_);\\r\\n\\r\\n                Uint32Map storage oo = $.oo;\\r\\n                uint256 fromEnd = fromIndex - numNFTBurns;\\r\\n                fromAddressData.ownedLength = uint32(fromEnd);\\r\\n                uint256 burnedPoolSize = $.burnedPoolSize;\\r\\n                // Burn loop.\\r\\n                do {\\r\\n                    uint256 id = _get(fromOwned, --fromIndex);\\r\\n                    _setOwnerAliasAndOwnedIndex(oo, id, 0, 0);\\r\\n                    _packedLogsAppend(packedLogs, id);\\r\\n                    if (addToBurnedPool) {\\r\\n                        _set($.burnedPool, burnedPoolSize++, uint32(id));\\r\\n                    }\\r\\n                    if (_get($.mayHaveNFTApproval, id)) {\\r\\n                        _set($.mayHaveNFTApproval, id, false);\\r\\n                        delete $.nftApprovals[id];\\r\\n                    }\\r\\n                } while (fromIndex != fromEnd);\\r\\n\\r\\n                $.burnedPoolSize = uint32(burnedPoolSize);\\r\\n                _packedLogsSend(packedLogs, $.mirrorERC721);\\r\\n            }\\r\\n        }\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Emit the {Transfer} event.\\r\\n            mstore(0x00, amount)\\r\\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Moves `amount` of tokens from `from` to `to`.\\r\\n    ///\\r\\n    /// Will burn sender NFTs if balance after transfer is less than\\r\\n    /// the amount required to support the current NFT balance.\\r\\n    ///\\r\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\r\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\r\\n    /// set to false.\\r\\n    ///\\r\\n    /// Emits a {Transfer} event.\\r\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\r\\n        if (to == address(0)) revert TransferToZeroAddress();\\r\\n\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n\\r\\n        AddressData storage fromAddressData = _addressData(from);\\r\\n        AddressData storage toAddressData = _addressData(to);\\r\\n\\r\\n        _TransferTemps memory t;\\r\\n        t.fromOwnedLength = fromAddressData.ownedLength;\\r\\n        t.toOwnedLength = toAddressData.ownedLength;\\r\\n        t.totalSupply = $.totalSupply;\\r\\n\\r\\n        if (amount > (t.fromBalance = fromAddressData.balance)) revert InsufficientBalance();\\r\\n\\r\\n        unchecked {\\r\\n            fromAddressData.balance = uint96(t.fromBalance -= amount);\\r\\n            toAddressData.balance = uint96(t.toBalance = uint256(toAddressData.balance) + amount);\\r\\n\\r\\n            t.numNFTBurns = _zeroFloorSub(t.fromOwnedLength, t.fromBalance / _unit());\\r\\n\\r\\n            if (toAddressData.flags & _ADDRESS_DATA_SKIP_NFT_FLAG == 0) {\\r\\n                if (from == to) t.toOwnedLength = t.fromOwnedLength - t.numNFTBurns;\\r\\n                t.numNFTMints = _zeroFloorSub(t.toBalance / _unit(), t.toOwnedLength);\\r\\n            }\\r\\n\\r\\n            t.totalNFTSupply = uint256($.totalNFTSupply) + t.numNFTMints - t.numNFTBurns;\\r\\n            $.totalNFTSupply = uint32(t.totalNFTSupply);\\r\\n\\r\\n            _PackedLogs memory packedLogs = _packedLogsMalloc(t.numNFTBurns + t.numNFTMints);\\r\\n            Uint32Map storage oo = $.oo;\\r\\n\\r\\n            uint256 burnedPoolSize = $.burnedPoolSize;\\r\\n            if (t.numNFTBurns != 0) {\\r\\n                _packedLogsSet(packedLogs, from, 1);\\r\\n                bool addToBurnedPool = _addToBurnedPool(t.totalNFTSupply, t.totalSupply);\\r\\n                Uint32Map storage fromOwned = $.owned[from];\\r\\n                uint256 fromIndex = t.fromOwnedLength;\\r\\n                uint256 fromEnd = fromIndex - t.numNFTBurns;\\r\\n                fromAddressData.ownedLength = uint32(fromEnd);\\r\\n                // Burn loop.\\r\\n                do {\\r\\n                    uint256 id = _get(fromOwned, --fromIndex);\\r\\n                    _setOwnerAliasAndOwnedIndex(oo, id, 0, 0);\\r\\n                    _packedLogsAppend(packedLogs, id);\\r\\n                    if (addToBurnedPool) {\\r\\n                        _set($.burnedPool, burnedPoolSize++, uint32(id));\\r\\n                    }\\r\\n                    if (_get($.mayHaveNFTApproval, id)) {\\r\\n                        _set($.mayHaveNFTApproval, id, false);\\r\\n                        delete $.nftApprovals[id];\\r\\n                    }\\r\\n                } while (fromIndex != fromEnd);\\r\\n            }\\r\\n\\r\\n            if (t.numNFTMints != 0) {\\r\\n                _packedLogsSet(packedLogs, to, 0);\\r\\n                uint256 nextTokenId = $.nextTokenId;\\r\\n                Uint32Map storage toOwned = $.owned[to];\\r\\n                uint256 toIndex = t.toOwnedLength;\\r\\n                uint256 toEnd = toIndex + t.numNFTMints;\\r\\n                uint32 toAlias = _registerAndResolveAlias(toAddressData, to);\\r\\n                uint256 maxNFTId = t.totalSupply / _unit();\\r\\n                toAddressData.ownedLength = uint32(toEnd);\\r\\n                // Mint loop.\\r\\n                do {\\r\\n                    uint256 id;\\r\\n                    if (burnedPoolSize != 0) {\\r\\n                        id = _get($.burnedPool, --burnedPoolSize);\\r\\n                    } else {\\r\\n                        id = nextTokenId;\\r\\n                        while (_get(oo, _ownershipIndex(id)) != 0) {\\r\\n                            id = _wrapNFTId(id + 1, maxNFTId);\\r\\n                        }\\r\\n                        nextTokenId = _wrapNFTId(id + 1, maxNFTId);\\r\\n                    }\\r\\n                    _set(toOwned, toIndex, uint32(id));\\r\\n                    _setOwnerAliasAndOwnedIndex(oo, id, toAlias, uint32(toIndex++));\\r\\n                    _packedLogsAppend(packedLogs, id);\\r\\n                } while (toIndex != toEnd);\\r\\n\\r\\n                // Leave some spacing between minted batches for better open addressing.\\r\\n                $.nextTokenId = uint32(_wrapNFTId(nextTokenId + 7, maxNFTId));\\r\\n            }\\r\\n\\r\\n            if (packedLogs.logs.length != 0) {\\r\\n                $.burnedPoolSize = uint32(burnedPoolSize);\\r\\n                _packedLogsSend(packedLogs, $.mirrorERC721);\\r\\n            }\\r\\n        }\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Emit the {Transfer} event.\\r\\n            mstore(0x00, amount)\\r\\n            // forgefmt: disable-next-item\\r\\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), shr(96, shl(96, to)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns if burns should be added to the burn pool.\\r\\n    function _addToBurnedPool(uint256 totalNFTSupplyAfterBurn, uint256 totalSupplyAfterBurn)\\r\\n        internal\\r\\n        view\\r\\n        virtual\\r\\n        returns (bool)\\r\\n    {\\r\\n        // Add to burned pool if the load factor > 50%, and collection is not small.\\r\\n        uint256 thres = (totalSupplyAfterBurn / _unit()) >> 1;\\r\\n        return _toUint(totalNFTSupplyAfterBurn > thres) & _toUint(thres > 128) != 0;\\r\\n    }\\r\\n\\r\\n    /// @dev Transfers token `id` from `from` to `to`.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    ///\\r\\n    /// - Call must originate from the mirror contract.\\r\\n    /// - Token `id` must exist.\\r\\n    /// - `from` must be the owner of the token.\\r\\n    /// - `to` cannot be the zero address.\\r\\n    ///   `msgSender` must be the owner of the token, or be approved to manage the token.\\r\\n    ///\\r\\n    /// Emits a {Transfer} event.\\r\\n    function _transferFromNFT(address from, address to, uint256 id, address msgSender)\\r\\n        internal\\r\\n        virtual\\r\\n    {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n\\r\\n        if (to == address(0)) revert TransferToZeroAddress();\\r\\n\\r\\n        Uint32Map storage oo = $.oo;\\r\\n\\r\\n        if (from != $.aliasToAddress[_get(oo, _ownershipIndex(id))]) {\\r\\n            revert TransferFromIncorrectOwner();\\r\\n        }\\r\\n\\r\\n        if (msgSender != from) {\\r\\n            if (_ref($.operatorApprovals, from, msgSender).value == 0) {\\r\\n                if (msgSender != $.nftApprovals[id]) {\\r\\n                    revert TransferCallerNotOwnerNorApproved();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        AddressData storage fromAddressData = _addressData(from);\\r\\n        AddressData storage toAddressData = _addressData(to);\\r\\n\\r\\n        uint256 unit = _unit();\\r\\n\\r\\n        unchecked {\\r\\n            {\\r\\n                uint256 fromBalance = fromAddressData.balance;\\r\\n                if (unit > fromBalance) revert InsufficientBalance();\\r\\n                fromAddressData.balance = uint96(fromBalance - unit);\\r\\n                toAddressData.balance += uint96(unit);\\r\\n            }\\r\\n            mapping(address => Uint32Map) storage owned = $.owned;\\r\\n            Uint32Map storage fromOwned = owned[from];\\r\\n\\r\\n            if (_get($.mayHaveNFTApproval, id)) {\\r\\n                _set($.mayHaveNFTApproval, id, false);\\r\\n                delete $.nftApprovals[id];\\r\\n            }\\r\\n\\r\\n            {\\r\\n                uint32 updatedId = _get(fromOwned, --fromAddressData.ownedLength);\\r\\n                uint32 i = _get(oo, _ownedIndex(id));\\r\\n                _set(fromOwned, i, updatedId);\\r\\n                _set(oo, _ownedIndex(updatedId), i);\\r\\n            }\\r\\n            uint32 n = toAddressData.ownedLength++;\\r\\n            _set(owned[to], n, uint32(id));\\r\\n            _setOwnerAliasAndOwnedIndex(oo, id, _registerAndResolveAlias(toAddressData, to), n);\\r\\n        }\\r\\n\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Emit the {Transfer} event.\\r\\n            mstore(0x00, unit)\\r\\n            // forgefmt: disable-next-item\\r\\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), shr(96, shl(96, to)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                 INTERNAL APPROVE FUNCTIONS                 */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\\r\\n    ///\\r\\n    /// Emits a {Approval} event.\\r\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\r\\n        _ref(_getDN404Storage().allowance, owner, spender).value = amount;\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Emit the {Approval} event.\\r\\n            mstore(0x00, amount)\\r\\n            // forgefmt: disable-next-item\\r\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, shl(96, owner)), shr(96, shl(96, spender)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                 DATA HITCHHIKING FUNCTIONS                 */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Returns the auxiliary data for `owner`.\\r\\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\\r\\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\\r\\n    function _getAux(address owner) internal view virtual returns (uint88) {\\r\\n        return _getDN404Storage().addressData[owner].aux;\\r\\n    }\\r\\n\\r\\n    /// @dev Set the auxiliary data for `owner` to `value`.\\r\\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\\r\\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\\r\\n    function _setAux(address owner, uint88 value) internal virtual {\\r\\n        _getDN404Storage().addressData[owner].aux = value;\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                     SKIP NFT FUNCTIONS                     */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Returns true if minting and transferring ERC20s to `owner` will skip minting NFTs.\\r\\n    /// Returns false otherwise.\\r\\n    function getSkipNFT(address owner) public view virtual returns (bool) {\\r\\n        AddressData storage d = _getDN404Storage().addressData[owner];\\r\\n        if (d.flags & _ADDRESS_DATA_INITIALIZED_FLAG == 0) return _hasCode(owner);\\r\\n        return d.flags & _ADDRESS_DATA_SKIP_NFT_FLAG != 0;\\r\\n    }\\r\\n\\r\\n    /// @dev Sets the caller's skipNFT flag to `skipNFT`. Returns true.\\r\\n    ///\\r\\n    /// Emits a {SkipNFTSet} event.\\r\\n    function setSkipNFT(bool skipNFT) public virtual returns (bool) {\\r\\n        _setSkipNFT(msg.sender, skipNFT);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @dev Internal function to set account `owner` skipNFT flag to `state`\\r\\n    ///\\r\\n    /// Initializes account `owner` AddressData if it is not currently initialized.\\r\\n    ///\\r\\n    /// Emits a {SkipNFTSet} event.\\r\\n    function _setSkipNFT(address owner, bool state) internal virtual {\\r\\n        AddressData storage d = _addressData(owner);\\r\\n        if ((d.flags & _ADDRESS_DATA_SKIP_NFT_FLAG != 0) != state) {\\r\\n            d.flags ^= _ADDRESS_DATA_SKIP_NFT_FLAG;\\r\\n        }\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, iszero(iszero(state)))\\r\\n            log2(0x00, 0x20, _SKIP_NFT_SET_EVENT_SIGNATURE, shr(96, shl(96, owner)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns a storage data pointer for account `owner` AddressData\\r\\n    ///\\r\\n    /// Initializes account `owner` AddressData if it is not currently initialized.\\r\\n    function _addressData(address owner) internal virtual returns (AddressData storage d) {\\r\\n        d = _getDN404Storage().addressData[owner];\\r\\n        unchecked {\\r\\n            if (d.flags & _ADDRESS_DATA_INITIALIZED_FLAG == 0) {\\r\\n                uint256 skipNFT = (_toUint(_hasCode(owner)) * _ADDRESS_DATA_SKIP_NFT_FLAG);\\r\\n                d.flags = uint8(skipNFT | _ADDRESS_DATA_INITIALIZED_FLAG);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the `addressAlias` of account `to`.\\r\\n    ///\\r\\n    /// Assigns and registers the next alias if `to` alias was not previously registered.\\r\\n    function _registerAndResolveAlias(AddressData storage toAddressData, address to)\\r\\n        internal\\r\\n        virtual\\r\\n        returns (uint32 addressAlias)\\r\\n    {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n        addressAlias = toAddressData.addressAlias;\\r\\n        if (addressAlias == 0) {\\r\\n            unchecked {\\r\\n                addressAlias = ++$.numAliases;\\r\\n            }\\r\\n            toAddressData.addressAlias = addressAlias;\\r\\n            $.aliasToAddress[addressAlias] = to;\\r\\n            if (addressAlias == 0) revert(); // Overflow.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                     MIRROR OPERATIONS                      */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Returns the address of the mirror NFT contract.\\r\\n    function mirrorERC721() public view virtual returns (address) {\\r\\n        return _getDN404Storage().mirrorERC721;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the total NFT supply.\\r\\n    function _totalNFTSupply() internal view virtual returns (uint256) {\\r\\n        return _getDN404Storage().totalNFTSupply;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns `owner` NFT balance.\\r\\n    function _balanceOfNFT(address owner) internal view virtual returns (uint256) {\\r\\n        return _getDN404Storage().addressData[owner].ownedLength;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the owner of token `id`.\\r\\n    /// Returns the zero address instead of reverting if the token does not exist.\\r\\n    function _ownerAt(uint256 id) internal view virtual returns (address) {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n        return $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the owner of token `id`.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - Token `id` must exist.\\r\\n    function _ownerOf(uint256 id) internal view virtual returns (address) {\\r\\n        if (!_exists(id)) revert TokenDoesNotExist();\\r\\n        return _ownerAt(id);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns if token `id` exists.\\r\\n    function _exists(uint256 id) internal view virtual returns (bool) {\\r\\n        return _ownerAt(id) != address(0);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the account approved to manage token `id`.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - Token `id` must exist.\\r\\n    function _getApproved(uint256 id) internal view virtual returns (address) {\\r\\n        if (!_exists(id)) revert TokenDoesNotExist();\\r\\n        return _getDN404Storage().nftApprovals[id];\\r\\n    }\\r\\n\\r\\n    /// @dev Sets `spender` as the approved account to manage token `id`, using `msgSender`.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - `msgSender` must be the owner or an approved operator for the token owner.\\r\\n    function _approveNFT(address spender, uint256 id, address msgSender)\\r\\n        internal\\r\\n        virtual\\r\\n        returns (address owner)\\r\\n    {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n\\r\\n        owner = $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\r\\n\\r\\n        if (msgSender != owner) {\\r\\n            if (_ref($.operatorApprovals, owner, msgSender).value == 0) {\\r\\n                revert ApprovalCallerNotOwnerNorApproved();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        $.nftApprovals[id] = spender;\\r\\n        _set($.mayHaveNFTApproval, id, spender != address(0));\\r\\n    }\\r\\n\\r\\n    /// @dev Approve or remove the `operator` as an operator for `msgSender`,\\r\\n    /// without authorization checks.\\r\\n    function _setApprovalForAll(address operator, bool approved, address msgSender)\\r\\n        internal\\r\\n        virtual\\r\\n    {\\r\\n        _ref(_getDN404Storage().operatorApprovals, msgSender, operator).value = _toUint(approved);\\r\\n    }\\r\\n\\r\\n    /// @dev Fallback modifier to dispatch calls from the mirror NFT contract\\r\\n    /// to internal functions in this contract.\\r\\n    modifier dn404Fallback() virtual {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n\\r\\n        uint256 fnSelector = _calldataload(0x00) >> 224;\\r\\n\\r\\n        // `transferFromNFT(address,address,uint256,address)`.\\r\\n        if (fnSelector == 0xe5eb36c8) {\\r\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\r\\n            if (msg.data.length < 0x84) revert();\\r\\n\\r\\n            address from = address(uint160(_calldataload(0x04)));\\r\\n            address to = address(uint160(_calldataload(0x24)));\\r\\n            uint256 id = _calldataload(0x44);\\r\\n            address msgSender = address(uint160(_calldataload(0x64)));\\r\\n\\r\\n            _transferFromNFT(from, to, id, msgSender);\\r\\n            _return(1);\\r\\n        }\\r\\n        // `setApprovalForAll(address,bool,address)`.\\r\\n        if (fnSelector == 0x813500fc) {\\r\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\r\\n            if (msg.data.length < 0x64) revert();\\r\\n\\r\\n            address spender = address(uint160(_calldataload(0x04)));\\r\\n            bool status = _calldataload(0x24) != 0;\\r\\n            address msgSender = address(uint160(_calldataload(0x44)));\\r\\n\\r\\n            _setApprovalForAll(spender, status, msgSender);\\r\\n            _return(1);\\r\\n        }\\r\\n        // `isApprovedForAll(address,address)`.\\r\\n        if (fnSelector == 0xe985e9c5) {\\r\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\r\\n            if (msg.data.length < 0x44) revert();\\r\\n\\r\\n            address owner = address(uint160(_calldataload(0x04)));\\r\\n            address operator = address(uint160(_calldataload(0x24)));\\r\\n\\r\\n            _return(_ref($.operatorApprovals, owner, operator).value);\\r\\n        }\\r\\n        // `ownerOf(uint256)`.\\r\\n        if (fnSelector == 0x6352211e) {\\r\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\r\\n            if (msg.data.length < 0x24) revert();\\r\\n\\r\\n            uint256 id = _calldataload(0x04);\\r\\n\\r\\n            _return(uint160(_ownerOf(id)));\\r\\n        }\\r\\n        // `ownerAt(uint256)`.\\r\\n        if (fnSelector == 0x24359879) {\\r\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\r\\n            if (msg.data.length < 0x24) revert();\\r\\n\\r\\n            uint256 id = _calldataload(0x04);\\r\\n\\r\\n            _return(uint160(_ownerAt(id)));\\r\\n        }\\r\\n        // `approveNFT(address,uint256,address)`.\\r\\n        if (fnSelector == 0xd10b6e0c) {\\r\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\r\\n            if (msg.data.length < 0x64) revert();\\r\\n\\r\\n            address spender = address(uint160(_calldataload(0x04)));\\r\\n            uint256 id = _calldataload(0x24);\\r\\n            address msgSender = address(uint160(_calldataload(0x44)));\\r\\n\\r\\n            _return(uint160(_approveNFT(spender, id, msgSender)));\\r\\n        }\\r\\n        // `getApproved(uint256)`.\\r\\n        if (fnSelector == 0x081812fc) {\\r\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\r\\n            if (msg.data.length < 0x24) revert();\\r\\n\\r\\n            uint256 id = _calldataload(0x04);\\r\\n\\r\\n            _return(uint160(_getApproved(id)));\\r\\n        }\\r\\n        // `balanceOfNFT(address)`.\\r\\n        if (fnSelector == 0xf5b100ea) {\\r\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\r\\n            if (msg.data.length < 0x24) revert();\\r\\n\\r\\n            address owner = address(uint160(_calldataload(0x04)));\\r\\n\\r\\n            _return(_balanceOfNFT(owner));\\r\\n        }\\r\\n        // `totalNFTSupply()`.\\r\\n        if (fnSelector == 0xe2c79281) {\\r\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\r\\n            if (msg.data.length < 0x04) revert();\\r\\n\\r\\n            _return(_totalNFTSupply());\\r\\n        }\\r\\n        // `implementsDN404()`.\\r\\n        if (fnSelector == 0xb7a94eb8) {\\r\\n            _return(1);\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev Fallback function for calls from mirror NFT contract.\\r\\n    fallback() external payable virtual dn404Fallback {}\\r\\n\\r\\n    receive() external payable virtual {}\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                 INTERNAL / PRIVATE HELPERS                 */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Returns `(i - 1) << 1`.\\r\\n    function _ownershipIndex(uint256 i) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            return (i - 1) << 1; // Minus 1 as token IDs start from 1.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns `((i - 1) << 1) + 1`.\\r\\n    function _ownedIndex(uint256 i) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            return ((i - 1) << 1) + 1; // Minus 1 as token IDs start from 1.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the uint32 value at `index` in `map`.\\r\\n    function _get(Uint32Map storage map, uint256 index) internal view returns (uint32 result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let s := add(shl(96, map.slot), shr(3, index)) // Storage slot.\\r\\n            result := and(0xffffffff, shr(shl(5, and(index, 7)), sload(s)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Updates the uint32 value at `index` in `map`.\\r\\n    function _set(Uint32Map storage map, uint256 index, uint32 value) internal {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let s := add(shl(96, map.slot), shr(3, index)) // Storage slot.\\r\\n            let o := shl(5, and(index, 7)) // Storage slot offset (bits).\\r\\n            let v := sload(s) // Storage slot value.\\r\\n            let m := 0xffffffff // Value mask.\\r\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sets the owner alias and the owned index together.\\r\\n    function _setOwnerAliasAndOwnedIndex(\\r\\n        Uint32Map storage map,\\r\\n        uint256 id,\\r\\n        uint32 ownership,\\r\\n        uint32 ownedIndex\\r\\n    ) internal {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let i := sub(id, 1) // Index of the uint64 combined value.\\r\\n            let s := add(shl(96, map.slot), shr(2, i)) // Storage slot.\\r\\n            let o := shl(6, and(i, 3)) // Storage slot offset (bits).\\r\\n            let v := sload(s) // Storage slot value.\\r\\n            let m := 0xffffffffffffffff // Value mask.\\r\\n            let combined := or(shl(32, ownedIndex), and(0xffffffff, ownership))\\r\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), combined)))))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the boolean value of the bit at `index` in `bitmap`.\\r\\n    function _get(Bitmap storage bitmap, uint256 index) internal view returns (bool result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let s := add(shl(96, bitmap.slot), shr(8, index)) // Storage slot.\\r\\n            result := and(1, shr(and(0xff, index), sload(s)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Updates the bit at `index` in `bitmap` to `value`.\\r\\n    function _set(Bitmap storage bitmap, uint256 index, bool value) internal {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let s := add(shl(96, bitmap.slot), shr(8, index)) // Storage slot.\\r\\n            let o := and(0xff, index) // Storage slot offset (bits).\\r\\n            sstore(s, or(and(sload(s), not(shl(o, 1))), shl(o, iszero(iszero(value)))))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns a storage reference to the value at (`a0`, `a1`) in `map`.\\r\\n    function _ref(AddressPairToUint256RefMap storage map, address a0, address a1)\\r\\n        internal\\r\\n        pure\\r\\n        returns (Uint256Ref storage ref)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x28, a1)\\r\\n            mstore(0x14, a0)\\r\\n            mstore(0x00, map.slot)\\r\\n            ref.slot := keccak256(0x00, 0x48)\\r\\n            // Clear the part of the free memory pointer that was overwritten.\\r\\n            mstore(0x28, 0x00)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Wraps the NFT ID.\\r\\n    function _wrapNFTId(uint256 id, uint256 maxNFTId) internal pure returns (uint256 result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := or(mul(iszero(gt(id, maxNFTId)), id), gt(id, maxNFTId))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns whether `amount` is a valid `totalSupply`.\\r\\n    function _totalSupplyOverflows(uint256 amount) internal view returns (bool) {\\r\\n        unchecked {\\r\\n            return _toUint(amount > type(uint96).max)\\r\\n                | _toUint(amount / _unit() > type(uint32).max - 1) != 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns `max(0, x - y)`.\\r\\n    function _zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            z := mul(gt(x, y), sub(x, y))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns `b ? 1 : 0`.\\r\\n    function _toUint(bool b) internal pure returns (uint256 result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := iszero(iszero(b))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Struct containing packed log data for {Transfer} events to be\\r\\n    /// emitted by the mirror NFT contract.\\r\\n    struct _PackedLogs {\\r\\n        uint256 offset;\\r\\n        uint256 addressAndBit;\\r\\n        uint256[] logs;\\r\\n    }\\r\\n\\r\\n    /// @dev Initiates memory allocation for packed logs with `n` log items.\\r\\n    function _packedLogsMalloc(uint256 n) private pure returns (_PackedLogs memory p) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Note that `p` implicitly allocates and advances the free memory pointer by\\r\\n            // 3 words, which we can safely mutate in `_packedLogsSend`.\\r\\n            let logs := mload(0x40)\\r\\n            mstore(logs, n) // Store the length.\\r\\n            let offset := add(0x20, logs) // Skip the word for `p.logs.length`.\\r\\n            mstore(0x40, add(offset, shl(5, n))) // Allocate memory.\\r\\n            mstore(add(0x40, p), logs) // Set `p.logs`.\\r\\n            mstore(p, offset) // Set `p.offset`.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Set the current address and the burn bit.\\r\\n    function _packedLogsSet(_PackedLogs memory p, address a, uint256 burnBit) private pure {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(add(p, 0x20), or(shl(96, a), burnBit)) // Set `p.addressAndBit`.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Adds a packed log item to `p` with token `id`.\\r\\n    function _packedLogsAppend(_PackedLogs memory p, uint256 id) private pure {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let offset := mload(p)\\r\\n            mstore(offset, or(mload(add(p, 0x20)), shl(8, id))) // `p.addressAndBit | (id << 8)`.\\r\\n            mstore(p, add(offset, 0x20))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Calls the `mirror` NFT contract to emit {Transfer} events for packed logs `p`.\\r\\n    function _packedLogsSend(_PackedLogs memory p, address mirror) private {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let logs := mload(add(p, 0x40))\\r\\n            let o := sub(logs, 0x40) // Start of calldata to send.\\r\\n            mstore(o, 0x263c69d6) // `logTransfer(uint256[])`.\\r\\n            mstore(add(o, 0x20), 0x20) // Offset of `logs` in the calldata to send.\\r\\n            let n := add(0x44, shl(5, mload(logs))) // Length of calldata to send.\\r\\n            if iszero(and(eq(mload(o), 1), call(gas(), mirror, 0, add(o, 0x1c), n, o, 0x20))) {\\r\\n                revert(o, 0x00)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Struct of temporary variables for transfers.\\r\\n    struct _TransferTemps {\\r\\n        uint256 numNFTBurns;\\r\\n        uint256 numNFTMints;\\r\\n        uint256 fromBalance;\\r\\n        uint256 toBalance;\\r\\n        uint256 fromOwnedLength;\\r\\n        uint256 toOwnedLength;\\r\\n        uint256 totalSupply;\\r\\n        uint256 totalNFTSupply;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\r\\n    function _hasCode(address a) private view returns (bool result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := extcodesize(a) // Can handle dirty upper bits.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the calldata value at `offset`.\\r\\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            value := calldataload(offset)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Executes a return opcode to return `x` and end the current call frame.\\r\\n    function _return(uint256 x) private pure {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, x)\\r\\n            return(0x00, 0x20)\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/lib/DN404/DN404Mirror.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @title DN404Mirror\\r\\n/// @notice DN404Mirror provides an interface for interacting with the\\r\\n/// NFT tokens in a DN404 implementation.\\r\\n///\\r\\n/// @author vectorized.eth (@optimizoor)\\r\\n/// @author Quit (@0xQuit)\\r\\n/// @author Michael Amadi (@AmadiMichaels)\\r\\n/// @author cygaar (@0xCygaar)\\r\\n/// @author Thomas (@0xjustadev)\\r\\n/// @author Harrison (@PopPunkOnChain)\\r\\n///\\r\\n/// @dev Note:\\r\\n/// - The ERC721 data is stored in the base DN404 contract.\\r\\ncontract DN404Mirror {\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                           EVENTS                           */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Emitted when token `id` is transferred from `from` to `to`.\\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\r\\n\\r\\n    /// @dev Emitted when `owner` enables `account` to manage the `id` token.\\r\\n    event Approval(address indexed owner, address indexed account, uint256 indexed id);\\r\\n\\r\\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\\r\\n\\r\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\r\\n    /// This is for marketplace signaling purposes. This contract has a `pullOwner()`\\r\\n    /// function that will sync the owner from the base contract.\\r\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\r\\n\\r\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\r\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\r\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\r\\n\\r\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\r\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\r\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\r\\n\\r\\n    /// @dev `keccak256(bytes(\\\"ApprovalForAll(address,address,bool)\\\"))`.\\r\\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\\r\\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                        CUSTOM ERRORS                       */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Thrown when a call for an NFT function did not originate\\r\\n    /// from the base DN404 contract.\\r\\n    error SenderNotBase();\\r\\n\\r\\n    /// @dev Thrown when a call for an NFT function did not originate from the deployer.\\r\\n    error SenderNotDeployer();\\r\\n\\r\\n    /// @dev Thrown when transferring an NFT to a contract address that\\r\\n    /// does not implement ERC721Receiver.\\r\\n    error TransferToNonERC721ReceiverImplementer();\\r\\n\\r\\n    /// @dev Thrown when linking to the DN404 base contract and the\\r\\n    /// DN404 supportsInterface check fails or the call reverts.\\r\\n    error CannotLink();\\r\\n\\r\\n    /// @dev Thrown when a linkMirrorContract call is received and the\\r\\n    /// NFT mirror contract has already been linked to a DN404 base contract.\\r\\n    error AlreadyLinked();\\r\\n\\r\\n    /// @dev Thrown when retrieving the base DN404 address when a link has not\\r\\n    /// been established.\\r\\n    error NotLinked();\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                          STORAGE                           */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Struct contain the NFT mirror contract storage.\\r\\n    struct DN404NFTStorage {\\r\\n        address baseERC20;\\r\\n        address deployer;\\r\\n        address owner;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns a storage pointer for DN404NFTStorage.\\r\\n    function _getDN404NFTStorage() internal pure virtual returns (DN404NFTStorage storage $) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // `uint72(bytes9(keccak256(\\\"DN404_MIRROR_STORAGE\\\")))`.\\r\\n            $.slot := 0x3602298b8c10b01230 // Truncate to 9 bytes to reduce bytecode size.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                        CONSTRUCTOR                         */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    constructor(address deployer) {\\r\\n        // For non-proxies, we will store the deployer so that only the deployer can\\r\\n        // link the base contract.\\r\\n        _getDN404NFTStorage().deployer = deployer;\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                     ERC721 OPERATIONS                      */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Returns the token collection name from the base DN404 contract.\\r\\n    function name() public view virtual returns (string memory result) {\\r\\n        return _readString(0x06fdde03, 0); // `symbol()`.\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the token collection symbol from the base DN404 contract.\\r\\n    function symbol() public view virtual returns (string memory result) {\\r\\n        return _readString(0x95d89b41, 0); // `symbol()`.\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id` from\\r\\n    /// the base DN404 contract.\\r\\n    function tokenURI(uint256 id) public view virtual returns (string memory result) {\\r\\n        return _readString(0xc87b56dd, id); // `tokenURI()`.\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the total NFT supply from the base DN404 contract.\\r\\n    function totalSupply() public view virtual returns (uint256 result) {\\r\\n        return _readWord(0xe2c79281, 0, 0); // `totalNFTSupply()`.\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the number of NFT tokens owned by `nftOwner` from the base DN404 contract.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - `nftOwner` must not be the zero address.\\r\\n    function balanceOf(address nftOwner) public view virtual returns (uint256 result) {\\r\\n        return _readWord(0xf5b100ea, uint160(nftOwner), 0); // `balanceOfNFT(address)`.\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the owner of token `id` from the base DN404 contract.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - Token `id` must exist.\\r\\n    function ownerOf(uint256 id) public view virtual returns (address result) {\\r\\n        return address(uint160(_readWord(0x6352211e, id, 0))); // `ownerOf(uint256)`.\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the owner of token `id` from the base DN404 contract.\\r\\n    /// Returns `address(0)` instead of reverting if the token does not exist.\\r\\n    function ownerAt(uint256 id) public view virtual returns (address result) {\\r\\n        return address(uint160(_readWord(0x24359879, id, 0))); // `ownerAt(uint256)`.\\r\\n    }\\r\\n\\r\\n    /// @dev Sets `spender` as the approved account to manage token `id` in\\r\\n    /// the base DN404 contract.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - Token `id` must exist.\\r\\n    /// - The caller must be the owner of the token,\\r\\n    ///   or an approved operator for the token owner.\\r\\n    ///\\r\\n    /// Emits an {Approval} event.\\r\\n    function approve(address spender, uint256 id) public virtual {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            spender := shr(96, shl(96, spender))\\r\\n            let m := mload(0x40)\\r\\n            mstore(0x00, 0xd10b6e0c) // `approveNFT(address,uint256,address)`.\\r\\n            mstore(0x20, spender)\\r\\n            mstore(0x40, id)\\r\\n            mstore(0x60, caller())\\r\\n            if iszero(\\r\\n                and(\\r\\n                    gt(returndatasize(), 0x1f),\\r\\n                    call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                returndatacopy(m, 0x00, returndatasize())\\r\\n                revert(m, returndatasize())\\r\\n            }\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n            mstore(0x60, 0) // Restore the zero pointer.\\r\\n            // Emit the {Approval} event.\\r\\n            log4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, shr(96, mload(0x0c)), spender, id)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the account approved to manage token `id` from\\r\\n    /// the base DN404 contract.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - Token `id` must exist.\\r\\n    function getApproved(uint256 id) public view virtual returns (address) {\\r\\n        return address(uint160(_readWord(0x081812fc, id, 0))); // `getApproved(uint256)`.\\r\\n    }\\r\\n\\r\\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller in\\r\\n    /// the base DN404 contract.\\r\\n    ///\\r\\n    /// Emits an {ApprovalForAll} event.\\r\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            operator := shr(96, shl(96, operator))\\r\\n            let m := mload(0x40)\\r\\n            mstore(0x00, 0x813500fc) // `setApprovalForAll(address,bool,address)`.\\r\\n            mstore(0x20, operator)\\r\\n            mstore(0x40, iszero(iszero(approved)))\\r\\n            mstore(0x60, caller())\\r\\n            if iszero(\\r\\n                and(eq(mload(0x00), 1), call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20))\\r\\n            ) {\\r\\n                returndatacopy(m, 0x00, returndatasize())\\r\\n                revert(m, returndatasize())\\r\\n            }\\r\\n            // Emit the {ApprovalForAll} event.\\r\\n            // The `approved` value is already at 0x40.\\r\\n            log3(0x40, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n            mstore(0x60, 0) // Restore the zero pointer.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns whether `operator` is approved to manage the tokens of `nftOwner` from\\r\\n    /// the base DN404 contract.\\r\\n    function isApprovedForAll(address nftOwner, address operator)\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        returns (bool result)\\r\\n    {\\r\\n        // `isApprovedForAll(address,address)`.\\r\\n        return _readWord(0xe985e9c5, uint160(nftOwner), uint160(operator)) != 0;\\r\\n    }\\r\\n\\r\\n    /// @dev Transfers token `id` from `from` to `to`.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    ///\\r\\n    /// - Token `id` must exist.\\r\\n    /// - `from` must be the owner of the token.\\r\\n    /// - `to` cannot be the zero address.\\r\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\r\\n    ///\\r\\n    /// Emits a {Transfer} event.\\r\\n    function transferFrom(address from, address to, uint256 id) public virtual {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            from := shr(96, shl(96, from))\\r\\n            to := shr(96, shl(96, to))\\r\\n            let m := mload(0x40)\\r\\n            mstore(m, 0xe5eb36c8) // `transferFromNFT(address,address,uint256,address)`.\\r\\n            mstore(add(m, 0x20), from)\\r\\n            mstore(add(m, 0x40), to)\\r\\n            mstore(add(m, 0x60), id)\\r\\n            mstore(add(m, 0x80), caller())\\r\\n            if iszero(\\r\\n                and(eq(mload(m), 1), call(gas(), base, callvalue(), add(m, 0x1c), 0x84, m, 0x20))\\r\\n            ) {\\r\\n                returndatacopy(m, 0x00, returndatasize())\\r\\n                revert(m, returndatasize())\\r\\n            }\\r\\n            // Emit the {Transfer} event.\\r\\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Equivalent to `safeTransferFrom(from, to, id, \\\"\\\")`.\\r\\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\\r\\n        transferFrom(from, to, id);\\r\\n\\r\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    /// @dev Transfers token `id` from `from` to `to`.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    ///\\r\\n    /// - Token `id` must exist.\\r\\n    /// - `from` must be the owner of the token.\\r\\n    /// - `to` cannot be the zero address.\\r\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\r\\n    /// - If `to` refers to a smart contract, it must implement\\r\\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n    ///\\r\\n    /// Emits a {Transfer} event.\\r\\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\\r\\n        public\\r\\n        virtual\\r\\n    {\\r\\n        transferFrom(from, to, id);\\r\\n\\r\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\\r\\n    /// See: https://eips.ethereum.org/EIPS/eip-165\\r\\n    /// This function call must use less than 30000 gas.\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let s := shr(224, interfaceId)\\r\\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\\r\\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                  OWNER SYNCING OPERATIONS                  */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Returns the `owner` of the contract, for marketplace signaling purposes.\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _getDN404NFTStorage().owner;\\r\\n    }\\r\\n\\r\\n    /// @dev Permissionless function to pull the owner from the base DN404 contract\\r\\n    /// if it implements ownable, for marketplace signaling purposes.\\r\\n    function pullOwner() public virtual {\\r\\n        address newOwner;\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, 0x8da5cb5b) // `owner()`.\\r\\n            if and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x20)) {\\r\\n                newOwner := shr(96, mload(0x0c))\\r\\n            }\\r\\n        }\\r\\n        DN404NFTStorage storage $ = _getDN404NFTStorage();\\r\\n        address oldOwner = $.owner;\\r\\n        if (oldOwner != newOwner) {\\r\\n            $.owner = newOwner;\\r\\n            emit OwnershipTransferred(oldOwner, newOwner);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                     MIRROR OPERATIONS                      */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Returns the address of the base DN404 contract.\\r\\n    function baseERC20() public view virtual returns (address base) {\\r\\n        base = _getDN404NFTStorage().baseERC20;\\r\\n        if (base == address(0)) revert NotLinked();\\r\\n    }\\r\\n\\r\\n    /// @dev Fallback modifier to execute calls from the base DN404 contract.\\r\\n    modifier dn404NFTFallback() virtual {\\r\\n        DN404NFTStorage storage $ = _getDN404NFTStorage();\\r\\n\\r\\n        uint256 fnSelector = _calldataload(0x00) >> 224;\\r\\n\\r\\n        // `logTransfer(uint256[])`.\\r\\n        if (fnSelector == 0x263c69d6) {\\r\\n            if (msg.sender != $.baseERC20) revert SenderNotBase();\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                // When returndatacopy copies 1 or more out-of-bounds bytes, it reverts.\\r\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), 0x20))\\r\\n                let o := add(0x24, calldataload(0x04)) // Packed logs offset.\\r\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), o))\\r\\n                let end := add(o, shl(5, calldataload(sub(o, 0x20))))\\r\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), end))\\r\\n\\r\\n                for {} iszero(eq(o, end)) { o := add(0x20, o) } {\\r\\n                    let d := calldataload(o) // Entry in the packed logs.\\r\\n                    let a := shr(96, d) // The address.\\r\\n                    let b := and(1, d) // Whether it is a burn.\\r\\n                    log4(\\r\\n                        codesize(),\\r\\n                        0x00,\\r\\n                        _TRANSFER_EVENT_SIGNATURE,\\r\\n                        mul(a, b), // `from`.\\r\\n                        mul(a, iszero(b)), // `to`.\\r\\n                        shr(168, shl(160, d)) // `id`.\\r\\n                    )\\r\\n                }\\r\\n                mstore(0x00, 0x01)\\r\\n                return(0x00, 0x20)\\r\\n            }\\r\\n        }\\r\\n        // `linkMirrorContract(address)`.\\r\\n        if (fnSelector == 0x0f4599e5) {\\r\\n            if ($.deployer != address(0)) {\\r\\n                if (address(uint160(_calldataload(0x04))) != $.deployer) {\\r\\n                    revert SenderNotDeployer();\\r\\n                }\\r\\n            }\\r\\n            if ($.baseERC20 != address(0)) revert AlreadyLinked();\\r\\n            $.baseERC20 = msg.sender;\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                mstore(0x00, 0x01)\\r\\n                return(0x00, 0x20)\\r\\n            }\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev Fallback function for calls from base DN404 contract.\\r\\n    fallback() external payable virtual dn404NFTFallback {}\\r\\n\\r\\n    receive() external payable virtual {}\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                      PRIVATE HELPERS                       */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Helper to read a string from the base DN404 contract.\\r\\n    function _readString(uint256 fnSelector, uint256 arg0)\\r\\n        private\\r\\n        view\\r\\n        returns (string memory result)\\r\\n    {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := mload(0x40)\\r\\n            mstore(0x00, fnSelector)\\r\\n            mstore(0x20, arg0)\\r\\n            if iszero(staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x00)) {\\r\\n                returndatacopy(result, 0x00, returndatasize())\\r\\n                revert(result, returndatasize())\\r\\n            }\\r\\n            returndatacopy(0x00, 0x00, 0x20) // Copy the offset of the string in returndata.\\r\\n            returndatacopy(result, mload(0x00), 0x20) // Copy the length of the string.\\r\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result)) // Copy the string.\\r\\n            mstore(0x40, add(add(result, 0x20), mload(result))) // Allocate memory.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Helper to read a word from the base DN404 contract.\\r\\n    function _readWord(uint256 fnSelector, uint256 arg0, uint256 arg1)\\r\\n        private\\r\\n        view\\r\\n        returns (uint256 result)\\r\\n    {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let m := mload(0x40)\\r\\n            mstore(0x00, fnSelector)\\r\\n            mstore(0x20, arg0)\\r\\n            mstore(0x40, arg1)\\r\\n            if iszero(\\r\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x44, 0x00, 0x20))\\r\\n            ) {\\r\\n                returndatacopy(m, 0x00, returndatasize())\\r\\n                revert(m, returndatasize())\\r\\n            }\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n            result := mload(0x00)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the calldata value at `offset`.\\r\\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            value := calldataload(offset)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\r\\n    function _hasCode(address a) private view returns (bool result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := extcodesize(a) // Can handle dirty upper bits.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\\r\\n    /// Reverts if the target does not support the function correctly.\\r\\n    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\\r\\n        private\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Prepare the calldata.\\r\\n            let m := mload(0x40)\\r\\n            let onERC721ReceivedSelector := 0x150b7a02\\r\\n            mstore(m, onERC721ReceivedSelector)\\r\\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\\r\\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\\r\\n            mstore(add(m, 0x60), id)\\r\\n            mstore(add(m, 0x80), 0x80)\\r\\n            let n := mload(data)\\r\\n            mstore(add(m, 0xa0), n)\\r\\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\\r\\n            // Revert if the call reverts.\\r\\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\\r\\n                if returndatasize() {\\r\\n                    // Bubble up the revert if the call reverts.\\r\\n                    returndatacopy(m, 0x00, returndatasize())\\r\\n                    revert(m, returndatasize())\\r\\n                }\\r\\n            }\\r\\n            // Load the returndata and compare it.\\r\\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\\r\\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/Sheboshi.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"./lib/DN404/DN404.sol\\\";\\r\\nimport \\\"./lib/DN404/DN404Mirror.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\\\";\\r\\nimport {Ownable} from \\\"solady/src/auth/Ownable.sol\\\";\\r\\nimport {LibString} from \\\"solady/src/utils/LibString.sol\\\";\\r\\nimport {SafeTransferLib} from \\\"solady/src/utils/SafeTransferLib.sol\\\";\\r\\nimport {MerkleProofLib} from \\\"solady/src/utils/MerkleProofLib.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\n\\r\\ninterface IERC20 {\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n}\\r\\n\\r\\ncontract Sheboshi is\\r\\n    Initializable,\\r\\n    Ownable,\\r\\n    UUPSUpgradeable,\\r\\n    ReentrancyGuardUpgradeable,\\r\\n    DN404\\r\\n{\\r\\n    event NameChanged(uint256 indexed tokenId, string name);\\r\\n    event ContractURIUpdated();\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n    string private _baseURI;\\r\\n    uint256 public numMinted;\\r\\n    bytes32 private allowlistRoot;\\r\\n    uint256 public saleStartTime;\\r\\n    IERC20 public tokenLEASH;\\r\\n    bool public contractsApproval;\\r\\n    bool public reveal;\\r\\n    uint256 public maxSupply;\\r\\n    uint256 public mintPrice;\\r\\n    mapping(address => bool) claims;\\r\\n    uint8 public LEASHHolderMintLimit;\\r\\n    mapping(address => uint8) LEASHHoldermints;\\r\\n\\r\\n    error InvalidMint();\\r\\n    error InvalidPrice();\\r\\n    error TotalSupplyReached();\\r\\n    error SaleNotStarted();\\r\\n    error InvalidProof();\\r\\n\\r\\n    modifier isValidMint(uint256 amount) {\\r\\n        if (saleStartTime == 0) {\\r\\n            revert SaleNotStarted();\\r\\n        }\\r\\n        if (mintPrice * amount != msg.value) {\\r\\n            revert InvalidPrice();\\r\\n        }\\r\\n        if ((totalSupply() / _unit()) + amount > maxSupply) {\\r\\n            revert TotalSupplyReached();\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function initialize(\\r\\n        string memory name_,\\r\\n        string memory symbol_,\\r\\n        uint96 initialTokenSupply,\\r\\n        bytes32 _allowlistRoot,\\r\\n        uint256 _maxSupply,\\r\\n        uint256 _mintPrice,\\r\\n        uint8 _LEASHHolderMintLimit,\\r\\n        uint96 _earnings\\r\\n    ) public initializer {\\r\\n        _initializeOwner(msg.sender);\\r\\n        __ReentrancyGuard_init();\\r\\n        __UUPSUpgradeable_init();\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n        allowlistRoot = _allowlistRoot;\\r\\n        maxSupply = _maxSupply;\\r\\n        mintPrice = _mintPrice;\\r\\n        LEASHHolderMintLimit = _LEASHHolderMintLimit;\\r\\n        contractsApproval = true;\\r\\n        address mirror = address(new DN404Mirror(msg.sender));\\r\\n        _initializeDN404(0, msg.sender, mirror);\\r\\n        _mint(msg.sender, initialTokenSupply * _unit());\\r\\n    }\\r\\n\\r\\n    function _authorizeUpgrade(\\r\\n        address _newImplementation\\r\\n    ) internal override onlyOwner {}\\r\\n\\r\\n    function name() public view override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() public view override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function setBaseURI(string calldata baseURI_) public onlyOwner {\\r\\n        _baseURI = baseURI_;\\r\\n    }\\r\\n\\r\\n    function setReveal() public onlyOwner {\\r\\n        reveal = true;\\r\\n    }\\r\\n\\r\\n    function setLEASH(address addr) public onlyOwner {\\r\\n        tokenLEASH = IERC20(addr);\\r\\n    }\\r\\n\\r\\n    function startSale() public onlyOwner {\\r\\n        saleStartTime = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function setAllowlistRoot(bytes32 _allowlistRoot) public onlyOwner {\\r\\n        allowlistRoot = _allowlistRoot;\\r\\n    }\\r\\n\\r\\n    function setMaxSupply(uint256 _maxSupply) public onlyOwner {\\r\\n        maxSupply = _maxSupply;\\r\\n    }\\r\\n\\r\\n    function setMintPrice(uint256 _mintPrice) public onlyOwner {\\r\\n        mintPrice = _mintPrice;\\r\\n    }\\r\\n\\r\\n    function setLEASHHolderMintLimit(uint8 _LEASHHolderMintLimit) public onlyOwner {\\r\\n        LEASHHolderMintLimit = _LEASHHolderMintLimit;\\r\\n    }\\r\\n\\r\\n    function tokenURI(\\r\\n        uint256 tokenId\\r\\n    ) public view override returns (string memory result) {\\r\\n        if (_ownerAt(tokenId) == address(0)) revert TokenDoesNotExist();\\r\\n        return !reveal ? _baseURI : string.concat(_baseURI, LibString.toString(tokenId));\\r\\n    }\\r\\n\\r\\n    function changeName(uint256 tokenId, string memory newName) public {\\r\\n        require(\\r\\n            _ownerOf(tokenId) == msg.sender,\\r\\n            \\\"You are not the owner of this NFT\\\"\\r\\n        );\\r\\n        emit NameChanged(tokenId, newName);\\r\\n    }\\r\\n\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        uint256 size;\\r\\n        assembly {\\r\\n            size := extcodesize(account)\\r\\n        }\\r\\n        return size > 0;\\r\\n    }\\r\\n\\r\\n    function claim(\\r\\n        uint256 amount,\\r\\n        bytes32[] calldata proof\\r\\n    ) external nonReentrant {\\r\\n        require(\\r\\n            block.timestamp < saleStartTime + 2 days,\\r\\n            \\\"Sale is not in the SHIBOSHIS phase\\\"\\r\\n        );\\r\\n        require(!claims[msg.sender], \\\"Already claimed\\\");\\r\\n        bytes32 fullRewardBytes = bytes32(amount);\\r\\n        bytes12 rewardBytes = bytes12(fullRewardBytes << 160);\\r\\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, rewardBytes));\\r\\n\\r\\n        if (!MerkleProofLib.verifyCalldata(proof, allowlistRoot, leaf)) {\\r\\n            revert InvalidProof();\\r\\n        }\\r\\n        _mint(msg.sender, amount * _unit());\\r\\n        claims[msg.sender] = true;\\r\\n    }\\r\\n\\r\\n    function approvalToContracts(bool _value) public onlyOwner {\\r\\n        contractsApproval = _value;\\r\\n    }\\r\\n\\r\\n    function mint(\\r\\n        uint256 amount\\r\\n    ) public payable isValidMint(amount) nonReentrant {\\r\\n        if (\\r\\n            block.timestamp >= saleStartTime + 2 days &&\\r\\n            block.timestamp <= saleStartTime + 3 days\\r\\n        ) {\\r\\n            bool istokenLEASHHolder = tokenLEASH.balanceOf(msg.sender) > 0;\\r\\n            require(istokenLEASHHolder, \\\"Only LEASH holders can mint now\\\");\\r\\n            require(LEASHHoldermints[msg.sender] + amount <= LEASHHolderMintLimit, \\\"Mint limit exceeded\\\");\\r\\n            LEASHHoldermints[msg.sender] += uint8(amount);\\r\\n            _mint(msg.sender, amount * _unit());\\r\\n        }\\r\\n        if (block.timestamp >= saleStartTime + 3 days) {\\r\\n            _mint(msg.sender, amount * _unit());\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function approve(\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        if (contractsApproval) {\\r\\n            require(\\r\\n                !isContract(spender),\\r\\n                \\\"Approvals to contracts blocked for now\\\"\\r\\n            );\\r\\n        }\\r\\n        return super.approve(spender, amount);\\r\\n    }\\r\\n\\r\\n    function withdraw() public onlyOwner {\\r\\n        SafeTransferLib.safeTransferAllETH(msg.sender);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"solady/src/auth/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n///\\n/// @dev Note:\\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\\n///\\n/// While the ownable portion follows\\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\\nabstract contract Ownable {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The caller is not authorized to call the function.\\n    error Unauthorized();\\n\\n    /// @dev The `newOwner` cannot be the zero address.\\n    error NewOwnerIsZeroAddress();\\n\\n    /// @dev The `pendingOwner` does not have a valid handover request.\\n    error NoHandoverRequest();\\n\\n    /// @dev Cannot double-initialize.\\n    error AlreadyInitialized();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\n    /// despite it not being as lightweight as a single argument event.\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @dev An ownership handover to `pendingOwner` has been requested.\\n    event OwnershipHandoverRequested(address indexed pendingOwner);\\n\\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The owner slot is given by:\\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\\\"_OWNER_SLOT_NOT\\\")))))`.\\n    /// It is intentionally chosen to be a high value\\n    /// to avoid collision with lower slots.\\n    /// The choice of manual storage layout is to enable compatibility\\n    /// with both regular and upgradeable contracts.\\n    bytes32 internal constant _OWNER_SLOT =\\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\\n\\n    /// The ownership handover slot of `newOwner` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\n    ///     let handoverSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// It stores the expiry timestamp of the two-step ownership handover.\\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\\n\\n    /// @dev Initializes the owner directly without authorization guard.\\n    /// This function must be called upon initialization,\\n    /// regardless of whether the contract is upgradeable or not.\\n    /// This is to enable generalization to both regular and upgradeable contracts,\\n    /// and to save gas in case the initial owner is not the caller.\\n    /// For performance reasons, this function will not check if there\\n    /// is an existing owner.\\n    function _initializeOwner(address newOwner) internal virtual {\\n        if (_guardInitializeOwner()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                if sload(ownerSlot) {\\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Store the new value.\\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n            }\\n        } else {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Store the new value.\\n                sstore(_OWNER_SLOT, newOwner)\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sets the owner directly without authorization guard.\\n    function _setOwner(address newOwner) internal virtual {\\n        if (_guardInitializeOwner()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n                // Store the new value.\\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\\n            }\\n        } else {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n                // Store the new value.\\n                sstore(ownerSlot, newOwner)\\n            }\\n        }\\n    }\\n\\n    /// @dev Throws if the sender is not the owner.\\n    function _checkOwner() internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the caller is not the stored owner, revert.\\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\\n    /// Override to return a different value if needed.\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\\n        return 48 * 3600;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(shl(96, newOwner)) {\\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @dev Allows the owner to renounce their ownership.\\n    function renounceOwnership() public payable virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /// @dev Request a two-step ownership handover to the caller.\\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\\n    function requestOwnershipHandover() public payable virtual {\\n        unchecked {\\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Compute and set the handover slot to `expires`.\\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\\n                mstore(0x00, caller())\\n                sstore(keccak256(0x0c, 0x20), expires)\\n                // Emit the {OwnershipHandoverRequested} event.\\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\n            }\\n        }\\n    }\\n\\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\\n    function cancelOwnershipHandover() public payable virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x20), 0)\\n            // Emit the {OwnershipHandoverCanceled} event.\\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\n        }\\n    }\\n\\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            let handoverSlot := keccak256(0x0c, 0x20)\\n            // If the handover does not exist, or has expired.\\n            if gt(timestamp(), sload(handoverSlot)) {\\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Set the handover slot to 0.\\n            sstore(handoverSlot, 0)\\n        }\\n        _setOwner(pendingOwner);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the owner of the contract.\\n    function owner() public view virtual returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(_OWNER_SLOT)\\n        }\\n    }\\n\\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\n    function ownershipHandoverExpiresAt(address pendingOwner)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the handover slot.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            // Load the handover slot.\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Marks a function as only callable by the owner.\\n    modifier onlyOwner() virtual {\\n        _checkOwner();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/LibString.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for converting numbers into strings and other string operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\n///\\n/// @dev Note:\\n/// For performance and bytecode compactness, most of the string operations are restricted to\\n/// byte strings (7-bit ASCII), except where otherwise specified.\\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\\n/// can lead to undefined behavior.\\nlibrary LibString {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The length of the output is too small to contain all the hex digits.\\n    error HexLengthInsufficient();\\n\\n    /// @dev The length of the string is more than 32 bytes.\\n    error TooBigForSmallString();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The constant returned when the `search` is not found in the string.\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     DECIMAL OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits.\\n            str := add(mload(0x40), 0x80)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            let w := not(0) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 1)`.\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(int256 value) internal pure returns (string memory str) {\\n        if (value >= 0) {\\n            return toString(uint256(value));\\n        }\\n        unchecked {\\n            str = toString(~uint256(value) + 1);\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We still have some spare memory space on the left,\\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\\n            let length := mload(str) // Load the string length.\\n            mstore(str, 0x2d) // Store the '-' character.\\n            str := sub(str, 1) // Move back the string pointer by a byte.\\n            mstore(str, add(length, 1)) // Update the string length.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   HEXADECIMAL OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2 + 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value, length);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexStringNoPrefix(uint256 value, uint256 length)\\n        internal\\n        pure\\n        returns (string memory str)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\n            // We add 0x20 to the total and round down to a multiple of 0x20.\\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let start := sub(str, add(length, length))\\n            let w := not(1) // Tsk.\\n            let temp := value\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for {} 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(xor(str, start)) { break }\\n            }\\n\\n            if temp {\\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2 + 2` bytes.\\n    function toHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\".\\n    /// The output excludes leading \\\"0\\\" from the `toHexString` output.\\n    /// `0x00: \\\"0x0\\\", 0x01: \\\"0x1\\\", 0x12: \\\"0x12\\\", 0x123: \\\"0x123\\\"`.\\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(add(str, o), 0x3078) // Write the \\\"0x\\\" prefix, accounting for leading zero.\\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output excludes leading \\\"0\\\" from the `toHexStringNoPrefix` output.\\n    /// `0x00: \\\"0\\\", 0x01: \\\"1\\\", 0x12: \\\"12\\\", 0x123: \\\"123\\\"`.\\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := mload(str) // Get the length.\\n            str := add(str, o) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2` bytes.\\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\n            str := add(mload(0x40), 0x80)\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let w := not(1) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(temp) { break }\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\", encoded using 2 hexadecimal digits per byte,\\n    /// and the alphabets are capitalized conditionally according to\\n    /// https://eips.ethereum.org/EIPS/eip-55\\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\\n        str = toHexString(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\\n            let o := add(str, 0x22)\\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\\n            let t := shl(240, 136) // `0b10001000 << 240`\\n            for { let i := 0 } 1 {} {\\n                mstore(add(i, i), mul(t, byte(i, hashed)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\\n            o := add(o, 0x20)\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    function toHexString(address value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            str := mload(0x40)\\n\\n            // Allocate the memory.\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\\n            mstore(0x40, add(str, 0x80))\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            str := add(str, 2)\\n            mstore(str, 40)\\n\\n            let o := add(str, 0x20)\\n            mstore(add(o, 40), 0)\\n\\n            value := shl(96, value)\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let i := 0 } 1 {} {\\n                let p := add(o, add(i, i))\\n                let temp := byte(i, value)\\n                mstore8(add(p, 1), mload(and(temp, 15)))\\n                mstore8(p, mload(shr(4, temp)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(raw);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(raw)\\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\\n            mstore(str, add(length, length)) // Store the length of the output.\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let o := add(str, 0x20)\\n            let end := add(raw, length)\\n\\n            for {} iszero(eq(raw, end)) {} {\\n                raw := add(raw, 1)\\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\\n                o := add(o, 2)\\n            }\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   RUNE STRING OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the number of UTF characters in the string.\\n    function runeCount(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(s) {\\n                mstore(0x00, div(not(0), 255))\\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\\n                let o := add(s, 0x20)\\n                let end := add(o, mload(s))\\n                for { result := 1 } 1 { result := add(result, 1) } {\\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\\n                    if iszero(lt(o, end)) { break }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns if this string is a 7-bit ASCII string.\\n    /// (i.e. all characters codes are in [0..127])\\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(7, div(not(0), 255))\\n            result := 1\\n            let n := mload(s)\\n            if n {\\n                let o := add(s, 0x20)\\n                let end := add(o, n)\\n                let last := mload(end)\\n                mstore(end, 0)\\n                for {} 1 {} {\\n                    if and(mask, mload(o)) {\\n                        result := 0\\n                        break\\n                    }\\n                    o := add(o, 0x20)\\n                    if iszero(lt(o, end)) { break }\\n                }\\n                mstore(end, last)\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   BYTE STRING OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // For performance and bytecode compactness, byte string operations are restricted\\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\\n    // can lead to undefined behavior.\\n\\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\\n    function replace(string memory subject, string memory search, string memory replacement)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n            let replacementLength := mload(replacement)\\n\\n            subject := add(subject, 0x20)\\n            search := add(search, 0x20)\\n            replacement := add(replacement, 0x20)\\n            result := add(mload(0x40), 0x20)\\n\\n            let subjectEnd := add(subject, subjectLength)\\n            if iszero(gt(searchLength, subjectLength)) {\\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                mstore(result, t)\\n                                result := add(result, 1)\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Copy the `replacement` one word at a time.\\n                        for { let o := 0 } 1 {} {\\n                            mstore(add(result, o), mload(add(replacement, o)))\\n                            o := add(o, 0x20)\\n                            if iszero(lt(o, replacementLength)) { break }\\n                        }\\n                        result := add(result, replacementLength)\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    mstore(result, t)\\n                    result := add(result, 1)\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n            }\\n\\n            let resultRemainder := result\\n            result := add(mload(0x40), 0x20)\\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\\n            // Copy the rest of the string one word at a time.\\n            for {} lt(subject, subjectEnd) {} {\\n                mstore(resultRemainder, mload(subject))\\n                resultRemainder := add(resultRemainder, 0x20)\\n                subject := add(subject, 0x20)\\n            }\\n            result := sub(result, 0x20)\\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            mstore(result, k) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let subjectLength := mload(subject) } 1 {} {\\n                if iszero(mload(search)) {\\n                    if iszero(gt(from, subjectLength)) {\\n                        result := from\\n                        break\\n                    }\\n                    result := subjectLength\\n                    break\\n                }\\n                let searchLength := mload(search)\\n                let subjectStart := add(subject, 0x20)\\n\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n\\n                subject := add(subjectStart, from)\\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\\n\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(add(search, 0x20))\\n\\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\\n\\n                if iszero(lt(searchLength, 0x20)) {\\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                        if iszero(shr(m, xor(mload(subject), s))) {\\n                            if eq(keccak256(subject, searchLength), h) {\\n                                result := sub(subject, subjectStart)\\n                                break\\n                            }\\n                        }\\n                        subject := add(subject, 1)\\n                        if iszero(lt(subject, end)) { break }\\n                    }\\n                    break\\n                }\\n                for {} 1 {} {\\n                    if iszero(shr(m, xor(mload(subject), s))) {\\n                        result := sub(subject, subjectStart)\\n                        break\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = indexOf(subject, search, 0);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n                let searchLength := mload(search)\\n                if gt(searchLength, mload(subject)) { break }\\n                let w := result\\n\\n                let fromMax := sub(mload(subject), searchLength)\\n                if iszero(gt(fromMax, from)) { from := fromMax }\\n\\n                let end := add(add(subject, 0x20), w)\\n                subject := add(add(subject, 0x20), from)\\n                if iszero(gt(subject, end)) { break }\\n                // As this function is not too often used,\\n                // we shall simply use keccak256 for smaller bytecode size.\\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                    if eq(keccak256(subject, searchLength), h) {\\n                        result := sub(subject, add(end, 1))\\n                        break\\n                    }\\n                    subject := add(subject, w) // `sub(subject, 1)`.\\n                    if iszero(gt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns true if `search` is found in `subject`, false otherwise.\\n    function contains(string memory subject, string memory search) internal pure returns (bool) {\\n        return indexOf(subject, search) != NOT_FOUND;\\n    }\\n\\n    /// @dev Returns whether `subject` starts with `search`.\\n    function startsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                iszero(gt(searchLength, mload(subject))),\\n                eq(\\n                    keccak256(add(subject, 0x20), searchLength),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `subject` ends with `search`.\\n    function endsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            let subjectLength := mload(subject)\\n            // Whether `search` is not longer than `subject`.\\n            let withinRange := iszero(gt(searchLength, subjectLength))\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                withinRange,\\n                eq(\\n                    keccak256(\\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\\n                        searchLength\\n                    ),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns `subject` repeated `times`.\\n    function repeat(string memory subject, uint256 times)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(or(iszero(times), iszero(subjectLength))) {\\n                subject := add(subject, 0x20)\\n                result := mload(0x40)\\n                let output := add(result, 0x20)\\n                for {} 1 {} {\\n                    // Copy the `subject` one word at a time.\\n                    for { let o := 0 } 1 {} {\\n                        mstore(add(output, o), mload(add(subject, o)))\\n                        o := add(o, 0x20)\\n                        if iszero(lt(o, subjectLength)) { break }\\n                    }\\n                    output := add(output, subjectLength)\\n                    times := sub(times, 1)\\n                    if iszero(times) { break }\\n                }\\n                mstore(output, 0) // Zeroize the slot after the string.\\n                let resultLength := sub(output, add(result, 0x20))\\n                mstore(result, resultLength) // Store the length.\\n                // Allocate the memory.\\n                mstore(0x40, add(result, add(resultLength, 0x20)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function slice(string memory subject, uint256 start, uint256 end)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\\n            if lt(start, end) {\\n                result := mload(0x40)\\n                let resultLength := sub(end, start)\\n                mstore(result, resultLength)\\n                subject := add(subject, start)\\n                let w := not(0x1f)\\n                // Copy the `subject` one word at a time, backwards.\\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\\n                    mstore(add(result, o), mload(add(subject, o)))\\n                    o := add(o, w) // `sub(o, 0x20)`.\\n                    if iszero(o) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(add(add(result, 0x20), resultLength), 0)\\n                // Allocate memory for the length and the bytes,\\n                // rounded up to a multiple of 32.\\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\n    /// `start` is a byte offset.\\n    function slice(string memory subject, uint256 start)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = slice(subject, start, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns all the indices of `search` in `subject`.\\n    /// The indices are byte offsets.\\n    function indicesOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256[] memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n\\n            if iszero(gt(searchLength, subjectLength)) {\\n                subject := add(subject, 0x20)\\n                search := add(search, 0x20)\\n                result := add(mload(0x40), 0x20)\\n\\n                let subjectStart := subject\\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Append to `result`.\\n                        mstore(result, sub(subject, subjectStart))\\n                        result := add(result, 0x20)\\n                        // Advance `subject` by `searchLength`.\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                let resultEnd := result\\n                // Assign `result` to the free memory pointer.\\n                result := mload(0x40)\\n                // Store the length of `result`.\\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\\n                // Allocate memory for result.\\n                // We allocate one more word, so this array can be recycled for {split}.\\n                mstore(0x40, add(resultEnd, 0x20))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\n    function split(string memory subject, string memory delimiter)\\n        internal\\n        pure\\n        returns (string[] memory result)\\n    {\\n        uint256[] memory indices = indicesOf(subject, delimiter);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            let indexPtr := add(indices, 0x20)\\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\n            mstore(add(indicesEnd, w), mload(subject))\\n            mstore(indices, add(mload(indices), 1))\\n            let prevIndex := 0\\n            for {} 1 {} {\\n                let index := mload(indexPtr)\\n                mstore(indexPtr, 0x60)\\n                if iszero(eq(index, prevIndex)) {\\n                    let element := mload(0x40)\\n                    let elementLength := sub(index, prevIndex)\\n                    mstore(element, elementLength)\\n                    // Copy the `subject` one word at a time, backwards.\\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\n                        o := add(o, w) // `sub(o, 0x20)`.\\n                        if iszero(o) { break }\\n                    }\\n                    // Zeroize the slot after the string.\\n                    mstore(add(add(element, 0x20), elementLength), 0)\\n                    // Allocate memory for the length and the bytes,\\n                    // rounded up to a multiple of 32.\\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\\n                    // Store the `element` into the array.\\n                    mstore(indexPtr, element)\\n                }\\n                prevIndex := add(index, mload(delimiter))\\n                indexPtr := add(indexPtr, 0x20)\\n                if iszero(lt(indexPtr, indicesEnd)) { break }\\n            }\\n            result := indices\\n            if iszero(mload(delimiter)) {\\n                result := add(indices, 0x20)\\n                mstore(result, sub(mload(indices), 2))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a concatenated string of `a` and `b`.\\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\n    function concat(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            result := mload(0x40)\\n            let aLength := mload(a)\\n            // Copy `a` one word at a time, backwards.\\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\\n                mstore(add(result, o), mload(add(a, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let bLength := mload(b)\\n            let output := add(result, aLength)\\n            // Copy `b` one word at a time, backwards.\\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\\n                mstore(add(output, o), mload(add(b, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let totalLength := add(aLength, bLength)\\n            let last := add(add(result, 0x20), totalLength)\\n            // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            // Stores the length.\\n            mstore(result, totalLength)\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 0x1f), w))\\n        }\\n    }\\n\\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function toCase(string memory subject, bool toUpper)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(subject)\\n            if length {\\n                result := add(mload(0x40), 0x20)\\n                subject := add(subject, 1)\\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\\n                let w := not(0)\\n                for { let o := length } 1 {} {\\n                    o := add(o, w)\\n                    let b := and(0xff, mload(add(subject, o)))\\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\\n                    if iszero(o) { break }\\n                }\\n                result := mload(0x40)\\n                mstore(result, length) // Store the length.\\n                let last := add(add(result, 0x20), length)\\n                mstore(last, 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a string from a small bytes32 string.\\n    /// `s` must be null-terminated, or behavior will be undefined.\\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let n := 0\\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\\\0'.\\n            mstore(result, n)\\n            let o := add(result, 0x20)\\n            mstore(o, s)\\n            mstore(add(o, n), 0)\\n            mstore(0x40, add(result, 0x40))\\n        }\\n    }\\n\\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\\\0'.\\n            mstore(0x00, s)\\n            mstore(result, 0x00)\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the string as a normalized null-terminated small string.\\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(s)\\n            if iszero(lt(result, 33)) {\\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\\n                revert(0x1c, 0x04)\\n            }\\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\\n        }\\n    }\\n\\n    /// @dev Returns a lowercased copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function lower(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, false);\\n    }\\n\\n    /// @dev Returns an UPPERCASED copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function upper(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, true);\\n    }\\n\\n    /// @dev Escapes the string to be used within HTML tags.\\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            // Store the bytes of the packed offsets and strides into the scratch space.\\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\\n            mstore(0x1f, 0x900094)\\n            mstore(0x08, 0xc0000000a6ab)\\n            // Store \\\"&quot;&amp;&#39;&lt;&gt;\\\" into the scratch space.\\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                // Not in `[\\\"\\\\\\\"\\\",\\\"'\\\",\\\"&\\\",\\\"<\\\",\\\">\\\"]`.\\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\\n                    mstore8(result, c)\\n                    result := add(result, 1)\\n                    continue\\n                }\\n                let t := shr(248, mload(c))\\n                mstore(result, mload(and(t, 0x1f)))\\n                result := add(result, shr(5, t))\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\\n    function escapeJSON(string memory s, bool addDoubleQuotes)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            // Store \\\"\\\\\\\\u0000\\\" in scratch space.\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            // Also, store `{0x08:\\\"b\\\", 0x09:\\\"t\\\", 0x0a:\\\"n\\\", 0x0c:\\\"f\\\", 0x0d:\\\"r\\\"}`.\\n            // into the scratch space.\\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\\n            // Bitmask for detecting `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                if iszero(lt(c, 0x20)) {\\n                    if iszero(and(shl(c, 1), e)) {\\n                        // Not in `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n                        mstore8(result, c)\\n                        result := add(result, 1)\\n                        continue\\n                    }\\n                    mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                    mstore8(add(result, 1), c)\\n                    result := add(result, 2)\\n                    continue\\n                }\\n                if iszero(and(shl(c, 1), 0x3700)) {\\n                    // Not in `[\\\"\\\\b\\\",\\\"\\\\t\\\",\\\"\\\\n\\\",\\\"\\\\f\\\",\\\"\\\\d\\\"]`.\\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\\n                    mstore(result, mload(0x19)) // \\\"\\\\\\\\u00XX\\\".\\n                    result := add(result, 6)\\n                    continue\\n                }\\n                mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                mstore8(add(result, 1), mload(add(c, 8)))\\n                result := add(result, 2)\\n            }\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\\n        result = escapeJSON(s, false);\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`.\\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\\n        }\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // These should be evaluated on compile time, as far as possible.\\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\\n            let x := not(or(m, or(b, add(m, and(b, m)))))\\n            let r := shl(7, iszero(iszero(shr(128, x))))\\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // forgefmt: disable-next-item\\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Packs a single string with its length into a single word.\\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\\n    function packOne(string memory a) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We don't need to zero right pad the string,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes.\\n                    mload(add(a, 0x1f)),\\n                    // `length != 0 && length < 32`. Abuses underflow.\\n                    // Assumes that the length is valid and within the block gas limit.\\n                    lt(sub(mload(a), 1), 0x1f)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks a string packed using {packOne}.\\n    /// Returns the empty string if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            result := mload(0x40)\\n            // Allocate 2 words (1 for the length, 1 for the bytes).\\n            mstore(0x40, add(result, 0x40))\\n            // Zeroize the length slot.\\n            mstore(result, 0)\\n            // Store the length and bytes.\\n            mstore(add(result, 0x1f), packed)\\n            // Right pad with zeroes.\\n            mstore(add(add(result, 0x20), mload(result)), 0)\\n        }\\n    }\\n\\n    /// @dev Packs two strings with their lengths into a single word.\\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let aLength := mload(a)\\n            // We don't need to zero right pad the strings,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes of `a` and `b`.\\n                    or(\\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\\n                        mload(sub(add(b, 0x1e), aLength))\\n                    ),\\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\\n                    // Assumes that the lengths are valid and within the block gas limit.\\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks strings packed using {packTwo}.\\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\\n    function unpackTwo(bytes32 packed)\\n        internal\\n        pure\\n        returns (string memory resultA, string memory resultB)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            resultA := mload(0x40)\\n            resultB := add(resultA, 0x40)\\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\n            mstore(0x40, add(resultB, 0x40))\\n            // Zeroize the length slots.\\n            mstore(resultA, 0)\\n            mstore(resultB, 0)\\n            // Store the lengths and bytes.\\n            mstore(add(resultA, 0x1f), packed)\\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\\n            // Right pad with zeroes.\\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\\n        }\\n    }\\n\\n    /// @dev Directly returns `a` without copying.\\n    function directReturn(string memory a) internal pure {\\n        assembly {\\n            // Assumes that the string does not start from the scratch space.\\n            let retStart := sub(a, 0x20)\\n            let retSize := add(mload(a), 0x40)\\n            // Right pad with zeroes. Just in case the string is produced\\n            // by a method that doesn't zero right pad.\\n            mstore(add(retStart, retSize), 0)\\n            // Store the return offset.\\n            mstore(retStart, 0x20)\\n            // End the transaction, returning the string.\\n            return(retStart, retSize)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/MerkleProofLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Gas optimized verification of proof of inclusion for a leaf in a Merkle tree.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/MerkleProofLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/MerkleProofLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol)\\nlibrary MerkleProofLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*            MERKLE PROOF VERIFICATION OPERATIONS            */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns whether `leaf` exists in the Merkle tree with `root`, given `proof`.\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf)\\n        internal\\n        pure\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(proof) {\\n                // Initialize `offset` to the offset of `proof` elements in memory.\\n                let offset := add(proof, 0x20)\\n                // Left shift by 5 is equivalent to multiplying by 0x20.\\n                let end := add(offset, shl(5, mload(proof)))\\n                // Iterate over proof elements to compute root hash.\\n                for {} 1 {} {\\n                    // Slot of `leaf` in scratch space.\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\n                    let scratch := shl(5, gt(leaf, mload(offset)))\\n                    // Store elements to hash contiguously in scratch space.\\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\\n                    mstore(scratch, leaf)\\n                    mstore(xor(scratch, 0x20), mload(offset))\\n                    // Reuse `leaf` to store the hash to reduce stack operations.\\n                    leaf := keccak256(0x00, 0x40)\\n                    offset := add(offset, 0x20)\\n                    if iszero(lt(offset, end)) { break }\\n                }\\n            }\\n            isValid := eq(leaf, root)\\n        }\\n    }\\n\\n    /// @dev Returns whether `leaf` exists in the Merkle tree with `root`, given `proof`.\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf)\\n        internal\\n        pure\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if proof.length {\\n                // Left shift by 5 is equivalent to multiplying by 0x20.\\n                let end := add(proof.offset, shl(5, proof.length))\\n                // Initialize `offset` to the offset of `proof` in the calldata.\\n                let offset := proof.offset\\n                // Iterate over proof elements to compute root hash.\\n                for {} 1 {} {\\n                    // Slot of `leaf` in scratch space.\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\n                    let scratch := shl(5, gt(leaf, calldataload(offset)))\\n                    // Store elements to hash contiguously in scratch space.\\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\\n                    mstore(scratch, leaf)\\n                    mstore(xor(scratch, 0x20), calldataload(offset))\\n                    // Reuse `leaf` to store the hash to reduce stack operations.\\n                    leaf := keccak256(0x00, 0x40)\\n                    offset := add(offset, 0x20)\\n                    if iszero(lt(offset, end)) { break }\\n                }\\n            }\\n            isValid := eq(leaf, root)\\n        }\\n    }\\n\\n    /// @dev Returns whether all `leaves` exist in the Merkle tree with `root`,\\n    /// given `proof` and `flags`.\\n    ///\\n    /// Note:\\n    /// - Breaking the invariant `flags.length == (leaves.length - 1) + proof.length`\\n    ///   will always return false.\\n    /// - The sum of the lengths of `proof` and `leaves` must never overflow.\\n    /// - Any non-zero word in the `flags` array is treated as true.\\n    /// - The memory offset of `proof` must be non-zero\\n    ///   (i.e. `proof` is not pointing to the scratch space).\\n    function verifyMultiProof(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32[] memory leaves,\\n        bool[] memory flags\\n    ) internal pure returns (bool isValid) {\\n        // Rebuilds the root by consuming and producing values on a queue.\\n        // The queue starts with the `leaves` array, and goes into a `hashes` array.\\n        // After the process, the last element on the queue is verified\\n        // to be equal to the `root`.\\n        //\\n        // The `flags` array denotes whether the sibling\\n        // should be popped from the queue (`flag == true`), or\\n        // should be popped from the `proof` (`flag == false`).\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cache the lengths of the arrays.\\n            let leavesLength := mload(leaves)\\n            let proofLength := mload(proof)\\n            let flagsLength := mload(flags)\\n\\n            // Advance the pointers of the arrays to point to the data.\\n            leaves := add(0x20, leaves)\\n            proof := add(0x20, proof)\\n            flags := add(0x20, flags)\\n\\n            // If the number of flags is correct.\\n            for {} eq(add(leavesLength, proofLength), add(flagsLength, 1)) {} {\\n                // For the case where `proof.length + leaves.length == 1`.\\n                if iszero(flagsLength) {\\n                    // `isValid = (proof.length == 1 ? proof[0] : leaves[0]) == root`.\\n                    isValid := eq(mload(xor(leaves, mul(xor(proof, leaves), proofLength))), root)\\n                    break\\n                }\\n\\n                // The required final proof offset if `flagsLength` is not zero, otherwise zero.\\n                let proofEnd := add(proof, shl(5, proofLength))\\n                // We can use the free memory space for the queue.\\n                // We don't need to allocate, since the queue is temporary.\\n                let hashesFront := mload(0x40)\\n                // Copy the leaves into the hashes.\\n                // Sometimes, a little memory expansion costs less than branching.\\n                // Should cost less, even with a high free memory offset of 0x7d00.\\n                leavesLength := shl(5, leavesLength)\\n                for { let i := 0 } iszero(eq(i, leavesLength)) { i := add(i, 0x20) } {\\n                    mstore(add(hashesFront, i), mload(add(leaves, i)))\\n                }\\n                // Compute the back of the hashes.\\n                let hashesBack := add(hashesFront, leavesLength)\\n                // This is the end of the memory for the queue.\\n                // We recycle `flagsLength` to save on stack variables (sometimes save gas).\\n                flagsLength := add(hashesBack, shl(5, flagsLength))\\n\\n                for {} 1 {} {\\n                    // Pop from `hashes`.\\n                    let a := mload(hashesFront)\\n                    // Pop from `hashes`.\\n                    let b := mload(add(hashesFront, 0x20))\\n                    hashesFront := add(hashesFront, 0x40)\\n\\n                    // If the flag is false, load the next proof,\\n                    // else, pops from the queue.\\n                    if iszero(mload(flags)) {\\n                        // Loads the next proof.\\n                        b := mload(proof)\\n                        proof := add(proof, 0x20)\\n                        // Unpop from `hashes`.\\n                        hashesFront := sub(hashesFront, 0x20)\\n                    }\\n\\n                    // Advance to the next flag.\\n                    flags := add(flags, 0x20)\\n\\n                    // Slot of `a` in scratch space.\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\n                    let scratch := shl(5, gt(a, b))\\n                    // Hash the scratch space and push the result onto the queue.\\n                    mstore(scratch, a)\\n                    mstore(xor(scratch, 0x20), b)\\n                    mstore(hashesBack, keccak256(0x00, 0x40))\\n                    hashesBack := add(hashesBack, 0x20)\\n                    if iszero(lt(hashesBack, flagsLength)) { break }\\n                }\\n                isValid :=\\n                    and(\\n                        // Checks if the last value in the queue is same as the root.\\n                        eq(mload(sub(hashesBack, 0x20)), root),\\n                        // And whether all the proofs are used, if required.\\n                        eq(proofEnd, proof)\\n                    )\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns whether all `leaves` exist in the Merkle tree with `root`,\\n    /// given `proof` and `flags`.\\n    ///\\n    /// Note:\\n    /// - Breaking the invariant `flags.length == (leaves.length - 1) + proof.length`\\n    ///   will always return false.\\n    /// - Any non-zero word in the `flags` array is treated as true.\\n    /// - The calldata offset of `proof` must be non-zero\\n    ///   (i.e. `proof` is from a regular Solidity function with a 4-byte selector).\\n    function verifyMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32[] calldata leaves,\\n        bool[] calldata flags\\n    ) internal pure returns (bool isValid) {\\n        // Rebuilds the root by consuming and producing values on a queue.\\n        // The queue starts with the `leaves` array, and goes into a `hashes` array.\\n        // After the process, the last element on the queue is verified\\n        // to be equal to the `root`.\\n        //\\n        // The `flags` array denotes whether the sibling\\n        // should be popped from the queue (`flag == true`), or\\n        // should be popped from the `proof` (`flag == false`).\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the number of flags is correct.\\n            for {} eq(add(leaves.length, proof.length), add(flags.length, 1)) {} {\\n                // For the case where `proof.length + leaves.length == 1`.\\n                if iszero(flags.length) {\\n                    // `isValid = (proof.length == 1 ? proof[0] : leaves[0]) == root`.\\n                    // forgefmt: disable-next-item\\n                    isValid := eq(\\n                        calldataload(\\n                            xor(leaves.offset, mul(xor(proof.offset, leaves.offset), proof.length))\\n                        ),\\n                        root\\n                    )\\n                    break\\n                }\\n\\n                // The required final proof offset if `flagsLength` is not zero, otherwise zero.\\n                let proofEnd := add(proof.offset, shl(5, proof.length))\\n                // We can use the free memory space for the queue.\\n                // We don't need to allocate, since the queue is temporary.\\n                let hashesFront := mload(0x40)\\n                // Copy the leaves into the hashes.\\n                // Sometimes, a little memory expansion costs less than branching.\\n                // Should cost less, even with a high free memory offset of 0x7d00.\\n                calldatacopy(hashesFront, leaves.offset, shl(5, leaves.length))\\n                // Compute the back of the hashes.\\n                let hashesBack := add(hashesFront, shl(5, leaves.length))\\n                // This is the end of the memory for the queue.\\n                // We recycle `flagsLength` to save on stack variables (sometimes save gas).\\n                flags.length := add(hashesBack, shl(5, flags.length))\\n\\n                // We don't need to make a copy of `proof.offset` or `flags.offset`,\\n                // as they are pass-by-value (this trick may not always save gas).\\n\\n                for {} 1 {} {\\n                    // Pop from `hashes`.\\n                    let a := mload(hashesFront)\\n                    // Pop from `hashes`.\\n                    let b := mload(add(hashesFront, 0x20))\\n                    hashesFront := add(hashesFront, 0x40)\\n\\n                    // If the flag is false, load the next proof,\\n                    // else, pops from the queue.\\n                    if iszero(calldataload(flags.offset)) {\\n                        // Loads the next proof.\\n                        b := calldataload(proof.offset)\\n                        proof.offset := add(proof.offset, 0x20)\\n                        // Unpop from `hashes`.\\n                        hashesFront := sub(hashesFront, 0x20)\\n                    }\\n\\n                    // Advance to the next flag offset.\\n                    flags.offset := add(flags.offset, 0x20)\\n\\n                    // Slot of `a` in scratch space.\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\n                    let scratch := shl(5, gt(a, b))\\n                    // Hash the scratch space and push the result onto the queue.\\n                    mstore(scratch, a)\\n                    mstore(xor(scratch, 0x20), b)\\n                    mstore(hashesBack, keccak256(0x00, 0x40))\\n                    hashesBack := add(hashesBack, 0x20)\\n                    if iszero(lt(hashesBack, flags.length)) { break }\\n                }\\n                isValid :=\\n                    and(\\n                        // Checks if the last value in the queue is same as the root.\\n                        eq(mload(sub(hashesBack, 0x20)), root),\\n                        // And whether all the proofs are used, if required.\\n                        eq(proofEnd, proof.offset)\\n                    )\\n                break\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   EMPTY CALLDATA HELPERS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns an empty calldata bytes32 array.\\n    function emptyProof() internal pure returns (bytes32[] calldata proof) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            proof.length := 0\\n        }\\n    }\\n\\n    /// @dev Returns an empty calldata bytes32 array.\\n    function emptyLeaves() internal pure returns (bytes32[] calldata leaves) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            leaves.length := 0\\n        }\\n    }\\n\\n    /// @dev Returns an empty calldata bool array.\\n    function emptyFlags() internal pure returns (bool[] calldata flags) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            flags.length := 0\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DNAlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"ERC1967InvalidImplementation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1967NonPayable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMint\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProof\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LinkMirrorContractFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MirrorAddressIsZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SaleNotStarted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderNotMirror\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TotalSupplyOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TotalSupplyReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UUPSUnauthorizedCallContext\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slot\",\"type\":\"bytes32\"}],\"name\":\"UUPSUnsupportedProxiableUUID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnitIsZero\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ContractURIUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"NameChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"SkipNFTSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"LEASHHolderMintLimit\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UPGRADE_INTERFACE_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"approvalToContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"changeName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractsApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getSkipNFT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint96\",\"name\":\"initialTokenSupply\",\"type\":\"uint96\"},{\"internalType\":\"bytes32\",\"name\":\"_allowlistRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mintPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_LEASHHolderMintLimit\",\"type\":\"uint8\"},{\"internalType\":\"uint96\",\"name\":\"_earnings\",\"type\":\"uint96\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mirrorERC721\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reveal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_allowlistRoot\",\"type\":\"bytes32\"}],\"name\":\"setAllowlistRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setLEASH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_LEASHHolderMintLimit\",\"type\":\"uint8\"}],\"name\":\"setLEASHHolderMintLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSupply\",\"type\":\"uint256\"}],\"name\":\"setMaxSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mintPrice\",\"type\":\"uint256\"}],\"name\":\"setMintPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setReveal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"skipNFT\",\"type\":\"bool\"}],\"name\":\"setSkipNFT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenLEASH\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"result\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Sheboshi", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}