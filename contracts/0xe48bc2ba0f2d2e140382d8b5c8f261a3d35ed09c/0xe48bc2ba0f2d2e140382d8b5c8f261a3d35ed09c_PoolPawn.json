{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2020-08-01\r\n*/\r\n\r\n/*\r\n * Copyright (c) The Force Protocol Development Team\r\n * Submitted for verification at Etherscan.io on 2019-09-17\r\n */\r\n\r\npragma solidity 0.5.13;\r\n// pragma experimental ABIEncoderV2;\r\n\r\ncontract ReentrancyGuard {\r\n    bool private _notEntered;\r\n\r\n    constructor() internal {\r\n        // Storing an initial non-zero value makes deployment a bit more\r\n        // expensive, but in exchange the refund on every call to nonReentrant\r\n        // will be lower in amount. Since refunds are capped to a percetange of\r\n        // the total transaction's gas, it is best to keep them low in cases\r\n        // like this one, to increase the likelihood of the full refund coming\r\n        // into effect.\r\n        _notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _notEntered = false;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _notEntered = true;\r\n    }\r\n}\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size != 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"uint mul overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b != 0, \"uint div by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"uint sub overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"uint add overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"uint mod by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0));\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, value)\r\n        );\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(\r\n            value\r\n        );\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\r\n            value\r\n        );\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n\r\n        require(address(token).isContract());\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success);\r\n\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)));\r\n        }\r\n    }\r\n}\r\n\r\nlibrary addressMakePayable {\r\n    function makePayable(address x) internal pure returns (address payable) {\r\n        return address(uint160(x));\r\n    }\r\n}\r\n\r\ncontract IOracle {\r\n    function get(address token) external view returns (uint256, bool);\r\n}\r\n\r\ncontract IInterestRateModel {\r\n    function getLoanRate(int256 cash, int256 borrow)\r\n    external\r\n    view\r\n    returns (int256 y);\r\n\r\n    function getDepositRate(int256 cash, int256 borrow)\r\n    external\r\n    view\r\n    returns (int256 y);\r\n\r\n    function calculateBalance(\r\n        int256 principal,\r\n        int256 lastIndex,\r\n        int256 newIndex\r\n    ) external view returns (int256 y);\r\n\r\n    function calculateInterestIndex(\r\n        int256 Index,\r\n        int256 r,\r\n        int256 t\r\n    ) external view returns (int256 y);\r\n\r\n    function pert(\r\n        int256 principal,\r\n        int256 r,\r\n        int256 t\r\n    ) external view returns (int256 y);\r\n\r\n    function getNewReserve(\r\n        int256 oldReserve,\r\n        int256 cash,\r\n        int256 borrow,\r\n        int256 blockDelta\r\n    ) external view returns (int256 y);\r\n}\r\n\r\ncontract PoolPawn is ReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    using addressMakePayable for address;\r\n\r\n    uint public constant int_max = 57896044618658097711785492504343953926634992332820282019728792003956564819967;\r\n\r\n    address public admin; //the admin address\r\n    address public proposedAdmin; //use pull over push pattern for admin\r\n\r\n    // uint256 public constant interestRateDenomitor = 1e18;\r\n\r\n    /**\r\n     * @notice Container for borrow balance information\r\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\r\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\r\n     */\r\n    // Balance struct\r\n    struct Balance {\r\n        uint256 principal;\r\n        uint256 interestIndex;\r\n        uint256 totalPnl; //total profit and loss\r\n    }\r\n\r\n    struct Market {\r\n        uint256 accrualBlockNumber;\r\n        int256 supplyRate; //\u5b58\u6b3e\u5229\u7387\r\n        int256 demondRate; //\u501f\u6b3e\u5229\u7387\r\n        IInterestRateModel irm;\r\n        uint256 totalSupply;\r\n        uint256 supplyIndex;\r\n        uint256 totalBorrows;\r\n        uint256 borrowIndex;\r\n        uint256 totalReserves; //\u7cfb\u7edf\u76c8\u5229\r\n        uint256 minPledgeRate; //\u6700\u5c0f\u8d28\u62bc\u7387\r\n        uint256 liquidationDiscount; //\u6e05\u7b97\u6298\u6263\r\n        uint256 decimals; //\u5e01\u79cd\u7684\u6700\u5c0f\u7cbe\u5ea6\r\n    }\r\n\r\n    // Mappings of users' balance of each token\r\n    mapping(address => mapping(address => Balance))\r\n    public accountSupplySnapshot; //tokenContract->address(usr)->SupplySnapshot\r\n    mapping(address => mapping(address => Balance))\r\n    public accountBorrowSnapshot; //tokenContract->address(usr)->BorrowSnapshot\r\n\r\n    struct LiquidateInfo {\r\n        address targetAccount; //\u88ab\u6e05\u7b97\u8d26\u6237\r\n        address liquidator; //\u6e05\u7b97\u4eba\r\n        address assetCollatera; //\u62b5\u62bc\u7269token\u5730\u5740\r\n        address assetBorrow; //\u503a\u52a1token\u5730\u5740\r\n        uint256 liquidateAmount; //\u6e05\u7b97\u989d\u5ea6\uff0c\u62b5\u62bc\u7269\r\n        uint256 targetAmount; //\u76ee\u6807\u989d\u5ea6, \u503a\u52a1\r\n        uint256 timestamp;\r\n    }\r\n\r\n    mapping(uint256 => LiquidateInfo) public liquidateInfoMap;\r\n    uint256 public liquidateIndexes;\r\n\r\n    function setLiquidateInfoMap(\r\n        address _targetAccount,\r\n        address _liquidator,\r\n        address _assetCollatera,\r\n        address _assetBorrow,\r\n        uint256 x,\r\n        uint256 y\r\n    ) internal {\r\n        LiquidateInfo memory newStruct = LiquidateInfo(\r\n            _targetAccount,\r\n            _liquidator,\r\n            _assetCollatera,\r\n            _assetBorrow,\r\n            x,\r\n            y,\r\n            block.timestamp\r\n        );\r\n        // Update liquidation record\r\n        liquidateInfoMap[liquidateIndexes] = newStruct;\r\n        liquidateIndexes++;\r\n    }\r\n\r\n    //user table\r\n    mapping(uint256 => address) public accounts;\r\n    mapping(address => uint256) public indexes;\r\n    uint256 public index = 1;\r\n\r\n    // Add new user\r\n    function join(address who) internal {\r\n        if (indexes[who] == 0) {\r\n            accounts[index] = who;\r\n            indexes[who] = index;\r\n            ++index;\r\n        }\r\n    }\r\n\r\n    event SupplyPawnLog(\r\n        address usr,\r\n        address t,\r\n        uint256 amount,\r\n        uint256 beg,\r\n        uint256 end\r\n    );\r\n    event WithdrawPawnLog(\r\n        address usr,\r\n        address t,\r\n        uint256 amount,\r\n        uint256 beg,\r\n        uint256 end\r\n    );\r\n    event BorrowPawnLog(\r\n        address usr,\r\n        address t,\r\n        uint256 amount,\r\n        uint256 beg,\r\n        uint256 end\r\n    );\r\n    event RepayFastBorrowLog(\r\n        address usr,\r\n        address t,\r\n        uint256 amount,\r\n        uint256 beg,\r\n        uint256 end\r\n    );\r\n    event LiquidateBorrowPawnLog(\r\n        address usr,\r\n        address tBorrow,\r\n        uint256 endBorrow,\r\n        address liquidator,\r\n        address tCol,\r\n        uint256 endCol\r\n    );\r\n    event WithdrawPawnEquityLog(\r\n        address t,\r\n        uint256 equityAvailableBefore,\r\n        uint256 amount,\r\n        address owner\r\n    );\r\n\r\n    mapping(address => Market) public mkts; //tokenAddress->Market\r\n    address[] public collateralTokens; //\u62b5\u62bc\u5e01\u79cd\r\n    IOracle public oracleInstance;\r\n\r\n    uint256 public constant initialInterestIndex = 10**18;\r\n    uint256 public constant defaultOriginationFee = 0; // default is zero bps\r\n    uint256 public constant originationFee = 0;\r\n    uint256 public constant ONE_ETH = 1 ether;\r\n\r\n    // \u589e\u52a0\u62b5\u62bc\u5e01\u79cd\r\n    function addCollateralMarket(address asset) public onlyAdmin {\r\n        for (uint256 i = 0; i < collateralTokens.length; i++) {\r\n            if (collateralTokens[i] == asset) {\r\n                return;\r\n            }\r\n        }\r\n        collateralTokens.push(asset);\r\n    }\r\n\r\n    function getCollateralMarketsLength() external view returns (uint256) {\r\n        return collateralTokens.length;\r\n    }\r\n\r\n    function setInterestRateModel(address t, address irm) public onlyAdmin {\r\n        mkts[t].irm = IInterestRateModel(irm);\r\n    }\r\n\r\n    function setMinPledgeRate(address t, uint256 minPledgeRate)\r\n    external\r\n    onlyAdmin\r\n    {\r\n        mkts[t].minPledgeRate = minPledgeRate;\r\n    }\r\n\r\n    function setLiquidationDiscount(address t, uint256 liquidationDiscount)\r\n    external\r\n    onlyAdmin\r\n    {\r\n        mkts[t].liquidationDiscount = liquidationDiscount;\r\n    }\r\n\r\n    function initCollateralMarket(\r\n        address t,\r\n        address irm,\r\n        address oracle,\r\n        uint256 decimals\r\n    ) external onlyAdmin {\r\n        if (address(oracleInstance) == address(0)) {\r\n            setOracle(oracle);\r\n        }\r\n        Market memory m = mkts[t];\r\n        if (address(m.irm) == address(0)) {\r\n            setInterestRateModel(t, irm);\r\n        }\r\n\r\n        addCollateralMarket(t);\r\n        if (m.supplyIndex == 0) {\r\n            m.supplyIndex = initialInterestIndex;\r\n        }\r\n\r\n        if (m.borrowIndex == 0) {\r\n            m.borrowIndex = initialInterestIndex;\r\n        }\r\n\r\n        if (m.decimals == 0) {\r\n            m.decimals = decimals;\r\n        }\r\n        mkts[t] = m;\r\n    }\r\n\r\n    constructor() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    //Starting from Solidity 0.4.0, contracts without a fallback function automatically revert payments, making the code above redundant.\r\n    // function() external payable {\r\n    //   revert(\"fallback can't be payable\");\r\n    // }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"only admin can do this!\");\r\n        _;\r\n    }\r\n\r\n    function proposeNewAdmin(address admin_) external onlyAdmin {\r\n        proposedAdmin = admin_;\r\n    }\r\n\r\n    function claimAdministration() external {\r\n        require(msg.sender == proposedAdmin, \"Not proposed admin.\");\r\n        admin = proposedAdmin;\r\n        proposedAdmin = address(0);\r\n    }\r\n\r\n    // Set the initial timestamp of tokens\r\n    function setInitialTimestamp(address token) external onlyAdmin {\r\n        mkts[token].accrualBlockNumber = now;\r\n    }\r\n\r\n    function setDecimals(address t, uint256 decimals) external onlyAdmin {\r\n        mkts[t].decimals = decimals;\r\n    }\r\n\r\n    function setOracle(address oracle) public onlyAdmin {\r\n        oracleInstance = IOracle(oracle);\r\n    }\r\n\r\n    modifier existOracle() {\r\n        require(address(oracleInstance) != address(0), \"oracle not set\");\r\n        _;\r\n    }\r\n\r\n    // Get price of oracle\r\n    function fetchAssetPrice(address asset)\r\n    public\r\n    view\r\n    returns (uint256, bool)\r\n    {\r\n        require(address(oracleInstance) != address(0), \"oracle not set\");\r\n        return oracleInstance.get(asset);\r\n    }\r\n\r\n    function valid_uint(uint r) internal view returns (int256) {\r\n        require(r <= int_max, \"uint r is not valid\");\r\n        return int256(r);\r\n    }\r\n\r\n    // Get the price of assetAmount tokens\r\n    function getPriceForAssetAmount(address asset, uint256 assetAmount)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        require(address(oracleInstance) != address(0), \"oracle not set\");\r\n        (uint256 price, bool ok) = fetchAssetPrice(asset);\r\n        require(ok && price != 0, \"invalid token price\");\r\n        return price.mul(assetAmount).div(10**mkts[asset].decimals);\r\n    }\r\n\r\n    // Calc the token amount of usdValue\r\n    function getAssetAmountForValue(address t, uint256 usdValue)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        require(address(oracleInstance) != address(0), \"oracle not set\");\r\n        (uint256 price, bool ok) = fetchAssetPrice(t);\r\n        require(ok && price != 0, \"invalid token price\");\r\n        return usdValue.mul(10**mkts[t].decimals).div(price);\r\n    }\r\n\r\n    // Balance of \"t\" token of this contract\r\n    function getCash(address t) public view returns (uint256) {\r\n        // address(0) represents for eth\r\n        if (t == address(0)) {\r\n            return address(this).balance;\r\n        }\r\n        IERC20 token = IERC20(t);\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    // Balance of \"asset\" token of the \"from\" account\r\n    function getBalanceOf(address asset, address from)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        // address(0) represents for eth\r\n        if (asset == address(0)) {\r\n            return address(from).balance;\r\n        }\r\n\r\n        IERC20 token = IERC20(asset);\r\n\r\n        return token.balanceOf(from);\r\n    }\r\n\r\n    //  totalBorrows / totalSupply\r\n    function loanToDepositRatio(address asset) public view returns (uint256) {\r\n        uint256 loan = mkts[asset].totalBorrows;\r\n        uint256 deposit = mkts[asset].totalSupply;\r\n        // uint256 _1 = 1 ether;\r\n\r\n        return loan.mul(ONE_ETH).div(deposit);\r\n    }\r\n\r\n    //m:market, a:account\r\n    //i(n,m)=i(n-1,m)*(1+rm*t)\r\n    //return P*(i(n,m)/i(n-1,a))\r\n    // Calc the balance of the \"t\" token of \"acc\" account\r\n    function getSupplyBalance(address acc, address t)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        Balance storage supplyBalance = accountSupplySnapshot[t][acc];\r\n\r\n        int256 mSupplyIndex = mkts[t].irm.pert(\r\n            int256(mkts[t].supplyIndex),\r\n            mkts[t].supplyRate,\r\n            int256(now - mkts[t].accrualBlockNumber)\r\n        );\r\n\r\n        uint256 userSupplyCurrent = uint256(\r\n            mkts[t].irm.calculateBalance(\r\n                valid_uint(supplyBalance.principal),\r\n                int256(supplyBalance.interestIndex),\r\n                mSupplyIndex\r\n            )\r\n        );\r\n        return userSupplyCurrent;\r\n    }\r\n\r\n    // Calc the actual USD value of \"t\" token of \"who\" account\r\n    function getSupplyBalanceInUSD(address who, address t)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return getPriceForAssetAmount(t, getSupplyBalance(who, t));\r\n    }\r\n\r\n    // Calc the profit of \"t\" token of \"acc\" account\r\n    function getSupplyPnl(address acc, address t)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        Balance storage supplyBalance = accountSupplySnapshot[t][acc];\r\n\r\n        int256 mSupplyIndex = mkts[t].irm.pert(\r\n            int256(mkts[t].supplyIndex),\r\n            mkts[t].supplyRate,\r\n            int256(now - mkts[t].accrualBlockNumber)\r\n        );\r\n\r\n        uint256 userSupplyCurrent = uint256(\r\n            mkts[t].irm.calculateBalance(\r\n                valid_uint(supplyBalance.principal),\r\n                int256(supplyBalance.interestIndex),\r\n                mSupplyIndex\r\n            )\r\n        );\r\n\r\n        if (userSupplyCurrent > supplyBalance.principal) {\r\n            return\r\n            supplyBalance.totalPnl.add(\r\n                userSupplyCurrent.sub(supplyBalance.principal)\r\n            );\r\n        } else {\r\n            return supplyBalance.totalPnl;\r\n        }\r\n    }\r\n\r\n    // Calc the profit of \"t\" token of \"acc\" account in USD value\r\n    function getSupplyPnlInUSD(address who, address t)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return getPriceForAssetAmount(t, getSupplyPnl(who, t));\r\n    }\r\n\r\n    // Gets USD all token values of supply profit\r\n    function getTotalSupplyPnl(address who)\r\n    public\r\n    view\r\n    returns (uint256 sumPnl)\r\n    {\r\n        uint256 length = collateralTokens.length;\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            uint256 pnl = getSupplyPnlInUSD(who, collateralTokens[i]);\r\n            sumPnl = sumPnl.add(pnl);\r\n        }\r\n    }\r\n\r\n    //m:market, a:account\r\n    //i(n,m)=i(n-1,m)*(1+rm*t)\r\n    //return P*(i(n,m)/i(n-1,a))\r\n    function getBorrowBalance(address acc, address t)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        Balance storage borrowBalance = accountBorrowSnapshot[t][acc];\r\n\r\n        int256 mBorrowIndex = mkts[t].irm.pert(\r\n            int256(mkts[t].borrowIndex),\r\n            mkts[t].demondRate,\r\n            int256(now - mkts[t].accrualBlockNumber)\r\n        );\r\n\r\n        uint256 userBorrowCurrent = uint256(\r\n            mkts[t].irm.calculateBalance(\r\n                valid_uint(borrowBalance.principal),\r\n                int256(borrowBalance.interestIndex),\r\n                mBorrowIndex\r\n            )\r\n        );\r\n        return userBorrowCurrent;\r\n    }\r\n\r\n    function getBorrowBalanceInUSD(address who, address t)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return getPriceForAssetAmount(t, getBorrowBalance(who, t));\r\n    }\r\n\r\n    function getBorrowPnl(address acc, address t)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        Balance storage borrowBalance = accountBorrowSnapshot[t][acc];\r\n\r\n        int256 mBorrowIndex = mkts[t].irm.pert(\r\n            int256(mkts[t].borrowIndex),\r\n            mkts[t].demondRate,\r\n            int256(now - mkts[t].accrualBlockNumber)\r\n        );\r\n\r\n        uint256 userBorrowCurrent = uint256(\r\n            mkts[t].irm.calculateBalance(\r\n                valid_uint(borrowBalance.principal),\r\n                int256(borrowBalance.interestIndex),\r\n                mBorrowIndex\r\n            )\r\n        );\r\n\r\n        return\r\n        borrowBalance.totalPnl.add(userBorrowCurrent).sub(\r\n            borrowBalance.principal\r\n        );\r\n    }\r\n\r\n    function getBorrowPnlInUSD(address who, address t)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return getPriceForAssetAmount(t, getBorrowPnl(who, t));\r\n    }\r\n\r\n    // Gets USD all token values of borrow lose\r\n    function getTotalBorrowPnl(address who)\r\n    public\r\n    view\r\n    returns (uint256 sumPnl)\r\n    {\r\n        uint256 length = collateralTokens.length;\r\n        // uint sumPnl = 0;\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            uint256 pnl = getBorrowPnlInUSD(who, collateralTokens[i]);\r\n            sumPnl = sumPnl.add(pnl);\r\n        }\r\n        // return sumPnl;\r\n    }\r\n\r\n    // BorrowBalance * collateral ratio\r\n    // collateral ratio always great than 1\r\n    function getBorrowBalanceLeverage(address who, address t)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return\r\n        getBorrowBalanceInUSD(who, t).mul(mkts[t].minPledgeRate).div(\r\n            ONE_ETH\r\n        );\r\n    }\r\n\r\n    // Gets USD token values of supply and borrow balances\r\n    function calcAccountTokenValuesInternal(address who, address t)\r\n    public\r\n    view\r\n    returns (uint256, uint256)\r\n    {\r\n        return (getSupplyBalanceInUSD(who, t), getBorrowBalanceInUSD(who, t));\r\n    }\r\n\r\n    // Gets USD token values of supply and borrow balances\r\n    function calcAccountTokenValuesLeverageInternal(address who, address t)\r\n    public\r\n    view\r\n    returns (uint256, uint256)\r\n    {\r\n        return (\r\n        getSupplyBalanceInUSD(who, t),\r\n        getBorrowBalanceLeverage(who, t)\r\n        );\r\n    }\r\n\r\n    // Gets USD all token values of supply and borrow balances\r\n    function calcAccountAllTokenValuesLeverageInternal(address who)\r\n    public\r\n    view\r\n    returns (uint256 sumSupplies, uint256 sumBorrowLeverage)\r\n    {\r\n        uint256 length = collateralTokens.length;\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            (\r\n            uint256 supplyValue,\r\n            uint256 borrowsLeverage\r\n            ) = calcAccountTokenValuesLeverageInternal(\r\n                who,\r\n                collateralTokens[i]\r\n            );\r\n            sumSupplies = sumSupplies.add(supplyValue);\r\n            sumBorrowLeverage = sumBorrowLeverage.add(borrowsLeverage);\r\n        }\r\n    }\r\n\r\n    function calcAccountLiquidity(address who)\r\n    public\r\n    view\r\n    returns (uint256, uint256)\r\n    {\r\n        uint256 sumSupplies;\r\n        uint256 sumBorrowsLeverage; //sumBorrows* collateral ratio\r\n        (\r\n        sumSupplies,\r\n        sumBorrowsLeverage\r\n        ) = calcAccountAllTokenValuesLeverageInternal(who);\r\n        if (sumSupplies < sumBorrowsLeverage) {\r\n            return (0, sumBorrowsLeverage.sub(sumSupplies)); //\u4e0d\u8db3\r\n        } else {\r\n            return (sumSupplies.sub(sumBorrowsLeverage), 0); //\u6709\u4f59\r\n        }\r\n    }\r\n\r\n    struct SupplyIR {\r\n        uint256 startingBalance;\r\n        uint256 newSupplyIndex;\r\n        uint256 userSupplyCurrent;\r\n        uint256 userSupplyUpdated;\r\n        uint256 newTotalSupply;\r\n        uint256 currentCash;\r\n        uint256 updatedCash;\r\n        uint256 newBorrowIndex;\r\n    }\r\n\r\n    // deposit\r\n    function supplyPawn(address t, uint256 amount)\r\n    external\r\n    payable\r\n    nonReentrant\r\n    {\r\n        uint256 supplyAmount = amount;\r\n        // address(0) represents for eth\r\n        if (t == address(0)) {\r\n            require(amount == msg.value, \"Eth value should be equal to amount\");\r\n            supplyAmount = msg.value;\r\n        } else {\r\n            require(msg.value == 0, \"Eth should not be provided\");\r\n        }\r\n        SupplyIR memory tmp;\r\n        Market storage market = mkts[t];\r\n        Balance storage supplyBalance = accountSupplySnapshot[t][msg.sender];\r\n\r\n        uint256 lastTimestamp = market.accrualBlockNumber;\r\n        uint256 blockDelta = now - lastTimestamp;\r\n\r\n        // Calc the supplyIndex of supplyBalance\r\n        tmp.newSupplyIndex = uint256(\r\n            market.irm.pert(\r\n                int256(market.supplyIndex),\r\n                market.supplyRate,\r\n                int256(blockDelta)\r\n            )\r\n        );\r\n        tmp.userSupplyCurrent = uint256(\r\n            market.irm.calculateBalance(\r\n                valid_uint(accountSupplySnapshot[t][msg.sender].principal),\r\n                int256(supplyBalance.interestIndex),\r\n                int256(tmp.newSupplyIndex)\r\n            )\r\n        );\r\n        tmp.userSupplyUpdated = tmp.userSupplyCurrent.add(supplyAmount);\r\n        // Update supply of the market\r\n        tmp.newTotalSupply = market.totalSupply.add(tmp.userSupplyUpdated).sub(\r\n            supplyBalance.principal\r\n        );\r\n\r\n        tmp.currentCash = getCash(t);\r\n        // address(0) represents for eth\r\n        // We support both ERC20 and ETH.\r\n        // Calc the new Balance of the contract if it's ERC20\r\n        // else(ETH) does nothing because the cash has been added(msg.value) when the contract is called\r\n        tmp.updatedCash = t != address(0)\r\n        ? tmp.currentCash.add(supplyAmount)\r\n        : tmp.currentCash;\r\n\r\n        // Update supplyRate and demondRate\r\n        market.supplyRate = market.irm.getDepositRate(\r\n            valid_uint(tmp.updatedCash),\r\n            valid_uint(market.totalBorrows)\r\n        );\r\n        tmp.newBorrowIndex = uint256(\r\n            market.irm.pert(\r\n                int256(market.borrowIndex),\r\n                market.demondRate,\r\n                int256(blockDelta)\r\n            )\r\n        );\r\n        market.demondRate = market.irm.getLoanRate(\r\n            valid_uint(tmp.updatedCash),\r\n            valid_uint(market.totalBorrows)\r\n        );\r\n\r\n        market.borrowIndex = tmp.newBorrowIndex;\r\n        market.supplyIndex = tmp.newSupplyIndex;\r\n        market.totalSupply = tmp.newTotalSupply;\r\n        market.accrualBlockNumber = now;\r\n        // mkts[t] = market;\r\n        tmp.startingBalance = supplyBalance.principal;\r\n        supplyBalance.principal = tmp.userSupplyUpdated;\r\n        supplyBalance.interestIndex = tmp.newSupplyIndex;\r\n\r\n        // Update total profit of user\r\n        if (tmp.userSupplyCurrent > tmp.startingBalance) {\r\n            supplyBalance.totalPnl = supplyBalance.totalPnl.add(\r\n                tmp.userSupplyCurrent.sub(tmp.startingBalance)\r\n            );\r\n        }\r\n\r\n        join(msg.sender);\r\n\r\n        safeTransferFrom(\r\n            t,\r\n            msg.sender,\r\n            address(this),\r\n            address(this).makePayable(),\r\n            supplyAmount,\r\n            0\r\n        );\r\n\r\n        emit SupplyPawnLog(\r\n            msg.sender,\r\n            t,\r\n            supplyAmount,\r\n            tmp.startingBalance,\r\n            tmp.userSupplyUpdated\r\n        );\r\n    }\r\n\r\n    struct WithdrawIR {\r\n        uint256 withdrawAmount;\r\n        uint256 startingBalance;\r\n        uint256 newSupplyIndex;\r\n        uint256 userSupplyCurrent;\r\n        uint256 userSupplyUpdated;\r\n        uint256 newTotalSupply;\r\n        uint256 currentCash;\r\n        uint256 updatedCash;\r\n        uint256 newBorrowIndex;\r\n        uint256 accountLiquidity;\r\n        uint256 accountShortfall;\r\n        uint256 usdValueOfWithdrawal;\r\n        uint256 withdrawCapacity;\r\n    }\r\n\r\n    // withdraw\r\n    function withdrawPawn(address t, uint256 requestedAmount)\r\n    external\r\n    nonReentrant\r\n    {\r\n        Market storage market = mkts[t];\r\n        Balance storage supplyBalance = accountSupplySnapshot[t][msg.sender];\r\n\r\n        WithdrawIR memory tmp;\r\n\r\n        uint256 lastTimestamp = mkts[t].accrualBlockNumber;\r\n        uint256 blockDelta = now - lastTimestamp;\r\n\r\n        // Judge if the user has ability to withdraw\r\n        (tmp.accountLiquidity, tmp.accountShortfall) = calcAccountLiquidity(\r\n            msg.sender\r\n        );\r\n        require(\r\n            tmp.accountLiquidity != 0 && tmp.accountShortfall == 0,\r\n            \"can't withdraw, shortfall\"\r\n        );\r\n        // Update the balance of the user\r\n        tmp.newSupplyIndex = uint256(\r\n            mkts[t].irm.pert(\r\n                int256(mkts[t].supplyIndex),\r\n                mkts[t].supplyRate,\r\n                int256(blockDelta)\r\n            )\r\n        );\r\n        tmp.userSupplyCurrent = uint256(\r\n            mkts[t].irm.calculateBalance(\r\n                valid_uint(supplyBalance.principal),\r\n                int256(supplyBalance.interestIndex),\r\n                int256(tmp.newSupplyIndex)\r\n            )\r\n        );\r\n\r\n        // Get the balance of this contract\r\n        tmp.currentCash = getCash(t);\r\n        // uint(-1) represents the user want to withdraw all of his supplies of the \"t\" token\r\n        if (requestedAmount == uint256(-1)) {\r\n            // max withdraw amount = min(his account liquidity, his balance)\r\n            tmp.withdrawCapacity = getAssetAmountForValue(\r\n                t,\r\n                tmp.accountLiquidity\r\n            );\r\n            tmp.withdrawAmount = min(\r\n                min(tmp.withdrawCapacity, tmp.userSupplyCurrent),\r\n                tmp.currentCash\r\n            );\r\n            // tmp.withdrawAmount = min(tmp.withdrawAmount, tmp.currentCash);\r\n        } else {\r\n            tmp.withdrawAmount = requestedAmount;\r\n        }\r\n\r\n        // Update balance of this contract\r\n        tmp.updatedCash = tmp.currentCash.sub(tmp.withdrawAmount);\r\n        tmp.userSupplyUpdated = tmp.userSupplyCurrent.sub(tmp.withdrawAmount);\r\n\r\n        // Get the amount of token to withdraw\r\n        tmp.usdValueOfWithdrawal = getPriceForAssetAmount(\r\n            t,\r\n            tmp.withdrawAmount\r\n        );\r\n        // require account liquidity is enough\r\n        require(\r\n            tmp.usdValueOfWithdrawal <= tmp.accountLiquidity,\r\n            \"account is short\"\r\n        );\r\n\r\n        // Update totalSupply of the market\r\n        tmp.newTotalSupply = market.totalSupply.add(tmp.userSupplyUpdated).sub(\r\n            supplyBalance.principal\r\n        );\r\n\r\n        tmp.newSupplyIndex = uint256(\r\n            mkts[t].irm.pert(\r\n                int256(mkts[t].supplyIndex),\r\n                mkts[t].supplyRate,\r\n                int256(blockDelta)\r\n            )\r\n        );\r\n\r\n        // Update loan to deposit rate\r\n        market.supplyRate = mkts[t].irm.getDepositRate(\r\n            valid_uint(tmp.updatedCash),\r\n            valid_uint(market.totalBorrows)\r\n        );\r\n        tmp.newBorrowIndex = uint256(\r\n            mkts[t].irm.pert(\r\n                int256(mkts[t].borrowIndex),\r\n                mkts[t].demondRate,\r\n                int256(blockDelta)\r\n            )\r\n        );\r\n        market.demondRate = mkts[t].irm.getLoanRate(\r\n            valid_uint(tmp.updatedCash),\r\n            valid_uint(market.totalBorrows)\r\n        );\r\n\r\n        market.accrualBlockNumber = now;\r\n        market.totalSupply = tmp.newTotalSupply;\r\n        market.supplyIndex = tmp.newSupplyIndex;\r\n        market.borrowIndex = tmp.newBorrowIndex;\r\n        // mkts[t] = market;\r\n        tmp.startingBalance = supplyBalance.principal;\r\n        supplyBalance.principal = tmp.userSupplyUpdated;\r\n        supplyBalance.interestIndex = tmp.newSupplyIndex;\r\n\r\n        safeTransferFrom(\r\n            t,\r\n            address(this).makePayable(),\r\n            address(this),\r\n            msg.sender,\r\n            tmp.withdrawAmount,\r\n            0\r\n        );\r\n\r\n        emit WithdrawPawnLog(\r\n            msg.sender,\r\n            t,\r\n            tmp.withdrawAmount,\r\n            tmp.startingBalance,\r\n            tmp.userSupplyUpdated\r\n        );\r\n    }\r\n\r\n    struct PayBorrowIR {\r\n        uint256 newBorrowIndex;\r\n        uint256 userBorrowCurrent;\r\n        uint256 repayAmount;\r\n        uint256 userBorrowUpdated;\r\n        uint256 newTotalBorrows;\r\n        uint256 currentCash;\r\n        uint256 updatedCash;\r\n        uint256 newSupplyIndex;\r\n        uint256 startingBalance;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a < b) {\r\n            return a;\r\n        } else {\r\n            return b;\r\n        }\r\n    }\r\n\r\n    //`(1 + originationFee) * borrowAmount`\r\n    function calcBorrowAmountWithFee(uint256 borrowAmount)\r\n    public\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        return borrowAmount.mul((ONE_ETH).add(originationFee)).div(ONE_ETH);\r\n    }\r\n\r\n    // supply value * min pledge rate\r\n    function getPriceForAssetAmountMulCollatRatio(\r\n        address t,\r\n        uint256 assetAmount\r\n    ) public view returns (uint256) {\r\n        return\r\n        getPriceForAssetAmount(t, assetAmount)\r\n        .mul(mkts[t].minPledgeRate)\r\n        .div(ONE_ETH);\r\n    }\r\n\r\n    struct BorrowIR {\r\n        uint256 newBorrowIndex;\r\n        uint256 userBorrowCurrent;\r\n        uint256 borrowAmountWithFee;\r\n        uint256 userBorrowUpdated;\r\n        uint256 newTotalBorrows;\r\n        uint256 currentCash;\r\n        uint256 updatedCash;\r\n        uint256 newSupplyIndex;\r\n        uint256 startingBalance;\r\n        uint256 accountLiquidity;\r\n        uint256 accountShortfall;\r\n        uint256 usdValueOfBorrowAmountWithFee;\r\n    }\r\n\r\n    // borrow\r\n    function BorrowPawn(address t, uint256 amount) external nonReentrant {\r\n        BorrowIR memory tmp;\r\n        Market storage market = mkts[t];\r\n        Balance storage borrowBalance = accountBorrowSnapshot[t][msg.sender];\r\n\r\n        uint256 lastTimestamp = mkts[t].accrualBlockNumber;\r\n        uint256 blockDelta = now - lastTimestamp;\r\n\r\n        // Calc borrow index\r\n        tmp.newBorrowIndex = uint256(\r\n            mkts[t].irm.pert(\r\n                int256(mkts[t].borrowIndex),\r\n                mkts[t].demondRate,\r\n                int256(blockDelta)\r\n            )\r\n        );\r\n        int256 lastIndex = int256(borrowBalance.interestIndex);\r\n        tmp.userBorrowCurrent = uint256(\r\n            mkts[t].irm.calculateBalance(\r\n                valid_uint(borrowBalance.principal),\r\n                lastIndex,\r\n                int256(tmp.newBorrowIndex)\r\n            )\r\n        );\r\n        // add borrow fee\r\n        tmp.borrowAmountWithFee = calcBorrowAmountWithFee(amount);\r\n\r\n        tmp.userBorrowUpdated = tmp.userBorrowCurrent.add(\r\n            tmp.borrowAmountWithFee\r\n        );\r\n        // Update market borrows\r\n        tmp.newTotalBorrows = market\r\n        .totalBorrows\r\n        .add(tmp.userBorrowUpdated)\r\n        .sub(borrowBalance.principal);\r\n\r\n        // calc account liquidity\r\n        (tmp.accountLiquidity, tmp.accountShortfall) = calcAccountLiquidity(\r\n            msg.sender\r\n        );\r\n        require(\r\n            tmp.accountLiquidity != 0 && tmp.accountShortfall == 0,\r\n            \"can't borrow, shortfall\"\r\n        );\r\n\r\n        // require accountLiquitidy is enough\r\n        tmp.usdValueOfBorrowAmountWithFee = getPriceForAssetAmountMulCollatRatio(\r\n            t,\r\n            tmp.borrowAmountWithFee\r\n        );\r\n        require(\r\n            tmp.usdValueOfBorrowAmountWithFee <= tmp.accountLiquidity,\r\n            \"can't borrow, without enough value\"\r\n        );\r\n\r\n        // Update the balance of this contract\r\n        tmp.currentCash = getCash(t);\r\n        tmp.updatedCash = tmp.currentCash.sub(amount);\r\n\r\n        tmp.newSupplyIndex = uint256(\r\n            mkts[t].irm.pert(\r\n                int256(mkts[t].supplyIndex),\r\n                mkts[t].supplyRate,\r\n                int256(blockDelta)\r\n            )\r\n        );\r\n        market.supplyRate = mkts[t].irm.getDepositRate(\r\n            valid_uint(tmp.updatedCash),\r\n            valid_uint(tmp.newTotalBorrows)\r\n        );\r\n        market.demondRate = mkts[t].irm.getLoanRate(\r\n            valid_uint(tmp.updatedCash),\r\n            valid_uint(tmp.newTotalBorrows)\r\n        );\r\n\r\n        market.accrualBlockNumber = now;\r\n        market.totalBorrows = tmp.newTotalBorrows;\r\n        market.supplyIndex = tmp.newSupplyIndex;\r\n        market.borrowIndex = tmp.newBorrowIndex;\r\n        // mkts[t] = market;\r\n        tmp.startingBalance = borrowBalance.principal;\r\n        borrowBalance.principal = tmp.userBorrowUpdated;\r\n        borrowBalance.interestIndex = tmp.newBorrowIndex;\r\n\r\n        // \u66f4\u65b0\u5e01\u79cd\u7684\u501f\u5e01\u603b\u989d\r\n        // borrowBalance.totalPnl = borrowBalance.totalPnl.add(tmp.userBorrowCurrent.sub(tmp.startingBalance));\r\n\r\n        safeTransferFrom(\r\n            t,\r\n            address(this).makePayable(),\r\n            address(this),\r\n            msg.sender,\r\n            amount,\r\n            0\r\n        );\r\n\r\n        emit BorrowPawnLog(\r\n            msg.sender,\r\n            t,\r\n            amount,\r\n            tmp.startingBalance,\r\n            tmp.userBorrowUpdated\r\n        );\r\n        // return 0;\r\n    }\r\n\r\n    // repay\r\n    function repayFastBorrow(address t, uint256 amount)\r\n    external\r\n    payable\r\n    nonReentrant\r\n    {\r\n        PayBorrowIR memory tmp;\r\n        Market storage market = mkts[t];\r\n        Balance storage borrowBalance = accountBorrowSnapshot[t][msg.sender];\r\n\r\n        uint256 lastTimestamp = mkts[t].accrualBlockNumber;\r\n        uint256 blockDelta = now - lastTimestamp;\r\n\r\n        // calc the new borrow index\r\n        tmp.newBorrowIndex = uint256(\r\n            mkts[t].irm.pert(\r\n                int256(mkts[t].borrowIndex),\r\n                mkts[t].demondRate,\r\n                int256(blockDelta)\r\n            )\r\n        );\r\n\r\n        int256 lastIndex = int256(borrowBalance.interestIndex);\r\n        tmp.userBorrowCurrent = uint256(\r\n            mkts[t].irm.calculateBalance(\r\n                valid_uint(borrowBalance.principal),\r\n                lastIndex,\r\n                int256(tmp.newBorrowIndex)\r\n            )\r\n        );\r\n\r\n        // uint(-1) represents the user want to repay all of his borrows of \"t\" token\r\n        if (amount == uint256(-1)) {\r\n            // that is the minimum of (his balance, his borrows)\r\n            tmp.repayAmount = min(\r\n                getBalanceOf(t, msg.sender),\r\n                tmp.userBorrowCurrent\r\n            );\r\n            // address(0) represents for eth\r\n            // if the user want to repay eth, he needs to repay a little more\r\n            // because the exact amount will be calculated in the above\r\n            // the extra eth will be returned in the safeTransferFrom\r\n            if (t == address(0)) {\r\n                require(\r\n                    msg.value > tmp.repayAmount,\r\n                    \"Eth value should be larger than repayAmount\"\r\n                );\r\n            }\r\n        } else {\r\n            tmp.repayAmount = amount;\r\n            if (t == address(0)) {\r\n                require(\r\n                    msg.value == tmp.repayAmount,\r\n                    \"Eth value should be equal to repayAmount\"\r\n                );\r\n            }\r\n        }\r\n\r\n        // calc the new borrows of user\r\n        tmp.userBorrowUpdated = tmp.userBorrowCurrent.sub(tmp.repayAmount);\r\n        // calc the new borrows of market\r\n        tmp.newTotalBorrows = market\r\n        .totalBorrows\r\n        .add(tmp.userBorrowUpdated)\r\n        .sub(borrowBalance.principal);\r\n        tmp.currentCash = getCash(t);\r\n        // address(0) represents for eth\r\n        // just like the supplyPawn function, eth has been transfered.\r\n        tmp.updatedCash = t != address(0)\r\n        ? tmp.currentCash.add(tmp.repayAmount)\r\n        : tmp.currentCash;\r\n\r\n        tmp.newSupplyIndex = uint256(\r\n            mkts[t].irm.pert(\r\n                int256(mkts[t].supplyIndex),\r\n                mkts[t].supplyRate,\r\n                int256(blockDelta)\r\n            )\r\n        );\r\n        // update deposit and loan rate\r\n        market.supplyRate = mkts[t].irm.getDepositRate(\r\n            valid_uint(tmp.updatedCash),\r\n            valid_uint(tmp.newTotalBorrows)\r\n        );\r\n        market.demondRate = mkts[t].irm.getLoanRate(\r\n            valid_uint(tmp.updatedCash),\r\n            valid_uint(tmp.newTotalBorrows)\r\n        );\r\n\r\n        market.accrualBlockNumber = now;\r\n        market.totalBorrows = tmp.newTotalBorrows;\r\n        market.supplyIndex = tmp.newSupplyIndex;\r\n        market.borrowIndex = tmp.newBorrowIndex;\r\n        // mkts[t] = market;\r\n        tmp.startingBalance = borrowBalance.principal;\r\n        borrowBalance.principal = tmp.userBorrowUpdated;\r\n        borrowBalance.interestIndex = tmp.newBorrowIndex;\r\n\r\n        safeTransferFrom(\r\n            t,\r\n            msg.sender,\r\n            address(this),\r\n            address(this).makePayable(),\r\n            tmp.repayAmount,\r\n            msg.value\r\n        );\r\n\r\n        emit RepayFastBorrowLog(\r\n            msg.sender,\r\n            t,\r\n            tmp.repayAmount,\r\n            tmp.startingBalance,\r\n            tmp.userBorrowUpdated\r\n        );\r\n\r\n    }\r\n\r\n    // shortfall/(price*(minPledgeRate-liquidationDiscount-1))\r\n    // underwaterAsset is borrowAsset\r\n    function calcDiscountedRepayToEvenAmount(\r\n        address targetAccount,\r\n        address underwaterAsset,\r\n        uint256 underwaterAssetPrice\r\n    ) public view returns (uint256) {\r\n        (, uint256 shortfall) = calcAccountLiquidity(targetAccount);\r\n        uint256 minPledgeRate = mkts[underwaterAsset].minPledgeRate;\r\n        uint256 liquidationDiscount = mkts[underwaterAsset].liquidationDiscount;\r\n        uint256 gap = minPledgeRate.sub(liquidationDiscount).sub(1 ether);\r\n        return\r\n        shortfall.mul(10**mkts[underwaterAsset].decimals).div(\r\n            underwaterAssetPrice.mul(gap).div(ONE_ETH)\r\n        ); //underwater asset amount\r\n    }\r\n\r\n    //[supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\r\n    //[supplyCurrent * (Oracle price for the collateral)] / [ (1 + liquidationDiscount) * (Oracle price for the borrow) ]\r\n    // amount of underwaterAsset to be repayed by liquidator, calculated by the amount of collateral asset\r\n    function calcDiscountedBorrowDenominatedCollateral(\r\n        address underwaterAsset,\r\n        address collateralAsset,\r\n        uint256 underwaterAssetPrice,\r\n        uint256 collateralPrice,\r\n        uint256 supplyCurrent_TargetCollateralAsset\r\n    ) public view returns (uint256 res) {\r\n        uint256 liquidationDiscount = mkts[underwaterAsset].liquidationDiscount;\r\n        uint256 onePlusLiquidationDiscount = (ONE_ETH).add(liquidationDiscount);\r\n        uint256 supplyCurrentTimesOracleCollateral\r\n        = supplyCurrent_TargetCollateralAsset.mul(collateralPrice);\r\n\r\n        res = supplyCurrentTimesOracleCollateral.div(\r\n            onePlusLiquidationDiscount.mul(underwaterAssetPrice).div(ONE_ETH)\r\n        ); //underwaterAsset amout\r\n        res = res.mul(10**mkts[underwaterAsset].decimals);\r\n        res = res.div(10**mkts[collateralAsset].decimals);\r\n    }\r\n\r\n    //closeBorrowAmount_TargetUnderwaterAsset * (1+liquidationDiscount) * priceBorrow/priceCollateral\r\n    //underwaterAssetPrice * (1+liquidationDiscount) *closeBorrowAmount_TargetUnderwaterAsset) / collateralPrice\r\n    //underwater is borrow\r\n    // calc the amount of collateral asset bought by underwaterAsset(amount: closeBorrowAmount_TargetUnderwaterAsset)\r\n    function calcAmountSeize(\r\n        address underwaterAsset,\r\n        address collateralAsset,\r\n        uint256 underwaterAssetPrice,\r\n        uint256 collateralPrice,\r\n        uint256 closeBorrowAmount_TargetUnderwaterAsset\r\n    ) public view returns (uint256 res) {\r\n        uint256 liquidationDiscount = mkts[underwaterAsset].liquidationDiscount;\r\n        uint256 onePlusLiquidationDiscount = (ONE_ETH).add(liquidationDiscount);\r\n        res = underwaterAssetPrice.mul(onePlusLiquidationDiscount);\r\n        res = res.mul(closeBorrowAmount_TargetUnderwaterAsset);\r\n        res = res.div(collateralPrice);\r\n        res = res.div(ONE_ETH);\r\n        res = res.mul(10**mkts[collateralAsset].decimals);\r\n        res = res.div(10**mkts[underwaterAsset].decimals);\r\n    }\r\n\r\n    struct LiquidateIR {\r\n        // we need these addresses in the struct for use with `emitLiquidationEvent` to avoid `CompilerError: Stack too deep, try removing local variables.`\r\n        address targetAccount;\r\n        address assetBorrow;\r\n        address liquidator;\r\n        address assetCollateral;\r\n        // borrow index and supply index are global to the asset, not specific to the user\r\n        uint256 newBorrowIndex_UnderwaterAsset;\r\n        uint256 newSupplyIndex_UnderwaterAsset;\r\n        uint256 newBorrowIndex_CollateralAsset;\r\n        uint256 newSupplyIndex_CollateralAsset;\r\n        // the target borrow's full balance with accumulated interest\r\n        uint256 currentBorrowBalance_TargetUnderwaterAsset;\r\n        // currentBorrowBalance_TargetUnderwaterAsset minus whatever gets repaid as part of the liquidation\r\n        uint256 updatedBorrowBalance_TargetUnderwaterAsset;\r\n        uint256 newTotalBorrows_ProtocolUnderwaterAsset;\r\n        uint256 startingBorrowBalance_TargetUnderwaterAsset;\r\n        uint256 startingSupplyBalance_TargetCollateralAsset;\r\n        uint256 startingSupplyBalance_LiquidatorCollateralAsset;\r\n        uint256 currentSupplyBalance_TargetCollateralAsset;\r\n        uint256 updatedSupplyBalance_TargetCollateralAsset;\r\n        // If liquidator already has a balance of collateralAsset, we will accumulate\r\n        // interest on it before transferring seized collateral from the borrower.\r\n        uint256 currentSupplyBalance_LiquidatorCollateralAsset;\r\n        // This will be the liquidator's accumulated balance of collateral asset before the liquidation (if any)\r\n        // plus the amount seized from the borrower.\r\n        uint256 updatedSupplyBalance_LiquidatorCollateralAsset;\r\n        uint256 newTotalSupply_ProtocolCollateralAsset;\r\n        uint256 currentCash_ProtocolUnderwaterAsset;\r\n        uint256 updatedCash_ProtocolUnderwaterAsset;\r\n        // cash does not change for collateral asset\r\n\r\n        //mkts[t]\r\n        uint256 newSupplyRateMantissa_ProtocolUnderwaterAsset;\r\n        uint256 newBorrowRateMantissa_ProtocolUnderwaterAsset;\r\n        // Why no variables for the interest rates for the collateral asset?\r\n        // We don't need to calculate new rates for the collateral asset since neither cash nor borrows change\r\n\r\n        uint256 discountedRepayToEvenAmount;\r\n        //[supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow) (discountedBorrowDenominatedCollateral)\r\n        uint256 discountedBorrowDenominatedCollateral;\r\n        uint256 maxCloseableBorrowAmount_TargetUnderwaterAsset;\r\n        uint256 closeBorrowAmount_TargetUnderwaterAsset;\r\n        uint256 seizeSupplyAmount_TargetCollateralAsset;\r\n        uint256 collateralPrice;\r\n        uint256 underwaterAssetPrice;\r\n    }\r\n\r\n    // get the max amount to be liquidated\r\n    function calcMaxLiquidateAmount(\r\n        address targetAccount,\r\n        address assetBorrow,\r\n        address assetCollateral\r\n    ) external view returns (uint256) {\r\n        require(msg.sender != targetAccount, \"can't self-liquidate\");\r\n        LiquidateIR memory tmp;\r\n\r\n        uint256 blockDelta = now - mkts[assetBorrow].accrualBlockNumber;\r\n\r\n        Market storage borrowMarket = mkts[assetBorrow];\r\n        Market storage collateralMarket = mkts[assetCollateral];\r\n\r\n        Balance storage borrowBalance_TargeUnderwaterAsset\r\n        = accountBorrowSnapshot[assetBorrow][targetAccount];\r\n\r\n\r\n        Balance storage supplyBalance_TargetCollateralAsset\r\n        = accountSupplySnapshot[assetCollateral][targetAccount];\r\n\r\n        tmp.newSupplyIndex_CollateralAsset = uint256(\r\n            collateralMarket.irm.pert(\r\n                int256(collateralMarket.supplyIndex),\r\n                collateralMarket.supplyRate,\r\n                int256(blockDelta)\r\n            )\r\n        );\r\n        tmp.newBorrowIndex_UnderwaterAsset = uint256(\r\n            borrowMarket.irm.pert(\r\n                int256(borrowMarket.borrowIndex),\r\n                borrowMarket.demondRate,\r\n                int256(blockDelta)\r\n            )\r\n        );\r\n        tmp.currentSupplyBalance_TargetCollateralAsset = uint256(\r\n            collateralMarket.irm.calculateBalance(\r\n                valid_uint(supplyBalance_TargetCollateralAsset.principal),\r\n                int256(supplyBalance_TargetCollateralAsset.interestIndex),\r\n                int256(tmp.newSupplyIndex_CollateralAsset)\r\n            )\r\n        );\r\n        tmp.currentBorrowBalance_TargetUnderwaterAsset = uint256(\r\n            borrowMarket.irm.calculateBalance(\r\n                valid_uint(borrowBalance_TargeUnderwaterAsset.principal),\r\n                int256(borrowBalance_TargeUnderwaterAsset.interestIndex),\r\n                int256(tmp.newBorrowIndex_UnderwaterAsset)\r\n            )\r\n        );\r\n\r\n        bool ok;\r\n        (tmp.collateralPrice, ok) = fetchAssetPrice(assetCollateral);\r\n        require(ok, \"fail to get collateralPrice\");\r\n\r\n        (tmp.underwaterAssetPrice, ok) = fetchAssetPrice(assetBorrow);\r\n        require(ok, \"fail to get underwaterAssetPrice\");\r\n\r\n        tmp.discountedBorrowDenominatedCollateral = calcDiscountedBorrowDenominatedCollateral(\r\n            assetBorrow,\r\n            assetCollateral,\r\n            tmp.underwaterAssetPrice,\r\n            tmp.collateralPrice,\r\n            tmp.currentSupplyBalance_TargetCollateralAsset\r\n        );\r\n        tmp.discountedRepayToEvenAmount = calcDiscountedRepayToEvenAmount(\r\n            targetAccount,\r\n            assetBorrow,\r\n            tmp.underwaterAssetPrice\r\n        );\r\n        tmp.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(\r\n            tmp.currentBorrowBalance_TargetUnderwaterAsset,\r\n            tmp.discountedBorrowDenominatedCollateral\r\n        );\r\n        tmp.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(\r\n            tmp.maxCloseableBorrowAmount_TargetUnderwaterAsset,\r\n            tmp.discountedRepayToEvenAmount\r\n        );\r\n\r\n        return tmp.maxCloseableBorrowAmount_TargetUnderwaterAsset;\r\n    }\r\n\r\n    // liquidate\r\n    function liquidateBorrowPawn(\r\n        address targetAccount,\r\n        address assetBorrow,\r\n        address assetCollateral,\r\n        uint256 requestedAmountClose\r\n    ) external payable nonReentrant {\r\n        require(msg.sender != targetAccount, \"can't self-liquidate\");\r\n        LiquidateIR memory tmp;\r\n        // Copy these addresses into the struct for use with `emitLiquidationEvent`\r\n        // We'll use tmp.liquidator inside this function for clarity vs using msg.sender.\r\n        tmp.targetAccount = targetAccount;\r\n        tmp.assetBorrow = assetBorrow;\r\n        tmp.liquidator = msg.sender;\r\n        tmp.assetCollateral = assetCollateral;\r\n\r\n        uint256 blockDelta = now - mkts[assetBorrow].accrualBlockNumber;\r\n\r\n        Market storage borrowMarket = mkts[assetBorrow];\r\n        Market storage collateralMarket = mkts[assetCollateral];\r\n\r\n        // borrower's borrow balance and supply balance\r\n        Balance storage borrowBalance_TargeUnderwaterAsset\r\n        = accountBorrowSnapshot[assetBorrow][targetAccount];\r\n\r\n        Balance storage supplyBalance_TargetCollateralAsset\r\n        = accountSupplySnapshot[assetCollateral][targetAccount];\r\n\r\n        // Liquidator might already hold some of the collateral asset\r\n        Balance storage supplyBalance_LiquidatorCollateralAsset\r\n        = accountSupplySnapshot[assetCollateral][tmp.liquidator];\r\n\r\n        bool ok;\r\n        (tmp.collateralPrice, ok) = fetchAssetPrice(assetCollateral);\r\n        require(ok, \"fail to get collateralPrice\");\r\n\r\n        (tmp.underwaterAssetPrice, ok) = fetchAssetPrice(assetBorrow);\r\n        require(ok, \"fail to get underwaterAssetPrice\");\r\n\r\n        // calc borrower's borrow balance with the newest interest\r\n        tmp.newBorrowIndex_UnderwaterAsset = uint256(\r\n            borrowMarket.irm.pert(\r\n                int256(borrowMarket.borrowIndex),\r\n                borrowMarket.demondRate,\r\n                int256(blockDelta)\r\n            )\r\n        );\r\n        tmp.currentBorrowBalance_TargetUnderwaterAsset = uint256(\r\n            borrowMarket.irm.calculateBalance(\r\n                valid_uint(borrowBalance_TargeUnderwaterAsset.principal),\r\n                int256(borrowBalance_TargeUnderwaterAsset.interestIndex),\r\n                int256(tmp.newBorrowIndex_UnderwaterAsset)\r\n            )\r\n        );\r\n\r\n        // calc borrower's supply balance with the newest interest\r\n        tmp.newSupplyIndex_CollateralAsset = uint256(\r\n            collateralMarket.irm.pert(\r\n                int256(collateralMarket.supplyIndex),\r\n                collateralMarket.supplyRate,\r\n                int256(blockDelta)\r\n            )\r\n        );\r\n        tmp.currentSupplyBalance_TargetCollateralAsset = uint256(\r\n            collateralMarket.irm.calculateBalance(\r\n                valid_uint(supplyBalance_TargetCollateralAsset.principal),\r\n                int256(supplyBalance_TargetCollateralAsset.interestIndex),\r\n                int256(tmp.newSupplyIndex_CollateralAsset)\r\n            )\r\n        );\r\n\r\n        // calc liquidator's balance of the collateral asset\r\n        tmp.currentSupplyBalance_LiquidatorCollateralAsset = uint256(\r\n            collateralMarket.irm.calculateBalance(\r\n                valid_uint(supplyBalance_LiquidatorCollateralAsset.principal),\r\n                int256(supplyBalance_LiquidatorCollateralAsset.interestIndex),\r\n                int256(tmp.newSupplyIndex_CollateralAsset)\r\n            )\r\n        );\r\n\r\n        // update collateral asset of the market\r\n        tmp.newTotalSupply_ProtocolCollateralAsset = collateralMarket\r\n        .totalSupply\r\n        .add(tmp.currentSupplyBalance_TargetCollateralAsset)\r\n        .sub(supplyBalance_TargetCollateralAsset.principal);\r\n        tmp.newTotalSupply_ProtocolCollateralAsset = tmp\r\n        .newTotalSupply_ProtocolCollateralAsset\r\n        .add(tmp.currentSupplyBalance_LiquidatorCollateralAsset)\r\n        .sub(supplyBalance_LiquidatorCollateralAsset.principal);\r\n\r\n        // calc the max amount to be liquidated\r\n        tmp.discountedBorrowDenominatedCollateral = calcDiscountedBorrowDenominatedCollateral(\r\n            assetBorrow,\r\n            assetCollateral,\r\n            tmp.underwaterAssetPrice,\r\n            tmp.collateralPrice,\r\n            tmp.currentSupplyBalance_TargetCollateralAsset\r\n        );\r\n        tmp.discountedRepayToEvenAmount = calcDiscountedRepayToEvenAmount(\r\n            targetAccount,\r\n            assetBorrow,\r\n            tmp.underwaterAssetPrice\r\n        );\r\n        tmp.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(\r\n            min(\r\n                tmp.currentBorrowBalance_TargetUnderwaterAsset,\r\n                tmp.discountedBorrowDenominatedCollateral\r\n            ),\r\n            tmp.discountedRepayToEvenAmount\r\n        );\r\n\r\n        // uint(-1) represents the user want to liquidate all\r\n        if (requestedAmountClose == uint256(-1)) {\r\n            tmp.closeBorrowAmount_TargetUnderwaterAsset = tmp\r\n            .maxCloseableBorrowAmount_TargetUnderwaterAsset;\r\n        } else {\r\n            tmp.closeBorrowAmount_TargetUnderwaterAsset = requestedAmountClose;\r\n        }\r\n        require(\r\n            tmp.closeBorrowAmount_TargetUnderwaterAsset <=\r\n            tmp.maxCloseableBorrowAmount_TargetUnderwaterAsset,\r\n            \"closeBorrowAmount > maxCloseableBorrowAmount err\"\r\n        );\r\n        // address(0) represents for eth\r\n        if (assetBorrow == address(0)) {\r\n            // just the repay method, eth amount be transfered should be a litte more\r\n            require(\r\n                msg.value >= tmp.closeBorrowAmount_TargetUnderwaterAsset,\r\n                \"Not enough ETH\"\r\n            );\r\n        } else {\r\n            // user needs to have enough balance\r\n            require(\r\n                getBalanceOf(assetBorrow, tmp.liquidator) >=\r\n                tmp.closeBorrowAmount_TargetUnderwaterAsset,\r\n                \"insufficient balance\"\r\n            );\r\n        }\r\n\r\n        // \u8ba1\u7b97\u6e05\u7b97\u4eba\u5b9e\u9645\u6e05\u7b97\u5f97\u5230\u7684\u6b64\u8d28\u62bc\u5e01\u6570\u91cf\r\n        // The amount of collateral asset that liquidator can get\r\n        tmp.seizeSupplyAmount_TargetCollateralAsset = calcAmountSeize(\r\n            assetBorrow,\r\n            assetCollateral,\r\n            tmp.underwaterAssetPrice,\r\n            tmp.collateralPrice,\r\n            tmp.closeBorrowAmount_TargetUnderwaterAsset\r\n        );\r\n\r\n        // \u88ab\u6e05\u7b97\u4eba\u501f\u5e01\u4f59\u989d\u51cf\u5c11\r\n        // Update borrower's balance\r\n        tmp.updatedBorrowBalance_TargetUnderwaterAsset = tmp\r\n        .currentBorrowBalance_TargetUnderwaterAsset\r\n        .sub(tmp.closeBorrowAmount_TargetUnderwaterAsset);\r\n        // \u66f4\u65b0\u501f\u5e01\u5e02\u573a\u603b\u91cf\r\n        // Update borrow market\r\n        tmp.newTotalBorrows_ProtocolUnderwaterAsset = borrowMarket\r\n        .totalBorrows\r\n        .add(tmp.updatedBorrowBalance_TargetUnderwaterAsset)\r\n        .sub(borrowBalance_TargeUnderwaterAsset.principal);\r\n\r\n        tmp.currentCash_ProtocolUnderwaterAsset = getCash(assetBorrow);\r\n        // address(0) represents for eth\r\n        // eth has been transfered when called\r\n        tmp.updatedCash_ProtocolUnderwaterAsset = assetBorrow != address(0)\r\n        ? tmp.currentCash_ProtocolUnderwaterAsset.add(\r\n            tmp.closeBorrowAmount_TargetUnderwaterAsset\r\n        )\r\n        : tmp.currentCash_ProtocolUnderwaterAsset;\r\n\r\n        tmp.newSupplyIndex_UnderwaterAsset = uint256(\r\n            borrowMarket.irm.pert(\r\n                int256(borrowMarket.supplyIndex),\r\n                borrowMarket.demondRate,\r\n                int256(blockDelta)\r\n            )\r\n        );\r\n        borrowMarket.supplyRate = borrowMarket.irm.getDepositRate(\r\n            int256(tmp.updatedCash_ProtocolUnderwaterAsset),\r\n            int256(tmp.newTotalBorrows_ProtocolUnderwaterAsset)\r\n        );\r\n        borrowMarket.demondRate = borrowMarket.irm.getLoanRate(\r\n            int256(tmp.updatedCash_ProtocolUnderwaterAsset),\r\n            int256(tmp.newTotalBorrows_ProtocolUnderwaterAsset)\r\n        );\r\n        tmp.newBorrowIndex_CollateralAsset = uint256(\r\n            collateralMarket.irm.pert(\r\n                int256(collateralMarket.supplyIndex),\r\n                collateralMarket.demondRate,\r\n                int256(blockDelta)\r\n            )\r\n        );\r\n\r\n        // Update the balance of liquidator and borrower\r\n        tmp.updatedSupplyBalance_TargetCollateralAsset = tmp\r\n        .currentSupplyBalance_TargetCollateralAsset\r\n        .sub(tmp.seizeSupplyAmount_TargetCollateralAsset);\r\n        tmp.updatedSupplyBalance_LiquidatorCollateralAsset = tmp\r\n        .currentSupplyBalance_LiquidatorCollateralAsset\r\n        .add(tmp.seizeSupplyAmount_TargetCollateralAsset);\r\n\r\n        borrowMarket.accrualBlockNumber = now;\r\n        borrowMarket.totalBorrows = tmp.newTotalBorrows_ProtocolUnderwaterAsset;\r\n        borrowMarket.supplyIndex = tmp.newSupplyIndex_UnderwaterAsset;\r\n        borrowMarket.borrowIndex = tmp.newBorrowIndex_UnderwaterAsset;\r\n        // mkts[assetBorrow] = borrowMarket;\r\n        collateralMarket.accrualBlockNumber = now;\r\n        collateralMarket.totalSupply = tmp\r\n        .newTotalSupply_ProtocolCollateralAsset;\r\n        collateralMarket.supplyIndex = tmp.newSupplyIndex_CollateralAsset;\r\n        collateralMarket.borrowIndex = tmp.newBorrowIndex_CollateralAsset;\r\n        // mkts[assetCollateral] = collateralMarket;\r\n        tmp.startingBorrowBalance_TargetUnderwaterAsset = borrowBalance_TargeUnderwaterAsset\r\n        .principal; // save for use in event\r\n        borrowBalance_TargeUnderwaterAsset.principal = tmp\r\n        .updatedBorrowBalance_TargetUnderwaterAsset;\r\n        borrowBalance_TargeUnderwaterAsset.interestIndex = tmp\r\n        .newBorrowIndex_UnderwaterAsset;\r\n\r\n        tmp.startingSupplyBalance_TargetCollateralAsset = supplyBalance_TargetCollateralAsset\r\n        .principal; // save for use in event\r\n        supplyBalance_TargetCollateralAsset.principal = tmp\r\n        .updatedSupplyBalance_TargetCollateralAsset;\r\n        supplyBalance_TargetCollateralAsset.interestIndex = tmp\r\n        .newSupplyIndex_CollateralAsset;\r\n\r\n        tmp.startingSupplyBalance_LiquidatorCollateralAsset = supplyBalance_LiquidatorCollateralAsset\r\n        .principal; // save for use in event\r\n        supplyBalance_LiquidatorCollateralAsset.principal = tmp\r\n        .updatedSupplyBalance_LiquidatorCollateralAsset;\r\n        supplyBalance_LiquidatorCollateralAsset.interestIndex = tmp\r\n        .newSupplyIndex_CollateralAsset;\r\n\r\n        setLiquidateInfoMap(\r\n            tmp.targetAccount,\r\n            tmp.liquidator,\r\n            tmp.assetCollateral,\r\n            assetBorrow,\r\n            tmp.seizeSupplyAmount_TargetCollateralAsset,\r\n            tmp.closeBorrowAmount_TargetUnderwaterAsset\r\n        );\r\n\r\n        safeTransferFrom(\r\n            assetBorrow,\r\n            tmp.liquidator.makePayable(),\r\n            address(this),\r\n            address(this).makePayable(),\r\n            tmp.closeBorrowAmount_TargetUnderwaterAsset,\r\n            msg.value\r\n        );\r\n\r\n        emit LiquidateBorrowPawnLog(\r\n            tmp.targetAccount,\r\n            assetBorrow,\r\n            tmp.updatedBorrowBalance_TargetUnderwaterAsset,\r\n            tmp.liquidator,\r\n            tmp.assetCollateral,\r\n            tmp.updatedSupplyBalance_TargetCollateralAsset\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address payable owner,\r\n        address spender,\r\n        address payable to,\r\n        uint256 amount,\r\n        uint256 msgValue\r\n    ) internal {\r\n        require(amount != 0, \"invalid safeTransferFrom amount\");\r\n        if (owner != spender && token != address(0)) {\r\n            // transfer in ERC20\r\n            require(\r\n                IERC20(token).allowance(owner, spender) >= amount,\r\n                \"Insufficient allowance\"\r\n            );\r\n        }\r\n        if (token != address(0)) {\r\n            require(\r\n                IERC20(token).balanceOf(owner) >= amount,\r\n                \"Insufficient balance\"\r\n            );\r\n        } else if (owner == spender) {\r\n            // eth\uff0c owner == spender represents for transfer out, requires enough balance\r\n            require(owner.balance >= amount, \"Insufficient eth balance\");\r\n        }\r\n\r\n        if (owner != spender) {\r\n            // transfer in\r\n            if (token != address(0)) {\r\n                // transferFrom ERC20\r\n                IERC20(token).safeTransferFrom(owner, to, amount);\r\n            } else if (msgValue != 0 && msgValue > amount) {\r\n                // return the extra eth to user\r\n                owner.transfer(msgValue.sub(amount));\r\n            }\r\n            // eth has been transfered when called using msg.value\r\n        } else {\r\n            // transfer out\r\n            if (token != address(0)) {\r\n                // ERC20\r\n                IERC20(token).safeTransfer(to, amount);\r\n            } else {\r\n                // \u53c2\u6570\u8bbe\u7f6e\uff0c msgValue \u5927\u4e8e0\uff0c\u5373\u8fd8\u6b3e\u6216\u6e05\u7b97\u903b\u8f91\uff0c\u5b9e\u9645\u8fd8\u7684\u94b1\u5927\u4e8e\u9700\u8981\u8fd8\u7684\u94b1\uff0c\u9700\u8981\u8fd4\u56de\u591a\u4f59\u7684\u94b1\r\n                // msgValue \u7b49\u4e8e 0\uff0c\u501f\u94b1\u6216\u53d6\u94b1\u903b\u8f91\uff0c\u76f4\u63a5\u8f6c\u51fa amount \u6570\u91cf\u7684\u5e01\r\n\r\n                // msgValue greater than 0 represents for repay or liquidate,\r\n                // which means we should give back the extra eth to user\r\n                // msgValue equals to 0 represents for withdraw or borrow\r\n                // just take the wanted money\r\n                if (msgValue != 0 && msgValue > amount) {\r\n                    to.transfer(msgValue.sub(amount));\r\n                } else {\r\n                    to.transfer(amount);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // admin transfers profit out\r\n    function withdrawPawnEquity(address t, uint256 amount)\r\n    external\r\n    nonReentrant\r\n    onlyAdmin\r\n    {\r\n        uint256 cash = getCash(t);\r\n        uint256 equity = cash.add(mkts[t].totalBorrows).sub(\r\n            mkts[t].totalSupply\r\n        );\r\n        require(equity >= amount, \"insufficient equity amount\");\r\n        safeTransferFrom(\r\n            t,\r\n            address(this).makePayable(),\r\n            address(this),\r\n            admin.makePayable(),\r\n            amount,\r\n            0\r\n        );\r\n        emit WithdrawPawnEquityLog(t, equity, amount, admin);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"beg\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"BorrowPawnLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tBorrow\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endBorrow\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tCol\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endCol\",\"type\":\"uint256\"}],\"name\":\"LiquidateBorrowPawnLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"beg\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"RepayFastBorrowLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"beg\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"SupplyPawnLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"equityAvailableBefore\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"WithdrawPawnEquityLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"beg\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"WithdrawPawnLog\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BorrowPawn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ONE_ETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountBorrowSnapshot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPnl\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountSupplySnapshot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPnl\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accounts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"addCollateralMarket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"calcAccountAllTokenValuesLeverageInternal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sumSupplies\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sumBorrowLeverage\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"calcAccountLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"calcAccountTokenValuesInternal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"calcAccountTokenValuesLeverageInternal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"underwaterAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"underwaterAssetPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closeBorrowAmount_TargetUnderwaterAsset\",\"type\":\"uint256\"}],\"name\":\"calcAmountSeize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"res\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"calcBorrowAmountWithFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"underwaterAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"underwaterAssetPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyCurrent_TargetCollateralAsset\",\"type\":\"uint256\"}],\"name\":\"calcDiscountedBorrowDenominatedCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"res\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"targetAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underwaterAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"underwaterAssetPrice\",\"type\":\"uint256\"}],\"name\":\"calcDiscountedRepayToEvenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"targetAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetBorrow\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetCollateral\",\"type\":\"address\"}],\"name\":\"calcMaxLiquidateAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimAdministration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"collateralTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultOriginationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"fetchAssetPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"usdValue\",\"type\":\"uint256\"}],\"name\":\"getAssetAmountForValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"acc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getBorrowBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getBorrowBalanceInUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getBorrowBalanceLeverage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"acc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getBorrowPnl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getBorrowPnlInUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getCash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCollateralMarketsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetAmount\",\"type\":\"uint256\"}],\"name\":\"getPriceForAssetAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetAmount\",\"type\":\"uint256\"}],\"name\":\"getPriceForAssetAmountMulCollatRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"acc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getSupplyBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getSupplyBalanceInUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"acc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getSupplyPnl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getSupplyPnlInUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"getTotalBorrowPnl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sumPnl\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"getTotalSupplyPnl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sumPnl\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"index\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"indexes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"irm\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"initCollateralMarket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialInterestIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"int_max\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"targetAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetBorrow\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetCollateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requestedAmountClose\",\"type\":\"uint256\"}],\"name\":\"liquidateBorrowPawn\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidateIndexes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"liquidateInfoMap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"targetAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetCollatera\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetBorrow\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidateAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"loanToDepositRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mkts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"accrualBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"supplyRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"demondRate\",\"type\":\"int256\"},{\"internalType\":\"contract IInterestRateModel\",\"name\":\"irm\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPledgeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationDiscount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracleInstance\",\"outputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"originationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin_\",\"type\":\"address\"}],\"name\":\"proposeNewAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposedAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"repayFastBorrow\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"setDecimals\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"setInitialTimestamp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"irm\",\"type\":\"address\"}],\"name\":\"setInterestRateModel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidationDiscount\",\"type\":\"uint256\"}],\"name\":\"setLiquidationDiscount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minPledgeRate\",\"type\":\"uint256\"}],\"name\":\"setMinPledgeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"setOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"supplyPawn\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requestedAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawPawn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawPawnEquity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PoolPawn", "CompilerVersion": "v0.5.13+commit.5b0b510c", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "istanbul", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://92b377c46f5c00676d5b91f01689410a809bd827018743d10d1cb5273cc8c627"}