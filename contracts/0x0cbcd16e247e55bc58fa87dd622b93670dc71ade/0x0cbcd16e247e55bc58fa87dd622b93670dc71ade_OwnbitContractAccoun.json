{"SourceCode": "pragma solidity >=0.8.0 <0.9.0;\r\n\r\n// Lock Year contract for Ownbit.\r\n//\r\n// Lock your assets for 1 year. This is an active lock-up behavior. Why do this? \r\n// Because in investment, human nature is difficult to overcome. You may sell in a hurry because the market plummets,\r\n// or you can't help but rush into the Binance contract service and return to zero in an instant. \r\n// The lock-up contract helps you overcome these problems, allowing you to passively hold the spot of a certain token for a long time.\r\n\r\n// Warning: Once locked into the contract, the assets cannot be transferred in advance under any circumstances.\r\n// Users should carefully evaluate and recognize this limitation.\r\n\r\n// Refresh Lock: re-lock the assets to one year from the current time.\r\n//\r\n// Last update time: 2023-08-18.\r\n// copyright@ownbit.io\r\n\r\ncontract OwnbitContractAccount {\r\n  uint constant public MAX_SPENDER_COUNT = 9;\r\n  uint constant public LOCK_ONE_YEAR = 365 days; \r\n\r\n  // The owner of this contract (who creates it). \r\n  address private owner;\r\n\r\n  // Who can spend this money.\r\n  address[] private spenders;\r\n\r\n  // The timestamp the current lock to time. From when the assets can be spent.\r\n  uint256 private lockToTime = 0; \r\n  \r\n  // An event sent when funds are received.\r\n  event Funded(address from, uint value);\r\n  \r\n  // An event sent when spend is executed.\r\n  event Spent(address to, uint value);\r\n\r\n  // An event sent when the lock is refreshed.\r\n  event LockRefreshed();\r\n\r\n  modifier validRequirement(uint spenderCount) {\r\n    require (spenderCount <= MAX_SPENDER_COUNT\r\n            && spenderCount >= 1);\r\n    _;\r\n  }\r\n  \r\n  /// @dev Contract constructor sets initial spenders and contract owner.\r\n  /// @param _spenders List of address of spenders.\r\n  /// @param _owner Owner address.\r\n  constructor(address[] memory _spenders, address _owner) validRequirement(_spenders.length) {\r\n    for (uint i = 0; i < _spenders.length; i++) {\r\n        //spender must be non-zero\r\n        if (_spenders[i] == address(0x0)) {\r\n            revert();\r\n        }\r\n    }\r\n    owner = _owner;\r\n    spenders = _spenders;\r\n  }\r\n\r\n  // The fallback function for this contract.\r\n  fallback() external payable {\r\n    if (msg.value > 0) {\r\n        emit Funded(msg.sender, msg.value);\r\n    }\r\n  }\r\n  \r\n  // @dev Returns list of spenders.\r\n  // @return List of spender addresses.\r\n  function getSpenders() public view returns (address[] memory) {\r\n    return spenders;\r\n  }\r\n\r\n  function getOwner() public view returns (address) {\r\n    return owner;\r\n  }\r\n    \r\n  function getLockToTime() public view returns (uint256) {\r\n    return lockToTime;\r\n  }\r\n\r\n  function getVersion() public pure returns(uint) {\r\n      return 1;\r\n  }\r\n  \r\n  //destination can be a normal address or an ERC20 contract address.\r\n  //value is the wei transferred to the destination.\r\n  //data for transfer ether: 0x\r\n  //data for transfer erc20 example: 0xa9059cbb000000000000000000000000ac6342a7efb995d63cc91db49f6023e95873d25000000000000000000000000000000000000000000000000000000000000003e8\r\n  //data for transfer erc721 example: 0x42842e0e00000000000000000000000097b65ad59c8c96f2dd786751e6279a1a6d34a4810000000000000000000000006cb33e7179860d24635c66850f1f6a5d4f8eee6d0000000000000000000000000000000000000000000000000000000000042134\r\n  //data can contain any data to be executed. \r\n  function spend(address destination, uint256 value, bytes calldata data) external {\r\n    require(destination != address(this), \"Not allow sending to yourself\");\r\n    require(isSpender(msg.sender), \"Not a spender\");\r\n    require(block.timestamp >= lockToTime, \"lockToTime is not yet reached\");\r\n\r\n    //transfer tokens from this contract to the destination address\r\n    (bool sent,) = destination.call{value: value}(data);\r\n    if (sent) {\r\n        emit Spent(destination, value);\r\n    }\r\n  }\r\n  \r\n  //send a tx from the owner address to refresh the lock\r\n  //Allow the owner to transfer some ETH, although this is not necessary.\r\n  function refreshLock() external payable {\r\n    require(owner == msg.sender, \"Not the owner\");\r\n    lockToTime = block.timestamp + LOCK_ONE_YEAR;\r\n    emit LockRefreshed();\r\n  }\r\n  \r\n  // Is this address a spender\r\n  function isSpender(address addr) private view returns (bool) {\r\n    for (uint i = 0; i < spenders.length; i++) {\r\n        if (addr == spenders[i]) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  //support ERC721 safeTransferFrom\r\n  function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4) {\r\n      return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\r\n  }\r\n\r\n  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data) external returns(bytes4) {\r\n      return bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"));\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_spenders\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Funded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LockRefreshed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Spent\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"LOCK_ONE_YEAR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SPENDER_COUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLockToTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSpenders\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refreshLock\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"spend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OwnbitContractAccount", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000c77bc9e93c8849ee8b45b1abdfab6e099272f60d0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000c77bc9e93c8849ee8b45b1abdfab6e099272f60d", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ab4a64ced354afaf9c2bf54b5095c279435d2890e9ef72ee82564a3b305d2b82"}