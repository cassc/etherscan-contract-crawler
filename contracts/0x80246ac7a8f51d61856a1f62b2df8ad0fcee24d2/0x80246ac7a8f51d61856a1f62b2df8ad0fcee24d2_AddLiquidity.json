{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IReserves.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\ninterface IReserves {\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1);\\n\\n    function getFees() external view returns (uint256 fee0, uint256 fee1);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITwapERC20.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\nimport './IERC20.sol';\\n\\ninterface ITwapERC20 is IERC20 {\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITwapOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\ninterface ITwapOracle {\\n    event OwnerSet(address owner);\\n    event UniswapPairSet(address uniswapPair);\\n\\n    function decimalsConverter() external view returns (int256);\\n\\n    function xDecimals() external view returns (uint8);\\n\\n    function yDecimals() external view returns (uint8);\\n\\n    function owner() external view returns (address);\\n\\n    function uniswapPair() external view returns (address);\\n\\n    function getPriceInfo() external view returns (uint256 priceAccumulator, uint256 priceTimestamp);\\n\\n    function getSpotPrice() external view returns (uint256);\\n\\n    function getAveragePrice(uint256 priceAccumulator, uint256 priceTimestamp) external view returns (uint256);\\n\\n    function setOwner(address _owner) external;\\n\\n    function setUniswapPair(address _uniswapPair) external;\\n\\n    function tradeX(\\n        uint256 xAfter,\\n        uint256 xBefore,\\n        uint256 yBefore,\\n        bytes calldata data\\n    ) external view returns (uint256 yAfter);\\n\\n    function tradeY(\\n        uint256 yAfter,\\n        uint256 yBefore,\\n        uint256 xBefore,\\n        bytes calldata data\\n    ) external view returns (uint256 xAfter);\\n\\n    function depositTradeXIn(\\n        uint256 xLeft,\\n        uint256 xBefore,\\n        uint256 yBefore,\\n        bytes calldata data\\n    ) external view returns (uint256 xIn);\\n\\n    function depositTradeYIn(\\n        uint256 yLeft,\\n        uint256 yBefore,\\n        uint256 xBefore,\\n        bytes calldata data\\n    ) external view returns (uint256 yIn);\\n\\n    function getSwapAmount0Out(\\n        uint256 swapFee,\\n        uint256 amount1In,\\n        bytes calldata data\\n    ) external view returns (uint256 amount0Out);\\n\\n    function getSwapAmount1Out(\\n        uint256 swapFee,\\n        uint256 amount0In,\\n        bytes calldata data\\n    ) external view returns (uint256 amount1Out);\\n\\n    function getSwapAmountInMaxOut(\\n        bool inverse,\\n        uint256 swapFee,\\n        uint256 _amountOut,\\n        bytes calldata data\\n    ) external view returns (uint256 amountIn, uint256 amountOut);\\n\\n    function getSwapAmountInMinOut(\\n        bool inverse,\\n        uint256 swapFee,\\n        uint256 _amountOut,\\n        bytes calldata data\\n    ) external view returns (uint256 amountIn, uint256 amountOut);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITwapPair.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\nimport './ITwapERC20.sol';\\nimport './IReserves.sol';\\n\\ninterface ITwapPair is ITwapERC20, IReserves {\\n    event Mint(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 liquidityOut, address indexed to);\\n    event Burn(address indexed sender, uint256 amount0Out, uint256 amount1Out, uint256 liquidityIn, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event SetMintFee(uint256 fee);\\n    event SetBurnFee(uint256 fee);\\n    event SetSwapFee(uint256 fee);\\n    event SetOracle(address account);\\n    event SetTrader(address trader);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function oracle() external view returns (address);\\n\\n    function trader() external view returns (address);\\n\\n    function mintFee() external view returns (uint256);\\n\\n    function setMintFee(uint256 fee) external;\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function burnFee() external view returns (uint256);\\n\\n    function setBurnFee(uint256 fee) external;\\n\\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\\n\\n    function swapFee() external view returns (uint256);\\n\\n    function setSwapFee(uint256 fee) external;\\n\\n    function setOracle(address account) external;\\n\\n    function setTrader(address account) external;\\n\\n    function collect(address to) external;\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function sync() external;\\n\\n    function initialize(\\n        address _token0,\\n        address _token1,\\n        address _oracle,\\n        address _trader\\n    ) external;\\n\\n    function getSwapAmount0In(uint256 amount1Out, bytes calldata data) external view returns (uint256 swapAmount0In);\\n\\n    function getSwapAmount1In(uint256 amount0Out, bytes calldata data) external view returns (uint256 swapAmount1In);\\n\\n    function getSwapAmount0Out(uint256 amount1In, bytes calldata data) external view returns (uint256 swapAmount0Out);\\n\\n    function getSwapAmount1Out(uint256 amount0In, bytes calldata data) external view returns (uint256 swapAmount1Out);\\n\\n    function getDepositAmount0In(uint256 amount0, bytes calldata data) external view returns (uint256 depositAmount0In);\\n\\n    function getDepositAmount1In(uint256 amount1, bytes calldata data) external view returns (uint256 depositAmount1In);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/AddLiquidity.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\nimport './TransferHelper.sol';\\nimport './SafeMath.sol';\\nimport './Math.sol';\\nimport '../interfaces/ITwapPair.sol';\\nimport '../interfaces/ITwapOracle.sol';\\n\\nlibrary AddLiquidity {\\n    using SafeMath for uint256;\\n\\n    function addLiquidity(\\n        address pair,\\n        uint256 amount0Desired,\\n        uint256 amount1Desired\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256 amount0,\\n            uint256 amount1,\\n            uint256 swapToken\\n        )\\n    {\\n        if (amount0Desired == 0 || amount1Desired == 0) {\\n            if (amount0Desired > 0) {\\n                swapToken = 1;\\n            } else if (amount1Desired > 0) {\\n                swapToken = 2;\\n            }\\n            return (0, 0, swapToken);\\n        }\\n        (uint256 reserve0, uint256 reserve1) = ITwapPair(pair).getReserves();\\n        if (reserve0 == 0 && reserve1 == 0) {\\n            (amount0, amount1) = (amount0Desired, amount1Desired);\\n        } else {\\n            require(reserve0 > 0 && reserve1 > 0, 'AL07');\\n            uint256 amount1Optimal = amount0Desired.mul(reserve1) / reserve0;\\n            if (amount1Optimal <= amount1Desired) {\\n                swapToken = 2;\\n                (amount0, amount1) = (amount0Desired, amount1Optimal);\\n            } else {\\n                uint256 amount0Optimal = amount1Desired.mul(reserve0) / reserve1;\\n                assert(amount0Optimal <= amount0Desired);\\n                swapToken = 1;\\n                (amount0, amount1) = (amount0Optimal, amount1Desired);\\n            }\\n\\n            uint256 totalSupply = ITwapPair(pair).totalSupply();\\n            uint256 liquidityOut = Math.min(amount0.mul(totalSupply) / reserve0, amount1.mul(totalSupply) / reserve1);\\n            if (liquidityOut == 0) {\\n                amount0 = 0;\\n                amount1 = 0;\\n            }\\n        }\\n    }\\n\\n    function addLiquidityAndMint(\\n        address pair,\\n        address to,\\n        address token0,\\n        address token1,\\n        uint256 amount0Desired,\\n        uint256 amount1Desired\\n    )\\n        external\\n        returns (\\n            uint256 amount0Left,\\n            uint256 amount1Left,\\n            uint256 swapToken\\n        )\\n    {\\n        uint256 amount0;\\n        uint256 amount1;\\n        (amount0, amount1, swapToken) = addLiquidity(pair, amount0Desired, amount1Desired);\\n        if (amount0 == 0 || amount1 == 0) {\\n            return (amount0Desired, amount1Desired, swapToken);\\n        }\\n        TransferHelper.safeTransfer(token0, pair, amount0);\\n        TransferHelper.safeTransfer(token1, pair, amount1);\\n        ITwapPair(pair).mint(to);\\n\\n        amount0Left = amount0Desired.sub(amount0);\\n        amount1Left = amount1Desired.sub(amount1);\\n    }\\n\\n    function swapDeposit0(\\n        address pair,\\n        address token0,\\n        uint256 amount0,\\n        uint256 minSwapPrice,\\n        uint16 tolerance,\\n        bytes calldata data\\n    ) external returns (uint256 amount0Left, uint256 amount1Left) {\\n        uint256 amount0In = ITwapPair(pair).getDepositAmount0In(amount0, data);\\n        amount1Left = ITwapPair(pair).getSwapAmount1Out(amount0In, data).sub(tolerance);\\n        if (amount1Left == 0) {\\n            return (amount0, amount1Left);\\n        }\\n        uint256 price = getPrice(amount0In, amount1Left, pair);\\n        require(minSwapPrice == 0 || price >= minSwapPrice, 'AL15');\\n        TransferHelper.safeTransfer(token0, pair, amount0In);\\n        ITwapPair(pair).swap(0, amount1Left, address(this), data);\\n        amount0Left = amount0.sub(amount0In);\\n    }\\n\\n    function swapDeposit1(\\n        address pair,\\n        address token1,\\n        uint256 amount1,\\n        uint256 maxSwapPrice,\\n        uint16 tolerance,\\n        bytes calldata data\\n    ) external returns (uint256 amount0Left, uint256 amount1Left) {\\n        uint256 amount1In = ITwapPair(pair).getDepositAmount1In(amount1, data);\\n        amount0Left = ITwapPair(pair).getSwapAmount0Out(amount1In, data).sub(tolerance);\\n        if (amount0Left == 0) {\\n            return (amount0Left, amount1);\\n        }\\n        uint256 price = getPrice(amount0Left, amount1In, pair);\\n        require(maxSwapPrice == 0 || price <= maxSwapPrice, 'AL16');\\n        TransferHelper.safeTransfer(token1, pair, amount1In);\\n        ITwapPair(pair).swap(amount0Left, 0, address(this), data);\\n        amount1Left = amount1.sub(amount1In);\\n    }\\n\\n    function getPrice(\\n        uint256 amount0,\\n        uint256 amount1,\\n        address pair\\n    ) internal view returns (uint256) {\\n        ITwapOracle oracle = ITwapOracle(ITwapPair(pair).oracle());\\n        return amount1.mul(uint256(oracle.decimalsConverter())).div(amount0);\\n    }\\n\\n    function _refundDeposit(\\n        address to,\\n        address token0,\\n        address token1,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) internal {\\n        if (amount0 > 0) {\\n            TransferHelper.safeTransfer(token0, to, amount0);\\n        }\\n        if (amount1 > 0) {\\n            TransferHelper.safeTransfer(token1, to, amount1);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\n// a library for performing various math operations\\n\\nlibrary Math {\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x > y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    int256 private constant _INT256_MIN = -2**255;\\n\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, 'SM4E');\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = sub(x, y, 'SM12');\\n    }\\n\\n    function sub(\\n        uint256 x,\\n        uint256 y,\\n        string memory message\\n    ) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, message);\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, 'SM2A');\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, 'SM43');\\n        return a / b;\\n    }\\n\\n    function ceil_div(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = div(a, b);\\n        if (a != mul(b, c)) {\\n            return add(c, 1);\\n        }\\n    }\\n\\n    function toUint32(uint256 n) internal pure returns (uint32) {\\n        require(n <= type(uint32).max, 'SM50');\\n        return uint32(n);\\n    }\\n\\n    function toUint64(uint256 n) internal pure returns (uint64) {\\n        require(n <= type(uint64).max, 'SM54');\\n        return uint64(n);\\n    }\\n\\n    function toUint112(uint256 n) internal pure returns (uint112) {\\n        require(n <= type(uint112).max, 'SM51');\\n        return uint112(n);\\n    }\\n\\n    function toInt256(uint256 unsigned) internal pure returns (int256 signed) {\\n        require(unsigned <= uint256(type(int256).max), 'SM34');\\n        signed = int256(unsigned);\\n    }\\n\\n    // int256\\n\\n    function add(int256 a, int256 b) internal pure returns (int256 c) {\\n        c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), 'SM4D');\\n    }\\n\\n    function sub(int256 a, int256 b) internal pure returns (int256 c) {\\n        c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), 'SM11');\\n    }\\n\\n    function mul(int256 a, int256 b) internal pure returns (int256 c) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT256_MIN), 'SM29');\\n\\n        c = a * b;\\n        require(c / a == b, 'SM29');\\n    }\\n\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, 'SM43');\\n        require(!(b == -1 && a == _INT256_MIN), 'SM42');\\n\\n        return a / b;\\n    }\\n\\n    function neg_floor_div(int256 a, int256 b) internal pure returns (int256 c) {\\n        c = div(a, b);\\n        if ((a < 0 && b > 0) || (a >= 0 && b < 0)) {\\n            if (a != mul(b, c)) {\\n                c = sub(c, 1);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH4B');\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH05');\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH0E');\\n    }\\n\\n    function safeTransferETH(\\n        address to,\\n        uint256 value,\\n        uint256 gasLimit\\n    ) internal {\\n        (bool success, ) = to.call{ value: value, gas: gasLimit }('');\\n        require(success, 'TH3F');\\n    }\\n\\n    function transferETH(\\n        address to,\\n        uint256 value,\\n        uint256 gasLimit\\n    ) internal returns (bool success) {\\n        (success, ) = to.call{ value: value, gas: gasLimit }('');\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[]", "ContractName": "AddLiquidity", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}