/**
 *Submitted for verification at Etherscan.io on 2023-04-27
*/

/*
                                                  .:^~~!!!!~^:.                                                                             
                                              .:!7???777777???77!^:.          .:^~~!!7777!!~~^.                                             
                                            :!7?77777777777777777??7!^.  .:~!77??77777777777???7!:                                          
                                          :7?77777777777777777777777??7~^7?7777777777777777777777?!.                                        
                                        :!77777777777!!~~~~~~~~~~~~~!77?7^!77777777777777777777777?7.                                       
                                       ~777777777!~~~~!777777777777!~~~!77^7777777777777!!!!!!!!!777!.                                      
                                     .!?777777!~~~!77777777777777777777~^~~~77!!~~~~^^^^^^~~~~~~~~~~~:                                      
                                     !?777777!777777777777777777777777777~~^777777777777777777777!!!!!^:.                                   
                                    ^?777777777777777777777777!!!!~~!!!!!!~:7777777777777777777777777777!!^.                                
                                   :7777777777777777777777!!~!!!777!!!!!!!7!^!?7777777777777777777!!~~~~!!!!!!^.                            
                              .:^~^!7777777777777777777!!~!!7!!~~~~!!!77!!!!~.^777777777777777!!~~~~~~!!!!!!~~~^.                           
                           .~77??!~77777777777777!!!~~~~~~~^^^^^~~~~~~~~~~~!!!!!~!7777777!!!~~~~~~!!777!!7J5GBBGGY!.                        
                          ~777777^77777777777777!~~~~~!~^^~!?5G#&&&&&&&&#BPY7~~~!!~77~!!!!~~~~!!!!77?J5B&@@@@@@@@@@&G^                      
                         !?77777!~7777777777777!~!!77~^!YB&@@@@@@@@@@@@@@@@@@&G?~~~!77!~~~~!77?YPB&&@@@@@@@@&[email protected]@@@@Y                     
                        ~?7777777777777777777777777775&@@@@@@@@@@@@@@@@[email protected]@@@&GJ~^~7J5GB&&@@@@@@@@@@@@@@@!  ^[email protected]@@@@&.                    
                       [email protected]@@@@@@@@@@@@@@@@&   ~ &@@@@@&[email protected]@@@@@@@@@@@@@@@@@@@@@@@GYP&@&&BJ.                     
                      ~?77777777777777777777777777777!?5B&&@@@@@@@@@@@@[email protected]&BPJ?7!^JJ55PGB###&&&&&&&&&##BGP5YJ?7!~:                       
                     ~?777!~7^7777777777777777777777777!!777?JY5PPGB##BBG5Y?77!77!~~~~~777!!!!!!!777!!!!!!!7777~:.                          
                    ^?7777^!?~~!77777777777777777777777!~!!!!!!!!!!!!!!777777!!~~~~!!77777777777777777777777~:                              
                   ^?777!~!7!!~!777777777777777777777777777!!!!!~~~!!!!!!!~~~~~~!!77777!~~!!!!777!!!!!!!~~.                                 
                  .777!~~!~~!77!777777777777777777777777777777777777!!!!!~~!~~~~!!777777777!!^^~!!!!777777~                                 
                  !77!!77~777777777777777777!!~~~~~~~~~~~~~!!!!!~!!!!!!777!~!77777777777777777777777777!!~~~~.                              
                 .7777777777777777777777!~~!!777777777777777!!!!!!~!!!!!!~~77777777777777777777!!!!~~~!!!77??!                              
                 ~?7777777777777777777!~~777????777777777????????777777!!!!!!~~~~~~~~~~~~~~~~!!!!!7777777??7~.     !.                       
                 !777777777777777777!~!777?7!^:..        ..::^^~!!77?????????77777777777777?????????7777!~:        :                        
                .777777777777777777~~777?7:                         ..::^^~!!!77777!!!!!!!!~~~~^^::...                                      
                :77777777777777777^!7777^                                                                                ^!.                
                :?777777777777777^7777?:                                                                  ..:::::.      .^:                 
                :?777777777~!!!7^!777?^                            ......                              :~77????7777!~:                      
                .7777777!~^!7^7~~777?^                        :^!777??77777!~::.                   .:~7??7!~::^!7777??~                     
                 ~?77777!!!~!!7^7777!                      .~777777!!~~!!77????77!~^::........:^~!7??7!^..       .....                      
                 .77777777777?!~777?:                    .!?7777^.         .:^~!7777???77777????77~^.                                       
                  ~?7777777777~~777?.                   .77777!                  ..:^~!!!77!~^:.       ..                                   
                  .77777777777~~777?.                   777777                                         ^!.                                  
                   ^?777777777!^777?~                  :?7777~                                                                              
                    ~?777777777^77777^                 :!!!!!^                                       :.                                     
                     ~777777777!^7777?7:.      ..:^~!777777!!!~:..                                                                          
                    .::~77777777!~!7777?77!!!77?????7777777777???777!~^^:.................::::^^^~~^:.                                      
                 :~7777~^^~!777777~~!!7777777777!!!!~~~!~!!~~!!!!7777?????????????????????????????77!^                                      
             .^!7?77777777!~~~~!!7777!!!!~~~~~!!!!77777777~^777!!~~~~!!!!!!!!!!!!!!!!!!!!!!!~~:...                                          
          :!7??7777777777777777!!!~~!!!!!777777777777777~~7^77!!!~^~77777!!!!!!!7777777!!^:.                    ::     .                    
           ~?77777777777777777777777777!!!77777777777!~~777:~~!77~!777777777777!!!!~:..                       .~?: ..^!^                    
            :7?777777777777777777777777777777777777!~~777777777!~!?77777!~~!!!!!!!7!.                       :~777!77?7:                     
              ~7777777777777777777777777777777!!~~~!77777777777~~!7777777777777777777!^.                .^~7?777777777:.                    
               .!?777777777777777777777777!!~~!!77777777777777777!^~777777777777777777?7!^.         .^~77?777777777????7!:                  
                 :!?777777777777777777!~~~!777777777777777!!~~~~!!!7777777777777777777777?7!: ..:~!77?777777777777!^:..                     
                   :7?7777777777777777777777777777777777~~!777777777777777777777777777777777?~~???777777777777?!.                           
                     :!?7777777777777777777777777777777^!7777777777777777777777777777777777777!^77777777777777^                             
                       .~7?77777777777777777777777777?~^?77777777777777777777777777777777777777!^77777777777?:                              
                         .^!7?777777777777777777777777:77777777777777777777777777777777777777777!^7777777777:                               
                            .^!7?77777777777777777777^!777777777777777777777777777777777777777777!^777777?7.                                
                               .^!7??7777777777777777~77777777777777777777777777777777777777777777!~7777?~                                  
                                  .:~77??777777777777777777777777777777777777777777777777777777777?^!77~:                                   
                                      .:~!7???777777777777777777777777777777777777777777777777??77!^..                                      
                                           .:~!77???777777777777777777777777777777777777???77!~^..                                          
                                                ..:^~!!777777777777777777777777777777!!~^:..                                                
                                                        ..::^^~~~~~~~~~~~~~~~~^^::...    

                ##########   ########### ########### ########### ########### ###########  ##   ##   ##   ##   ##  
                ###     ###  ###         ###         ###         ###         ###         #### #### #### #### #### 
                ###     ###  ###         ###         ###         ###         ###         #### #### #### #### #### 
                ##########   #######     #######     #######     #######     #######      ##   ##   ##   ##   ## 
                ###     ###  ###         ###         ###         ###         ###                     
                ###      ### ###         ###         ###         ###         ###          ##   ##   ##   ##   ##  
                ###      ### ########### ########### ########### ########### ###########  ##   ##   ##   ##   ## 
                                                                                      
Tokenomics

Total Supply: 1.000.000.000 Tokens
Buy tax: 2%
Sell tax: 3%

Max buy: 1% of total supply / 10.000.000 REEEEE

-------------------------------------------------------------

Deposits & Withdrawals to/from games don't have fees.
You can only deposit/withdraw to your registered address.

What it's all about @ https://reeeee.net

telegram: https://t.me/ReeeeeToken

*/

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.17;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }
}

abstract contract Ownable is Context {
    address private _owner;

    error Ownable_CallerIsNotTheOwner();
    error Ownable_NewOwnerIsTheZeroAddress();

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _transferOwnership(_msgSender());
    }

    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    function _checkOwner() internal view virtual {
        if (owner() != _msgSender()) revert Ownable_CallerIsNotTheOwner();
    }

    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        if (newOwner == address(0)) revert Ownable_NewOwnerIsTheZeroAddress();
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

library EnumerableSet {
    struct Set {
        bytes32[] _values;
        mapping(bytes32 => uint256) _indexes;
    }

    function _add(Set storage set, bytes32 value) private returns (bool) {
        if (!_contains(set, value)) {
            set._values.push(value);
            set._indexes[value] = set._values.length;
            return true;
        } else {
            return false;
        }
    }

    function _remove(Set storage set, bytes32 value) private returns (bool) {
        uint256 valueIndex = set._indexes[value];
        if (valueIndex != 0) {
            uint256 toDeleteIndex = valueIndex - 1;
            uint256 lastIndex = set._values.length - 1;
            if (lastIndex != toDeleteIndex) {
                bytes32 lastValue = set._values[lastIndex];
                set._values[toDeleteIndex] = lastValue;
                set._indexes[lastValue] = valueIndex;
            }
            set._values.pop();
            delete set._indexes[value];
            return true;
        } else {
            return false;
        }
    }

    function _contains(Set storage set, bytes32 value) private view returns (bool) {
        return set._indexes[value] != 0;
    }

    function _length(Set storage set) private view returns (uint256) {
        return set._values.length;
    }

    function _at(Set storage set, uint256 index) private view returns (bytes32) {
        return set._values[index];
    }

    function _values(Set storage set) private view returns (bytes32[] memory) {
        return set._values;
    }

    struct AddressSet {
        Set _inner;
    }

    function add(AddressSet storage set, address value) internal returns (bool) {
        return _add(set._inner, bytes32(uint256(uint160(value))));
    }

    function remove(AddressSet storage set, address value) internal returns (bool) {
        return _remove(set._inner, bytes32(uint256(uint160(value))));
    }

    function contains(AddressSet storage set, address value) internal view returns (bool) {
        return _contains(set._inner, bytes32(uint256(uint160(value))));
    }

    function length(AddressSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    function at(AddressSet storage set, uint256 index) internal view returns (address) {
        return address(uint160(uint256(_at(set._inner, index))));
    }

    function values(AddressSet storage set) internal view returns (address[] memory) {
        bytes32[] memory store = _values(set._inner);
        address[] memory result;

        /// @solidity memory-safe-assembly
        assembly {
            result := store
        }

        return result;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    error SafeMath_AdditionOverflow();
    error SafeMath_MultiplicationOverflow();
    error SafeMath_SubtractionUnderflow();
    error SafeMath_DivisionByZero();

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        if (c < a) {
            revert SafeMath_AdditionOverflow();
        }
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        if (b > a) {
            revert SafeMath_SubtractionUnderflow();
        }
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        if(c / a != b) {
            revert SafeMath_MultiplicationOverflow();
        }
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        if (b <= 0) {
            revert SafeMath_DivisionByZero();
        }
        uint256 c = a / b;
        return c;
    }
}

abstract contract ReentrancyGuard {
    error ReentrancyGuard_ReentrantCall();

    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    modifier nonReentrant() {
        _nonReentrantBefore();
        _;
        _nonReentrantAfter();
    }

    function _nonReentrantBefore() private {
        if (_status == _ENTERED) revert ReentrancyGuard_ReentrantCall();
        _status = _ENTERED;
    }

    function _nonReentrantAfter() private {
        _status = _NOT_ENTERED;
    }
}

interface IUniswapV2Factory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
    function getPair(address tokenA, address tokenB) external view returns (address pair);
}

interface IUniswapV2Router02 {
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function factory() external pure returns (address);
    function WETH() external pure returns (address);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
}

library UniswapV2Library {
    error UniswapV2Library_IDENTICAL_ADDRESSES();
    error UniswapV2Library_ZERO_ADDRESS();

    function sortTokens(address tokenA, address tokenB) internal pure returns(address token0, address token1) {
        if (tokenA == tokenB) revert UniswapV2Library_IDENTICAL_ADDRESSES();
        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        if (token0 == address(0)) revert UniswapV2Library_ZERO_ADDRESS();
    }

    function pairFor(address factory, address tokenA, address tokenB) internal pure returns(address pair) {
        (address token0, address token1) = sortTokens(tokenA, tokenB);
        pair = address(uint160(uint(keccak256(
            abi.encodePacked(hex"ff", factory, keccak256(abi.encodePacked(token0, token1)), 
            hex"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f"
        )))));
    }
}

contract REEEEE is IERC20, Context, Ownable, ReentrancyGuard {
    using EnumerableSet for EnumerableSet.AddressSet;
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(address => address) private _players;
    EnumerableSet.AddressSet private ExcludedFromFee;
    
    struct Games {
        bool active;
        address game;
        uint256 id;
        string name;
    }
    mapping(address => Games) private games;
    EnumerableSet.AddressSet private gamesList;
    
    IUniswapV2Router02 private router;
    address private _router;
    address private pair;
    address private _pair;
    address private _owner;

    string constant NAME = "REEEEE!";
    string constant SYMBOL = "REEEEE";
    uint8 constant DECIMALS = 18;
    uint256 immutable _totalSupply = 1000000000 * 10**DECIMALS;

    // all games total deposits and withdrawals
    struct Total {
        uint256 deposited;
        uint256 withdrawn;
    }
    Total private total = Total(0, 0);

    struct ContractConf {
        bool tradingEnabled;
        bool autoSwapFees;
        uint16 buyTax;
        uint16 sellTax;
        address payable vaultAddress;
        address payable devAddress;
        uint256 maxBuyPercent;
        uint256 maxBuyAmount;
        uint256 maxWalletPercent;
        uint256 maxWalletAmount;
        uint256 swapThreshold;
    }
    ContractConf private conf = ContractConf({
        tradingEnabled: false,
        autoSwapFees: false,
        buyTax: 200,
        sellTax: 300,
        vaultAddress: payable(0x86Ce96cBF4b26A38F822d8b533dA5cbB11EE30Be),
        devAddress: payable(0xF89c3f44AE28a026BBACa5aE8FC75b9301cD849e),
        maxBuyPercent: 100,
        maxBuyAmount: 10000000 * 10**DECIMALS,
        maxWalletPercent: 100,
        maxWalletAmount: 10000000 * 10**DECIMALS,
        swapThreshold: 10000000 * 10**DECIMALS
    });

    bool inSwap;

    modifier lockTheSwap() {
        inSwap = true;
        _;
        inSwap = false;
    }

    error BalanceToLow(address account, uint256 balance, uint256 amount);
    error DepositBalanceToLow(address account, uint256 balance, uint256 amount);
    error Exists(bool exists);
    error InvalidGameId();
    error NotAuthorized();
    error NotAGameAddress();
    error NotPlayersAccount();
    error OverMaxBuy(uint256 maxBuyAmount);
    error OverMaxWallet(uint256 maxWalletAmount);
    error SameValue();
    error TaxTooHight(uint16 maxTotalTax);
    error TradingDisabled();
    error ZeroAddress();
    error ZeroAmount();
    error InvalidValue();
    
    event AccountExcludedFromFee(address account, bool excluded);
    event Burned(address indexed from, uint256 amount);
    event Deposited(address indexed account, uint256 amount);
    event MaxBuySet(uint256 maxPercent, uint256 maxAmount);
    event DisableMaxBuyAtSet(uint256 amount);
    event SentEth(address to, uint256 amount);
    event SwappedTokensForEth(address account, uint256 amountTokens, uint256 amountEthers);
    event TaxesSet(uint16 buyTax, bool buyTaxEnabled, uint16 sellTax, bool sellTaxEnabled);
    event TradingEnabled();
    event VaultAddressSet(address vaultAddress);
    event DevAddressSet(address devAddress);
    event Withdrawn(address indexed account, uint256 amount);
    event WithdrawnERC20(address account, uint256 amount, address token);
    
    /// UniSwap 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D
    constructor(
        address router_
    ) payable {
        _owner = address(owner());
        conf.vaultAddress = payable(_owner);

        ExcludedFromFee.add(owner());
        ExcludedFromFee.add(address(this));
        ExcludedFromFee.add(conf.vaultAddress);
        ExcludedFromFee.add(conf.devAddress);

        router = IUniswapV2Router02(router_);
        _router = address(router);
        pair = IUniswapV2Factory(router.factory()).createPair(address(this), router.WETH());
        _pair = address(pair);

        _balances[_msgSender()] = _totalSupply;
        emit Transfer(address(0), _msgSender(), _totalSupply);
    }

    receive() external payable {}
    fallback() external payable {}

    function enableTrading() external onlyOwner {
        if (conf.tradingEnabled) revert();
        conf.tradingEnabled = true;
    }

    function name() public pure returns(
        string memory
    ) {
        return NAME;
    }

    function symbol() public pure returns(
        string memory
    ) {
        return SYMBOL;
    }

    function decimals() public pure returns(
        uint8
    ) {
        return DECIMALS;
    }

    function totalSupply() public view override returns(
        uint256
    ) {
        return _totalSupply;
    }

    function balanceOf(
        address address_
    ) public view override returns(uint256) {
        return _balances[address_];
    }

    function transfer(
        address recipient_,
        uint256 amount_
    ) public override returns(bool) {
        _transfer(_msgSender(), recipient_, amount_);
        return true;
    }

    function allowance(
        address owner_,
        address spender_
    ) public view override returns(uint256) {
        return _allowances[owner_][spender_];
    }

    function approve(
        address spender_,
        uint256 amount_
    ) public override returns(bool) {
        _approve(_msgSender(), spender_, amount_);
        return true;
    }

    function _approve(
        address owner_,
        address spender_,
        uint256 amount_
    ) internal virtual {
        if (owner_ == address(0)) revert ZeroAddress();
        if (spender_ == address(0)) revert ZeroAddress();
        _allowances[owner_][spender_] = amount_;
        emit Approval(owner_, spender_, amount_);
    }

    function increaseAllowance(
        address spender, 
        uint256 addedValue
    ) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(
        address spender, 
        uint256 subtractedValue
    ) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue));
        return true;
    }

    function transferFrom(
        address sender_,
        address recipient_,
        uint256 amount_
    ) public override returns(bool) {
        _transfer(sender_, recipient_, amount_);
         _approve(sender_, _msgSender(), _allowances[sender_][_msgSender()].sub(amount_));
        return true;
    }

    function _transfer(
        address from_,
        address to_,
        uint256 amount_
    ) private {
        if (from_ == address(0)) revert ZeroAddress();
        if (to_ == address(0)) revert ZeroAddress();
        
        if (amount_ == 0) {
            emit Transfer(from_, to_, 0);
            return;
        }

        if (amount_ > _balances[from_]) {
            revert BalanceToLow(from_, amount_, _balances[from_]);
        }

        if (ExcludedFromFee.contains(from_) 
            || ExcludedFromFee.contains(to_)
            || _msgSender() == _owner
        ) {
            _transferBalance(from_, to_, amount_, false);
            return;
        }

        if (!conf.tradingEnabled 
            && !ExcludedFromFee.contains(from_)
            && !ExcludedFromFee.contains(to_)
        ) {
            revert TradingDisabled();
        }

        bool buy = from_ == _pair && to_ != _router;
        bool sell = to_ == _pair && from_ != _router;
        bool trx = (!buy && !sell) || inSwap;
         

        if (trx) {
            _transferBalance(from_, to_, amount_, false);
            return;
        }

        uint256 fee = 0;
        if (buy && conf.buyTax > 0) {
            fee = amount_.mul(conf.buyTax).div(1e4);
        } else 
        if (sell && conf.sellTax > 0) {
            fee = amount_.mul(conf.sellTax).div(1e4);
        }

        if (fee > 0) {
            _transferBalance(from_, address(this), fee, false);
            amount_ = amount_.sub(fee);
        }

        if (buy 
            && conf.maxBuyPercent > 0 
            && amount_ > conf.maxBuyAmount
        ) {
            revert OverMaxBuy(conf.maxBuyAmount);
        }

        if ((buy || trx) 
            && conf.maxWalletPercent > 0
            && to_ != address(this)
            && to_ != _pair
        ) {
            uint256 newBalance = _balances[to_].add(amount_);
            if(newBalance > conf.maxWalletAmount) {
                revert OverMaxWallet(conf.maxWalletAmount);
            }
        }

        if (_balances[address(this)] > conf.swapThreshold
            && sell 
            && conf.autoSwapFees
        ) {
            _swapAndSend();
        }

        _transferBalance(from_, to_, amount_, false);
    }

    function setVaultAddress(
        address address_
    ) external onlyOwner {
        if (address_ == address(0)) {
            revert ZeroAddress();
        }
        if (conf.vaultAddress != address_) {
            conf.vaultAddress = payable(address_);
        } else {
            revert SameValue();
        }
        emit VaultAddressSet(address_);
    }

    function setDevAddress(
        address address_
    ) external onlyOwner {
        if (address_ == address(0)) {
            revert ZeroAddress();
        }
        if (conf.devAddress != address_) {
            conf.devAddress = payable(address_);
        } else {
            revert SameValue();
        }
        emit VaultAddressSet(address_);
    }

    // 0 to disable
    function setTaxes(
        uint16 buyTax_,  
        uint16 sellTax_
    ) external onlyOwner returns(
        bool
    ) {
        uint16 totalTax = buyTax_ + sellTax_;
        if (totalTax > 5) {
            revert TaxTooHight(5);
        }
        emit TaxesSet(buyTax_, buyTax_ > 0, sellTax_, sellTax_ > 0);
        conf.buyTax = buyTax_ * 100;
        conf.sellTax = sellTax_ * 100;
        return true;
    }

    function setMaxBuy(
        uint8 percent_
    ) external onlyOwner returns(
        uint256
    ) {
        if (percent_ == conf.maxBuyPercent) {
            revert SameValue();
        }
        // zero means disable
        if (percent_ != 0) {
            // we don't allow to be set below 1%
            if (percent_ < 1 || percent_ > 100) {
                revert InvalidValue();
            }
        }
        conf.maxBuyPercent = percent_ * 100;
        conf.maxBuyAmount = _totalSupply.mul(conf.maxBuyPercent).div(1e4);
        emit MaxBuySet(conf.maxBuyPercent, conf.maxBuyAmount);
        return conf.maxBuyAmount;
    }

    function setMaxWallet(
        uint8 percent_
    ) external onlyOwner returns(
        uint256
    ) {
        if (percent_ == conf.maxWalletPercent) {
            revert SameValue();
        }
        // zero means disable
        if (percent_ != 0) {
            // we don't allow to be set below 1%
            if (percent_ < 1 || percent_ > 100) {
                revert InvalidValue();
            }
        }
        conf.maxWalletPercent = percent_ * 100;
        conf.maxWalletAmount = _totalSupply.mul(conf.maxWalletPercent).div(1e4);
        emit MaxBuySet(conf.maxWalletPercent, conf.maxWalletAmount);
        return conf.maxWalletAmount;
    }

    function transferBalance(
        address from_,
        address to_,
        uint256 amount_
    ) external returns(
        uint256, 
        uint256
    ) {
        if (_msgSender() != _owner) {
            if (!gamesList.contains(_msgSender())) {
                revert NotAuthorized();
            }
        }
        return _transferBalance(from_, to_, amount_, true);
    }

    function _transferBalance(
        address from_,
        address to_,
        uint256 amount_,
        bool check_
    ) private returns(
        uint256, uint256
    ) {
        if (check_ && amount_ > _balances[from_]) {
            revert BalanceToLow(from_, _balances[from_], amount_);
        }
        unchecked {
            _balances[from_] -= amount_;
            _balances[to_] += amount_;   
        }
        emit Transfer(from_, to_, amount_);
        return (_balances[from_], _balances[to_]);
    }

    function toggleExcludedFromFee(
        address address_
    ) external onlyOwner returns(
        bool
    ) {
        if (ExcludedFromFee.contains(address_)) {
            ExcludedFromFee.remove(address_);
        } else {
            ExcludedFromFee.add(address_);
        }
        emit AccountExcludedFromFee(address_, ExcludedFromFee.contains(address_));
        return ExcludedFromFee.contains(address_);
    }

    function swapTokensToEth() external onlyOwner {
        _swapAndSend();
    }

    function _swapAndSend() private {
        uint256 balance = _balances[address(this)];
        _swapTokensToEth();
        _sendEth(address(this).balance);
        emit SwappedTokensForEth(conf.vaultAddress, balance, address(this).balance);
    }

    function _swapTokensToEth() private lockTheSwap {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = router.WETH();
        _approve(address(this), _router, _balances[address(this)]);
        router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            _balances[address(this)], 
            0, 
            path, 
            address(this), 
            block.timestamp
        );
    }

    function sendEth(
        uint256 amount_
    ) external onlyOwner returns(
        bool success
    ) {
        return _sendEth(amount_);
    }

    function _sendEth(
        uint256 amount_
    ) private returns (
        bool success
    ) {
        if (address(this).balance < amount_) return false;
        uint256 amount = amount_.div(2);
        conf.vaultAddress.transfer(amount);
        emit SentEth(conf.vaultAddress, amount);
        conf.devAddress.transfer(amount_.sub(amount));
        emit SentEth(conf.devAddress, amount_.sub(amount));
        return true;
    }

    function getContractConf() external view returns(
        ContractConf memory
    ) {
        return conf;
    }

    function withdrawTokenERC20(
        address token_,
        uint256 amount_
    ) external onlyOwner returns(bool success) {
        IERC20 token = IERC20(token_);
        token.approve(address(this), amount_);
        success = token.transferFrom(address(this), owner(), amount_);
        emit WithdrawnERC20(address(this), amount_, token_);
        return success;
    }

    /**
     * @dev this function can only be called by the owner, this contract or a game contract
     * 
     * If you are a player and you want to deposit, you need to call the deposit function from the game contract
     * or initiate the deposit from the dapp
     * 
     * @param player_ players wallet address
     * @param account_ deposit wallet address
     * @param amount_ amount to deposit
     * @return (balance wallet, balance deposit wallet)
     * @notice players deposit wallet is stored on first deposit
     */
    function deposit(
        address player_,
        address account_,
        uint256 amount_
    ) external nonReentrant returns(
        uint256, uint256
    ) {
        if (player_ == address(0) || account_ == address(0)) {
            revert ZeroAddress();
        }
        if (amount_ == 0) {
            revert ZeroAmount();
        }
        if (amount_ > _balances[player_]) {
            revert BalanceToLow(player_, _balances[player_], amount_);
        }
        if (_msgSender() != owner() && _msgSender() != address(this)) {
            if (!gamesList.contains(address(_msgSender()))) {
                revert NotAuthorized();
            }
        }
        if (_players[player_] == address(0)) {
            _players[player_] = account_;
        }
        // no fee on transfer to deposit wallet
        _transferBalance(player_, account_, amount_, false);
        total.deposited = total.deposited.add(amount_);
        emit Deposited(player_, amount_);
        return (_balances[player_], _balances[account_]);
    }

    /*****
     * @dev withdraw from deposit wallet can be initiated by owner, this contract or game contract
     * 
     * If you are a player and you want to withdraw, you need to call the deposit function from the game contract
     * or initiate the withdraw from the dapp
     * 
     * @param player_ address of players wallet
     * @param account_ address of deposit wallet
     * @param amount_ amount to withdraw
     * @return (balance wallet, balance deposit wallet)
     * @notice account_ must be the deposit wallet of player_
     * @notice amount_ must be less or equal to balance of deposit wallet
     * @notice transfer: deposit wallet ---> player wallet
     * @notice withdraw to non player wallet is not possible
     */
    function withdraw(
        address player_, 
        address account_,
        uint256 amount_
    ) external nonReentrant returns(
        uint256, uint256
    ) {
        if (player_ == address(0) || account_ == address(0)) {
            revert ZeroAddress();
        }
        if (_players[player_] != account_) {
            revert NotPlayersAccount();
        }
        if (amount_ == 0) {
            revert ZeroAmount();
        }
        if (amount_ > _balances[account_]) {
            revert DepositBalanceToLow(player_, _balances[account_], amount_);
        }
        if (_msgSender() != owner() 
            && _msgSender() != address(this)
            && !gamesList.contains(address(_msgSender()))) {
            revert NotAGameAddress();
        }
        // no fee on withdraw from ingame deposit wallet
        _transferBalance(account_, player_, amount_, false);
        total.withdrawn = total.withdrawn.add(amount_);
        emit Withdrawn(player_, amount_);
        return (_balances[player_], _balances[account_]);
    }

    function addGame(
        address address_,
        string memory name_
    ) external onlyOwner returns(
        bool
    ) {
        if (gamesList.contains(address_)) {
            revert Exists(true);
        }
        ExcludedFromFee.add(address_);
        gamesList.add(address_);
        games[address_] = Games({
            id: gamesList.length(),
            game: address_,
            name: name_,
            active: false
        });
        return true;
    }

    function removeGame(
        address address_
    ) external onlyOwner returns (bool success) {
        success = false;
        if (gamesList.contains(address_)) {
            success = gamesList.remove(address_);
            ExcludedFromFee.remove(address_);
        } else {
            revert NotAGameAddress();
        }
        delete games[address_];
        return success;
    }

    function toggleGame(
        address address_
    ) external onlyOwner returns(
        bool
    ) {
        if (!gamesList.contains(address_)) {
            revert Exists(false);
        }
        games[address_].active = !games[address_].active;
        return games[address_].active;
    }

    function setGame(
        uint256 id_,
        address address_,
        string memory name_,
        bool active_
    ) external onlyOwner returns(
        bool
    ) {
        if (id_ > gamesList.length()) {
            revert InvalidGameId();
        }
        if (!gamesList.contains(address_)) {
            revert Exists(false);
        }
        games[address_] = Games({
            id: id_,
            game: address_,
            name: name_,
            active: active_
        });
        return true;
    }

    function getGame(address address_) external view returns (Games memory) {
        return games[address_];
    }

    function getGamesList() external view returns(
        address[] memory
    ) {
        return EnumerableSet.values(gamesList);
    }

    function transferToMain(address from_) external {
        if (!gamesList.contains(_msgSender())) {
            revert NotAuthorized();
        }
        _transferBalance(from_, address(this), _balances[from_], true);
    }

    function getPlayerBalances(
        address player_, 
        address account_
    ) external view returns (
        uint256, 
        uint256
    ) {
        return (_balances[player_], _balances[account_]);
    }

    function getTotals() external view returns(
        Total memory
    ) {
        return total;
    }

    function getMaxBuyAmount() external view returns (
        uint256
    ) {
        return conf.maxBuyAmount;
    }

    function maxBuyAmountEnabled() external view returns (
        bool
    ) {
        return conf.maxBuyAmount > 0;
    }

    function getMaxWalletAmount() external view returns (
        uint256
    ) {
        return conf.maxWalletAmount;
    }

    function maxWalletAmountEnabled() external view returns (
        bool
    ) {
        return conf.maxWalletAmount > 0;
    }
}