{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/MaxApyVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.19;\\n\\nimport {BaseVault, StrategyData, IERC20, Math, SafeTransferLib, IStrategy} from \\\"./base/BaseVault.sol\\\";\\n\\n/*KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK\\nKKKKK0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO0KKKKKKK\\nKK0dcclllllllllllllllllllllllllllllccccccccccccccccccclx0KKK\\nKOc,dKNWWWWWWWWWWWWWWWWWWWWWWWWWWWWNNNNNNNNNNNNNNNNNXOl';xKK\\nKd'oWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMX; ,kK\\nKo'xMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNc .dK\\nKo'dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNc .oK\\nKd'oWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNc .oK\\nKO:,xXWWWWWWWWWWWWWWWWWWWWMMMMMMMMMMMMMMMMMMMMMMMMMMMMNc .oK\\nKKOl,',;;,,,,,,;;,,,,,,,;;cxXMMMMMMMMMMMMMMMMMMMMMMMMMNc .oK\\nKKKKOoc;;;;;;;;;;;;;;;;;;;,.cXMMMMMMMMMMMMMMMMMMMMMMMMNc .oK\\nKKKKKKKKKKKKKKKKKKKK00O00K0:,0MMMMMMMMMMMMMMMMMMMMMMMMNc .oK\\nKKKKKKKKKKKKKKKKKKklcccccld;,0MMMMMMMMMMMMMMMMMMMMMMMMNc .oK\\nKKKKKKKKKKKKKKKKkl;ckXNXOc. '0MMMMMMMMMMMMMMMMMMMMMMMMNc .oK\\nKKKKKKKKKKKKKKkc;l0WMMMMMX; .oKNMMMMMMMMMMMMMMMMMMMMMMNc .oK\\nKKKKKKKKKKKKkc;l0WMMMMMMMWd.  .,lddddddxONMMMMMMMMMMMMNc .oK\\nKKKKKKKKKKkc;l0WMMMMMMMMMMWOl::;'.  .....:0WMMMMMMMMMMNc .oK\\nKKKKKKK0xc;o0WMMMMMMMMMMMMMMMMMWNk'.;xkko'lNMMMMMMMMMMNc .oK\\nKKKKK0x:;oKWMMMMMMMMMMMMMMMMMMMMMWd..lKKk,lNMMMMMMMMMMNc .oK\\nKKK0x:;oKWMMMMMMMMMMMMMMMMMMMMMMWO,  c0Kk,lNMMMMMMMMMMNc .oK\\nKKx:;dKWMMMMMMMMMMMMMMMMMMMMMWN0c.  ;kKKk,lNMMMMMMMMMMNc .oK\\nKx,:KWMMMMMMMMMMMMMMMMMMMMMW0c,.  'oOKKKk,lNMMMMMMMMMMNc .oK\\nKo'xMMMMMMMMMMMMMMMMMMMMMW0c.   'oOKKKKKk,lNMMMMMMMMMMNc .oK\\nKo'xMMMMMMMMMMMMMMMMMMMW0c.  ':oOKKKKKKKk,lNMMMMMMMMMMNc .oK\\nKo'xMMMMMMMMMMMMMMMMMW0l.  'oOKKKKKKKKKKk,cNMMMMMMMMMMNc .oK\\nKo'xMMMMMMMMMMMMMMMW0l.  'oOKKKKKKKKKKKKk,lNMMMMMMMMMMNc .oK\\nKo'dWMMMMMMMMMMMMW0l.  'oOKKKKKKKKKKKKKKk,cNMMMMMMMMMMX: .oK\\nKO:,xXNWWWWWWWWNOl.  'oOKKKKKKKKKKKKKKKK0c,xNMMMMMMMMNd. .dK\\nKKOl''',,,,,,,,..  'oOKKKKKKKKKKKKKKKKKKKOl,,ccccccc:'  .c0K\\nKKKKOoc:;;;;;;;;:ldOKKKKKKKKKKKKKKKKKKKKKKKkl;'......',cx0KK\\nKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK0OOOOOOO0KKK*/\\n\\n/// @title MaxApy Vault Contract\\n/// @notice A vault contract deploying `underlyingAsset` to strategies that earn yield and report gains/losses to the vault\\n/// @author Forked and adapted from YVaults (https://github.com/yearn/yearn-vaults/blob/efb47d8a84fcb13ceebd3ceb11b126b323bcc05d/contracts/Vault.vy)\\ncontract MaxApyVault is BaseVault {\\n    using SafeTransferLib for address;\\n\\n    ////////////////////////////////////////////////////////////////\\n    ///                     CONSTRUCTOR                          ///\\n    ////////////////////////////////////////////////////////////////\\n    /// @dev Create the Vault\\n    /// @param _underlyingAsset The vault's underlying asset that will be deposited by users\\n    /// @param _name The ERC20 token name for the vault's shares token\\n    /// @param _symbol The ERC20 token symbol for the vault's shares token\\n    constructor(IERC20 _underlyingAsset, string memory _name, string memory _symbol, address _treasury)\\n        BaseVault(_underlyingAsset, _name, _symbol)\\n    {\\n        performanceFee = 1000; // 10% of reported yield (per Strategy)\\n        managementFee = 200; // 2% of reported yield (per Strategy)\\n        depositLimit = type(uint256).max;\\n        lastReport = block.timestamp;\\n        lockedProfitDegradation = (DEGRADATION_COEFFICIENT * 46) / 10 ** 6; // 6 hours in blocks\\n        treasury = _treasury;\\n    }\\n\\n    ////////////////////////////////////////////////////////////////\\n    ///                 DEPOSIT/WITHDRAWAL LOGIC                 ///\\n    ////////////////////////////////////////////////////////////////\\n\\n    /// @notice Deposits `amount` of `underlyingAsset`, issuing shares to `recipient`. If the Vault is in Emergency Shutdown,\\n    /// deposits will not be accepted and this call will fail.\\n    /// @dev Measuring quantity of shares to issue is based on the total outstanding debt that this contract\\n    /// has (\\\"expected value\\\") instead of the total balance sheet it has (\\\"estimated value\\\"). This has important\\n    /// security considerations, and is done intentionally. If this value were measured against external systems, it\\n    /// could be purposely manipulated by an attacker to withdraw more assets than they otherwise should be able\\n    /// to claim by redeeming their shares.\\n    /// @param amount The quantity of tokens to deposit\\n    /// @param recipient The address to issue the shares in this Vault to\\n    function deposit(uint256 amount, address recipient) external noEmergencyShutdown nonReentrant returns (uint256) {\\n        uint256 totalIdle_;\\n        assembly (\\\"memory-safe\\\") {\\n            // if recipient == address(0)\\n            if iszero(shl(96, recipient)) {\\n                // throw the `InvalidZeroAddress` error\\n                mstore(0x00, 0xf6b2911f)\\n                revert(0x1c, 0x04)\\n            }\\n            // if amount == 0\\n            if iszero(amount) {\\n                // throw the `InvalidZeroAmount` error\\n                mstore(0x00, 0xdd484e70)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Get totalAssets, same as calling _totalAssets() but caching totalIdle\\n            totalIdle_ := sload(totalIdle.slot)\\n            let totalAssets_ := add(totalIdle_, sload(totalDebt.slot))\\n            if lt(totalAssets_, totalIdle_) { revert(0, 0) }\\n\\n            // check if totalAssets + amount overflows\\n            let total := add(totalAssets_, amount)\\n            if lt(total, totalAssets_) { revert(0, 0) }\\n            // if totalAssets + amount > depositLimit\\n            if gt(total, sload(depositLimit.slot)) {\\n                // throw the `VaultDepositLimitExceeded` error\\n                mstore(0x00, 0x0c11966b)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n\\n        /// Issue new shares (needs to be done before taking deposit to be accurate and not modify `_totalAssets()`)\\n        // Inline _issueSharesForAmount(recipient, amount) saves 50 gas\\n        uint256 vaultTotalSupply = totalSupply();\\n        uint256 shares = amount;\\n        /// By default minting 1:1 shares\\n\\n        if (vaultTotalSupply != 0) {\\n            /// Mint amount of tokens based on what the Vault is managing overall\\n            shares = (amount * vaultTotalSupply) / _freeFunds();\\n        }\\n\\n        assembly (\\\"memory-safe\\\") {\\n            // if shares == 0\\n            if iszero(shares) {\\n                // Throw the `InvalidZeroShares` error\\n                mstore(0x00, 0x5a870a25)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n\\n        _mint(recipient, shares);\\n\\n        address(underlyingAsset).safeTransferFrom(msg.sender, address(this), amount);\\n\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(totalIdle.slot, add(totalIdle_, amount))\\n            // Emit the `Deposit` event\\n            mstore(0x00, shares)\\n            mstore(0x20, amount)\\n            log2(0x00, 0x40, _DEPOSIT_EVENT_SIGNATURE, recipient)\\n        }\\n\\n        return shares;\\n    }\\n\\n    /// @notice Withdraws the calling account's tokens from this Vault, redeeming\\n    /// amount `shares` for the corresponding amount of tokens\\n    /// @dev Measuring quantity of shares to issue is based on the total outstanding debt that this contract\\n    /// has (\\\"expected value\\\") instead of the total balance sheet it has (\\\"estimated value\\\"). This has important\\n    /// security considerations, and is done intentionally. If this value were measured against external systems, it\\n    /// could be purposely manipulated by an attacker to withdraw more assets than they otherwise should be able\\n    /// to claim by redeeming their shares\\n    /// @param shares How many shares to try and redeem for tokens\\n    /// @param recipient The address to issue the shares in this Vault to\\n    /// @param maxLoss The maximum acceptable loss to sustain on withdrawal. Up to loss specified amount of shares may be\\n    /// burnt to cover losses on withdrawal\\n    function withdraw(uint256 shares, address recipient, uint256 maxLoss) external nonReentrant returns (uint256) {\\n        assembly (\\\"memory-safe\\\") {\\n            // if maxLoss > MAX_BPS\\n            if gt(maxLoss, MAX_BPS) {\\n                // throw the `InvalidMaxLoss` error\\n                mstore(0x00, 0xef374dc7)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // if shares == 0\\n            if iszero(shares) {\\n                // throw the `InvalidZeroShares` error\\n                mstore(0x00, 0x5a870a25)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // if (shares == type(uint256).max) shares = balanceOf(msg.sender);\\n            if eq(shares, not(0)) {\\n                // compute `balanceOf(msg.sender)` and store it in `shares`\\n                mstore(0x0c, 0x87a211a2) // `_BALANCE_SLOT_SEED`\\n                mstore(0x00, caller())\\n                shares := sload(keccak256(0x0c, 0x20))\\n            }\\n        }\\n\\n        // Cache underlying asset\\n        IERC20 underlying = underlyingAsset;\\n\\n        uint256 valueToWithdraw = _shareValue(shares);\\n        uint256 vaultBalance = totalIdle;\\n\\n        // Check if value to withdraw exceeds vault balance\\n        if (valueToWithdraw > vaultBalance) {\\n            // Vault balance is not enough to cover withdrawal. We need to perform forced withdrawals\\n            // from strategies until requested value amount is covered.\\n            // During forced withdrawal, a Strategy may realize a loss, which is reported back to the\\n            // Vault. This will affect the withdrawer, affecting the amount of tokens they will\\n            // receive in exchange for their shares.\\n\\n            uint256 totalLoss;\\n\\n            // Iterate over strategies\\n            for (uint256 i; i < MAXIMUM_STRATEGIES;) {\\n                address strategy = withdrawalQueue[i];\\n\\n                // Check if we have exhausted the queue\\n                if (strategy == address(0)) break;\\n\\n                // Check if the vault balance is finally enough to cover the requested withdrawal\\n                if (vaultBalance >= valueToWithdraw) break;\\n\\n                uint256 slotStrategies2;\\n                // Compute remaining amount to withdraw considering the current balance of the vault\\n                uint256 amountNeeded;\\n                assembly (\\\"memory-safe\\\") {\\n                    // amountNeeded = valueToWithdraw - vaultBalance;\\n                    amountNeeded := sub(valueToWithdraw, vaultBalance)\\n\\n                    // cache slot strategies[strategy].strategyTotalDebt\\n                    mstore(0x00, strategy)\\n                    mstore(0x20, strategies.slot)\\n                    slotStrategies2 := add(keccak256(0x00, 0x40), 2)\\n\\n                    // compute strategies[strategy].strategyTotalDebt\\n                    let strategyTotalDebt := shr(128, shl(128, sload(slotStrategies2)))\\n\\n                    // Don't withdraw more than the debt loaned to the strategy so that the strategy can still continue\\n                    // to work based on the profits it has.\\n\\n                    // amountNeeded = Math.min(amountNeeded, strategyTotalDebt)\\n                    amountNeeded :=\\n                        xor(amountNeeded, mul(xor(amountNeeded, strategyTotalDebt), lt(strategyTotalDebt, amountNeeded)))\\n                }\\n\\n                // Try the next strategy if the current strategy has no debt to be withdrawn\\n                if (amountNeeded == 0) {\\n                    unchecked {\\n                        ++i;\\n                    }\\n                    continue;\\n                }\\n\\n                // Withdraw from strategy. Compute amount withdrawn\\n                // considering the difference between balances pre/post withdrawal\\n                uint256 preBalance = underlying.balanceOf(address(this));\\n                uint256 loss = IStrategy(strategy).withdraw(amountNeeded);\\n\\n                uint256 withdrawn = underlying.balanceOf(address(this)) - preBalance;\\n\\n                // Increase cached vault balance to track the newly withdrawn amount\\n                vaultBalance += withdrawn;\\n\\n                // If loss has been realised, withdrawer will incur it, affecting to the amount\\n                // of value they will receive in exchange for their shares\\n                if (loss != 0) {\\n                    valueToWithdraw -= loss;\\n                    totalLoss += loss;\\n                    _reportLoss(strategy, loss);\\n                }\\n\\n                assembly (\\\"memory-safe\\\") {\\n                    // Reduce debts by the amount withdrawn\\n                    //totalDebt -= withdrawn;\\n                    let totalDebt_ := sload(totalDebt.slot)\\n                    if gt(withdrawn, totalDebt_) { revert(0, 0) }\\n                    sstore(totalDebt.slot, sub(totalDebt_, withdrawn))\\n\\n                    // compute strategies[strategy].strategyTotalDebt\\n                    let slotContent := sload(slotStrategies2)\\n                    let strategyTotalDebt := sub(shr(128, shl(128, slotContent)), withdrawn)\\n                    // strategies[strategy].strategyTotalDebt -= uint128(withdrawn);\\n                    sstore(slotStrategies2, or(shl(128, shr(128, slotContent)), strategyTotalDebt))\\n                    // Emit the `WithdrawFromStrategy` event\\n                    mstore(0x00, strategyTotalDebt)\\n                    mstore(0x20, loss)\\n                    log2(0x00, 0x40, _WITHDRAW_FROM_STRATEGY_EVENT_SIGNATURE, strategy)\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n\\n            // Update total idle with the actual vault balance that considers the total withdrawn amount\\n            totalIdle = vaultBalance;\\n\\n            // We have withdrawn everything possible out of the withdrawal queue but we still don't\\n            // have enough to fully pay the user back. Adjust the total amount we've freed up through\\n            // forced withdrawals\\n            if (valueToWithdraw > vaultBalance) {\\n                valueToWithdraw = vaultBalance;\\n                // Burn number of shares that corresponds to what Vault has on-hand,\\n                // including the losses incurred during withdrawals\\n                shares = _sharesForAmount(valueToWithdraw + totalLoss);\\n            }\\n\\n            assembly (\\\"memory-safe\\\") {\\n                let sum := add(valueToWithdraw, totalLoss)\\n                if lt(sum, valueToWithdraw) {\\n                    // throw the `Overflow` error\\n                    revert(0, 0)\\n                }\\n                // Ensure max loss allowed has not been reached\\n                // if (totalLoss > (maxLoss * (valueToWithdraw + totalLoss)) / MAX_BPS)\\n                if gt(totalLoss, div(mul(maxLoss, sum), MAX_BPS)) {\\n                    // no need to check overflow here maxLoss is capped at MAX_BPS\\n                    // throw the `MaxLossReached` error\\n                    mstore(0x00, 0x9ec5941d)\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n\\n        // Burn shares\\n        _burn(msg.sender, shares);\\n\\n        // Reduce value withdrawn from vault total idle\\n        totalIdle -= valueToWithdraw;\\n\\n        // Transfer underlying to `recipient`\\n        address(underlying).safeTransfer(recipient, valueToWithdraw);\\n\\n        assembly (\\\"memory-safe\\\") {\\n            // Emit the `Withdraw` event\\n            mstore(0x00, shares)\\n            mstore(0x20, valueToWithdraw)\\n            log2(0x00, 0x40, _WITHDRAW_EVENT_SIGNATURE, recipient)\\n        }\\n\\n        return valueToWithdraw;\\n    }\\n\\n    ////////////////////////////////////////////////////////////////\\n    ///                      REPORT LOGIC                        ///\\n    ////////////////////////////////////////////////////////////////\\n\\n    /// @notice  Reports the amount of assets the calling Strategy has free (usually in terms of ROI).\\n    /// The performance fee is determined here, off of the strategy's profits (if any), and sent to governance.\\n    /// The strategist's fee is also determined here (off of profits), to be handled according to the strategist on the next harvest.\\n    /// @dev For approved strategies, this is the most efficient behavior. The Strategy reports back what it has free, then\\n    /// Vault \\\"decides\\\" whether to take some back or give it more.\\n    /// Note that the most it can take is `gain + debtPayment`, and the most it can give is all of the\\n    /// remaining reserves. Anything outside of those bounds is abnormal behavior\\n    /// @param gain Amount Strategy has realized as a gain on its investment since its last report, and is free\\n    /// to be given back to Vault as earnings\\n    /// @param loss Amount Strategy has realized as a loss on its investment since its last report, and should be\\n    /// accounted for on the Vault's balance sheet. The loss will reduce the debtRatio for the strategy and vault.\\n    /// The next time the strategy will harvest, it will pay back the debt in an attempt to adjust to the new debt limit.\\n    /// @param debtPayment Amount Strategy has made available to cover outstanding debt\\n    /// @return debt Amount of debt outstanding (if totalDebt > debtLimit or emergency shutdown).\\n    function report(uint128 gain, uint128 loss, uint128 debtPayment)\\n        external\\n        checkRoles(STRATEGY_ROLE)\\n        returns (uint256)\\n    {\\n        // Cache underlying asset\\n        IERC20 underlying = underlyingAsset;\\n        // Cache strategy balance\\n        uint256 senderBalance = underlying.balanceOf(msg.sender);\\n\\n        assembly (\\\"memory-safe\\\") {\\n            // Ensure strategy reporting actually has enough funds to cover `gain` and `debtPayment`\\n            let sum := add(gain, debtPayment)\\n            if lt(sum, gain) {\\n                // throw the `Overflow` error\\n                revert(0, 0)\\n            }\\n            // if (underlying.balanceOf(msg.sender) < gain + debtPayment)\\n            if lt(senderBalance, sum) {\\n                // throw the `InvalidReportedGainAndDebtPayment` error\\n                mstore(0x00, 0x746feeec)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n\\n        // If strategy suffered a loss, report it\\n        if (loss > 0) {\\n            _reportLoss(msg.sender, loss);\\n        }\\n\\n        // Assess both management fee and performance fee, and issue both as shares of the vault\\n        uint256 totalFees = _assessFees(msg.sender, gain);\\n\\n        // Set gain returns as realized gains for the vault\\n        strategies[msg.sender].strategyTotalGain += gain;\\n\\n        // Compute the line of credit the Vault is able to offer the Strategy (if any)\\n        uint256 credit = _creditAvailable(msg.sender);\\n\\n        // Compute excess of debt the Strategy wants to transfer back to the Vault (if any)\\n        uint256 debt = _debtOutstanding(msg.sender);\\n\\n        // Adjust excess of reported debt payment by the debt outstanding computed\\n        debtPayment = uint128(Math.min(uint256(debtPayment), debt));\\n\\n        if (debtPayment != 0) {\\n            strategies[msg.sender].strategyTotalDebt -= debtPayment;\\n            totalDebt -= debtPayment;\\n            debt -= debtPayment;\\n        }\\n\\n        // Update the actual debt based on the full credit we are extending to the Strategy\\n        if (credit != 0) {\\n            strategies[msg.sender].strategyTotalDebt += uint128(credit);\\n            totalDebt += credit;\\n        }\\n\\n        // Give/take corresponding amount to/from Strategy, based on the difference between the reported gains\\n        // and the debt needed to be paid off (if any)\\n        uint256 totalReportedAmount = gain + debtPayment;\\n\\n        unchecked {\\n            if (credit > totalReportedAmount) {\\n                // Credit is greater than the amount reported by the strategy, send funds **to** strategy\\n                totalIdle -= (credit - totalReportedAmount);\\n                address(underlying).safeTransfer(msg.sender, credit - totalReportedAmount);\\n            } else if (totalReportedAmount > credit) {\\n                // Amount reported by the strategy is greater than the credit, take funds **from** strategy\\n                totalIdle += (totalReportedAmount - credit);\\n                address(underlying).safeTransferFrom(msg.sender, address(this), totalReportedAmount - credit);\\n            }\\n\\n            // else don't do anything (credit and reported amounts are balanced, hence no transfers need to be executed)\\n        }\\n\\n        // Profit is locked and gradually released per block\\n        uint256 lockedProfitBeforeLoss = _calculateLockedProfit() + gain - totalFees;\\n\\n        if (lockedProfitBeforeLoss > 0) {\\n            lockedProfit = lockedProfitBeforeLoss - loss;\\n        } else {\\n            lockedProfit = 0;\\n        }\\n\\n        // Update reporting time\\n        strategies[msg.sender].strategyLastReport = uint48(block.timestamp);\\n        lastReport = block.timestamp;\\n\\n        emit StrategyReported(\\n            msg.sender,\\n            gain,\\n            loss,\\n            debtPayment,\\n            strategies[msg.sender].strategyTotalGain,\\n            strategies[msg.sender].strategyTotalLoss,\\n            strategies[msg.sender].strategyTotalDebt,\\n            credit,\\n            strategies[msg.sender].strategyDebtRatio\\n        );\\n\\n        if (strategies[msg.sender].strategyDebtRatio == 0 || emergencyShutdown) {\\n            // Take every last penny the Strategy has (Emergency Exit/revokeStrategy)\\n            return IStrategy(msg.sender).estimatedTotalAssets();\\n        }\\n\\n        // Otherwise, just return what we have as debt outstanding\\n        return debt;\\n    }\\n\\n    ////////////////////////////////////////////////////////////////\\n    ///                STRATEGIES CONFIGURATION                  ///\\n    ////////////////////////////////////////////////////////////////\\n\\n    /// @notice Adds a new strategy\\n    /// @dev The Strategy will be appended to `withdrawalQueue`, and `_organizeWithdrawalQueue` will reorganize the queue order\\n    /// @param newStrategy The new strategy to add\\n    /// @param strategyDebtRatio The percentage of the total assets in the vault that the `newStrategy` has access to\\n    /// @param strategyMaxDebtPerHarvest Lower limit on the increase of debt since last harvest\\n    /// @param strategyMinDebtPerHarvest Upper limit on the increase of debt since last harvest\\n    /// @param strategyPerformanceFee The fee the strategist will receive based on this Vault's performance\\n    function addStrategy(\\n        address newStrategy,\\n        uint256 strategyDebtRatio,\\n        uint256 strategyMaxDebtPerHarvest,\\n        uint256 strategyMinDebtPerHarvest,\\n        uint256 strategyPerformanceFee\\n    ) external checkRoles(ADMIN_ROLE) noEmergencyShutdown {\\n        uint256 slot; // Slot where strategies[newStrategy] slot will be stored\\n\\n        assembly (\\\"memory-safe\\\") {\\n            // General checks\\n\\n            // if (withdrawalQueue[MAXIMUM_STRATEGIES - 1] != address(0))\\n            if sload(add(withdrawalQueue.slot, sub(MAXIMUM_STRATEGIES, 1))) {\\n                // throw `QueueIsFull()` error\\n                mstore(0x00, 0xa3d0cff3)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Strategy checks\\n            // if (newStrategy == address(0))\\n            if iszero(newStrategy) {\\n                // throw `InvalidZeroAddress()` error\\n                mstore(0x00, 0xf6b2911f)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Compute strategies[newStrategy] slot\\n            mstore(0x00, newStrategy)\\n            mstore(0x20, strategies.slot)\\n            slot := keccak256(0x00, 0x40)\\n\\n            // if (strategies[newStrategy].strategyActivation != 0)\\n            if shr(208, shl(176, sload(slot))) {\\n                // throw `StrategyAlreadyActive()` error\\n                mstore(0x00, 0xc976754d)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        if (IStrategy(newStrategy).vault() != address(this)) {\\n            assembly (\\\"memory-safe\\\") {\\n                // throw `InvalidStrategyVault()` error\\n                mstore(0x00, 0xac4e0773)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        if (IStrategy(newStrategy).underlyingAsset() != address(underlyingAsset)) {\\n            assembly (\\\"memory-safe\\\") {\\n                // throw `InvalidStrategyUnderlying()` error\\n                mstore(0x00, 0xf083d3f1)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n\\n        if (IStrategy(newStrategy).strategist() == address(0)) {\\n            assembly (\\\"memory-safe\\\") {\\n                // throw `StrategyMustHaveStrategist()` error\\n                mstore(0x00, 0xeb8bf8b6)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n\\n        uint256 debtRatio_;\\n        assembly (\\\"memory-safe\\\") {\\n            debtRatio_ := sload(debtRatio.slot)\\n            // Compute debtRatio + strategyDebtRatio\\n            let sum := add(debtRatio_, strategyDebtRatio)\\n            if lt(sum, strategyDebtRatio) {\\n                // throw the `Overflow` error\\n                revert(0, 0)\\n            }\\n\\n            // if (debtRatio + strategyDebtRatio > MAX_BPS)\\n            if gt(sum, MAX_BPS) {\\n                // throw the `InvalidDebtRatio` error\\n                mstore(0x00, 0x79facb0d)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // if (strategyMinDebtPerHarvest > strategyMaxDebtPerHarvest)\\n            if gt(strategyMinDebtPerHarvest, strategyMaxDebtPerHarvest) {\\n                // throw the `InvalidMinDebtPerHarvest` error\\n                mstore(0x00, 0x5f3bd953)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // if (strategyPerformanceFee > 5000)\\n            if gt(strategyPerformanceFee, 5000) {\\n                // throw the `InvalidPerformanceFee` error\\n                mstore(0x00, 0xf14508d0)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Add strategy to strategies mapping\\n            // Strategy struct\\n            // StrategyData({\\n            //     strategyPerformanceFee: uint16(strategyPerformanceFee),\\n            //     strategyDebtRatio: uint16(strategyDebtRatio),\\n            //     strategyActivation: uint48(block.timestamp),\\n            //     strategyLastReport: uint48(block.timestamp),\\n            //     strategyMaxDebtPerHarvest: uint128(strategyMaxDebtPerHarvest),\\n            //     strategyMinDebtPerHarvest: uint128(strategyMinDebtPerHarvest),\\n            //     strategyTotalDebt: 0,\\n            //     strategyTotalGain: 0,\\n            //     strategyTotalLoss: 0\\n            // });\\n\\n            // Using yul saves 5k gas, bitmasks are used to create the `StrategyData` struct above.\\n            // Slot 0 and slot 1 will be updated. Slot 2 is not updated since it stores `strategyTotalDebt`\\n            // and `strategyTotalLoss`, which will remain with a value of 0 upon strategy addition.\\n\\n            // Store data for slot 0 in strategies[newStrategy]\\n            sstore(\\n                slot,\\n                or(\\n                    shl(128, strategyMaxDebtPerHarvest),\\n                    or(\\n                        shl(80, and(0xffffffffffff, timestamp())), // Set `strategyLastReport` to `block.timestamp`\\n                        or(\\n                            shl(32, and(0xffffffffffff, timestamp())), // Set `strategyActivation` to `block.timestamp`\\n                            or(shl(16, and(0xffff, strategyPerformanceFee)), and(0xffff, strategyDebtRatio))\\n                        )\\n                    )\\n                )\\n            )\\n\\n            // Store data for slot 1 in strategies[newStrategy]\\n            sstore(add(slot, 1), shr(128, shl(128, strategyMinDebtPerHarvest)))\\n        }\\n\\n        // Grant `STRATEGY_ROLE` to strategy\\n        _grantRoles(newStrategy, STRATEGY_ROLE);\\n\\n        assembly {\\n            // Update vault parameters\\n            // debtRatio += strategyDebtRatio;\\n            sstore(debtRatio.slot, add(debtRatio_, strategyDebtRatio))\\n            // Add strategy to withdrawal queue\\n            // withdrawalQueue[MAXIMUM_STRATEGIES - 1] = newStrategy;\\n            sstore(add(withdrawalQueue.slot, sub(MAXIMUM_STRATEGIES, 1)), newStrategy)\\n        }\\n\\n        _organizeWithdrawalQueue();\\n\\n        assembly (\\\"memory-safe\\\") {\\n            // Emit the `StrategyAdded` event\\n            mstore(0x00, strategyDebtRatio)\\n            mstore(0x20, strategyMaxDebtPerHarvest)\\n            mstore(0x40, strategyMinDebtPerHarvest)\\n            mstore(0x60, strategyPerformanceFee)\\n            log2(0x00, 0x80, _STRATEGY_ADDED_EVENT_SIGNATURE, newStrategy)\\n        }\\n    }\\n\\n    /// @notice Removes a strategy from the queue\\n    /// @dev  We don't do this with `revokeStrategy` because it should still be possible to withdraw from the Strategy if it's unwinding.\\n    /// @param strategy The strategy to remove\\n    function removeStrategy(address strategy) external checkRoles(ADMIN_ROLE) noEmergencyShutdown {\\n        address[MAXIMUM_STRATEGIES] memory cachedWithdrawalQueue = withdrawalQueue;\\n        for (uint256 i; i < MAXIMUM_STRATEGIES;) {\\n            if (cachedWithdrawalQueue[i] == strategy) {\\n                // The strategy was found and can be removed\\n                withdrawalQueue[i] = address(0);\\n\\n                _removeRoles(strategy, STRATEGY_ROLE);\\n\\n                // Update withdrawal queue\\n                _organizeWithdrawalQueue();\\n\\n                // Emit the `StrategyRemoved` event\\n                assembly {\\n                    log2(0x00, 0x00, _STRATEGY_REMOVED_EVENT_SIGNATURE, strategy)\\n                }\\n                return;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @notice Revoke a Strategy, setting its debt limit to 0 and preventing any future deposits\\n    /// @dev This function should only be used in the scenario where the Strategy is being retired but no migration\\n    /// of the positions is possible, or in the extreme scenario that the Strategy needs to be put into \\\"Emergency Exit\\\"\\n    /// mode in order for it to exit as quickly as possible. The latter scenario could be for any reason that is considered\\n    /// \\\"critical\\\" that the Strategy exits its position as fast as possible, such as a sudden change in market\\n    /// conditions leading to losses, or an imminent failure in an external dependency.\\n    /// @param strategy The strategy to revoke\\n    function revokeStrategy(address strategy) external checkRoles(ADMIN_ROLE) {\\n        uint256 cachedStrategyDebtRatio = strategies[strategy].strategyDebtRatio; // Saves an SLOAD if strategy is != addr(0)\\n        assembly (\\\"memory-safe\\\") {\\n            // if (strategies[strategy].strategyActivation == 0)\\n            if iszero(cachedStrategyDebtRatio) {\\n                // throw `StrategyDebtRatioAlreadyZero()` error\\n                mstore(0x00, 0xe3a1d5ed)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        // Remove `STRATEGY_ROLE` from strategy\\n        _removeRoles(strategy, STRATEGY_ROLE);\\n\\n        // Revoke the strategy\\n        _revokeStrategy(strategy, cachedStrategyDebtRatio);\\n    }\\n\\n    /// @notice Updates a given strategy configured data\\n    /// @param strategy The strategy to change the data to\\n    /// @param newDebtRatio The new percentage of the total assets in the vault that `strategy` has access to\\n    /// @param newMaxDebtPerHarvest New lower limit on the increase of debt since last harvest\\n    /// @param newMinDebtPerHarvest New upper limit on the increase of debt since last harvest\\n    /// @param newPerformanceFee New fee the strategist will receive based on this Vault's performance\\n    function updateStrategyData(\\n        address strategy,\\n        uint256 newDebtRatio,\\n        uint256 newMaxDebtPerHarvest,\\n        uint256 newMinDebtPerHarvest,\\n        uint256 newPerformanceFee\\n    ) external checkRoles(ADMIN_ROLE) {\\n        uint256 slot; // Slot where strategies[strategy] slot will be stored\\n        uint256 slotContent; // Used to store strategies[strategy] slot content\\n\\n        assembly (\\\"memory-safe\\\") {\\n            // Compute strategies[newStrategy] slot\\n            mstore(0x00, strategy)\\n            mstore(0x20, strategies.slot)\\n            slot := keccak256(0x00, 0x40)\\n\\n            // Load strategies[newStrategy] data into `slotContent`\\n            slotContent := sload(slot)\\n            // if (strategyData.strategyActivation == 0)\\n            if iszero(shr(208, shl(176, slotContent))) {\\n                // throw `StrategyNotActive()` error\\n                mstore(0x00, 0xdc974a98)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        if (IStrategy(strategy).emergencyExit() == 2) {\\n            assembly (\\\"memory-safe\\\") {\\n                // throw `StrategyInEmergencyExitMode()` error\\n                mstore(0x00, 0x57c7c24f)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            // if (newMinDebtPerHarvest > newMaxDebtPerHarvest)\\n            if gt(newMinDebtPerHarvest, newMaxDebtPerHarvest) {\\n                // throw the `InvalidMinDebtPerHarvest` error\\n                mstore(0x00, 0x5f3bd953)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // if (strategyPerformanceFee > 5000)\\n            if gt(newPerformanceFee, 5000) {\\n                // throw the `InvalidPerformanceFee` error\\n                mstore(0x00, 0xf14508d0)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n\\n        uint256 strategyDebtRatio_;\\n        assembly {\\n            // Compute strategies[newStrategy].strategyDebtRatio\\n            strategyDebtRatio_ := shr(240, shl(240, slotContent))\\n        }\\n\\n        uint256 debtRatio_;\\n        unchecked {\\n            // Update `debtRatio` storage as well as cache `debtRatio` final value result in `debtRatio_`\\n            // Underflowing will make maxbps check fail later\\n            debtRatio_ = debtRatio -= strategyDebtRatio_;\\n        }\\n\\n        assembly (\\\"memory-safe\\\") {\\n            let sum := add(debtRatio_, newDebtRatio)\\n            if lt(sum, debtRatio_) {\\n                // throw the `Overflow` error\\n                revert(0, 0)\\n            }\\n            // if (debtRatio_ + newDebtRatio > MAX_BPS)\\n            if gt(sum, MAX_BPS) {\\n                // throw the `InvalidDebtRatio` error\\n                mstore(0x00, 0x79facb0d)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n\\n        unchecked {\\n            // Add new debt ratio to current `debtRatio`\\n            debtRatio = debtRatio_ + newDebtRatio;\\n        }\\n\\n        assembly (\\\"memory-safe\\\") {\\n            // Update strategies[strategy] with new updated data: debtRatio, maxDebtPerHarvest, minDebtPerHarvest, performanceFee\\n            // Slot 0 and slot 1 will be updated with the new values. Slot 2 is not updated since it stores `strategyTotalDebt`\\n            // and `strategyTotalLoss`, which are not updated in `updateStrategyData()`.\\n\\n            // Store data for slot 0 in strategies[strategy]\\n            sstore(\\n                slot,\\n                or(\\n                    // Obtain old values in slot\\n                    and(shl(32, 0xffffffffffffffffffffffff), slotContent), // Extract previously stored `strategyActivation` and `strategyLastReport`\\n                    // Build new values to store\\n                    or(\\n                        shl(128, newMaxDebtPerHarvest),\\n                        or(shl(16, and(0xffff, newPerformanceFee)), and(0xffff, newDebtRatio))\\n                    )\\n                )\\n            )\\n            // Store data for slot 1 in strategies[strategy]\\n            sstore(\\n                add(slot, 1),\\n                or(\\n                    // Obtain old values in slot\\n                    shl(128, shr(128, sload(add(slot, 1)))), // Extract previously stored `strategyTotalGain`\\n                    // Build new values to store\\n                    shr(128, shl(128, newMinDebtPerHarvest))\\n                )\\n            )\\n\\n            // Emit the `StrategyUpdated` event\\n            mstore(0x00, newDebtRatio)\\n            mstore(0x20, newMaxDebtPerHarvest)\\n            mstore(0x40, newMinDebtPerHarvest)\\n            mstore(0x60, newPerformanceFee)\\n            log2(0x00, 0x80, _STRATEGY_UPDATED_EVENT_SIGNATURE, strategy)\\n        }\\n    }\\n\\n    ////////////////////////////////////////////////////////////////\\n    ///                   VAULT CONFIGURATION                    ///\\n    ////////////////////////////////////////////////////////////////\\n\\n    /// @notice Updates the withdrawalQueue to match the addresses and order specified by `queue`\\n    /// @dev There can be fewer strategies than the maximum, as well as fewer than the total number\\n    /// of strategies active in the vault.\\n    /// Note This is order sensitive, specify the addresses in the order in which funds should be\\n    /// withdrawn (so `queue`[0] is the first Strategy withdrawn from, `queue`[1] is the second, etc.),\\n    /// and add address(0) only when strategies to be added have occupied first queue positions.\\n    /// This means that the least impactful Strategy (the Strategy that will have its core positions\\n    /// impacted the least by having funds removed) should be at `queue`[0], then the next least\\n    /// impactful at `queue`[1], and so on.\\n    /// @param queue The array of addresses to use as the new withdrawal queue. **This is order sensitive**.\\n    function setWithdrawalQueue(address[MAXIMUM_STRATEGIES] calldata queue) external checkRoles(ADMIN_ROLE) {\\n        address prevStrategy;\\n        // Check queue order is correct\\n        for (uint256 i; i < MAXIMUM_STRATEGIES;) {\\n            assembly (\\\"memory-safe\\\") {\\n                let strategy := calldataload(add(4, mul(i, 0x20)))\\n                // if (prevStrategy == address(0) && queue[i] != address(0) && i != 0)\\n                if and(gt(strategy, 0), and(iszero(prevStrategy), gt(i, 0))) {\\n                    // throw the `InvalidQueueOrder` error\\n                    mstore(0x00, 0xefb91db4)\\n                    revert(0x1c, 0x04)\\n                }\\n\\n                // Store data necessary to compute strategies[newStrategy] slot\\n                mstore(0x00, strategy)\\n                mstore(0x20, strategies.slot)\\n\\n                // if (strategy != address(0) && strategies[strategy].strategyActivation == 0)\\n                if and(iszero(shr(208, shl(176, sload(keccak256(0x00, 0x40))))), gt(strategy, 0)) {\\n                    // throw the `StrategyNotActive` error\\n                    mstore(0x00, 0xdc974a98)\\n                    revert(0x1c, 0x04)\\n                }\\n                prevStrategy := strategy\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        withdrawalQueue = queue;\\n        emit WithdrawalQueueUpdated(queue);\\n    }\\n\\n    /// @notice Used to change the value of `performanceFee`\\n    /// @dev Should set this value below the maximum strategist performance fee\\n    /// @param _performanceFee The new performance fee to use\\n    function setPerformanceFee(uint256 _performanceFee) external checkRoles(ADMIN_ROLE) {\\n        assembly (\\\"memory-safe\\\") {\\n            // if (strategyPerformanceFee > 5000)\\n            if gt(_performanceFee, 5000) {\\n                // throw the `InvalidPerformanceFee` error\\n                mstore(0x00, 0xf14508d0)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        performanceFee = _performanceFee;\\n        assembly (\\\"memory-safe\\\") {\\n            // Emit the `PerformanceFeeUpdated` event\\n            mstore(0x00, _performanceFee)\\n            log1(0x00, 0x20, _PERFORMANCE_FEE_UPDATED_EVENT_SIGNATURE)\\n        }\\n    }\\n\\n    /// @notice Used to change the value of `managementFee`\\n    /// @param _managementFee The new performance fee to use\\n    function setManagementFee(uint256 _managementFee) external checkRoles(ADMIN_ROLE) {\\n        assembly (\\\"memory-safe\\\") {\\n            // if (_managementFee > MAX_BPS)\\n            if gt(_managementFee, MAX_BPS) {\\n                // throw the `InvalidManagementFee` error\\n                mstore(0x00, 0x8e9b51ff)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        managementFee = _managementFee;\\n        assembly {\\n            // Emit the `ManagementFeeUpdated` event\\n            mstore(0x00, _managementFee)\\n            log1(0x00, 0x20, _MANAGEMENT_FEE_UPDATED_EVENT_SIGNATURE)\\n        }\\n    }\\n\\n    /// @notice Used to change the value of `lockedProfitDegradation`\\n    /// @param _lockedProfitDegradation The rate of degradation in percent per second scaled to 1e18\\n    function setLockedProfitDegradation(uint256 _lockedProfitDegradation) external checkRoles(ADMIN_ROLE) {\\n        assembly (\\\"memory-safe\\\") {\\n            // if (_lockedProfitDegradation > DEGRADATION_COEFFICIENT)\\n            if gt(_lockedProfitDegradation, DEGRADATION_COEFFICIENT) {\\n                // throw the `InvalidLockedProfitDegradation` error\\n                mstore(0x00, 0xd5fccc67)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n\\n        lockedProfitDegradation = _lockedProfitDegradation;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            // Emit the `LockedProfitDegradationUpdated` event\\n            mstore(0x00, _lockedProfitDegradation)\\n            log1(0x00, 0x20, _LOCKED_PROFIT_DEGRADATION_UPDATED_EVENT_SIGNATURE)\\n        }\\n    }\\n\\n    /// @notice Changes the maximum amount of tokens that can be deposited in this Vault\\n    /// @dev This is not how much may be deposited by a single depositor,\\n    /// but the maximum amount that may be deposited across all depositors\\n    /// @param _depositLimit The new deposit limit to use\\n    function setDepositLimit(uint256 _depositLimit) external checkRoles(ADMIN_ROLE) {\\n        depositLimit = _depositLimit;\\n        assembly (\\\"memory-safe\\\") {\\n            // Emit the `DepositLimitUpdated` event\\n            mstore(0x00, _depositLimit)\\n            log1(0x00, 0x20, _DEPOSIT_LIMIT_UPDATED_EVENT_SIGNATURE)\\n        }\\n    }\\n\\n    /// @notice Activates or deactivates Vault mode where all Strategies go into full withdrawal.\\n    /// During Emergency Shutdown:\\n    /// 1. No users may deposit into the Vault (but may withdraw as usual)\\n    /// 2. No new Strategies may be added\\n    /// 3. Each Strategy must pay back their debt as quickly as reasonable to minimally affect their position\\n    /// @param _emergencyShutdown If true, the Vault goes into Emergency Shutdown. If false, the Vault goes back into normal operation\\n    function setEmergencyShutdown(bool _emergencyShutdown) external checkRoles(EMERGENCY_ADMIN_ROLE) {\\n        emergencyShutdown = _emergencyShutdown;\\n        assembly (\\\"memory-safe\\\") {\\n            // Emit the `EmergencyShutdownUpdated` event\\n            mstore(0x00, _emergencyShutdown)\\n            log1(0x00, 0x20, _EMERGENCY_SHUTDOWN_UPDATED_EVENT_SIGNATURE)\\n        }\\n    }\\n\\n    /// @notice Updates the treasury address\\n    /// @param _treasury The new treasury address\\n    function setTreasury(address _treasury) external checkRoles(ADMIN_ROLE) {\\n        treasury = _treasury;\\n        assembly (\\\"memory-safe\\\") {\\n            // Emit the `TreasuryUpdated` event\\n            mstore(0x00, _treasury)\\n            log1(0x00, 0x20, _TREASURY_UPDATED_EVENT_SIGNATURE)\\n        }\\n    }\\n\\n    ////////////////////////////////////////////////////////////////\\n    ///                    VIEW FUNCTIONS                        ///\\n    ////////////////////////////////////////////////////////////////\\n\\n    /// @notice Returns the total quantity of all assets under control of this Vault,\\n    /// whether they're loaned out to a Strategy, or currently held in the Vault\\n    /// @return The total assets under control of this Vault\\n    function totalAssets() public view returns (uint256) {\\n        return _totalAssets();\\n    }\\n\\n    /// @notice Determines the amount of underlying corresponding to `shares` amount of shares\\n    /// @dev Measuring quantity of shares to issue is based on the total outstanding debt that this contract\\n    /// has (\\\"expected value\\\") instead of the total balance sheet (balanceOf) it has (\\\"estimated value\\\"). This has important\\n    /// security considerations, and is done intentionally. If this value were measured against external systems, it\\n    /// could be purposely manipulated by an attacker to withdraw more assets than they otherwise should be able\\n    /// to claim by redeeming their shares.\\n    /// @param shares The amount of shares to compute the equivalent underlying for\\n    /// @return the value of underlying computed given the `shares` amount of shares given as input\\n    function shareValue(uint256 shares) public view returns (uint256) {\\n        return _shareValue(shares);\\n    }\\n\\n    /// @notice Determines how many shares `amount` of underlying asset would receive\\n    /// @param amount The amount to compute the equivalent shares for\\n    /// @return shares the shares computed given the amount\\n    function sharesForAmount(uint256 amount) public view returns (uint256 shares) {\\n        return _sharesForAmount(amount);\\n    }\\n\\n    /// @notice Amount of tokens in Vault a Strategy has access to as a credit line.\\n    /// This will check the Strategy's debt limit, as well as the tokens available in the\\n    /// Vault, and determine the maximum amount of tokens (if any) the Strategy may draw on\\n    /// @param strategy The strategy to check\\n    /// @return The quantity of tokens available for the Strategy to draw on\\n    function creditAvailable(address strategy) external view returns (uint256) {\\n        return _creditAvailable(strategy);\\n    }\\n\\n    /// @notice Determines if `strategy` is past its debt limit and if any tokens should be withdrawn to the Vault\\n    /// @param strategy The Strategy to check\\n    /// @return The quantity of tokens to withdraw\\n    function debtOutstanding(address strategy) external view returns (uint256) {\\n        return _debtOutstanding(strategy);\\n    }\\n\\n    /// @notice returns stratetegyTotalDebt, saves gas, no need to return the whole struct\\n    /// @param strategy The Strategy to check\\n    /// @return strategyTotalDebt The strategy's total debt\\n    function getStratetegyTotalDebt(address strategy) external view returns (uint256 strategyTotalDebt) {\\n        assembly (\\\"memory-safe\\\") {\\n            // Store data necessary to compute strategies[newStrategy] slot\\n            mstore(0x00, strategy)\\n            mstore(0x20, strategies.slot)\\n\\n            // Obtain strategies[strategy].strategyTotalDebt, stored in struct's slot 2\\n            strategyTotalDebt := shr(128, shl(128, sload(add(keccak256(0x00, 0x40), 2))))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/base/BaseVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.19;\\n\\nimport {StrategyData} from \\\"../helpers/VaultTypes.sol\\\";\\nimport {ERC20} from \\\"../lib/ERC20.sol\\\";\\nimport {ReentrancyGuard} from \\\"../lib/ReentrancyGuard.sol\\\";\\nimport {IStrategy} from \\\"../interfaces/IStrategy.sol\\\";\\n\\nimport {OwnableRoles} from \\\"solady/auth/OwnableRoles.sol\\\";\\nimport {IERC20} from \\\"openzeppelin/token/ERC20/IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"openzeppelin/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {FixedPointMathLib as Math} from \\\"solady/utils/FixedPointMathLib.sol\\\";\\nimport {SafeTransferLib} from \\\"solady/utils/SafeTransferLib.sol\\\";\\n\\n/// @title MaxApy Base Vault Contract\\n/// @notice Stores data and executes generic logic for MaxApy vaults\\n/// @author MaxApy\\ncontract BaseVault is ERC20, OwnableRoles, ReentrancyGuard {\\n    using SafeTransferLib for address;\\n\\n    ////////////////////////////////////////////////////////////////\\n    ///                         CONSTANTS                        ///\\n    ////////////////////////////////////////////////////////////////\\n\\n    uint256 public constant MAXIMUM_STRATEGIES = 20;\\n    uint256 public constant MAX_BPS = 10_000;\\n    uint256 public constant DEGRADATION_COEFFICIENT = 1e18;\\n    uint256 public constant SECS_PER_YEAR = 31_556_952;\\n    /// 365.2425 days\\n\\n    /// Roles\\n    uint256 public constant ADMIN_ROLE = _ROLE_0;\\n    uint256 public constant EMERGENCY_ADMIN_ROLE = _ROLE_1;\\n    uint256 public constant STRATEGY_ROLE = _ROLE_2;\\n\\n    ////////////////////////////////////////////////////////////////\\n    ///                         ERRORS                           ///\\n    ////////////////////////////////////////////////////////////////\\n    error QueueIsFull();\\n    error VaultInEmergencyShutdownMode();\\n    error StrategyInEmergencyExitMode();\\n    error InvalidZeroAddress();\\n    error StrategyAlreadyActive();\\n    error StrategyNotActive();\\n    error InvalidStrategyVault();\\n    error InvalidStrategyUnderlying();\\n    error InvalidDebtRatio();\\n    error InvalidMinDebtPerHarvest();\\n    error InvalidPerformanceFee();\\n    error InvalidManagementFee();\\n    error InvalidLockedProfitDegradation();\\n    error StrategyDebtRatioAlreadyZero();\\n    error InvalidQueueOrder();\\n    error VaultDepositLimitExceeded();\\n    error InvalidZeroAmount();\\n    error InvalidZeroShares();\\n    error InvalidMaxLoss();\\n    error MaxLossReached();\\n    error LossGreaterThanStrategyTotalDebt();\\n    error InvalidReportedGainAndDebtPayment();\\n    error FeesAlreadyAssesed();\\n\\n    ////////////////////////////////////////////////////////////////\\n    ///                         EVENTS                           ///\\n    ////////////////////////////////////////////////////////////////\\n\\n    /// @notice Emitted when a strategy is newly added to the protocol\\n    event StrategyAdded(\\n        address indexed newStrategy,\\n        uint16 strategyDebtRatio,\\n        uint128 strategyMaxDebtPerHarvest,\\n        uint128 strategyMinDebtPerHarvest,\\n        uint16 strategyPerformanceFee\\n    );\\n\\n    /// @notice Emitted when a strategy is removed from the protocol\\n    event StrategyAdded(address indexed strategy);\\n\\n    /// @notice Emitted when a vault's emergency shutdown state is switched\\n    event EmergencyShutdownUpdated(bool emergencyShutdown);\\n\\n    /// @notice Emitted when a strategy is revoked from the vault\\n    event StrategyRevoked(address indexed strategy);\\n\\n    /// @notice Emitted when a strategy parameters are updated\\n    event StrategyUpdated(\\n        address indexed strategy,\\n        uint16 newDebtRatio,\\n        uint128 newMaxDebtPerHarvest,\\n        uint128 newMinDebtPerHarvest,\\n        uint16 newPerformanceFee\\n    );\\n\\n    /// @notice Emitted when the withdrawal queue is updated\\n    event WithdrawalQueueUpdated(address[MAXIMUM_STRATEGIES] withdrawalQueue);\\n\\n    /// @notice Emitted when the vault's performance fee is updated\\n    event PerformanceFeeUpdated(uint16 newPerformanceFee);\\n\\n    /// @notice Emitted when the vault's management fee is updated\\n    event ManagementFeeUpdated(uint256 newManagementFee);\\n\\n    /// @notice Emitted the vault's locked profit degradation is updated\\n    event LockedProfitDegradationUpdated(uint256 newLockedProfitDegradation);\\n\\n    /// @notice Emitted when the vault's deposit limit is updated\\n    event DepositLimitUpdated(uint256 newDepositLimit);\\n\\n    /// @notice Emitted when the vault's treasury addresss is updated\\n    event TreasuryUpdated(address treasury);\\n\\n    /// @notice Emitted on vault deposits\\n    event Deposit(address indexed recipient, uint256 shares, uint256 amount);\\n\\n    /// @notice Emitted on vault withdrawals\\n    event Withdraw(address indexed recipient, uint256 shares, uint256 amount);\\n\\n    /// @notice Emitted on withdrawal strategy withdrawals\\n    event WithdrawFromStrategy(address indexed strategy, uint128 strategyTotalDebt, uint128 loss);\\n\\n    /// @notice Emitted after assessing protocol fees\\n    event FeesReported(uint256 managementFee, uint16 performanceFee, uint256 strategistFee, uint256 duration);\\n\\n    /// @notice Emitted after a strategy reports to the vault\\n    event StrategyReported(\\n        address indexed strategy,\\n        uint256 gain,\\n        uint256 loss,\\n        uint256 debtPayment,\\n        uint128 strategyTotalGain,\\n        uint128 strategyTotalLoss,\\n        uint128 strategyTotalDebt,\\n        uint256 credit,\\n        uint16 strategyDebtRatio\\n    );\\n\\n    // EVENT SIGNATURES\\n\\n    uint256 internal constant _STRATEGY_ADDED_EVENT_SIGNATURE =\\n        0x66277e61c003f7703009ad857a4c4900f9cd3ee44535afe5905f98d53922e0f4;\\n\\n    uint256 internal constant _STRATEGY_REMOVED_EVENT_SIGNATURE =\\n        0x3f008fd510eae7a9e7bee13513d7b83bef8003d488b5a3d0b0da4de71d6846f1;\\n\\n    uint256 internal constant _EMERGENCY_SHUTDOWN_UPDATED_EVENT_SIGNATURE =\\n        0xa63137c77816d51f856c11ffb11e84757ac9db0ce2569f94edd04c91fe2250a1;\\n\\n    uint256 internal constant _STRATEGY_REVOKED_EVENT_SIGNATURE =\\n        0x4201c688d84c01154d321afa0c72f1bffe9eef53005c9de9d035074e71e9b32a;\\n\\n    uint256 internal constant _STRATEGY_UPDATED_EVENT_SIGNATURE =\\n        0x102a33a8369310733322056f2c0f753209cd77c65b1ce5775c2d6f181e38778f;\\n\\n    uint256 internal constant _WITHDRAWAL_QUEUE_UPDATED_EVENT_SIGNATURE =\\n        0x92fa0b6a2861480bf8c9977f0f9fe1d95c535ba23cbf234f2716fc765aec3be8;\\n\\n    uint256 internal constant _PERFORMANCE_FEE_UPDATED_EVENT_SIGNATURE =\\n        0x0632b4ddf7c06e7e3bc19b7ce92862c7de91b312a392142116fb574a06a47cfd;\\n\\n    uint256 internal constant _MANAGEMENT_FEE_UPDATED_EVENT_SIGNATURE =\\n        0x2147e2bc8c39e67f74b1a9e08896ea1485442096765942206af1f4bc8bcde917;\\n\\n    uint256 internal constant _LOCKED_PROFIT_DEGRADATION_UPDATED_EVENT_SIGNATURE =\\n        0x056863905a721211fc4dda1d688efc8f120b4b689d2e41da8249cf6eff200691;\\n\\n    uint256 internal constant _DEPOSIT_LIMIT_UPDATED_EVENT_SIGNATURE =\\n        0xc512617347fd848ec9d7347c99c10e4fa7059132c92d0445930a7fb0c8252ff5;\\n\\n    uint256 internal constant _TREASURY_UPDATED_EVENT_SIGNATURE =\\n        0x7dae230f18360d76a040c81f050aa14eb9d6dc7901b20fc5d855e2a20fe814d1;\\n\\n    uint256 internal constant _DEPOSIT_EVENT_SIGNATURE =\\n        0x90890809c654f11d6e72a28fa60149770a0d11ec6c92319d6ceb2bb0a4ea1a15;\\n\\n    uint256 internal constant _WITHDRAW_EVENT_SIGNATURE =\\n        0xf279e6a1f5e320cca91135676d9cb6e44ca8a08c0b88342bcdb1144f6511b568;\\n\\n    uint256 internal constant _WITHDRAW_FROM_STRATEGY_EVENT_SIGNATURE =\\n        0x8c1171ccd065c6769e1540f65c3c0874e5f7173ccdff7ca293238e69d000bf20;\\n\\n    uint256 internal constant _FEES_REPORTED_EVENT_SIGNATURE =\\n        0x25bf703141a84375d04ea08a0c4a21c7406f300f133e12aef555607b4f3ff238;\\n\\n    uint256 internal constant _STRATEGY_REPORTED_EVENT_SIGNATURE =\\n        0xc2d7e1173e37528dce423c72b129fa1ad2c5d51e50974c64fe13f1928eb27f89;\\n\\n    ////////////////////////////////////////////////////////////////\\n    ///               VAULT GLOBAL STATE VARIABLES               ///\\n    ////////////////////////////////////////////////////////////////\\n\\n    /// @notice The vault underlying asset\\n    IERC20 public underlyingAsset;\\n\\n    /// @notice Vault state stating if vault is in emergency shutdown mode\\n    bool public emergencyShutdown;\\n    /// @notice Limit for totalAssets the Vault can hold\\n    uint256 public depositLimit;\\n    /// @notice Debt ratio for the Vault across all strategies (in BPS, <= 10k)\\n    uint256 public debtRatio;\\n    /// @notice Amount of tokens that are in the vault\\n    uint256 public totalIdle;\\n    /// @notice Amount of tokens that all strategies have borrowed\\n    uint256 public totalDebt;\\n    /// @notice block.timestamp of last report\\n    uint256 public lastReport;\\n    /// @notice How much profit is locked and cant be withdrawn\\n    uint256 public lockedProfit;\\n    /// @notice Rate per block of degradation. DEGRADATION_COEFFICIENT is 100% per block\\n    uint256 public lockedProfitDegradation;\\n    /// @notice Rewards address where performance and management fees are sent to\\n    address public treasury;\\n\\n    /// @notice Record of all the strategies that are allowed to receive assets from the vault\\n    mapping(address => StrategyData) public strategies;\\n    /// @notice Ordering that `withdraw` uses to determine which strategies to pull funds from\\n    address[MAXIMUM_STRATEGIES] public withdrawalQueue;\\n\\n    /// @notice Fee minted to the treasury and deducted from yield earned every time the vault harvests a strategy\\n    uint256 public performanceFee;\\n    /// @notice Flat rate taken from vault yield over a year\\n    uint256 public managementFee;\\n\\n    ////////////////////////////////////////////////////////////////\\n    ///                         MODIFIERS                        ///\\n    ////////////////////////////////////////////////////////////////\\n\\n    modifier checkRoles(uint256 roles) {\\n        _checkRoles(roles);\\n        _;\\n    }\\n\\n    modifier noEmergencyShutdown() {\\n        assembly (\\\"memory-safe\\\") {\\n            // if emergencyShutdown == true\\n            if shr(160, sload(emergencyShutdown.slot)) {\\n                // throw the `VaultInEmergencyShutdownMode` error\\n                mstore(0x00, 0x04aca5db)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _;\\n    }\\n\\n    ////////////////////////////////////////////////////////////////\\n    ///                     CONSTRUCTOR                          ///\\n    ////////////////////////////////////////////////////////////////\\n    constructor(IERC20 _underlyingAsset, string memory _name, string memory _symbol)\\n        ERC20(_name, _symbol, IERC20Metadata(address(_underlyingAsset)).decimals())\\n    {\\n        _initializeOwner(msg.sender);\\n        _grantRoles(msg.sender, ADMIN_ROLE);\\n        underlyingAsset = _underlyingAsset;\\n    }\\n\\n    ////////////////////////////////////////////////////////////////\\n    ///                    INTERNAL FUNCTIONS                    ///\\n    ////////////////////////////////////////////////////////////////\\n\\n    /// @notice Reports a strategy loss, adjusting the corresponding vault and strategy parameters\\n    /// to minimize trust in the strategy\\n    /// @param strategy The strategy reporting the loss\\n    /// @param loss The amount of loss to report\\n    function _reportLoss(address strategy, uint256 loss) internal {\\n        // Strategy data\\n        uint128 strategyTotalDebt;\\n        uint16 strategyDebtRatio;\\n\\n        // Vault data\\n        uint256 totalDebt_;\\n        uint256 debtRatio_;\\n\\n        // Slot data\\n        uint256 strategiesSlot;\\n        uint256 slot0Content;\\n        uint256 slot2Content;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            // Get strategies slot\\n            mstore(0x00, strategy)\\n            mstore(0x20, strategies.slot)\\n            strategiesSlot := keccak256(0x00, 0x40)\\n            // Obtain strategy slot 0 data\\n            slot0Content := sload(strategiesSlot)\\n            // Obtain strategy slot 2 data\\n            slot2Content := sload(add(strategiesSlot, 2))\\n\\n            // Cache strategy data\\n            strategyDebtRatio := shr(240, shl(240, slot0Content))\\n            strategyTotalDebt := shr(128, shl(128, slot2Content))\\n\\n            // Ensure loss reported is not greater than strategy total debt\\n            // if loss > strategyData.strategyTotalDebt\\n            if gt(loss, strategyTotalDebt) {\\n                // throw the `LossGreaterThanStrategyTotalDebt` error\\n                mstore(0x00, 0xd5436ad8)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Obtain vault debtRatio\\n            debtRatio_ := sload(debtRatio.slot)\\n            // Obtain vault totalDebt\\n            totalDebt_ := sload(totalDebt.slot)\\n        }\\n\\n        // Reduce trust in this strategy by the amount of loss, lowering the corresponding strategy debt ratio\\n        uint256 ratioChange = Math.min((loss * debtRatio_) / totalDebt_, strategyDebtRatio);\\n\\n        assembly {\\n            // Overflow checks\\n            if gt(ratioChange, debtRatio_) {\\n                // throw `Overflwow` error\\n                revert(0, 0)\\n            }\\n            if gt(loss, totalDebt_) {\\n                // throw `Overflow` error\\n                revert(0, 0)\\n            }\\n            if gt(ratioChange, strategyDebtRatio) {\\n                // throw `Overflow` error\\n                revert(0, 0)\\n            }\\n\\n            // Update vault data\\n            // debtRatio -= ratioChange;\\n            // totalDebt -= loss;\\n            sstore(debtRatio.slot, sub(debtRatio_, ratioChange)) // debtRatio -= ratioChange\\n            sstore(totalDebt.slot, sub(totalDebt_, loss)) // totalDebt -= loss\\n\\n            // Update strategy debt ratio\\n            // strategies[strategy].strategyDebtRatio -= ratioChange\\n            sstore(\\n                strategiesSlot,\\n                or(\\n                    shr(240, shl(240, sub(strategyDebtRatio, ratioChange))), // Compute strategies[strategy].strategyDebtRatio - ratioChange\\n                    shl(16, shr(16, slot0Content)) // Obtain previous slot data, removing `strategyDebtRatio`\\n                )\\n            )\\n\\n            // Adjust final strategy parameters by the loss\\n            let strategyTotalLoss := shr(128, slot2Content)\\n            // strategyTotalLoss += loss\\n            strategyTotalLoss := add(strategyTotalLoss, loss)\\n\\n            if lt(strategyTotalLoss, loss) {\\n                // throw `Overflow` error\\n                revert(0, 0)\\n            }\\n\\n            // Pack strategyTotalLoss and strategyTotalDebt into slot2Content\\n            slot2Content :=\\n                or(\\n                    shl(128, strategyTotalLoss),\\n                    shr(128, shl(128, sub(strategyTotalDebt, loss))) // Compute strategies[strategy].strategyTotalDebt -= loss;\\n                )\\n\\n            // Update strategy total loss and total debt, store in slot 2\\n            sstore(add(strategiesSlot, 2), slot2Content)\\n        }\\n    }\\n\\n    /// @notice Issues new shares to cover performance, management and strategist fees\\n    /// @param strategy The strategy reporting the gain\\n    /// @param gain The amount of gain to extract fees from\\n    /// @return the total fees (performance + management + strategist) extracted from the gain\\n    function _assessFees(address strategy, uint256 gain) internal returns (uint256) {\\n        bool success;\\n        uint256 slot0Content;\\n        assembly (\\\"memory-safe\\\") {\\n            // Get strategies[strategy] slot\\n            mstore(0x00, strategy)\\n            mstore(0x20, strategies.slot)\\n            // Get strategies[strategy] data\\n            slot0Content := sload(keccak256(0x00, 0x40))\\n\\n            // If strategy was just added or no gains were reported, return 0 as fees\\n            // if (strategyData.strategyActivation == block.timestamp || gain == 0)\\n            if or(eq(shr(208, shl(176, slot0Content)), timestamp()), eq(gain, 0)) { success := 1 }\\n        }\\n        if (success) {\\n            return 0;\\n        }\\n\\n        // Stack variables to cache\\n        uint256 duration;\\n        uint256 strategyPerformanceFee;\\n        uint256 computedManagementFee;\\n        uint256 computedStrategistFee;\\n        uint256 computedPerformanceFee;\\n        uint256 totalFee;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            // duration = block.timestamp - strategyData.strategyLastReport;\\n            duration := sub(timestamp(), shr(208, shl(128, slot0Content)))\\n\\n            // if duration == 0\\n            if iszero(duration) {\\n                // throw the `FeesAlreadyAssesed` error\\n                mstore(0x00, 0x17de0c6e)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Cache strategy performance fee\\n            strategyPerformanceFee := shr(240, shl(224, slot0Content))\\n\\n            // Load vault fees\\n            let managementFee_ := sload(managementFee.slot)\\n            let performanceFee_ := sload(performanceFee.slot)\\n\\n            // Overflow check equivalent to require(managementFee_ == 0 || gain <= type(uint256).max / managementFee_)\\n            if iszero(iszero(mul(managementFee_, gt(gain, div(not(0), managementFee_))))) { revert(0, 0) }\\n\\n            // Compute vault management fee\\n            // computedManagementFee = (gain * managementFee) / MAX_BPS\\n            computedManagementFee := div(mul(gain, managementFee_), MAX_BPS)\\n\\n            // Overflow check equivalent to require(strategyPerformanceFee == 0 || gain <= type(uint256).max / strategyPerformanceFee)\\n            if iszero(iszero(mul(strategyPerformanceFee, gt(gain, div(not(0), strategyPerformanceFee))))) {\\n                revert(0, 0)\\n            }\\n\\n            // Compute strategist fee\\n            // computedStrategistFee = (gain * strategyData.strategyPerformanceFee) / MAX_BPS;\\n            computedStrategistFee := div(mul(gain, strategyPerformanceFee), MAX_BPS)\\n\\n            // Overflow check equivalent to require(performanceFee_ == 0 || gain <= type(uint256).max / performanceFee_)\\n            if iszero(iszero(mul(performanceFee_, gt(gain, div(not(0), performanceFee_))))) { revert(0, 0) }\\n\\n            // Compute vault performance fee\\n            // computedPerformanceFee = (gain * performanceFee) / MAX_BPS;\\n            computedPerformanceFee := div(mul(gain, performanceFee_), MAX_BPS)\\n\\n            // totalFee = computedManagementFee + computedStrategistFee + computedPerformanceFee\\n            totalFee := add(add(computedManagementFee, computedStrategistFee), computedPerformanceFee)\\n\\n            // Ensure total fee is not greater than the gain, set total fee to become the actual gain otherwise\\n            // if totalFee > gain\\n            if gt(totalFee, gain) {\\n                // totalFee = gain\\n                totalFee := gain\\n            }\\n        }\\n\\n        // Only transfer shares if there are actual shares to transfer\\n        if (totalFee != 0) {\\n            // Compute corresponding shares and mint rewards to vault\\n            uint256 reward = _issueSharesForAmount(address(this), totalFee);\\n\\n            // Transfer corresponding rewards in shares to strategist\\n            if (computedStrategistFee != 0) {\\n                uint256 strategistReward;\\n                assembly {\\n                    // Overflow check equivalent to require(reward == 0 || computedStrategistFee <= type(uint256).max / reward)\\n                    // No need to check for totalFee == 0 since it is checked in the if clause above\\n                    if iszero(iszero(mul(reward, gt(computedStrategistFee, div(not(0), reward))))) { revert(0, 0) }\\n\\n                    // Compute strategist reward\\n                    // strategistReward = (computedStrategistFee * reward) / totalFee;\\n                    strategistReward := div(mul(computedStrategistFee, reward), totalFee)\\n                }\\n                // Transfer corresponding reward to strategist\\n                address(this).safeTransfer(IStrategy(strategy).strategist(), strategistReward);\\n            }\\n\\n            // Treasury earns remaining shares (performance fee + management fee + any dust leftover from flooring math above)\\n            uint256 cachedBalance = balanceOf(address(this));\\n            if (cachedBalance != 0) {\\n                address(this).safeTransfer(treasury, cachedBalance);\\n            }\\n        }\\n\\n        assembly (\\\"memory-safe\\\") {\\n            // Emit the `FeesReported` event\\n            let m := mload(0x40)\\n            mstore(0x00, computedManagementFee)\\n            mstore(0x20, computedPerformanceFee)\\n            mstore(0x40, computedStrategistFee)\\n            mstore(0x60, duration)\\n            log1(0x00, 0x80, _FEES_REPORTED_EVENT_SIGNATURE)\\n            mstore(0x40, m)\\n            mstore(0x60, 0)\\n        }\\n\\n        return totalFee;\\n    }\\n\\n    /// @notice Amount of tokens in Vault a Strategy has access to as a credit line.\\n    /// This will check the Strategy's debt limit, as well as the tokens available in the\\n    /// Vault, and determine the maximum amount of tokens (if any) the Strategy may draw on\\n    /// @param strategy The strategy to check\\n    /// @return The quantity of tokens available for the Strategy to draw on\\n    function _creditAvailable(address strategy) internal view returns (uint256) {\\n        if (emergencyShutdown) return 0;\\n\\n        // Compute necessary data regarding current state of the vault\\n        uint256 vaultTotalAssets = _totalAssets();\\n        uint256 vaultDebtLimit = _computeDebtLimit(debtRatio, vaultTotalAssets);\\n        uint256 vaultTotalDebt = totalDebt;\\n\\n        // Stack variables to cache\\n        bool success;\\n        uint256 slot;\\n        uint256 slot0Content;\\n        uint256 strategyTotalDebt;\\n        uint256 strategyDebtLimit;\\n        assembly (\\\"memory-safe\\\") {\\n            // Compute slot of strategies[strategy]\\n            mstore(0x00, strategy)\\n            mstore(0x20, strategies.slot)\\n            slot := keccak256(0x00, 0x40)\\n            // Load strategies[strategy].strategyTotalDebt\\n            strategyTotalDebt := shr(128, shl(128, sload(add(slot, 2))))\\n\\n            // Load slot 0 content\\n            slot0Content := sload(slot)\\n\\n            // Extract strategies[strategy].strategyDebtRatio\\n            let strategyDebtRatio := shr(240, shl(240, slot0Content))\\n\\n            // Overflow check equivalent to require(vaultTotalAssets == 0 || strategyDebtRatio <= type(uint256).max / vaultTotalAssets)\\n            if iszero(iszero(mul(vaultTotalAssets, gt(strategyDebtRatio, div(not(0), vaultTotalAssets))))) {\\n                revert(0, 0)\\n            }\\n\\n            // Compute necessary data regarding current state of the strategy\\n\\n            // strategyDebtLimit = (strategies[strategy].strategyDebtRatio * vaultTotalAssets) / MAX_BPS;\\n            strategyDebtLimit := div(mul(strategyDebtRatio, vaultTotalAssets), MAX_BPS)\\n\\n            // If strategy current debt is already greater than the configured debt limit for that strategy,\\n            // or if the vault's current debt is already greater than the configured debt limit for that vault,\\n            // no credit should be given to the strategy\\n            // if strategies[strategy].strategyTotalDebt > strategyDebtLimit || vaultTotalDebt > vaultDebtLimit\\n            if or(gt(strategyTotalDebt, strategyDebtLimit), gt(vaultTotalDebt, vaultDebtLimit)) { success := 1 }\\n        }\\n        if (success) return 0;\\n\\n        // Adjust by the vault debt limit left\\n        uint256 available;\\n        unchecked {\\n            available = Math.min(strategyDebtLimit - strategyTotalDebt, vaultDebtLimit - vaultTotalDebt);\\n        }\\n\\n        // Adjust by the idle amount of underlying the vault has\\n        available = Math.min(available, totalIdle);\\n\\n        assembly {\\n            // Adjust by min and max borrow limits per harvest\\n\\n            // if (available < strategies[strategy].strategyMinDebtPerHarvest) return 0;\\n            if lt(available, shr(128, shl(128, sload(add(slot, 1))))) { success := 1 }\\n        }\\n        if (success) return 0;\\n\\n        // Obtain strategies[strategy].strategyMaxDebtPerHarvest from the previously loaded slot0Content, this saves one SLOAD\\n        uint256 strategyMaxDebtPerHarvest;\\n        assembly {\\n            strategyMaxDebtPerHarvest := shr(128, slot0Content)\\n        }\\n        return Math.min(available, strategyMaxDebtPerHarvest);\\n    }\\n\\n    /// @notice Performs the debt limit calculation\\n    /// @param _debtRatio The debt ratio to use for computation\\n    /// @param totalAssets The amount of assets\\n    /// @return debtLimit The limit amount of assets allowed for the strategy, given the current debt ratio and total assets\\n    function _computeDebtLimit(uint256 _debtRatio, uint256 totalAssets) internal pure returns (uint256 debtLimit) {\\n        assembly {\\n            // Overflow check equivalent to require(totalAssets == 0 || _debtRatio <= type(uint256).max / totalAssets)\\n            if iszero(iszero(mul(totalAssets, gt(_debtRatio, div(not(0), totalAssets))))) { revert(0, 0) }\\n            // _debtRatio * totalAssets / MAX_BPS\\n            debtLimit := div(mul(_debtRatio, totalAssets), MAX_BPS)\\n        }\\n    }\\n\\n    /// @notice Determines if `strategy` is past its debt limit and if any tokens should be withdrawn to the Vault\\n    /// @param strategy The Strategy to check\\n    /// @return debtOutstanding The quantity of tokens to withdraw\\n    function _debtOutstanding(address strategy) internal view returns (uint256 debtOutstanding) {\\n        uint256 strategyTotalDebt;\\n        uint256 strategyDebtRatio;\\n        assembly (\\\"memory-safe\\\") {\\n            // Get strategies[strategy] slot\\n            mstore(0x00, strategy)\\n            mstore(0x20, strategies.slot)\\n            let slot := keccak256(0x00, 0x40)\\n            // Obtain strategies[strategy].strategyTotalDebt from slot 2\\n            strategyTotalDebt := shr(128, shl(128, sload(add(slot, 2))))\\n            // Obtain strategies[strategy].strategyDebtRatio from slot 0\\n            strategyDebtRatio := shr(240, shl(240, sload(slot)))\\n        }\\n        // If debt ratio configured in vault is zero or emergency shutdown, any amount of debt in the strategy should be returned\\n        if (debtRatio == 0 || emergencyShutdown) return strategyTotalDebt;\\n\\n        uint256 strategyDebtLimit = _computeDebtLimit(strategyDebtRatio, _totalAssets());\\n\\n        // There will not be debt outstanding if strategy total debt is smaller or equal to the current debt limit\\n        if (strategyDebtLimit >= strategyTotalDebt) {\\n            return 0;\\n        }\\n        unchecked {\\n            debtOutstanding = strategyTotalDebt - strategyDebtLimit;\\n        }\\n    }\\n\\n    /// @notice Reorganize `withdrawalQueue` based on premise that if there is an\\n    /// empty value between two actual values, then the empty value should be\\n    /// replaced by the later value.\\n    /// @dev Relative ordering of non-zero values is maintained.\\n    function _organizeWithdrawalQueue() internal {\\n        uint256 offset;\\n        for (uint256 i; i < MAXIMUM_STRATEGIES;) {\\n            address strategy = withdrawalQueue[i];\\n            if (strategy == address(0)) {\\n                unchecked {\\n                    ++offset;\\n                }\\n            } else if (offset > 0) {\\n                withdrawalQueue[i - offset] = strategy;\\n                withdrawalQueue[i] = address(0);\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @notice Revoke a Strategy, setting its debt limit to 0 and preventing any future deposits\\n    /// @param strategy The strategy to revoke\\n    /// @param strategy The strategy debt ratio\\n    function _revokeStrategy(address strategy, uint256 strategyDebtRatio) internal {\\n        debtRatio -= strategyDebtRatio;\\n        strategies[strategy].strategyDebtRatio = 0;\\n        assembly {\\n            log2(0x00, 0x00, _STRATEGY_REVOKED_EVENT_SIGNATURE, strategy)\\n        }\\n    }\\n\\n    /// @notice Issues `amount` Vault shares to `to`\\n    /// @dev Shares must be issued prior to taking on new collateral, or calculation will be wrong.\\n    /// This means that only *trusted* tokens (with no capability for exploitative behavior) can be used\\n    /// @param to The shares recipient\\n    /// @param amount The amount considered to compute the shares\\n    /// @return shares The amount of shares computed from the amount\\n    function _issueSharesForAmount(address to, uint256 amount) internal returns (uint256 shares) {\\n        uint256 vaultTotalSupply = totalSupply();\\n\\n        // By default, 1:1 shares are minted\\n        shares = amount;\\n\\n        if (vaultTotalSupply != 0) {\\n            // Mint amount of tokens based on what the Vault is managing overall\\n            shares = (amount * vaultTotalSupply) / _freeFunds();\\n        }\\n\\n        assembly (\\\"memory-safe\\\") {\\n            // if shares == 0\\n            if iszero(shares) {\\n                // Throw the `InvalidZeroShares` error\\n                mstore(0x00, 0x5a870a25)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n\\n        _mint(to, shares);\\n    }\\n\\n    ////////////////////////////////////////////////////////////////\\n    ///                INTERNAL VIEW FUNCTIONS                   ///\\n    ////////////////////////////////////////////////////////////////\\n\\n    /// @notice Calculates the free funds available considering the locked profit\\n    /// @return The amount of free funds available\\n    function _freeFunds() internal view returns (uint256) {\\n        return _totalAssets() - _calculateLockedProfit();\\n    }\\n\\n    /// @notice Returns the total quantity of all assets under control of this Vault,\\n    /// whether they're loaned out to a Strategy, or currently held in the Vault\\n    /// @return totalAssets The total assets under control of this Vault\\n    function _totalAssets() internal view returns (uint256 totalAssets) {\\n        assembly {\\n            let totalDebt_ := sload(totalDebt.slot)\\n            totalAssets := add(sload(totalIdle.slot), totalDebt_)\\n\\n            // Perform overflow check\\n            if lt(totalAssets, totalDebt_) { revert(0, 0) }\\n        }\\n    }\\n\\n    /// @notice Calculates how much profit is locked and cant be withdrawn\\n    /// @return calculatedLockedProfit The total assets locked\\n    function _calculateLockedProfit() internal view returns (uint256 calculatedLockedProfit) {\\n        assembly {\\n            // No need to check for underflow, since block.timestamp is always greater or equal than lastReport\\n            let difference := sub(timestamp(), sload(lastReport.slot)) // difference = block.timestamp - lastReport\\n            let lockedProfitDegradation_ := sload(lockedProfitDegradation.slot)\\n\\n            // Overflow check equivalent to require(lockedProfitDegradation_ == 0 || difference <= type(uint256).max / lockedProfitDegradation_)\\n            if iszero(iszero(mul(lockedProfitDegradation_, gt(difference, div(not(0), lockedProfitDegradation_))))) {\\n                revert(0, 0)\\n            }\\n\\n            // lockedFundsRatio = (block.timestamp - lastReport) * lockedProfitDegradation\\n            let lockedFundsRatio := mul(difference, lockedProfitDegradation_)\\n\\n            if lt(lockedFundsRatio, DEGRADATION_COEFFICIENT) {\\n                let vaultLockedProfit := sload(lockedProfit.slot)\\n                // Overflow check equivalent to require(vaultLockedProfit == 0 || lockedFundsRatio <= type(uint256).max / vaultLockedProfit)\\n                if iszero(iszero(mul(vaultLockedProfit, gt(lockedFundsRatio, div(not(0), vaultLockedProfit))))) {\\n                    revert(0, 0)\\n                }\\n                // ((lockedFundsRatio * vaultLockedProfit) / DEGRADATION_COEFFICIENT\\n                let degradation := div(mul(lockedFundsRatio, vaultLockedProfit), DEGRADATION_COEFFICIENT)\\n                // Overflow check\\n                if gt(degradation, vaultLockedProfit) { revert(0, 0) }\\n                // calculatedLockedProfit = vaultLockedProfit - ((lockedFundsRatio * vaultLockedProfit) / DEGRADATION_COEFFICIENT);\\n                calculatedLockedProfit := sub(vaultLockedProfit, degradation)\\n            }\\n        }\\n    }\\n\\n    /// @notice Determines the amount of underlying corresponding to `shares` amount of shares\\n    /// @dev Measuring quantity of shares to issue is based on the total outstanding debt that this contract\\n    /// has (\\\"expected value\\\") instead of the total balance sheet (balanceOf) it has (\\\"estimated value\\\"). This has important\\n    /// security considerations, and is done intentionally. If this value were measured against external systems, it\\n    /// could be purposely manipulated by an attacker to withdraw more assets than they otherwise should be able\\n    /// to claim by redeeming their shares.\\n    /// @param shares The amount of shares to compute the equivalent underlying for\\n    /// @return shareValue the value of underlying computed given the `shares` amount of shares given as input\\n    function _shareValue(uint256 shares) internal view returns (uint256 shareValue) {\\n        uint256 totalSupply_ = totalSupply();\\n        // Return price = 1:1 if vault is empty\\n        if (totalSupply_ == 0) return shares;\\n        uint256 freeFunds = _freeFunds();\\n        assembly {\\n            // Overflow check equivalent to require(freeFunds == 0 || shares <= type(uint256).max / freeFunds)\\n            if iszero(iszero(mul(freeFunds, gt(shares, div(not(0), freeFunds))))) { revert(0, 0) }\\n            // shares * freeFunds / totalSupply_\\n            shareValue := div(mul(shares, freeFunds), totalSupply_)\\n        }\\n    }\\n\\n    /// @notice Determines how many shares `amount` of underlying asset would receive\\n    /// @param amount The amount to compute the equivalent shares for\\n    /// @return shares the shares computed given the amount\\n    function _sharesForAmount(uint256 amount) internal view returns (uint256 shares) {\\n        uint256 freeFunds = _freeFunds();\\n        assembly {\\n            //if (freeFunds != 0) return (amount * totalSupply()) / freeFunds;\\n            if gt(freeFunds, 0) {\\n                let totalSupply_ := sload(0x05345cdf77eb68f44c) // load data from `_TOTAL_SUPPLY_SLOT`\\n\\n                // Overflow check equivalent to require(totalSupply_ == 0 || amount <= type(uint256).max / totalSupply_)\\n                if iszero(iszero(mul(totalSupply_, gt(amount, div(not(0), totalSupply_))))) { revert(0, 0) }\\n                // amount * totalSupply() / freeFunds\\n                shares := div(mul(amount, totalSupply_), freeFunds)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/helpers/VaultTypes.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.19;\\n\\n/// @notice Stores all data from a single strategy\\n/// @dev Packed in two slots\\nstruct StrategyData {\\n    /// Slot 0\\n    /// @notice Maximum percentage available to be lent to strategies(in BPS)\\n    /// @dev in BPS. uint16 is enough to cover the max BPS value of 10_000\\n    uint16 strategyDebtRatio;\\n    /// @notice The performance fee\\n    /// @dev in BPS. uint16 is enough to cover the max BPS value of 10_000\\n    uint16 strategyPerformanceFee;\\n    /// @notice Timestamp when the strategy was added.\\n    /// @dev Overflowing July 21, 2554\\n    uint48 strategyActivation;\\n    /// @notice block.timestamp of the last time a report occured\\n    /// @dev Overflowing July 21, 2554\\n    uint48 strategyLastReport;\\n    /// @notice Upper limit on the increase of debt since last harvest\\n    /// @dev max debt per harvest to be set to a maximum value of 4,722,366,482,869,645,213,695\\n    uint128 strategyMaxDebtPerHarvest;\\n    /// Slot 1\\n    /// @notice Lower limit on the increase of debt since last harvest\\n    /// @dev min debt per harvest to be set to a maximum value of 16,777,215\\n    uint128 strategyMinDebtPerHarvest;\\n    /// @notice Total returns that Strategy has realized for Vault\\n    /// @dev max strategy total gain of 79,228,162,514,264,337,593,543,950,335\\n    uint128 strategyTotalGain;\\n    /// Slot 2\\n    /// @notice Total outstanding debt that Strategy has\\n    /// @dev max total debt of 79,228,162,514,264,337,593,543,950,335\\n    uint128 strategyTotalDebt;\\n    /// @notice Total losses that Strategy has realized for Vault\\n    /// @dev max strategy total loss of 79,228,162,514,264,337,593,543,950,335\\n    uint128 strategyTotalLoss;\\n}\\n\"\r\n    },\r\n    \"src/lib/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple ERC20 + EIP-2612 implementation.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\\n///\\n/// @dev Note:\\n/// The ERC20 standard allows minting and transferring to and from the zero address,\\n/// minting and transferring zero tokens, as well as self-approvals.\\n/// For performance, this implementation WILL NOT revert for such actions.\\n/// Please add any checks with overrides if desired.\\n\\nlibrary StringPacker { // This library is used to pack and unpack strings into bytes32. This is used to store the name and symbol of the token in the contract.\\n    function pack(string memory unpacked) internal pure returns (bytes32 packed) {\\n        require(bytes(unpacked).length < 32);\\n        assembly {\\n            packed := mload(add(unpacked, 31))\\n        }\\n    }\\n\\n    function unpack(bytes32 packed) internal pure returns (string memory unpacked) {\\n        uint256 l = uint256(packed >> 248);\\n        require(l < 32);\\n        unpacked = string(new bytes (l));\\n        assembly {\\n            mstore(add(unpacked, 31), packed) // Potentially writes into unallocated memory, which is fine\\n        }\\n    }\\n}\\n\\nabstract contract ERC20 {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The total supply has overflowed.\\n    error TotalSupplyOverflow();\\n\\n    /// @dev The allowance has overflowed.\\n    error AllowanceOverflow();\\n\\n    /// @dev The allowance has underflowed.\\n    error AllowanceUnderflow();\\n\\n    /// @dev Insufficient balance.\\n    error InsufficientBalance();\\n\\n    /// @dev Insufficient allowance.\\n    error InsufficientAllowance();\\n\\n    /// @dev The permit is invalid.\\n    error InvalidPermit();\\n\\n    /// @dev The permit has expired.\\n    error PermitExpired();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The storage slot for the total supply.\\n    uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;\\n\\n    /// @dev The balance slot of `owner` is given by:\\n    /// ```\\n    ///     mstore(0x0c, _BALANCE_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let balanceSlot := keccak256(0x0c, 0x20)\\n    /// ```\\n    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;\\n\\n    /// @dev The allowance slot of (`owner`, `spender`) is given by:\\n    /// ```\\n    ///     mstore(0x20, spender)\\n    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\\n    /// ```\\n    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\\n\\n    /// @dev The nonce slot of `owner` is given by:\\n    /// ```\\n    ///     mstore(0x0c, _NONCES_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let nonceSlot := keccak256(0x0c, 0x20)\\n    /// ```\\n    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;\\n\\n    ////////////////////////////////////////////////////////////////\\n    ///                     METADATA STORAGE                     ///\\n    ////////////////////////////////////////////////////////////////\\n\\n    bytes32 private immutable name_; // added immutable variables to name, symbol, decimals\\n\\n    bytes32 private immutable symbol_;\\n\\n    uint256 public immutable decimals;\\n\\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) {\\n        name_ = StringPacker.pack(_name);\\n        symbol_ = StringPacker.pack(_symbol);\\n        decimals = _decimals;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ERC20 METADATA                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the name of the token.\\n    function name() public view returns (string memory) {\\n        return StringPacker.unpack(name_);\\n    }\\n\\n    /// @dev Returns the symbol of the token.\\n    function symbol() public view returns (string memory) {\\n        return StringPacker.unpack(symbol_);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           ERC20                            */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the amount of tokens in existence.\\n    function totalSupply() public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(_TOTAL_SUPPLY_SLOT)\\n        }\\n    }\\n\\n    /// @dev Returns the amount of tokens owned by `owner`.\\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\\n    function allowance(address owner, address spender) public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x34))\\n        }\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    ///\\n    /// Emits a {Approval} event.\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and store the amount.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x34), amount)\\n            // Emit the {Approval} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\\n        }\\n        return true;\\n    }\\n\\n    /// @dev Atomically increases the allowance granted to `spender` by the caller.\\n    ///\\n    /// Emits a {Approval} event.\\n    function increaseAllowance(address spender, uint256 difference) public virtual returns (bool) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and load its value.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            let allowanceSlot := keccak256(0x0c, 0x34)\\n            let allowanceBefore := sload(allowanceSlot)\\n            // Add to the allowance.\\n            let allowanceAfter := add(allowanceBefore, difference)\\n            // Revert upon overflow.\\n            if lt(allowanceAfter, allowanceBefore) {\\n                mstore(0x00, 0xf9067066) // `AllowanceOverflow()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Store the updated allowance.\\n            sstore(allowanceSlot, allowanceAfter)\\n            // Emit the {Approval} event.\\n            mstore(0x00, allowanceAfter)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\\n        }\\n        return true;\\n    }\\n\\n    /// @dev Atomically decreases the allowance granted to `spender` by the caller.\\n    ///\\n    /// Emits a {Approval} event.\\n    function decreaseAllowance(address spender, uint256 difference) public virtual returns (bool) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and load its value.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            let allowanceSlot := keccak256(0x0c, 0x34)\\n            let allowanceBefore := sload(allowanceSlot)\\n            // Revert if will underflow.\\n            if lt(allowanceBefore, difference) {\\n                mstore(0x00, 0x8301ab38) // `AllowanceUnderflow()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated allowance.\\n            let allowanceAfter := sub(allowanceBefore, difference)\\n            sstore(allowanceSlot, allowanceAfter)\\n            // Emit the {Approval} event.\\n            mstore(0x00, allowanceAfter)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\\n        }\\n        return true;\\n    }\\n\\n    /// @dev Transfer `amount` tokens from the caller to `to`.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        _beforeTokenTransfer(msg.sender, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    /// @dev Transfers `amount` tokens from `from` to `to`.\\n    ///\\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\\n        _beforeTokenTransfer(from, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let from_ := shl(96, from)\\n            // Compute the allowance slot and load its value.\\n            mstore(0x20, caller())\\n            mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\\n            let allowanceSlot := keccak256(0x0c, 0x34)\\n            let allowance_ := sload(allowanceSlot)\\n            // If the allowance is not the maximum uint256 value.\\n            if iszero(eq(allowance_, not(0))) {\\n                // Revert if the amount to be transferred exceeds the allowance.\\n                if gt(amount, allowance_) {\\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated allowance.\\n                sstore(allowanceSlot, sub(allowance_, amount))\\n            }\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  INTERNAL MINT FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _mint(address to, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(address(0), to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\\n            // Revert if the total supply overflows.\\n            if lt(totalSupplyAfter, totalSupplyBefore) {\\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Store the updated total supply.\\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(address(0), to, amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  INTERNAL BURN FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _burn(address from, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(from, address(0), amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, from)\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Subtract and store the updated total supply.\\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\\n        }\\n        _afterTokenTransfer(from, address(0), amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Moves `amount` of tokens from `from` to `to`.\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(from, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let from_ := shl(96, from)\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                INTERNAL ALLOWANCE FUNCTIONS                */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and load its value.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            let allowanceSlot := keccak256(0x0c, 0x34)\\n            let allowance_ := sload(allowanceSlot)\\n            // If the allowance is not the maximum uint256 value.\\n            if iszero(eq(allowance_, not(0))) {\\n                // Revert if the amount to be transferred exceeds the allowance.\\n                if gt(amount, allowance_) {\\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated allowance.\\n                sstore(allowanceSlot, sub(allowance_, amount))\\n            }\\n        }\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\\n    ///\\n    /// Emits a {Approval} event.\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let owner_ := shl(96, owner)\\n            // Compute the allowance slot and store the amount.\\n            mstore(0x20, spender)\\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\\n            sstore(keccak256(0x0c, 0x34), amount)\\n            // Emit the {Approval} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     HOOKS TO OVERRIDE                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Hook that is called before any transfer of tokens.\\n    /// This includes minting and burning.\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /// @dev Hook that is called after any transfer of tokens.\\n    /// This includes minting and burning.\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"src/lib/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.19;\\n\\n//Efficient Solidity & assembly version of ReentrancyGuard\\nabstract contract ReentrancyGuard {\\n    error ReentrantCall();\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n\\n    uint256 private _status = 1;\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        assembly {\\n            if eq(sload(_status.slot), 2) {\\n                mstore(0x00, 0x37ed32e8) // ReentrantCall() selector\\n                revert(0x1c, 0x04)\\n            }\\n            sstore(_status.slot, 0x02)\\n        }\\n        _;\\n        assembly {\\n            sstore(_status.slot, 0x01)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.19;\\n\\nimport {StrategyData} from \\\"../helpers/VaultTypes.sol\\\";\\n\\ninterface IStrategy {\\n    /// Roles\\n    function grantRoles(address user, uint256 roles) external payable;\\n\\n    function revokeRoles(address user, uint256 roles) external payable;\\n\\n    function renounceRoles(uint256 roles) external payable;\\n\\n    function harvest(uint256 minExpectedBalance, uint256 minOutputAfterInvestment) external;\\n\\n    function setEmergencyExit(uint256 _emergencyExit) external;\\n\\n    function setStrategist(address _newStrategist) external;\\n\\n    function vault() external returns (address);\\n\\n    function underlyingAsset() external returns (address);\\n\\n    function emergencyExit() external returns (uint256);\\n\\n    function withdraw(uint256 amountNeeded) external returns (uint256);\\n\\n    function delegatedAssets() external view returns (uint256);\\n\\n    function estimatedTotalAssets() external view returns (uint256);\\n\\n    function strategist() external view returns (address);\\n\\n    function strategyName() external view returns (bytes32);\\n\\n    function isActive() external view returns (bool);\\n\\n    /// View roles\\n    function hasAnyRole(address user, uint256 roles) external view returns (bool result);\\n\\n    function hasAllRoles(address user, uint256 roles) external view returns (bool result);\\n\\n    function rolesOf(address user) external view returns (uint256 roles);\\n\\n    function rolesFromOrdinals(uint8[] memory ordinals) external pure returns (uint256 roles);\\n\\n    function ordinalsFromRoles(uint256 roles) external pure returns (uint8[] memory ordinals);\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/auth/OwnableRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {Ownable} from \\\"./Ownable.sol\\\";\\n\\n/// @notice Simple single owner and multiroles authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n/// @dev While the ownable portion follows [EIP-173](https://eips.ethereum.org/EIPS/eip-173)\\n/// for compatibility, the nomenclature for the 2-step ownership handover and roles\\n/// may be unique to this codebase.\\nabstract contract OwnableRoles is Ownable { \\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The `user`'s roles is updated to `roles`.\\n    /// Each bit of `roles` represents whether the role is set.\\n    event RolesUpdated(address indexed user, uint256 indexed roles);\\n\\n    /// @dev `keccak256(bytes(\\\"RolesUpdated(address,uint256)\\\"))`.\\n    uint256 private constant _ROLES_UPDATED_EVENT_SIGNATURE =\\n        0x715ad5ce61fc9595c7b415289d59cf203f23a94fa06f04af7e489a0a76e1fe26;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The role slot of `user` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _ROLE_SLOT_SEED))\\n    ///     let roleSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// This automatically ignores the upper bits of the `user` in case\\n    /// they are not clean, as well as keep the `keccak256` under 32-bytes.\\n    ///\\n    /// Note: This is equal to `_OWNER_SLOT_NOT` in for gas efficiency.\\n    uint256 private constant _ROLE_SLOT_SEED = 0x8b78c6d8;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Grants the roles directly without authorization guard.\\n    /// Each bit of `roles` represents the role to turn on.\\n    function _grantRoles(address user, uint256 roles) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the role slot.\\n            mstore(0x0c, _ROLE_SLOT_SEED)\\n            mstore(0x00, user)\\n            let roleSlot := keccak256(0x0c, 0x20)\\n            // Load the current value and `or` it with `roles`.\\n            roles := or(sload(roleSlot), roles)\\n            // Store the new value.\\n            sstore(roleSlot, roles)\\n            // Emit the {RolesUpdated} event.\\n            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, mload(0x0c)), roles)\\n        }\\n    }\\n\\n    /// @dev Removes the roles directly without authorization guard.\\n    /// Each bit of `roles` represents the role to turn off.\\n    function _removeRoles(address user, uint256 roles) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the role slot.\\n            mstore(0x0c, _ROLE_SLOT_SEED)\\n            mstore(0x00, user)\\n            let roleSlot := keccak256(0x0c, 0x20)\\n            // Load the current value.\\n            let currentRoles := sload(roleSlot)\\n            // Use `and` to compute the intersection of `currentRoles` and `roles`,\\n            // `xor` it with `currentRoles` to flip the bits in the intersection.\\n            roles := xor(currentRoles, and(currentRoles, roles))\\n            // Then, store the new value.\\n            sstore(roleSlot, roles)\\n            // Emit the {RolesUpdated} event.\\n            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, mload(0x0c)), roles)\\n        }\\n    }\\n\\n    /// @dev Throws if the sender does not have any of the `roles`.\\n    function _checkRoles(uint256 roles) internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the role slot.\\n            mstore(0x0c, _ROLE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            // Load the stored value, and if the `and` intersection\\n            // of the value and `roles` is zero, revert.\\n            if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Throws if the sender is not the owner,\\n    /// and does not have any of the `roles`.\\n    /// Checks for ownership first, then lazily checks for roles.\\n    function _checkOwnerOrRoles(uint256 roles) internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the caller is not the stored owner.\\n            // Note: `_ROLE_SLOT_SEED` is equal to `_OWNER_SLOT_NOT`.\\n            if iszero(eq(caller(), sload(not(_ROLE_SLOT_SEED)))) {\\n                // Compute the role slot.\\n                mstore(0x0c, _ROLE_SLOT_SEED)\\n                mstore(0x00, caller())\\n                // Load the stored value, and if the `and` intersection\\n                // of the value and `roles` is zero, revert.\\n                if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {\\n                    mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Throws if the sender does not have any of the `roles`,\\n    /// and is not the owner.\\n    /// Checks for roles first, then lazily checks for ownership.\\n    function _checkRolesOrOwner(uint256 roles) internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the role slot.\\n            mstore(0x0c, _ROLE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            // Load the stored value, and if the `and` intersection\\n            // of the value and `roles` is zero, revert.\\n            if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {\\n                // If the caller is not the stored owner.\\n                // Note: `_ROLE_SLOT_SEED` is equal to `_OWNER_SLOT_NOT`.\\n                if iszero(eq(caller(), sload(not(_ROLE_SLOT_SEED)))) {\\n                    mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Allows the owner to grant `user` `roles`.\\n    /// If the `user` already has a role, then it will be an no-op for the role.\\n    function grantRoles(address user, uint256 roles) public payable virtual onlyOwner {\\n        _grantRoles(user, roles);\\n    }\\n\\n    /// @dev Allows the owner to remove `user` `roles`.\\n    /// If the `user` does not have a role, then it will be an no-op for the role.\\n    function revokeRoles(address user, uint256 roles) public payable virtual onlyOwner {\\n        _removeRoles(user, roles);\\n    }\\n\\n    /// @dev Allow the caller to remove their own roles.\\n    /// If the caller does not have a role, then it will be an no-op for the role.\\n    function renounceRoles(uint256 roles) public payable virtual {\\n        _removeRoles(msg.sender, roles);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns whether `user` has any of `roles`.\\n    function hasAnyRole(address user, uint256 roles) public view virtual returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the role slot.\\n            mstore(0x0c, _ROLE_SLOT_SEED)\\n            mstore(0x00, user)\\n            // Load the stored value, and set the result to whether the\\n            // `and` intersection of the value and `roles` is not zero.\\n            result := iszero(iszero(and(sload(keccak256(0x0c, 0x20)), roles)))\\n        }\\n    }\\n\\n    /// @dev Returns whether `user` has all of `roles`.\\n    function hasAllRoles(address user, uint256 roles) public view virtual returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the role slot.\\n            mstore(0x0c, _ROLE_SLOT_SEED)\\n            mstore(0x00, user)\\n            // Whether the stored value is contains all the set bits in `roles`.\\n            result := eq(and(sload(keccak256(0x0c, 0x20)), roles), roles)\\n        }\\n    }\\n\\n    /// @dev Returns the roles of `user`.\\n    function rolesOf(address user) public view virtual returns (uint256 roles) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the role slot.\\n            mstore(0x0c, _ROLE_SLOT_SEED)\\n            mstore(0x00, user)\\n            // Load the stored value.\\n            roles := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Convenience function to return a `roles` bitmap from an array of `ordinals`.\\n    /// This is meant for frontends like Etherscan, and is therefore not fully optimized.\\n    /// Not recommended to be called on-chain.\\n    function rolesFromOrdinals(uint8[] memory ordinals) public pure returns (uint256 roles) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let i := shl(5, mload(ordinals)) } i { i := sub(i, 0x20) } {\\n                // We don't need to mask the values of `ordinals`, as Solidity\\n                // cleans dirty upper bits when storing variables into memory.\\n                roles := or(shl(mload(add(ordinals, i)), 1), roles)\\n            }\\n        }\\n    }\\n\\n    /// @dev Convenience function to return an array of `ordinals` from the `roles` bitmap.\\n    /// This is meant for frontends like Etherscan, and is therefore not fully optimized.\\n    /// Not recommended to be called on-chain.\\n    function ordinalsFromRoles(uint256 roles) public pure returns (uint8[] memory ordinals) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the pointer to the free memory.\\n            ordinals := mload(0x40)\\n            let ptr := add(ordinals, 0x20)\\n            let o := 0\\n            // The absence of lookup tables, De Bruijn, etc., here is intentional for\\n            // smaller bytecode, as this function is not meant to be called on-chain.\\n            for { let t := roles } 1 {} {\\n                mstore(ptr, o)\\n                // `shr` 5 is equivalent to multiplying by 0x20.\\n                // Push back into the ordinals array if the bit is set.\\n                ptr := add(ptr, shl(5, and(t, 1)))\\n                o := add(o, 1)\\n                t := shr(o, roles)\\n                if iszero(t) { break }\\n            }\\n            // Store the length of `ordinals`.\\n            mstore(ordinals, shr(5, sub(ptr, add(ordinals, 0x20))))\\n            // Allocate the memory.\\n            mstore(0x40, ptr)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Marks a function as only callable by an account with `roles`.\\n    modifier onlyRoles(uint256 roles) virtual {\\n        _checkRoles(roles);\\n        _;\\n    }\\n\\n    /// @dev Marks a function as only callable by the owner or by an account\\n    /// with `roles`. Checks for ownership first, then lazily checks for roles.\\n    modifier onlyOwnerOrRoles(uint256 roles) virtual {\\n        _checkOwnerOrRoles(roles);\\n        _;\\n    }\\n\\n    /// @dev Marks a function as only callable by an account with `roles`\\n    /// or the owner. Checks for roles first, then lazily checks for ownership.\\n    modifier onlyRolesOrOwner(uint256 roles) virtual {\\n        _checkRolesOrOwner(roles);\\n        _;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ROLE CONSTANTS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // IYKYK\\n\\n    uint256 internal constant _ROLE_0 = 1 << 0;\\n    uint256 internal constant _ROLE_1 = 1 << 1;\\n    uint256 internal constant _ROLE_2 = 1 << 2;\\n    uint256 internal constant _ROLE_3 = 1 << 3;\\n    uint256 internal constant _ROLE_4 = 1 << 4;\\n    uint256 internal constant _ROLE_5 = 1 << 5;\\n    uint256 internal constant _ROLE_6 = 1 << 6;\\n    uint256 internal constant _ROLE_7 = 1 << 7;\\n    uint256 internal constant _ROLE_8 = 1 << 8;\\n    uint256 internal constant _ROLE_9 = 1 << 9;\\n    uint256 internal constant _ROLE_10 = 1 << 10;\\n    uint256 internal constant _ROLE_11 = 1 << 11;\\n    uint256 internal constant _ROLE_12 = 1 << 12;\\n    uint256 internal constant _ROLE_13 = 1 << 13;\\n    uint256 internal constant _ROLE_14 = 1 << 14;\\n    uint256 internal constant _ROLE_15 = 1 << 15;\\n    uint256 internal constant _ROLE_16 = 1 << 16;\\n    uint256 internal constant _ROLE_17 = 1 << 17;\\n    uint256 internal constant _ROLE_18 = 1 << 18;\\n    uint256 internal constant _ROLE_19 = 1 << 19;\\n    uint256 internal constant _ROLE_20 = 1 << 20;\\n    uint256 internal constant _ROLE_21 = 1 << 21;\\n    uint256 internal constant _ROLE_22 = 1 << 22;\\n    uint256 internal constant _ROLE_23 = 1 << 23;\\n    uint256 internal constant _ROLE_24 = 1 << 24;\\n    uint256 internal constant _ROLE_25 = 1 << 25;\\n    uint256 internal constant _ROLE_26 = 1 << 26;\\n    uint256 internal constant _ROLE_27 = 1 << 27;\\n    uint256 internal constant _ROLE_28 = 1 << 28;\\n    uint256 internal constant _ROLE_29 = 1 << 29;\\n    uint256 internal constant _ROLE_30 = 1 << 30;\\n    uint256 internal constant _ROLE_31 = 1 << 31;\\n    uint256 internal constant _ROLE_32 = 1 << 32;\\n    uint256 internal constant _ROLE_33 = 1 << 33;\\n    uint256 internal constant _ROLE_34 = 1 << 34;\\n    uint256 internal constant _ROLE_35 = 1 << 35;\\n    uint256 internal constant _ROLE_36 = 1 << 36;\\n    uint256 internal constant _ROLE_37 = 1 << 37;\\n    uint256 internal constant _ROLE_38 = 1 << 38;\\n    uint256 internal constant _ROLE_39 = 1 << 39;\\n    uint256 internal constant _ROLE_40 = 1 << 40;\\n    uint256 internal constant _ROLE_41 = 1 << 41;\\n    uint256 internal constant _ROLE_42 = 1 << 42;\\n    uint256 internal constant _ROLE_43 = 1 << 43;\\n    uint256 internal constant _ROLE_44 = 1 << 44;\\n    uint256 internal constant _ROLE_45 = 1 << 45;\\n    uint256 internal constant _ROLE_46 = 1 << 46;\\n    uint256 internal constant _ROLE_47 = 1 << 47;\\n    uint256 internal constant _ROLE_48 = 1 << 48;\\n    uint256 internal constant _ROLE_49 = 1 << 49;\\n    uint256 internal constant _ROLE_50 = 1 << 50;\\n    uint256 internal constant _ROLE_51 = 1 << 51;\\n    uint256 internal constant _ROLE_52 = 1 << 52;\\n    uint256 internal constant _ROLE_53 = 1 << 53;\\n    uint256 internal constant _ROLE_54 = 1 << 54;\\n    uint256 internal constant _ROLE_55 = 1 << 55;\\n    uint256 internal constant _ROLE_56 = 1 << 56;\\n    uint256 internal constant _ROLE_57 = 1 << 57;\\n    uint256 internal constant _ROLE_58 = 1 << 58;\\n    uint256 internal constant _ROLE_59 = 1 << 59;\\n    uint256 internal constant _ROLE_60 = 1 << 60;\\n    uint256 internal constant _ROLE_61 = 1 << 61;\\n    uint256 internal constant _ROLE_62 = 1 << 62;\\n    uint256 internal constant _ROLE_63 = 1 << 63;\\n    uint256 internal constant _ROLE_64 = 1 << 64;\\n    uint256 internal constant _ROLE_65 = 1 << 65;\\n    uint256 internal constant _ROLE_66 = 1 << 66;\\n    uint256 internal constant _ROLE_67 = 1 << 67;\\n    uint256 internal constant _ROLE_68 = 1 << 68;\\n    uint256 internal constant _ROLE_69 = 1 << 69;\\n    uint256 internal constant _ROLE_70 = 1 << 70;\\n    uint256 internal constant _ROLE_71 = 1 << 71;\\n    uint256 internal constant _ROLE_72 = 1 << 72;\\n    uint256 internal constant _ROLE_73 = 1 << 73;\\n    uint256 internal constant _ROLE_74 = 1 << 74;\\n    uint256 internal constant _ROLE_75 = 1 << 75;\\n    uint256 internal constant _ROLE_76 = 1 << 76;\\n    uint256 internal constant _ROLE_77 = 1 << 77;\\n    uint256 internal constant _ROLE_78 = 1 << 78;\\n    uint256 internal constant _ROLE_79 = 1 << 79;\\n    uint256 internal constant _ROLE_80 = 1 << 80;\\n    uint256 internal constant _ROLE_81 = 1 << 81;\\n    uint256 internal constant _ROLE_82 = 1 << 82;\\n    uint256 internal constant _ROLE_83 = 1 << 83;\\n    uint256 internal constant _ROLE_84 = 1 << 84;\\n    uint256 internal constant _ROLE_85 = 1 << 85;\\n    uint256 internal constant _ROLE_86 = 1 << 86;\\n    uint256 internal constant _ROLE_87 = 1 << 87;\\n    uint256 internal constant _ROLE_88 = 1 << 88;\\n    uint256 internal constant _ROLE_89 = 1 << 89;\\n    uint256 internal constant _ROLE_90 = 1 << 90;\\n    uint256 internal constant _ROLE_91 = 1 << 91;\\n    uint256 internal constant _ROLE_92 = 1 << 92;\\n    uint256 internal constant _ROLE_93 = 1 << 93;\\n    uint256 internal constant _ROLE_94 = 1 << 94;\\n    uint256 internal constant _ROLE_95 = 1 << 95;\\n    uint256 internal constant _ROLE_96 = 1 << 96;\\n    uint256 internal constant _ROLE_97 = 1 << 97;\\n    uint256 internal constant _ROLE_98 = 1 << 98;\\n    uint256 internal constant _ROLE_99 = 1 << 99;\\n    uint256 internal constant _ROLE_100 = 1 << 100;\\n    uint256 internal constant _ROLE_101 = 1 << 101;\\n    uint256 internal constant _ROLE_102 = 1 << 102;\\n    uint256 internal constant _ROLE_103 = 1 << 103;\\n    uint256 internal constant _ROLE_104 = 1 << 104;\\n    uint256 internal constant _ROLE_105 = 1 << 105;\\n    uint256 internal constant _ROLE_106 = 1 << 106;\\n    uint256 internal constant _ROLE_107 = 1 << 107;\\n    uint256 internal constant _ROLE_108 = 1 << 108;\\n    uint256 internal constant _ROLE_109 = 1 << 109;\\n    uint256 internal constant _ROLE_110 = 1 << 110;\\n    uint256 internal constant _ROLE_111 = 1 << 111;\\n    uint256 internal constant _ROLE_112 = 1 << 112;\\n    uint256 internal constant _ROLE_113 = 1 << 113;\\n    uint256 internal constant _ROLE_114 = 1 << 114;\\n    uint256 internal constant _ROLE_115 = 1 << 115;\\n    uint256 internal constant _ROLE_116 = 1 << 116;\\n    uint256 internal constant _ROLE_117 = 1 << 117;\\n    uint256 internal constant _ROLE_118 = 1 << 118;\\n    uint256 internal constant _ROLE_119 = 1 << 119;\\n    uint256 internal constant _ROLE_120 = 1 << 120;\\n    uint256 internal constant _ROLE_121 = 1 << 121;\\n    uint256 internal constant _ROLE_122 = 1 << 122;\\n    uint256 internal constant _ROLE_123 = 1 << 123;\\n    uint256 internal constant _ROLE_124 = 1 << 124;\\n    uint256 internal constant _ROLE_125 = 1 << 125;\\n    uint256 internal constant _ROLE_126 = 1 << 126;\\n    uint256 internal constant _ROLE_127 = 1 << 127;\\n    uint256 internal constant _ROLE_128 = 1 << 128;\\n    uint256 internal constant _ROLE_129 = 1 << 129;\\n    uint256 internal constant _ROLE_130 = 1 << 130;\\n    uint256 internal constant _ROLE_131 = 1 << 131;\\n    uint256 internal constant _ROLE_132 = 1 << 132;\\n    uint256 internal constant _ROLE_133 = 1 << 133;\\n    uint256 internal constant _ROLE_134 = 1 << 134;\\n    uint256 internal constant _ROLE_135 = 1 << 135;\\n    uint256 internal constant _ROLE_136 = 1 << 136;\\n    uint256 internal constant _ROLE_137 = 1 << 137;\\n    uint256 internal constant _ROLE_138 = 1 << 138;\\n    uint256 internal constant _ROLE_139 = 1 << 139;\\n    uint256 internal constant _ROLE_140 = 1 << 140;\\n    uint256 internal constant _ROLE_141 = 1 << 141;\\n    uint256 internal constant _ROLE_142 = 1 << 142;\\n    uint256 internal constant _ROLE_143 = 1 << 143;\\n    uint256 internal constant _ROLE_144 = 1 << 144;\\n    uint256 internal constant _ROLE_145 = 1 << 145;\\n    uint256 internal constant _ROLE_146 = 1 << 146;\\n    uint256 internal constant _ROLE_147 = 1 << 147;\\n    uint256 internal constant _ROLE_148 = 1 << 148;\\n    uint256 internal constant _ROLE_149 = 1 << 149;\\n    uint256 internal constant _ROLE_150 = 1 << 150;\\n    uint256 internal constant _ROLE_151 = 1 << 151;\\n    uint256 internal constant _ROLE_152 = 1 << 152;\\n    uint256 internal constant _ROLE_153 = 1 << 153;\\n    uint256 internal constant _ROLE_154 = 1 << 154;\\n    uint256 internal constant _ROLE_155 = 1 << 155;\\n    uint256 internal constant _ROLE_156 = 1 << 156;\\n    uint256 internal constant _ROLE_157 = 1 << 157;\\n    uint256 internal constant _ROLE_158 = 1 << 158;\\n    uint256 internal constant _ROLE_159 = 1 << 159;\\n    uint256 internal constant _ROLE_160 = 1 << 160;\\n    uint256 internal constant _ROLE_161 = 1 << 161;\\n    uint256 internal constant _ROLE_162 = 1 << 162;\\n    uint256 internal constant _ROLE_163 = 1 << 163;\\n    uint256 internal constant _ROLE_164 = 1 << 164;\\n    uint256 internal constant _ROLE_165 = 1 << 165;\\n    uint256 internal constant _ROLE_166 = 1 << 166;\\n    uint256 internal constant _ROLE_167 = 1 << 167;\\n    uint256 internal constant _ROLE_168 = 1 << 168;\\n    uint256 internal constant _ROLE_169 = 1 << 169;\\n    uint256 internal constant _ROLE_170 = 1 << 170;\\n    uint256 internal constant _ROLE_171 = 1 << 171;\\n    uint256 internal constant _ROLE_172 = 1 << 172;\\n    uint256 internal constant _ROLE_173 = 1 << 173;\\n    uint256 internal constant _ROLE_174 = 1 << 174;\\n    uint256 internal constant _ROLE_175 = 1 << 175;\\n    uint256 internal constant _ROLE_176 = 1 << 176;\\n    uint256 internal constant _ROLE_177 = 1 << 177;\\n    uint256 internal constant _ROLE_178 = 1 << 178;\\n    uint256 internal constant _ROLE_179 = 1 << 179;\\n    uint256 internal constant _ROLE_180 = 1 << 180;\\n    uint256 internal constant _ROLE_181 = 1 << 181;\\n    uint256 internal constant _ROLE_182 = 1 << 182;\\n    uint256 internal constant _ROLE_183 = 1 << 183;\\n    uint256 internal constant _ROLE_184 = 1 << 184;\\n    uint256 internal constant _ROLE_185 = 1 << 185;\\n    uint256 internal constant _ROLE_186 = 1 << 186;\\n    uint256 internal constant _ROLE_187 = 1 << 187;\\n    uint256 internal constant _ROLE_188 = 1 << 188;\\n    uint256 internal constant _ROLE_189 = 1 << 189;\\n    uint256 internal constant _ROLE_190 = 1 << 190;\\n    uint256 internal constant _ROLE_191 = 1 << 191;\\n    uint256 internal constant _ROLE_192 = 1 << 192;\\n    uint256 internal constant _ROLE_193 = 1 << 193;\\n    uint256 internal constant _ROLE_194 = 1 << 194;\\n    uint256 internal constant _ROLE_195 = 1 << 195;\\n    uint256 internal constant _ROLE_196 = 1 << 196;\\n    uint256 internal constant _ROLE_197 = 1 << 197;\\n    uint256 internal constant _ROLE_198 = 1 << 198;\\n    uint256 internal constant _ROLE_199 = 1 << 199;\\n    uint256 internal constant _ROLE_200 = 1 << 200;\\n    uint256 internal constant _ROLE_201 = 1 << 201;\\n    uint256 internal constant _ROLE_202 = 1 << 202;\\n    uint256 internal constant _ROLE_203 = 1 << 203;\\n    uint256 internal constant _ROLE_204 = 1 << 204;\\n    uint256 internal constant _ROLE_205 = 1 << 205;\\n    uint256 internal constant _ROLE_206 = 1 << 206;\\n    uint256 internal constant _ROLE_207 = 1 << 207;\\n    uint256 internal constant _ROLE_208 = 1 << 208;\\n    uint256 internal constant _ROLE_209 = 1 << 209;\\n    uint256 internal constant _ROLE_210 = 1 << 210;\\n    uint256 internal constant _ROLE_211 = 1 << 211;\\n    uint256 internal constant _ROLE_212 = 1 << 212;\\n    uint256 internal constant _ROLE_213 = 1 << 213;\\n    uint256 internal constant _ROLE_214 = 1 << 214;\\n    uint256 internal constant _ROLE_215 = 1 << 215;\\n    uint256 internal constant _ROLE_216 = 1 << 216;\\n    uint256 internal constant _ROLE_217 = 1 << 217;\\n    uint256 internal constant _ROLE_218 = 1 << 218;\\n    uint256 internal constant _ROLE_219 = 1 << 219;\\n    uint256 internal constant _ROLE_220 = 1 << 220;\\n    uint256 internal constant _ROLE_221 = 1 << 221;\\n    uint256 internal constant _ROLE_222 = 1 << 222;\\n    uint256 internal constant _ROLE_223 = 1 << 223;\\n    uint256 internal constant _ROLE_224 = 1 << 224;\\n    uint256 internal constant _ROLE_225 = 1 << 225;\\n    uint256 internal constant _ROLE_226 = 1 << 226;\\n    uint256 internal constant _ROLE_227 = 1 << 227;\\n    uint256 internal constant _ROLE_228 = 1 << 228;\\n    uint256 internal constant _ROLE_229 = 1 << 229;\\n    uint256 internal constant _ROLE_230 = 1 << 230;\\n    uint256 internal constant _ROLE_231 = 1 << 231;\\n    uint256 internal constant _ROLE_232 = 1 << 232;\\n    uint256 internal constant _ROLE_233 = 1 << 233;\\n    uint256 internal constant _ROLE_234 = 1 << 234;\\n    uint256 internal constant _ROLE_235 = 1 << 235;\\n    uint256 internal constant _ROLE_236 = 1 << 236;\\n    uint256 internal constant _ROLE_237 = 1 << 237;\\n    uint256 internal constant _ROLE_238 = 1 << 238;\\n    uint256 internal constant _ROLE_239 = 1 << 239;\\n    uint256 internal constant _ROLE_240 = 1 << 240;\\n    uint256 internal constant _ROLE_241 = 1 << 241;\\n    uint256 internal constant _ROLE_242 = 1 << 242;\\n    uint256 internal constant _ROLE_243 = 1 << 243;\\n    uint256 internal constant _ROLE_244 = 1 << 244;\\n    uint256 internal constant _ROLE_245 = 1 << 245;\\n    uint256 internal constant _ROLE_246 = 1 << 246;\\n    uint256 internal constant _ROLE_247 = 1 << 247;\\n    uint256 internal constant _ROLE_248 = 1 << 248;\\n    uint256 internal constant _ROLE_249 = 1 << 249;\\n    uint256 internal constant _ROLE_250 = 1 << 250;\\n    uint256 internal constant _ROLE_251 = 1 << 251;\\n    uint256 internal constant _ROLE_252 = 1 << 252;\\n    uint256 internal constant _ROLE_253 = 1 << 253;\\n    uint256 internal constant _ROLE_254 = 1 << 254;\\n    uint256 internal constant _ROLE_255 = 1 << 255;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\r\\n *\\r\\n * _Available since v4.1._\\r\\n */\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the decimals places of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solady/src/utils/FixedPointMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\nlibrary FixedPointMathLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\\n    error ExpOverflow();\\n\\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\\n    error FactorialOverflow();\\n\\n    /// @dev The operation failed, due to an multiplication overflow.\\n    error MulWadFailed();\\n\\n    /// @dev The operation failed, either due to a\\n    /// multiplication overflow, or a division by a zero.\\n    error DivWadFailed();\\n\\n    /// @dev The multiply-divide operation failed, either due to a\\n    /// multiplication overflow, or a division by a zero.\\n    error MulDivFailed();\\n\\n    /// @dev The division failed, as the denominator is zero.\\n    error DivFailed();\\n\\n    /// @dev The full precision multiply-divide operation failed, either due\\n    /// to the result being larger than 256 bits, or a division by a zero.\\n    error FullMulDivFailed();\\n\\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\\n    error LnWadUndefined();\\n\\n    /// @dev The output is undefined, as the input is zero.\\n    error Log2Undefined();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The scalar of ETH and most ERC20s.\\n    uint256 internal constant WAD = 1e18;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n            if mul(y, gt(x, div(not(0), y))) {\\n                // Store the function selector of `MulWadFailed()`.\\n                mstore(0x00, 0xbac65e5b)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, y), WAD)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n            if mul(y, gt(x, div(not(0), y))) {\\n                // Store the function selector of `MulWadFailed()`.\\n                mstore(0x00, 0xbac65e5b)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\\n                // Store the function selector of `DivWadFailed()`.\\n                mstore(0x00, 0x7c5f487d)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, WAD), y)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\\n                // Store the function selector of `DivWadFailed()`.\\n                mstore(0x00, 0x7c5f487d)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `x` to the power of `y`.\\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\\n        // Using `ln(x)` means `x` must be greater than 0.\\n        return expWad((lnWad(x) * y) / int256(WAD));\\n    }\\n\\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\\n    function expWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            // When the result is < 0.5 we return zero. This happens when\\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\\n            if (x <= -42139678854452767551) return r;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\\n                // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\\n                if iszero(slt(x, 135305999368893231589)) {\\n                    // Store the function selector of `ExpOverflow()`.\\n                    mstore(0x00, 0xa37bfec9)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n\\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\\n            // for more intermediate precision and a binary basis. This base conversion\\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n            x = (x << 78) / 5 ** 18;\\n\\n            // Reduce range of x to (-\u00bd ln 2, \u00bd ln 2) * 2**96 by factoring out powers\\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\\n            x = x - k * 54916777467707473351141471128;\\n\\n            // k is in the range [-61, 195].\\n\\n            // Evaluate using a (6, 7)-term rational approximation.\\n            // p is made monic, we'll multiply by a scale factor later.\\n            int256 y = x + 1346386616545796478920950773328;\\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n            int256 p = y + x - 94201549194550492254356042504812;\\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n            p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            int256 q = x - 2855989394907223263936484059900;\\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\\n                // No scaling is necessary because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r should be in the range (0.09, 0.25) * 2**96.\\n\\n            // We now need to multiply r by:\\n            // * the scale factor s = ~6.031367120.\\n            // * the 2**k factor from the range reduction.\\n            // * the 1e18 / 2**96 factor for base conversion.\\n            // We do this all at once, with an intermediate result in 2**213\\n            // basis, so the final right shift is always by a positive amount.\\n            r = int256(\\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\\n            );\\n        }\\n    }\\n\\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\\n    function lnWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                if iszero(sgt(x, 0)) {\\n                    // Store the function selector of `LnWadUndefined()`.\\n                    mstore(0x00, 0x1615e638)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n\\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\\n            // We do this by multiplying by 2**96 / 10**18. But since\\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\\n            // and add ln(2**96 / 10**18) at the end.\\n\\n            // Compute k = log2(x) - 96.\\n            int256 k;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let v := x\\n                k := shl(7, lt(0xffffffffffffffffffffffffffffffff, v))\\n                k := or(k, shl(6, lt(0xffffffffffffffff, shr(k, v))))\\n                k := or(k, shl(5, lt(0xffffffff, shr(k, v))))\\n\\n                // For the remaining 32 bits, use a De Bruijn lookup.\\n                // See: https://graphics.stanford.edu/~seander/bithacks.html\\n                v := shr(k, v)\\n                v := or(v, shr(1, v))\\n                v := or(v, shr(2, v))\\n                v := or(v, shr(4, v))\\n                v := or(v, shr(8, v))\\n                v := or(v, shr(16, v))\\n\\n                // forgefmt: disable-next-item\\n                k := sub(or(k, byte(shr(251, mul(v, shl(224, 0x07c4acdd))),\\n                    0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f)), 96)\\n            }\\n\\n            // Reduce range of x to (1, 2) * 2**96\\n            // ln(2^k * x) = k * ln(2) + ln(x)\\n            x <<= uint256(159 - k);\\n            x = int256(uint256(x) >> 159);\\n\\n            // Evaluate using a (8, 8)-term rational approximation.\\n            // p is made monic, we will multiply by a scale factor later.\\n            int256 p = x + 3273285459638523848632254066296;\\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\\n            p = p * x - (795164235651350426258249787498 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            // q is monic by convention.\\n            int256 q = x + 5573035233440673466300451813936;\\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial is known not to have zeros in the domain.\\n                // No scaling required because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r is in the range (0, 0.125) * 2**96\\n\\n            // Finalization, we need to:\\n            // * multiply by the scale factor s = 5.549\u2026\\n            // * add ln(2**96 / 10**18)\\n            // * add k * ln(2)\\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\\n\\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\\n            r *= 1677202110996718588342820967067443963516166;\\n            // add ln(2) * k * 5e18 * 2**192\\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\\n            // base conversion: mul 2**18 / 2**192\\n            r >>= 174;\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  GENERAL NUMBER UTILITIES                  */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Calculates `floor(a * b / d)` with full precision.\\n    /// Throws if result overflows a uint256 or when `d` is zero.\\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/21/muldiv\\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            for {} 1 {} {\\n                // 512-bit multiply `[prod1 prod0] = x * y`.\\n                // Compute the product mod `2**256` and mod `2**256 - 1`\\n                // then use the Chinese Remainder Theorem to reconstruct\\n                // the 512 bit result. The result is stored in two 256\\n                // variables such that `product = prod1 * 2**256 + prod0`.\\n\\n                // Least significant 256 bits of the product.\\n                let prod0 := mul(x, y)\\n                let mm := mulmod(x, y, not(0))\\n                // Most significant 256 bits of the product.\\n                let prod1 := sub(mm, add(prod0, lt(mm, prod0)))\\n\\n                // Handle non-overflow cases, 256 by 256 division.\\n                if iszero(prod1) {\\n                    if iszero(d) {\\n                        // Store the function selector of `FullMulDivFailed()`.\\n                        mstore(0x00, 0xae47f702)\\n                        // Revert with (offset, size).\\n                        revert(0x1c, 0x04)\\n                    }\\n                    result := div(prod0, d)\\n                    break       \\n                }\\n\\n                // Make sure the result is less than `2**256`.\\n                // Also prevents `d == 0`.\\n                if iszero(gt(d, prod1)) {\\n                    // Store the function selector of `FullMulDivFailed()`.\\n                    mstore(0x00, 0xae47f702)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n\\n                ///////////////////////////////////////////////\\n                // 512 by 256 division.\\n                ///////////////////////////////////////////////\\n\\n                // Make division exact by subtracting the remainder from `[prod1 prod0]`.\\n                // Compute remainder using mulmod.\\n                let remainder := mulmod(x, y, d)\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n                // Factor powers of two out of `d`.\\n                // Compute largest power of two divisor of `d`.\\n                // Always greater or equal to 1.\\n                let twos := and(d, sub(0, d))\\n                // Divide d by power of two.\\n                d := div(d, twos)\\n                // Divide [prod1 prod0] by the factors of two.\\n                prod0 := div(prod0, twos)\\n                // Shift in bits from `prod1` into `prod0`. For this we need\\n                // to flip `twos` such that it is `2**256 / twos`.\\n                // If `twos` is zero, then it becomes one.\\n                prod0 := or(prod0, mul(prod1, add(div(sub(0, twos), twos), 1)))\\n                // Invert `d mod 2**256`\\n                // Now that `d` is an odd number, it has an inverse\\n                // modulo `2**256` such that `d * inv = 1 mod 2**256`.\\n                // Compute the inverse by starting with a seed that is correct\\n                // correct for four bits. That is, `d * inv = 1 mod 2**4`.\\n                let inv := xor(mul(3, d), 2)\\n                // Now use Newton-Raphson iteration to improve the precision.\\n                // Thanks to Hensel's lifting lemma, this also works in modular\\n                // arithmetic, doubling the correct bits in each step.\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\\n                result := mul(prod0, mul(inv, sub(2, mul(d, inv)))) // inverse mod 2**256\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\\n    /// Throws if result overflows a uint256 or when `d` is zero.\\n    /// Credit to Uniswap-v3-core under MIT license:\\n    /// https://github.com/Uniswap/v3-core/blob/contracts/libraries/FullMath.sol\\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\\n        result = fullMulDiv(x, y, d);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mulmod(x, y, d) {\\n                if iszero(add(result, 1)) {\\n                    // Store the function selector of `FullMulDivFailed()`.\\n                    mstore(0x00, 0xae47f702)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n                result := add(result, 1)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns `floor(x * y / d)`.\\n    /// Reverts if `x * y` overflows, or `d` is zero.\\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\\n                // Store the function selector of `MulDivFailed()`.\\n                mstore(0x00, 0xad251c27)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, y), d)\\n        }\\n    }\\n\\n    /// @dev Returns `ceil(x * y / d)`.\\n    /// Reverts if `x * y` overflows, or `d` is zero.\\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\\n                // Store the function selector of `MulDivFailed()`.\\n                mstore(0x00, 0xad251c27)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, y), d))), div(mul(x, y), d))\\n        }\\n    }\\n\\n    /// @dev Returns `ceil(x / d)`.\\n    /// Reverts if `d` is zero.\\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(d) {\\n                // Store the function selector of `DivFailed()`.\\n                mstore(0x00, 0x65244e4e)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\\n        }\\n    }\\n\\n    /// @dev Returns `max(0, x - y)`.\\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(gt(x, y), sub(x, y))\\n        }\\n    }\\n\\n    /// @dev Returns the square root of `x`.\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // Let `y = x / 2**r`.\\n            // We check `y >= 2**(k + 8)` but shift right by `k` bits\\n            // each branch to ensure that if `x >= 256`, then `y >= 256`.\\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\\n            z := shl(shr(1, r), z)\\n\\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\\n\\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\\n\\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\\n\\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\\n            // Then we can estimate `sqrt(y)` using\\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\\n\\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If `x+1` is a perfect square, the Babylonian method cycles between\\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    /// @dev Returns the cube root of `x`.\\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/utils/Math.vy\\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n\\n            z := shl(add(div(r, 3), lt(0xf, shr(r, x))), 0xff)\\n            z := div(z, byte(mod(r, 3), shl(232, 0x7f624b)))\\n\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n\\n            z := sub(z, lt(div(x, mul(z, z)), z))\\n        }\\n    }\\n\\n    /// @dev Returns the factorial of `x`.\\n    function factorial(uint256 x) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(lt(x, 58)) {\\n                // Store the function selector of `FactorialOverflow()`.\\n                mstore(0x00, 0xaba0f2a2)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            for { result := 1 } x {} {\\n                result := mul(result, x)\\n                x := sub(x, 1)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the log2 of `x`.\\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(x) {\\n                // Store the function selector of `Log2Undefined()`.\\n                mstore(0x00, 0x5be3aa5c)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n\\n            // For the remaining 32 bits, use a De Bruijn lookup.\\n            // See: https://graphics.stanford.edu/~seander/bithacks.html\\n            x := shr(r, x)\\n            x := or(x, shr(1, x))\\n            x := or(x, shr(2, x))\\n            x := or(x, shr(4, x))\\n            x := or(x, shr(8, x))\\n            x := or(x, shr(16, x))\\n\\n            // forgefmt: disable-next-item\\n            r := or(r, byte(shr(251, mul(x, shl(224, 0x07c4acdd))),\\n                0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f))\\n        }\\n    }\\n\\n    /// @dev Returns the log2 of `x`, rounded up.\\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\\n        unchecked {\\n            uint256 isNotPo2;\\n            assembly {\\n                isNotPo2 := iszero(iszero(and(x, sub(x, 1))))\\n            }\\n            return log2(x) + isNotPo2;\\n        }\\n    }\\n\\n    /// @dev Returns the average of `x` and `y`.\\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = (x & y) + ((x ^ y) >> 1);\\n        }\\n    }\\n\\n    /// @dev Returns the average of `x` and `y`.\\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = (x >> 1) + (y >> 1) + (((x & 1) + (y & 1)) >> 1);\\n        }\\n    }\\n\\n    /// @dev Returns the absolute value of `x`.\\n    function abs(int256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := sub(0, shr(255, x))\\n            z := xor(mask, add(mask, x))\\n        }\\n    }\\n\\n    /// @dev Returns the absolute distance between `x` and `y`.\\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let a := sub(y, x)\\n            z := xor(a, mul(xor(a, sub(x, y)), sgt(x, y)))\\n        }\\n    }\\n\\n    /// @dev Returns the minimum of `x` and `y`.\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), lt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the minimum of `x` and `y`.\\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), slt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the maximum of `x` and `y`.\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), gt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the maximum of `x` and `y`.\\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\\n        internal\\n        pure\\n        returns (uint256 z)\\n    {\\n        z = min(max(x, minValue), maxValue);\\n    }\\n\\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\\n        z = min(max(x, minValue), maxValue);\\n    }\\n\\n    /// @dev Returns greatest common divisor of `x` and `y`.\\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            for { z := x } y {} {\\n                let t := y\\n                y := mod(z, y)\\n                z := t\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   RAW NUMBER OPERATIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns `x + y`, without checking for overflow.\\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x + y;\\n        }\\n    }\\n\\n    /// @dev Returns `x + y`, without checking for overflow.\\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x + y;\\n        }\\n    }\\n\\n    /// @dev Returns `x - y`, without checking for underflow.\\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x - y;\\n        }\\n    }\\n\\n    /// @dev Returns `x - y`, without checking for underflow.\\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x - y;\\n        }\\n    }\\n\\n    /// @dev Returns `x * y`, without checking for overflow.\\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x * y;\\n        }\\n    }\\n\\n    /// @dev Returns `x * y`, without checking for overflow.\\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x * y;\\n        }\\n    }\\n\\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := div(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := sdiv(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := smod(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := addmod(x, y, d)\\n        }\\n    }\\n\\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mulmod(x, y, d)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH\\n    /// that disallows any storage writes.\\n    uint256 internal constant _GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    /// Multiply by a small constant (e.g. 2), if needed.\\n    uint256 internal constant _GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    /// The `gasStipend` can be set to a low enough value to prevent\\n    /// storage writes or gas griefing.\\n    ///\\n    /// If sending via the normal procedure fails, force sends the ETH by\\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n    ///\\n    /// Reverts if the current contract has insufficient balance.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If insufficient balance, revert.\\n            if lt(selfbalance(), amount) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(gasStipend, to, amount, 0, 0, 0, 0)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                // We can directly use `SELFDESTRUCT` in the contract creation.\\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    // For better gas estimation.\\n                    if iszero(gt(gas(), 1000000)) { revert(0, 0) }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend\\n    /// equal to `_GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default\\n    /// for 99% of cases and can be overriden with the three-argument version of this\\n    /// function if necessary.\\n    ///\\n    /// If sending via the normal procedure fails, force sends the ETH by\\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n    ///\\n    /// Reverts if the current contract has insufficient balance.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        // Manually inlined because the compiler doesn't inline functions with branches.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If insufficient balance, revert.\\n            if lt(selfbalance(), amount) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(_GAS_STIPEND_NO_GRIEF, to, amount, 0, 0, 0, 0)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                // We can directly use `SELFDESTRUCT` in the contract creation.\\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    // For better gas estimation.\\n                    if iszero(gt(gas(), 1000000)) { revert(0, 0) }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    /// The `gasStipend` can be set to a low enough value to prevent\\n    /// storage writes or gas griefing.\\n    ///\\n    /// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.\\n    ///\\n    /// Note: Does NOT revert upon failure.\\n    /// Returns whether the transfer of ETH is successful instead.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and check if it succeeded or not.\\n            success := call(gasStipend, to, amount, 0, 0, 0, 0)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            // Store the function selector of `transferFrom(address,address,uint256)`.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            // Store the function selector of `balanceOf(address)`.\\n            mstore(0x0c, 0x70a08231000000000000000000000000)\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Store the function selector of `transferFrom(address,address,uint256)`.\\n            mstore(0x00, 0x23b872dd)\\n            // The `amount` argument is already written to the memory word at 0x6c.\\n            amount := mload(0x60)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            // Store the function selector of `transfer(address,uint256)`.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x14, to) // Store the `to` argument.\\n            // The `amount` argument is already written to the memory word at 0x34.\\n            amount := mload(0x34)\\n            // Store the function selector of `transfer(address,uint256)`.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            // Store the function selector of `approve(address,uint256)`.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `ApproveFailed()`.\\n                mstore(0x00, 0x3e3f8f73)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            // Store the function selector of `balanceOf(address)`.\\n            mstore(0x00, 0x70a08231000000000000000000000000)\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/auth/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n/// @dev While the ownable portion follows [EIP-173](https://eips.ethereum.org/EIPS/eip-173)\\n/// for compatibility, the nomenclature for the 2-step ownership handover\\n/// may be unique to this codebase.\\nabstract contract Ownable { \\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The caller is not authorized to call the function.\\n    error Unauthorized();\\n\\n    /// @dev The `newOwner` cannot be the zero address.\\n    error NewOwnerIsZeroAddress();\\n\\n    /// @dev The `pendingOwner` does not have a valid handover request.\\n    error NoHandoverRequest();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\n    /// despite it not being as lightweight as a single argument event.\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @dev An ownership handover to `pendingOwner` has been requested.\\n    event OwnershipHandoverRequested(address indexed pendingOwner);\\n\\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\\n    /// It is intentionally choosen to be a high value\\n    /// to avoid collision with lower slots.\\n    /// The choice of manual storage layout is to enable compatibility\\n    /// with both regular and upgradeable contracts.\\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\\n\\n    /// The ownership handover slot of `newOwner` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\n    ///     let handoverSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// It stores the expiry timestamp of the two-step ownership handover.\\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Initializes the owner directly without authorization guard.\\n    /// This function must be called upon initialization,\\n    /// regardless of whether the contract is upgradeable or not.\\n    /// This is to enable generalization to both regular and upgradeable contracts,\\n    /// and to save gas in case the initial owner is not the caller.\\n    /// For performance reasons, this function will not check if there\\n    /// is an existing owner.\\n    function _initializeOwner(address newOwner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Store the new value.\\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n        }\\n    }\\n\\n    /// @dev Sets the owner directly without authorization guard.\\n    function _setOwner(address newOwner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ownerSlot := not(_OWNER_SLOT_NOT)\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n            // Store the new value.\\n            sstore(ownerSlot, newOwner)\\n        }\\n    }\\n\\n    /// @dev Throws if the sender is not the owner.\\n    function _checkOwner() internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the caller is not the stored owner, revert.\\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(shl(96, newOwner)) {\\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @dev Allows the owner to renounce their ownership.\\n    function renounceOwnership() public payable virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /// @dev Request a two-step ownership handover to the caller.\\n    /// The request will be automatically expire in 48 hours (172800 seconds) by default.\\n    function requestOwnershipHandover() public payable virtual {\\n        unchecked {\\n            uint256 expires = block.timestamp + ownershipHandoverValidFor();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Compute and set the handover slot to `expires`.\\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\\n                mstore(0x00, caller())\\n                sstore(keccak256(0x0c, 0x20), expires)\\n                // Emit the {OwnershipHandoverRequested} event.\\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\n            }\\n        }\\n    }\\n\\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\\n    function cancelOwnershipHandover() public payable virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x20), 0)\\n            // Emit the {OwnershipHandoverCanceled} event.\\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\n        }\\n    }\\n\\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            let handoverSlot := keccak256(0x0c, 0x20)\\n            // If the handover does not exist, or has expired.\\n            if gt(timestamp(), sload(handoverSlot)) {\\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Set the handover slot to 0.\\n            sstore(handoverSlot, 0)\\n        }\\n        _setOwner(pendingOwner);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the owner of the contract.\\n    function owner() public view virtual returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(not(_OWNER_SLOT_NOT))\\n        }\\n    }\\n\\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\n    function ownershipHandoverExpiresAt(address pendingOwner)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the handover slot.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            // Load the handover slot.\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\\n    function ownershipHandoverValidFor() public view virtual returns (uint64) {\\n        return 48 * 3600;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Marks a function as only callable by the owner.\\n    modifier onlyOwner() virtual {\\n        _checkOwner();\\n        _;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"solady/=lib/solady/src/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_underlyingAsset\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AllowanceOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AllowanceUnderflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FeesAlreadyAssesed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidDebtRatio\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidLockedProfitDegradation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidManagementFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMaxLoss\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMinDebtPerHarvest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPerformanceFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPermit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidQueueOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidReportedGainAndDebtPayment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidStrategyUnderlying\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidStrategyVault\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidZeroAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidZeroShares\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LossGreaterThanStrategyTotalDebt\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxLossReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PermitExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QueueIsFull\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrantCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StrategyAlreadyActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StrategyDebtRatioAlreadyZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StrategyInEmergencyExitMode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StrategyNotActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TotalSupplyOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultDepositLimitExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultInEmergencyShutdownMode\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDepositLimit\",\"type\":\"uint256\"}],\"name\":\"DepositLimitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"emergencyShutdown\",\"type\":\"bool\"}],\"name\":\"EmergencyShutdownUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"managementFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"performanceFee\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"strategistFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"FeesReported\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLockedProfitDegradation\",\"type\":\"uint256\"}],\"name\":\"LockedProfitDegradationUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newManagementFee\",\"type\":\"uint256\"}],\"name\":\"ManagementFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"newPerformanceFee\",\"type\":\"uint16\"}],\"name\":\"PerformanceFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roles\",\"type\":\"uint256\"}],\"name\":\"RolesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newStrategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"strategyDebtRatio\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"strategyMaxDebtPerHarvest\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"strategyMinDebtPerHarvest\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"strategyPerformanceFee\",\"type\":\"uint16\"}],\"name\":\"StrategyAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"StrategyAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gain\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loss\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"debtPayment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"strategyTotalGain\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"strategyTotalLoss\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"strategyTotalDebt\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"credit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"strategyDebtRatio\",\"type\":\"uint16\"}],\"name\":\"StrategyReported\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"StrategyRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"newDebtRatio\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"newMaxDebtPerHarvest\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"newMinDebtPerHarvest\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"newPerformanceFee\",\"type\":\"uint16\"}],\"name\":\"StrategyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"}],\"name\":\"TreasuryUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"strategyTotalDebt\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"loss\",\"type\":\"uint128\"}],\"name\":\"WithdrawFromStrategy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[20]\",\"name\":\"withdrawalQueue\",\"type\":\"address[20]\"}],\"name\":\"WithdrawalQueueUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEGRADATION_COEFFICIENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EMERGENCY_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAXIMUM_STRATEGIES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECS_PER_YEAR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STRATEGY_ROLE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newStrategy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"strategyDebtRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strategyMaxDebtPerHarvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strategyMinDebtPerHarvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strategyPerformanceFee\",\"type\":\"uint256\"}],\"name\":\"addStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"creditAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"debtOutstanding\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"debtRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"difference\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyShutdown\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"getStratetegyTotalDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"strategyTotalDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roles\",\"type\":\"uint256\"}],\"name\":\"grantRoles\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roles\",\"type\":\"uint256\"}],\"name\":\"hasAllRoles\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roles\",\"type\":\"uint256\"}],\"name\":\"hasAnyRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"difference\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastReport\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedProfitDegradation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managementFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roles\",\"type\":\"uint256\"}],\"name\":\"ordinalsFromRoles\",\"outputs\":[{\"internalType\":\"uint8[]\",\"name\":\"ordinals\",\"type\":\"uint8[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownershipHandoverValidFor\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"performanceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"removeStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roles\",\"type\":\"uint256\"}],\"name\":\"renounceRoles\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"gain\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"loss\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"debtPayment\",\"type\":\"uint128\"}],\"name\":\"report\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roles\",\"type\":\"uint256\"}],\"name\":\"revokeRoles\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"revokeStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"ordinals\",\"type\":\"uint8[]\"}],\"name\":\"rolesFromOrdinals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"roles\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"rolesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"roles\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositLimit\",\"type\":\"uint256\"}],\"name\":\"setDepositLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_emergencyShutdown\",\"type\":\"bool\"}],\"name\":\"setEmergencyShutdown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockedProfitDegradation\",\"type\":\"uint256\"}],\"name\":\"setLockedProfitDegradation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_managementFee\",\"type\":\"uint256\"}],\"name\":\"setManagementFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_performanceFee\",\"type\":\"uint256\"}],\"name\":\"setPerformanceFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[20]\",\"name\":\"queue\",\"type\":\"address[20]\"}],\"name\":\"setWithdrawalQueue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"shareValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sharesForAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"strategies\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"strategyDebtRatio\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"strategyPerformanceFee\",\"type\":\"uint16\"},{\"internalType\":\"uint48\",\"name\":\"strategyActivation\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"strategyLastReport\",\"type\":\"uint48\"},{\"internalType\":\"uint128\",\"name\":\"strategyMaxDebtPerHarvest\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"strategyMinDebtPerHarvest\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"strategyTotalGain\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"strategyTotalDebt\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"strategyTotalLoss\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalIdle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingAsset\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newDebtRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMaxDebtPerHarvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMinDebtPerHarvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newPerformanceFee\",\"type\":\"uint256\"}],\"name\":\"updateStrategyData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxLoss\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdrawalQueue\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MaxApyVault", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000067539d650922af9d2c611251ac9749f167e51ac0000000000000000000000000000000000000000000000000000000000000000f4d6178417079574554485661756c74000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000076d61785745544800000000000000000000000000000000000000000000000000", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}