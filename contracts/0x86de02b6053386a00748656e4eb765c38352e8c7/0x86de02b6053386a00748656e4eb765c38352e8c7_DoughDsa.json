{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/DoughDsa.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity =0.8.24;\\nimport { IDoughIndex, CustomError } from \\\"./Interfaces.sol\\\";\\n\\n/**\\n* $$$$$$$\\\\                                $$\\\\             $$$$$$$$\\\\ $$\\\\                                                   \\n* $$  __$$\\\\                               $$ |            $$  _____|\\\\__|                                                  \\n* $$ |  $$ | $$$$$$\\\\  $$\\\\   $$\\\\  $$$$$$\\\\  $$$$$$$\\\\        $$ |      $$\\\\ $$$$$$$\\\\   $$$$$$\\\\  $$$$$$$\\\\   $$$$$$$\\\\  $$$$$$\\\\  \\n* $$ |  $$ |$$  __$$\\\\ $$ |  $$ |$$  __$$\\\\ $$  __$$\\\\       $$$$$\\\\    $$ |$$  __$$\\\\  \\\\____$$\\\\ $$  __$$\\\\ $$  _____|$$  __$$\\\\ \\n* $$ |  $$ |$$ /  $$ |$$ |  $$ |$$ /  $$ |$$ |  $$ |      $$  __|   $$ |$$ |  $$ | $$$$$$$ |$$ |  $$ |$$ /      $$$$$$$$ |\\n* $$ |  $$ |$$ |  $$ |$$ |  $$ |$$ |  $$ |$$ |  $$ |      $$ |      $$ |$$ |  $$ |$$  __$$ |$$ |  $$ |$$ |      $$   ____|\\n* $$$$$$$  |\\\\$$$$$$  |\\\\$$$$$$  |\\\\$$$$$$$ |$$ |  $$ |      $$ |      $$ |$$ |  $$ |\\\\$$$$$$$ |$$ |  $$ |\\\\$$$$$$$\\\\ \\\\$$$$$$$\\\\ \\n* \\\\_______/  \\\\______/  \\\\______/  \\\\____$$ |\\\\__|  \\\\__|      \\\\__|      \\\\__|\\\\__|  \\\\__| \\\\_______|\\\\__|  \\\\__| \\\\_______| \\\\_______|\\n*                               $$\\\\   $$ |                                                                                \\n*                               \\\\$$$$$$  |                                                                                \\n*                                \\\\______/                                                                                 \\n* \\n* @title DoughDsa\\n* @notice This contract is used to delegate the call to the respective connectors\\n* @custom:version 1.0 - Initial release\\n* @author Liberalite https://github.com/liberalite\\n* @custom:coauthor 0xboga https://github.com/0xboga\\n*/\\ncontract DoughDsa {\\n    /* ========== LAYOUT ========== */\\n    address public dsaOwner;\\n    address public doughIndex;\\n\\n    /**\\n    * @notice Initializes the DoughDsa contract\\n    * @param _dsaOwner: The DSA owner address of the DSA contract\\n    * @param _doughIndex: The DoughIndex contract address\\n    */\\n    function initialize(address _dsaOwner, address _doughIndex) external {\\n        if (dsaOwner != address(0) || _dsaOwner == address(0)) revert CustomError(\\\"invalid dsaOwner\\\");\\n        if (doughIndex != address(0) || _doughIndex == address(0)) revert CustomError(\\\"invalid doughIndex\\\");\\n        doughIndex = _doughIndex;\\n        dsaOwner = _dsaOwner;\\n    }\\n\\n    /**\\n    * @notice Delegates the call to the respective connector\\n    * @param _connectorId: The connector ID to call\\n    * @param _actionId: The action ID to call\\n    * @param _token: The token address to call\\n    * @param _amount: The amount to call\\n    * @param _opt: The optional boolean value\\n    * @param _swapData: The swap data to call\\n    */\\n    function doughCall(uint256 _connectorId, uint256 _actionId, address _token, uint256 _amount, bool _opt, bytes[] calldata _swapData) external payable {\\n        // _connectorId:  0-dsa  1-aave  2-paraswap  3-uniV3  4-deleveraging-uniV3  4-deleveraging-paraswap  5-shield  6-vault\\n        address _contract = IDoughIndex(doughIndex).getDoughConnector(_connectorId);\\n        if (_contract == address(0)) revert CustomError(\\\"Unregistered Connector\\\");\\n\\n        if (_connectorId < 21) {\\n            // only the DSA Owner can run supply, withdraw, repay, swap, loop, deloop, etc\\n            if (msg.sender != dsaOwner) revert CustomError(\\\"Caller not dsaOwner\\\");\\n        } else if (_connectorId == 21 || _connectorId == 22) {\\n            if (msg.sender != IDoughIndex(doughIndex).deleverageAutomation()) revert CustomError(\\\"Only Deleveraging Automation\\\");\\n        } else if (_connectorId == 23) {\\n            if (msg.sender != IDoughIndex(doughIndex).shieldAutomation()) revert CustomError(\\\"Only Shield Automation\\\");\\n        } else if (_connectorId == 24) {\\n            if (msg.sender != IDoughIndex(doughIndex).vaultAutomation()) revert CustomError(\\\"Only Vault Automation\\\");\\n        } else {\\n            // future connectors will only be available to the DSA Owner\\n            if (msg.sender != dsaOwner) revert CustomError(\\\"Caller not dsaOwner\\\");\\n        }\\n\\n        (bool success, bytes memory data) = _contract.delegatecall(abi.encodeWithSignature(\\\"delegateDoughCall(uint256,address,uint256,bool,bytes[])\\\", _actionId, _token, _amount, _opt, _swapData));\\n        if (!success) {\\n            if (data.length == 0) revert CustomError(\\\"Invalid doughcall error length\\\");\\n            if (data.length > 0) {\\n                assembly {\\n                    revert(add(32, data), mload(data))\\n                }\\n            }\\n        }\\n\\n    }\\n\\n    /**\\n    * @notice Executes an action from and to the Flashloan Connector\\n    * @param _connectorId: The connector ID\\n    * @param _tokenIn: The token address to get in\\n    * @param _inAmount: The amount to get in\\n    * @param _tokenOut: The token address to get out\\n    * @param _outAmount: The amount to get out\\n    * @param _actionId: The action ID to call\\n    */\\n    function executeAction(uint256 _connectorId, address _tokenIn, uint256 _inAmount, address _tokenOut, uint256 _outAmount, uint256 _actionId) external payable {\\n        address _connector = IDoughIndex(doughIndex).getDoughConnector(_connectorId);\\n        if(msg.sender != address(this) && msg.sender != _connector) revert CustomError(\\\"Caller not owner or DSA\\\");\\n\\n        address aaveActions = IDoughIndex(doughIndex).aaveActionsAddress();\\n\\n        (bool success, bytes memory data) = aaveActions.delegatecall(abi.encodeWithSignature(\\\"executeAaveAction(uint256,address,uint256,address,uint256,uint256)\\\", _connectorId, _tokenIn, _inAmount, _tokenOut, _outAmount, _actionId));\\n        if (!success) {\\n            if (data.length == 0) revert CustomError(\\\"Invalid Aave error length\\\");\\n            if (data.length > 0) {\\n                assembly {\\n                    revert(add(32, data), mload(data))\\n                }\\n            }\\n        }\\n\\n    }\\n\\n    /**\\n    * @notice allows DSA Owner to deposit and withdraw ETH\\n    */\\n    receive() external payable {}\\n    fallback() external payable {}\\n}\"\r\n    },\r\n    \"contracts/Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.10;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nerror CustomError(string errorMsg);\\n\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n    function withdraw(uint amount) external;\\n}\\n\\ninterface AaveActionsConnector {\\n    function executeAaveAction(address _dsaAddress, uint256 _connectorId, address _tokenIn, uint256 _inAmount, address _tokenOut, uint256 _outAmount, uint256 _actionId) external payable;\\n}\\n\\ninterface IDoughDsa {\\n    function doughCall(uint256 _connectorId, uint256 _actionId, address _token, uint256 _amount, bool _opt, bytes[] calldata _swapData) external payable;\\n    function executeAction(uint256 _connectorId, address tokenIn, uint256 inAmount, address tokenOut, uint256 outAmount, uint256 actionId) external payable;\\n    function dsaOwner() external view returns (address);\\n    function doughIndex() external view returns (address);\\n}\\n\\ninterface IDoughIndex {\\n    function aaveActionsAddress() external view returns (address);\\n    function setDsaMasterClone(address _dsaMasterCopy) external;\\n    function setNewBorrowFormula(address _newBorrowFormula) external;\\n    function setNewAaveActions(address _newAaveActions) external;\\n    function apyFee() external view returns (uint256);\\n    function getFlashBorrowers(address _flashBorrower) external view returns (bool);\\n    function deleverageAutomation() external view returns (address);\\n    function shieldAutomation() external view returns (address);\\n    function vaultAutomation() external view returns (address);\\n    function getWhitelistedTokenList() external view returns (address[] memory);\\n    function multisig() external view returns (address);\\n    function treasury() external view returns (address);\\n    function deleverageAsset() external view returns (address);\\n    function getDoughConnector (uint256 _connectorId) external view returns (address);\\n    function getOwnerOfDoughDsa(address dsaAddress) external view returns (address);\\n    function getDoughDsa(address dsaAddress) external view returns (address);\\n    function getTokenDecimals(address _token) external view returns (uint8);\\n    function getTokenMinInterest(address _token) external view returns (uint256);\\n    function getTokenIndex(address _token) external view returns (uint256);\\n    function borrowFormula (address _token, address _dsaAddress) external returns (uint256, uint256, uint256, uint256);\\n    function borrowFormulaInterest (address _token, address _dsaAddress) external returns (uint256);\\n    function getDsaBorrowStartDate (address _dsaAddress, address _token) external view returns (uint256);\\n    function updateBorrowDate(uint256 _connectorID, uint256 _time, address _dsaAddress, address _token) external;\\n    function minDeleveragingRatio() external view returns (uint256);\\n    function minHealthFactor() external view returns (uint256);\\n}\\n\\ninterface IBorrowManagementConnector {\\n    function borrowFormula(address _token, address _dsaAddress) external view returns (uint256, uint256, uint256, uint256);\\n    function borrowFormulaInterest(address _token, address _dsaAddress) external view returns (uint256);\\n}\\n\\ninterface IConnectorMultiFlashloan {\\n    function flashloanReq(address[] memory flashloanTokens, uint256[] memory flashloanAmounts, uint256[] memory flashLoanInterestRateModes, bytes[] memory swapData) external;\\n}\\n\\ninterface IConnectorMultiFlashloanOnchain {\\n    function flashloanReq(address[] memory flashloanTokens, uint256[] memory flashloanAmount, uint256[] memory flashLoanInterestRateModes, address[] memory flashLoanTokensCollateral, uint256[] memory flashLoanAmountsCollateral) external;\\n}\\n\\ninterface IConnectorFlashloan {\\n    function flashloanReq(address dsaOwnerAddress, address flashloanToken, uint256 flashloanAmount, uint256 flashActionId, bytes calldata _swapData) external;\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"errorMsg\",\"type\":\"string\"}],\"name\":\"CustomError\",\"type\":\"error\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_connectorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_actionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_opt\",\"type\":\"bool\"},{\"internalType\":\"bytes[]\",\"name\":\"_swapData\",\"type\":\"bytes[]\"}],\"name\":\"doughCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"doughIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dsaOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_connectorId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_inAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_outAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_actionId\",\"type\":\"uint256\"}],\"name\":\"executeAction\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dsaOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_doughIndex\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DoughDsa", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}