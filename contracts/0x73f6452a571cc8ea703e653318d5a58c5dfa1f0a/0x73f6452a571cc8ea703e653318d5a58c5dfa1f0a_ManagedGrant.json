{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"solidity/contracts/ManagedGrant.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.4;\\n\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"./TokenGrant.sol\\\";\\n\\n/// @title ManagedGrant\\n/// @notice A managed grant acts as the grantee towards the token grant contract,\\n/// proxying instructions from the actual grantee.\\n/// The address used by the actual grantee\\n/// to issue instructions and withdraw tokens\\n/// can be reassigned with the consent of the grant manager.\\ncontract ManagedGrant {\\n    using SafeERC20 for ERC20Burnable;\\n\\n    ERC20Burnable public token;\\n    TokenGrant public tokenGrant;\\n    address public grantManager;\\n    uint256 public grantId;\\n    address public grantee;\\n    address public requestedNewGrantee;\\n\\n    event GranteeReassignmentRequested(\\n        address newGrantee\\n    );\\n    event GranteeReassignmentConfirmed(\\n        address oldGrantee,\\n        address newGrantee\\n    );\\n    event GranteeReassignmentCancelled(\\n        address cancelledRequestedGrantee\\n    );\\n    event GranteeReassignmentChanged(\\n        address previouslyRequestedGrantee,\\n        address newRequestedGrantee\\n    );\\n    event TokensWithdrawn(\\n        address destination,\\n        uint256 amount\\n    );\\n\\n    constructor(\\n        address _tokenAddress,\\n        address _tokenGrant,\\n        address _grantManager,\\n        uint256 _grantId,\\n        address _grantee\\n    ) public {\\n        token = ERC20Burnable(_tokenAddress);\\n        tokenGrant = TokenGrant(_tokenGrant);\\n        grantManager = _grantManager;\\n        grantId = _grantId;\\n        grantee = _grantee;\\n    }\\n\\n    /// @notice Request a reassignment of the grantee address.\\n    /// Can only be called by the grantee.\\n    /// @param _newGrantee The requested new grantee.\\n    function requestGranteeReassignment(address _newGrantee)\\n        public\\n        onlyGrantee\\n        noRequestedReassignment\\n    {\\n        _setRequestedNewGrantee(_newGrantee);\\n        emit GranteeReassignmentRequested(_newGrantee);\\n    }\\n\\n    /// @notice Cancel a pending grantee reassignment request.\\n    /// Can only be called by the grantee.\\n    function cancelReassignmentRequest()\\n        public\\n        onlyGrantee\\n        withRequestedReassignment\\n    {\\n        address cancelledGrantee = requestedNewGrantee;\\n        requestedNewGrantee = address(0);\\n        emit GranteeReassignmentCancelled(cancelledGrantee);\\n    }\\n\\n    /// @notice Change a pending reassignment request to a different grantee.\\n    /// Can only be called by the grantee.\\n    /// @param _newGrantee The address of the new requested grantee.\\n    function changeReassignmentRequest(address _newGrantee)\\n        public\\n        onlyGrantee\\n        withRequestedReassignment\\n    {\\n        address previouslyRequestedGrantee = requestedNewGrantee;\\n        require(\\n            previouslyRequestedGrantee != _newGrantee,\\n            \\\"Unchanged reassignment request\\\"\\n        );\\n        _setRequestedNewGrantee(_newGrantee);\\n        emit GranteeReassignmentChanged(previouslyRequestedGrantee, _newGrantee);\\n    }\\n\\n    /// @notice Confirm a grantee reassignment request and set the new grantee as the grantee.\\n    /// Can only be called by the grant manager.\\n    /// @param _newGrantee The address of the new grantee.\\n    /// Must match the currently requested new grantee.\\n    function confirmGranteeReassignment(address _newGrantee)\\n        public\\n        onlyManager\\n        withRequestedReassignment\\n    {\\n        address oldGrantee = grantee;\\n        require(\\n            requestedNewGrantee == _newGrantee,\\n            \\\"Reassignment address mismatch\\\"\\n        );\\n        grantee = requestedNewGrantee;\\n        requestedNewGrantee = address(0);\\n        emit GranteeReassignmentConfirmed(oldGrantee, _newGrantee);\\n    }\\n\\n    /// @notice Withdraw all unlocked tokens from the grant.\\n    function withdraw() public onlyGrantee {\\n        require(\\n            requestedNewGrantee == address(0),\\n            \\\"Can not withdraw with pending reassignment\\\"\\n        );\\n        tokenGrant.withdraw(grantId);\\n        uint256 amount = token.balanceOf(address(this));\\n        token.safeTransfer(grantee, amount);\\n        emit TokensWithdrawn(grantee, amount);\\n    }\\n\\n    /// @notice Stake tokens from the grant.\\n    /// @param _stakingContract The contract to stake the tokens on.\\n    /// @param _amount The amount of tokens to stake.\\n    /// @param _extraData Data for the stake delegation.\\n    /// This byte array must have the following values concatenated:\\n    /// beneficiary address (20 bytes)\\n    /// operator address (20 bytes)\\n    /// authorizer address (20 bytes)\\n    function stake(\\n        address _stakingContract,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    ) public onlyGrantee {\\n        tokenGrant.stake(grantId, _stakingContract, _amount, _extraData);\\n    }\\n\\n    /// @notice Cancel delegating tokens to the given operator.\\n    function cancelStake(address _operator) public onlyGranteeOr(_operator) {\\n        tokenGrant.cancelStake(_operator);\\n    }\\n\\n    /// @notice Begin undelegating tokens from the given operator.\\n    function undelegate(address _operator) public onlyGranteeOr(_operator) {\\n        tokenGrant.undelegate(_operator);\\n    }\\n\\n    /// @notice Recover tokens previously staked and delegated to the operator.\\n    function recoverStake(address _operator) public {\\n        tokenGrant.recoverStake(_operator);\\n    }\\n\\n    function _setRequestedNewGrantee(address _newGrantee) internal {\\n        require(_newGrantee != address(0), \\\"Invalid new grantee address\\\");\\n        require(_newGrantee != grantee, \\\"New grantee same as current grantee\\\");\\n\\n        requestedNewGrantee = _newGrantee;\\n    }\\n\\n    modifier withRequestedReassignment {\\n        require(\\n            requestedNewGrantee != address(0),\\n            \\\"No reassignment requested\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier noRequestedReassignment {\\n        require(\\n            requestedNewGrantee == address(0),\\n            \\\"Reassignment already requested\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyGrantee {\\n        require(\\n            msg.sender == grantee,\\n            \\\"Only grantee may perform this action\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyGranteeOr(address _operator) {\\n        require(\\n            msg.sender == grantee || msg.sender == _operator,\\n            \\\"Only grantee or operator may perform this action\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyManager {\\n        require(\\n            msg.sender == grantManager,\\n            \\\"Only grantManager may perform this action\\\"\\n        );\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/TokenGrant.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/math/SafeMath.sol\\\";\\nimport \\\"./libraries/grant/UnlockingSchedule.sol\\\";\\nimport \\\"./utils/BytesLib.sol\\\";\\nimport \\\"./utils/AddressArrayUtils.sol\\\";\\nimport \\\"./TokenStaking.sol\\\";\\nimport \\\"./TokenGrantStake.sol\\\";\\nimport \\\"./GrantStakingPolicy.sol\\\";\\n\\n\\n/// @title TokenGrant\\n/// @notice A token grant contract for a specified standard ERC20Burnable token.\\n/// Has additional functionality to stake delegate/undelegate token grants.\\n/// Tokens are granted to the grantee via unlocking scheme and can be\\n/// withdrawn gradually based on the unlocking schedule cliff and unlocking duration.\\n/// Optionally grant can be revoked by the token grant manager.\\ncontract TokenGrant {\\n    using SafeMath for uint256;\\n    using UnlockingSchedule for uint256;\\n    using SafeERC20 for ERC20Burnable;\\n    using BytesLib for bytes;\\n    using AddressArrayUtils for address[];\\n\\n    event TokenGrantCreated(uint256 id);\\n    event TokenGrantWithdrawn(uint256 indexed grantId, uint256 amount);\\n    event TokenGrantStaked(uint256 indexed grantId, uint256 amount, address operator);\\n    event TokenGrantRevoked(uint256 id);\\n\\n    event StakingContractAuthorized(address indexed grantManager, address stakingContract);\\n\\n    struct Grant {\\n        address grantManager; // Token grant manager.\\n        address grantee; // Address to which granted tokens are going to be withdrawn.\\n        uint256 revokedAt; // Timestamp at which grant was revoked by the grant manager.\\n        uint256 revokedAmount; // The number of tokens revoked from the grantee.\\n        uint256 revokedWithdrawn; // The number of tokens returned to the grant creator.\\n        bool revocable; // Whether grant manager can revoke the grant.\\n        uint256 amount; // Amount of tokens to be granted.\\n        uint256 duration; // Duration in seconds of the period in which the granted tokens will unlock.\\n        uint256 start; // Timestamp at which the linear unlocking schedule will start.\\n        uint256 cliff; // Timestamp before which no tokens will be unlocked.\\n        uint256 withdrawn; // Amount that was withdrawn to the grantee.\\n        uint256 staked; // Amount that was staked by the grantee.\\n        GrantStakingPolicy stakingPolicy;\\n    }\\n\\n    uint256 public numGrants;\\n\\n    ERC20Burnable public token;\\n\\n    // Staking contracts authorized by the given grant manager.\\n    // grant manager -> staking contract -> authorized?\\n    mapping(address => mapping (address => bool)) internal stakingContracts;\\n\\n    // Token grants.\\n    mapping(uint256 => Grant) public grants;\\n\\n    // Token grants stakes.\\n    mapping(address => TokenGrantStake) public grantStakes;\\n\\n    // Mapping of token grant IDs per particular address\\n    // involved in a grant as a grantee or as a grant manager.\\n    mapping(address => uint256[]) public grantIndices;\\n\\n    // Token grants balances. Sum of all granted tokens to a grantee.\\n    // This includes granted tokens that are already unlocked and\\n    // available to be withdrawn to the grantee\\n    mapping(address => uint256) public balances;\\n\\n    // Mapping of operator addresses per particular grantee address.\\n    mapping(address => address[]) public granteesToOperators;\\n\\n    /// @notice Creates a token grant contract for a provided Standard ERC20Burnable token.\\n    /// @param _tokenAddress address of a token that will be linked to this contract.\\n    constructor(address _tokenAddress) public {\\n        require(_tokenAddress != address(0x0), \\\"Token address can't be zero.\\\");\\n        token = ERC20Burnable(_tokenAddress);\\n    }\\n\\n    /// @notice Used by grant manager to authorize staking contract with the given\\n    /// address.\\n    function authorizeStakingContract(address _stakingContract) public {\\n        require(\\n            _stakingContract != address(0x0),\\n            \\\"Staking contract address can't be zero\\\"\\n        );\\n        stakingContracts[msg.sender][_stakingContract] = true;\\n        emit StakingContractAuthorized(msg.sender, _stakingContract);\\n    }\\n\\n    /// @notice Gets the amount of granted tokens to the specified address.\\n    /// @param _owner The address to query the grants balance of.\\n    /// @return An uint256 representing the grants balance owned by the passed address.\\n    function balanceOf(address _owner) public view returns (uint256 balance) {\\n        return balances[_owner];\\n    }\\n\\n    /// @notice Gets the stake balance of the specified address.\\n    /// @param _address The address to query the balance of.\\n    /// @return An uint256 representing the amount staked by the passed address.\\n    function stakeBalanceOf(address _address) public view returns (uint256 balance) {\\n        for (uint i = 0; i < grantIndices[_address].length; i++) {\\n            uint256 id = grantIndices[_address][i];\\n            balance += grants[id].staked;\\n        }\\n        return balance;\\n    }\\n\\n    /// @notice Gets grant by ID. Returns only basic grant data.\\n    /// If you need unlocking schedule for the grant you must call `getGrantUnlockingSchedule()`\\n    /// This is to avoid Ethereum `Stack too deep` issue described here:\\n    /// https://forum.ethereum.org/discussion/2400/error-stack-too-deep-try-removing-local-variables\\n    /// @param _id ID of the token grant.\\n    /// @return amount The amount of tokens the grant provides.\\n    /// @return withdrawn The amount of tokens that have already been withdrawn\\n    ///                   from the grant.\\n    /// @return staked The amount of tokens that have been staked from the grant.\\n    /// @return revoked A boolean indicating whether the grant has been revoked,\\n    ///                 which is to say that it is no longer unlocking.\\n    /// @return grantee The grantee of grant.\\n    function getGrant(uint256 _id) public view returns (\\n        uint256 amount,\\n        uint256 withdrawn,\\n        uint256 staked,\\n        uint256 revokedAmount,\\n        uint256 revokedAt,\\n        address grantee\\n    ) {\\n        return (\\n            grants[_id].amount,\\n            grants[_id].withdrawn,\\n            grants[_id].staked,\\n            grants[_id].revokedAmount,\\n            grants[_id].revokedAt,\\n            grants[_id].grantee\\n        );\\n    }\\n\\n    /// @notice Gets grant unlocking schedule by grant ID.\\n    /// @param _id ID of the token grant.\\n    /// @return grantManager The address designated as the manager of the grant,\\n    ///                      which is the only address that can revoke this grant.\\n    /// @return duration The duration, in seconds, during which the tokens will\\n    ///                  unlocking linearly.\\n    /// @return start The start time, as a timestamp comparing to `now`.\\n    /// @return cliff The timestamp, before which none of the tokens in the grant\\n    ///               will be unlocked, and after which a linear amount based on\\n    ///               the time elapsed since the start will be unlocked.\\n    /// @return policy The address of the grant's staking policy.\\n    function getGrantUnlockingSchedule(\\n        uint256 _id\\n    ) public view returns (\\n        address grantManager,\\n        uint256 duration,\\n        uint256 start,\\n        uint256 cliff,\\n        address policy\\n    ) {\\n        return (\\n            grants[_id].grantManager,\\n            grants[_id].duration,\\n            grants[_id].start,\\n            grants[_id].cliff,\\n            address(grants[_id].stakingPolicy)\\n        );\\n    }\\n\\n    /// @notice Gets grant ids of the specified address.\\n    /// @param _granteeOrGrantManager The address to query.\\n    /// @return An uint256 array of grant IDs.\\n    function getGrants(address _granteeOrGrantManager) public view returns (uint256[] memory) {\\n        return grantIndices[_granteeOrGrantManager];\\n    }\\n\\n    /// @notice Gets operator addresses of the specified grantee address.\\n    /// @param grantee The grantee address.\\n    /// @return An array of all operators for a given grantee.\\n    function getGranteeOperators(address grantee) public view returns (address[] memory) {\\n        return granteesToOperators[grantee];\\n    }\\n\\n    /// @notice Gets grant stake details of the given operator.\\n    /// @param operator The operator address.\\n    /// @return grantId ID of the token grant.\\n    /// @return amount The amount of tokens the given operator delegated.\\n    /// @return stakingContract The address of staking contract.\\n    function getGrantStakeDetails(address operator) public view returns (uint256 grantId, uint256 amount, address stakingContract) {\\n        return grantStakes[operator].getDetails();\\n    }\\n\\n\\n    /// @notice Receives approval of token transfer and creates a token grant with a unlocking\\n    /// schedule where balance withdrawn to the grantee gradually in a linear fashion until\\n    /// start + duration. By then all of the balance will have unlocked.\\n    /// @param _from The owner of the tokens who approved them to transfer.\\n    /// @param _amount Approved amount for the transfer to create token grant.\\n    /// @param _token Token contract address.\\n    /// @param _extraData This byte array must have the following values ABI encoded:\\n    /// grantManager (address) Address of the grant manager.\\n    /// grantee (address) Address of the grantee.\\n    /// duration (uint256) Duration in seconds of the unlocking period.\\n    /// start (uint256) Timestamp at which unlocking will start.\\n    /// cliffDuration (uint256) Duration in seconds of the cliff;\\n    ///               no tokens will be unlocked until the time `start + cliff`.\\n    /// revocable (bool) Whether the token grant is revocable or not (1 or 0).\\n    /// stakingPolicy (address) Address of the staking policy for the grant.\\n    function receiveApproval(address _from, uint256 _amount, address _token, bytes memory _extraData) public {\\n        require(ERC20Burnable(_token) == token, \\\"Token contract must be the same one linked to this contract.\\\");\\n        require(_amount <= token.balanceOf(_from), \\\"Sender must have enough amount.\\\");\\n        (address _grantManager,\\n         address _grantee,\\n         uint256 _duration,\\n         uint256 _start,\\n         uint256 _cliffDuration,\\n         bool _revocable,\\n         address _stakingPolicy) = abi.decode(\\n             _extraData,\\n             (address, address, uint256, uint256, uint256, bool, address)\\n        );\\n\\n        require(_grantee != address(0), \\\"Grantee address can't be zero.\\\");\\n        require(\\n            _cliffDuration <= _duration,\\n            \\\"Unlocking cliff duration must be less or equal total unlocking duration.\\\"\\n        );\\n\\n        require(_stakingPolicy != address(0), \\\"Staking policy can't be zero.\\\");\\n\\n        uint256 id = numGrants++;\\n        grants[id] = Grant(\\n            _grantManager,\\n            _grantee,\\n            0, 0, 0,\\n            _revocable,\\n            _amount,\\n            _duration,\\n            _start,\\n            _start.add(_cliffDuration),\\n            0, 0,\\n            GrantStakingPolicy(_stakingPolicy)\\n        );\\n\\n        // Maintain a record to make it easier to query grants by grant manager.\\n        grantIndices[_from].push(id);\\n\\n        // Maintain a record to make it easier to query grants by grantee.\\n        grantIndices[_grantee].push(id);\\n\\n        token.safeTransferFrom(_from, address(this), _amount);\\n\\n        // Maintain a record of the unlocked amount\\n        balances[_grantee] = balances[_grantee].add(_amount);\\n        emit TokenGrantCreated(id);\\n    }\\n\\n    /// @notice Withdraws Token grant amount to grantee.\\n    /// @dev Transfers unlocked tokens of the token grant to grantee.\\n    /// @param _id Grant ID.\\n    function withdraw(uint256 _id) public {\\n        uint256 amount = withdrawable(_id);\\n        require(amount > 0, \\\"Grant available to withdraw amount should be greater than zero.\\\");\\n\\n        // Update withdrawn amount.\\n        grants[_id].withdrawn = grants[_id].withdrawn.add(amount);\\n\\n        // Update grantee grants balance.\\n        balances[grants[_id].grantee] = balances[grants[_id].grantee].sub(amount);\\n\\n        // Transfer tokens from this contract balance to the grantee token balance.\\n        token.safeTransfer(grants[_id].grantee, amount);\\n\\n        emit TokenGrantWithdrawn(_id, amount);\\n    }\\n\\n    /// @notice Calculates and returns unlocked grant amount.\\n    /// @dev Calculates token grant amount that has already unlocked,\\n    /// including any tokens that have already been withdrawn by the grantee as well\\n    /// as any tokens that are available to withdraw but have not yet been withdrawn.\\n    /// @param _id Grant ID.\\n    function unlockedAmount(uint256 _id) public view returns (uint256) {\\n        Grant storage grant = grants[_id];\\n        return (grant.revokedAt != 0)\\n            // Grant revoked -> return what is remaining\\n            ? grant.amount.sub(grant.revokedAmount)\\n            // Not revoked -> calculate the unlocked amount normally\\n            : now.getUnlockedAmount(\\n                grant.amount,\\n                grant.duration,\\n                grant.start,\\n                grant.cliff\\n            );\\n    }\\n\\n    /// @notice Calculates withdrawable granted amount.\\n    /// @dev Calculates the amount that has already unlocked but hasn't been withdrawn yet.\\n    /// @param _id Grant ID.\\n    function withdrawable(uint256 _id) public view returns (uint256) {\\n        uint256 unlocked = unlockedAmount(_id);\\n        uint256 withdrawn = grants[_id].withdrawn;\\n        uint256 staked = grants[_id].staked;\\n\\n        if (withdrawn.add(staked) >= unlocked) {\\n            return 0;\\n        } else {\\n            return unlocked.sub(withdrawn).sub(staked);\\n        }\\n    }\\n\\n    /// @notice Allows the grant manager to revoke the grant.\\n    /// @dev Granted tokens that are already unlocked (releasable amount)\\n    /// remain in the grant so grantee can still withdraw them\\n    /// the rest are revoked and withdrawable by token grant manager.\\n    /// @param _id Grant ID.\\n    function revoke(uint256 _id) public {\\n        require(grants[_id].grantManager == msg.sender, \\\"Only grant manager can revoke.\\\");\\n        require(grants[_id].revocable, \\\"Grant must be revocable in the first place.\\\");\\n        require(grants[_id].revokedAt == 0, \\\"Grant must not be already revoked.\\\");\\n\\n        uint256 unlockedAmount = unlockedAmount(_id);\\n        uint256 revokedAmount = grants[_id].amount.sub(unlockedAmount);\\n        grants[_id].revokedAt = now;\\n        grants[_id].revokedAmount = revokedAmount;\\n\\n        // Update grantee's grants balance.\\n        balances[grants[_id].grantee] = balances[grants[_id].grantee].sub(revokedAmount);\\n        emit TokenGrantRevoked(_id);\\n    }\\n\\n    /// @notice Allows the grant manager to withdraw revoked tokens.\\n    /// @dev Will withdraw as many of the revoked tokens as possible\\n    /// without pushing the grant contract into a token deficit.\\n    /// If the grantee has staked more tokens than the unlocked amount,\\n    /// those tokens will remain in the grant until undelegated and returned,\\n    /// after which they can be withdrawn by calling `withdrawRevoked` again.\\n    /// @param _id Grant ID.\\n    function withdrawRevoked(uint256 _id) public {\\n        Grant storage grant = grants[_id];\\n        require(\\n            grant.grantManager == msg.sender,\\n            \\\"Only grant manager can withdraw revoked tokens.\\\"\\n        );\\n        uint256 revoked = grant.revokedAmount;\\n        uint256 revokedWithdrawn = grant.revokedWithdrawn;\\n        require(revokedWithdrawn < revoked, \\\"All revoked tokens withdrawn.\\\");\\n\\n        uint256 revokedRemaining = revoked.sub(revokedWithdrawn);\\n\\n        uint256 totalAmount = grant.amount;\\n        uint256 staked = grant.staked;\\n        uint256 granteeWithdrawn = grant.withdrawn;\\n        uint256 remainingPresentInGrant =\\n            totalAmount.sub(staked).sub(revokedWithdrawn).sub(granteeWithdrawn);\\n\\n        require(remainingPresentInGrant > 0, \\\"No revoked tokens withdrawable.\\\");\\n\\n        uint256 amountToWithdraw = remainingPresentInGrant < revokedRemaining\\n            ? remainingPresentInGrant\\n            : revokedRemaining;\\n        token.safeTransfer(msg.sender, amountToWithdraw);\\n        grant.revokedWithdrawn += amountToWithdraw;\\n    }\\n\\n    /// @notice Stake token grant.\\n    /// @dev Stakable token grant amount is determined\\n    /// by the grant's staking policy.\\n    /// @param _id Grant Id.\\n    /// @param _stakingContract Address of the staking contract.\\n    /// @param _amount Amount to stake.\\n    /// @param _extraData Data for stake delegation. This byte array must have\\n    /// the following values concatenated:\\n    /// - Beneficiary address (20 bytes)\\n    /// - Operator address (20 bytes)\\n    /// - Authorizer address (20 bytes)\\n    function stake(uint256 _id, address _stakingContract, uint256 _amount, bytes memory _extraData) public {\\n        require(grants[_id].grantee == msg.sender, \\\"Only grantee of the grant can stake it.\\\");\\n        require(grants[_id].revokedAt == 0, \\\"Revoked grant can not be staked\\\");\\n        require(\\n            stakingContracts[grants[_id].grantManager][_stakingContract],\\n            \\\"Provided staking contract is not authorized.\\\"\\n        );\\n\\n        // Expecting 60 bytes _extraData for stake delegation.\\n        require(_extraData.length == 60, \\\"Stake delegation data must be provided.\\\");\\n        address operator = _extraData.toAddress(20);\\n\\n        // Calculate available amount. Amount of unlocked tokens minus what user already withdrawn and staked.\\n        require(_amount <= availableToStake(_id), \\\"Must have available granted amount to stake.\\\");\\n\\n        // Keep staking record.\\n        TokenGrantStake grantStake = new TokenGrantStake(\\n            address(token),\\n            _id,\\n            _stakingContract\\n        );\\n        grantStakes[operator] = grantStake;\\n        granteesToOperators[grants[_id].grantee].push(operator);\\n        grants[_id].staked += _amount;\\n\\n        token.transfer(address(grantStake), _amount);\\n\\n        // Staking contract expects 40 bytes _extraData for stake delegation.\\n        // 20 bytes beneficiary's address + 20 bytes operator's address.\\n        grantStake.stake(_amount, _extraData);\\n        emit TokenGrantStaked(_id, _amount, operator);\\n    }\\n\\n    ///  @notice Returns the amount of tokens available for staking from the grant.\\n    /// The stakeable amount is determined by the staking policy of the grant.\\n    /// If the grantee has withdrawn some tokens\\n    /// or the policy returns an erroneously high value,\\n    /// the stakeable amount is limited to the number of tokens remaining.\\n    /// @param _grantId Identifier of the grant\\n    function availableToStake(uint256 _grantId) public view returns (uint256) {\\n        Grant storage grant = grants[_grantId];\\n        // Revoked grants cannot be staked.\\n        // If the grant isn't revoked, the number of revoked tokens is 0.\\n        if (grant.revokedAt != 0) { return 0; }\\n        uint256 amount = grant.amount;\\n        uint256 withdrawn = grant.withdrawn;\\n        uint256 remaining = amount.sub(withdrawn);\\n        uint256 stakeable = grant.stakingPolicy.getStakeableAmount(\\n            now,\\n            amount,\\n            grant.duration,\\n            grant.start,\\n            grant.cliff,\\n            withdrawn\\n        );\\n        // Clamp the stakeable amount to what is left in the grant\\n        // in the case of a malfunctioning staking policy.\\n        if (stakeable > remaining) {\\n            stakeable = remaining;\\n        }\\n\\n        return stakeable.sub(grant.staked);\\n    }\\n\\n    /// @notice Cancels delegation within the operator initialization period\\n    /// without being subjected to the stake lockup for the undelegation period.\\n    /// This can be used to undo mistaken delegation to the wrong operator address.\\n    /// @param _operator Address of the stake operator.\\n    function cancelStake(address _operator) public {\\n        TokenGrantStake grantStake = grantStakes[_operator];\\n        uint256 grantId = grantStake.getGrantId();\\n        require(\\n            msg.sender == _operator || msg.sender == grants[grantId].grantee,\\n            \\\"Only operator or grantee can cancel the delegation.\\\"\\n        );\\n\\n        uint256 returned = grantStake.cancelStake();\\n        grants[grantId].staked = grants[grantId].staked.sub(returned);\\n    }\\n\\n    /// @notice Undelegate the token grant.\\n    /// @param _operator Operator of the stake.\\n    function undelegate(address _operator) public {\\n        TokenGrantStake grantStake = grantStakes[_operator];\\n        uint256 grantId = grantStake.getGrantId();\\n        require(\\n            msg.sender == _operator || msg.sender == grants[grantId].grantee,\\n            \\\"Only operator or grantee can undelegate.\\\"\\n        );\\n\\n        grantStake.undelegate();\\n    }\\n\\n    /// @notice Force cancellation of a revoked grant's stake.\\n    /// Can be used by the grant manager\\n    /// to immediately withdraw tokens back into the grant,\\n    /// from an operator still within the initialization period.\\n    /// These tokens can then be withdrawn\\n    /// if some revoked tokens haven't been withdrawn yet.\\n    function cancelRevokedStake(address _operator) public {\\n        TokenGrantStake grantStake = grantStakes[_operator];\\n        uint256 grantId = grantStake.getGrantId();\\n        require(\\n            grants[grantId].revokedAt != 0,\\n            \\\"Grant must be revoked\\\"\\n        );\\n        require(\\n            msg.sender == grants[grantId].grantManager,\\n            \\\"Only grant manager can force cancellation of revoked grant stake.\\\"\\n        );\\n\\n        uint256 returned = grantStake.cancelStake();\\n        grants[grantId].staked = grants[grantId].staked.sub(returned);\\n    }\\n\\n    /// @notice Force undelegation of a revoked grant's stake.\\n    /// @dev Can be called by the grant manager once the grant is revoked.\\n    /// Has to be done this way, instead of undelegating all operators when the\\n    /// grant is revoked, because the latter method is vulnerable to DoS via\\n    /// out-of-gas.\\n    function undelegateRevoked(address _operator) public {\\n        TokenGrantStake grantStake = grantStakes[_operator];\\n        uint256 grantId = grantStake.getGrantId();\\n        require(\\n            grants[grantId].revokedAt != 0,\\n            \\\"Grant must be revoked\\\"\\n        );\\n        require(\\n            msg.sender == grants[grantId].grantManager,\\n            \\\"Only grant manager can force undelegation of revoked grant stake\\\"\\n        );\\n\\n        grantStake.undelegate();\\n    }\\n\\n    /// @notice Recover stake of the token grant.\\n    /// Recovers the tokens correctly\\n    /// even if they were earlier recovered directly in the staking contract.\\n    /// @param _operator Operator of the stake.\\n    function recoverStake(address _operator) public {\\n        TokenGrantStake grantStake = grantStakes[_operator];\\n        uint256 returned = grantStake.recoverStake();\\n        uint256 grantId = grantStake.getGrantId();\\n        grants[grantId].staked = grants[grantId].staked.sub(returned);\\n\\n        delete grantStakes[_operator];\\n    }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/TokenGrantStake.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/math/SafeMath.sol\\\";\\nimport \\\"./TokenStaking.sol\\\";\\nimport \\\"./utils/BytesLib.sol\\\";\\n\\n\\n/// @dev Interface of sender contract for approveAndCall pattern.\\ninterface tokenSender {\\n    function approveAndCall(address _spender, uint256 _value, bytes calldata _extraData) external;\\n}\\n\\ncontract TokenGrantStake {\\n    using SafeMath for uint256;\\n    using BytesLib for bytes;\\n\\n    ERC20Burnable token;\\n    TokenStaking tokenStaking;\\n\\n    address tokenGrant; // Address of the master grant contract.\\n\\n    uint256 grantId; // ID of the grant for this stake.\\n    uint256 amount; // Amount of staked tokens.\\n    address operator; // Operator of the stake.\\n\\n    constructor(\\n        address _tokenAddress,\\n        uint256 _grantId,\\n        address _tokenStaking\\n    ) public {\\n        require(\\n            _tokenAddress != address(0x0),\\n            \\\"Token address can't be zero.\\\"\\n        );\\n        require(\\n            _tokenStaking != address(0x0),\\n            \\\"Staking contract address can't be zero.\\\"\\n        );\\n\\n        token = ERC20Burnable(_tokenAddress);\\n        tokenGrant = msg.sender;\\n        grantId = _grantId;\\n        tokenStaking = TokenStaking(_tokenStaking);\\n    }\\n\\n    function stake(\\n        uint256 _amount,\\n        bytes memory _extraData\\n    ) public onlyGrant {\\n        amount = _amount;\\n        operator = _extraData.toAddress(20);\\n        tokenSender(address(token)).approveAndCall(\\n            address(tokenStaking),\\n            _amount,\\n            _extraData\\n        );\\n    }\\n\\n    function getGrantId() public view onlyGrant returns (uint256) {\\n        return grantId;\\n    }\\n\\n    function getAmount() public view onlyGrant returns (uint256) {\\n        return amount;\\n    }\\n\\n    function getStakingContract() public view onlyGrant returns (address) {\\n        return address(tokenStaking);\\n    }\\n\\n    function getDetails() public view onlyGrant returns (\\n        uint256 _grantId,\\n        uint256 _amount,\\n        address _tokenStaking\\n    ) {\\n        return (\\n            grantId,\\n            amount,\\n            address(tokenStaking)\\n        );\\n    }\\n\\n    function cancelStake() public onlyGrant returns (uint256) {\\n        tokenStaking.cancelStake(operator);\\n        return returnTokens();\\n    }\\n\\n    function undelegate() public onlyGrant {\\n        tokenStaking.undelegate(operator);\\n    }\\n\\n    function recoverStake() public onlyGrant returns (uint256) {\\n        tokenStaking.recoverStake(operator);\\n        return returnTokens();\\n    }\\n\\n    function returnTokens() internal returns (uint256) {\\n        uint256 returnedAmount = token.balanceOf(address(this));\\n        amount -= returnedAmount;\\n        token.transfer(tokenGrant, returnedAmount);\\n        return returnedAmount;\\n    }\\n\\n    modifier onlyGrant {\\n        require(\\n            msg.sender == tokenGrant,\\n            \\\"For token grant contract only\\\"\\n        );\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/libraries/grant/UnlockingSchedule.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"openzeppelin-solidity/contracts/math/SafeMath.sol\\\";\\n\\nlibrary UnlockingSchedule {\\n    using SafeMath for uint256;\\n\\n    function getUnlockedAmount(\\n        uint256 _now,\\n        uint256 grantedAmount,\\n        uint256 duration,\\n        uint256 start,\\n        uint256 cliff\\n    ) internal pure returns (uint256) {\\n        bool cliffNotReached = _now < cliff;\\n        if (cliffNotReached) { return 0; }\\n\\n        uint256 timeElapsed = _now.sub(start);\\n\\n        bool unlockingPeriodFinished = timeElapsed >= duration;\\n        if (unlockingPeriodFinished) { return grantedAmount; }\\n\\n        return grantedAmount.mul(timeElapsed).div(duration);\\n    }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/GrantStakingPolicy.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\n/// @title GrantStakingPolicy\\n/// @notice A staking policy defines the function `getStakeableAmount`\\n/// which calculates how many tokens may be staked from a token grant.\\ncontract GrantStakingPolicy {\\n    function getStakeableAmount(\\n        uint256 _now,\\n        uint256 grantedAmount,\\n        uint256 duration,\\n        uint256 start,\\n        uint256 cliff,\\n        uint256 withdrawn) public view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/TokenStaking.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"./StakeDelegatable.sol\\\";\\nimport \\\"./utils/UintArrayUtils.sol\\\";\\nimport \\\"./utils/PercentUtils.sol\\\";\\nimport \\\"./utils/LockUtils.sol\\\";\\nimport \\\"./KeepRegistry.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\n/// @title AuthorityDelegator\\n/// @notice An operator contract can delegate authority to other operator\\n/// contracts by implementing the AuthorityDelegator interface.\\n///\\n/// To delegate authority,\\n/// the recipient of delegated authority must call `claimDelegatedAuthority`,\\n/// specifying the contract it wants delegated authority from.\\n/// The staking contract calls `delegator.__isRecognized(recipient)`\\n/// and if the call returns `true`,\\n/// the named delegator contract is set as the recipient's authority delegator.\\n/// Any future checks of registry approval or per-operator authorization\\n/// will transparently mirror the delegator's status.\\n///\\n/// Authority can be delegated recursively;\\n/// an operator contract receiving delegated authority\\n/// can recognize other operator contracts as recipients of its authority.\\ninterface AuthorityDelegator {\\n    function __isRecognized(address delegatedAuthorityRecipient) external returns (bool);\\n}\\n\\n/// @title TokenStaking\\n/// @notice A token staking contract for a specified standard ERC20Burnable token.\\n/// A holder of the specified token can stake delegate its tokens to this contract\\n/// and recover the stake after undelegation period is over.\\ncontract TokenStaking is StakeDelegatable {\\n    using UintArrayUtils for uint256[];\\n    using PercentUtils for uint256;\\n    using LockUtils for LockUtils.LockSet;\\n    using SafeERC20 for ERC20Burnable;\\n\\n    // Minimum amount of KEEP that allows sMPC cluster client to participate in\\n    // the Keep network. Expressed as number with 18-decimal places.\\n    // Initial minimum stake is higher than the final and lowered periodically based\\n    // on the amount of steps and the length of the minimum stake schedule in seconds.\\n    uint256 public minimumStakeScheduleStart;\\n    uint256 public constant minimumStakeSchedule = 86400 * 365 * 2; // 2 years in seconds (seconds per day * days in a year * years)\\n    uint256 public constant minimumStakeSteps = 10;\\n    uint256 public constant minimumStakeBase = 10000 * 1e18;\\n\\n    event Staked(address indexed from, uint256 value);\\n    event Undelegated(address indexed operator, uint256 undelegatedAt);\\n    event RecoveredStake(address operator, uint256 recoveredAt);\\n    event TokensSlashed(address indexed operator, uint256 amount);\\n    event TokensSeized(address indexed operator, uint256 amount);\\n    event StakeLocked(address indexed operator, address lockCreator, uint256 until);\\n    event LockReleased(address indexed operator, address lockCreator);\\n    event ExpiredLockReleased(address indexed operator, address lockCreator);\\n\\n    // Registry contract with a list of approved operator contracts and upgraders.\\n    KeepRegistry public registry;\\n\\n    // Authorized operator contracts.\\n    mapping(address => mapping (address => bool)) internal authorizations;\\n\\n    // Locks placed on the operator.\\n    // `operatorLocks[operator]` returns all locks placed on the operator.\\n    // Each authorized operator contract can place one lock on an operator.\\n    mapping(address => LockUtils.LockSet) internal operatorLocks;\\n    uint256 public constant maximumLockDuration = 86400 * 200; // 200 days in seconds\\n\\n    // Granters of delegated authority to operator contracts.\\n    // E.g. keep factories granting delegated authority to keeps.\\n    // `delegatedAuthority[keep] = factory`\\n    mapping(address => address) internal delegatedAuthority;\\n\\n    modifier onlyApprovedOperatorContract(address operatorContract) {\\n        require(\\n            registry.isApprovedOperatorContract(getAuthoritySource(operatorContract)),\\n            \\\"Operator contract is not approved\\\"\\n        );\\n        _;\\n    }\\n\\n    /// @notice Creates a token staking contract for a provided Standard ERC20Burnable token.\\n    /// @param _tokenAddress Address of a token that will be linked to this contract.\\n    /// @param _registry Address of a keep registry that will be linked to this contract.\\n    /// @param _initializationPeriod To avoid certain attacks on work selection, recently created\\n    /// operators must wait for a specific period of time before being eligible for work selection.\\n    /// @param _undelegationPeriod The staking contract guarantees that an undelegated operator\u2019s\\n    /// stakes will stay locked for a period of time after undelegation, and thus available as\\n    /// collateral for any work the operator is engaged in.\\n    constructor(\\n        address _tokenAddress,\\n        address _registry,\\n        uint256 _initializationPeriod,\\n        uint256 _undelegationPeriod\\n    ) public {\\n        require(_tokenAddress != address(0x0), \\\"Token address can't be zero.\\\");\\n        token = ERC20Burnable(_tokenAddress);\\n        registry = KeepRegistry(_registry);\\n        initializationPeriod = _initializationPeriod;\\n        undelegationPeriod = _undelegationPeriod;\\n        minimumStakeScheduleStart = block.timestamp;\\n    }\\n\\n    /// @notice Returns minimum amount of KEEP that allows sMPC cluster client to\\n    /// participate in the Keep network. Expressed as number with 18-decimal places.\\n    /// Initial minimum stake is higher than the final and lowered periodically based\\n    /// on the amount of steps and the length of the minimum stake schedule in seconds.\\n    function minimumStake() public view returns (uint256) {\\n        if (block.timestamp < minimumStakeScheduleStart.add(minimumStakeSchedule)) {\\n            uint256 currentStep = minimumStakeSteps.mul(\\n                block.timestamp.sub(minimumStakeScheduleStart)\\n            ).div(minimumStakeSchedule);\\n            return minimumStakeBase.mul(minimumStakeSteps.sub(currentStep));\\n        }\\n        return minimumStakeBase;\\n    }\\n\\n    /// @notice Receives approval of token transfer and stakes the approved amount.\\n    /// @dev Makes sure provided token contract is the same one linked to this contract.\\n    /// @param _from The owner of the tokens who approved them to transfer.\\n    /// @param _value Approved amount for the transfer and stake.\\n    /// @param _token Token contract address.\\n    /// @param _extraData Data for stake delegation. This byte array must have\\n    /// the following values concatenated:\\n    /// - Beneficiary address (20 bytes)\\n    /// - Operator address (20 bytes)\\n    /// - Authorizer address (20 bytes)\\n    function receiveApproval(address _from, uint256 _value, address _token, bytes memory _extraData) public {\\n        require(ERC20Burnable(_token) == token, \\\"Token contract must be the same one linked to this contract.\\\");\\n        require(_value >= minimumStake(), \\\"Tokens amount must be greater than the minimum stake\\\");\\n        require(_extraData.length == 60, \\\"Stake delegation data must be provided.\\\");\\n\\n        address payable beneficiary = address(uint160(_extraData.toAddress(0)));\\n        address operator = _extraData.toAddress(20);\\n        require(operators[operator].owner == address(0), \\\"Operator address is already in use.\\\");\\n        address authorizer = _extraData.toAddress(40);\\n\\n        // Transfer tokens to this contract.\\n        token.safeTransferFrom(_from, address(this), _value);\\n\\n        operators[operator] = Operator(\\n            OperatorParams.pack(_value, block.timestamp, 0),\\n            _from,\\n            beneficiary,\\n            authorizer\\n        );\\n        ownerOperators[_from].push(operator);\\n\\n        emit Staked(operator, _value);\\n    }\\n\\n    /// @notice Cancels stake of tokens within the operator initialization period\\n    /// without being subjected to the token lockup for the undelegation period.\\n    /// This can be used to undo mistaken delegation to the wrong operator address.\\n    /// @param _operator Address of the stake operator.\\n    function cancelStake(address _operator) public {\\n        address owner = operators[_operator].owner;\\n        require(\\n            msg.sender == _operator ||\\n            msg.sender == owner, \\\"Only operator or the owner of the stake can cancel the delegation.\\\"\\n        );\\n        uint256 operatorParams = operators[_operator].packedParams;\\n\\n        require(\\n            !_isInitialized(operatorParams),\\n            \\\"Initialization period is over\\\"\\n        );\\n\\n        uint256 amount = operatorParams.getAmount();\\n        operators[_operator].packedParams = operatorParams.setAmount(0);\\n\\n        token.safeTransfer(owner, amount);\\n    }\\n\\n    /// @notice Undelegates staked tokens. You will be able to recover your stake by calling\\n    /// `recoverStake()` with operator address once undelegation period is over.\\n    /// @param _operator Address of the stake operator.\\n    function undelegate(address _operator) public {\\n        undelegateAt(_operator, block.timestamp);\\n    }\\n\\n    /// @notice Set an undelegation time for staked tokens.\\n    /// Undelegation will begin at the specified timestamp.\\n    /// You will be able to recover your stake by calling\\n    /// `recoverStake()` with operator address once undelegation period is over.\\n    /// @param _operator Address of the stake operator.\\n    /// @param _undelegationTimestamp The timestamp undelegation is to start at.    \\n    function undelegateAt(\\n        address _operator,\\n        uint256 _undelegationTimestamp\\n    ) public {\\n        address owner = operators[_operator].owner;\\n        bool sentByOwner = msg.sender == owner;\\n        require(\\n            msg.sender == _operator ||\\n            sentByOwner, \\\"Only operator or the owner of the stake can undelegate.\\\"\\n        );\\n        require(\\n            _undelegationTimestamp >= block.timestamp,\\n            \\\"May not set undelegation timestamp in the past\\\"\\n        );\\n        uint256 oldParams = operators[_operator].packedParams;\\n        uint256 existingCreationTimestamp = oldParams.getCreationTimestamp();\\n        uint256 existingUndelegationTimestamp = oldParams.getUndelegationTimestamp();\\n        require(\\n            _undelegationTimestamp > existingCreationTimestamp.add(initializationPeriod),\\n            \\\"Cannot undelegate in initialization period, use cancelStake instead\\\"\\n        );\\n        require(\\n            // Undelegation not in progress OR\\n            existingUndelegationTimestamp == 0 ||\\n            // Undelegating sooner than previously set time OR\\n            existingUndelegationTimestamp > _undelegationTimestamp ||\\n            // Owner may override\\n            sentByOwner,\\n            \\\"Only the owner may postpone previously set undelegation\\\"\\n        );\\n        uint256 newParams = oldParams.setUndelegationTimestamp(_undelegationTimestamp);\\n        operators[_operator].packedParams = newParams;\\n        emit Undelegated(_operator, _undelegationTimestamp);\\n    }\\n\\n    /// @notice Recovers staked tokens and transfers them back to the owner.\\n    /// Recovering tokens can only be performed when the operator finished\\n    /// undelegating.\\n    /// @param _operator Operator address.\\n    function recoverStake(address _operator) public {\\n        uint256 operatorParams = operators[_operator].packedParams;\\n        require(\\n            operatorParams.getUndelegationTimestamp() != 0,\\n            \\\"Can not recover without first undelegating\\\"\\n        );\\n        require(\\n            _isUndelegatingFinished(operatorParams),\\n            \\\"Can not recover stake before undelegation period is over.\\\"\\n        );\\n\\n        require(\\n            !isStakeLocked(_operator),\\n            \\\"Can not recover locked stake\\\"\\n        );\\n\\n        address owner = operators[_operator].owner;\\n        uint256 amount = operatorParams.getAmount();\\n\\n        operators[_operator].packedParams = operatorParams.setAmount(0);\\n\\n        token.safeTransfer(owner, amount);\\n        emit RecoveredStake(_operator, block.timestamp);\\n    }\\n\\n    /// @notice Gets stake delegation info for the given operator.\\n    /// @param _operator Operator address.\\n    /// @return amount The amount of tokens the given operator delegated.\\n    /// @return createdAt The time when the stake has been delegated.\\n    /// @return undelegatedAt The time when undelegation has been requested.\\n    /// If undelegation has not been requested, 0 is returned.\\n    function getDelegationInfo(address _operator)\\n    public view returns (uint256 amount, uint256 createdAt, uint256 undelegatedAt) {\\n        return operators[_operator].packedParams.unpack();\\n    }\\n\\n    /// @notice Locks given operator stake for the specified duration.\\n    /// Locked stake may not be recovered until the lock expires or is released,\\n    /// even if the normal undelegation period has passed.\\n    /// Only previously authorized operator contract can lock the stake.\\n    /// @param operator Operator address.\\n    /// @param duration Lock duration in seconds.\\n    function lockStake(\\n        address operator,\\n        uint256 duration\\n    ) public onlyApprovedOperatorContract(msg.sender) {\\n        require(\\n            isAuthorizedForOperator(operator, msg.sender),\\n            \\\"Not authorized\\\"\\n        );\\n        require(duration <= maximumLockDuration, \\\"Lock duration too long\\\");\\n\\n        uint256 operatorParams = operators[operator].packedParams;\\n\\n        require(\\n            _isInitialized(operatorParams),\\n            \\\"Operator stake must be active\\\"\\n        );\\n        require(\\n            !_isUndelegating(operatorParams),\\n            \\\"Operator undelegating\\\"\\n        );\\n\\n        operatorLocks[operator].setLock(\\n            msg.sender,\\n            uint96(block.timestamp.add(duration))\\n        );\\n        emit StakeLocked(operator, msg.sender, block.timestamp.add(duration));\\n    }\\n\\n    /// @notice Removes a lock the caller had previously placed on the operator.\\n    /// @dev Only for operator contracts.\\n    /// To remove expired or disabled locks, use `releaseExpiredLocks`.\\n    /// The authorization check ensures that the caller must have been able\\n    /// to place a lock on the operator sometime in the past.\\n    /// We don't need to check for current approval status of the caller\\n    /// because unlocking stake cannot harm the operator\\n    /// nor interfere with other operator contracts.\\n    /// Therefore even disabled operator contracts may freely unlock stake.\\n    /// @param operator Operator address.\\n    function unlockStake(\\n        address operator\\n    ) public {\\n        require(\\n            isAuthorizedForOperator(operator, msg.sender),\\n            \\\"Not authorized\\\"\\n        );\\n        operatorLocks[operator].releaseLock(msg.sender);\\n        emit LockReleased(operator, msg.sender);\\n    }\\n\\n    /// @notice Removes the lock of the specified operator contract\\n    /// if the lock has expired or the contract has been disabled.\\n    /// @dev Necessary for removing locks placed by contracts\\n    /// that have been disabled by the panic button.\\n    /// Also applicable to prevent inadvertent DoS of `recoverStake`\\n    /// if too many operator contracts have failed to clean up their locks.\\n    function releaseExpiredLock(\\n        address operator,\\n        address operatorContract\\n    ) public {\\n        LockUtils.LockSet storage locks = operatorLocks[operator];\\n        require(\\n            locks.contains(operatorContract),\\n            \\\"No matching lock present\\\"\\n        );\\n        bool expired = block.timestamp >= locks.getLockTime(operatorContract);\\n        bool disabled = !registry.isApprovedOperatorContract(operatorContract);\\n        require(\\n            expired || disabled,\\n            \\\"Lock still active and valid\\\"\\n        );\\n        locks.releaseLock(operatorContract);\\n        emit ExpiredLockReleased(operator, operatorContract);\\n    }\\n\\n    /// @notice Check whether the operator has any active locks\\n    /// that haven't expired yet\\n    /// and whose creators aren't disabled by the panic button.\\n    function isStakeLocked(\\n        address operator\\n    ) public view returns (bool) {\\n        LockUtils.Lock[] storage _locks = operatorLocks[operator].locks;\\n        LockUtils.Lock memory lock;\\n        for (uint i = 0; i < _locks.length; i++) {\\n            lock = _locks[i];\\n            if (block.timestamp < lock.expiresAt) {\\n                if (registry.isApprovedOperatorContract(lock.creator)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /// @notice Get the locks placed on the operator.\\n    /// @return creators The addresses of operator contracts\\n    /// that have placed a lock on the operator.\\n    /// @return expirations The expiration times\\n    /// of the locks placed on the operator.\\n    function getLocks(address operator)\\n        public\\n        view\\n        returns (address[] memory creators, uint256[] memory expirations) {\\n        uint256 lockCount = operatorLocks[operator].locks.length;\\n        creators = new address[](lockCount);\\n        expirations = new uint256[](lockCount);\\n        LockUtils.Lock memory lock;\\n        for (uint i = 0; i < lockCount; i++) {\\n            lock = operatorLocks[operator].locks[i];\\n            creators[i] = lock.creator;\\n            expirations[i] = lock.expiresAt;\\n        }\\n    }\\n\\n    /// @notice Slash provided token amount from every member in the misbehaved\\n    /// operators array and burn 100% of all the tokens.\\n    /// @param amountToSlash Token amount to slash from every misbehaved operator.\\n    /// @param misbehavedOperators Array of addresses to seize the tokens from.\\n    function slash(uint256 amountToSlash, address[] memory misbehavedOperators)\\n        public\\n        onlyApprovedOperatorContract(msg.sender) {\\n\\n        uint256 totalAmountToBurn = 0;\\n        address authoritySource = getAuthoritySource(msg.sender);\\n        for (uint i = 0; i < misbehavedOperators.length; i++) {\\n            address operator = misbehavedOperators[i];\\n            require(authorizations[authoritySource][operator], \\\"Not authorized\\\");\\n\\n            uint256 operatorParams = operators[operator].packedParams;\\n            require(\\n                _isInitialized(operatorParams),\\n                \\\"Operator stake must be active\\\"\\n            );\\n\\n            require(\\n                !_isStakeReleased(operator, operatorParams, msg.sender),\\n                \\\"Stake is released\\\"\\n            );\\n\\n            uint256 currentAmount = operatorParams.getAmount();\\n\\n            if (currentAmount < amountToSlash) {\\n                totalAmountToBurn = totalAmountToBurn.add(currentAmount);\\n\\n                uint256 newAmount = 0;\\n                operators[operator].packedParams = operatorParams.setAmount(newAmount);\\n                emit TokensSlashed(operator, currentAmount);\\n            } else {\\n                totalAmountToBurn = totalAmountToBurn.add(amountToSlash);\\n\\n                uint256 newAmount = currentAmount.sub(amountToSlash);\\n                operators[operator].packedParams = operatorParams.setAmount(newAmount);\\n                emit TokensSlashed(operator, amountToSlash);\\n            }\\n        }\\n\\n        token.burn(totalAmountToBurn);\\n    }\\n\\n    /// @notice Seize provided token amount from every member in the misbehaved\\n    /// operators array. The tattletale is rewarded with 5% of the total seized\\n    /// amount scaled by the reward adjustment parameter and the rest 95% is burned.\\n    /// @param amountToSeize Token amount to seize from every misbehaved operator.\\n    /// @param rewardMultiplier Reward adjustment in percentage. Min 1% and 100% max.\\n    /// @param tattletale Address to receive the 5% reward.\\n    /// @param misbehavedOperators Array of addresses to seize the tokens from.\\n    function seize(\\n        uint256 amountToSeize,\\n        uint256 rewardMultiplier,\\n        address tattletale,\\n        address[] memory misbehavedOperators\\n    ) public onlyApprovedOperatorContract(msg.sender) {\\n        uint256 totalAmountToBurn = 0;\\n        address authoritySource = getAuthoritySource(msg.sender);\\n        for (uint i = 0; i < misbehavedOperators.length; i++) {\\n            address operator = misbehavedOperators[i];\\n            require(authorizations[authoritySource][operator], \\\"Not authorized\\\");\\n\\n            uint256 operatorParams = operators[operator].packedParams;\\n            require(\\n                _isInitialized(operatorParams),\\n                \\\"Operator stake must be active\\\"\\n            );\\n\\n            require(\\n                !_isStakeReleased(operator, operatorParams, msg.sender),\\n                \\\"Stake is released\\\"\\n            );\\n\\n            uint256 currentAmount = operatorParams.getAmount();\\n\\n            if (currentAmount < amountToSeize) {\\n                totalAmountToBurn = totalAmountToBurn.add(currentAmount);\\n\\n                uint256 newAmount = 0;\\n                operators[operator].packedParams = operatorParams.setAmount(newAmount);\\n                emit TokensSeized(operator, currentAmount);\\n            } else {\\n                totalAmountToBurn = totalAmountToBurn.add(amountToSeize);\\n\\n                uint256 newAmount = currentAmount.sub(amountToSeize);\\n                operators[operator].packedParams = operatorParams.setAmount(newAmount);\\n                emit TokensSeized(operator, amountToSeize);\\n            }\\n        }\\n\\n        uint256 tattletaleReward = (totalAmountToBurn.percent(5)).percent(rewardMultiplier);\\n\\n        token.safeTransfer(tattletale, tattletaleReward);\\n        token.burn(totalAmountToBurn.sub(tattletaleReward));\\n    }\\n\\n    /// @notice Authorizes operator contract to access staked token balance of\\n    /// the provided operator. Can only be executed by stake operator authorizer.\\n    /// Contracts using delegated authority\\n    /// cannot be authorized with `authorizeOperatorContract`.\\n    /// Instead, authorize `getAuthoritySource(_operatorContract)`.\\n    /// @param _operator address of stake operator.\\n    /// @param _operatorContract address of operator contract.\\n    function authorizeOperatorContract(address _operator, address _operatorContract)\\n        public\\n        onlyOperatorAuthorizer(_operator)\\n        onlyApprovedOperatorContract(_operatorContract) {\\n        require(\\n            getAuthoritySource(_operatorContract) == _operatorContract,\\n            \\\"Contract uses delegated authority\\\"\\n        );\\n        authorizations[_operatorContract][_operator] = true;\\n    }\\n\\n    /// @notice Checks if operator contract has access to the staked token balance of\\n    /// the provided operator.\\n    /// @param _operator address of stake operator.\\n    /// @param _operatorContract address of operator contract.\\n    function isAuthorizedForOperator(address _operator, address _operatorContract) public view returns (bool) {\\n        return authorizations[getAuthoritySource(_operatorContract)][_operator];\\n    }\\n\\n    /// @notice Gets the eligible stake balance of the specified address.\\n    /// An eligible stake is a stake that passed the initialization period\\n    /// and is not currently undelegating. Also, the operator had to approve\\n    /// the specified operator contract.\\n    ///\\n    /// Operator with a minimum required amount of eligible stake can join the\\n    /// network and participate in new work selection.\\n    ///\\n    /// @param _operator address of stake operator.\\n    /// @param _operatorContract address of operator contract.\\n    /// @return an uint256 representing the eligible stake balance.\\n    function eligibleStake(\\n        address _operator,\\n        address _operatorContract\\n    ) public view returns (uint256 balance) {\\n        bool isAuthorized = isAuthorizedForOperator(_operator, _operatorContract);\\n\\n        uint256 operatorParams = operators[_operator].packedParams;\\n\\n        bool isActive = _isInitialized(operatorParams);\\n        // `undelegatedAt` may be set to a time in the future,\\n        // to schedule undelegation in advance.\\n        // In this case the operator is still eligible\\n        // until the timestamp `undelegatedAt`.\\n        bool isUndelegating = _isUndelegating(operatorParams);\\n\\n        if (isAuthorized && isActive && !isUndelegating) {\\n            balance = operatorParams.getAmount();\\n        }\\n    }\\n\\n    /// @notice Gets the active stake balance of the specified address.\\n    /// An active stake is a stake that passed the initialization period,\\n    /// and may be in the process of undelegation\\n    /// but has not been released yet,\\n    /// either because the undelegation period is not over,\\n    /// or because the operator contract has an active lock on the operator.\\n    /// Also, the operator had to approve the specified operator contract.\\n    ///\\n    /// The difference between eligible stake is that active stake does not make\\n    /// the operator eligible for work selection but it may be still finishing\\n    /// earlier work until the stake is released.\\n    /// Operator with a minimum required\\n    /// amount of active stake can join the network but cannot be selected to any\\n    /// new work.\\n    ///\\n    /// @param _operator address of stake operator.\\n    /// @param _operatorContract address of operator contract.\\n    /// @return an uint256 representing the eligible stake balance.\\n    function activeStake(\\n        address _operator,\\n        address _operatorContract\\n    ) public view returns (uint256 balance) {\\n        bool isAuthorized = isAuthorizedForOperator(_operator, _operatorContract);\\n\\n        uint256 operatorParams = operators[_operator].packedParams;\\n\\n        bool isActive = _isInitialized(operatorParams);\\n\\n        bool stakeReleased = _isStakeReleased(\\n            _operator,\\n            operatorParams,\\n            _operatorContract\\n        );\\n\\n        if (isAuthorized && isActive && !stakeReleased) {\\n            balance = operatorParams.getAmount();\\n        }\\n    }\\n\\n    /// @notice Checks if the specified account has enough active stake to become\\n    /// network operator and that the specified operator contract has been\\n    /// authorized for potential slashing.\\n    ///\\n    /// Having the required minimum of active stake makes the operator eligible\\n    /// to join the network. If the active stake is not currently undelegating,\\n    /// operator is also eligible for work selection.\\n    ///\\n    /// @param staker Staker's address\\n    /// @param operatorContract Operator contract's address\\n    /// @return True if has enough active stake to participate in the network,\\n    /// false otherwise.\\n    function hasMinimumStake(\\n        address staker,\\n        address operatorContract\\n    ) public view returns(bool) {\\n        return activeStake(staker, operatorContract) >= minimumStake();\\n    }\\n\\n    /// @notice Grant the sender the same authority as `delegatedAuthoritySource`\\n    /// @dev If `delegatedAuthoritySource` is an approved operator contract\\n    /// and recognizes the claimant,\\n    /// this relationship will be recorded in `delegatedAuthority`.\\n    /// Later, the claimant can slash, seize, place locks etc.\\n    /// on operators that have authorized the `delegatedAuthoritySource`.\\n    /// If the `delegatedAuthoritySource` is disabled with the panic button,\\n    /// any recipients of delegated authority from it will also be disabled.\\n    function claimDelegatedAuthority(\\n        address delegatedAuthoritySource\\n    ) public onlyApprovedOperatorContract(delegatedAuthoritySource) {\\n        require(\\n            AuthorityDelegator(delegatedAuthoritySource).__isRecognized(msg.sender),\\n            \\\"Unrecognized claimant\\\"\\n        );\\n        delegatedAuthority[msg.sender] = delegatedAuthoritySource;\\n    }\\n\\n    /// @notice Get the source of the operator contract's authority.\\n    /// If the contract uses delegated authority,\\n    /// returns the original source of the delegated authority.\\n    /// If the contract doesn't use delegated authority,\\n    /// returns the contract itself.\\n    /// Authorize `getAuthoritySource(operatorContract)`\\n    /// to grant `operatorContract` the authority to penalize an operator.\\n    function getAuthoritySource(\\n        address operatorContract\\n    ) public view returns (address) {\\n        address delegatedAuthoritySource = delegatedAuthority[operatorContract];\\n        if (delegatedAuthoritySource == address(0)) {\\n            return operatorContract;\\n        }\\n        return getAuthoritySource(delegatedAuthoritySource);\\n    }\\n\\n    /// @notice Is the operator with the given params initialized\\n    function _isInitialized(uint256 _operatorParams)\\n        internal view returns (bool) {\\n        uint256 createdAt = _operatorParams.getCreationTimestamp();\\n        return block.timestamp > createdAt.add(initializationPeriod);\\n    }\\n\\n    /// @notice Is the operator with the given params undelegating\\n    function _isUndelegating(uint256 _operatorParams)\\n        internal view returns (bool) {\\n        uint256 undelegatedAt = _operatorParams.getUndelegationTimestamp();\\n        return (undelegatedAt != 0) && (block.timestamp > undelegatedAt);\\n    }\\n\\n    /// @notice Has the operator with the given params finished undelegating\\n    function _isUndelegatingFinished(uint256 _operatorParams)\\n        internal view returns (bool) {\\n        uint256 undelegatedAt = _operatorParams.getUndelegationTimestamp();\\n        uint256 finishedAt = undelegatedAt.add(undelegationPeriod);\\n        return (undelegatedAt != 0) && (block.timestamp > finishedAt);\\n    }\\n\\n    /// @notice Get whether the operator's stake is released\\n    /// as far as the operator contract is concerned.\\n    /// If the operator contract has a lock on the operator,\\n    /// the operator's stake is be released when the lock expires.\\n    /// Otherwise the stake is released when the operator finishes undelegating.\\n    function _isStakeReleased(\\n        address _operator,\\n        uint256 _operatorParams,\\n        address _operatorContract\\n    ) internal view returns (bool) {\\n        if (!_isUndelegatingFinished(_operatorParams)) {\\n            return false;\\n        }\\n        // Undelegating finished, so check locks\\n        LockUtils.LockSet storage locks = operatorLocks[_operator];\\n        // `getLockTime` returns 0 if the lock doesn't exist,\\n        // thus we don't need to check for its presence separately.\\n        return block.timestamp >= locks.getLockTime(_operatorContract);\\n    }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/StakeDelegatable.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/math/SafeMath.sol\\\";\\nimport \\\"./utils/BytesLib.sol\\\";\\nimport \\\"./utils/AddressArrayUtils.sol\\\";\\nimport \\\"./utils/OperatorParams.sol\\\";\\n\\n\\n/// @title Stake Delegatable\\n/// @notice A base contract to allow stake delegation for staking contracts.\\ncontract StakeDelegatable {\\n    using SafeMath for uint256;\\n    using SafeERC20 for ERC20Burnable;\\n    using BytesLib for bytes;\\n    using AddressArrayUtils for address[];\\n    using OperatorParams for uint256;\\n\\n    ERC20Burnable public token;\\n\\n    uint256 public initializationPeriod;\\n    uint256 public undelegationPeriod;\\n\\n    mapping(address => address[]) public ownerOperators;\\n\\n    mapping(address => Operator) public operators;\\n\\n    struct Operator {\\n        uint256 packedParams;\\n        address owner;\\n        address payable beneficiary;\\n        address authorizer;\\n    }\\n\\n    modifier onlyOperatorAuthorizer(address _operator) {\\n        require(\\n            operators[_operator].authorizer == msg.sender,\\n            \\\"Not operator authorizer\\\"\\n        );\\n        _;\\n    }\\n\\n    /// @notice Gets the list of operators of the specified address.\\n    /// @return An array of addresses.\\n    function operatorsOf(address _address) public view returns (address[] memory) {\\n        return ownerOperators[_address];\\n    }\\n\\n    /// @notice Gets the stake balance of the specified address.\\n    /// @param _address The address to query the balance of.\\n    /// @return An uint256 representing the amount staked by the passed address.\\n    function balanceOf(address _address) public view returns (uint256 balance) {\\n        return operators[_address].packedParams.getAmount();\\n    }\\n\\n    /// @notice Gets the stake owner for the specified operator address.\\n    /// @return Stake owner address.\\n    function ownerOf(address _operator) public view returns (address) {\\n        return operators[_operator].owner;\\n    }\\n\\n    /// @notice Gets the beneficiary for the specified operator address.\\n    /// @return Beneficiary address.\\n    function beneficiaryOf(address _operator) public view returns (address payable) {\\n        return operators[_operator].beneficiary;\\n    }\\n\\n    /// @notice Gets the authorizer for the specified operator address.\\n    /// @return Authorizer address.\\n    function authorizerOf(address _operator) public view returns (address) {\\n        return operators[_operator].authorizer;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\ncontract ERC20Burnable is Context, ERC20 {\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev See {ERC20-_burnFrom}.\\n     */\\n    function burnFrom(address account, uint256 amount) public {\\n        _burnFrom(account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/GSN/Context.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor () internal { }\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20Mintable}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for `sender`'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n     /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller's allowance.\\n     *\\n     * See {_burn} and {_approve}.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal {\\n        _burn(account, amount);\\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \\\"ERC20: burn amount exceeds allowance\\\"));\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/utils/Address.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.5;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\n     * execution of a contract's constructor, its address will be reported as\\n     * not containing a contract.\\n     *\\n     * IMPORTANT: It is unsafe to assume that an address for which this\\n     * function returns false is an externally-owned account (EOA) and not a\\n     * contract.\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != 0x0 && codehash != accountHash);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function toPayable(address account) internal pure returns (address payable) {\\n        return address(uint160(account));\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-call-value\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/utils/BytesLib.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\n/*\\nVerison pulled from https://github.com/summa-tx/bitcoin-spv/blob/2535e4edaeaac4b2b095903fce684ae1c05761bc/solidity/contracts/BytesLib.sol\\n*/\\n\\n/*\\nhttps://github.com/GNSPS/solidity-bytes-utils/\\nThis is free and unencumbered software released into the public domain.\\nAnyone is free to copy, modify, publish, use, compile, sell, or\\ndistribute this software, either in source code form or as a compiled\\nbinary, for any purpose, commercial or non-commercial, and by any\\nmeans.\\nIn jurisdictions that recognize copyright laws, the author or authors\\nof this software dedicate any and all copyright interest in the\\nsoftware to the public domain. We make this dedication for the benefit\\nof the public at large and to the detriment of our heirs and\\nsuccessors. We intend this dedication to be an overt act of\\nrelinquishment in perpetuity of all present and future rights to this\\nsoftware under copyright law.\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND,\\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\\nIN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\\nOTHER DEALINGS IN THE SOFTWARE.\\nFor more information, please refer to <https://unlicense.org>\\n*/\\n\\n\\n/** @title BytesLib **/\\n/** @author https://github.com/GNSPS **/\\n\\nlibrary BytesLib {\\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(0x40, and(\\n                add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n                not(31) // Round down to the nearest 32 bytes.\\n            ))\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes_slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes_slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                        ),\\n                        // and now shift left the number of bytes to\\n                        // leave space for the length in the slot\\n                        exp(0x100, sub(32, newlength))\\n                        ),\\n                        // increase length by the double of the memory\\n                        // bytes length\\n                        mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes_slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(\\n                            fslot,\\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\\n                    ),\\n                    and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes_slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(bytes memory _bytes, uint _start, uint _length) internal  pure returns (bytes memory res) {\\n        uint _end = _start + _length;\\n        require(_end > _start && _bytes.length >= _end, \\\"Slice out of bounds\\\");\\n\\n        assembly {\\n            // Alloc bytes array with additional 32 bytes afterspace and assign it's size\\n            res := mload(0x40)\\n            mstore(0x40, add(add(res, 64), _length))\\n            mstore(res, _length)\\n\\n            // Compute distance between source and destination pointers\\n            let diff := sub(res, add(_bytes, _start))\\n\\n            for {\\n                let src := add(add(_bytes, 32), _start)\\n                let end := add(src, _length)\\n            } lt(src, end) {\\n                src := add(src, 32)\\n            } {\\n                mstore(add(src, diff), mload(src))\\n            }\\n        }\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\\n        uint _totalLen = _start + 20;\\n        require(_totalLen > _start && _bytes.length >= _totalLen, \\\"Address conversion out of bounds.\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\\n        require(_bytes.length >= (_start + 1), \\\"Uint8 conversion out of bounds.\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\\n        uint _totalLen = _start + 32;\\n        require(_totalLen > _start && _bytes.length >= _totalLen, \\\"Uint conversion out of bounds.\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                    // the next line is the loop condition:\\n                    // while(uint(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes_slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes_slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint(mc < end) + cb == 2)\\n                        for {} eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function toBytes32(bytes memory _source) pure internal returns (bytes32 result) {\\n        if (_source.length == 0) {\\n            return 0x0;\\n        }\\n\\n        assembly {\\n            result := mload(add(_source, 32))\\n        }\\n    }\\n\\n    function keccak256Slice(bytes memory _bytes, uint _start, uint _length) pure internal returns (bytes32 result) {\\n        uint _end = _start + _length;\\n        require(_end > _start && _bytes.length >= _end, \\\"Slice out of bounds\\\");\\n\\n        assembly {\\n            result := keccak256(add(add(_bytes, 32), _start), _length)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/utils/AddressArrayUtils.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\n\\nlibrary AddressArrayUtils {\\n\\n    function contains(address[] memory self, address _address)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        for (uint i = 0; i < self.length; i++) {\\n            if (_address == self[i]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function removeAddress(address[] storage self, address _addressToRemove)\\n        internal\\n        returns (address[] storage)\\n    {\\n        for (uint i = 0; i < self.length; i++) {\\n            // If address is found in array.\\n            if (_addressToRemove == self[i]) {\\n                // Delete element at index and shift array.\\n                for (uint j = i; j < self.length-1; j++) {\\n                    self[j] = self[j+1];\\n                }\\n                self.length--;\\n                i--;\\n            }\\n        }\\n        return self;\\n    }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/utils/OperatorParams.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nlibrary OperatorParams {\\n    // OperatorParams packs values that are commonly used together\\n    // into a single uint256 to reduce the cost functions\\n    // like querying eligibility.\\n    //\\n    // An OperatorParams uint256 contains:\\n    // - the operator's staked token amount (uint128)\\n    // - the operator's creation timestamp (uint64)\\n    // - the operator's undelegation timestamp (uint64)\\n    //\\n    // These are packed as [amount | createdAt | undelegatedAt]\\n    //\\n    // Staked KEEP is stored in an uint128,\\n    // which is sufficient because KEEP tokens have 18 decimals (2^60)\\n    // and there will be at most 10^9 KEEP in existence (2^30).\\n    //\\n    // Creation and undelegation times are stored in an uint64 each.\\n    // Thus uint64s would be sufficient for around 3*10^11 years.\\n    uint256 constant TIMESTAMP_WIDTH = 64;\\n    uint256 constant AMOUNT_WIDTH = 128;\\n\\n    uint256 constant TIMESTAMP_MAX = (2**TIMESTAMP_WIDTH) - 1;\\n    uint256 constant AMOUNT_MAX = (2**AMOUNT_WIDTH) - 1;\\n\\n    uint256 constant CREATION_SHIFT = TIMESTAMP_WIDTH;\\n    uint256 constant AMOUNT_SHIFT = 2 * TIMESTAMP_WIDTH;\\n\\n    function pack(\\n        uint256 amount,\\n        uint256 createdAt,\\n        uint256 undelegatedAt\\n    ) internal pure returns (uint256) {\\n        // Check for staked amount overflow.\\n        // We shouldn't actually ever need this.\\n        require(\\n            amount <= AMOUNT_MAX,\\n            \\\"amount uint128 overflow\\\"\\n        );\\n        // Bitwise OR the timestamps together.\\n        // The resulting number is equal or greater than either,\\n        // and tells if we have a bit set outside the 64 available bits.\\n        require(\\n            (createdAt | undelegatedAt) <= TIMESTAMP_MAX,\\n            \\\"timestamp uint64 overflow\\\"\\n        );\\n        uint256 a = amount << AMOUNT_SHIFT;\\n        uint256 c = createdAt << CREATION_SHIFT;\\n        uint256 u = undelegatedAt;\\n        return (a | c | u);\\n    }\\n\\n    function unpack(uint256 packedParams) internal pure returns (\\n        uint256 amount,\\n        uint256 createdAt,\\n        uint256 undelegatedAt\\n    ) {\\n        amount = getAmount(packedParams);\\n        createdAt = getCreationTimestamp(packedParams);\\n        undelegatedAt = getUndelegationTimestamp(packedParams);\\n    }\\n\\n    function getAmount(uint256 packedParams)\\n        internal pure returns (uint256) {\\n        return (packedParams >> AMOUNT_SHIFT) & AMOUNT_MAX;\\n    }\\n\\n    function setAmount(\\n        uint256 packedParams,\\n        uint256 amount\\n    ) internal pure returns (uint256) {\\n        return pack(\\n            amount,\\n            getCreationTimestamp(packedParams),\\n            getUndelegationTimestamp(packedParams)\\n        );\\n    }\\n\\n    function getCreationTimestamp(uint256 packedParams)\\n        internal pure returns (uint256) {\\n        return (packedParams >> CREATION_SHIFT) & TIMESTAMP_MAX;\\n    }\\n\\n    function setCreationTimestamp(\\n        uint256 packedParams,\\n        uint256 creationTimestamp\\n    ) internal pure returns (uint256) {\\n        return pack(\\n            getAmount(packedParams),\\n            creationTimestamp,\\n            getUndelegationTimestamp(packedParams)\\n        );\\n    }\\n\\n    function getUndelegationTimestamp(uint256 packedParams)\\n        internal pure returns (uint256) {\\n        return packedParams & TIMESTAMP_MAX;\\n    }\\n\\n    function setUndelegationTimestamp(\\n        uint256 packedParams,\\n        uint256 undelegationTimestamp\\n    ) internal pure returns (uint256) {\\n        return pack(\\n            getAmount(packedParams),\\n            getCreationTimestamp(packedParams),\\n            undelegationTimestamp\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/utils/UintArrayUtils.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\n\\nlibrary UintArrayUtils {\\n\\n    function removeValue(uint256[] storage self, uint256 _value)\\n        internal\\n        returns(uint256[] storage)\\n    {\\n        for (uint i = 0; i < self.length; i++) {\\n            // If value is found in array.\\n            if (_value == self[i]) {\\n                // Delete element at index and shift array.\\n                for (uint j = i; j < self.length-1; j++) {\\n                    self[j] = self[j+1];\\n                }\\n                self.length--;\\n                i--;\\n            }\\n        }\\n        return self;\\n    }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/utils/PercentUtils.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"openzeppelin-solidity/contracts/math/SafeMath.sol\\\";\\n\\nlibrary PercentUtils {\\n    using SafeMath for uint256;\\n\\n    // Return `b`% of `a`\\n    // 200.percent(40) == 80\\n    // Commutative, works both ways\\n    function percent(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a.mul(b).div(100);\\n    }\\n\\n    // Return `a` as percentage of `b`:\\n    // 80.asPercentOf(200) == 40\\n    function asPercentOf(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a.mul(100).div(b);\\n    }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/utils/LockUtils.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nlibrary LockUtils {\\n    struct Lock {\\n        address creator;\\n        uint96 expiresAt;\\n    }\\n\\n    /// @notice The LockSet is like an array of unique `uint256`s,\\n    /// but additionally supports O(1) membership tests and removals.\\n    /// @dev Because the LockSet relies on a mapping,\\n    /// it can only be used in storage, not in memory.\\n    struct LockSet {\\n        // locks[positions[lock.creator] - 1] = lock\\n        Lock[] locks;\\n        mapping(address => uint256) positions;\\n    }\\n\\n    /// @notice Check whether the LockSet `self` contains a lock by `creator`\\n    function contains(LockSet storage self, address creator)\\n        internal view returns (bool) {\\n        return (self.positions[creator] != 0);\\n    }\\n\\n    function getLockTime(LockSet storage self, address creator)\\n        internal view returns (uint96) {\\n        uint256 positionPlusOne = self.positions[creator];\\n        if (positionPlusOne == 0) { return 0; }\\n        return self.locks[positionPlusOne - 1].expiresAt;\\n    }\\n\\n    /// @notice Set the lock of `creator` to `expiresAt`,\\n    /// overriding the current value if any.\\n    function setLock(\\n        LockSet storage self,\\n        address _creator,\\n        uint96 _expiresAt\\n    ) internal {\\n        uint256 positionPlusOne = self.positions[_creator];\\n        Lock memory lock = Lock(_creator, _expiresAt);\\n        // No existing lock\\n        if (positionPlusOne == 0) {\\n            self.locks.push(lock);\\n            self.positions[_creator] = self.locks.length;\\n        // Existing lock present\\n        } else {\\n            self.locks[positionPlusOne - 1].expiresAt = _expiresAt;\\n        }\\n    }\\n\\n    /// @notice Remove the lock of `creator`.\\n    /// If no lock present, do nothing.\\n    function releaseLock(\\n        LockSet storage self,\\n        address _creator\\n    ) internal {\\n        uint256 positionPlusOne = self.positions[_creator];\\n        if (positionPlusOne != 0) {\\n            uint256 lockCount = self.locks.length;\\n            if (positionPlusOne != lockCount) {\\n                // Not the last lock,\\n                // so we need to move the last lock into the emptied position.\\n                Lock memory lastLock = self.locks[lockCount - 1];\\n                self.locks[positionPlusOne - 1] = lastLock;\\n                self.positions[lastLock.creator] = positionPlusOne;\\n            }\\n            self.locks.length--;\\n            self.positions[_creator] = 0;\\n        }\\n    }\\n\\n    /// @notice Return the locks of the LockSet `self`.\\n    function enumerate(LockSet storage self)\\n        internal view returns (Lock[] memory) {\\n        return self.locks;\\n    }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/KeepRegistry.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\n\\n/// @title KeepRegistry\\n/// @notice Governance owned registry of approved contracts and roles.\\ncontract KeepRegistry {\\n    enum ContractStatus {New, Approved, Disabled}\\n\\n    // Governance role is to enable recovery from key compromise by rekeying\\n    // other roles. Also, it can disable operator contract panic buttons\\n    // permanently.\\n    address public governance;\\n\\n    // Registry Keeper maintains approved operator contracts. Each operator\\n    // contract must be approved before it can be authorized by a staker or\\n    // used by a service contract.\\n    address public registryKeeper;\\n\\n    // Each operator contract has a Panic Button which can disable malicious\\n    // or malfunctioning contract that have been previously approved by the\\n    // Registry Keeper.\\n    //\\n    // New operator contract added to the registry has a default panic button\\n    // value assigned (defaultPanicButton). Panic button for each operator\\n    // contract can be later updated by Governance to individual value.\\n    //\\n    // It is possible to disable panic button for individual contract by\\n    // setting the panic button to zero address. In such case, operator contract\\n    // can not be disabled and is permanently approved in the registry.\\n    mapping(address => address) public panicButtons;\\n\\n    // Default panic button for each new operator contract added to the\\n    // registry. Can be later updated for each contract.\\n    address public defaultPanicButton;\\n\\n    // Each service contract has a Operator Contract Upgrader whose purpose\\n    // is to manage operator contracts for that specific service contract.\\n    // The Operator Contract Upgrader can add new operator contracts to the\\n    // service contract\u2019s operator contract list, and deprecate old ones.\\n    mapping(address => address) public operatorContractUpgraders;\\n\\n    // Operator contract may have a Service Contract Upgrader whose purpose is\\n    // to manage service contracts for that specific operator contract.\\n    // Service Contract Upgrader can add and remove service contracts\\n    // from the list of service contracts approved to work with the operator\\n    // contract. List of service contracts is maintained in the operator\\n    // contract and is optional - not every operator contract needs to have\\n    // a list of service contracts it wants to cooperate with.\\n    mapping(address => address) public serviceContractUpgraders;\\n\\n    // The registry of operator contracts\\n    mapping(address => ContractStatus) public operatorContracts;\\n\\n    event OperatorContractApproved(address operatorContract);\\n    event OperatorContractDisabled(address operatorContract);\\n\\n    event GovernanceUpdated(address governance);\\n    event RegistryKeeperUpdated(address registryKeeper);\\n    event DefaultPanicButtonUpdated(address defaultPanicButton);\\n    event OperatorContractPanicButtonDisabled(address operatorContract);\\n    event OperatorContractPanicButtonUpdated(\\n        address operatorContract,\\n        address panicButton\\n    );\\n    event OperatorContractUpgraderUpdated(\\n        address serviceContract,\\n        address upgrader\\n    );\\n    event ServiceContractUpgraderUpdated(\\n        address operatorContract,\\n        address keeper\\n    );\\n\\n    modifier onlyGovernance() {\\n        require(governance == msg.sender, \\\"Not authorized\\\");\\n        _;\\n    }\\n\\n    modifier onlyRegistryKeeper() {\\n        require(registryKeeper == msg.sender, \\\"Not authorized\\\");\\n        _;\\n    }\\n\\n    modifier onlyPanicButton(address _operatorContract) {\\n        address panicButton = panicButtons[_operatorContract];\\n        require(panicButton != address(0), \\\"Panic button disabled\\\");\\n        require(panicButton == msg.sender, \\\"Not authorized\\\");\\n        _;\\n    }\\n\\n    modifier onlyForNewContract(address _operatorContract) {\\n        require(\\n            isNewOperatorContract(_operatorContract),\\n            \\\"Not a new operator contract\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyForApprovedContract(address _operatorContract) {\\n        require(\\n            isApprovedOperatorContract(_operatorContract),\\n            \\\"Not an approved operator contract\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor() public {\\n        governance = msg.sender;\\n        registryKeeper = msg.sender;\\n        defaultPanicButton = msg.sender;\\n    }\\n\\n    function setGovernance(address _governance) public onlyGovernance {\\n        governance = _governance;\\n        emit GovernanceUpdated(governance);\\n    }\\n\\n    function setRegistryKeeper(address _registryKeeper) public onlyGovernance {\\n        registryKeeper = _registryKeeper;\\n        emit RegistryKeeperUpdated(registryKeeper);\\n    }\\n\\n    function setDefaultPanicButton(address _panicButton) public onlyGovernance {\\n        defaultPanicButton = _panicButton;\\n        emit DefaultPanicButtonUpdated(defaultPanicButton);\\n    }\\n\\n    function setOperatorContractPanicButton(\\n        address _operatorContract,\\n        address _panicButton\\n    ) public onlyForApprovedContract(_operatorContract) onlyGovernance {\\n        require(\\n            panicButtons[_operatorContract] != address(0),\\n            \\\"Disabled panic button cannot be updated\\\"\\n        );\\n        require(\\n            _panicButton != address(0),\\n            \\\"Panic button must be non-zero address\\\"\\n        );\\n\\n        panicButtons[_operatorContract] = _panicButton;\\n\\n        emit OperatorContractPanicButtonUpdated(\\n            _operatorContract,\\n            _panicButton\\n        );\\n    }\\n\\n    function disableOperatorContractPanicButton(address _operatorContract)\\n        public\\n        onlyForApprovedContract(_operatorContract)\\n        onlyGovernance\\n    {\\n        require(\\n            panicButtons[_operatorContract] != address(0),\\n            \\\"Panic button already disabled\\\"\\n        );\\n\\n        panicButtons[_operatorContract] = address(0);\\n\\n        emit OperatorContractPanicButtonDisabled(_operatorContract);\\n    }\\n\\n    function setOperatorContractUpgrader(\\n        address _serviceContract,\\n        address _operatorContractUpgrader\\n    ) public onlyGovernance {\\n        operatorContractUpgraders[_serviceContract] = _operatorContractUpgrader;\\n        emit OperatorContractUpgraderUpdated(\\n            _serviceContract,\\n            _operatorContractUpgrader\\n        );\\n    }\\n\\n    function setServiceContractUpgrader(\\n        address _operatorContract,\\n        address _serviceContractUpgrader\\n    ) public onlyGovernance {\\n        serviceContractUpgraders[_operatorContract] = _serviceContractUpgrader;\\n        emit ServiceContractUpgraderUpdated(\\n            _operatorContract,\\n            _serviceContractUpgrader\\n        );\\n    }\\n\\n    function approveOperatorContract(address operatorContract)\\n        public\\n        onlyForNewContract(operatorContract)\\n        onlyRegistryKeeper\\n    {\\n        operatorContracts[operatorContract] = ContractStatus.Approved;\\n        panicButtons[operatorContract] = defaultPanicButton;\\n        emit OperatorContractApproved(operatorContract);\\n    }\\n\\n    function disableOperatorContract(address operatorContract)\\n        public\\n        onlyForApprovedContract(operatorContract)\\n        onlyPanicButton(operatorContract)\\n    {\\n        operatorContracts[operatorContract] = ContractStatus.Disabled;\\n        emit OperatorContractDisabled(operatorContract);\\n    }\\n\\n    function isNewOperatorContract(address operatorContract)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return operatorContracts[operatorContract] == ContractStatus.New;\\n    }\\n\\n    function isApprovedOperatorContract(address operatorContract)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return operatorContracts[operatorContract] == ContractStatus.Approved;\\n    }\\n\\n    function operatorContractUpgraderFor(address _serviceContract)\\n        public\\n        view\\n        returns (address)\\n    {\\n        return operatorContractUpgraders[_serviceContract];\\n    }\\n\\n    function serviceContractUpgraderFor(address _operatorContract)\\n        public\\n        view\\n        returns (address)\\n    {\\n        return serviceContractUpgraders[_operatorContract];\\n    }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/cryptography/AltBn128.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"../utils/ModUtils.sol\\\";\\n\\n/**\\n * @title Operations on alt_bn128\\n * @dev Implementations of common elliptic curve operations on Ethereum's\\n * (poorly named) alt_bn128 curve. Whenever possible, use post-Byzantium\\n * pre-compiled contracts to offset gas costs. Note that these pre-compiles\\n * might not be available on all (eg private) chains.\\n */\\nlibrary AltBn128 {\\n\\n    using ModUtils for uint256;\\n\\n    // G1Point implements a point in G1 group.\\n    struct G1Point {\\n        uint256 x;\\n        uint256 y;\\n    }\\n\\n    // gfP2 implements a field of size p\u00b2 as a quadratic extension of the base field.\\n    struct gfP2 {\\n        uint256 x;\\n        uint256 y;\\n    }\\n\\n    // G2Point implements a point in G2 group.\\n    struct G2Point {\\n        gfP2 x;\\n        gfP2 y;\\n    }\\n\\n    // p is a prime over which we form a basic field\\n    // Taken from go-ethereum/crypto/bn256/cloudflare/constants.go\\n    uint256 constant p = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n\\n    function getP() internal pure returns (uint256) {\\n        return p;\\n    }\\n\\n    /**\\n     * @dev Gets generator of G1 group.\\n     * Taken from go-ethereum/crypto/bn256/cloudflare/curve.go\\n     */\\n    uint256 constant g1x = 1;\\n    uint256 constant g1y = 2;\\n    function g1() internal pure returns (G1Point memory) {\\n        return G1Point(g1x, g1y);\\n    }\\n\\n    /**\\n     * @dev Gets generator of G2 group.\\n     * Taken from go-ethereum/crypto/bn256/cloudflare/twist.go\\n     */\\n    uint256 constant g2xx = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\\n    uint256 constant g2xy = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\\n    uint256 constant g2yx = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\\n    uint256 constant g2yy = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\\n    function g2() internal pure returns (G2Point memory) {\\n        return G2Point(\\n            gfP2(g2xx, g2xy),\\n            gfP2(g2yx, g2yy)\\n        );\\n    }\\n\\n    /**\\n     * @dev Gets twist curve B constant.\\n     * Taken from go-ethereum/crypto/bn256/cloudflare/twist.go\\n     */\\n    uint256 constant twistBx = 266929791119991161246907387137283842545076965332900288569378510910307636690;\\n    uint256 constant twistBy = 19485874751759354771024239261021720505790618469301721065564631296452457478373;\\n    function twistB() private pure returns (gfP2 memory) {\\n        return gfP2(twistBx, twistBy);\\n    }\\n\\n    /**\\n     * @dev Gets root of the point where x and y are equal.\\n     */\\n    uint256 constant hexRootX = 21573744529824266246521972077326577680729363968861965890554801909984373949499;\\n    uint256 constant hexRootY = 16854739155576650954933913186877292401521110422362946064090026408937773542853;\\n    function hexRoot() private pure returns (gfP2 memory) {\\n        return gfP2(hexRootX, hexRootY);\\n    }\\n\\n    /**\\n     * @dev g1YFromX computes a Y value for a G1 point based on an X value.\\n     * This computation is simply evaluating the curve equation for Y on a\\n     * given X, and allows a point on the curve to be represented by just\\n     * an X value + a sign bit.\\n     */\\n    function g1YFromX(uint256 x)\\n        internal\\n        view returns(uint256)\\n    {\\n        return ((x.modExp(3, p) + 3) % p).modSqrt(p);\\n    }\\n\\n    /**\\n     * @dev g2YFromX computes a Y value for a G2 point based on an X value.\\n     * This computation is simply evaluating the curve equation for Y on a\\n     * given X, and allows a point on the curve to be represented by just\\n     * an X value + a sign bit.\\n     */\\n    function g2YFromX(gfP2 memory _x)\\n        internal\\n        pure returns(gfP2 memory y)\\n    {\\n        (uint256 xx, uint256 xy) = _gfP2CubeAddTwistB(_x.x, _x.y);\\n\\n        // Using formula y = x ^ (p^2 + 15) / 32 from\\n        // https://github.com/ethereum/beacon_chain/blob/master/beacon_chain/utils/bls.py\\n        // (p^2 + 15) / 32 results into a big 512bit value, so breaking it to two uint256 as (a * a + b)\\n        uint256 a = 3869331240733915743250440106392954448556483137451914450067252501901456824595;\\n        uint256 b = 146360017852723390495514512480590656176144969185739259173561346299185050597;\\n\\n        (uint256 xbx, uint256 xby) = _gfP2Pow(xx, xy, b);\\n        (uint256 yax, uint256 yay) = _gfP2Pow(xx, xy, a);\\n        (uint256 ya2x, uint256 ya2y) = _gfP2Pow(yax, yay, a);\\n        (y.x, y.y) = _gfP2Multiply(ya2x, ya2y, xbx, xby);\\n\\n        // Multiply y by hexRoot constant to find correct y.\\n        while (!_g2X2y(xx, xy, y.x, y.y)) {\\n            (y.x, y.y) = _gfP2Multiply(y.x, y.y, hexRootX, hexRootY);\\n        }\\n    }\\n\\n    /**\\n     * @dev Hash a byte array message, m, and map it deterministically to a\\n     * point on G1. Note that this approach was chosen for its simplicity /\\n     * lower gas cost on the EVM, rather than good distribution of points on\\n     * G1.\\n     */\\n    function g1HashToPoint(bytes memory m)\\n        internal\\n        view returns(G1Point memory)\\n    {\\n        bytes32 h = sha256(m);\\n        uint256 x = uint256(h) % p;\\n        uint256 y;\\n\\n        while (true) {\\n            y = g1YFromX(x);\\n            if (y > 0) {\\n                return G1Point(x, y);\\n            }\\n            x += 1;\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates whether the provided number is even or odd.\\n     * @return 0x01 if y is an even number and 0x00 if it's odd.\\n     */\\n    function parity(uint256 value) private pure returns (byte) {\\n        return bytes32(value)[31] & 0x01;\\n    }\\n\\n    /**\\n     * @dev Compress a point on G1 to a single uint256 for serialization.\\n     */\\n    function g1Compress(G1Point memory point)\\n        internal\\n        pure returns(bytes32)\\n    {\\n        bytes32 m = bytes32(point.x);\\n\\n        byte leadM = m[0] | parity(point.y) << 7;\\n        uint256 mask = 0xff << 31*8;\\n        m = (m & ~bytes32(mask)) | (leadM >> 0);\\n\\n        return m;\\n    }\\n\\n    /**\\n     * @dev Compress a point on G2 to a pair of uint256 for serialization.\\n     */\\n    function g2Compress(G2Point memory point)\\n        internal\\n        pure returns(bytes memory)\\n    {\\n        bytes32 m = bytes32(point.x.x);\\n\\n        byte leadM = m[0] | parity(point.y.x) << 7;\\n        uint256 mask = 0xff << 31*8;\\n        m = (m & ~bytes32(mask)) | (leadM >> 0);\\n\\n        return abi.encodePacked(m, bytes32(point.x.y));\\n    }\\n\\n    /**\\n     * @dev Decompress a point on G1 from a single uint256.\\n     */\\n    function g1Decompress(bytes32 m)\\n        internal\\n        view returns(G1Point memory)\\n    {\\n        bytes32 mX = bytes32(0);\\n        byte leadX = m[0] & 0x7f;\\n        uint256 mask = 0xff << 31*8;\\n        mX = (m & ~bytes32(mask)) | (leadX >> 0);\\n\\n        uint256 x = uint256(mX);\\n        uint256 y = g1YFromX(x);\\n\\n        if (parity(y) != (m[0] & 0x80) >> 7) {\\n            y = p - y;\\n        }\\n\\n        require(isG1PointOnCurve(G1Point(x, y)), \\\"Malformed bn256.G1 point.\\\");\\n\\n        return G1Point(x, y);\\n    }\\n\\n    /**\\n     * @dev Unmarshals a point on G1 from bytes in an uncompressed form.\\n     */\\n    function g1Unmarshal(bytes memory m) internal pure returns(G1Point memory) {\\n        require(\\n            m.length == 64,\\n            \\\"Invalid G1 bytes length\\\"\\n        );\\n\\n        bytes32 x;\\n        bytes32 y;\\n\\n        /* solium-disable-next-line */\\n        assembly {\\n            x := mload(add(m, 0x20))\\n            y := mload(add(m, 0x40))\\n        }\\n\\n        return G1Point(uint256(x), uint256(y));\\n    }\\n\\n    /**\\n     * @dev Marshals a point on G1 to bytes form.\\n     */\\n    function g1Marshal(G1Point memory point) internal pure returns(bytes memory) {\\n        bytes memory m = new bytes(64);\\n        bytes32 x = bytes32(point.x);\\n        bytes32 y = bytes32(point.y);\\n\\n        /* solium-disable-next-line */\\n        assembly {\\n            mstore(add(m, 32), x)\\n            mstore(add(m, 64), y)\\n        }\\n\\n        return m;\\n    }\\n\\n    /**\\n     * @dev Unmarshals a point on G2 from bytes in an uncompressed form.\\n     */\\n    function g2Unmarshal(bytes memory m) internal pure returns(G2Point memory) {\\n        require(\\n            m.length == 128,\\n            \\\"Invalid G2 bytes length\\\"\\n        );\\n\\n        uint256 xx;\\n        uint256 xy;\\n        uint256 yx;\\n        uint256 yy;\\n\\n        /* solium-disable-next-line */\\n        assembly {\\n            xx := mload(add(m, 0x20))\\n            xy := mload(add(m, 0x40))\\n            yx := mload(add(m, 0x60))\\n            yy := mload(add(m, 0x80))\\n        }\\n\\n        return G2Point(gfP2(xx, xy), gfP2(yx,yy));\\n    }\\n\\n    /**\\n     * @dev Decompress a point on G2 from a pair of uint256.\\n     */\\n    function g2Decompress(bytes memory m)\\n        internal\\n        pure returns(G2Point memory)\\n    {\\n        require(\\n            m.length == 64,\\n            \\\"Invalid G2 compressed bytes length\\\"\\n        );\\n\\n        bytes32 x1;\\n        bytes32 x2;\\n        uint256 temp;\\n\\n        // Extract two bytes32 from bytes array\\n        /* solium-disable-next-line */\\n        assembly {\\n            temp := add(m, 32)\\n            x1 := mload(temp)\\n            temp := add(m, 64)\\n            x2 := mload(temp)\\n        }\\n\\n        bytes32 mX = bytes32(0);\\n        byte leadX = x1[0] & 0x7f;\\n        uint256 mask = 0xff << 31*8;\\n        mX = (x1 & ~bytes32(mask)) | (leadX >> 0);\\n\\n        gfP2 memory x = gfP2(uint256(mX), uint256(x2));\\n        gfP2 memory y = g2YFromX(x);\\n\\n        if (parity(y.x) != (m[0] & 0x80) >> 7) {\\n            y.x = p - y.x;\\n            y.y = p - y.y;\\n        }\\n\\n        return G2Point(x, y);\\n    }\\n\\n    /**\\n     * @dev Wrap the point addition pre-compile introduced in Byzantium. Return\\n     * the sum of two points on G1. Revert if the provided points aren't on the\\n     * curve.\\n     */\\n    function g1Add(G1Point memory a, G1Point memory b)\\n        internal view returns (G1Point memory c) {\\n        /* solium-disable-next-line */\\n        assembly {\\n            let arg := mload(0x40)\\n            mstore(arg, mload(a))\\n            mstore(add(arg, 0x20), mload(add(a, 0x20)))\\n            mstore(add(arg, 0x40), mload(b))\\n            mstore(add(arg, 0x60), mload(add(b, 0x20)))\\n            // 0x60 is the ECADD precompile address\\n            if iszero(staticcall(not(0), 0x06, arg, 0x80, c, 0x40)) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the sum of two gfP2 field elements.\\n     */\\n    function gfP2Add(gfP2 memory a, gfP2 memory b) internal pure returns(gfP2 memory) {\\n        return gfP2(\\n            addmod(a.x, b.x, p),\\n            addmod(a.y, b.y, p)\\n        );\\n    }\\n\\n    /**\\n     * @dev Return multiplication of two gfP2 field elements.\\n     */\\n    function gfP2Multiply(gfP2 memory a, gfP2 memory b) internal pure returns(gfP2 memory) {\\n        return gfP2(\\n            addmod(mulmod(a.x, b.y, p), mulmod(b.x, a.y, p), p),\\n            addmod(mulmod(a.y, b.y, p), p - mulmod(a.x, b.x, p), p)\\n        );\\n    }\\n\\n    /**\\n     * @dev Return gfP2 element to the power of the provided exponent.\\n     */\\n    function gfP2Pow(gfP2 memory _a, uint256 _exp) internal pure returns(gfP2 memory result) {\\n        (uint256 x, uint256 y) = _gfP2Pow(_a.x, _a.y, _exp);\\n        return gfP2(x, y);\\n    }\\n\\n    function gfP2Square(gfP2 memory a) internal pure returns (gfP2 memory) {\\n        return gfP2Multiply(a, a);\\n    }\\n\\n    function gfP2Cube(gfP2 memory a) internal pure returns (gfP2 memory) {\\n        return gfP2Multiply(a, gfP2Square(a));\\n    }\\n\\n    function gfP2CubeAddTwistB(gfP2 memory a) internal pure returns (gfP2 memory) {\\n        (uint256 x, uint256 y) = _gfP2CubeAddTwistB(a.x, a.y);\\n        return gfP2(x, y);\\n    }\\n\\n    /**\\n     * @dev Return true if G2 point's y^2 equals x.\\n     */\\n    function g2X2y(gfP2 memory x, gfP2 memory y) internal pure returns(bool) {\\n        gfP2 memory y2;\\n        y2 = gfP2Square(y);\\n\\n        return (y2.x == x.x && y2.y == x.y);\\n    }\\n\\n    /**\\n     * @dev Return true if G1 point is on the curve.\\n     */\\n    function isG1PointOnCurve(G1Point memory point) internal view returns (bool) {\\n        return point.y.modExp(2, p) == (point.x.modExp(3, p) + 3) % p;\\n    }\\n\\n    /**\\n     * @dev Return true if G2 point is on the curve.\\n     */\\n    function isG2PointOnCurve(G2Point memory point) internal pure returns(bool) {\\n        (uint256 y2x, uint256 y2y) = _gfP2Square(point.y.x, point.y.y);\\n        (uint256 x3x, uint256 x3y) = _gfP2CubeAddTwistB(point.x.x, point.x.y);\\n\\n        return (y2x == x3x && y2y == x3y);\\n    }\\n\\n    /**\\n     * @dev Wrap the scalar point multiplication pre-compile introduced in\\n     * Byzantium. The result of a point from G1 multiplied by a scalar should\\n     * match the point added to itself the same number of times. Revert if the\\n     * provided point isn't on the curve.\\n     */\\n    function scalarMultiply(G1Point memory p_1, uint256 scalar)\\n        internal view returns (G1Point memory p_2) {\\n        assembly {\\n            let arg := mload(0x40)\\n            mstore(arg, mload(p_1))\\n            mstore(add(arg, 0x20), mload(add(p_1, 0x20)))\\n            mstore(add(arg, 0x40), scalar)\\n            // 0x70 is the ECMUL precompile address\\n            if iszero(staticcall(not(0), 0x07, arg, 0x60, p_2, 0x40)) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Wrap the pairing check pre-compile introduced in Byzantium. Return\\n     * the result of a pairing check of 2 pairs (G1 p1, G2 p2) (G1 p3, G2 p4)\\n     */\\n    function pairing(\\n        G1Point memory p1,\\n        G2Point memory p2,\\n        G1Point memory p3,\\n        G2Point memory p4\\n    ) internal view returns (bool result) {\\n        uint256 _c;\\n        /* solium-disable-next-line */\\n        assembly {\\n            let c := mload(0x40)\\n            let arg := add(c, 0x20)\\n\\n            mstore(arg, mload(p1))\\n            mstore(add(arg, 0x20), mload(add(p1, 0x20)))\\n\\n            let p2x := mload(p2)\\n            mstore(add(arg, 0x40), mload(p2x))\\n            mstore(add(arg, 0x60), mload(add(p2x, 0x20)))\\n\\n            let p2y := mload(add(p2, 0x20))\\n            mstore(add(arg, 0x80), mload(p2y))\\n            mstore(add(arg, 0xa0), mload(add(p2y, 0x20)))\\n\\n            mstore(add(arg, 0xc0), mload(p3))\\n            mstore(add(arg, 0xe0), mload(add(p3, 0x20)))\\n\\n            let p4x := mload(p4)\\n            mstore(add(arg, 0x100), mload(p4x))\\n            mstore(add(arg, 0x120), mload(add(p4x, 0x20)))\\n\\n            let p4y := mload(add(p4, 0x20))\\n            mstore(add(arg, 0x140), mload(p4y))\\n            mstore(add(arg, 0x160), mload(add(p4y, 0x20)))\\n\\n            // call(gasLimit, to, value, inputOffset, inputSize, outputOffset, outputSize)\\n            if iszero(staticcall(not(0), 0x08, arg, 0x180, c, 0x20)) {\\n                revert(0, 0)\\n            }\\n            _c := mload(c)\\n        }\\n        return _c != 0;\\n    }\\n\\n    function _gfP2Add(uint256 ax, uint256 ay, uint256 bx, uint256 by)\\n        private pure returns(uint256 x, uint256 y) {\\n        x = addmod(ax, bx, p);\\n        y = addmod(ay, by, p);\\n    }\\n\\n    function _gfP2Multiply(uint256 ax, uint256 ay, uint256 bx, uint256 by)\\n        private pure returns(uint256 x, uint256 y) {\\n        x = addmod(mulmod(ax, by, p), mulmod(bx, ay, p), p);\\n        y = addmod(mulmod(ay, by, p), p - mulmod(ax, bx, p), p);\\n    }\\n\\n    function _gfP2CubeAddTwistB(uint256 ax, uint256 ay)\\n        private pure returns (uint256 x, uint256 y) {\\n        (uint256 a3x, uint256 a3y) = _gfP2Cube(ax, ay);\\n        return _gfP2Add(a3x, a3y, twistBx, twistBy);\\n    }\\n\\n    function _gfP2Pow(uint256 _ax, uint256 _ay, uint256 _exp)\\n        private pure returns (uint256 x, uint256 y) {\\n        uint256 exp = _exp;\\n        x = 0;\\n        y = 1;\\n        uint256 ax = _ax;\\n        uint256 ay = _ay;\\n\\n        // Reduce exp dividing by 2 gradually to 0 while computing final\\n        // result only when exp is an odd number.\\n        while (exp > 0) {\\n            if (parity(exp) == 0x01) {\\n                (x, y) = _gfP2Multiply(x, y, ax, ay);\\n            }\\n\\n            exp = exp / 2;\\n            (ax, ay) = _gfP2Multiply(ax, ay, ax, ay);\\n        }\\n    }\\n\\n    function _gfP2Square(uint256 _ax, uint256 _ay)\\n        private pure returns (uint256 x, uint256 y) {\\n        return _gfP2Multiply(_ax, _ay, _ax, _ay);\\n    }\\n\\n    function _gfP2Cube(uint256 _ax, uint256 _ay)\\n        private pure returns (uint256 x, uint256 y) {\\n        (uint256 _bx, uint256 _by) = _gfP2Square(_ax, _ay);\\n        return _gfP2Multiply(_ax, _ay, _bx, _by);\\n    }\\n\\n    function _g2X2y(uint256 xx, uint256 xy, uint256 yx, uint256 yy)\\n        private pure returns (bool) {\\n        (uint256 y2x, uint256 y2y) = _gfP2Square(yx, yy);\\n\\n        return (y2x == xx && y2y == xy);\\n    }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/utils/ModUtils.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\n\\nlibrary ModUtils {\\n\\n    /**\\n     * @dev Wrap the modular exponent pre-compile introduced in Byzantium.\\n     * Returns base^exponent mod p.\\n     */\\n    function modExp(uint256 base, uint256 exponent, uint256 p)\\n        internal\\n        view returns(uint256 o)\\n    {\\n        /* solium-disable-next-line */\\n        assembly {\\n            // Args for the precompile: [<length_of_BASE> <length_of_EXPONENT>\\n            // <length_of_MODULUS> <BASE> <EXPONENT> <MODULUS>]\\n            let output := mload(0x40)\\n            let args := add(output, 0x20)\\n            mstore(args, 0x20)\\n            mstore(add(args, 0x20), 0x20)\\n            mstore(add(args, 0x40), 0x20)\\n            mstore(add(args, 0x60), base)\\n            mstore(add(args, 0x80), exponent)\\n            mstore(add(args, 0xa0), p)\\n\\n            // 0x05 is the modular exponent contract address\\n            if iszero(staticcall(not(0), 0x05, args, 0xc0, output, 0x20)) {\\n                revert(0, 0)\\n            }\\n            o := mload(output)\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates and returns the square root of a mod p,\\n     * or 0 if there is no such root.\\n     */\\n    function modSqrt(uint256 a, uint256 p)\\n        internal\\n        view returns(uint256)\\n    {\\n\\n        if (legendre(a, p) != 1) {\\n            return 0;\\n        }\\n\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        if (p == 2) {\\n            return p;\\n        }\\n\\n        if (p % 4 == 3) {\\n            return modExp(a, (p + 1) / 4, p);\\n        }\\n\\n        uint256 s = p - 1;\\n        uint256 e = 0;\\n\\n        while (s % 2 == 0) {\\n            s = s / 2;\\n            e = e + 1;\\n        }\\n\\n        // Note the smaller int- finding n with Legendre symbol or -1\\n        // should be quick\\n        uint256 n = 2;\\n        while (legendre(n, p) != -1) {\\n            n = n + 1;\\n        }\\n\\n        uint256 x = modExp(a, (s + 1) / 2, p);\\n        uint256 b = modExp(a, s, p);\\n        uint256 g = modExp(n, s, p);\\n        uint256 r = e;\\n        uint256 gs = 0;\\n        uint256 m = 0;\\n        uint256 t = b;\\n\\n        while (true) {\\n            t = b;\\n            m = 0;\\n\\n            for (m = 0; m < r; m++) {\\n                if (t == 1) {\\n                    break;\\n                }\\n                t = modExp(t, 2, p);\\n            }\\n\\n            if (m == 0) {\\n                return x;\\n            }\\n\\n            gs = modExp(g, uint256(2) ** (r - m - 1), p);\\n            g = (gs * gs) % p;\\n            x = (x * gs) % p;\\n            b = (b * g) % p;\\n            r = m;\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates the Legendre symbol of the given a mod p.\\n     * @return Returns 1 if a is a quadratic residue mod p, -1 if it is\\n     * a non-quadratic residue, and 0 if a is 0.\\n     */\\n    function legendre(uint256 a, uint256 p)\\n        internal\\n        view returns(int256)\\n    {\\n        uint256 raised = modExp(a, (p - 1) / uint256(2), p);\\n\\n        if (raised == 0 || raised == 1) {\\n            return int256(raised);\\n        } else if (raised == p - 1) {\\n            return -1;\\n        }\\n\\n        require(false, \\\"Failed to calculate legendre.\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/cryptography/BLS.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"./AltBn128.sol\\\";\\n\\n\\n/**\\n * @title BLS signatures verification\\n * @dev Library for verification of 2-pairing-check BLS signatures, including\\n * basic, aggregated, or reconstructed threshold BLS signatures, generated\\n * using the AltBn128 curve.\\n */\\nlibrary BLS {\\n\\n    /**\\n     * @dev Creates a signature over message using the provided secret key.\\n     */\\n    function sign(bytes memory message, uint256 secretKey) public view returns(bytes memory) {\\n        AltBn128.G1Point memory p_1 = AltBn128.g1HashToPoint(message);\\n        AltBn128.G1Point memory p_2 = AltBn128.scalarMultiply(p_1, secretKey);\\n\\n        return AltBn128.g1Marshal(p_2);\\n    }\\n\\n    /**\\n     * @dev Verify performs the pairing operation to check if the signature\\n     * is correct for the provided message and the corresponding public key.\\n     * Public key must be a valid point on G2 curve in an uncompressed format.\\n     * Message must be a valid point on G1 curve in an uncompressed format.\\n     * Signature must be a valid point on G1 curve in an uncompressed format.\\n     */\\n    function verify(\\n        bytes memory publicKey,\\n        bytes memory message,\\n        bytes memory signature\\n    ) public view returns (bool) {\\n\\n        AltBn128.G1Point memory _signature = AltBn128.g1Unmarshal(signature);\\n\\n        return AltBn128.pairing(\\n            AltBn128.G1Point(_signature.x, AltBn128.getP() - _signature.y),\\n            AltBn128.g2(),\\n            AltBn128.g1Unmarshal(message),\\n            AltBn128.g2Unmarshal(publicKey)\\n        );\\n    }\\n\\n    /**\\n     * @dev VerifyBytes wraps the functionality of BLS.verify, but hashes a message\\n     * to a point on G1 and marshal to bytes first to allow raw bytes verificaion.\\n     */\\n    function verifyBytes(\\n        bytes memory publicKey,\\n        bytes memory message,\\n        bytes memory signature\\n    ) public view returns (bool) {\\n        AltBn128.G1Point memory point = AltBn128.g1HashToPoint(message);\\n        bytes memory messageAsPoint = AltBn128.g1Marshal(point);\\n\\n        return verify(publicKey, messageAsPoint, signature);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenGrant\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_grantManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_grantId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_grantee\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cancelledRequestedGrantee\",\"type\":\"address\"}],\"name\":\"GranteeReassignmentCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previouslyRequestedGrantee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRequestedGrantee\",\"type\":\"address\"}],\"name\":\"GranteeReassignmentChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldGrantee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGrantee\",\"type\":\"address\"}],\"name\":\"GranteeReassignmentConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGrantee\",\"type\":\"address\"}],\"name\":\"GranteeReassignmentRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensWithdrawn\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelReassignmentRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"cancelStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGrantee\",\"type\":\"address\"}],\"name\":\"changeReassignmentRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGrantee\",\"type\":\"address\"}],\"name\":\"confirmGranteeReassignment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"grantId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"grantManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"grantee\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"recoverStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGrantee\",\"type\":\"address\"}],\"name\":\"requestGranteeReassignment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requestedNewGrantee\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"stake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract ERC20Burnable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenGrant\",\"outputs\":[{\"internalType\":\"contract TokenGrant\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"undelegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ManagedGrant", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000085eee30c52b0b379b046fb0f85f4f3dc3009afec000000000000000000000000175989c71fd023d580c65f5dc214002687ff88b70000000000000000000000006950c4c7e97c7d2e6b5bffec4634f841db2a5f3d00000000000000000000000000000000000000000000000000000000000000760000000000000000000000006950c4c7e97c7d2e6b5bffec4634f841db2a5f3d", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://f66a753081134bf4182dcc855c173c9655b6346fe5f821d0c0b048d1978aad74"}