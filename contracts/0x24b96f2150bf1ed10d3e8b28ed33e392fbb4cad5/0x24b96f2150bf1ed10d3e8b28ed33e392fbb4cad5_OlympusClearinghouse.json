{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/modules/CHREG/OlympusClearinghouseRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.15;\\n\\nimport {CHREGv1} from \\\"src/modules/CHREG/CHREG.v1.sol\\\";\\nimport \\\"src/Kernel.sol\\\";\\n\\n/// @title  Olympus Clearinghouse Registry\\n/// @notice Olympus Clearinghouse Registry (Module) Contract\\n/// @dev    The Olympus Clearinghouse Registry Module tracks the lending facilities that the Olympus\\n///         protocol deploys to satisfy the Cooler Loan demand. This allows for a single-soure of truth\\n///         for reporting purposes around the total Treasury holdings as well as its projected receivables.\\ncontract OlympusClearinghouseRegistry is CHREGv1 {\\n    //============================================================================================//\\n    //                                      MODULE SETUP                                          //\\n    //============================================================================================//\\n\\n    /// @notice Can be initialized with an active Clearinghouse and list of inactive ones.\\n    /// @param  kernel_ contract address.\\n    /// @param  active_ Address of the active Clearinghouse. Set to address(0) if none.\\n    /// @param  inactive_ List of inactive Clearinghouses. Leave empty if none.\\n    constructor(Kernel kernel_, address active_, address[] memory inactive_) Module(kernel_) {\\n        // Process inactive addresses.\\n        uint256 toRegister = inactive_.length;\\n        for (uint256 i; i < toRegister; ) {\\n            // Ensure clearinghouses are either active or inactive.\\n            if (inactive_[i] == active_) revert CHREG_InvalidConstructor();\\n            // Ensure no duplicates in active addresses.\\n            for (uint256 j; j < toRegister; ) {\\n                if (i != j && inactive_[i] == inactive_[j]) revert CHREG_InvalidConstructor();\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n            // Add to storage.\\n            registry.push(inactive_[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        // Process active address.\\n        if (active_ == address(0)) {\\n            registryCount = toRegister;\\n        } else {\\n            active.push(active_);\\n            registry.push(active_);\\n            registryCount = toRegister + 1;\\n            activeCount = 1;\\n        }\\n    }\\n\\n    /// @inheritdoc Module\\n    function KEYCODE() public pure override returns (Keycode) {\\n        return toKeycode(\\\"CHREG\\\");\\n    }\\n\\n    /// @inheritdoc Module\\n    function VERSION() public pure override returns (uint8 major, uint8 minor) {\\n        major = 1;\\n        minor = 0;\\n    }\\n\\n    //============================================================================================//\\n    //                                       CORE FUNCTIONS                                       //\\n    //============================================================================================//\\n\\n    /// @inheritdoc CHREGv1\\n    function activateClearinghouse(address clearinghouse_) external override permissioned {\\n        // Ensure Clearinghouse is not currently registered as active.\\n        uint256 count = activeCount;\\n        for (uint256 i; i < count; ) {\\n            if (active[i] == clearinghouse_) revert CHREG_AlreadyActivated(clearinghouse_);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        active.push(clearinghouse_);\\n        unchecked {\\n            ++activeCount;\\n        }\\n\\n        // Only add to registry if Clearinghouse is new.\\n        count = registry.length;\\n        bool registered;\\n        for (uint256 i; i < count; ) {\\n            if (registry[i] == clearinghouse_) registered = true;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        if (!registered) registry.push(clearinghouse_);\\n\\n        emit ClearinghouseActivated(clearinghouse_);\\n    }\\n\\n    /// @inheritdoc CHREGv1\\n    function deactivateClearinghouse(address clearinghouse_) external override permissioned {\\n        bool found;\\n        uint256 count = activeCount;\\n        for (uint256 i; i < count; ) {\\n            if (active[i] == clearinghouse_) {\\n                // Delete address from array by swapping with last element and popping.\\n                active[i] = active[count - 1];\\n                active.pop();\\n                --activeCount;\\n                found = true;\\n                break;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // If Clearinghouse was not active, revert. Otherwise, emit event.\\n        if (!found) revert CHREG_NotActivated(clearinghouse_);\\n        emit ClearinghouseDeactivated(clearinghouse_);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/modules/CHREG/CHREG.v1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.15;\\n\\nimport \\\"src/Kernel.sol\\\";\\n\\n/// @title  Olympus Clearinghouse Registry\\n/// @notice Olympus Clearinghouse Registry (Module) Contract\\n/// @dev    The Olympus Clearinghouse Registry Module tracks the lending facilities that the Olympus\\n///         protocol deploys to satisfy the Cooler Loan demand. This allows for a single-soure of truth\\n///         for reporting purposes around the total Treasury holdings as well as its projected receivables.\\nabstract contract CHREGv1 is Module {\\n    // =========  ERRORS ========= //\\n\\n    error CHREG_InvalidConstructor();\\n    error CHREG_NotActivated(address clearinghouse_);\\n    error CHREG_AlreadyActivated(address clearinghouse_);\\n\\n    // ========= EVENTS ========= //\\n\\n    /// @notice Logs whenever a Clearinghouse is activated.\\n    ///         If it is the first time, it is also added to the registry.\\n    event ClearinghouseActivated(address indexed clearinghouse);\\n\\n    /// @notice Logs whenever an active Clearinghouse is deactivated.\\n    event ClearinghouseDeactivated(address indexed clearinghouse);\\n\\n    // ========= STATE ========= //\\n\\n    /// @notice Count of active and historical clearinghouses.\\n    /// @dev    These are useless variables in contracts, but useful for any frontends\\n    ///         or off-chain requests where the array is not easily accessible.\\n    uint256 public activeCount;\\n    uint256 public registryCount;\\n\\n    /// @notice Tracks the addresses of all the active Clearinghouses.\\n    address[] public active;\\n\\n    /// @notice Historical record of all the Clearinghouse addresses.\\n    address[] public registry;\\n\\n    // ========= FUNCTIONS ========= //\\n\\n    /// @notice Adds a Clearinghouse to the registry.\\n    ///         Only callable by permissioned policies.\\n    /// @param  clearinghouse_ The address of the clearinghouse.\\n    function activateClearinghouse(address clearinghouse_) external virtual;\\n\\n    /// @notice Deactivates a clearinghouse from the registry.\\n    ///         Only callable by permissioned policies.\\n    /// @param  clearinghouse_ The address of the clearginhouse.\\n    function deactivateClearinghouse(address clearinghouse_) external virtual;\\n}\\n\"\r\n    },\r\n    \"src/Kernel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.15;\\n\\n//     \u2588\u2588\u2588\u2588\u2588\u2588\u2588    \u2588\u2588\u2588\u2588\u2588       \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n//   \u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588       \u2591\u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588  \u2591\u2591\u2588\u2588\u2588  \u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\\n//  \u2588\u2588\u2588     \u2591\u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588        \u2591\u2591\u2588\u2588\u2588 \u2588\u2588\u2588   \u2591\u2588\u2588\u2588\u2591\u2588\u2588\u2588\u2588\u2588\u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588    \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588   \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588    \u2591\u2591\u2591\\n// \u2591\u2588\u2588\u2588      \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588         \u2591\u2591\u2588\u2588\u2588\u2588\u2588    \u2591\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2591\u2588\u2588\u2588   \u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n// \u2591\u2588\u2588\u2588      \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588          \u2591\u2591\u2588\u2588\u2588     \u2591\u2588\u2588\u2588 \u2591\u2591\u2591  \u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591   \u2591\u2588\u2588\u2588   \u2591\u2588\u2588\u2588  \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\\n// \u2591\u2591\u2588\u2588\u2588     \u2588\u2588\u2588  \u2591\u2588\u2588\u2588      \u2588    \u2591\u2588\u2588\u2588     \u2591\u2588\u2588\u2588      \u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588         \u2591\u2588\u2588\u2588   \u2591\u2588\u2588\u2588  \u2588\u2588\u2588    \u2591\u2588\u2588\u2588\\n//  \u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588    \u2588\u2588\u2588\u2588\u2588    \u2588\u2588\u2588\u2588\u2588     \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588        \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n//    \u2591\u2591\u2591\u2591\u2591\u2591\u2591    \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591    \u2591\u2591\u2591\u2591\u2591    \u2591\u2591\u2591\u2591\u2591     \u2591\u2591\u2591\u2591\u2591 \u2591\u2591\u2591\u2591\u2591          \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591    \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\\n\\n//============================================================================================//\\n//                                        GLOBAL TYPES                                        //\\n//============================================================================================//\\n\\n/// @notice Actions to trigger state changes in the kernel. Passed by the executor\\nenum Actions {\\n    InstallModule,\\n    UpgradeModule,\\n    ActivatePolicy,\\n    DeactivatePolicy,\\n    ChangeExecutor,\\n    MigrateKernel\\n}\\n\\n/// @notice Used by executor to select an action and a target contract for a kernel action\\nstruct Instruction {\\n    Actions action;\\n    address target;\\n}\\n\\n/// @notice Used to define which module functions a policy needs access to\\nstruct Permissions {\\n    Keycode keycode;\\n    bytes4 funcSelector;\\n}\\n\\ntype Keycode is bytes5;\\n\\n//============================================================================================//\\n//                                       UTIL FUNCTIONS                                       //\\n//============================================================================================//\\n\\nerror TargetNotAContract(address target_);\\nerror InvalidKeycode(Keycode keycode_);\\n\\n// solhint-disable-next-line func-visibility\\nfunction toKeycode(bytes5 keycode_) pure returns (Keycode) {\\n    return Keycode.wrap(keycode_);\\n}\\n\\n// solhint-disable-next-line func-visibility\\nfunction fromKeycode(Keycode keycode_) pure returns (bytes5) {\\n    return Keycode.unwrap(keycode_);\\n}\\n\\n// solhint-disable-next-line func-visibility\\nfunction ensureContract(address target_) view {\\n    if (target_.code.length == 0) revert TargetNotAContract(target_);\\n}\\n\\n// solhint-disable-next-line func-visibility\\nfunction ensureValidKeycode(Keycode keycode_) pure {\\n    bytes5 unwrapped = Keycode.unwrap(keycode_);\\n    for (uint256 i = 0; i < 5; ) {\\n        bytes1 char = unwrapped[i];\\n        if (char < 0x41 || char > 0x5A) revert InvalidKeycode(keycode_); // A-Z only\\n        unchecked {\\n            i++;\\n        }\\n    }\\n}\\n\\n//============================================================================================//\\n//                                        COMPONENTS                                          //\\n//============================================================================================//\\n\\n/// @notice Generic adapter interface for kernel access in modules and policies.\\nabstract contract KernelAdapter {\\n    error KernelAdapter_OnlyKernel(address caller_);\\n\\n    Kernel public kernel;\\n\\n    constructor(Kernel kernel_) {\\n        kernel = kernel_;\\n    }\\n\\n    /// @notice Modifier to restrict functions to be called only by kernel.\\n    modifier onlyKernel() {\\n        if (msg.sender != address(kernel)) revert KernelAdapter_OnlyKernel(msg.sender);\\n        _;\\n    }\\n\\n    /// @notice Function used by kernel when migrating to a new kernel.\\n    function changeKernel(Kernel newKernel_) external onlyKernel {\\n        kernel = newKernel_;\\n    }\\n}\\n\\n/// @notice Base level extension of the kernel. Modules act as independent state components to be\\n///         interacted with and mutated through policies.\\n/// @dev    Modules are installed and uninstalled via the executor.\\nabstract contract Module is KernelAdapter {\\n    error Module_PolicyNotPermitted(address policy_);\\n\\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\\n\\n    /// @notice Modifier to restrict which policies have access to module functions.\\n    modifier permissioned() {\\n        if (\\n            msg.sender == address(kernel) ||\\n            !kernel.modulePermissions(KEYCODE(), Policy(msg.sender), msg.sig)\\n        ) revert Module_PolicyNotPermitted(msg.sender);\\n        _;\\n    }\\n\\n    /// @notice 5 byte identifier for a module.\\n    function KEYCODE() public pure virtual returns (Keycode) {}\\n\\n    /// @notice Returns which semantic version of a module is being implemented.\\n    /// @return major - Major version upgrade indicates breaking change to the interface.\\n    /// @return minor - Minor version change retains backward-compatible interface.\\n    function VERSION() external pure virtual returns (uint8 major, uint8 minor) {}\\n\\n    /// @notice Initialization function for the module\\n    /// @dev    This function is called when the module is installed or upgraded by the kernel.\\n    /// @dev    MUST BE GATED BY onlyKernel. Used to encompass any initialization or upgrade logic.\\n    function INIT() external virtual onlyKernel {}\\n}\\n\\n/// @notice Policies are application logic and external interface for the kernel and installed modules.\\n/// @dev    Policies are activated and deactivated in the kernel by the executor.\\n/// @dev    Module dependencies and function permissions must be defined in appropriate functions.\\nabstract contract Policy is KernelAdapter {\\n    error Policy_ModuleDoesNotExist(Keycode keycode_);\\n\\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\\n\\n    /// @notice Easily accessible indicator for if a policy is activated or not.\\n    function isActive() external view returns (bool) {\\n        return kernel.isPolicyActive(this);\\n    }\\n\\n    /// @notice Function to grab module address from a given keycode.\\n    function getModuleAddress(Keycode keycode_) internal view returns (address) {\\n        address moduleForKeycode = address(kernel.getModuleForKeycode(keycode_));\\n        if (moduleForKeycode == address(0)) revert Policy_ModuleDoesNotExist(keycode_);\\n        return moduleForKeycode;\\n    }\\n\\n    /// @notice Define module dependencies for this policy.\\n    /// @return dependencies - Keycode array of module dependencies.\\n    function configureDependencies() external virtual returns (Keycode[] memory dependencies) {}\\n\\n    /// @notice Function called by kernel to set module function permissions.\\n    /// @return requests - Array of keycodes and function selectors for requested permissions.\\n    function requestPermissions() external view virtual returns (Permissions[] memory requests) {}\\n}\\n\\n/// @notice Main contract that acts as a central component registry for the protocol.\\n/// @dev    The kernel manages modules and policies. The kernel is mutated via predefined Actions,\\n/// @dev    which are input from any address assigned as the executor. The executor can be changed as needed.\\ncontract Kernel {\\n    // =========  EVENTS ========= //\\n\\n    event PermissionsUpdated(\\n        Keycode indexed keycode_,\\n        Policy indexed policy_,\\n        bytes4 funcSelector_,\\n        bool granted_\\n    );\\n    event ActionExecuted(Actions indexed action_, address indexed target_);\\n\\n    // =========  ERRORS ========= //\\n\\n    error Kernel_OnlyExecutor(address caller_);\\n    error Kernel_ModuleAlreadyInstalled(Keycode module_);\\n    error Kernel_InvalidModuleUpgrade(Keycode module_);\\n    error Kernel_PolicyAlreadyActivated(address policy_);\\n    error Kernel_PolicyNotActivated(address policy_);\\n\\n    // =========  PRIVILEGED ADDRESSES ========= //\\n\\n    /// @notice Address that is able to initiate Actions in the kernel. Can be assigned to a multisig or governance contract.\\n    address public executor;\\n\\n    // =========  MODULE MANAGEMENT ========= //\\n\\n    /// @notice Array of all modules currently installed.\\n    Keycode[] public allKeycodes;\\n\\n    /// @notice Mapping of module address to keycode.\\n    mapping(Keycode => Module) public getModuleForKeycode;\\n\\n    /// @notice Mapping of keycode to module address.\\n    mapping(Module => Keycode) public getKeycodeForModule;\\n\\n    /// @notice Mapping of a keycode to all of its policy dependents. Used to efficiently reconfigure policy dependencies.\\n    mapping(Keycode => Policy[]) public moduleDependents;\\n\\n    /// @notice Helper for module dependent arrays. Prevents the need to loop through array.\\n    mapping(Keycode => mapping(Policy => uint256)) public getDependentIndex;\\n\\n    /// @notice Module <> Policy Permissions.\\n    /// @dev    Keycode -> Policy -> Function Selector -> bool for permission\\n    mapping(Keycode => mapping(Policy => mapping(bytes4 => bool))) public modulePermissions;\\n\\n    // =========  POLICY MANAGEMENT ========= //\\n\\n    /// @notice List of all active policies\\n    Policy[] public activePolicies;\\n\\n    /// @notice Helper to get active policy quickly. Prevents need to loop through array.\\n    mapping(Policy => uint256) public getPolicyIndex;\\n\\n    //============================================================================================//\\n    //                                       CORE FUNCTIONS                                       //\\n    //============================================================================================//\\n\\n    constructor() {\\n        executor = msg.sender;\\n    }\\n\\n    /// @notice Modifier to check if caller is the executor.\\n    modifier onlyExecutor() {\\n        if (msg.sender != executor) revert Kernel_OnlyExecutor(msg.sender);\\n        _;\\n    }\\n\\n    function isPolicyActive(Policy policy_) public view returns (bool) {\\n        return activePolicies.length > 0 && activePolicies[getPolicyIndex[policy_]] == policy_;\\n    }\\n\\n    /// @notice Main kernel function. Initiates state changes to kernel depending on Action passed in.\\n    function executeAction(Actions action_, address target_) external onlyExecutor {\\n        if (action_ == Actions.InstallModule) {\\n            ensureContract(target_);\\n            ensureValidKeycode(Module(target_).KEYCODE());\\n            _installModule(Module(target_));\\n        } else if (action_ == Actions.UpgradeModule) {\\n            ensureContract(target_);\\n            ensureValidKeycode(Module(target_).KEYCODE());\\n            _upgradeModule(Module(target_));\\n        } else if (action_ == Actions.ActivatePolicy) {\\n            ensureContract(target_);\\n            _activatePolicy(Policy(target_));\\n        } else if (action_ == Actions.DeactivatePolicy) {\\n            ensureContract(target_);\\n            _deactivatePolicy(Policy(target_));\\n        } else if (action_ == Actions.ChangeExecutor) {\\n            executor = target_;\\n        } else if (action_ == Actions.MigrateKernel) {\\n            ensureContract(target_);\\n            _migrateKernel(Kernel(target_));\\n        }\\n\\n        emit ActionExecuted(action_, target_);\\n    }\\n\\n    function _installModule(Module newModule_) internal {\\n        Keycode keycode = newModule_.KEYCODE();\\n\\n        if (address(getModuleForKeycode[keycode]) != address(0))\\n            revert Kernel_ModuleAlreadyInstalled(keycode);\\n\\n        getModuleForKeycode[keycode] = newModule_;\\n        getKeycodeForModule[newModule_] = keycode;\\n        allKeycodes.push(keycode);\\n\\n        newModule_.INIT();\\n    }\\n\\n    function _upgradeModule(Module newModule_) internal {\\n        Keycode keycode = newModule_.KEYCODE();\\n        Module oldModule = getModuleForKeycode[keycode];\\n\\n        if (address(oldModule) == address(0) || oldModule == newModule_)\\n            revert Kernel_InvalidModuleUpgrade(keycode);\\n\\n        getKeycodeForModule[oldModule] = Keycode.wrap(bytes5(0));\\n        getKeycodeForModule[newModule_] = keycode;\\n        getModuleForKeycode[keycode] = newModule_;\\n\\n        newModule_.INIT();\\n\\n        _reconfigurePolicies(keycode);\\n    }\\n\\n    function _activatePolicy(Policy policy_) internal {\\n        if (isPolicyActive(policy_)) revert Kernel_PolicyAlreadyActivated(address(policy_));\\n\\n        // Add policy to list of active policies\\n        activePolicies.push(policy_);\\n        getPolicyIndex[policy_] = activePolicies.length - 1;\\n\\n        // Record module dependencies\\n        Keycode[] memory dependencies = policy_.configureDependencies();\\n        uint256 depLength = dependencies.length;\\n\\n        for (uint256 i; i < depLength; ) {\\n            Keycode keycode = dependencies[i];\\n\\n            moduleDependents[keycode].push(policy_);\\n            getDependentIndex[keycode][policy_] = moduleDependents[keycode].length - 1;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Grant permissions for policy to access restricted module functions\\n        Permissions[] memory requests = policy_.requestPermissions();\\n        _setPolicyPermissions(policy_, requests, true);\\n    }\\n\\n    function _deactivatePolicy(Policy policy_) internal {\\n        if (!isPolicyActive(policy_)) revert Kernel_PolicyNotActivated(address(policy_));\\n\\n        // Revoke permissions\\n        Permissions[] memory requests = policy_.requestPermissions();\\n        _setPolicyPermissions(policy_, requests, false);\\n\\n        // Remove policy from all policy data structures\\n        uint256 idx = getPolicyIndex[policy_];\\n        Policy lastPolicy = activePolicies[activePolicies.length - 1];\\n\\n        activePolicies[idx] = lastPolicy;\\n        activePolicies.pop();\\n        getPolicyIndex[lastPolicy] = idx;\\n        delete getPolicyIndex[policy_];\\n\\n        // Remove policy from module dependents\\n        _pruneFromDependents(policy_);\\n    }\\n\\n    /// @notice All functionality will move to the new kernel. WARNING: ACTION WILL BRICK THIS KERNEL.\\n    /// @dev    New kernel must add in all of the modules and policies via executeAction.\\n    /// @dev    NOTE: Data does not get cleared from this kernel.\\n    function _migrateKernel(Kernel newKernel_) internal {\\n        uint256 keycodeLen = allKeycodes.length;\\n        for (uint256 i; i < keycodeLen; ) {\\n            Module module = Module(getModuleForKeycode[allKeycodes[i]]);\\n            module.changeKernel(newKernel_);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        uint256 policiesLen = activePolicies.length;\\n        for (uint256 j; j < policiesLen; ) {\\n            Policy policy = activePolicies[j];\\n\\n            // Deactivate before changing kernel\\n            policy.changeKernel(newKernel_);\\n            unchecked {\\n                ++j;\\n            }\\n        }\\n    }\\n\\n    function _reconfigurePolicies(Keycode keycode_) internal {\\n        Policy[] memory dependents = moduleDependents[keycode_];\\n        uint256 depLength = dependents.length;\\n\\n        for (uint256 i; i < depLength; ) {\\n            dependents[i].configureDependencies();\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function _setPolicyPermissions(\\n        Policy policy_,\\n        Permissions[] memory requests_,\\n        bool grant_\\n    ) internal {\\n        uint256 reqLength = requests_.length;\\n        for (uint256 i = 0; i < reqLength; ) {\\n            Permissions memory request = requests_[i];\\n            modulePermissions[request.keycode][policy_][request.funcSelector] = grant_;\\n\\n            emit PermissionsUpdated(request.keycode, policy_, request.funcSelector, grant_);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function _pruneFromDependents(Policy policy_) internal {\\n        Keycode[] memory dependencies = policy_.configureDependencies();\\n        uint256 depcLength = dependencies.length;\\n\\n        for (uint256 i; i < depcLength; ) {\\n            Keycode keycode = dependencies[i];\\n            Policy[] storage dependents = moduleDependents[keycode];\\n\\n            uint256 origIndex = getDependentIndex[keycode][policy_];\\n            Policy lastPolicy = dependents[dependents.length - 1];\\n\\n            // Swap with last and pop\\n            dependents[origIndex] = lastPolicy;\\n            dependents.pop();\\n\\n            // Record new index and delete deactivated policy index\\n            getDependentIndex[keycode][lastPolicy] = origIndex;\\n            delete getDependentIndex[keycode][policy_];\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"interfaces/=src/interfaces/\",\r\n      \"modules/=src/modules/\",\r\n      \"policies/=src/policies/\",\r\n      \"libraries/=src/libraries/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"layer-zero/=lib/solidity-examples/contracts/\",\r\n      \"bonds/=lib/bonds/src/\",\r\n      \"test/=src/test/\",\r\n      \"clones/=lib/clones-with-immutable-args/src/\",\r\n      \"cooler/=lib/Cooler/src/\",\r\n      \"balancer-v2/=lib/balancer-v2/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"Cooler/=lib/Cooler/src/\",\r\n      \"clones-with-immutable-args/=lib/clones-with-immutable-args/src/\",\r\n      \"olympus-v3/=lib/Cooler/lib/olympus-v3/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solidity-examples/=lib/solidity-examples/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract Kernel\",\"name\":\"kernel_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"active_\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"inactive_\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"clearinghouse_\",\"type\":\"address\"}],\"name\":\"CHREG_AlreadyActivated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CHREG_InvalidConstructor\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"clearinghouse_\",\"type\":\"address\"}],\"name\":\"CHREG_NotActivated\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller_\",\"type\":\"address\"}],\"name\":\"KernelAdapter_OnlyKernel\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"policy_\",\"type\":\"address\"}],\"name\":\"Module_PolicyNotPermitted\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"clearinghouse\",\"type\":\"address\"}],\"name\":\"ClearinghouseActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"clearinghouse\",\"type\":\"address\"}],\"name\":\"ClearinghouseDeactivated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INIT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"KEYCODE\",\"outputs\":[{\"internalType\":\"Keycode\",\"name\":\"\",\"type\":\"bytes5\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"major\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"minor\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"clearinghouse_\",\"type\":\"address\"}],\"name\":\"activateClearinghouse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"active\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Kernel\",\"name\":\"newKernel_\",\"type\":\"address\"}],\"name\":\"changeKernel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"clearinghouse_\",\"type\":\"address\"}],\"name\":\"deactivateClearinghouse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kernel\",\"outputs\":[{\"internalType\":\"contract Kernel\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registryCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "OlympusClearinghouseRegistry", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "10", "ConstructorArguments": "0000000000000000000000002286d7f9639e8158fad1169e76d1fbc38247f54b000000000000000000000000e6343ad0675c9b8d3f32679ae6adba0766a2ab4c00000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000001000000000000000000000000d6a6e8d9e82534bd65821142fccd91ec9cf31880", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}