{"SourceCode": "pragma solidity >=0.5.6 <0.6.0;\r\n\r\n/// @title Shared constants used throughout the Cheeze Wizards contracts\r\ncontract WizardConstants {\r\n    // Wizards normally have their affinity set when they are first created,\r\n    // but for example Exclusive Wizards can be created with no set affinity.\r\n    // In this case the affinity can be set by the owner.\r\n    uint8 internal constant ELEMENT_NOTSET = 0; //000\r\n    // A neutral Wizard has no particular strength or weakness with specific\r\n    // elements.\r\n    uint8 internal constant ELEMENT_NEUTRAL = 1; //001\r\n    // The fire, water and wind elements are used both to reflect an affinity\r\n    // of Elemental Wizards for a specific element, and as the moves a\r\n    // Wizard can make during a duel.\r\n    // Note that if these values change then `moveMask` and `moveDelta` in\r\n    // ThreeAffinityDuelResolver would need to be updated accordingly.\r\n    uint8 internal constant ELEMENT_FIRE = 2; //010\r\n    uint8 internal constant ELEMENT_WATER = 3; //011\r\n    uint8 internal constant ELEMENT_WIND = 4; //100\r\n    uint8 internal constant MAX_ELEMENT = ELEMENT_WIND;\r\n}\r\n\r\n\r\n\r\n/// @title ERC165Query example\r\n/// @notice see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\ncontract ERC165Query {\r\n    bytes4 constant _INTERFACE_ID_INVALID = 0xffffffff;\r\n    bytes4 constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    function doesContractImplementInterface(\r\n        address _contract,\r\n        bytes4 _interfaceId\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint256 success;\r\n        uint256 result;\r\n\r\n        (success, result) = noThrowCall(_contract, _INTERFACE_ID_ERC165);\r\n        if ((success == 0) || (result == 0)) {\r\n            return false;\r\n        }\r\n\r\n        (success, result) = noThrowCall(_contract, _INTERFACE_ID_INVALID);\r\n        if ((success == 0) || (result != 0)) {\r\n            return false;\r\n        }\r\n\r\n        (success, result) = noThrowCall(_contract, _interfaceId);\r\n        if ((success == 1) && (result == 1)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function noThrowCall(\r\n        address _contract,\r\n        bytes4 _interfaceId\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 success,\r\n            uint256 result\r\n        )\r\n    {\r\n        bytes memory encodedParams = abi.encodeWithSelector(_INTERFACE_ID_ERC165, _interfaceId);\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { // solium-disable-line security/no-inline-assembly\r\n            let encodedParams_data := add(0x20, encodedParams)\r\n            let encodedParams_size := mload(encodedParams)\r\n\r\n            let output := mload(0x40)    // Find empty storage location using \"free memory pointer\"\r\n            mstore(output, 0x0)\r\n\r\n            success := staticcall(\r\n                30000,                   // 30k gas\r\n                _contract,               // To addr\r\n                encodedParams_data,\r\n                encodedParams_size,\r\n                output,\r\n                0x20                     // Outputs are 32 bytes long\r\n            )\r\n\r\n            result := mload(output)      // Load the result\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title IERC165\r\n * @dev https://eips.ethereum.org/EIPS/eip-165\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @notice Query if a contract implements an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @dev Interface identification is specified in ERC-165. This function\r\n     * uses less than 30,000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ncontract IERC721Receiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a `safeTransfer`. This function MUST return the function selector,\r\n     * otherwise the caller will revert the transaction. The selector to be\r\n     * returned can be obtained as `this.onERC721Received.selector`. This\r\n     * function MAY throw to revert and reject the transfer.\r\n     * Note: the ERC721 contract address is always the message sender.\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\r\n    public returns (bytes4);\r\n}\r\n\r\n\r\n\r\n\r\n/// @title ERC165Interface\r\n/// @dev https://eips.ethereum.org/EIPS/eip-165\r\ninterface ERC165Interface {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceId The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///      uses less than 30,000 gas.\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n\r\n/// Utility library of inline functions on address payables.\r\n/// Modified from original by OpenZeppelin.\r\ncontract Address {\r\n    /// @notice Returns whether the target address is a contract.\r\n    /// @dev This function will return false if invoked during the constructor of a contract,\r\n    /// as the code is not actually created until after the constructor finishes.\r\n    /// @param account address of the account to check\r\n    /// @return whether the target address is a contract\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) } // solium-disable-line security/no-inline-assembly\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/// @title Wizard Non-Fungible Token\r\n/// @notice The basic ERC-721 functionality for storing Cheeze Wizard NFTs.\r\n///     Derived from: https://github.com/OpenZeppelin/openzeppelin-solidity/tree/v2.2.0\r\ncontract WizardNFT is ERC165Interface, IERC721, WizardConstants, Address {\r\n\r\n    /// @notice Emitted when a wizard token is created.\r\n    event WizardConjured(uint256 wizardId, uint8 affinity, uint256 innatePower);\r\n\r\n    /// @notice Emitted when a Wizard's affinity is set. This only applies for\r\n    ///         Exclusive Wizards who can have the ELEMENT_NOT_SET affinity,\r\n    ///         and should only happen once for each Wizard.\r\n    event WizardAffinityAssigned(uint256 wizardId, uint8 affinity);\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 internal constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    /// @dev The base Wizard structure.\r\n    /// Designed to fit in two words.\r\n    struct Wizard {\r\n        // NOTE: Changing the order or meaning of any of these fields requires an update\r\n        //   to the _createWizard() function which assumes a specific order for these fields.\r\n        uint8 affinity;\r\n        uint88 innatePower;\r\n        address owner;\r\n        bytes32 metadata;\r\n    }\r\n\r\n    // Mapping from Wizard ID to Wizard struct\r\n    mapping (uint256 => Wizard) public wizardsById;\r\n\r\n    // Mapping from Wizard ID to address approved to control them\r\n    mapping (uint256 => address) private wizardApprovals;\r\n\r\n    // Mapping from owner address to number of owned Wizards\r\n    mapping (address => uint256) internal ownedWizardsCount;\r\n\r\n    // Mapping from owner to Wizard controllers\r\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\r\n\r\n    /// @dev 0x80ac58cd ===\r\n    ///    bytes4(keccak256('balanceOf(address)')) ^\r\n    ///    bytes4(keccak256('ownerOf(uint256)')) ^\r\n    ///    bytes4(keccak256('approve(address,uint256)')) ^\r\n    ///    bytes4(keccak256('getApproved(uint256)')) ^\r\n    ///    bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n    ///    bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n    ///    bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n    ///    bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n    ///    bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceId The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///      uses less than 30,000 gas.\r\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\r\n        return\r\n            interfaceId == this.supportsInterface.selector || // ERC165\r\n            interfaceId == _INTERFACE_ID_ERC721; // ERC721\r\n    }\r\n\r\n    /// @notice Gets the number of Wizards owned by the specified address.\r\n    /// @param owner Address to query the balance of.\r\n    /// @return uint256 representing the amount of Wizards owned by the address.\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\r\n        return ownedWizardsCount[owner];\r\n    }\r\n\r\n    /// @notice Gets the owner of the specified Wizard\r\n    /// @param wizardId ID of the Wizard to query the owner of\r\n    /// @return address currently marked as the owner of the given Wizard\r\n    function ownerOf(uint256 wizardId) public view returns (address) {\r\n        address owner = wizardsById[wizardId].owner;\r\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\n        return owner;\r\n    }\r\n\r\n    /// @notice Approves another address to transfer the given Wizard\r\n    /// The zero address indicates there is no approved address.\r\n    /// There can only be one approved address per Wizard at a given time.\r\n    /// Can only be called by the Wizard owner or an approved operator.\r\n    /// @param to address to be approved for the given Wizard\r\n    /// @param wizardId ID of the Wizard to be approved\r\n    function approve(address to, uint256 wizardId) public {\r\n        address owner = ownerOf(wizardId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n        require(\r\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\r\n            \"ERC721: approve caller is not owner nor approved for all\"\r\n        );\r\n\r\n        wizardApprovals[wizardId] = to;\r\n        emit Approval(owner, to, wizardId);\r\n    }\r\n\r\n    /// @notice Gets the approved address for a Wizard, or zero if no address set\r\n    /// Reverts if the Wizard does not exist.\r\n    /// @param wizardId ID of the Wizard to query the approval of\r\n    /// @return address currently approved for the given Wizard\r\n    function getApproved(uint256 wizardId) public view returns (address) {\r\n        require(_exists(wizardId), \"ERC721: approved query for nonexistent token\");\r\n        return wizardApprovals[wizardId];\r\n    }\r\n\r\n    /// @notice Sets or unsets the approval of a given operator.\r\n    /// An operator is allowed to transfer all Wizards of the sender on their behalf.\r\n    /// @param to operator address to set the approval\r\n    /// @param approved representing the status of the approval to be set\r\n    function setApprovalForAll(address to, bool approved) public {\r\n        require(to != msg.sender, \"ERC721: approve to caller\");\r\n        _operatorApprovals[msg.sender][to] = approved;\r\n        emit ApprovalForAll(msg.sender, to, approved);\r\n    }\r\n\r\n    /// @notice Tells whether an operator is approved by a given owner.\r\n    /// @param owner owner address which you want to query the approval of\r\n    /// @param operator operator address which you want to query the approval of\r\n    /// @return bool whether the given operator is approved by the given owner\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /// @notice Transfers the ownership of a given Wizard to another address.\r\n    /// Usage of this method is discouraged, use `safeTransferFrom` whenever possible.\r\n    /// Requires the msg.sender to be the owner, approved, or operator.\r\n    /// @param from current owner of the Wizard.\r\n    /// @param to address to receive the ownership of the given Wizard.\r\n    /// @param wizardId ID of the Wizard to be transferred.\r\n    function transferFrom(address from, address to, uint256 wizardId) public {\r\n        require(_isApprovedOrOwner(msg.sender, wizardId), \"ERC721: transfer caller is not owner nor approved\");\r\n\r\n        _transferFrom(from, to, wizardId);\r\n    }\r\n\r\n    /// @notice Safely transfers the ownership of a given Wizard to another address\r\n    /// If the target address is a contract, it must implement `onERC721Received`,\r\n    /// which is called upon a safe transfer, and return the magic value\r\n    /// `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n    /// the transfer is reverted.\r\n    /// Requires the msg.sender to be the owner, approved, or operator.\r\n    /// @param from current owner of the Wizard.\r\n    /// @param to address to receive the ownership of the given Wizard.\r\n    /// @param wizardId ID of the Wizard to be transferred.\r\n    function safeTransferFrom(address from, address to, uint256 wizardId) public {\r\n        safeTransferFrom(from, to, wizardId, \"\");\r\n    }\r\n\r\n    /// @notice Safely transfers the ownership of a given Wizard to another address\r\n    /// If the target address is a contract, it must implement `onERC721Received`,\r\n    /// which is called upon a safe transfer, and return the magic value\r\n    /// `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n    /// the transfer is reverted.\r\n    /// Requires the msg.sender to be the owner, approved, or operator\r\n    /// @param from current owner of the Wizard.\r\n    /// @param to address to receive the ownership of the given Wizard.\r\n    /// @param wizardId ID of the Wizard to be transferred.\r\n    /// @param _data bytes data to send along with a safe transfer check\r\n    function safeTransferFrom(address from, address to, uint256 wizardId, bytes memory _data) public {\r\n        transferFrom(from, to, wizardId);\r\n        require(_checkOnERC721Received(from, to, wizardId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    /// @notice Returns whether the specified Wizard exists.\r\n    /// @param wizardId ID of the Wizard to query the existence of..\r\n    /// @return bool whether the Wizard exists.\r\n    function _exists(uint256 wizardId) internal view returns (bool) {\r\n        address owner = wizardsById[wizardId].owner;\r\n        return owner != address(0);\r\n    }\r\n\r\n    /// @notice Returns whether the given spender can transfer a given Wizard.\r\n    /// @param spender address of the spender to query\r\n    /// @param wizardId ID of the Wizard to be transferred\r\n    /// @return bool whether the msg.sender is approved for the given Wizard,\r\n    /// is an operator of the owner, or is the owner of the Wizard.\r\n    function _isApprovedOrOwner(address spender, uint256 wizardId) internal view returns (bool) {\r\n        require(_exists(wizardId), \"ERC721: operator query for nonexistent token\");\r\n        address owner = ownerOf(wizardId);\r\n        return (spender == owner || getApproved(wizardId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /** @dev Internal function to create a new Wizard; reverts if the Wizard ID is taken.\r\n     *       NOTE: This function heavily depends on the internal format of the Wizard struct\r\n     *       and should always be reassessed if anything about that structure changes.\r\n     *  @param wizardId ID of the new Wizard.\r\n     *  @param owner The address that will own the newly conjured Wizard.\r\n     *  @param innatePower The power level associated with the new Wizard.\r\n     *  @param affinity The elemental affinity of the new Wizard.\r\n     */\r\n    function _createWizard(uint256 wizardId, address owner, uint88 innatePower, uint8 affinity) internal {\r\n        require(owner != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(wizardId), \"ERC721: token already minted\");\r\n        require(wizardId > 0, \"No 0 token allowed\");\r\n        require(innatePower > 0, \"Wizard power must be non-zero\");\r\n\r\n        // Create the Wizard!\r\n        wizardsById[wizardId] = Wizard({\r\n            affinity: affinity,\r\n            innatePower: innatePower,\r\n            owner: owner,\r\n            metadata: 0\r\n        });\r\n\r\n        ownedWizardsCount[owner]++;\r\n\r\n        // Tell the world!\r\n        emit Transfer(address(0), owner, wizardId);\r\n        emit WizardConjured(wizardId, affinity, innatePower);\r\n    }\r\n\r\n    /// @notice Internal function to burn a specific Wizard.\r\n    /// Reverts if the Wizard does not exist.\r\n    /// Deprecated, use _burn(uint256) instead.\r\n    /// @param owner owner of the Wizard to burn.\r\n    /// @param wizardId ID of the Wizard being burned\r\n    function _burn(address owner, uint256 wizardId) internal {\r\n        require(ownerOf(wizardId) == owner, \"ERC721: burn of token that is not own\");\r\n\r\n        _clearApproval(wizardId);\r\n\r\n        ownedWizardsCount[owner]--;\r\n        // delete the entire object to recover the most gas\r\n        delete wizardsById[wizardId];\r\n\r\n        // required for ERC721 compatibility\r\n        emit Transfer(owner, address(0), wizardId);\r\n    }\r\n\r\n    /// @notice Internal function to burn a specific Wizard.\r\n    /// Reverts if the Wizard does not exist.\r\n    /// @param wizardId ID of the Wizard being burned\r\n    function _burn(uint256 wizardId) internal {\r\n        _burn(ownerOf(wizardId), wizardId);\r\n    }\r\n\r\n    /// @notice Internal function to transfer ownership of a given Wizard to another address.\r\n    /// As opposed to transferFrom, this imposes no restrictions on msg.sender.\r\n    /// @param from current owner of the Wizard.\r\n    /// @param to address to receive the ownership of the given Wizard\r\n    /// @param wizardId ID of the Wizard to be transferred\r\n    function _transferFrom(address from, address to, uint256 wizardId) internal {\r\n        require(ownerOf(wizardId) == from, \"ERC721: transfer of token that is not own\");\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _clearApproval(wizardId);\r\n\r\n        ownedWizardsCount[from]--;\r\n        ownedWizardsCount[to]++;\r\n\r\n        wizardsById[wizardId].owner = to;\r\n\r\n        emit Transfer(from, to, wizardId);\r\n    }\r\n\r\n    /// @notice Internal function to invoke `onERC721Received` on a target address.\r\n    /// The call is not executed if the target address is not a contract\r\n    /// @param from address representing the previous owner of the given Wizard\r\n    /// @param to target address that will receive the Wizards.\r\n    /// @param wizardId ID of the Wizard to be transferred\r\n    /// @param _data bytes optional data to send along with the call\r\n    /// @return bool whether the call correctly returned the expected magic value\r\n    function _checkOnERC721Received(address from, address to, uint256 wizardId, bytes memory _data)\r\n        internal returns (bool)\r\n    {\r\n        if (!isContract(to)) {\r\n            return true;\r\n        }\r\n\r\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, wizardId, _data);\r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n\r\n    /// @notice Private function to clear current approval of a given Wizard.\r\n    /// @param wizardId ID of the Wizard to be transferred\r\n    function _clearApproval(uint256 wizardId) private {\r\n        if (wizardApprovals[wizardId] != address(0)) {\r\n            wizardApprovals[wizardId] = address(0);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract WizardGuildInterfaceId {\r\n    bytes4 internal constant _INTERFACE_ID_WIZARDGUILD = 0x41d4d437;\r\n}\r\n\r\n/// @title The public interface of the Wizard Guild\r\n/// @notice The methods listed in this interface (including the inherited ERC-721 interface),\r\n///         make up the public interface of the Wizard Guild contract. Any contracts that wish\r\n///         to make use of Cheeze Wizard NFTs (such as Cheeze Wizards Tournaments!) should use\r\n///         these methods to ensure they are working correctly with the base NFTs.\r\ncontract WizardGuildInterface is IERC721, WizardGuildInterfaceId {\r\n\r\n    /// @notice Returns the information associated with the given Wizard\r\n    ///         owner - The address that owns this Wizard\r\n    ///         innatePower - The innate power level of this Wizard, set when minted and entirely\r\n    ///               immutable\r\n    ///         affinity - The Elemental Affinity of this Wizard. For most Wizards, this is set\r\n    ///               when they are minted, but some exclusive Wizards are minted with an affinity\r\n    ///               of 0 (ELEMENT_NOTSET). A Wizard with an NOTSET affinity should NOT be able\r\n    ///               to participate in Tournaments. Once the affinity of a Wizard is set to a non-zero\r\n    ///               value, it can never be changed again.\r\n    ///         metadata - A 256-bit hash of the Wizard's metadata, which is stored off chain. This\r\n    ///               contract doesn't specify format of this hash, nor the off-chain storage mechanism\r\n    ///               but, let's be honest, it's probably an IPFS SHA-256 hash.\r\n    ///\r\n    ///         NOTE: Series zero Wizards have one of four Affinities:  Neutral (1), Fire (2), Water (3)\r\n    ///               or Air (4, sometimes called \"Wind\" in the code). Future Wizard Series may have\r\n    ///               additional Affinities, and clients of this API should be prepared for that\r\n    ///               eventuality.\r\n    function getWizard(uint256 id) external view returns (address owner, uint88 innatePower, uint8 affinity, bytes32 metadata);\r\n\r\n    /// @notice Sets the affinity for a Wizard that doesn't already have its elemental affinity chosen.\r\n    ///         Only usable for Exclusive Wizards (all non-Exclusives must have their affinity chosen when\r\n    ///         conjured.) Even Exclusives can't change their affinity once it's been chosen.\r\n    ///\r\n    ///         NOTE: This function can only be called by the series minter, and (therefore) only while the\r\n    ///         series is open. A Wizard that has no affinity when a series is closed will NEVER have an Affinity.\r\n    ///         BTW- This implies that a minter is responsible for either never minting ELEMENT_NOTSET\r\n    ///         Wizards, or having some public mechanism for a Wizard owner to set the Affinity after minting.\r\n    /// @param wizardId The id of the wizard\r\n    /// @param newAffinity The new affinity of the wizard\r\n    function setAffinity(uint256 wizardId, uint8 newAffinity) external;\r\n\r\n    /// @notice A function to be called that conjures a whole bunch of Wizards at once! You know how\r\n    ///         there's \"a pride of lions\", \"a murder of crows\", and \"a parliament of owls\"? Well, with this\r\n    ///         here function you can conjure yourself \"a stench of Cheeze Wizards\"!\r\n    ///\r\n    ///         Unsurprisingly, this method can only be called by the registered minter for a Series.\r\n    /// @param powers the power level of each wizard\r\n    /// @param affinities the Elements of the wizards to create\r\n    /// @param owner the address that will own the newly created Wizards\r\n    function mintWizards(\r\n        uint88[] calldata powers,\r\n        uint8[] calldata affinities,\r\n        address owner\r\n        ) external returns (uint256[] memory wizardIds);\r\n\r\n    /// @notice A function to be called that conjures a series of Wizards in the reserved ID range.\r\n    /// @param wizardIds the ID values to use for each Wizard, must be in the reserved range of the current Series\r\n    /// @param affinities the Elements of the wizards to create\r\n    /// @param powers the power level of each wizard\r\n    /// @param owner the address that will own the newly created Wizards\r\n    function mintReservedWizards(\r\n        uint256[] calldata wizardIds,\r\n        uint88[] calldata powers,\r\n        uint8[] calldata affinities,\r\n        address owner\r\n        ) external;\r\n\r\n    /// @notice Sets the metadata values for a list of Wizards. The metadata for a Wizard can only be set once,\r\n    ///         can only be set by the COO or Minter, and can only be set while the Series is still open. Once\r\n    ///         a Series is closed, the metadata is locked forever!\r\n    /// @param wizardIds the ID values of the Wizards to apply metadata changes to.\r\n    /// @param metadata the raw metadata values for each Wizard. This contract does not define how metadata\r\n    ///         should be interpreted, but it is likely to be a 256-bit hash of a complete metadata package\r\n    ///         accessible via IPFS or similar.\r\n    function setMetadata(uint256[] calldata wizardIds, bytes32[] calldata metadata) external;\r\n\r\n    /// @notice Returns true if the given \"spender\" address is allowed to manipulate the given token\r\n    ///         (either because it is the owner of that token, has been given approval to manage that token)\r\n    function isApprovedOrOwner(address spender, uint256 tokenId) external view returns (bool);\r\n\r\n    /// @notice Verifies that a given signature represents authority to control the given Wizard ID,\r\n    ///         reverting otherwise. It handles three cases:\r\n    ///             - The simplest case: The signature was signed with the private key associated with\r\n    ///               an external address that is the owner of this Wizard.\r\n    ///             - The signature was generated with the private key associated with an external address\r\n    ///               that is \"approved\" for working with this Wizard ID. (See the Wizard Guild and/or\r\n    ///               the ERC-721 spec for more information on \"approval\".)\r\n    ///             - The owner or approval address (as in cases one or two) is a smart contract\r\n    ///               that conforms to ERC-1654, and accepts the given signature as being valid\r\n    ///               using its own internal logic.\r\n    ///\r\n    ///        NOTE: This function DOES NOT accept a signature created by an address that was given \"operator\r\n    ///               status\" (as granted by ERC-721's setApprovalForAll() functionality). Doing so is\r\n    ///               considered an extreme edge case that can be worked around where necessary.\r\n    /// @param wizardId The Wizard ID whose control is in question\r\n    /// @param hash The message hash we are authenticating against\r\n    /// @param sig the signature data; can be longer than 65 bytes for ERC-1654\r\n    function verifySignature(uint256 wizardId, bytes32 hash, bytes calldata sig) external view;\r\n\r\n    /// @notice Convenience function that verifies signatures for two wizards using equivalent logic to\r\n    ///         verifySignature(). Included to save on cross-contract calls in the common case where we\r\n    ///         are verifying the signatures of two Wizards who wish to enter into a Duel.\r\n    /// @param wizardId1 The first Wizard ID whose control is in question\r\n    /// @param wizardId2 The second Wizard ID whose control is in question\r\n    /// @param hash1 The message hash we are authenticating against for the first Wizard\r\n    /// @param hash2 The message hash we are authenticating against for the first Wizard\r\n    /// @param sig1 the signature data corresponding to the first Wizard; can be longer than 65 bytes for ERC-1654\r\n    /// @param sig2 the signature data corresponding to the second Wizard; can be longer than 65 bytes for ERC-1654\r\n    function verifySignatures(\r\n        uint256 wizardId1,\r\n        uint256 wizardId2,\r\n        bytes32 hash1,\r\n        bytes32 hash2,\r\n        bytes calldata sig1,\r\n        bytes calldata sig2) external view;\r\n}\r\n\r\n\r\n\r\n/// @title Contract that manages addresses and access modifiers for certain operations.\r\n/// @author Dapper Labs Inc. (https://www.dapperlabs.com)\r\ncontract AccessControl {\r\n\r\n    /// @dev The address of the master administrator account that has the power to\r\n    ///      update itself and all of the other administrator addresses.\r\n    ///      The CEO account is not expected to be used regularly, and is intended to\r\n    ///      be stored offline (i.e. a hardware device kept in a safe).\r\n    address public ceoAddress;\r\n\r\n    /// @dev The address of the \"day-to-day\" operator of various privileged\r\n    ///      functions inside the smart contract. Although the CEO has the power\r\n    ///      to replace the COO, the CEO address doesn't actually have the power\r\n    ///      to do \"COO-only\" operations. This is to discourage the regular use\r\n    ///      of the CEO account.\r\n    address public cooAddress;\r\n\r\n    /// @dev The address that is allowed to move money around. Kept separate from\r\n    ///      the COO because the COO address typically lives on an internet-connected\r\n    ///      computer.\r\n    address payable public cfoAddress;\r\n\r\n    // Events to indicate when access control role addresses are updated.\r\n    event CEOTransferred(address previousCeo, address newCeo);\r\n    event COOTransferred(address previousCoo, address newCoo);\r\n    event CFOTransferred(address previousCfo, address newCfo);\r\n\r\n    /// @dev The AccessControl constructor sets the `ceoAddress` to the sender account. Also\r\n    ///      initializes the COO and CFO to the passed values (CFO is optional and can be address(0)).\r\n    /// @param newCooAddress The initial COO address to set\r\n    /// @param newCfoAddress The initial CFO to set (optional)\r\n    constructor(address newCooAddress, address payable newCfoAddress) public {\r\n        _setCeo(msg.sender);\r\n        setCoo(newCooAddress);\r\n\r\n        if (newCfoAddress != address(0)) {\r\n            setCfo(newCfoAddress);\r\n        }\r\n    }\r\n\r\n    /// @notice Access modifier for CEO-only functionality\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress, \"Only CEO\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Access modifier for COO-only functionality\r\n    modifier onlyCOO() {\r\n        require(msg.sender == cooAddress, \"Only COO\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Access modifier for CFO-only functionality\r\n    modifier onlyCFO() {\r\n        require(msg.sender == cfoAddress, \"Only CFO\");\r\n        _;\r\n    }\r\n\r\n    function checkControlAddress(address newController) internal view {\r\n        require(newController != address(0) && newController != ceoAddress, \"Invalid CEO address\");\r\n    }\r\n\r\n    /// @notice Assigns a new address to act as the CEO. Only available to the current CEO.\r\n    /// @param newCeo The address of the new CEO\r\n    function setCeo(address newCeo) external onlyCEO {\r\n        checkControlAddress(newCeo);\r\n        _setCeo(newCeo);\r\n    }\r\n\r\n    /// @dev An internal utility function that updates the CEO variable and emits the\r\n    ///      transfer event. Used from both the public setCeo function and the constructor.\r\n    function _setCeo(address newCeo) private {\r\n        emit CEOTransferred(ceoAddress, newCeo);\r\n        ceoAddress = newCeo;\r\n    }\r\n\r\n    /// @notice Assigns a new address to act as the COO. Only available to the current CEO.\r\n    /// @param newCoo The address of the new COO\r\n    function setCoo(address newCoo) public onlyCEO {\r\n        checkControlAddress(newCoo);\r\n        emit COOTransferred(cooAddress, newCoo);\r\n        cooAddress = newCoo;\r\n    }\r\n\r\n    /// @notice Assigns a new address to act as the CFO. Only available to the current CEO.\r\n    /// @param newCfo The address of the new CFO\r\n    function setCfo(address payable newCfo) public onlyCEO {\r\n        checkControlAddress(newCfo);\r\n        emit CFOTransferred(cfoAddress, newCfo);\r\n        cfoAddress = newCfo;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/// @title Signature utility library\r\nlibrary SigTools {\r\n\r\n    /// @notice Splits a signature into r & s values, and v (the verification value).\r\n    /// @dev Note: This does not verify the version, but does require signature length = 65\r\n    /// @param signature the packed signature to be split\r\n    function _splitSignature(bytes memory signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\r\n        // Check signature length\r\n        require(signature.length == 65, \"Invalid signature length\");\r\n\r\n        // We need to unpack the signature, which is given as an array of 65 bytes (like eth.sign)\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 32))\r\n            s := mload(add(signature, 64))\r\n            v := and(mload(add(signature, 65)), 255)\r\n        }\r\n\r\n        if (v < 27) {\r\n            v += 27; // Ethereum versions are 27 or 28 as opposed to 0 or 1 which is submitted by some signing libs\r\n        }\r\n\r\n        // check for valid version\r\n        // removed for now, done in another function\r\n        //require((v == 27 || v == 28), \"Invalid signature version\");\r\n\r\n        return (r, s, v);\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract ERC1654 {\r\n\r\n    /// @dev bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\r\n    bytes4 public constant ERC1654_VALIDSIGNATURE = 0x1626ba7e;\r\n\r\n    /// @dev Should return whether the signature provided is valid for the provided data\r\n    /// @param hash 32-byte hash of the data that is signed\r\n    /// @param _signature Signature byte array associated with _data\r\n    ///  MUST return the bytes4 magic value 0x1626ba7e when function passes.\r\n    ///  MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\r\n    ///  MUST allow external calls\r\n    function isValidSignature(\r\n        bytes32 hash,\r\n        bytes calldata _signature)\r\n        external\r\n        view\r\n        returns (bytes4);\r\n}\r\n\r\n\r\n\r\n/// @title The master organization behind all Cheeze Wizardry. The source of all them Wiz.\r\ncontract WizardGuild is AccessControl, WizardNFT, WizardGuildInterface, ERC165Query {\r\n\r\n    /// @notice Emitted when a new Series is opened or closed.\r\n    event SeriesOpen(uint64 seriesIndex, uint256 reservedIds);\r\n    event SeriesClose(uint64 seriesIndex);\r\n\r\n    /// @notice Emitted when metadata is associated with a Wizard\r\n    event MetadataSet(uint256 indexed wizardId, bytes32 metadata);\r\n\r\n    /// @notice The index of the current Series (zero-based). When no Series is open, this value\r\n    ///         indicates the index of the _upcoming_ Series. (i.e. it is incremented when the\r\n    ///         Series is closed. This makes it easier to bootstrap the first Series.)\r\n    uint64 internal seriesIndex;\r\n\r\n    /// @notice The address which is allowed to mint new Wizards in the current Series. When this\r\n    ///         is set to address(0), there is no open Series.\r\n    address internal seriesMinter;\r\n\r\n    /// @notice The index number of the next Wizard to be created (Neutral or Elemental).\r\n    ///         NOTE: There is a subtle distinction between a Wizard \"ID\" and a Wizard \"index\".\r\n    ///               We use the term \"ID\" to refer to a value that includes the Series number in the\r\n    ///               top 64 bits, while the term \"index\" refers to the Wizard number _within_ its\r\n    ///               Series. This is especially confusing when talking about Wizards in the first\r\n    ///               Series (Series 0), because the two values are identical in that case!\r\n    ///\r\n    ///               |---------------|--------------------------|\r\n    ///               |           Wizard ID (256 bits)           |\r\n    ///               |---------------|--------------------------|\r\n    ///               |  Series Index |      Wizard Index        |\r\n    ///               |   (64 bits)   |       (192 bits)         |\r\n    ///               |---------------|--------------------------|\r\n    uint256 internal nextWizardIndex;\r\n\r\n    function getNextWizardIndex() external view returns (uint256) {\r\n        return nextWizardIndex;\r\n    }\r\n\r\n    // NOTE: uint256(-1) maps to a value with all bits set, both the << and >> operators will fill\r\n    // in with zeros when acting on an unsigned value. So, \"uint256(-1) << 192\" resolves to \"a bunch\r\n    /// of ones, followed by 192 zeros\"\r\n    uint256 internal constant SERIES_OFFSET = 192;\r\n    uint256 internal constant SERIES_MASK = uint256(-1) << SERIES_OFFSET;\r\n    uint256 internal constant INDEX_MASK = uint256(-1) >> 64;\r\n\r\n    // The ERC1654 function selector value\r\n    bytes4 internal constant ERC1654_VALIDSIGNATURE = 0x1626ba7e;\r\n\r\n    /// @notice The Guild constructor.\r\n    /// @param _cooAddress The COO has the ability to create new Series and to update\r\n    ///         the metadata on the currently open Series (if any). It has no other special\r\n    ///         abilities, and (in particular), ALL Wizards in a closed series can never be\r\n    ///         modified or deleted. If the CEO and COO values are ever set to invalid addresses\r\n    ///        (such as address(1)), then no new Series can ever be created, either.\r\n    constructor(address _cooAddress) public AccessControl(_cooAddress, address(0)) {\r\n    }\r\n\r\n    /// @notice Require that a Tournament Series is currently open. For example closing\r\n    ///         a Series does not make sense if none is open.\r\n    /// @dev While in other contracts we use separate checking functions to avoid having the same\r\n    ///      string inlined in multiple places, given this modifier is scarcely used it doesn't seem\r\n    ///      worth the per-call gas cost here.\r\n    modifier duringSeries() {\r\n        require(seriesMinter != address(0), \"No series is currently open\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Require that the caller is the minter of the current series. This implicitely\r\n    ///         requires that a Series is open, or the minter address would be invalid (can never\r\n    ///         be matched).\r\n    /// @dev While in other contracts we use separate checking functions to avoid having the same\r\n    ///      string inlined in multiple places, given this modifier is scarcely used it doesn't seem\r\n    ///      worth the per-call gas cost here.\r\n    modifier onlyMinter() {\r\n        require(msg.sender == seriesMinter, \"Only callable by minter\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Open a new Series of Cheeze Wizards! Can only be called by the COO when no Series is open.\r\n    /// @param minter The address which is allowed to mint Wizards in this series. This contract does not\r\n    ///         assume that the minter is a smart contract, but it will presumably be in the vast majority\r\n    ///         of the cases. A minter has absolute control over the creation of new Wizards in an open\r\n    ///         Series, but CAN NOT manipulate a Series after it has been closed, and CAN NOT manipulate\r\n    ///         any Wizards that don't belong to its own Series. (Even if the same minting address is used\r\n    ///         for multiple Series, the Minter only has power over the currently open Series.)\r\n    /// @param reservedIds The number of IDs (from 1 to reservedIds, inclusive) that are reserved for minting\r\n    ///         reserved Wizards. (We use the term \"reserved\" here, instead of Exclusive, because there\r\n    ///         are times -- such as during the importation of the Presale -- when we need to reserve a\r\n    ///         block of IDs for Wizards that aren't what a user would think of as \"exclusive\". In Series\r\n    ///         0, the reserved IDs will include all Exclusive Wizards and Presale Wizards. In other Series\r\n    ///         it might also be the case that the set of \"reserved IDs\" doesn't exactly match the set of\r\n    ///         \"exclusive\" IDs.)\r\n    function openSeries(address minter, uint256 reservedIds) external onlyCOO returns (uint64 seriesId) {\r\n        require(seriesMinter == address(0), \"A series is already open\");\r\n        require(minter != address(0), \"Minter address cannot be 0\");\r\n\r\n        if (seriesIndex == 0) {\r\n            // The Presale contract has stopped sales.\r\n            // The ID of the last wizard sold in the Presale contract is 5974.\r\n            // So the reservedIds for the first series is hardcoded with that ID in order to ensure:\r\n            // 1) The next Wizard minted will have its ID continued from the last Presale Wizard.\r\n            // 2) All the Presale wizards can be minted in this contract with their IDs reserved.\r\n            require(reservedIds == 5974, \"Invalid reservedIds for 1st series\");\r\n        } else {\r\n            require(reservedIds < 1 << 192, \"Invalid reservedIds\");\r\n        }\r\n\r\n        // NOTE: The seriesIndex is updated when the Series is _closed_, not when it's opened.\r\n        //  (The first Series is Series #0.) So in this function, we just leave the seriesIndex alone.\r\n\r\n        seriesMinter = minter;\r\n        nextWizardIndex = reservedIds + 1;\r\n\r\n        emit SeriesOpen(seriesIndex, reservedIds);\r\n\r\n        return seriesIndex;\r\n    }\r\n\r\n    /// @notice Closes the current Wizard Series. Once a Series has been closed, it is forever sealed and\r\n    ///         no more Wizards in that Series can ever be minted! Can only be called by the COO when a Series\r\n    ///         is open.\r\n    ///\r\n    ///    NOTE: A series can be closed by the COO or the Minter. (It's assumed that some minters will\r\n    ///          know when they are done, and others will need to be shut off manually by the COO.)\r\n    function closeSeries() external duringSeries {\r\n        require(\r\n            msg.sender == seriesMinter || msg.sender == cooAddress,\r\n            \"Only Minter or COO can close a Series\");\r\n\r\n        seriesMinter = address(0);\r\n        emit SeriesClose(seriesIndex);\r\n\r\n        // Set up the next series.\r\n        seriesIndex += 1;\r\n        nextWizardIndex = 0;\r\n    }\r\n\r\n    /// @notice ERC-165 Query Function.\r\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\r\n        return interfaceId == _INTERFACE_ID_WIZARDGUILD || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /// @notice Returns the information associated with the given Wizard\r\n    ///         owner - The address that owns this Wizard\r\n    ///         innatePower - The innate power level of this Wizard, set when minted and entirely\r\n    ///               immutable\r\n    ///         affinity - The Elemental Affinity of this Wizard. For most Wizards, this is set\r\n    ///               when they are minted, but some exclusive Wizards are minted with an affinity\r\n    ///               of 0 (ELEMENT_NOTSET). A Wizard with an NOTSET affinity should NOT be able\r\n    ///               to participate in Tournaments. Once the affinity of a Wizard is set to a non-zero\r\n    ///               value, it can never be changed again.\r\n    ///         metadata - A 256-bit hash of the Wizard's metadata, which is stored off chain. This\r\n    ///               contract doesn't specify format of this hash, nor the off-chain storage mechanism\r\n    ///               but, let's be honest, it's probably an IPFS SHA-256 hash.\r\n    ///\r\n    ///         NOTE: Series zero Wizards have one of four Affinities:  Neutral (1), Fire (2), Water (3)\r\n    ///               or Air (4, sometimes called \"Wind\" in the code). Future Wizard Series may have\r\n    ///               additional Affinities, and clients of this API should be prepared for that\r\n    ///               eventuality.\r\n    function getWizard(uint256 id) public view returns (address owner, uint88 innatePower, uint8 affinity, bytes32 metadata) {\r\n        Wizard memory wizard = wizardsById[id];\r\n        require(wizard.owner != address(0), \"Wizard does not exist\");\r\n        (owner, innatePower, affinity, metadata) = (wizard.owner, wizard.innatePower, wizard.affinity, wizard.metadata);\r\n    }\r\n\r\n    /// @notice A function to be called that conjures a whole bunch of Wizards at once! You know how\r\n    ///         there's \"a pride of lions\", \"a murder of crows\", and \"a parliament of owls\"? Well, with this\r\n    ///         here function you can conjure yourself \"a stench of Cheeze Wizards\"!\r\n    ///\r\n    ///         Unsurprisingly, this method can only be called by the registered minter for a Series.\r\n    /// @dev This function DOES NOT CALL onERC721Received() as required by the ERC-721 standard. It is\r\n    ///         REQUIRED that the Minter calls onERC721Received() after calling this function. The following\r\n    ///         code snippet should suffice:\r\n    ///                 // Ensure the Wizard is being assigned to an ERC-721 aware address (either an external address,\r\n    ///                 // or a smart contract that implements onERC721Received()). We must call onERC721Received for\r\n    ///                 // each token created because it's allowed for an ERC-721 receiving contract to reject the\r\n    ///                 // transfer based on the properties of the token.\r\n    ///                 if (isContract(owner)) {\r\n    ///                     for (uint256 i = 0; i < wizardIds.length; i++) {\r\n    ///                         bytes4 retval = IERC721Receiver(owner).onERC721Received(owner, address(0), wizardIds[i], \"\");\r\n    ///                         require(retval == _ERC721_RECEIVED, \"Contract owner didn't accept ERC721 transfer\");\r\n    ///                     }\r\n    ///                 }\r\n    ///        Although it would be convenient for mintWizards to call onERC721Received, it opens us up to potential\r\n    ///        reentrancy attacks if the Minter needs to do more state updates after mintWizards() returns.\r\n    /// @param powers the power level of each wizard\r\n    /// @param affinities the Elements of the wizards to create\r\n    /// @param owner the address that will own the newly created Wizards\r\n    function mintWizards(\r\n        uint88[] calldata powers,\r\n        uint8[] calldata affinities,\r\n        address owner\r\n    ) external onlyMinter returns (uint256[] memory wizardIds)\r\n    {\r\n        require(affinities.length == powers.length, \"Inconsistent parameter lengths\");\r\n\r\n        // allocate result array\r\n        wizardIds = new uint256[](affinities.length);\r\n\r\n        // We take this storage variables, and turn it into a local variable for the course\r\n        // of this loop to save about 5k gas per wizard.\r\n        uint256 tempWizardId = (uint256(seriesIndex) << SERIES_OFFSET) + nextWizardIndex;\r\n\r\n        for (uint256 i = 0; i < affinities.length; i++) {\r\n            wizardIds[i] = tempWizardId;\r\n            tempWizardId++;\r\n\r\n            _createWizard(wizardIds[i], owner, powers[i], affinities[i]);\r\n        }\r\n\r\n        nextWizardIndex = tempWizardId & INDEX_MASK;\r\n    }\r\n\r\n    /// @notice A function to be called that mints a Series of Wizards in the reserved ID range, can only\r\n    ///         be called by the Minter for this Series.\r\n    /// @dev This function DOES NOT CALL onERC721Received() as required by the ERC-721 standard. It is\r\n    ///         REQUIRED that the Minter calls onERC721Received() after calling this function. See the note\r\n    ///         above on mintWizards() for more info.\r\n    /// @param wizardIds the ID values to use for each Wizard, must be in the reserved range of the current Series.\r\n    /// @param powers the power level of each Wizard.\r\n    /// @param affinities the Elements of the Wizards to create.\r\n    /// @param owner the address that will own the newly created Wizards.\r\n    function mintReservedWizards(\r\n        uint256[] calldata wizardIds,\r\n        uint88[] calldata powers,\r\n        uint8[] calldata affinities,\r\n        address owner\r\n    )\r\n    external onlyMinter\r\n    {\r\n        require(\r\n            wizardIds.length == affinities.length &&\r\n            wizardIds.length == powers.length, \"Inconsistent parameter lengths\");\r\n\r\n        for (uint256 i = 0; i < wizardIds.length; i++) {\r\n            uint256 currentId = wizardIds[i];\r\n\r\n            require((currentId & SERIES_MASK) == (uint256(seriesIndex) << SERIES_OFFSET), \"Wizards not in current series\");\r\n            require((currentId & INDEX_MASK) > 0, \"Wizards id cannot be zero\");\r\n\r\n            // Ideally, we would compare the requested Wizard index against the reserved range directly. However,\r\n            // it's a bit wasteful to spend storage on a reserved range variable when we can combine some known\r\n            // true facts instead:\r\n            //         - nextWizardIndex is initialized to reservedRange + 1 when the Series was opened\r\n            //         - nextWizardIndex is only incremented when a new Wizard is created\r\n            //         - therefore, the only empty Wizard IDs less than nextWizardIndex are in the reserved range.\r\n            //         - _conjureWizard() will abort if we try to reuse an ID.\r\n            // Combining all of the above, we know that, if the requested index is less than the next index, it\r\n            // either points to a reserved slot or an occupied slot. Trying to reuse an occupied slot will fail,\r\n            // so just checking against nextWizardIndex is sufficient to ensure we're pointing at a reserved slot.\r\n            require((currentId & INDEX_MASK) < nextWizardIndex, \"Wizards not in reserved range\");\r\n\r\n            _createWizard(currentId, owner, powers[i], affinities[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice Sets the metadata values for a list of Wizards. The metadata for a Wizard can only be set once,\r\n    ///         can only be set by the COO or Minter, and can only be set while the Series is still open. Once\r\n    ///         a Series is closed, the metadata is locked forever!\r\n    /// @param wizardIds the ID values of the Wizards to apply metadata changes to.\r\n    /// @param metadata the raw metadata values for each Wizard. This contract does not define how metadata\r\n    ///         should be interpreted, but it is likely to be a 256-bit hash of a complete metadata package\r\n    ///         accessible via IPFS or similar.\r\n    function setMetadata(uint256[] calldata wizardIds, bytes32[] calldata metadata) external duringSeries {\r\n        require(msg.sender == seriesMinter || msg.sender == cooAddress, \"Only Minter or COO can set metadata\");\r\n        require(wizardIds.length == metadata.length, \"Inconsistent parameter lengths\");\r\n\r\n        for (uint256 i = 0; i < wizardIds.length; i++) {\r\n            uint256 currentId = wizardIds[i];\r\n            bytes32 currentMetadata = metadata[i];\r\n\r\n            require((currentId & SERIES_MASK) == (uint256(seriesIndex) << SERIES_OFFSET), \"Wizards not in current series\");\r\n\r\n            require(wizardsById[currentId].metadata == bytes32(0), \"Metadata already set\");\r\n\r\n            require(currentMetadata != bytes32(0), \"Invalid metadata\");\r\n\r\n            wizardsById[currentId].metadata = currentMetadata;\r\n\r\n            emit MetadataSet(currentId, currentMetadata);\r\n        }\r\n    }\r\n\r\n    /// @notice Sets the affinity for a Wizard that doesn't already have its elemental affinity chosen.\r\n    ///         Only usable for Exclusive Wizards (all non-Exclusives must have their affinity chosen when\r\n    ///         conjured.) Even Exclusives can't change their affinity once it's been chosen.\r\n    ///\r\n    ///         NOTE: This function can only be called by the Series minter, and (therefore) only while the\r\n    ///         Series is open. A Wizard that has no affinity when a Series is closed will NEVER have an Affinity.\r\n    /// @param wizardId The ID of the Wizard to update affinity of.\r\n    /// @param newAffinity The new affinity of the Wizard.\r\n    function setAffinity(uint256 wizardId, uint8 newAffinity) external onlyMinter {\r\n        require((wizardId & SERIES_MASK) == (uint256(seriesIndex) << SERIES_OFFSET), \"Wizard not in current series\");\r\n\r\n        Wizard storage wizard = wizardsById[wizardId];\r\n\r\n        require(wizard.affinity == ELEMENT_NOTSET, \"Affinity can only be chosen once\");\r\n\r\n        // set the affinity\r\n        wizard.affinity = newAffinity;\r\n\r\n        // Tell the world this wizards now has an affinity!\r\n        emit WizardAffinityAssigned(wizardId, newAffinity);\r\n    }\r\n\r\n    /// @notice Returns true if the given \"spender\" address is allowed to manipulate the given token\r\n    ///         (either because it is the owner of that token, has been given approval to manage that token)\r\n    function isApprovedOrOwner(address spender, uint256 tokenId) external view returns (bool) {\r\n        return _isApprovedOrOwner(spender, tokenId);\r\n    }\r\n\r\n    /// @notice Verifies that a given signature represents authority to control the given Wizard ID,\r\n    ///         reverting otherwise. It handles three cases:\r\n    ///             - The simplest case: The signature was signed with the private key associated with\r\n    ///               an external address that is the owner of this Wizard.\r\n    ///             - The signature was generated with the private key associated with an external address\r\n    ///               that is \"approved\" for working with this Wizard ID. (See the Wizard Guild and/or\r\n    ///               the ERC-721 spec for more information on \"approval\".)\r\n    ///             - The owner or approval address (as in cases one or two) is a smart contract\r\n    ///               that conforms to ERC-1654, and accepts the given signature as being valid\r\n    ///               using its own internal logic.\r\n    ///\r\n    ///        NOTE: This function DOES NOT accept a signature created by an address that was given \"operator\r\n    ///               status\" (as granted by ERC-721's setApprovalForAll() functionality). Doing so is\r\n    ///               considered an extreme edge case that can be worked around where necessary.\r\n    /// @param wizardId The Wizard ID whose control is in question\r\n    /// @param hash The message hash we are authenticating against\r\n    /// @param sig the signature data; can be longer than 65 bytes for ERC-1654\r\n    function verifySignature(uint256 wizardId, bytes32 hash, bytes memory sig) public view {\r\n        // First see if the signature belongs to the owner (the most common case)\r\n        address owner = ownerOf(wizardId);\r\n\r\n        if (_validSignatureForAddress(owner, hash, sig)) {\r\n            return;\r\n        }\r\n\r\n        // Next check if the signature belongs to the approved address\r\n        address approved = getApproved(wizardId);\r\n\r\n        if (_validSignatureForAddress(approved, hash, sig)) {\r\n            return;\r\n        }\r\n\r\n        revert(\"Invalid signature\");\r\n    }\r\n\r\n    /// @notice Convenience function that verifies signatures for two wizards using equivalent logic to\r\n    ///         verifySignature(). Included to save on cross-contract calls in the common case where we\r\n    ///         are verifying the signatures of two Wizards who wish to enter into a Duel.\r\n    /// @param wizardId1 The first Wizard ID whose control is in question\r\n    /// @param wizardId2 The second Wizard ID whose control is in question\r\n    /// @param hash1 The message hash we are authenticating against for the first Wizard\r\n    /// @param hash2 The message hash we are authenticating against for the first Wizard\r\n    /// @param sig1 the signature data corresponding to the first Wizard; can be longer than 65 bytes for ERC-1654\r\n    /// @param sig2 the signature data corresponding to the second Wizard; can be longer than 65 bytes for ERC-1654\r\n    function verifySignatures(\r\n        uint256 wizardId1,\r\n        uint256 wizardId2,\r\n        bytes32 hash1,\r\n        bytes32 hash2,\r\n        bytes calldata sig1,\r\n        bytes calldata sig2) external view\r\n    {\r\n        verifySignature(wizardId1, hash1, sig1);\r\n        verifySignature(wizardId2, hash2, sig2);\r\n    }\r\n\r\n    /// @notice An internal function that checks if a given signature is a valid signature for a\r\n    ///         specific address on a particular hash value. Checks for ERC-1654 compatibility\r\n    ///         first (where the possibleSigner is a smart contract that implements its own\r\n    ///         signature validation), and falls back to ecrecover() otherwise.\r\n    function _validSignatureForAddress(address possibleSigner, bytes32 hash, bytes memory signature)\r\n        internal view returns(bool)\r\n    {\r\n        if (possibleSigner == address(0)) {\r\n            // The most basic Bozo check: The zero address can never be a valid signer!\r\n            return false;\r\n        } else if (Address.isContract(possibleSigner)) {\r\n            // If the address is a contract, it either implements ERC-1654 (and will validate the signature\r\n            // itself), or we have no way of confirming that this signature matches this address. In other words,\r\n            // if this address is a contract, there's no point in \"falling back\" to ecrecover().\r\n            if (doesContractImplementInterface(possibleSigner, ERC1654_VALIDSIGNATURE)) {\r\n                // cast to ERC1654\r\n                ERC1654 tso = ERC1654(possibleSigner);\r\n                bytes4 result = tso.isValidSignature(keccak256(abi.encodePacked(hash)), signature);\r\n                if (result == ERC1654_VALIDSIGNATURE) {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        } else {\r\n            // Not a contract, check for a match against an external address\r\n            // assume EIP 191 signature here\r\n            (bytes32 r, bytes32 s, uint8 v) = SigTools._splitSignature(signature);\r\n            address signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)), v, r, s);\r\n\r\n            // Note: Signer could be address(0) here, but we already checked that possibleSigner isn't zero\r\n            return (signer == possibleSigner);\r\n        }\r\n    }\r\n\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wizardId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"wizardId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"wizardId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wizardIds\",\"type\":\"uint256[]\"},{\"name\":\"metadata\",\"type\":\"bytes32[]\"}],\"name\":\"setMetadata\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCfo\",\"type\":\"address\"}],\"name\":\"setCfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wizardId\",\"type\":\"uint256\"},{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"verifySignature\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeSeries\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"wizardId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isApprovedOrOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minter\",\"type\":\"address\"},{\"name\":\"reservedIds\",\"type\":\"uint256\"}],\"name\":\"openSeries\",\"outputs\":[{\"name\":\"seriesId\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"powers\",\"type\":\"uint88[]\"},{\"name\":\"affinities\",\"type\":\"uint8[]\"},{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"mintWizards\",\"outputs\":[{\"name\":\"wizardIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"wizardsById\",\"outputs\":[{\"name\":\"affinity\",\"type\":\"uint8\"},{\"name\":\"innatePower\",\"type\":\"uint88\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"metadata\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wizardId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCeo\",\"type\":\"address\"}],\"name\":\"setCeo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wizardId\",\"type\":\"uint256\"},{\"name\":\"newAffinity\",\"type\":\"uint8\"}],\"name\":\"setAffinity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCoo\",\"type\":\"address\"}],\"name\":\"setCoo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wizardIds\",\"type\":\"uint256[]\"},{\"name\":\"powers\",\"type\":\"uint88[]\"},{\"name\":\"affinities\",\"type\":\"uint8[]\"},{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"mintReservedWizards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wizardId1\",\"type\":\"uint256\"},{\"name\":\"wizardId2\",\"type\":\"uint256\"},{\"name\":\"hash1\",\"type\":\"bytes32\"},{\"name\":\"hash2\",\"type\":\"bytes32\"},{\"name\":\"sig1\",\"type\":\"bytes\"},{\"name\":\"sig2\",\"type\":\"bytes\"}],\"name\":\"verifySignatures\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"wizardId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNextWizardIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getWizard\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"innatePower\",\"type\":\"uint88\"},{\"name\":\"affinity\",\"type\":\"uint8\"},{\"name\":\"metadata\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_cooAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"seriesIndex\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"reservedIds\",\"type\":\"uint256\"}],\"name\":\"SeriesOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"seriesIndex\",\"type\":\"uint64\"}],\"name\":\"SeriesClose\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"wizardId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"metadata\",\"type\":\"bytes32\"}],\"name\":\"MetadataSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wizardId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affinity\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"innatePower\",\"type\":\"uint256\"}],\"name\":\"WizardConjured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wizardId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affinity\",\"type\":\"uint8\"}],\"name\":\"WizardAffinityAssigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousCeo\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newCeo\",\"type\":\"address\"}],\"name\":\"CEOTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousCoo\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newCoo\",\"type\":\"address\"}],\"name\":\"COOTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousCfo\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newCfo\",\"type\":\"address\"}],\"name\":\"CFOTransferred\",\"type\":\"event\"}]", "ContractName": "WizardGuild", "CompilerVersion": "v0.5.8+commit.23d335f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d880d895ce716afc1e5e21cb901b5093701842e4", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://b138407e82d760238b182eaea80221baebef2742874f4aef9ca4f40d4f9fefd7"}